- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Animating UI Elements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化 UI 元素
- en: Since we have already discussed how to create animation transitions for buttons,
    in this chapter, we’ll take a look at animation transitions more thoroughly and
    discuss how to create animations for UI elements in a more general sense.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讨论了如何为按钮创建动画过渡，因此在本章中，我们将更深入地探讨动画过渡，并讨论如何更普遍地创建 UI 元素的动画。
- en: This chapter assumes that you have a basic understanding of Unity’s Animation
    System and will not go into detail describing the names of the various menus and
    layout of the Animation Window and Animator Window. Animation Clips and Animators
    will be described briefly, with a focus on how they relate to UI and their implementation,
    which will be discussed in the examples at the end of the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你对 Unity 的动画系统有基本的了解，并且不会详细描述各种菜单的名称和动画窗口、动画控制器窗口的布局。动画片段和动画控制器将简要介绍，重点介绍它们与
    UI 的关系及其实现，这些将在本章末尾的示例中进行讨论。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Applying animations to the various UI elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动画应用于各种 UI 元素
- en: Creating a pop-up window that fades in and out
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建淡入淡出的弹出窗口
- en: Creating a complex Animation System with a State Machine and Animation Events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态机和动画事件创建复杂的动画系统
- en: Even though I am assuming that you have a basic understanding of Unity’s Animation
    System, I do want to emphasize the difference between an Animation Clip and the
    Animator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我假设你对 Unity 的动画系统有基本的了解，但我确实想强调动画片段和动画控制器之间的区别。
- en: When creating animations for items in Unity, you start with **Animation Clips**.
    An Animation Clip should represent a single distinct action or motion. So, for
    example, if you had a menu that performed two separate actions, bouncing and zooming,
    you’d make each of those actions a separate Animation Clip. Although you can have
    multiple things happen in a single Animation Clip, it is very important not to
    put multiple actions in a single clip unless they are always going to happen at
    the same time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Unity 中为项目中的项目创建动画时，你从**动画片段**开始。一个动画片段应该代表一个单一的动作或运动。例如，如果你有一个执行两个独立动作的菜单，弹跳和缩放，你会为每个动作创建一个单独的动画片段。虽然你可以在单个动画片段中包含多个事件，但除非它们总是同时发生，否则非常重要不要将多个动作放入一个片段中。
- en: Every GameObject can have multiple Animation Clips. The **Animator** determines
    how all of these Animations link together. So, a GameObject’s Animator will have
    all of its Animation Clips within it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏对象都可以拥有多个动画片段。**动画控制器**决定了所有这些动画如何链接在一起。因此，一个游戏对象的动画控制器将包含其所有的动画片段。
- en: I wanted to make this distinction because in the past, I have seen projects
    with epic Animation Clips containing multiple actions that should have been broken
    down into more simple motions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要区分这一点，因为在过去，我见过一些包含多个动作的史诗级动画片段的项目，这些动作本应该被分解成更简单的动作。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As with previous chapters, all of the examples shown in this section can be
    found within the Unity project provided in the code bundle. They can be found
    within the scene labeled **Chapter14**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，本节中展示的所有示例都可以在提供的代码包中的 Unity 项目中找到。它们可以在标记为**第14章**的场景中找到。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2014](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2014)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2014](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2014)
- en: Animation Clips
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画片段
- en: 'The great thing about the Unity Animation System is that you can animate nearly
    any property of the UI. To create an Animation Clip, simply open the Animation
    Window (**Window** | **Animation** or *Ctrl* + *6*), and with the UI element you
    want to animate selected, select **Create**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 动画系统的优点在于你可以动画化 UI 的几乎所有属性。要创建动画片段，只需打开动画窗口（**窗口** | **动画** 或 *Ctrl* +
    *6*），然后选择要动画化的 UI 元素，然后选择**创建**：
- en: '![Figure 14.1: The Animation Window](img/Figure_14.01_B18327.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1：动画窗口](img/Figure_14.01_B18327.jpg)'
- en: 'Figure 14.1: The Animation Window'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：动画窗口
- en: Once you do so, you’ll be prompted to save the Animation Clip.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这样做，系统会提示你保存动画片段。
- en: 'After creating the Animation Clip, you can then add any property to the clip’s
    timeline by clicking on **Add Property**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动画剪辑后，您可以通过单击**添加属性**将任何属性添加到剪辑的时间线：
- en: '![Figure 14.2: The SliderExampleAnimation timeline](img/Figure_14.02_B18327.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2：SliderExampleAnimation时间线](img/Figure_14.02_B18327.jpg)'
- en: 'Figure 14.2: The SliderExampleAnimation timeline'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：SliderExampleAnimation时间线
- en: 'Doing so will bring up every component of the object, as well as a list of
    all of its children:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将显示对象的每个组件，以及其所有子组件的列表：
- en: '![Figure 14.3: Adding an Animation property](img/Figure_14.03_B18327.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3：添加动画属性](img/Figure_14.03_B18327.jpg)'
- en: 'Figure 14.3: Adding an Animation property'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：添加动画属性
- en: 'You can also view the components and children of each child:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看每个子组件的组件和子组件：
- en: '![Figure 14.4: Expanding Animation components](img/Figure_14.04_B18327.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4：展开动画组件](img/Figure_14.04_B18327.jpg)'
- en: 'Figure 14.4: Expanding Animation components'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：展开动画组件
- en: Then, you can view the components and children of those children. You can continue
    in this manner until you have exhausted the list of GameObjects that are nested
    under the selected GameObject.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以查看这些子组件的组件和子组件。您可以继续这种方式，直到耗尽所选GameObject下嵌套的GameObject列表。
- en: 'If you expand a component of a GameObject or one of its children, you will
    then note a list of all properties of that component that can be animated. As
    you will notice in the following screenshot, almost every property on the **Slider**
    component can be animated in this way:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您展开GameObject的组件或其子组件之一，您将注意到该组件所有可动画的属性列表。正如您将在以下屏幕截图中所注意到的，**滑动**组件上的几乎所有属性都可以以这种方式进行动画处理：
- en: '![Figure 14.5: The Slider component and its Animatable properties](img/Figure_14.05_B18327.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5：滑动组件及其可动画属性](img/Figure_14.05_B18327.jpg)'
- en: 'Figure 14.5: The Slider component and its Animatable properties'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：滑动组件及其可动画属性
- en: 'Only properties that have the following data types can be animated with the
    Animation System:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具有以下数据类型的属性才能使用动画系统进行动画处理：
- en: '`Vector2`, `Vector3`, and `Vector4`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector2`、`Vector3`和`Vector4`'
- en: '`Quaternion`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`四元数`'
- en: '`bool`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔值`'
- en: '`float`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`浮点数`'
- en: '`Color`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`颜色`'
- en: Selecting the plus sign will add the property to the Animation timeline along
    with two keyframes. You can then change the values of each property at the various
    keyframes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择加号将属性添加到动画时间线，并附带两个关键帧。然后您可以在各个关键帧更改每个属性的值。
- en: A **keyframe** is an important or *key* (hence the name) frame within an animation.
    It represents the start or end point of a transition within an animation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键帧**是动画中的一个重要或**关键**（因此得名）帧。它表示动画中转换的开始或结束点。'
- en: '![Figure 14.6: SliderExampleAnimation first keyframe](img/Figure_14.06_B18327.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6：SliderExampleAnimation第一个关键帧](img/Figure_14.06_B18327.jpg)'
- en: 'Figure 14.6: SliderExampleAnimation first keyframe'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：SliderExampleAnimation第一个关键帧
- en: In the preceding screenshot, the values encased in the red boxes represent the
    value of the property at the particular frame. Boolean values are represented
    by checkboxes, and float values are represented by numbers. Each type can be edited
    directly by selecting them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，红色方框内的值表示特定帧的属性值。布尔值由复选框表示，浮点值由数字表示。每种类型都可以通过选择它们进行直接编辑。
- en: Unity will fill in the values between the keyframes so that they change (or
    interpolate) on a curve. You can view the interpolation curve by selecting the
    **Curves** tab.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Unity将在关键帧之间填充值，以便它们在曲线上变化（或插值）。您可以通过选择**曲线**选项卡来查看插值曲线。
- en: You can watch the changes occur throughout all frames by playing the animation
    or scrubbing the playhead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过播放动画或拖动播放头查看整个帧的变化。
- en: The **playhead** is the marker that indicates what frame is currently being
    displayed. “Scrubbing the playhead” means dragging the playhead across the timeline
    to view changes over individual frames.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**播放头**是表示当前正在显示的帧的标记。“拖动播放头”意味着将播放头拖动到时间线上以查看单个帧的变化。'
- en: '![Figure 14.7: The Curves version of the timeline](img/Figure_14.07_B18327.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7：时间线的曲线版本](img/Figure_14.07_B18327.jpg)'
- en: 'Figure 14.7: The Curves version of the timeline'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：时间线的曲线版本
- en: Boolean properties are interpolated on a linear curve. All other properties
    (since they are a combination of floats) are interpolated along an ease-in-out
    curve. You can adjust these by adjusting the handles of the tangents at the keyframes
    by right-clicking on the keyframe.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '布尔属性沿线性曲线插值。所有其他属性（因为它们是浮点数的组合）沿渐变-渐出曲线插值。你可以通过右键单击关键帧处的切线手柄来调整这些插值。 '
- en: Often, these ease-in-out curves will cause your UI to appear *bouncy*, and adjusting
    the interpolation curve can remove that bounce. For example, animating an object
    between two points may make the object go past the destination point momentarily
    due to the ease-in-out nature of the default interpolation curve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些渐变曲线会导致你的UI看起来*弹跳*，调整插值曲线可以消除这种弹跳。例如，由于默认插值曲线的渐变-渐出特性，在两个点之间动画一个对象可能会使对象瞬间超过目标点。
- en: Animation Events
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画事件
- en: One of my favorite things about Animation Clips is the ability to add Animation
    Events to frames on the timeline. Animation Events allow you to call functions
    that exist on the GameObject at specified frames. They are represented by white
    *flags* above the timeline, and hovering over them will show the name of the function
    called by the Animation Event.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的关于动画剪辑的事情之一是能够在时间轴上的帧中添加动画事件。动画事件允许你在指定的帧上调用游戏对象上存在的函数。它们由时间轴上方的白色*旗帜*表示，悬停在它们上方将显示由动画事件调用的函数的名称。
- en: 'An Animation Event can only call a function that exists somewhere on the GameObject
    the Animation Clip is attached to. The function can be public or private and can
    also have a parameter. The parameter can be of the following types:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 动画事件只能调用附加到动画剪辑上的游戏对象上存在的函数。该函数可以是公共的或私有的，也可以有参数。参数可以是以下类型：
- en: '`float`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`int`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`string`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: An object reference
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象引用
- en: An `AnimationEvent` object
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationEvent`对象'
- en: You can add an Animation Event to the Animation Clip’s timeline by right-clicking
    on the area above the frame in which you wish to place the Animation Event and
    clicking on **Add Animation Event**, or you can click the **Add Event** button.
    Selecting the **Add Event** button will add the Animation Event wherever the playhead
    currently rests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在想要放置动画事件的帧上方的区域右键单击并点击**添加动画事件**，或者点击**添加事件**按钮来将动画事件添加到动画剪辑的时间轴上。选择**添加事件**按钮将在播放头当前停留的位置添加动画事件。
- en: '![Figure 14.8: Animation Events](img/Figure_14.08_B18327.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8：动画事件](img/Figure_14.08_B18327.jpg)'
- en: 'Figure 14.8: Animation Events'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：动画事件
- en: You can delete the Animation Event by selecting the white flag and clicking
    on **Delete**, and you can move it by clicking on it and dragging it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择白色旗帜并点击**删除**来删除动画事件，也可以通过点击并拖动它来移动它。
- en: 'The appearance of the Animation Event’s Inspector depends on whether the Animation
    Clip is attached to a GameObject and whether the GameObject is currently selected.
    The two appearances are shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 动画事件检查器的外观取决于动画剪辑是否附加到游戏对象，以及游戏对象是否当前被选中。以下截图显示了两种外观：
- en: '![Figure 14.9: The Inspector of the Animation Event](img/Figure_14.09_B18327.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9：动画事件的检查器](img/Figure_14.09_B18327.jpg)'
- en: 'Figure 14.9: The Inspector of the Animation Event'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：动画事件的检查器
- en: If the Animation Clip is attached to a GameObject and the GameObject is selected,
    a dropdown menu will appear with a list of all available functions. If the selected
    function has a parameter, then options concerning the parameter will be made available
    (take a look at the preceding screenshot). Otherwise, the name of the function
    and the parameters to pass will have to be entered manually.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画剪辑附加到游戏对象上，并且游戏对象被选中，将出现一个下拉菜单，其中列出了所有可用的函数。如果选定的函数有参数，则将提供有关该参数的选项（请参阅前面的截图）。否则，必须手动输入函数的名称和要传递的参数。
- en: If you play the `Chapter14` scene with the `Slider Animation Example` GameObject
    enabled, you will see an animation with events playing out.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用`Chapter14`场景中的`Slider Animation Example`游戏对象并播放，你会看到一个带有事件的动画正在播放。
- en: Now that we’ve looked at Animation Clips, let’s look at Animation Controllers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了动画剪辑，让我们看看动画控制器。
- en: Animator Controller
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画控制器
- en: 'Whenever an Animation Clip is created for an object, an `SliderExampleAnimation`
    Animation Clip on the `Slider` GameObject in the preceding section, an Animator
    named `Slider` was created and the Animator component was attached to the `Slider`
    GameObject:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每当为对象创建动画剪辑时，例如在前面章节中的`Slider` GameObject上的`SliderExampleAnimation`动画剪辑，就会创建一个名为`Slider`的动画器，并将动画器组件附加到`Slider`
    GameObject：
- en: '![Figure 14.10: The Slider Animator’s Inspector](img/Figure_14.10_B18327.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10：滑块动画器的检查器](img/Figure_14.10_B18327.jpg)'
- en: 'Figure 14.10: The Slider Animator’s Inspector'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：滑块动画器的检查器
- en: An Animator is needed to play Animation Clips because it determines when Animation
    Clips are played.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要动画器来播放动画剪辑，因为它决定了何时播放动画剪辑。
- en: An Animator is a type of decision tree known as a *state machine*. It holds
    a collection of *states*. States are essentially *statuses at a moment in time*.
    The *current state* of a state machine would be a representation of what is happening
    at this moment. So, for example, if there were a state machine describing my actions
    and behaviors, my *current state* would be *typing on the keyboard*. My state
    machine would have other states that I could eventually transition to, such as
    *sleeping* or *crying about approaching deadlines* if certain conditions are met.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 动画器是一种称为**状态机**的决策树类型。它包含一系列**状态**。状态本质上是在某一时刻的**状态**。状态机的**当前状态**将表示此刻正在发生的事情。例如，如果有一个描述我的行为和动作的状态机，我的**当前状态**将是**在键盘上打字**。我的状态机将会有我可以最终过渡到的其他状态，例如**睡觉**或**因为即将截止日期而哭泣**，如果满足某些条件。
- en: 'States in the Animator are represented by rectangles called *nodes*. States
    are connected by transitions that are represented by arrow lines. These transitions
    occur after either a predetermined time or a set of conditions have been met.
    The current state will have a blue, animated status bar on it telling you the
    percentage of the state that has been completed. If the current state is waiting
    for a transition to occur, this status bar may loop or stop in the full position
    until the conditions of the transition are met:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 动画器中的状态由称为**节点**的矩形表示。状态通过表示为箭头线的转换连接。这些转换发生在预定时间或满足一组条件之后。当前状态将有一个蓝色的动画状态栏，显示该状态完成的百分比。如果当前状态正在等待转换发生，这个状态栏可能会循环或停在完全位置，直到满足转换的条件：
- en: '![Figure 14.11: The Slider Animator](img/Figure_14.11_B18327.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11：滑块动画器](img/Figure_14.11_B18327.jpg)'
- en: 'Figure 14.11: The Slider Animator'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：滑块动画器
- en: The bottom-right corner of the Animator Window displays the name of the current
    Animator controller as well as its folder location. This can be very helpful when
    you have many different Animators, as it tells you which Animator you are working
    with.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 动画器窗口的右下角显示了当前动画控制器名称及其文件夹位置。当你有多个不同的动画器时，这非常有用，因为它告诉你你正在使用哪个动画器。
- en: 'States can be empty or represent Animation Clips. If a state represents an
    Animation Clip, it will have an Animation Clip set to its **Motion** property
    in its **Inspector**, as in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可以是空的，或者代表动画剪辑。如果一个状态代表动画剪辑，那么在它的**检查器**中，其**运动**属性将设置为一个动画剪辑，如下面的截图所示：
- en: '![Figure 14.12: The Motion property of an Animation State](img/Figure_14.12_B18327.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12：动画状态的“运动”属性](img/Figure_14.12_B18327.jpg)'
- en: 'Figure 14.12: The Motion property of an Animation State'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：动画状态的“运动”属性
- en: Most states will be colored gray, but those colored otherwise will represent
    special states. Every Animator will have an **Entry** node (green), an **Exit**
    node (red), and an **Any State** node (blue) within it. The first state you add
    to an Animator will be assigned the Default Layer State node (orange). You can
    change the state of the Default Layer State at any time. Note that Animator Layers
    are discussed in a later section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数状态将以灰色显示，但那些颜色不同的将代表特殊状态。每个动画器在其内部都将有一个**入口**节点（绿色）、一个**退出**节点（红色）和一个**任何状态**节点（蓝色）。你添加到动画器的第一个状态将被分配为默认层状态节点（橙色）。你可以随时更改默认层状态的状态。请注意，动画器层将在后面的章节中讨论。
- en: The **Entry** and **Exit** nodes essentially work as *gates* between state machines.
    You can have state machines within state machines, and these *gates* decide what
    happens after the state machine is entered and exited, respectively. So, the **Entry**
    node represents the instance the state machine starts, and the **Exit** node represents
    the instance it stops.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**入口**和**退出**节点本质上作为状态机之间的**门**。你可以在状态机内部有状态机，这些**门**分别决定状态机进入和退出后会发生什么。因此，**入口**节点代表状态机开始实例，而**退出**节点代表状态机停止的实例。'
- en: The **Entry** node always transitions to the Default Layer State, and you cannot
    define the conditions of the transition, so the transition will always happen
    automatically and instantly. Therefore, you can think of the Default Layer State
    as the *first* state that will occur when the state machine begins.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**入口**节点始终过渡到默认层状态，并且无法定义过渡的条件，因此过渡将始终自动且立即发生。因此，你可以将默认层状态视为状态机开始时将发生的**第一个**状态。'
- en: The **Any State** node is an *all-encompassing* state. You use this state when
    you want a transition to happen, regardless of the current state. You can only
    transition away from the **Any State** node. Continuing with the example of a
    state machine that describes my behavior, I would have a transition from **Any
    State** to the state of *crying about approaching deadlines*, because no matter
    what I am currently doing, I could burst into tears if the condition “deadline
    is within 24 hours” is met.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何状态**节点是一个**包容性**状态。当你想要发生过渡，而不管当前状态时，你将使用此状态。你只能从**任何状态**节点过渡出去。继续以描述我行为的状态机为例，我会从**任何状态**过渡到*关于即将截止日期哭泣*的状态，因为无论我现在在做什么，如果满足条件“截止日期在24小时内”，我可能会突然哭泣。'
- en: 'As stated before, the Animator will stay in the current state until a specified
    amount of time has passed or a set of conditions have been met. Selecting a transition
    arrow will display the conditions of transition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，动画师将保持在当前状态，直到经过指定的时间或满足一组条件。选择过渡箭头将显示过渡条件：
- en: '![Figure 14.13: Expanded properties of an Animation](img/Figure_14.13_B18327.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13：动画的扩展属性](img/Figure_14.13_B18327.jpg)'
- en: 'Figure 14.13: Expanded properties of an Animation'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：动画的扩展属性
- en: The transition from the preceding screenshot requires both a specified amount
    of time and a condition. The transition also isn’t instantaneous and takes `0.25`
    s to complete.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个屏幕截图的过渡需要指定的时间和条件。过渡也不是瞬时的，需要`0.25`秒才能完成。
- en: 'The **Conditions** that must be met for a transition to occur are set by the
    Animator’s **Parameters**, which can be found and created in the top-left corner
    of the Animator Window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 发生过渡必须满足的**条件**由动画师的**参数**设置，这些参数可以在动画窗口的左上角找到和创建：
- en: '![Figure 14.14: Adding an Animator Parameter](img/Figure_14.14_B18327.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14：添加动画参数](img/Figure_14.14_B18327.jpg)'
- en: 'Figure 14.14: Adding an Animator Parameter'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：添加动画参数
- en: 'The values of these parameters can be set from scripts. There are four types
    of Parameters: `False` after it is used by a transition. Trigger Parameters are
    helpful for creating flood-gate-type actions where the animation has to stop and
    wait before it can proceed to the next state. These are preferred over Bool Parameters
    in instances where the states and transitions form a loop, because a Bool Parameter
    would have to be manually reset before the state looped back around.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的值可以从脚本中设置。有四种类型的参数：在过渡使用后变为`False`。触发参数对于创建需要停止并等待才能进入下一个状态的洪水门类型动作很有帮助。在状态和过渡形成循环的情况下，这些参数比布尔参数更受欢迎，因为布尔参数在状态循环回之前必须手动重置。
- en: When you look at the list of **Parameters**, you can tell which type they are
    by the value on the right. Float Parameters have decimal numbers, Int Parameters
    have integers, Bool Parameters have square checkboxes, and Trigger Parameters
    have circular radio buttons.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看参数列表时，可以通过右侧的值来判断它们的类型。浮点参数有十进制数字，整型参数有整数，布尔参数有方形复选框，触发参数有圆形单选按钮。
- en: Since Animators are state machines, they can be used to accomplish much more
    than animations. Animators can be used to keep track of complex game logic. For
    example, I created the following state machine for a match-three RPG to keep track
    of what was currently happening in the game. Using it to keep track of the current
    state of the game allowed me to restrict what the player could do based on what
    was happening in the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动画器是状态机，它可以用来完成比动画更多的任务。动画器可以用来跟踪复杂的游戏逻辑。例如，我为一个三消RPG创建以下状态机来跟踪游戏中当前发生的情况。使用它来跟踪游戏当前状态允许我根据游戏中的情况限制玩家可以做什么。
- en: 'For example, if the enemy character was attacking, the player would not interact
    with the pieces on the board:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果敌人角色正在攻击，玩家将不会与棋盘上的碎片交互：
- en: '![Figure 14.15: Example of a Animation State Machine used for logic](img/Figure_14.15_B18327.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图14.15：用于逻辑的动画状态机示例](img/Figure_14.15_B18327.jpg)'
- en: 'Figure 14.15: Example of a Animation State Machine used for logic'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：用于逻辑的动画状态机示例
- en: Now that we’ve reviewed the properties of the Animator Controller, let’s look
    at some of its uses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了动画控制器属性，让我们看看它的用途。
- en: The Animator of Transition Animations
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡动画的动画器
- en: 'In [*Chapter 9*](B18327_09.xhtml#_idTextAnchor213), we took a look at Button
    Animation transitions and created a simple animation for a Button. We let the
    Button component automatically generate the Animator for us, but never looked
    at the Animator or did anything with it. Now that we’ve discussed Animators, let’s
    look at the Animator of the `Play Button` saved in `Assets/Animations`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18327_09.xhtml#_idTextAnchor213)中，我们探讨了按钮动画过渡并为按钮创建了一个简单的动画。我们让按钮组件自动为我们生成动画器，但从未查看过动画器或对其进行任何操作。现在我们已经讨论了动画器，让我们看看保存在`Assets/Animations`中的`Play
    Button`的动画器：
- en: '![Figure 14.16: The Animator of a Button](img/Figure_14.16_B18327.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图14.16：按钮的动画器](img/Figure_14.16_B18327.jpg)'
- en: 'Figure 14.16: The Animator of a Button'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16：按钮的动画器
- en: 'As you can see from the preceding screenshot, the Animator that was automatically
    generated for us isn’t particularly complicated and its setup is self-explanatory.
    It contains states to hold the following five Animation Clips: `Normal`, `Highlighted`,
    `Pressed`, `Selected`, and `Disabled`. All of the Animation Clips transition from
    `Any State`. Also, there are five Trigger Parameters: `Normal`, `Highlighted`,
    `Pressed`, `Selected`, and `Disabled`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，为我们自动生成的动画器并不特别复杂，其设置也是一目了然的。它包含以下五个动画片段的状态：`Normal`、`Highlighted`、`Pressed`、`Selected`和`Disabled`。所有动画片段都从`Any
    State`过渡。此外，还有五个触发参数：`Normal`、`Highlighted`、`Pressed`、`Selected`和`Disabled`。
- en: Automatically generating an Animator for any of the UI elements that allow for
    transition animations will result in the exact same setup. Even though this Animator
    is preset for you, you are free to adjust it however you see fit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何允许过渡动画的UI元素自动生成动画器将产生相同的设置。尽管这个动画器为你预设了，但你可以根据自己的需要自由调整它。
- en: Animator layers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画层
- en: 'When using the Animator, if you have a state with transitions to multiple nodes,
    only one transition can occur. For example, in the following screenshot, the `ChooseAState`
    state can only transition to one of the other states at once, even if the transition
    conditions for all are met; this is true regardless of the type of Parameter that
    you use:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用动画器时，如果你有一个具有多个节点过渡的状态，则只能发生一个过渡。例如，在以下截图中，`ChooseAState`状态只能同时过渡到其他状态中的一个，即使所有过渡条件都满足也是如此；这适用于你使用的任何类型的参数：
- en: '![Figure 14.17: A forking animation example in the Chapter14 scene](img/Figure_14.17_B18327.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图14.17：第14章场景中的分支动画示例](img/Figure_14.17_B18327.jpg)'
- en: 'Figure 14.17: A forking animation example in the Chapter14 scene'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17：第14章场景中的分支动画示例
- en: 'If you want multiple animations to trigger at once, you can use Animation Layers.
    The following layer setup will have all three states running simultaneously:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时触发多个动画，可以使用动画层。以下图层设置将使所有三个状态同时运行：
- en: '![Figure 14.18: An Animation Layers Example in the Chapter14 scene](img/Figure_14.18_B18327.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图14.18：第14章场景中的动画层示例](img/Figure_14.18_B18327.jpg)'
- en: 'Figure 14.18: An Animation Layers Example in the Chapter14 scene'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18：第14章场景中的动画层示例
- en: I’ve found that the most common need for something like this is when you have
    an object made of multiple sprite sheets and you want multiple sprite sheet animations
    to trigger at the same time and putting them all on the same Animation Clip doesn’t
    make sense. For example, I’ve worked on a game where a 2D character had multiple
    interchangeable parts, and each part had its own sprite sheet animation. It was
    necessary to have the idle animation for each part start all at the same time.
    Since the parts could be swapped out, there were multiple combinations of parts
    that could be achieved, and it would not have made sense to make all the different
    possible idle animation combinations. It also wouldn’t have made sense to give
    each possible part its own Animator. So, I made a layer for each body part and
    was able to have the individual sprite animations all play at the same time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，像这样的需求最常见的情况是当您有一个由多个精灵图集组成的对象，并且您希望同时触发多个精灵图集动画，将它们全部放在同一个动画剪辑中并不合理。例如，我在一个游戏中工作，其中2D角色有多个可互换的部分，每个部分都有自己的精灵图集动画。必须让每个部分的无动作动画同时开始。由于部分可以互换，因此可以实现多种部分组合，制作所有可能的无动作动画组合并不合理。给每个可能的部件分配自己的动画器也不合理。因此，我为每个身体部分创建了一个层，并能够同时播放所有单个精灵动画。
- en: Setting Animation Parameters in scripts
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中设置动画参数
- en: You can set the values of the Animator Parameters via scripts using the `SetFloat()`,
    `SetInteger()`, `SetBool()`, `SetTrigger()`, and `ResetTrigger()` functions of
    the `Animator` class. You reference the Animator Parameter variables by the string
    names assigned to them within the Animator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`Animator`类的`SetFloat()`、`SetInteger()`、`SetBool()`、`SetTrigger()`和`ResetTrigger()`函数通过脚本设置动画参数的值。您可以通过在动画器中分配给它们的字符串名称来引用动画参数变量。
- en: To set the Animation Parameters, you first get the Animator on which the Parameters
    were defined; you can do this with either a public Animator variable or using
    `GetComponent<Animator>()`. Then, you call the necessary function on the Animator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置动画参数，您首先需要获取定义了参数的动画器；您可以使用公共动画器变量或使用`GetComponent<Animator>()`来完成此操作。然后，在动画器上调用必要的函数。
- en: 'Let’s look at an example that would set the following **Parameters**:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，该示例将设置以下**参数**：
- en: '![Figure 14.19: Different types of Animation Parameters](img/Figure_14.19_B18327.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图14.19：不同类型的动画参数](img/Figure_14.19_B18327.jpg)'
- en: 'Figure 14.19: Different types of Animation Parameters'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19：不同类型的动画参数
- en: 'The following script would set the Animator Parameters defined in the previous
    screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将设置之前截图中所定义的动画参数：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The benefit of using a Trigger is that you usually don’t have to reset it as
    it instantly resets the moment a transition uses it. However, if you set a Trigger
    and the transition is never reached, you will need to reset it using `ResetTrigger()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用触发器的优点是您通常不需要重置它，因为一旦过渡使用它，它就会立即重置。然而，如果您设置了触发器，但过渡从未到达，您将需要使用`ResetTrigger()`来重置它。
- en: Animator Behaviours
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画器行为
- en: If you want to write code that fires at specific points within a state, you
    can use a unique class of scripts known as State Machine Behaviours. State Machine
    Behaviours can be added to any state node you create within the Animator. I specify
    *you create* because you cannot add them to the **Entry** node, **Exit** node,
    or **Any** **State** node.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在状态内的特定点执行代码，您可以使用一种独特的脚本类，称为状态机行为。状态机行为可以添加到您在动画器中创建的任何状态节点。我指定*您创建*，因为您不能将它们添加到**进入**节点、**退出**节点或**任何****状态**节点。
- en: 'You can create a new State Machine Behaviour by selecting a state and clicking
    on **Add Behaviour**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择一个状态并点击**添加行为**来创建一个新的状态机行为：
- en: '![Figure 14.20: How to add a Behaviour to an Animation State](img/Figure_14.20_B18327.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图14.20：如何将行为添加到动画状态](img/Figure_14.20_B18327.jpg)'
- en: 'Figure 14.20: How to add a Behaviour to an Animation State'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20：如何将行为添加到动画状态
- en: All new State Machine Behaviours created in this way are saved in the `Assets`
    folder.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的所有新状态机行为都保存在`Assets`文件夹中。
- en: 'When you open the script, it will be automatically populated with the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开脚本时，它将自动填充以下代码：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this class is derived from `StateMachineBehaviour` rather than `MonoBehaviour`,
    like the scripts we attach to GameObjects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类是从`StateMachineBehaviour`派生出来的，而不是像我们附加到GameObject上的脚本那样从`MonoBehaviour`派生。
- en: There are a few functions prewritten in the script for you, along with descriptions
    of how to use them. Just as `Awake()`, `Start()`, and `Update()` are predefined
    functions for MonoBehaviour, `OnStateEnter()`, `OnStateUpdate()`, `OnStateExit()`,
    `OnStateIK()`, and `OnStateMove()` are predefined functions that call at specific
    times. You can delete whichever functions you don’t want to use. You can also
    write other functions within this script, and they are not restricted to these
    predefined ones.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中预先编写了一些函数，以及如何使用它们的描述。就像`Awake()`、`Start()`和`Update()`是MonoBehaviour的预定义函数一样，`OnStateEnter()`、`OnStateUpdate()`、`OnStateExit()`、`OnStateIK()`和`OnStateMove()`是在特定时间调用的预定义函数。你可以删除你不想使用的任何函数。你还可以在此脚本中编写其他函数，它们不受这些预定义函数的限制。
- en: These functions can do whatever you want them to do, even set the Animator Parameters
    of your Animator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以执行你想要它们执行的操作，甚至可以设置你的动画机的动画参数。
- en: I find State Machine Behaviours to be incredibly helpful because I use state
    machines extensively to control the logic of my games. Earlier, in this section,
    I showed you a state machine I created for a match-three RPG. I used multiple
    State Machine Behaviours to let my other scripts know when the states had changed,
    call functions from other scripts at specified times, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现状态机行为非常有帮助，因为我广泛使用状态机来控制游戏逻辑。在前面这个部分，我向你展示了我为三合一RPG创建的状态机。我使用了多个状态机行为来让其他脚本知道状态何时改变，在指定时间调用其他脚本中的函数，等等。
- en: Now that we’ve reviewed using Animation clips and Animator Controllers, let’s
    look at some examples of how to implement them in our project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了使用动画剪辑和动画控制器，让我们看看一些如何在我们的项目中实现它们的示例。
- en: Examples
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: The main focus of this chapter is to provide examples of how to create common
    UI animations and effects, so let’s get to it. In these examples, I will show
    you a basic re-usable animation for fading UI Panels in and out, as well as a
    more complex animation of a loot box dependent on player interaction.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点是提供创建常见UI动画和效果的示例。让我们开始吧。在这些示例中，我将向你展示一个基本的可重用动画，用于淡入淡出UI面板，以及一个更复杂的依赖于玩家交互的宝箱动画。
- en: Animating pop-up windows to fade in and out
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画弹出窗口的淡入淡出效果
- en: With our first example, we will continue to work on our main scene.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将继续在我们的主场景中工作。
- en: Currently, we have a `Pause Panel` and `Inventory Panel` that instantly appear
    when the *P* or *I* key is pressed. That’s not terribly interesting, so let’s
    add some animations to have the Panels *pop* in and out with fade and scale animations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有`暂停面板`和`物品栏面板`，当按下*P*或*I*键时会立即出现。这并不特别有趣，所以让我们添加一些动画，使面板通过淡入淡出和缩放动画来弹出和消失。
- en: It can get rather tedious having to expand all of the parents to see their children
    every time you go to a new scene. A shortcut to open all parents is to select
    everything in the Hierarchy and then press the right arrow key on the keyboard.
    You can do this multiple times if you have multiple nestings. The left arrow key
    will collapse the parents.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每次进入新场景时，必须展开所有父项以查看其子项，这可能会变得相当繁琐。一个打开所有父项的快捷方式是选择层次结构中的所有内容，然后按键盘上的右箭头键。如果你有多个嵌套，你可以多次这样做。按左箭头键将折叠父项。
- en: Our workflow to set up these animations and their functionality will be to create
    Animation Clips, set up our Animator, and then write code that sets the Animator’s
    parameters at the appropriate times. To make the steps easier to digest, I’ve
    broken them into sections. The first section covers all of the steps involved
    with setting up the Animation Clips and Animator and the second section covers
    the sets involved with writing code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置这些动画及其功能的工作流程将是创建动画剪辑，设置我们的动画机，然后编写在适当时间设置动画机参数的代码。为了使步骤更容易理解，我将它们分为几个部分。第一部分涵盖了设置动画剪辑和动画机的所有步骤，第二部分涵盖了编写代码涉及的设置。
- en: Setting up the animations
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置动画
- en: 'To create a pop in and out animation on `Pause Panel` and `Inventory Panel`,
    perform the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`暂停面板`和`物品栏面板`上创建弹出和消失的动画，请执行以下步骤：
- en: We’ll start by adding an Animation Clip to `Pause Panel` that will cause it
    to scale and fade in. Open the Animation Window and select `Pause Panel` from
    the Hierarchy. Select `Assets/Animation` folder and name it `FadeAndScale`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将一个动画剪辑添加到`暂停面板`，这将使其缩放并淡入。打开动画窗口，从层次结构中选择`暂停面板`。选择`Assets/Animation`文件夹，并将其命名为`FadeAndScale`。
- en: 'We want to control four properties of this Panel: its scale, its alpha value,
    its ability to be interacted with, and its raycast blocking. Let’s start with
    scale. We can adjust this property from the Rect Transform component. Select **Add
    Property** and click on the plus sign next to **Scale** under **Rect Transform**,
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想控制这个面板的四个属性：其缩放、其 Alpha 值、其交互能力以及其射线投射阻塞。让我们从缩放开始。我们可以从 Rect Transform 组件调整这个属性。选择
    **添加属性**，然后点击 **Rect Transform** 下 **Scale** 旁边的加号，如下所示：
- en: '![Figure 14.21: Adding the Scale property](img/Figure_14.21_B18327.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.21：添加 Scale 属性](img/Figure_14.21_B18327.jpg)'
- en: 'Figure 14.21: Adding the Scale property'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21：添加 Scale 属性
- en: 'Two keyframes are initialized for the **Scale** property at **0:00** and **1:00**.
    This means that the animation will last one second, which is a bit long for a
    pop-in animation. Select the keyframe at **1:00** and drag it to **0:30** to make
    the animation half a second long:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Scale** 属性在 **0:00** 和 **1:00** 初始化了两个关键帧。这意味着动画将持续一秒钟，对于一个弹出动画来说有点长。选择 **1:00**
    的关键帧，并将其拖动到 **0:30**，使动画缩短到半秒钟：'
- en: '![Figure 14.22: Adjusting the length of the animation](img/Figure_14.22_B18327.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.22：调整动画长度](img/Figure_14.22_B18327.jpg)'
- en: 'Figure 14.22: Adjusting the length of the animation'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22：调整动画长度
- en: 'We want the Panel to start off small and then get big. To achieve this, we
    will need to adjust the *x* and *y* scales. Expand the `1` at both keyframes.
    Since we want the scale to start small and then enlarge to its normal size, we
    want it to scale from `0` to `1`. We only need to adjust the *x* and *y* scales
    since the *z* scale doesn’t really affect a 2D object. So, at keyframe `0` by
    typing `0` in their property boxes, as follows:![Figure 14.23: Adjusting the Scale
    properties](img/Figure_14.23_B18327.jpg)'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望面板开始时较小，然后变大。为了实现这一点，我们需要调整 *x* 和 *y* 缩放。在两个关键帧上展开 `1`。由于我们希望缩放从小开始，然后放大到正常大小，我们希望它从
    `0` 缩放到 `1`。我们只需要调整 *x* 和 *y* 缩放，因为 *z* 缩放实际上不会影响 2D 对象。因此，在关键帧 `0` 中，在它们的属性框中输入
    `0`，如下所示：![图 14.23：调整 Scale 属性](img/Figure_14.23_B18327.jpg)
- en: 'Figure 14.23: Adjusting the Scale properties'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.23：调整 Scale 属性
- en: If you play the animation, you’ll note that `Pause Panel` is quickly scaling
    in. Since parent/child relationships scale children with their parents, we don’t
    have to animate the scale of all the `Pause Panel` children separately.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你播放动画，你会注意到 `Pause Panel` 快速缩放。由于父子关系会以父元素的比例缩放子元素，所以我们不需要单独动画化所有 `Pause Panel`
    子元素的缩放。
- en: 'Now, let’s control the alpha of the Panel to fade it in. We don’t want to animate
    the alpha on the `Pause Panel`. Doing so would only affect the alpha of the Panel’s
    background Image and would not affect the children. Instead, we want to animate
    the alpha value on the `Pause Panel` and all its children work in unison. Remember
    that this was the whole reason we used a Canvas Group component to begin with.
    Let’s select **Add Property** | **Canvas Group** | **Alpha**:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们控制面板的 Alpha 值以渐显它。我们不想在 `Pause Panel` 上动画化 Alpha。这样做只会影响面板背景图像的 Alpha
    值，而不会影响子元素。相反，我们想在 `Pause Panel` 上动画化 Alpha 值，并让所有子元素一起工作。记住，这正是我们最初使用 Canvas
    Group 组件的原因。让我们选择 **添加属性** | **Canvas Group** | **Alpha**：
- en: '![Figure 14.24: Adding the Alpha property](img/Figure_14.24_B18327.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.24：添加 Alpha 属性](img/Figure_14.24_B18327.jpg)'
- en: 'Figure 14.24: Adding the Alpha property'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24：添加 Alpha 属性
- en: To fade in, the Panel should start completely transparent and end completely
    opaque. Both keyframes already have the `1`, so change the `0` at the first keyframe.
    Playing the animation (or scrubbing the playhead) will show the Panel and all
    of its children fading in.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要渐显，面板应从完全透明开始，并最终变为完全不透明。两个关键帧都已经有了 `1`，所以将第一个关键帧的 `0` 改变。播放动画（或拖动播放头）将显示面板及其所有子元素渐显。
- en: We will need to animate whether or not the Panel can be interacted with. We
    don’t want the player to be able to interact with the dropdown menu or mute buttons
    when the Panel is still popping in. This too is controlled by the Canvas Group
    component—select **Add Property** | **Canvas Group** | **Interactable**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要动画化面板是否可以被交互。我们不希望当面板仍在弹出时，玩家能够与下拉菜单或静音按钮交互。这同样由 Canvas Group 组件控制——选择 **添加属性**
    | **Canvas Group** | **Interactable**。
- en: The `Pause Panel` and its children should be interactable only after it has
    fully popped into the scene. So, deselect the checkbox next to **CanvasGroup.Interactable**
    at the first keyframe to make the Canvas Group animate from interactable to not
    interactable. When you scrub the playhead, you’ll see that the property does not
    turn back on until the very last frame.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在它完全弹出场景后，`Pause Panel` 和其子项才应该是可交互的。因此，在第一个关键帧旁边取消选择 **CanvasGroup.Interactable**
    旁边的复选框，使 Canvas Group 从可交互状态动画到不可交互状态。当你拖动播放头时，你会看到属性直到最后一帧都不会再次开启。
- en: 'The last item we will need to animate is its raycast blocking. Select `false`
    to `true` as you did with the `FadeAndScale` Animation Clip’s timeline should
    now appear, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要动画的最后一项是其射线投射阻塞。将 `false` 选择为 `true`，就像你在 `FadeAndScale` 动画片段的时间线上所做的那样，现在应该出现以下内容：
- en: '![Figure 14.25: The Timeline of the FadeAndScale Animation Clip](img/Figure_14.25_B18327.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.25：FadeAndScale 动画片段的时间线](img/Figure_14.25_B18327.jpg)'
- en: 'Figure 14.25: The Timeline of the FadeAndScale Animation Clip'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.25：FadeAndScale 动画片段的时间线
- en: Now that we have our Animation Clip set up, we can start working inside the
    Animator. When we created the `FadeAndScale` Animation Clip, an Animator named
    `Pause Panel` was automatically created. An Animator component was also added
    to the `Pause Panel` GameObject, with the `Pause Panel` Animator assigned to it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了动画片段，我们可以在动画器内部开始工作。当我们创建 `FadeAndScale` 动画片段时，一个名为 `Pause Panel` 的动画器被自动创建。还向
    `Pause Panel` 游戏对象添加了一个动画器组件，并将其分配给 `Pause Panel` 动画器。
- en: 'With `Pause Panel` selected, open the Animator Window. You should see something
    similar to the following:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择 `Pause Panel` 后，打开动画器窗口。你应该会看到以下类似的内容：
- en: '![Figure 14.26: The Animator of Pause Panel](img/Figure_14.26_B18327.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 14.26：Pause Panel 的动画器](img/Figure_14.26_B18327.jpg)'
- en: 'Figure 14.26: The Animator of Pause Panel'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.26：Pause Panel 的动画器
- en: You will see a state named `FadeAndScale`. This state uses the `FadeAndScale`
    Animation Clip as its **Motion**, which you can view in its Inspector.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到一个名为 `FadeAndScale` 的状态。此状态使用 `FadeAndScale` 动画片段作为其 **运动**，你可以在其检查器中查看。
- en: 'Currently, since the `FadeAndScale` state is connected to the `FadeAndScale`
    animation will play instantly. It will also play on a loop. That’s not at all
    what we want, obviously. Let’s stop it from playing when the game starts by creating
    an empty state as the Layer Default State. Right-click anywhere within the Animator
    and select **Create State** | **Empty**:![Figure 14.27: Creating an Empty State](img/Figure_14.27_B18327.jpg)'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，由于 `FadeAndScale` 状态连接到 `FadeAndScale` 动画将立即播放。它也会循环播放。这显然不是我们想要的。让我们通过创建一个空状态作为层默认状态来阻止它在游戏开始时播放。在动画器内任意位置右键单击并选择
    **创建状态** | **空状态**：![图 14.27：创建空状态](img/Figure_14.27_B18327.jpg)
- en: 'Figure 14.27: Creating an Empty State'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.27：创建空状态
- en: This will add a gray-colored state named `New State` to the Animator.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在动画器中添加一个名为 `New State` 的灰色状态。
- en: Rename `New State` to `Empty State` by changing its name in its Inspector.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在其检查器中更改名称，将 `New State` 重命名为 `Empty State`。
- en: 'Set `Empty State` to the Layer Default State by right-clicking on it and selecting
    **Set as Layer** **Default State**:![Figure 14.28: Setting a state as the Layer
    Default](img/Figure_14.28_B18327.jpg)'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择 **设置为层** **默认状态**，将 `Empty State` 设置为层默认状态：![图 14.28：设置状态为层默认状态](img/Figure_14.28_B18327.jpg)
- en: 'Figure 14.28: Setting a state as the Layer Default'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.28：设置状态为层默认状态
- en: 'It will now be connected to `FadeAndScale` will also now no longer be the Layer
    Default State and will not have any transitions connected to it:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，它将连接到 `FadeAndScale`，它也将不再是层默认状态，并且不会连接到任何过渡：
- en: '![Figure 14.29: Empty State set as the Layer Default](img/Figure_14.29_B18327.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 14.29：将空状态设置为层默认状态](img/Figure_14.29_B18327.jpg)'
- en: 'Figure 14.29: Empty State set as the Layer Default'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.29：将空状态设置为层默认状态
- en: We used an empty state as our Layer Default State because we want the Panel
    to do nothing, while it waits for us to tell it to start animating.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用空状态作为层默认状态，因为我们希望面板在等待我们告诉它开始动画时什么也不做。
- en: 'Rearrange the items to a more viewable layout. I personally like the following
    layout for this Animator:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目重新排列为更易于查看的布局。我个人喜欢以下布局用于此动画器：
- en: '![Figure 14.30: Rearranging the States](img/Figure_14.30_B18327.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.30：重新排列状态](img/Figure_14.30_B18327.jpg)'
- en: 'Figure 14.30: Rearranging the States'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.30：重新排列状态
- en: The `FadeAndScale` Animation Clip now no longer instantly plays when the game
    starts. It is still set to have its animation loop, however. To fix this, select
    the `FadeAndScale` Animation Clip from your **Project** folder view. This will
    bring up its Inspector.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FadeAndScale`动画剪辑现在在游戏开始时不再立即播放。然而，它仍然设置为具有动画循环。为了修复这个问题，从您的**项目**文件夹视图中选择`FadeAndScale`动画剪辑。这将打开其检查器。'
- en: 'Deselect the **Loop Time** property to disable looping on the animation:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 取消选择**循环时间**属性以禁用动画的循环：
- en: '![Figure 14.31: Deselecting Loop Time](img/Figure_14.31_B18327.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图14.31：取消选择循环时间](img/Figure_14.31_B18327.jpg)'
- en: 'Figure 14.31: Deselecting Loop Time'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.31：取消选择循环时间
- en: 'We want the `Pause Panel` to be able to fade in and out on command, but we
    don’t have an Animation Clip for fading out, only one for fading in. We actually
    don’t need to create a whole Animation Clip to achieve this motion. We can simply
    play the `FadeAndScale` Animation Clip backward. Duplicate the `FadeAndScale`
    state by selecting it and pressing *Ctrl* + *D*. This will give you a new state
    named `FadeAndScale 0` that has the `FadeAndScale` Animation Clip set as its **Motion**:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`Pause Panel`能够根据命令淡入和淡出，但我们没有淡出动画剪辑，只有淡入动画剪辑。实际上，我们不需要创建整个动画剪辑来实现这种动作。我们可以简单地播放`FadeAndScale`动画剪辑的反向。通过选择它并按*Ctrl*
    + *D*来复制`FadeAndScale`状态。这将为您提供一个名为`FadeAndScale 0`的新状态，其**运动**设置为`FadeAndScale`动画剪辑：
- en: '![Figure 14.32: Duplicating a State](img/Figure_14.32_B18327.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图14.32：复制状态](img/Figure_14.32_B18327.jpg)'
- en: 'Figure 14.32: Duplicating a State'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.32：复制状态
- en: Rename the `FadeAndScale` state to `FadeAndScaleIn` and the `FadeAndScale 0`
    state to `FadeAndScaleOut`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FadeAndScale`状态重命名为`FadeAndScaleIn`，将`FadeAndScale 0`状态重命名为`FadeAndScaleOut`。
- en: 'To set the `FadeAndScaleOut` state to play the `FadeAndScale` Animation Clip
    backward, we simply have to change its `-1` in its Inspector:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置`FadeAndScaleOut`状态反向播放`FadeAndScale`动画剪辑，我们只需在其检查器中更改其`-1`：
- en: '![Figure 14.33: Setting an animation to play in reverse](img/Figure_14.33_B18327.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图14.33：设置反向播放动画](img/Figure_14.33_B18327.jpg)'
- en: 'Figure 14.33: Setting an animation to play in reverse'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.33：设置反向播放动画
- en: 'Now that we have all of our states set up properly, we can create the transitions
    between them. Start by creating two Trigger Parameters named `FadeIn` and `FadeOut`:![Figure
    14.34: The Animator Parameters](img/Figure_14.34_B18327.jpg)'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了所有状态，我们可以创建它们之间的过渡。首先创建两个名为`FadeIn`和`FadeOut`的触发参数：![图14.34：动画师参数](img/Figure_14.34_B18327.jpg)
- en: 'Figure 14.34: The Animator Parameters'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.34：动画师参数
- en: We are using Trigger Parameters here because we want these values to instantly
    reset after we’ve used them. That way, we can create an animation cycle without
    having to write code that resets the parameter values.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用触发参数，因为我们希望在使用这些值后它们能够立即重置。这样，我们就可以创建一个动画循环，而无需编写重置参数值的代码。
- en: 'You create transitions between states by right-clicking on the first state,
    selecting **Make Transition**, and then clicking on the second state:![Figure
    14.35: Making transitions](img/Figure_14.35_B18327.jpg)'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在第一个状态上右键单击，选择**创建过渡**，然后点击第二个状态来创建状态之间的过渡：![图14.35：创建过渡](img/Figure_14.35_B18327.jpg)
- en: 'Figure 14.35: Making transitions'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.35：创建过渡
- en: 'Create transitions between the states in the following manner:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按以下方式在状态之间创建过渡：
- en: '![Figure 14.36: The final state transition layout](img/Figure_14.36_B18327.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图14.36：最终状态过渡布局](img/Figure_14.36_B18327.jpg)'
- en: 'Figure 14.36: The final state transition layout'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.36：最终状态过渡布局
- en: This transition flow will allow the Panel to transition from no animation to
    the `FadeAndScale` Animation Clip, then to the reversed `FadeAndScale` Animation
    Clip, and back and forth between the two.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种过渡流程将允许面板从无动画过渡到`FadeAndScale`动画剪辑，然后过渡到反转的`FadeAndScale`动画剪辑，并在两者之间来回切换。
- en: 'If you play the game, `Pause Panel` will instantly go from the `Empty State`
    to the `FadeAndScaleIn` state and then to the `FadeAndScaleOut` state, and back
    and forth between the two indefinitely. This is because transitions are automatically
    set to occur after an animation is complete. To stop this, you have to tell the
    transitions to only occur after a parameter has been set. Select the transition
    between the `Empty State` and the `FadeAndScaleIn` state. Select the plus sign
    in the `FadeIn` Trigger. Since we don’t want timing to be a factor in our transition,
    deselect **Has** **Exit Time**:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你玩游戏，`暂停面板`将立即从`空状态`变为`淡入并缩放`状态，然后变为`淡出并缩放`状态，并在这两个状态之间无限循环。这是因为过渡被自动设置为在动画完成后发生。要停止这种行为，你必须告诉过渡只在设置了一个参数之后发生。选择`空状态`和`淡入并缩放`状态之间的过渡。选择`淡入`触发器中的加号。由于我们不想让时间成为过渡的因素，取消选择**具有**
    **退出时间**：
- en: '![Figure 14.37: The transition properties](img/Figure_14.37_B18327.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图14.37：过渡属性](img/Figure_14.37_B18327.jpg)'
- en: 'Figure 14.37: The transition properties'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.37：过渡属性
- en: 'Complete the same steps for the transitions between the `FadeAndScaleIn` and
    `FadeAndScaleOut` States. Set the `FadeAndScaleIn` State to the `FadeAndScaleOut`
    State to the `FadeAndScaleOut` state to `FadeAndScaleIn` State to the `0` to ensure
    an instant transition:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成在`淡入并缩放`和`淡出并缩放`状态之间的过渡。将`淡入并缩放`状态设置为`淡出并缩放`状态，将`淡出并缩放`状态设置为`淡入并缩放`状态，并将`淡入并缩放`状态设置为`0`以确保瞬间过渡：
- en: '![Figure 14.38: How to set up the transitions of the Pause Panel](img/Figure_14.38_B18327.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图14.38：如何设置暂停面板的过渡](img/Figure_14.38_B18327.jpg)'
- en: 'Figure 14.38: How to set up the transitions of the Pause Panel'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.38：如何设置暂停面板的过渡
- en: 'If you play the game now, you’ll note that the `Pause Panel` is visible when
    the game starts. This is because our animation states supersede the code we wrote
    in `ShowHidePanels.cs` that made the `Pause Panel` invisible at the start of the
    scene. We’ll deal with our broken code later, but for now, make the `Pause Panel`
    invisible at start by setting its **Canvas Group** component to have the following
    values:![Figure 14.39: The properties of the Canvas Group](img/Figure_14.39_B18327.jpg)'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你会注意到`暂停面板`在游戏开始时是可见的。这是因为我们的动画状态覆盖了我们之前在`ShowHidePanels.cs`中编写的代码，该代码使`暂停面板`在场景开始时不可见。我们稍后会处理我们的损坏代码，但现在，通过将`Canvas
    Group`组件设置为以下值，使`暂停面板`在开始时不可见：![图14.39：Canvas Group的属性](img/Figure_14.39_B18327.jpg)
- en: 'Figure 14.39: The properties of the Canvas Group'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.39：Canvas Group的属性
- en: Now when you play the game, the `Pause Panel` will not appear at the start.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你玩游戏时，`暂停面板`将不会在开始时出现。
- en: 'We’ve completed setting up the animations for the `Pause Panel`, but before
    you proceed to the `Inventory Panel`, check whether the animations are working
    correctly. To do so, arrange your windows so that your Game view and Animator
    Window are both visible:![Figure 14.40: Playing the Empty State](img/Figure_14.40_B18327.jpg)'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了`暂停面板`动画的设置，但在你继续到`库存面板`之前，检查动画是否工作正常。为此，调整你的窗口，以便你的游戏视图和Animator窗口都可见：![图14.40：播放空状态](img/Figure_14.40_B18327.jpg)
- en: 'Figure 14.40: Playing the Empty State'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.40：播放空状态
- en: You’ll see the progress bar on the current state of `Pause Panel` running. To
    force the transitions, click on the circles next to the appropriate Trigger parameters.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到当前`暂停面板`状态上的进度条正在运行。要强制过渡，点击适当的触发参数旁边的圆圈。
- en: If your animations are working the way they should, you can now set up the animations
    on the `Inventory Panel`. You may be thinking, “Ugh, now I have to do all of this
    again for the `Inventory Panel`?!” However, worry not, you don’t have to do it
    again, because you can reuse the Animator for the `Pause Panel` on the `Inventory
    Panel`. All of the properties we changed on the `Pause Panel` in the `FadeAndScale`
    Animation Clip also exist on the `Inventory Panel`. So, to give the same set of
    animations and controls to the `Inventory Panel`, we can simply attach the Animator
    we created to `Inventory Panel`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的动画工作正常，你现在可以设置`库存面板`上的动画。你可能正在想，“呃，现在我必须为`库存面板`再次做所有这些吗？！”然而，不用担心，你不必再次这样做，因为你可以将`暂停面板`的Animator在`库存面板`上重用。我们在`暂停面板`的`淡入并缩放`动画剪辑中更改的所有属性也存在于`库存面板`上。因此，为了给`库存面板`提供相同的动画和控件集，我们可以简单地将我们创建的Animator附加到`库存面板`。
- en: Since we will be using the Animator we created on two different objects, it
    is a good idea to rename it. Change the name from `Pause Panel` to `PopUpPanels`.
    Now, drag it onto the `Inventory Panel`.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们将在两个不同的对象上使用我们创建的 Animator，所以将其重命名是个好主意。将名称从 `Pause Panel` 更改为 `PopUpPanels`。现在，将其拖动到
    `Inventory Panel` 上。
- en: Just as we had to change the properties of the Canvas Group on `Pause Panel`
    to stop it from appearing when the scene starts, we also have to change the properties
    on the `Inventory Panel`. Set the properties as they appear in *Figure 14**.39*.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们不得不改变 `Pause Panel` 上 Canvas Group 的属性以防止它在场景开始时出现一样，我们还需要改变 `Inventory
    Panel` 上的属性。将属性设置为 *图 14**.39* 中所示。
- en: Now that we are done setting up our animations for our two Panels, we can begin
    writing code that will trigger the animations when the *P* and *I* keys are hit
    to bring up the Panels.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的两个面板设置了动画，我们可以开始编写代码，当按下 *P* 和 *I* 键时触发动画以显示面板。
- en: Setting the Animator’s Parameters with code
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代码设置 Animator 的参数
- en: We have a script named `ShowHidePanels.cs` attached to the `Main Camera` that
    would bring the `Pause Panel` and `Inventory Panel` up when the *P* and *I* keys,
    respectively, are pressed. Sadly, it no longer functions, since the animations
    now supersede the properties of the Canvas Groups we set within it. We can reuse
    the logic but will have to do a bit of work to get our Panels popping up again.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `ShowHidePanels.cs` 的脚本附加到 `Main Camera` 上，当按下 *P* 和 *I* 键时，分别显示 `Pause
    Panel` 和 `Inventory Panel`。遗憾的是，它不再工作，因为现在的动画现在超过了我们在其中设置的 Canvas Groups 的属性。我们可以重用这个逻辑，但我们需要做一些工作才能让我们的面板再次弹出。
- en: The changes that we will make to `ShowHidePanels.cs` will cause the Panels in
    preceding chapter scenes to stop appearing. If you plan on accessing the previous
    chapter scenes, save a secondary copy of this script as it is now so that you
    can access it later.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 `ShowHidePanels.cs` 文件所做的更改将导致前一章场景中的面板停止显示。如果您计划访问前一章的场景，请现在保存此脚本的副本来供以后使用。
- en: 'To trigger the animations on the `Pause Panel` and `Inventory Panel` with code,
    complete the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用代码触发 `Pause Panel` 和 `Inventory Panel` 上的动画，请完成以下步骤：
- en: 'Open the `ShowHidePanels.cs` script. Comment out all the code in the `Start()`
    and `Update()` methods that use `TogglePanel()`. After you comment out those lines,
    you should see the following:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ShowHidePanels.cs` 脚本。注释掉 `Start()` 和 `Update()` 方法中所有使用 `TogglePanel()`
    的代码。在注释掉这些行之后，您应该看到以下内容：
- en: '[PRE2]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instead of referencing the `Pause Panel` and `Inventory Panel` with their Canvas
    Group components, we’ll now reference them with their Animator components. Create
    the following two variable declarations at the top of the class:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再使用它们的 Canvas Group 组件来引用 `Pause Panel` 和 `Inventory Panel`，而是现在使用它们的 Animator
    组件。在类的顶部创建以下两个变量声明：
- en: '[PRE3]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let’s create a new method called `FadePanel()` that accepts `Animator`
    and `bool` parameters:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的方法，称为 `FadePanel()`，它接受 `Animator` 和 `bool` 参数：
- en: '[PRE4]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Update the `Update()` method to now call the new `FadePanel()` method where
    the `TogglePanel()` method was once called. The bolded text in the following code
    signifies the added code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Update()` 方法，现在在曾经调用 `TogglePanel()` 方法的地方调用新的 `FadePanel()` 方法。以下代码中加粗的文本表示添加的代码：
- en: '[PRE5]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s all we have to do to the code.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们需要对代码所做的所有更改。
- en: 'Drag the `Inventory Panel` and the `Pause Panel` into their appropriate slots
    on the **Show Hide** **Panels** component:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Inventory Panel` 和 `Pause Panel` 拖动到 **显示/隐藏** **面板** 组件的相应插槽中：
- en: '![Figure 14.41: The properties of the Show Hide Panels component](img/Figure_14.41_B18327.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.41：显示/隐藏面板组件的属性](img/Figure_14.41_B18327.jpg)'
- en: 'Figure 14.41: The properties of the Show Hide Panels component'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.41：显示/隐藏面板组件的属性
- en: 'Play the game and watch it kind of work. `Inventory Panel` should appear and
    disappear as necessary, but the `Pause Panel` won’t fade out the way it is supposed
    to. This is because the following line of code stops all animations from happening
    that depend on time scale:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并观察它是否大致工作。`Inventory Panel` 应根据需要显示和消失，但 `Pause Panel` 不会像预期的那样淡出。这是因为以下代码行阻止了所有依赖于时间缩放的动画发生：
- en: '[PRE6]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That line of code was used to effectively pause the game. However, that means
    it’s pausing our `Pause Panel` pop-up animation. Don’t worry, you can still use
    this simple pause code and run animations when the game is paused. All you have
    to do is tell the Animator on the `Pause Panel` that it can still function when
    the time scale is set to `0`. You do this by changing the **Update Mode** on the
    Animator component from **Normal** to **Unscaled Time**:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那行代码被用来有效地暂停游戏。然而，这意味着它将暂停我们的 `Pause Panel` 弹出动画。别担心，你仍然可以使用这个简单的暂停代码，并在游戏暂停时运行动画。你只需要告诉
    `Pause Panel` 上的 Animator，当时间尺度设置为 `0` 时，它仍然可以工作。你可以通过将 Animator 组件上的 **Update
    Mode** 从 **Normal** 更改为 **Unscaled Time** 来做到这一点：
- en: '![Figure 14.42: Setting Update Mode to Unscaled Time](img/Figure_14.42_B18327.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.42：将 Update Mode 设置为 Unscaled Time](img/Figure_14.42_B18327.jpg)'
- en: 'Figure 14.42: Setting Update Mode to Unscaled Time'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.42：将 Update Mode 设置为 Unscaled Time
- en: Set the `Inventory Panel`’s Animator component as well.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也要设置 `Inventory Panel` 的 Animator 组件。
- en: Play the game, and you should have smoothly animating Pause and Inventory Panels.
    We can now move on to a more complex animation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏，你应该会有平滑动画的暂停和库存面板。我们现在可以继续到更复杂的动画。
- en: Animating a complex loot box
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画复杂宝箱
- en: For this example, we’ll work with a new scene. The animation we will create
    is a bit complicated—a chest will fly into the scene and then wait for the player
    to open it. Once the player opens it, the chest will animate open with a particle
    system that pops in front of it. Then, three collectibles will fly out in sequence.
    Each collectible will have its own *shiny* animation that begins to play.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用一个新的场景。我们将创建的动画稍微复杂一些——一个宝箱将飞入场景，然后等待玩家打开它。一旦玩家打开它，宝箱将使用粒子系统在它前面弹出动画打开。然后，三个可收集物品将依次飞出。每个可收集物品都将有自己的
    *闪亮* 动画开始播放。
- en: 'The following figure is a storyboard of sorts that shows a few keyframes of
    the animation playing out:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是一种故事板，显示了动画播放的一些关键帧：
- en: '![Figure 14.43: The final version of the animation from this example](img/Figure_14.43_B18327.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.43：本例动画的最终版本](img/Figure_14.43_B18327.jpg)'
- en: 'Figure 14.43: The final version of the animation from this example'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.43：本例动画的最终版本
- en: In this chapter, we will cover all items except for the Particle System, which
    we will cover in the next chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖所有项目，除了粒子系统，我们将在下一章中介绍。
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The chest sprite sheet was obtained from [https://bayat.itch.io/platform-game-assets](https://bayat.itch.io/platform-game-assets)
    and the item sprite sheets were obtained from [https://opengameart.org/content/shining-coin-shining-health-shining-power-up-sprite-sheets](https://opengameart.org/content/shining-coin-shining-health-shining-power-up-sprite-sheets).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 胸部精灵图集是从 [https://bayat.itch.io/platform-game-assets](https://bayat.itch.io/platform-game-assets)
    获得的，而物品精灵图集是从 [https://opengameart.org/content/shining-coin-shining-health-shining-power-up-sprite-sheets](https://opengameart.org/content/shining-coin-shining-health-shining-power-up-sprite-sheets)
    获得的。
- en: This example has a lot going on with it. It is not particularly complicated
    to build out, but providing the steps to build it entirely from scratch would
    require too many steps. That would go beyond the scope of this book; but at this
    point in the book, you can hopefully look at a scene that’s already been built
    out and understand how it was achieved. Therefore, we will start this example
    with a package file that has all the items placed in the scene, some of the animations
    already created, and all the new sprite sheets included.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有很多内容。它构建起来并不特别复杂，但提供从头开始构建它的步骤会需要太多步骤。这超出了本书的范围；但在这个书的这个阶段，你 hopefully
    可以查看一个已经构建好的场景，并理解它是如何实现的。因此，我们将从这个示例的包文件开始，其中包含了场景中放置的所有项目，一些已经创建的动画，以及所有新的精灵图集。
- en: Before you begin, import the `Chapter 14` `- Examples - LootBox - Start.unitypackage`
    asset package.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，导入 `Chapter 14` `- Examples - LootBox - Start.unitypackage` 资产包。
- en: If you’d like to view the completed example, view the package labeled `Chapter
    14` `- Examples - LootBox -` `End.unitypackage`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看完成的示例，请查看标记为 `Chapter 14` `- Examples - LootBox -` `End.unitypackage`
    的包。
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unity Layers do not save in Unity asset packages. The example will describe
    creating a Layer named **UI Particles** and having the cameras ignore or include
    the Layer, but this is not displayed in the provided package.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 层不会保存在 Unity 资产包中。本例将描述创建一个名为 **UI Particles** 的层，并让相机忽略或包含该层，但这在提供的包中并未显示。
- en: 'To make the example easier to absorb, I have broken the steps into three distinct
    sections. To complete this example, we will perform the following functions:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例更容易吸收，我已经将步骤分为三个不同的部分。为了完成这个示例，我们将执行以下功能：
- en: Set up the various animation clips for the individual items.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置各个项目的各种动画片段。
- en: Tie all the animations together and make sure that they are timed appropriately
    using a state machine, aka Animator.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用状态机，即动画控制器，将所有动画连接起来，并确保它们的时间安排适当。
- en: Create the Particle System that displays when the chest opens and make sure
    that it displays properly within the UI (which will be completed in the following
    chapter).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建在箱子打开时显示的粒子系统，并确保它在UI中正确显示（将在下一章完成）。
- en: Setting up the animations
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置动画
- en: 'Let’s start this section by creating the animations for each of the objects
    within the scene. To create all the animations for this scene, complete the following
    steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为场景中的每个对象创建动画开始这个部分。为了创建这个场景的所有动画，请完成以下步骤：
- en: 'If you have not done so already, import `Chapter 14` `- Examples - LootBox
    - Start.unitypackage`. You should see a scene that has two Canvases—one with a
    button and a background image and another with a chest, items, and a button, as
    shown in the following screenshot:![Figure 14.44: The scene layout of the package](img/Figure_14.44_B18327.jpg)'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，导入`Chapter 14` `- Examples - LootBox - Start.unitypackage`。你应该看到一个场景，其中有两个画布——一个带有按钮和背景图像，另一个带有箱子、物品和按钮，如下面的截图所示：![图14.44：包的场景布局](img/Figure_14.44_B18327.jpg)
- en: 'Figure 14.44: The scene layout of the package'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.44：包的场景布局
- en: After importing the package, you will also note that there are a few animation
    clips and controllers provided in the `Assets` folder.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入包之后，你也会注意到在`Assets`文件夹中提供了一些动画片段和控制器。
- en: The `Chest` object needs two animations, one of it *flying in from the side
    of the screen* and one of its *sprite sheet opening*. Let’s make the flying in
    animation first. Select the `Chest` object in the Hierarchy and then select `ChestFlyingIn.anim`
    and save it in the `Assets/Animations/LootBox/Clips` folder.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chest`对象需要两个动画，一个是它从屏幕的侧面*飞入*的动画，另一个是它的*精灵表打开*的动画。让我们先制作飞入动画。在层级中选择`Chest`对象，然后选择`ChestFlyingIn.anim`，并将其保存到`Assets/Animations/LootBox/Clips`文件夹中。'
- en: A new Animation Controller named `Chest.controller` was automatically created
    in the `Assets/Animations/LootBox/Clips` folder. Move it to the `Assets/Animations/LootBox/Controllers`
    folder.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Animations/LootBox/Clips`文件夹中自动创建了一个名为`Chest.controller`的新动画控制器。将其移动到`Assets/Animations/LootBox/Controllers`文件夹。
- en: 'Within the Animation window, select `Chest` within the Canvas:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画窗口中，在画布中选择`Chest`：
- en: '![Figure 14.45: The ChestFlyingIn animation](img/Figure_14.45_B18327.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图14.45：ChestFlyingIn动画](img/Figure_14.45_B18327.jpg)'
- en: 'Figure 14.45: The ChestFlyingIn animation'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.45：ChestFlyingIn动画
- en: Currently, the animation is one second long, which is a bit longer than we want.
    Move the second keyframe to the `0:30` mark so that it will be half a second long.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，动画时长为一秒，这比我们想要的要长一些。将第二个关键帧移动到`0:30`标记，使其时长为半秒。
- en: We will be moving objects in the scene at various keyframes and will want them
    to be saved in the animation. So, to have the animation record any of the changes
    you make in the scene, select the record button in the Animation window.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在场景中移动对象到不同的关键帧，并希望它们被保存在动画中。因此，为了使动画记录你在场景中做的任何更改，请在动画窗口中选择记录按钮。
- en: 'The position of the chest in the scene right now is where we want it to be
    at the end of the fly-in animation, so we will not affect the position at the
    second keyframe. However, we want it to start off screen, so with the animation
    playhead on the first frame, use the `Chest`’s position at the first frame. This
    is indicated by the red tint on the Rect Transform.![Figure 14.46: Moving the
    chest and recording the properties](img/Figure_14.46_B18327.jpg)'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前场景中`Chest`的位置就是我们希望在飞入动画结束时所在的位置，所以我们不会在第二个关键帧上影响位置。然而，我们希望它从屏幕外开始，所以当动画播放头在第一帧时，使用`Chest`的第一帧位置。这由Rect
    Transform上的红色色调表示。![图14.46：移动箱子并记录属性](img/Figure_14.46_B18327.jpg)
- en: 'Figure 14.46: Moving the chest and recording the properties'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.46：移动箱子并记录属性
- en: If you scrub the playhead, you will see the chest move from left to right.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你拖动播放头，你会看到箱子从左向右移动。
- en: 'Now, let’s make the chest fly in at an arc instead of a straight line. We’ll
    do this with Animation Curves. Select the **Curves** tab, as follows:![Figure
    14.47: Selecting the Curves menu](img/Figure_14.47_B18327.jpg)'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们让胸部以弧线而不是直线飞入。我们将使用动画曲线来完成这个操作。选择**曲线**选项卡，如下所示：![图14.47：选择曲线菜单](img/Figure_14.47_B18327.jpg)
- en: 'Figure 14.47: Selecting the Curves menu'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.47：选择曲线菜单
- en: The green line represents the *y* property of the anchored position. Select
    the **Anchored Postion.y** property to focus on it.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 绿色线代表锚定位置的**y**属性。选择**Anchored Position.y**属性以关注它。
- en: 'Select the first and second key frame anchors to affect their handles. Move
    their handles until the green curve looks more like an arc:![Figure 14.48: Adjusting
    the anchors of the curve](img/Figure_14.48_B18327.jpg)'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一和第二个关键帧锚点以影响它们的句柄。移动它们的句柄，直到绿色曲线看起来更像一个弧线：![图14.48：调整曲线的锚点](img/Figure_14.48_B18327.jpg)
- en: 'Figure 14.48: Adjusting the anchors of the curve'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.48：调整曲线的锚点
- en: Now, when you play the animation, you will see the chest move in an arcing path.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当你播放动画时，你会看到胸部沿着弧线移动。
- en: 'Let’s have the chest fade in as it flies by adding a `color` property to the
    animation. Return to the `0` to make the chest invisible on the first frame:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让胸部在飞过时淡入，向动画中添加一个`color`属性。返回到`0`使胸部在第一帧不可见：
- en: '![Figure 14.49: The properties of the first frame of the ChestFlyingIn animation](img/Figure_14.49_B18327.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图14.49：ChestFlyingIn动画第一帧的属性](img/Figure_14.49_B18327.jpg)'
- en: 'Figure 14.49: The properties of the first frame of the ChestFlyingIn animation'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.49：ChestFlyingIn动画第一帧的属性
- en: Whenever a new animation is created, it is automatically set to loop. We don’t
    want this animation to play on a loop, so select the `ChestFlyingIn` Animation
    Clip from the **Project** view to see its **Inspector** properties. Deselect the
    **Loop** **Time** checkbox.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次创建新动画时，它都会自动设置为循环。我们不希望这个动画循环播放，所以从**项目**视图中选择`ChestFlyingIn`动画剪辑以查看其**检查器**属性。取消选择**Loop**
    **Time**复选框。
- en: We don’t want the `ChestFlyingIn` Animation Clip to automatically play when
    the scene starts. Since this was the first Animation Clip created for the `Chest`,
    it will be set to the Animator default state. With the `Chest` selected, open
    the Animator Window.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望`ChestFlyingIn`动画剪辑在场景开始时自动播放。由于这是为`Chest`创建的第一个动画剪辑，它将被设置为动画器的默认状态。选择`Chest`，打开动画器窗口。
- en: Create a new default state by right-clicking within the Animator Window and
    selecting `Empty State` and set it as the default state by right-clicking on it
    and selecting **Set as Layer Default State**. We will do more with the Chest’s
    Animator later, but for now, this is all we are going to do.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在动画器窗口内右键单击并选择`Empty State`创建一个新的默认状态，并通过右键单击并选择**设置为层默认状态**将其设置为默认状态。我们将在稍后对胸部的动画器做更多操作，但现在我们只做这些。
- en: '![Figure 14.50: The Animator of the Chest](img/Figure_14.50_B18327.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图14.50：胸部的动画器](img/Figure_14.50_B18327.jpg)'
- en: 'Figure 14.50: The Animator of the Chest'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.50：胸部的动画器
- en: 'Now, let’s set up the chest opening animation. With `Chest` still selected,
    in the Animation window, select **Create New Clip…** from the Animation Clip dropdown
    list:![Figure 14.51: Creating a new clip](img/Figure_14.51_B18327.jpg)'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置胸部的开启动画。在仍然选择`Chest`的情况下，在动画窗口中，从动画剪辑下拉列表中选择**创建新剪辑…**![图14.51：创建新剪辑](img/Figure_14.51_B18327.jpg)
- en: 'Figure 14.51: Creating a new clip'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.51：创建新剪辑
- en: Name the new Animation Clip `ChestOpening.anim` and save it in the `Assets/Animations/LootBox/Clips`
    folder.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将新的动画剪辑命名为`ChestOpening.anim`，并将其保存在`Assets/Animations/LootBox/Clips`文件夹中。
- en: 'This Animation Clip will contain all the sprites from the sprite sheet. From
    the Project view, drag and drop all the sub-sprites into the Animation timeline.
    A new property for **Image.Sprite** will automatically be added, and all the sub-sprites
    will be added to the timeline in a sequence:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个动画剪辑将包含来自精灵图的全部精灵。从项目视图中，将所有子精灵拖放到动画时间轴上。将自动添加一个新的属性**Image.Sprite**，所有子精灵将按顺序添加到时间轴上：
- en: '![Figure 14.52: The Chest sprite sheet animation](img/Figure_14.52_B18327.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图14.52：胸部的精灵图动画](img/Figure_14.52_B18327.jpg)'
- en: 'Figure 14.52: The Chest sprite sheet animation'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.52：胸部的精灵图动画
- en: Right now, the animation is way too fast. It is running at 60 frames per second,
    and there are only 6 frames. We need to change the frame rate. First, we must
    enable the Sample Rate option in the Animation Window. Select the three dots on
    the timeline and then select **Show** **Sample Rate**.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，动画播放得太快。它以每秒 60 帧的速度运行，只有 6 帧。我们需要更改帧率。首先，我们必须在动画窗口中启用采样率选项。选择时间轴上的三个点，然后选择**显示**
    **采样率**。
- en: '![Figure 14.53: Enabling the Sample Rate menu item](img/Figure_14.53_B18327.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.53：启用采样率菜单项](img/Figure_14.53_B18327.jpg)'
- en: 'Figure 14.53: Enabling the Sample Rate menu item'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.53：启用采样率菜单项
- en: 'Now that the `12`; this will change the animation’s frame rate to `12` fps:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`12`；这将更改动画的帧率为`12` fps：
- en: '![Figure 14.54: Changing the Sample Rate](img/Figure_14.54_B18327.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.54：更改采样率](img/Figure_14.54_B18327.jpg)'
- en: 'Figure 14.54: Changing the Sample Rate'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.54：更改采样率
- en: Since `Chest` has an animation that will affect its alpha value, let’s ensure
    that this animation has full alpha whenever it plays. Select `1` on both the first
    and last frames.¶Technically, we only need the alpha set to `1` on the first frame,
    but I like to add a start and end frame here so that I am very sure about what
    the animation is doing with that value.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`胸`有一个会影响其alpha值的动画，让我们确保这个动画在播放时始终具有全alpha值。在第一帧和最后一帧上选择`1`。实际上，我们只需要在第一帧上将alpha设置为`1`，但我喜欢在这里添加起始帧和结束帧，这样我就可以非常确定动画是如何使用这个值的。
- en: We don’t want this animation to play on a loop, so select the `ChestOpening`
    Animation Clip from the **Project** view to take a look at its **Inspector** properties.
    Deselect the **Loop** **Time** checkbox.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望这个动画循环播放，所以从**项目**视图中选择`ChestOpening`动画剪辑，查看其**检查器**属性。取消选择**循环** **时间**复选框。
- en: All of the other animations needed for this example have already been set up.
    They are very similar to this one in setup or the ones created in the preceding
    example. However, they are not hooked up to the correct GameObjects.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本例所需的所有其他动画都已设置。它们的设置与这个类似，或者与前面示例中创建的类似。然而，它们并没有连接到正确的游戏对象。
- en: Let’s give the other objects in `Chest Open Canvas` their animations. Drag the
    `Coin` Animator to the Inspector of the `Coin` GameObject, the `Heart` Animator
    to the Inspector of the `Heart` GameObject, and the `PowerUp` Animator to the
    `PowerUp` GameObject’s Inspector. Each of these Animators can be found in the
    `Assets/Animations/Loot Box/Controllers` folder. You can now preview the animations
    of all the items popping out of the chests and shining by selecting the GameObjects
    and pressing play in the Animation window (Play in the Game view will not yet
    show the animations playing).
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们给`胸打开画布`中的其他对象添加动画。将`硬币`动画控制器拖到`硬币`游戏对象的检查器中，将`心形`动画控制器拖到`心形`游戏对象的检查器中，将`升级`动画控制器拖到`升级`游戏对象的检查器中。这些动画控制器都可以在`Assets/Animations/Loot
    Box/Controllers`文件夹中找到。现在，您可以通过选择游戏对象并在动画窗口中按播放来预览所有物品从胸中弹出并发光的动画（在游戏视图中按播放将不会显示正在播放的动画）。
- en: Let’s initialize the `Chest` and all of the objects as invisible. Select the
    `Chest`, `Coin`, `Heart`, and `PowerUp` GameObjects from the Hierarchy. In their
    Image component, change the alpha values of their `0`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们初始化`胸`以及所有对象为不可见。从层次结构中选择`胸`、`硬币`、`心形`和`升级`游戏对象。在其图像组件中，更改它们的`0`的alpha值。
- en: The `Chest Open Canvas` and the `Button` on that Canvas both have animations
    as well. These animations will affect a Canvas Group component on the objects.
    Right now, they don’t have Canvas Group components, though. So, add a Canvas Group
    component to `Chest Open Canvas` and its child `Button`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`胸打开画布`和该画布上的`按钮`都有动画。这些动画将影响对象上的Canvas Group组件。目前，它们还没有Canvas Group组件。因此，向`胸打开画布`及其子`按钮`添加Canvas
    Group组件。'
- en: Initialize the two new Canvas Group components to have `0` and their `false`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化两个新的Canvas Group组件，使其alpha值为`0`，并设置为`false`。
- en: You should now only see the Start Button in the scene.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，场景中应该只看到开始按钮。
- en: Now, add the `CanvasGroupFadeInOut` Animator to `Chest Open Canvas` and its
    child `Button`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向`胸打开画布`及其子`按钮`添加`CanvasGroupFadeInOut`动画控制器。
- en: The animations are now completely set up for each of the objects. We still need
    to finish working on the Animator Controller for the `Chest` and add some more
    logic for the various Animators, but we are done with the Animation Clips for
    now.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个对象的动画都已完全设置。我们仍然需要完成`胸`的动画控制器的工作，并为各种动画器添加一些更多逻辑，但现在我们已经完成了动画剪辑。
- en: Building a State Machine and timing the animations
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建状态机并设置动画时间
- en: The next thing to do is set up our state machine and write the code that will
    make the various animations play.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置我们的状态机并编写代码，使各种动画在正确的时间播放。
- en: 'To hook up the various animations and have them play at the correct time, complete
    the following steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接各种动画并在正确的时间播放，完成以下步骤：
- en: We’ll start by creating the state machine that will work as the logic for our
    animation sequences. Create a new Animator Controller named `ChestOpeningStateMachine.controller`
    in `Assets/Animations/Loot Box/Controllers`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个状态机，它将作为我们动画序列的逻辑。在`Assets/Animations/Loot Box/Controllers`中创建一个新的Animator
    Controller，命名为`ChestOpeningStateMachine.controller`。
- en: 'Open the `ChestOpeningStateMachine` Animator Controller and create 12 new Empty
    States. Arrange, name, and transition the States, as shown in the following screenshot:![Figure
    14.55: The State Machine for the Animation](img/Figure_14.55_B18327.jpg)'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ChestOpeningStateMachine` Animator Controller并创建12个新的空状态。按照以下屏幕截图中的方式排列、命名和转换状态：![图14.55：动画的状态机](img/Figure_14.55_B18327.jpg)
- en: 'Figure 14.55: The State Machine for the Animation'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.55：动画的状态机
- en: The state machine shown in the preceding screenshot demonstrates the sequence
    of events for the animations and interactions of the chest opening. The states
    labeled **Waiting On Player** will *play* when the game is waiting for the player
    to press a button to proceed with the animation. The other animations will automatically
    play based on timed events.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个屏幕截图中的状态机展示了打开胸部动画的事件序列和交互。标记为**等待玩家**的状态将在游戏等待玩家按下按钮以继续动画时播放。其他动画将根据定时事件自动播放。
- en: The state machine created in the previous steps will not actually contain any
    animations. It is simply a flow chart describing what is currently happening in
    the game. We will also use it to send information to the various objects in the
    scene to let them know what they should or should not be doing. Since we just
    want this to control the logic of this sequence, and not actually animate anything
    in the scene, we can add it on an Animator component to any object in the scene.
    Therefore, let’s add it to the `Main Camera`. Drag the `ChestOpeningStateMachine`
    Animator from the project view to the Inspector of the `Main Camera`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步骤中创建的状态机实际上不会包含任何动画。它仅仅是一个流程图，描述了游戏中当前正在发生的情况。我们还将使用它向场景中的各种对象发送信息，让它们知道它们应该或不应该做什么。由于我们只想用这个来控制这个序列的逻辑，而不是在场景中实际动画化任何东西，我们可以在场景中的任何对象上添加一个Animator组件。因此，让我们将其添加到`Main
    Camera`上。从项目视图中拖动`ChestOpeningStateMachine` Animator到`Main Camera`的检查器中。
- en: Now, we will need to set the conditions of transition for the various states
    within the state machine. Create four animation Trigger Parameters, named `ShowChest`,
    `OpenChest`, `CloseChest`, and `AnimationComplete`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置状态机中各种状态的转换条件。创建四个动画触发参数，分别命名为`ShowChest`、`OpenChest`、`CloseChest`和`AnimationComplete`。
- en: 'Now, set Trigger Conditions for each transition, as shown in the following
    screenshot; with each transition, make sure that you deselect **Has Exit Time**
    and **Fixed Duration**:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为每个转换设置触发条件，如图下所示；对于每个转换，确保取消选择**Has Exit Time**和**Fixed Duration**：
- en: '![Figure 14.56: The triggers for the various transitions](img/Figure_14.56_B18327.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图14.56：各种转换的触发器](img/Figure_14.56_B18327.jpg)'
- en: 'Figure 14.56: The triggers for the various transitions'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.56：各种转换的触发器
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I highly recommend that you bookmark this image or print out a screenshot of
    your **ChestOpeningStateMachine** Animator while working through this example.
    Having this as a flow chart that you can easily reference while working on this
    example will make the steps being completed a lot easier to follow.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你在处理这个示例时将此图像添加到书签或打印出你的**ChestOpeningStateMachine** Animator的屏幕截图。在处理这个示例时，拥有这样一个你可以轻松参考的流程图将使完成的步骤更容易遵循。
- en: 'Before we write code, let’s set up the Animator for the `Chest`. Currently,
    the Animator of the `Chest` should look something as follows:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写代码之前，让我们为`Chest`设置Animator。目前，`Chest`的Animator应该看起来像以下这样：
- en: '![Figure 14.57: The Chest Animator](img/Figure_14.57_B18327.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图14.57：胸部的Animator](img/Figure_14.57_B18327.jpg)'
- en: 'Figure 14.57: The Chest Animator'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.57：胸部的Animator
- en: 'The Animator only contains the animation states but does not yet indicate how
    they are all connected. We will need to create transitions and set up the Animation
    Parameters. Rearrange the states and add transitions to the Animator so it appears
    as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 动画器仅包含动画状态，但尚未指示它们是如何相互连接的。我们需要创建过渡并设置动画参数。重新排列状态并向动画器添加过渡，使其看起来如下：
- en: '![Figure 14.58: The Chest Animator updated](img/Figure_14.58_B18327.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.58：更新的胸部动画器](img/Figure_14.58_B18327.jpg)'
- en: 'Figure 14.58: The Chest Animator updated'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.58：更新的胸部动画器
- en: Create three animation Trigger Parameters, named `ShowChest`, `OpenChest`, and
    `Reset`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个动画触发参数，分别命名为`ShowChest`、`OpenChest`和`Reset`。
- en: 'Now, set Trigger Conditions for each transition, as shown in the following
    screenshot; with each transition, make sure that you deselect **Has Exit Time**
    and **Fixed Duration**:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为每个过渡设置触发条件，如以下截图所示；确保在每次过渡中取消选择**Has Exit Time**和**Fixed Duration**：
- en: '![Figure 14.59: The Triggers of the Chest Animator](img/Figure_14.59_B18327.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.59：胸部动画器的触发器](img/Figure_14.59_B18327.jpg)'
- en: 'Figure 14.59: The Triggers of the Chest Animator'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.59：胸部动画器的触发器
- en: Now that our Animators are all appropriately set, we can begin coding. We will
    use the `ChestOpeningStateMachine` Animator to make each appropriate animation
    play when the player clicks on the specified button during the specified state.
    The `ChestOpeningStateMachine` Animator will then automatically set the appropriate
    triggers on the Animators on the various objects that appear in the full animated
    sequence. We need a way to keep track of which items in the scene have Animators
    that will be controlled by the `ChestOpeningStateMachine` Animator, what their
    various parameters are, and what conditions need to be met to have those parameters
    set. We’ll keep track of all of this information in a single script. Create a
    new script called `ChestAnimControls` and save it in `Assets/Scripts/LootBox`.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所有的动画器都已适当地设置，我们可以开始编码。我们将使用`ChestOpeningStateMachine`动画器，在玩家在指定状态下点击指定的按钮时，使每个适当的动画播放。然后`ChestOpeningStateMachine`动画器将自动设置出现在完整动画序列中的各种对象上的动画器上的适当触发器。我们需要一种方法来跟踪场景中哪些项目具有由`ChestOpeningStateMachine`动画器控制的动画器，它们的各项参数是什么，以及需要满足哪些条件才能设置这些参数。我们将把这些信息都记录在一个脚本中。创建一个新的脚本，命名为`ChestAnimControls`，并将其保存在`Assets/Scripts/LootBox`中。
- en: 'To give us a nice, clean way of keeping track of all of the necessary information,
    we’ll use classes and an enumerated list (I’ll explain what these are and why
    we are using them momentarily). Delete the `Start()` and `Update()` functions
    from the `ChestAnimControls` class, and write the following code:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给我们一个优雅、干净的方式来跟踪所有必要的信息，我们将使用类和枚举列表（我将在稍后解释这些是什么以及为什么我们使用它们）。从`ChestAnimControls`类中删除`Start()`和`Update()`函数，并编写以下代码：
- en: '[PRE7]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ll note that the preceding code has the following three parts: the `TypesOfParameters`
    enumerated, the `ParameterProperties` class, and the `AnimatorProperties` class.
    First, let’s look at the `TypesOfParameters` enumerated. This is a list of the
    types of Animator Parameters that can be used within an Animator. An enumerated
    list is a custom type that contains a set of constants that are represented with
    names. A benefit of using an enumerated list is that the list appears as a dropdown
    menu within the Inspector. Now, let’s look at the `ParameterProperties` class.
    Each object that is animated within the scene has a set of properties related
    to its Animator Parameters that we need to keep track of. A class can be an effective
    tool for grouping sets of data together. Therefore, I used a class to group the
    name of the parameter, which state the parameter will be set in, what type of
    parameter it is, and its value if it is a `float`, `integer`, or `Boolean` parameter.
    Note that the type of parameter is defined using the enumerated list, `TypesOfParameters`.
    This was done because there is a finite and specific set of parameters available
    for each animator parameter. Now, let’s look at the `AnimatorProperties` subclass.
    For each object in the scene, we will need to keep track of its name, its animator,
    and all of its parameters along with the conditions in which they are set. Note
    that the list of parameters and their properties is defined by the `ParameterProperties`
    class. A big benefit of working with Unity is the ability to assign and view public
    variables in the Inspector. However, when you create a class within a class, the
    public variables are not visible within the Inspector unless you place `[System.Serializable]`
    above the class. This gives the subclass the `Serializable` attribute and allows
    its public variables to be visible in the Inspector.'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到前面的代码有三个部分：`TypesOfParameters`枚举、`ParameterProperties`类和`AnimatorProperties`类。首先，让我们看看`TypesOfParameters`枚举。这是一个Animator参数类型列表，可以在Animator中使用。枚举列表是一个包含一组用名称表示的常量的自定义类型。使用枚举列表的好处是列表在检查器中显示为下拉菜单。现在，让我们看看`ParameterProperties`类。场景中每个被动画化的对象都有一组与其Animator参数相关的属性，我们需要跟踪这些属性。类可以是一个有效的工具，用于将数据集分组在一起。因此，我使用类来分组参数名称、参数将被设置的状态、参数的类型以及如果是`float`、`integer`或`Boolean`参数，其值。请注意，参数类型是使用枚举列表`TypesOfParameters`定义的。这样做是因为每个动画师参数都有有限和特定的参数集。现在，让我们看看`AnimatorProperties`子类。对于场景中的每个对象，我们需要跟踪其名称、其动画师以及所有参数及其设置条件。请注意，参数及其属性的列表由`ParameterProperties`类定义。与Unity一起工作的一个重大好处是能够在检查器中分配和查看公共变量。然而，当你在一个类内部创建一个类时，公共变量在检查器中是不可见的，除非你在类上方放置`[System.Serializable]`。这给子类赋予了`Serializable`属性，并允许其公共变量在检查器中可见。
- en: Note
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I would like to point out that this code allows for the Animators to have **Float**,
    **Int**, and **Bool** parameters, even though the only parameters we use in any
    of our Animators are Triggers. I wrote it in this way to make it work more universally
    so that you can reuse this code for other animations in the future.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，这段代码允许动画师拥有**浮点数**、**整数**和**布尔值**参数，尽管我们在任何动画师中使用的唯一参数是触发器。我这样写是为了使其更通用，以便你可以在未来的其他动画中重用此代码。
- en: 'If you find the code we wrote in the preceding step overwhelming, don’t worry—seeing
    it all listed out in the Inspector will clear it up a bit. All we have done so
    far is set up a few different groups of data. Now, we will need to create a variable
    that will use the information. We need a list of all animated items, so add the
    following code to your script:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你觉得我们在前一步写的代码令人眼花缭乱，别担心——在检查器中看到所有内容列出来会稍微清晰一些。到目前为止，我们只是设置了几组不同的数据。现在，我们需要创建一个变量来使用这些信息。我们需要所有动画项目的列表，所以请将以下代码添加到你的脚本中：
- en: '[PRE8]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Attach the `ChestAnimControls` script to the `Main Camera` by dragging it into
    its Inspector.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其拖动到其检查器中，将`ChestAnimControls`脚本附加到`主相机`。
- en: 'In the Inspector of the `Main Camera`, click on the arrow next to **Animated
    Items** to expand the list:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`主相机`的检查器中，点击**动画项目**旁边的箭头以展开列表：
- en: '![Figure 14.60: The Chest Anim Controls component](img/Figure_14.60_B18327.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图14.60：胸动画控制组件](img/Figure_14.60_B18327.jpg)'
- en: 'Figure 14.60: The Chest Anim Controls component'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.60：胸动画控制组件
- en: 'We have a total of six items that need to have their Animators controlled by
    this script and the State Machine we created. So, change the List’s size to `6`.
    Expand **Animator Items** | **Element 0** and its **Animator Parameters**:![Figure
    14.61: The AnimatorProperties of the Chest Anim Controls](img/Figure_14.61_B18327.jpg)'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总共有六个项目需要由这个脚本和我们所创建的状态机来控制它们的动画师。因此，将列表的大小改为`6`。展开**Animator Items** | **Element
    0**及其**Animator Parameters**：![图 14.61：胸部的动画控制属性](img/Figure_14.61_B18327.jpg)
- en: 'Figure 14.61: The AnimatorProperties of the Chest Anim Controls'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.61：胸部的动画控制属性
- en: Remember that the `animatedItems` variable was a list of `AnimatorProperties`.
    So, `AnimatorProperties` class.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，`animatedItems`变量是一个`AnimatorProperties`列表。所以，`AnimatorProperties`类。
- en: 'The first item we will need to list data for is the `Chest Open Canvas` GameObject.
    Type `Chest Open Canvas` in the `Chest Open Canvas` from the Hierarchy into the
    `Chest Open Canvas` in the **Name** slot, you’ll see that the **Element 0** label
    is replaced with **Chest Open Canvas**. Whenever you have a list of objects in
    Unity’s Inspector, if the first item in the object is a string, the string will
    replace the **Element** **x** label:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要列出数据的第一个项目是`Chest Open Canvas` GameObject。在层次结构中将`Chest Open Canvas`从`Chest
    Open Canvas`输入到**名称**槽中，你会看到**Element 0**标签被替换为**Chest Open Canvas**。每次你在Unity的检查器中有一个对象的列表时，如果对象中的第一个是字符串，该字符串将替换**元素**
    **x** 标签：
- en: '![Figure 14.62: The Chest Open Canvas properties](img/Figure_14.62_B18327.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.62：胸部的打开画布属性](img/Figure_14.62_B18327.jpg)'
- en: 'Figure 14.62: The Chest Open Canvas properties'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.62：胸部的打开画布属性
- en: 'Now, we will need to list out all the parameters that are used within `Chest
    Open Canvas`’s Animator and the conditions under which it is set. It has two parameters
    that we need to list data for, so change the size of `2`. Expand the two resulting
    **Elements**, as follows:![Figure 14.63: The ParameterProperties and TypesOfParameters](img/Figure_14.63_B18327.jpg)'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要列出`Chest Open Canvas`的动画器中使用的所有参数及其设置条件。它有两个我们需要列出数据的参数，所以将大小改为`2`。展开两个生成的**元素**，如下所示：![图
    14.63：参数属性和参数类型](img/Figure_14.63_B18327.jpg)
- en: 'Figure 14.63: The ParameterProperties and TypesOfParameters'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.63：参数属性和参数类型
- en: Remember that the `animatorParameters` variable was a list of `ParameterProperties`.
    So, the two `ParameterProperties` class. Additionally, within the `ParameterProperties`
    class, `parameterType` was a `TypesOfParameters` variable. `TypesOfParameters`
    was an enumerated list, so any variable of that type will appear as a dropdown
    menu with the options that appeared within the defined list.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，`animatorParameters`变量是一个`ParameterProperties`列表。所以，有两个`ParameterProperties`类。此外，在`ParameterProperties`类中，`parameterType`是一个`TypesOfParameters`变量。`TypesOfParameters`是一个枚举列表，所以任何该类型的变量将显示为一个下拉菜单，其中包含在定义的列表中出现的选项。
- en: 'We now need to list out each Parameter of the `Chest Open Canvas`, `ChestOpeningStateMachine`
    will cause the Parameter to be set, and specify its **Parameter Type**:![Figure
    14.64: The Chest Open Canvas properties](img/Figure_14.64_B18327.jpg)'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要列出`Chest Open Canvas`的每个参数，`ChestOpeningStateMachine`将设置参数，并指定其**参数类型**：![图
    14.64：胸部的打开画布属性](img/Figure_14.64_B18327.jpg)
- en: 'Figure 14.64: The Chest Open Canvas properties'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.64：胸部的打开画布属性
- en: Since each is a Trigger Animator Parameter, we do not have to worry about the
    values for **Float Value**, **Int Value**, or **Bool Value**.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于每个都是触发动画参数，我们不需要担心**浮点值**、**整数值**或**布尔值**的值。
- en: 'Now, we can fill in the Animator information for the other five animated objects
    in the same way we filled out the information for the `Chest Open Canvas`. Fill
    in the information for the animator of `Chest` as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像填写`Chest Open Canvas`的信息一样，以同样的方式填写其他五个动画对象的动画师信息。按照以下方式填写`Chest`的动画师信息：
- en: '![Figure 14.65: The Chest properties](img/Figure_14.65_B18327.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.65：胸部的属性](img/Figure_14.65_B18327.jpg)'
- en: 'Figure 14.65: The Chest properties'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.65：胸部的属性
- en: 'Fill in the information for the Animator of `Coin` as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写`Coin`的动画师信息：
- en: '![Figure 14.66: The Coin properties](img/Figure_14.66_B18327.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.66：硬币属性](img/Figure_14.66_B18327.jpg)'
- en: 'Figure 14.66: The Coin properties'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.66：硬币属性
- en: 'Fill in the information for the Animator of `Heart` as follows:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写`Heart`的动画师信息：
- en: '![Figure 14.67: The Heart properties](img/Figure_14.67_B18327.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.67：心脏属性](img/Figure_14.67_B18327.jpg)'
- en: 'Figure 14.67: The Heart properties'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.67：心脏属性
- en: 'Fill in the information for the Animator of `PowerUp` as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写“PowerUp”的动画器信息：
- en: '![Figure 14.68: The PowerUp properties](img/Figure_14.68_B18327.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.68：PowerUp 属性](img/Figure_14.68_B18327.jpg)'
- en: 'Figure 14.68: The PowerUp properties'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.68：PowerUp 属性
- en: 'Fill in the information for the Animator of `Button` as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写“按钮”的动画器信息：
- en: '![Figure 14.69: The Button properties](img/Figure_14.69_B18327.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.69：按钮属性](img/Figure_14.69_B18327.jpg)'
- en: 'Figure 14.69: The Button properties'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.69：按钮属性
- en: 'Now that we have all the appropriate data values for the State Machine initialized
    and defined, let’s actually have the State Machine perform its appropriate logic.
    First, we will need to create a variable for the Animator. Add the following variable
    initialization to your script:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经初始化并定义了状态机所需的所有适当数据值，让我们实际上让状态机执行其适当的逻辑。首先，我们需要为动画器创建一个变量。将以下变量初始化添加到您的脚本中：
- en: '[PRE9]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, initialize the State Machine’s Animator in an `Awake()` function:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在“Awake()”函数中初始化状态机的动画器：
- en: '[PRE10]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To have the State Machine automatically set the various parameters of the individual
    Animators at the appropriate state, we will need to loop through all of the animated
    items we have listed and each of their listed parameters. If the animated item
    has a parameter, which is to be set at the current state of the State Machine,
    we will set it based on the conditions listed. Create the following function to
    perform that functionality:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让状态机自动设置各个动画器的各种参数，我们需要遍历我们所列出的所有动画项及其列出的参数。如果动画项有一个需要在状态机当前状态下设置的参数，我们将根据列出的条件设置它。创建以下函数以执行该功能：
- en: '[PRE11]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `CheckForParameterSet` function will determine whether a specified Animator
    needs a parameter set at the current state of the State Machine. However, this
    function is not currently called anywhere. We want this function to be called
    whenever a state in the State machine starts. We can accomplish this with a State
    Machine Behaviour. Open the `ChestOpeningStateMachine` Animator and select the
    `ChestStateMachineBehaviour`, and click on the `ChestStateMachineBehaviour` will
    be added to the `Assets` folder. Move it to the `Assets/Scripts/LootBox` folder
    and open it.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “CheckForParameterSet”函数将确定在状态机当前状态下指定的动画器是否需要一个参数集。然而，这个函数目前还没有被任何地方调用。我们希望这个函数在状态机中的任何状态开始时被调用。我们可以通过状态机行为来实现这一点。打开“ChestOpeningStateMachine”动画器并选择“ChestStateMachineBehaviour”，然后点击“ChestStateMachineBehaviour”将被添加到“Assets”文件夹中。将其移动到“Assets/Scripts/LootBox”文件夹并打开它。
- en: 'A lot of stuff is included within this State Machine Behaviour. We only need
    the `OnStateEnter` function. Adjust the code within the `ChestStateMachineBehaviour`
    class to include the following to call the `CheckForParameterSet` function on
    the `ChestAnimControls` script when it starts:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个状态机行为中包含了很多内容。我们只需要“OnStateEnter”函数。调整“ChestStateMachineBehaviour”类中的代码，包括以下内容以在开始时在“ChestAnimControls”脚本上调用“CheckForParameterSet”函数：
- en: '[PRE12]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will need this script on every state that does not say `ChestStateMachineBehaviour`
    to each of the states in the right-hand column (the ones that do not say `ChestStateMachineBehaviour`
    in their Inspector. The State Machine will now appropriately call each of the
    individual items’ animations when the appropriate states are entered, but we don’t
    have anything that actually controls the flow of the state machine.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要这个脚本在每个不说是“ChestStateMachineBehaviour”的状态上，对右侧列中的每个状态（在检查器中不说“ChestStateMachineBehaviour”的那些）进行操作。现在，状态机将适当地在进入适当的状态时调用每个单独项目的动画，但我们没有实际控制状态机流程的东西。
- en: 'Right now, it is going to just stay in the `Button` that is on the `Button
    Canvas` that says `ChestAnimControls.cs` script:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它将停留在“Button Canvas”上的“Button”中，显示“ChestAnimControls.cs”脚本：
- en: '[PRE13]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function will trigger the State Machine’s trigger parameter specified by
    the string sent as an argument.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数将触发状态机由字符串作为参数指定的触发参数。
- en: 'We will need to call that function from the `Button` on the `Button Canvas`:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从“按钮画布”上的“按钮”调用该函数：
- en: '![Figure 14.70: The On Click() event of the Button](img/Figure_14.70_B18327.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.70：按钮的 On Click() 事件](img/Figure_14.70_B18327.jpg)'
- en: 'Figure 14.70: The On Click() event of the Button'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.70：按钮的 On Click() 事件
- en: Now, we will need to create some logic that will have the `Button` on `Chest
    Open Canvas` transition from the other two `OpenCloseButton.cs` in the `Assets/Scripts/LootBox`
    folder.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一些逻辑，使 `Chest Open Canvas` 上的 `Button` 从 `Assets/Scripts/LootBox` 文件夹中的其他两个
    `OpenCloseButton.cs` 转换过来。
- en: 'Add the `UnityEngine.UI` namespace to the `OpenCloseButton` script with the
    following:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将 `UnityEngine.UI` 命名空间添加到 `OpenCloseButton` 脚本中：
- en: '[PRE14]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the following code to the `OpenCloseButton` script:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到 `OpenCloseButton` 脚本中：
- en: '[PRE15]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `OpenOrClose()` function will be called by the button›s `Button` on the
    `Chest Open Canvas` will be used to open and close the chest. It will set the
    appropriate trigger based on the current text written on the button and will change
    its text to `"Open"` or `"Close"` with the `SetText()` function.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OpenOrClose()` 函数将由按钮在 `Chest Open Canvas` 上的 `Button` 调用，用于打开和关闭箱子。它将根据按钮上当前写入的文本设置适当的触发器，并使用
    `SetText()` 函数将其文本更改为 `"Open"` 或 `"Close"`。'
- en: Add the `OpenCloseButton` script as a component to the `Button` on `Chest` `Open
    Canvas`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OpenCloseButton` 脚本作为组件添加到 `Chest` 的 `Open Canvas` 上的 `Button`。
- en: 'Now, add the following `Button` on `Chest` `Open Canvas`:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Chest` 的 `Open Canvas` 上添加以下 `Button`：
- en: '![Figure 14.71: The On Click() property of the Button](img/Figure_14.71_B18327.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.71：按钮的 On Click() 属性](img/Figure_14.71_B18327.jpg)'
- en: 'Figure 14.71: The On Click() property of the Button'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.71：按钮的 On Click() 属性
- en: If you play the game now and click on the `AnimationComplete` trigger in the
    `ChestOpeningStateMachine` Animator. We will need another script to set this trigger.
    Create a new script called `AnimationControls` in the `Assets/Scripts/LootBox`
    folder.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏并点击 `ChestOpeningStateMachine` 动画师中的 `AnimationComplete` 触发器。我们需要另一个脚本来设置此触发器。在
    `Assets/Scripts/LootBox` 文件夹中创建一个新的脚本，命名为 `AnimationControls`。
- en: 'Adjust the code within the `AnimationControls` class, as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下方式调整 `AnimationControls` 类中的代码：
- en: '[PRE16]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code simply sets the `AnimationComplete` trigger with the `ProceedStateMachine()`
    function.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码只是简单地使用 `ProceedStateMachine()` 函数设置了 `AnimationComplete` 触发器。
- en: This trigger is used to allow each of the individual animations to fully play
    before the next state is started. To make sure that the animation trigger isn’t
    set until the entire animation has played, we’ll use Animation Events to call
    the `ProceedStateMachine()` function at the appropriate time within the necessary
    animations.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此触发器用于确保在开始下一个状态之前，每个单独的动画都能完全播放。为了确保动画触发器在整个动画播放完毕后才设置，我们将在必要的动画中适当的时间使用动画事件来调用
    `ProceedStateMachine()` 函数。
- en: When you use an Animation Event, the function you want to call must be on a
    script attached to the same object as the animation. We want the function to be
    called at the end of animations on `Chest Open Canvas`, `Chest`, `Coin`, `Heart`,
    `PowerUp`, and the `Button` on `Chest Open Canvas`. Therefore, add the `AnimationControls`
    script as a component to each of them.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你使用动画事件时，你想要调用的函数必须位于与动画相同对象的脚本上。我们希望函数在 `Chest Open Canvas`、`Chest`、`Coin`、`Heart`、`PowerUp`
    和 `Chest Open Canvas` 上的 `Button` 的动画结束时被调用。因此，将 `AnimationControls` 脚本作为组件添加到每个对象上。
- en: 'Now, we will need to add the `ProceedStateMachine()` function as an Animation
    Event to the various animations. Select `Chest Open Canvas` and view its `CanvasGroupFadeIn`
    animation. On its last animation frame, right-click on the top dark gray area
    of the timeline and select `ProceedStateMachine()` from the dropdown menu. It
    will be the very last function in the list. You should now have a white flag above
    the last keyframe that says **ProceedStateMachine** when you hover over it:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将 `ProceedStateMachine()` 函数作为动画事件添加到各种动画中。选择 `Chest Open Canvas` 并查看其
    `CanvasGroupFadeIn` 动画。在其最后一个动画帧上，在时间轴的顶部深灰色区域右键单击，并从下拉菜单中选择 `ProceedStateMachine()`。它将是列表中的最后一个函数。当你悬停在它上方时，现在你应该在最后一个关键帧上方有一个白色旗帜，上面写着
    **ProceedStateMachine**：
- en: '![Figure 14.72: Adding the ProceedStateMachine Event to the animation](img/Figure_14.72_B18327.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.72：将 ProceedStateMachine 事件添加到动画中](img/Figure_14.72_B18327.jpg)'
- en: 'Figure 14.72: Adding the ProceedStateMachine Event to the animation'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.72：将 ProceedStateMachine 事件添加到动画中
- en: 'If you play the game now and click on the `ChestFlyingIn` animation. To have
    the animation sequence finish out, add the `ProceedStateMachine()` function as
    an Animation Event to each of the following animations: `ChestFlyingIn`, `ChestOpening`,
    `CoinPopping`, `HeartPopping`, and `PowerUpPop`.'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏并点击 `ChestFlyingIn` 动画。为了使动画序列完成，将 `ProceedStateMachine()` 函数作为动画事件添加到以下每个动画中：`ChestFlyingIn`、`ChestOpening`、`CoinPopping`、`HeartPopping`
    和 `PowerUpPop`。
- en: Playing the game now almost works the way it should. There’s a bit of an issue
    with the timing of the items popping out of the chest when you replay the animation
    sequence. Currently, there is a bit of a problem with the `AnimationComplete`
    trigger. We need that trigger to definitely be unset whenever any of the `true`
    when the State Machine restarts, causing some timing issues. To fix this, we need
    one more State Machine Behaviour. Select the `ResetTriggers` in its Inspector.
    Remember that whenever you create a new State Machine Behaviour, it is added to
    the `Asset` folder, so move it to the `Asset/Scripts/LootBox` folder.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在玩游戏几乎可以按照预期的方式运行。当重新播放动画序列时，物品从宝箱中弹出的时机有些问题。目前，`AnimationComplete`触发器有些问题。我们需要确保当状态机重新启动时，该触发器被明确重置，以避免一些时序问题。为了解决这个问题，我们需要一个额外的状态机行为。在它的检查器中选择`ResetTriggers`。记住，每次你创建一个新的状态机行为时，它都会被添加到`Asset`文件夹中，所以将其移动到`Asset/Scripts/LootBox`文件夹。
- en: 'We want the `AnimationComplete` Trigger Parameter to reset whenever a `ResetTriggers`
    class, as follows:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`AnimationComplete`触发器参数在`ResetTriggers`类被重置时重置，如下所示：
- en: '[PRE17]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, add the `ResetTriggers` State Machine Behaviour to all three of the **Waiting
    on** **Player** states.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`ResetTriggers`状态机行为添加到所有三个**等待玩家**的状态中。
- en: Playing the game now should have the animation sequence firing correctly, with
    everything but the particle system, which will be covered in the next chapter.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏应该能够正确触发动画序列，除了粒子系统，这部分将在下一章介绍。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Animating UI elements is not significantly different from animating any other
    2D object in Unity. Therefore, this chapter offered a brief overview of animation.
    This chapter also offered an example of the workflow for creating complex animations
    utilizing a State Machine and Animation Events. There’s a lot we can do with animations,
    and the examples in this chapter showed you many of the techniques you can use
    while animating UI. Hopefully, these examples will provide you with enough variation
    of technique that you can determine how to make your own animations in the future.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中动画化UI元素与动画化任何其他2D对象并没有显著区别。因此，本章提供了一个动画的简要概述。本章还提供了一个使用状态机和动画事件创建复杂动画的工作流程示例。我们可以用动画做很多事情，本章中的示例展示了你在动画UI时可以使用的技术。希望这些示例能为你提供足够的技巧变化，以便你未来能够确定如何制作自己的动画。
- en: In the next chapter, we will discuss how to render particle effects in front
    of the UI.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在UI前面渲染粒子效果。
