<html><head></head><body><div><div><h1 id="_idParaDest-146"><em class="italic"><a id="_idTextAnchor145"/>Chapter 10</em>: Dialogue Systems with ink</h1>
			<p>In this chapter, we will explore three different approaches to create a <code>#</code>), can be used to mark different lines in ink as being associated with certain characters in a story. Then, we will discuss an alternative to tags, where the name of the speaker precedes their dialogue. Finally, we will conclude the first part by reviewing how tags can be used and how both approaches can be combined.</p>
			<p>In the second topic, we will look at how to recreate the <strong class="bold">click-to-continue</strong> dialogue pattern that is found in many video games using ink. We will explore various ways of saving time and effort by using tunnels to move to different knots and back again in an ink project for use when needed. Following this, we will examine several different ways in which to generate dialogue trees in ink where players can explore different paths through extended branches of conversation.</p>
			<p>In the third and final topic, we will look at two common visual patterns in which to present dialogue options to players, that is, lists and radial menus, and how they affect both writing ink code and how information is displayed to a player in Unity. We will begin with the visual pattern of a list, where all options are shown to the player in a vertical pattern. Then, we will examine the <strong class="bold">radial menu pattern</strong>, where options are limited to a smaller number of options arranged in a specific, visual way.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Writing dialogue in ink using tags</li>
				<li>Dialogue loops and story knots</li>
				<li>User interface models for conversations<p class="callout-heading">Note</p><p class="callout">Unlike previous chapters, where sections built toward a completed project, this chapter will examine different approaches toward more visually complex systems. Each approach covered by a section can be found online on GitHub as a completed project. Only selected files and code, as they relate to the approach of each section, will be shown in this chapter. The specific files of each example are also noted within each section.</p></li>
			</ul>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Technical requirements</h1>
			<p>The completed code for the different sections of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10</a>.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Writing dialogue in Ink using tags</h1>
			<p>When ink was first introduced in <a href="B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Text, Flow, Choices, and Weaves</em>, the importance of a single line was also discussed. Each line in ink can consist of code, text, or a combination <a id="_idIndexMarker368"/>of the two. Depending on the use of other concepts, such as glue or comments, what counts as a single line can often be composed of <a id="_idIndexMarker369"/>multiple blocks of text or include notes for the authors as part of a single line. However, in addition to these previously reviewed concepts is <a id="_idIndexMarker370"/>another concept that has not previously been discussed: <strong class="bold">hashtags</strong>.</p>
			<p>In ink, a new, single <em class="italic">hashtag</em> is created when a hash (<code>#</code>) is used before any text. Starting from the hash (<code>#</code>) and <a id="_idIndexMarker371"/>until the end of that line, any text that <a id="_idIndexMarker372"/>appears between the two is considered part of the single <em class="italic">tag</em>:</p>
			<pre>This is text. #This is a tag.</pre>
			<p>Hashtags in ink are specifically designed to work with other systems. They have no meaning within Inky itself and are shown in the middle of the output:</p>
			<div><div><img src="img/Figure_10.1_B17597.jpg" alt="Figure 10.1 – A hashtag used within Inky&#13;&#10;" width="550" height="191"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – A hashtag used within Inky</p>
			<p>When working with another system such as Unity, hashtags can be used to add extra data to a <a id="_idIndexMarker373"/>single line in ink. The current tags for the loaded chunk of the <a id="_idIndexMarker374"/>ink story exist within a property provided by the Story API, called <code>currentTags</code>, which contains a <code>List&lt;string&gt;</code> of all tags detected <a id="_idIndexMarker375"/>within the last load of story content. As with other text-related content, the <code>currentTags</code> property is also affected by any usages of the <code>Continue()</code> or <code>ContinueMaximally()</code> methods.</p>
			<p>We will begin by learning how to use hashtags in ink. We will retrieve their values using the <code>currentTags</code> property in Unity to build a simple dialogue system where each spoken line has a name associated with who is communicating it. Next, we will examine a different approach to the same dialogue system using speech tags in front of the text of each ink line. The last section of this topic will compare the two approaches and review when one might be better than the other or whether a combination of the two might be needed.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Tagging ink text</h2>
			<p>In ink, hashtags are used on a per-line basis. They exist for that line but remain part of the current hashtags until the next <a id="_idIndexMarker376"/>part of the story is loaded using the <code>Continue()</code> or <code>ContinueMaximally()</code> methods. In this section, we will review an example that uses hashtags with dialogue and the name of the speaker as part of a single line in ink. We will learn how the <code>currentTags</code> property is affected using the <code>Continue()</code> and <code>ContinueMaximally()</code> methods.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a> examples on GitHub; these are under the name of <em class="italic">Chapter10-TaggingInkText</em>. Only selected parts of the code will be shown as they relate to the concepts examined in this section.</p>
			<p>Dialogue lines are meaningless unless attributed to a character within a piece of work. This helps establish who is communicating and enables you to build continuity within the story. In the <code>Chapter10-TaggingInkText</code> example, each line of dialogue ends with the name of its speaker as a hashtag in ink. This helps attribute who is communicating each line:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1 (InkDialogueTags.ink):</p>
			<pre>Hi, there! Welcome to an Ink example! #???
* [\[Continue\]]
- 
My name is Narrator! I will be guiding you through this example.
.. #Narrator
* [\[Continue\]]
- 
My name is Dan. #Dan
* [\[Continue\]]
-
I'm another character in this example! #Dan</pre>
			<p>The ink code of <em class="italic">Example 1</em> contains the lines of dialogue and the name of the speaker for each line. Moving over <a id="_idIndexMarker377"/>to Unity, this translates into using the <code>currentTags</code> property to access the tags after at least one use of the <code>Continue()</code> or <code>ContinueMaximally()</code> methods:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2 (InkStoryScript.cs):</p>
			<pre><code>void UpdatePanel()</code>
<code>{</code>
<code>DestroyChildren(OptionsPanel.transform);</code>
<code>InkOutputText.text = InkStory.ContinueMaximally();</code>
<strong class="bold">SpeakerNameText.text = InkStory.currentTags[0];</strong>
<code>}</code></pre>
			<p>In <em class="italic">Example 2</em>, because the <code>currentTags</code> property is a <code>List&lt;string&gt;</code>, the first (<code>0</code>) position can be retrieved using the number of its index. The result is the separation of the tagged speaker and their lines in Unity despite them being written as one line in ink.</p>
			<p>Hashtags are a powerful tool in which to add extra data to a single line in ink. As demonstrated in this section, they can be used to add the name of the character communicating the line at the end each time. However, there is another way to achieve the same outcome. In the next section, we will repeat the same general code but use <em class="italic">speech tags</em> in front of each line instead.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Using speech tags</h2>
			<p>In creative writing, a <strong class="bold">speech tag</strong> appears before <a id="_idIndexMarker378"/>or after some dialogue and signals who is doing the <a id="_idIndexMarker379"/>communicating. For example, a common example found in many novels might use the word <em class="italic">said</em> in the following way:</p>
			<pre>"Hello," Dan said.</pre>
			<p>The use of <em class="italic">Dan said</em> acts as a <em class="italic">tag</em> to the speech captured in the quotation marks. It signals who is doing the talking (<em class="italic">Dan</em>) and what is being said (<em class="italic">Hello</em>).</p>
			<p>Often, many people who write for games or other interactive projects follow a slightly different format <a id="_idIndexMarker380"/>where the name of the speaker appears before the speech. This style borrows from conventions found in screenwriting. The same words used in the previous example might appear as follows:</p>
			<pre>Dan: Hello</pre>
			<p>In the updated form, the use of quotation marks is dropped, and the name of the speaker precedes their words. There is also an introduction of a colon (<code>:</code>). This marks the end of the speaker and the beginning of their words. In screenwriting, both the name of the speaker and their dialogue will be centered. However, in an updated form that is more commonly used as part of game writing, this formatting is dropped, and the text appears as part of one line.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found inside the <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a> examples on GitHub under the name of <code>Chapter10-UsingSpeechTags</code>. Only selected parts of the code will be shown as they relate to the concepts examined in this section.</p>
			<p>The ink code in <code>Chapter10-UsingSpeechTags</code> follows a different pattern from the one found in the previous section. Instead of the name of the speaker included as a hashtag after the dialogue lines, it now precedes it. Often, this format is used for dialogue by writers working on video games and other interactive projects:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3 (InkSpeechTags.ink):</p>
			<pre>???: Hi, there! Welcome to an Ink example!
* [\[Continue\]]
- 
Narrator: My name is Narrator! I will be guiding you through this example.
* [\[Continue\]]
- 
Dan: My name is Dan.
* [\[Continue\]]
-
Dan: I'm another character in this example!</pre>
			<p>When the <em class="italic">Example 3</em> code is run in Inky, because the code is no longer using hashtags, the first output and weave will be updated:</p>
			<div><div><img src="img/Figure_10.2_B17597.jpg" alt="Figure 10.2 – Speech tag usage in Inky&#13;&#10;" width="474" height="112"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Speech tag usage in Inky</p>
			<p>Immediately, there is a visual difference between using ink hashtags and formatting the dialogue using speech tags. When <a id="_idIndexMarker381"/>testing the code in Inky, it is obvious who is communicating because their name will precede the text. However, while testing in Inky is easier, the removal of the hashtags within the ink code means the <code>currentTags</code> property cannot be used. Instead, more C# code must be added to parse the name from each line of text.</p>
			<p>To detect, parse, and remove the use of the colon (<code>:</code>) within the ink output, multiple lines of C# code are needed:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4 (InkStoryScript.cs):</p>
			<pre>void UpdatePanel()
{
DestroyChildren(OptionsPanel.transform);
        
<strong class="bold">string inkOutput = InkStory.ContinueMaximally();</strong>
<strong class="bold">if(inkOutput.Contains(":"))</strong>
<strong class="bold">{</strong>
<strong class="bold">string[] splitInkOutput = inkOutput.Split(':');</strong>
<strong class="bold">splitInkOutput[0] = splitInkOutput[0].TrimEnd(':');</strong>
<strong class="bold">SpeakerNameText.text = splitInkOutput[0];</strong>
<strong class="bold">InkOutputText.text = splitInkOutput[1];</strong>
<strong class="bold">}</strong>
<strong class="bold">else</strong>
<strong class="bold">{</strong>
<strong class="bold">SpeakerNameText.text = "";</strong>
<strong class="bold">InkOutputText.text = inkOutput;</strong>
<strong class="bold">}</strong>
}</pre>
			<p><em class="italic">Example 4</em> now detects whether a colon (<code>:</code>) exists in the output using the <code>Contains()</code> method. If it does, the string is split into two parts using the <code>Split()</code> method. The colon (<code>:</code>) is then trimmed from the first (<code>0</code>) string using the <code>Trim()</code> method and its value <a id="_idIndexMarker382"/>is then used for the speaker's name. The second (<code>1</code>) string is used for the output of Ink.</p>
			<p>The result of this new code appears to be the same as the previous section. However, it uses speech tags to mark who is speaking and when. This makes it easier to test the ink code outside of Unity, as hashtags in ink have no meaning in Inky. However, this approach also comes with the issue that a colon (<code>:</code>) can <em class="italic">only</em> appear as part of the speech tag. If the text contains a colon, the C# code might become confused and attempt to split the text as though it contained a speech tag instead.</p>
			<p>In the next section, we will compare each of the approaches outlined earlier: </p>
			<ul>
				<li>The <em class="italic">first</em> approach, using hashtags <a id="_idIndexMarker383"/>in ink, allows us to add extra data to a single line and then use the <code>currentTags</code> property to retrieve this in the C# code. </li>
				<li>The <em class="italic">second</em> approach, using speech tags directly in the text, makes the ink code easier to test but creates a need for more C# code to parse the resulting ink. </li>
			</ul>
			<p>As we will mention in the next section, there might be contexts in which both approaches can be combined.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Reviewing approaches to tagging dialogue</h2>
			<p>In ink, hashtags add extra data per line. They can be used, as we learned in the <em class="italic">Tagging ink text</em> section, to add hashtags to each line of dialogue and then retrieve this data using the <code>currentTags</code> property in C# code as part of a Unity project. However, hashtags in ink <a id="_idIndexMarker384"/>come with two issues. The first is that they can only be used <em class="italic">per line</em>. The second is that only <em class="italic">one tag per line</em> can be used at a time. This makes hashtags very useful, for example, in the task of adding who is communicating to the line, but it also means they can only be used once per line.</p>
			<p>Dialogue can be directly marked using speech tags in the text. As we learned in the <em class="italic">Using speech tags</em> section, a colon can be used to mark who the speaker is and what they are communicating. This can be very useful for testing in Inky, as the speaker and their lines are closely connected and appear together. However, using speech tags in ink requires additional C# code to understand the output. Additionally, it means the colon can only be used as part of speech tags, as any other user might create confusion.</p>
			<p>Both approaches have benefits and potential obstacles when used separately. However, there are also contexts in which both approaches might be combined to present the name of the speaker using speech tags and to convey extra data using a tag in ink at the same time. For example, many games not only present text to a player but also use audio, video, or some type of animation closely linked to the text itself. In these cases, the text could contain a speech tag and the ink code could also use tags to signal that additional media should be played as part of the combined delivery of the dialogue to a player. </p>
			<p>For games with spoken dialogue lines, it is very common to use a database or a spreadsheet of the text line and its corresponding audio based on a naming convention as part of the same row. Depending on the team, company, and other factors, the naming convention might use specific formatting or numbers, but a general example might include the type of audio, the character's name, their state of mind or emotion, and any additional information for the context, level, or area of the game:</p>
			<pre>dialogue_diana_happy_desert.mp3</pre>
			<p>Because ink hashtags can add extra data, a single line within the ink code can use speech tags to mark who was communicating and then use the hashtag after the line with the media file to play. Such code will combine both approaches.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found inside the <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a> examples on GitHub under the name of <code>Chapter10-CombiningTags</code>. Only selected parts of the code will be shown as they relate to the concepts examined in this section.</p>
			<p>The ink code in the <code>Chapter10-CombiningTags</code> example uses the combined approach. It includes both <a id="_idIndexMarker385"/>the name of the speaker preceding the dialogue lines and the use of a hashtag with the corresponding media file or reference to be used when the line is shown:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5 (InkCombiningTags.ink):</p>
			<pre>Diana: I love the desert! #dialogue_diana_happy_desert
* [\[Continue\]]
- 
Diana: But I hate how hot it gets! #dialogue_diana_sad_desert
* [\[Continue\]]
- 
Diana: Perhaps I'm just fickle. #dialogue_diana_shrug_desert
* [\[Continue\]]
-</pre>
			<p>For simplicity, the project for this section only displays the text of the hashtag. By adding an extra <code>Text</code> game object and associating it with an existing property, the adjusted C# code will incorporate the changes to parsing speech tags along with the usage of the <code>currentTags</code> property:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6 (InkStoryScript.cs):</p>
			<pre><strong class="bold">if(InkStory.currentTags.Count &gt; 0)</strong>
<strong class="bold">{</strong>
<strong class="bold">MediaText.text = InkStory.currentTags[0];</strong>
<strong class="bold">}</strong>
<strong class="bold">else</strong>
<strong class="bold">{</strong>
<strong class="bold">MediaText.text = "";</strong>
<strong class="bold">}</strong></pre>
			<p>In <em class="italic">Example 6</em>, the new code tests for the number of entries in the <code>currentTags</code> property. If it contains at least one hashtag, the first (<code>0</code>) entry is used as text for a <code>Text </code>game object. When run, the <a id="_idIndexMarker386"/>project shows the speaker, their communication, and the name of the media file that will be played or used as part of the dialogue in a smaller font. </p>
			<p>In the next topic, we will recreate some common patterns found in video game dialogue. We will learn how to create a click-to-continue pattern as well as more complex dialogue trees for players to explore. There will also be advice for those starting new projects on how to plan and then allow the code in ink to guide you to create an interface in Unity.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Dialogue loops and story knots</h1>
			<p>Writing dialogue in ink often means being aware of how it will be used with other systems. In the previous section, we investigated two approaches to using tags when writing single lines of dialogue. In this topic, we will move away from a focus on individual lines and work with the larger structures within an ink project. By inspecting two common patterns in which to present choices to a player, we will learn how knots in ink can be reused within projects to save future time and effort. The last section in this topic also includes advice for starting a new project or converting it using ink.</p>
			<p>Because it appears most often, we will begin with a pattern that appears in the <em class="italic">Writing dialogue in ink using tags</em> section as part of the ink code examples using tags: click to continue.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Click to continue</h2>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found inside the <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a> examples on GitHub under the name of <code>Chapter10-ClickToContinue</code>. Only selected parts of the code will be shown as they relate to the concepts examined in this section.</p>
			<p>There are <a id="_idIndexMarker387"/>many repeating patterns found in video game writing. One of the most common is the <strong class="bold">click-to-continue</strong> pattern. This is the presentation of information across a series of messages to a player, where they must press a button or click on the screen to progress through them. </p>
			<p>In ink, one way to create the click-to-continue pattern is with a single choice and then, usually, a gathering point to collapse the weave right after it. In its most simplistic form, it only contains these concepts and a single word to indicate an action, such as <em class="italic">Continue</em>:</p>
			<pre>* [\[Continue\]]
-</pre>
			<p>Breaking out the click-to-continue code into a knot allows a writer to reuse the same section multiple times by writing it once and then tunneling to it and back again when needed. In an extended example, the use of a specific knot for this purpose saves more lines of code the more times it appears:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 7 (InkClickToContinue.ink):</p>
			<pre>Guard: Sir! A dragon! There's a dragon!
-&gt; continue -&gt;
King: What? Are you sure?
-&gt; continue -&gt;
Guard: Let me check!
-&gt; continue -&gt;
Guard: Just a large bird, turns out.
-&gt; continue -&gt;
Guard: Sorry, sir.
-&gt; continue -&gt;
== continue ==
+ [\[Continue\]]
-
-&gt;-&gt;</pre>
			<p>In the code for <em class="italic">Example 7</em>, the <code>continue</code> ink knot is reused multiple times. Each usage tunnels to the knot and returns. This allows the code to decrease the number of overall lines.</p>
			<p>Based on the structure <a id="_idIndexMarker388"/>in ink, the amount of C# code can also be reduced. The pattern in the ink code can be reflected in a simplified technique in the C# code by providing a method and attaching to the overall panel holding two <code>Text</code> game objects:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 8 (InkStoryScript.cs):</p>
			<pre>void UpdatePanel()
{
<strong class="bold">SpeakerNameText.text = "";</strong>
<strong class="bold">InkOutputText.text = "";</strong>
string inkOutput = "";
if (InkStory.canContinue)
{
inkOutput = InkStory.ContinueMaximally();
}
if (inkOutput.Contains(":"))
{
string[] splitInkOutput = inkOutput.Split(':');
splitInkOutput[0] = splitInkOutput[0].TrimEnd(':');
<strong class="bold">SpeakerNameText.text = splitInkOutput[0];</strong>
<strong class="bold">InkOutputText.text = splitInkOutput[1];</strong>
}
else
{
<strong class="bold">SpeakerNameText.text = "";</strong>
<strong class="bold">InkOutputText.text = inkOutput;</strong>
}
}
<strong class="bold">public void ProgressDialogue()</strong>
<strong class="bold">{</strong>
<strong class="bold">if(InkStory.currentChoices.Count &gt; 0)</strong>
<strong class="bold">{</strong>
<strong class="bold">InkStory.ChooseChoiceIndex(0);</strong>
<strong class="bold">}</strong>
<strong class="bold">UpdatePanel();</strong>
<strong class="bold">}</strong></pre>
			<p>In the <a id="_idIndexMarker389"/>new <em class="italic">Example 8</em> code, the <code>ProgressDialogue()</code> method is used by a <code>Panel</code> game object as part of an <strong class="bold">EventTrigger</strong> component:</p>
			<div><div><img src="img/Figure_10.3_B17597.jpg" alt="Figure 10.3 – Event Trigger on the Panel game object&#13;&#10;" width="926" height="323"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Event Trigger on the Panel game object</p>
			<p>By associating the <code>ProgressDialogue()</code> method with the <code>Panel</code> game object, you can click on a visual representation of a dialogue. This then loads the next part of the click-to-continue pattern based on the ink code.</p>
			<p>While the click-to-continue pattern is the most common, there is another, more advanced pattern <a id="_idIndexMarker390"/>found in many role-playing games and narrative-heavy interactive projects: dialogue trees. In this pattern, multiple options are presented with each expanding out to separate branches of dialogue for players to explore. In the next section, we will learn how to create this pattern in ink and how new options can be easily added to branches.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Counting choices for trees</h2>
			<p>In ink, a weave is composed of one or more choices. Depending on the code following each choice, multiple <a id="_idIndexMarker391"/>levels can be created, and the flow of an ink story can branch off into different paths. When it <a id="_idIndexMarker392"/>comes to presenting options, there are often contexts where a user will progress through what is known as a <strong class="bold">dialogue tree</strong>. The use of the word <em class="italic">tree</em> is named after the shape created by the different parts, or branches, with all of them together as a single trunk.</p>
			<p>Often, in role-playing and narrative-heavy games, this pattern appears as part of a scene with information about an event or as part of a character explaining something to a player. In these scenarios, the normal use of weaves does not quite work as intended. Instead of needing to pick a single choice among a set, we need to progress <em class="italic">across</em> the collection instead. For this, a special built-in ink function is required: <code>CHOICE_COUNT()</code>.</p>
			<p>The ink runtime keeps track of the current number of options within the loaded chunk. This number can be accessed as part of the <code>CHOICE_COUNT()</code> ink function. When used as part of a conditional option in ink, this allows an author to limit the number of options presented to a reader by comparing the current count with the value returned by the <code>CHOICE_COUNT()</code> function. However, to keep track of values across loops, a variable is required:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 9 (oneBranch.ink):</p>
			<pre>VAR count = 0
-&gt; loop
== loop
~ count = CHOICE_COUNT()
* {limitChoice(count)} This is the first
* {limitChoice(count)} This is the second
* {limitChoice(count)} This is the third
+ Return
- -&gt; loop
== function limitChoice(localCount) ==
~ return localCount == CHOICE_COUNT()</pre>
			<p>The use of the <code>count</code> variable in <em class="italic">Example 9</em> records the current choice count at the start of the loop. Then, for each <a id="_idIndexMarker393"/>choice in turn, the value is compared with the increased number of uses of the choice before the comparison. The effect is the loading of each choice, in turn, from the set. At the beginning of the loop, the <code>This is the first</code> option will be provided. The use of a gathering point will automatically loop the code. This will continue until there are no choices left except the sticky choice of <code>Return</code>. This last choice will always remain and allow the player to either close the dialogue or <em class="italic">return</em> to a previous point.</p>
			<p>This model can be extended into multiple branches as well. For each tree, there needs to be a separate knot or stitch with tunnels used to move between to maintain the flow of the ink story. The use of multiple sections with their choice counts also means using another ink concept: temporary variables. The <code>temp</code> keyword can be used inside any knot or stitch to create a variable that does not exist outside of it:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 10 (multipleBranches.ink):</p>
			<pre>-&gt; loop
== loop
&lt;- tree1.branch1
&lt;- tree1.branch2
+ \[Close\]
    -&gt; DONE
- -&gt; loop
== tree1
= branch1
~ temp count = CHOICE_COUNT()
* {limitChoice(count)} Branch 1, first
* {limitChoice(count)} Branch 1, second
* {limitChoice(count)} Branch 1, third
- -&gt; loop
= branch2
~ temp count = CHOICE_COUNT()
* {limitChoice(count)} Branch 2, first
* {limitChoice(count)} Branch 2, second
* {limitChoice(count)} Branch 2, third
- -&gt; loop
== function limitChoice(localCount) ==
~ return localCount == CHOICE_COUNT()</pre>
			<p>In the preceding code for <em class="italic">Example 10</em>, each branch is broken out into its own stitches within a larger <a id="_idIndexMarker394"/>collected knot. Starting with the <code>loop</code> knot, threads are used to pull in the two stitches and create a unified appearance of options from two different parts of the code.</p>
			<p>Depending on the structure of the project, the <code>CHOICE_COUNT()</code> ink function can be used to limit one choice per set, in order, or a more traditional collection can be created. Each of these <a id="_idIndexMarker395"/>approaches provides different ways in which to create a dialogue tree for a player to explore. They can either exhaust each option one after another or use tunnels to pass the flow to the knot containing the tree structure and then back again.</p>
			<p>In this section, we examined two different structures for dialogue systems: click-to-continue and dialogue trees. In the last topic in this chapter, we will finally transition from ink structures into their visual representations in Unity. We will examine two models for presenting options to users: lists and radial menus. We will determine when each is best used and how the models affect both the structures in ink and the designs in Unity.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>User interface models for conversations</h1>
			<p>There is a long history of presenting dialogue options to players in video games and other interactive projects. From the earliest text prompts to complicated layers of menus in more <a id="_idIndexMarker396"/>modern video games, each generation of video game systems has introduced different methods of presenting information. However, two general models appear in many games: lists and radial menus. They can be explained as follows:</p>
			<ul>
				<li>Based on the original <a id="_idIndexMarker397"/>presentation of one choice after another in a vertical arrangement, the <strong class="bold">list pattern</strong> first appeared in early computer games and continues in visual designs where there is more space to show a variety of longer-text options to a player. </li>
				<li>The second model, the <strong class="bold">radial menu pattern</strong>, generally appears as part of role-playing games on <a id="_idIndexMarker398"/>video game consoles or mobile game spaces where there is limited visual space and, thus, options are arranged in a circle for easy access when using a controller.</li>
			</ul>
			<p>In the first section, we will start with lists. As we have already mentioned in multiple Unity examples across this book, and in earlier topics in this chapter, the vertical arrangement of options is a very common approach. However, we will discuss some common pitfalls when using this model and review several examples where they are best used and others where you might want to avoid them before we move on to cover the radial menu model next.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Listing dialogue options</h2>
			<p>There is one question we should ask when considering the user interface model of a list: how much visual spacing is allowed for each option? In computer games focused on text or with narrative-heavy designs, the list model is often the best to use. However, the reason for this <a id="_idIndexMarker399"/>is based not on computer games themselves, but on the assumed input peripherals used with the system. Often, computer games use the mouse as a primary input. This means a user can click on various things and scroll through a long <em class="italic">list</em> of options. Because the user is accustomed to this form of input and is willing to move through a longer presentation of text, the list is often a great model to follow. </p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a> examples on GitHub under the name of <code>Chapter10-ListingOptions</code>. Only selected parts of the code will be shown as they relate to the concepts examined in this section.</p>
			<p>In some role-playing or visual novel-based video games, the player might be presented with many options based on their past associations with other characters, political parties, or organizations. The number of options might also be influenced by certain skills, traits, or other in-game perks that grant the player additional benefits within dialogue selection. The <code>Chapter10-ListingOptions</code> project is based on such a premise. </p>
			<p>In the dialogue presented in the ink code, the player is aboard a passenger ship and on their way to another city where they encounter another character in a crew-only area. There are multiple programmed options for the player to consider, as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 11 (InkListingOptions.ink):</p>
			<pre>You sneak into the crew-only area. After you close the door, a man quickly stands up from what he was doing on the floor. Behind him seems to be a corpse on the floor.
* "Just give me any money you have, and I won't tell the captain you have been murdering on his ship."
* "Is that dark magic!? I'll go to report you to the captain right now!"
* "I don't care what you are doing in here. Leave. Now."
* \[Necromancer\] "Praise the Bone Mother! What foul sorcery have you been up to? And can I help?"
* "Oh, gosh. I totally forgot to clean up that body earlier. I guess I must kill you now too."
* \[Ignore them.\]</pre>
			<p>Because of the amount of visual space taken up by the dialogue selection in the code for <em class="italic">Example 11</em>, the multiple options extend off the screen. The player must scroll down and carefully read <a id="_idIndexMarker400"/>over the list in order to consider their choice. Such an interface works well in visual designs with a heavy narrative focus or on platforms such as desktop computers where the user might feel comfortable reviewing everything before making a final decision when progressing through a dialogue tree. However, this is not the only model a developer might want to use.</p>
			<p>In the next section, we will examine the radial menu pattern. Popularized by role-playing games on video game consoles where the number of inputs is limited, the radial menu pattern presents not <a id="_idIndexMarker401"/>only a design challenge but a writing one as well. As we will explore in more detail, the radial menu pattern limits the amount of text that appears on the screen and forces a developer to make sure the intent of a single word or phrase conveys the outcome the player will experience when choosing an option.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Presenting a radial menu for dialogue</h2>
			<p>Many video game controllers have at least one joystick and a limited number of buttons. Because of this <a id="_idIndexMarker402"/>reduced set of inputs, designing a user interface for a player to decide between multiple options often means presenting options arranged in a clockwise pattern on the screen. More commonly, this visual design pattern is called a <strong class="bold">radial menu</strong>. This term takes its name from the mathematical concept <em class="italic">radius</em>, which is the distance from the center of a circle to its perimeter. A <em class="italic">radial</em> menu shows options based on a circular pattern. </p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a> examples on GitHub under the name of <code>Chapter10-OptionWheel</code>. Only selected parts of the code will be shown as they relate to the concepts examined in this section.</p>
			<p>Demonstrating a common use of the radial menu, the <code>Chapter10-OptionWheel</code> example <a id="_idIndexMarker403"/>presents a scene where a player must confront a door and has multiple skills based on their in-game statistics. The outcomes for each option are represented by the name of the statistic:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 12 (InkOptionWheel.ink):</p>
			<pre>* [Strength]
    You kick the door down.
* [Intelligence]
    With a careful touch to two places where the wood has       rotted, the door falls flat.
* [Wisdom]
    You reach over and turn the knob. The door opens.
* [Charisma]
    You turn to your companions and nod towards the door. One       of them opens it for you.</pre>
			<p>In the code for <em class="italic">Example 12</em>, there are four options, each with the name of an example game statistic. When arranged in a simplified <em class="italic">radial</em> pattern, they might appear as the following in Unity:</p>
			<div><div><img src="img/Figure_10.4_B17597.jpg" alt="Figure 10.4 – The arrangement of dialogue options as a simplified radial menu&#13;&#10;" width="522" height="279"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – The arrangement of dialogue options as a simplified radial menu</p>
			<p>The <strong class="bold">radial menu pattern</strong> comes with the built-in limitation of reduced visual space. As mentioned in the <em class="italic">Listing dialogue options</em> section, the visual space given to the presentation of the options dictates how the information is presented. For the radial menu model, this is even more true.</p>
			<p>As with the code for <em class="italic">Example 12</em>, the options presented on the screen must be matched to either <a id="_idIndexMarker404"/>the in-game statistics or the known outcomes to the player. For example, a player might know that if they select a certain icon, it will match a certain action. In these scenarios, they will be limited to no words in Ink to represent the option, with Unity taking more of the load to represent the option to the player as part of the user interface.</p>
			<p>In this section, we reviewed the radial menu pattern. Presenting options in a clockwise arrangement, this pattern most often appears as part of a dialogue system for video game consoles with controllers or as part of a visual design with limited visual space. However, the use of the pattern has a direct effect on how options are written in ink. In one pattern, that is, lists, longer sentences can be included, but a player might not see all of them at once. For the other model, that is, the radial menu pattern, the options are only single words or perhaps even icons that represent more complex reactions.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/>Summary</h1>
			<p>In this chapter, we explored three different approaches to dialogue systems. In the first approach, we worked through hashtags and speech tags. In ink, we can add a hashtag to the end of a line. This allows you to add extra information per line such as the speaker for a line of dialogue or which media file to play for the line. With speech tags, a colon (<code>:</code>) can be added in front of the dialogue to mark the speaker. The speech tag helps with testing with Inky but requires more C# code in Unity. Hashtags and speech tags can be combined in various contexts where the hashtag can represent the media file or additional data for the developer whereas the speech tag contains who is communicating the line.</p>
			<p>In the second approach, we zoomed out from the line-by-line emphasis with tags to the structures within ink. To replicate a click-to-continue pattern, we can combine a knot and the use of tunnels in ink. This is also true of dialogue trees, which we can break out into their own stitches within a larger knot. We also learned about the use of the <code>CHOICE_COUNT()</code> ink function and how to progress through a set of options.</p>
			<p>In the final approach, we zoomed out from ink to consider visual designs in Unity and how they affect the writing of dialogue. The pattern used, whether a list or radial menu, will dictate how dialogue is created within ink. For a list, where each option can include multiple lines of text, a player will only see a limited selection at a time. For the radial menu pattern, where options are presented in a clockwise pattern on the screen, the dialogue within ink will be limited or nonexistent. In either case, the visual space for user interface elements directly affects how options are presented to a player.</p>
			<p>In <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a>, <em class="italic">Quest Tracking and Branching Narratives</em>, we will move from smaller dialogue systems to the much larger ones of quest tracking and creating branching narratives. While many video games often present dialogue to a player, some track multiple values over longer periods. We will examine how the <code>LIST</code> ink keyword can be used to track quest progression and how larger ink projects can be broken up across multiple files for easier asset maintenance.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Questions</h1>
			<ol>
				<li>What is a hashtag in ink?</li>
				<li>What are the differences between a hashtag and a speech tag?</li>
				<li>How did the term <em class="italic">dialogue tree</em> get its name?</li>
				<li>What is a list pattern?</li>
				<li>What is a radial menu pattern?</li>
			</ol>
		</div>
	</div></body></html>