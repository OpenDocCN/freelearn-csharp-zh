- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Application Settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the dynamic world of web applications, the ability to adapt to different
    environments and requirements is crucial. ASP.NET Core 9 provides a robust configuration
    system that allows developers to manage settings and behavior effectively. This
    chapter will explore the importance of application settings, how to manage them
    using the configuration system, and how to make your applications adaptable at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **IConfiguration** concepts and abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with configuration providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the Options pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dynamic configurations and behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides a robust configuration system that allows developers
    to effectively manage configurations and behaviors. This chapter will explore
    the importance of application configurations, how to manage them using the configuration
    system, and how to make your applications adaptive at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** : The Docker engine must be installed on your operating system and
    have a SQL Server container running. You can find more details about Docker and
    SQL Server containers in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis Insight** : This tool is used to connect to a Redis server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also need access to an Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IConfiguration concepts and abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the dynamic world of web applications, the ability to adapt to different
    environments and requirements is crucial, in addition to security requirements
    that have become increasingly essential in applications that run on different
    cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Most web applications have some type of configuration managed in files or classes,
    in order to centralize parameters that are used throughout the application flow.
    With each change in configurations or even application behaviors, a new version
    of the software must be generated. Furthermore, when working with remote teams,
    it is essential to maintain the correct management of configurations and sensitive
    data and not keep these parameters versioned in the application version control.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides powerful ways to manage application configurations in
    addition to enabling the use of other features, such as changing application behaviors
    without the need to generate new versions of the software.
  prefs: []
  type: TYPE_NORMAL
- en: We will start learning about these resources via the fundamentals of configuration
    management through the **IConfiguration** interface.
  prefs: []
  type: TYPE_NORMAL
- en: IConfiguration interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has the **IConfiguration** interface, which aims to provide a
    mechanism for managing application settings and configurations in a unified manner,
    allowing access to diverse configuration sources such as JSON files, environment
    variables, and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the main concepts regarding the **IConfiguration** interface, we have
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration sources** : Support multiple configuration sources, which can
    be combined and layered. Common sources include JSON files (such as **appsettings.json**
    ), environment variables, command-line arguments, and user secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchical configuration** : Configuration settings are organized in a
    hierarchical structure. This means that settings can be nested into sections,
    making complex settings easier to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options pattern** : The Options pattern uses **IConfiguration** to bind configuration
    settings to strongly typed objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we used the **appsettings.json**
    file to manage the connection string with the SQL Server database and retrieved
    the value of this configuration through the **IConfiguration** interface, in the
    **Program.cs** class. This practice brings several benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility** : **IConfiguration** allows you to extract configuration values
    from multiple sources, offering flexibility in how you manage configurations across
    different environments (development, test, production)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized management** : Centralizes configuration management, making it
    easier to maintain and update settings without spreading them across the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment-specific settings** : Supports environment-specific configuration,
    allowing you to customize settings based on the environment in which the application
    is running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strongly typed configuration** : Through the Options pattern, it supports
    configuration settings linked to strongly typed classes, improving type safety
    and reducing errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code examples demonstrate a configuration defined in the **appsettings.json**
    file; this value is then retrieved through the **IConfiguration** interface, in
    the **Program.cs** file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of the **appsettings.json** file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the content of the **Program.cs** file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see in the highlighted line of the previous code snippet, the connection
    string is obtained from the **appsettings.json** file using the **IConfiguration**
    interface, using the **GetConnectionString** method and informing the configuration
    name or key.
  prefs: []
  type: TYPE_NORMAL
- en: As the **IConfiguration** lifecycle considers the application lifecycle, all
    the complexity of obtaining settings through files such as **appsettings.json**
    or other data sources is abstracted, simply using the methods available in the
    interface to obtain the desired parameters throughout the ASP.NET Core 9 application.
  prefs: []
  type: TYPE_NORMAL
- en: The **IConfiguration** interface is also available in the **dependency injection
    container** ( **DIC** ), allowing you to reference it in the constructor of any
    application class that will have its dependencies resolved dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: IConfiguration methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The **IConfiguration** interface provides several extension methods that offer
    different ways to obtain configuration data in ASP.NET Core 9 applications. See
    the following link for more details: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The process of obtaining configurations in JSON files is a standard model for
    use in ASP.NET Core 9 applications. However, there are other ways of managing
    configurations, and for this possibility, there is the concept of providers, which
    we will explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with configuration providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration providers allow configurations to be obtained from various sources,
    such as JSON files, environment variables, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Through configuration providers, we have greater flexibility and the ability
    to prepare our applications to run in different environments (such as development,
    test, or production) in an appropriate way without the need to implement string
    replacement logic in JSON files, in addition to bringing greater reliability and
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will understand how to add other configuration providers to our ASP.NET
    Core 9 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding configuration providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration providers are used to read configuration data from various sources.
    This flexibility allows you to manage your application’s configuration settings
    in a consistent and centralized manner.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it possible to use configuration sources such as databases and even
    cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 9, there are already some configuration providers integrated
    by default, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON configuration provider** : Reads configuration data from JSON files
    such as **appsettings.json**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variable configuration provider** : Reads configuration data
    from environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line configuration provider** : Reads configuration data from command-line
    arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory configuration provider** : Allows you to add in-memory configuration
    data, useful for unit testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the implementation of example applications in this book, we have constantly
    used the following method in the **Program.cs** file: **WebApplication.CreateBuilder(args);**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: This method creates an instance of a **Builder** object, which represents a
    web application and allows us to add features such as services, middleware, and
    configurations. It creates a web application builder with some default parameters,
    so there is no need to define the provider configuration to obtain configuration
    data from the **appsettings.json** file.
  prefs: []
  type: TYPE_NORMAL
- en: Default builder settings
  prefs: []
  type: TYPE_NORMAL
- en: 'The **CreateBuilder** method defines some standardized parameters for the builder
    that will be created. You can learn more about these parameters by accessing the
    following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, observe the following code example from the **Program.cs** file where
    configuration providers are explicitly added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses two extension methods, **AddEnvironmentVariables** and
    **AddCommandLine** , allowing the application to obtain configurations from different
    providers. These extension methods are natively part of ASP.NET Core 9 applications.
    For other types of providers, it may be necessary to add NuGet packages to have
    access to extension methods for registering providers.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in ASP.NET Core 9 configuration providers
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core 9 offers several types of providers natively, as presented in
    the documentation: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Working with dynamic configurations and behaviors* section, we will
    use a provider to connect to a cloud resource that allows the management of configurations
    and behaviors in a dynamic and secure way. For now, let’s understand some important
    fundamentals, such as creating custom providers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom configuration provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a custom configuration provider in ASP.NET Core 9 allows you to load
    configuration data from sources not natively supported by the framework. This
    can be useful for integrating with custom configuration stores, third-party services,
    or even proprietary formats.
  prefs: []
  type: TYPE_NORMAL
- en: We already understand configuration management in native provisions in ASP.NET
    Core 9; now, we will create our first custom provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom provider, you need to create two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConfigurationSource** : The **IConfigurationSource** interface represents
    a source of configuration data. It is responsible for creating an instance of
    **IConfigurationProvider** , which will actually load the data. Separating the
    source and provider interfaces allows for a clear delineation between where configuration
    data comes from and how it is loaded. Through this approach, we benefit from encapsulating
    data source configurations and implementing best practices through the **Factory**
    pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConfigurationProvider** : The **ConfigurationProvider** class is an abstract
    base class that implements **IConfigurationProvider** . It is responsible for
    the actual loading and providing of configuration data. This class allows you
    to define how data is read, cached, and accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start creating a custom provider through the class responsible for
    creating a custom provider instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The **IConfigurationSource** interface has only one method, **Build()** , which
    is responsible for returning a custom provider instance.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being simple, this class allows for better separation of responsibilities,
    with the sole objective of providing an instance of the provider that will have
    all the necessary mechanisms for interacting with another data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the **CustomConfigurationProvider** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The custom provider implemented in the preceding code has an inheritance from
    the abstract **ConfigurationProvider** class, which already has some utility implementations.
  prefs: []
  type: TYPE_NORMAL
- en: For this provider, we are creating two configurations that will be managed by
    an object of type **Dictionary<string, string>** , allowing us to create configurations
    based on key and value in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The logic for managing provided information must be implemented by overriding
    the **Load** method, inherited from the **ConfigurationProvider** class.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the **Load** method, it is necessary to set the value of the **Data**
    property, also inherited from the **ConfigurationProvider** class. The data type
    of the **Data** property is **Dictionary<string, string?>** ; that is, representing
    a key-value pair. Settings are persisted or serialized in string format. However,
    even with this feature, it is possible to create strongly typed configurations.
    We will cover this approach in the *Learning the Options* *pattern* section.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a simple and didactic example. However, we can easily connect
    the custom provider to a SQL Server database, a storage account, or any other
    persistence resource. In the book’s code repository, the link to which is in the
    *Technical requirements* section, you can analyze another version of a custom
    provider where the data is persisted in a database. However, the implementation
    principles are the same as those demonstrated in the previous code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the new provider to be used, simply add the following code to the **Program.cs**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the extension method creation technique learned in [*Chapter
    8*](B21788_08.xhtml#_idTextAnchor132) .
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the settings through the new provider, simply use **Configuration**
    property methods, such as the **GetValue<T>** method, and rename the desired configuration,
    as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the creation of a custom provider does not change the development
    model already available in ASP.NET Core 9, bringing greater flexibility and possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Providers are an excellent abstraction for configuration management. However,
    ASP.NET Core 9 provides other types, such as the Options pattern, which we will
    discuss in the next section, making the configuration management model in our
    applications even more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Options pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 offers a good way to handle application configurations through
    the use of the Options pattern. This pattern provides a robust mechanism for managing
    and accessing configuration settings in a strongly typed manner, improving the
    maintainability and testability of your code and organizing configuration settings
    into classes. In this section, we will understand what the Options pattern is
    and how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Options pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every application must interact with some type of configuration, and in the
    previous chapters, we used the **IConfiguration** interface to obtain continuous
    information in the **appsettings.json** file. However, this is not the only way
    to interact with configurations in ASP.NET Core 9, which offers an implementation
    of the Options pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Options pattern is a design pattern that uses classes to represent groups
    of related configurations, allowing you to link configuration sections from various
    configuration sources (such as JSON files, environment variables, and so on) to
    these classes, allowing access to configuration settings, type-safe configuration,
    leveraging IntelliSense, and compile-time checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 9, the Options pattern has the following class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9](img/B21788_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in *Figure 9* *.1* , there are several interfaces for abstracting
    the Options pattern, in addition to their respective implementations. Let’s briefly
    understand the purpose of each of the interfaces represented in *Figure 9* *.1*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '**IOptions<T>** : The basic interface used to retrieve configured options.
    **IOptions<T>** types are registered as singletons. Then, when starting the application,
    the configurations are loaded into memory and made available throughout the application
    using **dependency injection** ( **DI** ). However, if any changes are made to
    the application so that they can be reflected, the application must be restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IOptionsSnapshot<T>** : A variation of **IOptions<T>** that provides a mechanism
    that updates configurations with each request. This interface allows application
    settings to be updated in real time. The lifecycle of this class is scoped; that
    is, the configurations are loaded with each request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IOptionsMonitor<T>:** An interface that allows you to monitor option changes
    and provides a way to receive notifications when options are updated. The lifecycle
    of this interface is singleton, available when the application is initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that do not have the “ **I** ” prefix represent the concrete implementation
    of each interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Options pattern offers an excellent option for manipulating configurations
    without the need to call strings but by creating strongly typed configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand how the Options pattern is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Options pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned throughout the book’s chapters, it is a good practice to centrally
    manage configuration information, and in most of the code available in this book,
    we use basic configurations, such as a database connection string.
  prefs: []
  type: TYPE_NORMAL
- en: Although the **IConfiguration** interface provides us with mechanisms for obtaining
    configurations, in some cases, this can affect the management and responsibilities
    of each class, which must know exactly the strings it wants to obtain from the
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: There are practices such as the use of constants; however, working with strongly
    typed classes to aggregate a set of information can be a powerful resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine the following context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an e-commerce application, where we have different services and resources
    such as payment and shipping. These resources have a set of distinct settings.
    In this example, we would have approximately the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PaymentGatewayURL** : URL of the gateway responsible for processing the payment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APIKey** : API key for using the payment gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout** : Timeout configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DefaultCarrier** : Default carrier for delivering orders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreeShippingThreshold** : Free shipping threshold setting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When developing the e-commerce application, for each configuration, it would
    be necessary to use the **IConfiguration** class to obtain data from the **appsettings.json**
    file, for example. Let’s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding settings would be available in the **appsettings.json** file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the settings recovery code demonstrated is correct. However,
    in more complex scenarios, it may be difficult to manage different types of configurations;
    there may be code duplications, which makes maintenance difficult, and if there
    is a typing error in the configuration key, for example, this problem will only
    be detected at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, through the abstraction of the Options pattern in ASP.NET Core
    9, we have the possibility of grouping configurations in a simple way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding example, we basically have two types of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PaymentSettings**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PaymentGatewayURL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APIKey**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShipmentSettings**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DefaultCarrier**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreeShippingThreshold**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This way, we could group the configurations into two distinct classes, as shown
    in *Figure 9* *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Grouping configurations](img/B21788_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Grouping configurations
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding classes only have the properties that will reference the respective
    configurations in a grouped manner. With this, we will have the following code
    defining **PaymentSettings** and **ShipingmentSettings** classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The classes represented in the preceding code only aim to abstract a set of
    configurations, not having any types of implemented behaviors, but there may be
    methods if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the classes that will be used in the Options pattern must follow the
    following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Being non-abstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having public read-and-write properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields are disregarded during binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, we will just keep the properties. Additionally, we will change
    the **appsettings.json** file, which will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code that the settings are grouped by **PaymentSettings**
    and **ShippingSettings** , which are exactly the names of the classes, and respectively,
    the properties also have the same names.
  prefs: []
  type: TYPE_NORMAL
- en: The Options pattern uses this convention to bind the settings with the class
    that will abstract this information in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the **Program.cs** file with the changes made to use the
    Options pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the highlighted code lines in the preceding code block, the
    **GetSection** method is used from the **IConfiguration** interface, accessed
    through the **Configuration** extension method. The **GetSection** method is a
    generic implementation, where the type entered determines the return type. The
    name of the section is entered as a parameter, which, in this case, is the desired
    configuration group.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, to facilitate understanding, we are registering
    the configuration classes using the Options pattern directly in the **Program.cs**
    file. However, it is good practice to create an extension method for registering
    classes that use the Options pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When executing these methods, the settings will be loaded into a **PaymentSettings**
    or **ShipmentSettings** object and these will be instantiated as a singleton and
    available in every application through the DIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of code where the configurations depend on a given
    service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we noted in the **OrderService** implementation, we just injected an **IOptions**
    interface for the **PaymentSettings** type. With this, the dependency is resolved
    by the ASP.NET Core 9 DIC.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting the Options pattern offers several benefits, such as allowing the organization
    of configuration settings, grouping them into dedicated classes, and the use of
    strongly typed configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to improving maintenance and implementation quality, errors can
    also be detected during compilation time. You can also benefit from using unit
    tests, which is an excellent practice.
  prefs: []
  type: TYPE_NORMAL
- en: The Options pattern in ASP.NET Core 9 is a powerful and flexible way to manage
    configuration settings, supporting environment-specific configurations and making
    it easier to manage configurations for different deployment environments.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to use the Options pattern to properly deal with
    application configurations, it is time to understand how to manage these configurations
    securely in a cloud environment, in addition to learning how to dynamically manipulate
    behaviors in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dynamic configurations and behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of web applications, maintaining flexibility
    and responsiveness is crucial. As developers, we must ensure that our applications
    can adapt to changes quickly and securely. Dynamic configurations and behavior
    management are key strategies that allow us to achieve this flexibility. By managing
    configurations dynamically, we can update them without redeploying our applications.
    Additionally, by implementing application behavior management using techniques
    such as **feature toggles** , we can control resource availability in real time,
    giving us the ability to effortlessly test, deploy, or roll back features.
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles or feature flags are a software development technique used to
    enable or disable specific functionality in a software application at runtime,
    facilitating **continuous integration and delivery** ( **CI/CD** ) by allowing
    code changes to be merged into the main code base without immediately exposing
    new functionality to all users. This technique helps in mitigating risks, conducting
    A/B testing, performing canary releases, and rolling back features without redeploying
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the following article to learn more about the technique: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into the details of dynamic configuration management and implement
    a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dynamic settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamic settings refer to the ability to modify application configurations at
    runtime without the need for redeployment. This capability is essential for maintaining
    application uptime, ensuring quick responses to changes in requirements, and enhancing
    security by allowing rapid adjustments to sensitive configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern applications must have dynamic configuration management mechanisms to
    guarantee the quality of the solution, in addition to benefits such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero downtime** : Update configurations without redeploying the application,
    ensuring continuous availability. This is an important feature that allows us
    to bring reliability and a better experience to users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : Quickly update security settings and credentials in response
    to threats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility** : Adjust settings in real time to accommodate changing business
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified deployments** : Reduce the complexity and risk associated with
    application deployments by decoupling configuration changes from code changes.
    In scenarios with many environments, such as development, testing, and production,
    the application will have different configurations based on the resources of each
    environment. Having the ability to abstract the management of application configurations
    improves quality, segregates responsibilities, and maintains continuous delivery
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several options are available to dynamically manage configurations in ASP.NET
    Core 9, including configuration files, environment variables, and cloud-based
    services such as **Azure App Configuration** . Azure App Configuration stands
    out for its robust features and seamless integration with other Azure services.
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration is a service that provides a centralized way to manage
    configuration settings and feature flags. It allows applications to dynamically
    adjust their behavior without redeployment.
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration is a powerful feature available in Microsoft Azure that
    allows us to manage configurations and feature toggles securely, supporting the
    deployment of cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about Azure App Configuration, I suggest reading the rich
    documentation about the resource: [https://learn.microsoft.com/en-us/azure/azure-app-configuration/](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover all the details of setting up and using Azure App Configuration
    in this book. For now, we will use the main resources to exemplify the use of
    dynamic configurations in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an application that interacts with Azure App Configuration and
    uses some patterns already learned in this chapter, such as the Options pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Azure App Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure App Configuration is a cloud-based service that provides a centralized
    repository for application configurations, enabling dynamic configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an Azure App Configuration resource before creating an application.
    You will need access to an Azure subscription, as described in the *Technical*
    *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'With access to the Azure subscription, follow these steps to create an Azure
    App Configuration resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ), and in the search field, in the top bar, type **App Configuration** and click
    on the icon, as highlighted in *Figure 9* *.3* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Accessing the App Configuration service](img/B21788_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Accessing the App Configuration service
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, click on the **+ Create** option to add the new resource,
    as shown in *Figure 9* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Creating a new App Configuration resource](img/B21788_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Creating a new App Configuration resource
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, we must configure the parameters of the new resource. We
    will keep the default settings. Use the following parameter suggestions as a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resource group** : **rg-aspnetcore8** . Be sure to click the **Create new**
    button below the **Resource group** field to create the new resource group.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location** : **East** **US 2**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource name** : **<Your** **Last Name>-configuration**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing** **tier** : **Standard**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the **Create replicas** option unchecked.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Review + Create** button then the **Create** button, and wait
    for the resource to be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you finish creating the new resource, click the **Go to resource** button,
    as shown in *Figure 9* *.5* , or access the **App Configuration** list, as described
    in *step 1* , and click on the created resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – New App Configuration creation status](img/B21788_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – New App Configuration creation status
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the configuration management resource created, it’s time to
    create and configure our application to interact with Azure App Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting an application in Azure App Configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this example, an ASP.NET Core 9 MVC application will be created and connected
    to the Azure App Configuration service created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal, and in a folder of your choice, create a directory named
    **DynamicConfiguration** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, access the directory with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to create the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous command creates an MVC application with the name **DynamicConfiguration**
    , defined with the **-n** parameter and in the current directory, determined by
    the **–o .** parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the application created, we will simply prepare it to integrate with Azure
    App Configuration. To do this, run the following command in the application directory
    to open Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the root of the project, create an **Options** folder and then create
    a file called **GlobalOptions.cs** . This file must contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The **GlobalOptions** class has only one property called **Title** that will
    be obtained through Azure App Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When the application starts, it loads the settings as we learned previously,
    using files such as **appsettings.json** and environment variables, among other
    providers that can be configured. However, for our classes, the details of obtaining
    the configurations are abstracted by ASP.NET Core 9, and, in this case, whatever
    the provider, when using the Options pattern, we will have the correct separation
    of responsibility, maintainability, flexibility, and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the code of the **HomeController** class, in the **Controllers**
    folder, and add the settings previously created using the Options pattern. The
    **HomeController** class code will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple changes were made to the class. Let’s understand each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GlobalOptions field** : A new field was created for the class that is of
    type **GlobalOptions** , created previously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change in the constructor** : Configurations will be injected through the
    ASP.NET Core 9 DIC, and that is why we added a parameter of type **IOptionsSnapshot<GlobalSettings>**
    . The purpose of using the **IOptionsSnapshot<>** interface is to allow you to
    obtain configurations dynamically, as we learned in the *What is the Options pattern?*
    section. If another interface is used, such as **IOptions<>** , the parameters
    will be loaded, but not dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changing the Index action** : We change the **Index** action where we set
    the value of the **Title** property in the **ViewData** dictionary with the value
    of the configuration of the **Title** property of the **_globalOptions** object.
    The **ViewData["Title"]** dictionary is used in the **Views/Home/Index.cshtml**
    file to display the page title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s change the code on the **Views/Home/Index.cshtml** page to display
    the title in the body of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the highlighted code, we are only rendering the value contained
    in the **ViewData["Title"]** dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The application is prepared to render data obtained through configuration. Now,
    it’s time to connect the application to Azure App Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the terminal in the application directory and run the following
    command to add the NuGet package that contains the necessary SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will need to get the connection string containing the resource from
    Azure App Configuration. Let’s execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search field, in the top bar of the portal, type **App Configuration**
    and click on the option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the list of configuration resources, click on the previously created
    resource with the name **<Your** **Last Name>-configuration** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the side menu, look for the **Access settings** option and copy the connection
    string as shown in *Figure 9* *.6* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Getting the connection string from App Configuration](img/B21788_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Getting the connection string from App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command in the terminal, in the application directory.
    The command uses a secret manager to store a secret named **ConnectionStrings:AppConfig**
    , which stores the connection string for your App Configuration store. Replace
    the **<your_connection_string>** placeholder with your App Configuration store’s
    connection string. This is a good practice to prevent sensitive data, such as
    connection strings that are credentials or have passwords, from being persisted
    in version control, bringing vulnerabilities to your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the definition of the secret that contains the App Configuration connection
    string, we will change the **Program.cs** file to add the necessary services and
    middleware. Let’s look at the changed **Program.cs** code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The App Configuration SDK has excellent abstraction and is simple to integrate
    into the application. Let’s understand the changes made to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**builder.Services.AddAzureAppConfiguration()** : This method registers the
    necessary services for Azure App Configuration to work within your ASP.NET Core
    9 application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Configuration.GetConnectionString("AppConfig")** : This line of code
    gets the Azure Application Configuration connection string, previously obtained
    from the Azure portal and added to the application via a secret. Note that getting
    the connection string is identical to getting it from **the appsettings.json**
    file. The big difference in managing configurations through secrets is that they
    are only kept on the local machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Configuration.AddAzureAppConfiguration** : This extension method
    adds Azure App Configuration as a configuration provider to your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options.Connect(connectionString)** : Connects to the Azure application configuration
    instance using the previously obtained connection string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.Select("Dynamic Configuration:*", LabelFilter.Null)** : Specifies that all
    keys with the **DynamicConfiguration:** prefix should be selected. The **LabelFilter.Null**
    parameter indicates that only unlabeled configurations are retrieved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.ConfigureRefresh** : The **ConfigureRefresh** method registers keys that
    you want to monitor for changes in your application configuration store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**refreshOptions.Register("Dynamic Configuration", updateAll: true)** : Registers
    a sentinel key ( **DynamicConfiguration:Sentinel** ) that triggers an update.
    When the value of this key changes, all settings will be updated ( **refreshAll:
    true** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Services.Configure<GlobalOptions>(builder.Configuration.GetSection("DynamicConfiguration:
    GlobalOptions"))** : This line of code binds the configuration created in Azure
    App Configuration and the **GlobalOptions** class created previously. With this,
    it will be possible to obtain the configuration through the DIC using the Options
    pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UseAzureAppConfiguration** : Allows your application to use the application
    configuration middleware to update configuration automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the previous configurations, added to the **Program.cs** file, allow
    the application to connect to Azure App Configuration via the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: The App Configuration SDK works with the concept of pooling. In this case, when
    obtaining the configurations, a cache is made in the application’s memory, to
    avoid constant requests to the Azure service and optimize the application’s functioning.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the time the application queries Azure App Configuration for updates
    is 30 seconds. It is possible to specify the refresh call time using the **refreshOptions.SetCacheExpiration**
    method. A **Sentinel** parameter was also configured, responsible for determining
    whether there were changes to the settings.
  prefs: []
  type: TYPE_NORMAL
- en: It is important as it prevents the SDK from analyzing each configuration individually,
    and if **Sentinel** has been changed, all configurations will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve learned how Azure App Configuration settings work, let’s create
    configuration keys in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ), in the App Configuration resource created previously, select the **Configuration
    explorer** option, as shown in *Figure 9* *.7* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration](img/B21788_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on the **Create** | **Key-value** option, as shown in *Figure 9*
    *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Adding a new configuration on Azure App Configuration](img/B21788_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Adding a new configuration on Azure App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'A form will be displayed where we will enter the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key** : **DynamicConfiguration:Sentinel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value** : **1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the rest of the parameters at their defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *step 2* and add another key with the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Key** : **DynamicConfiguration:GlobalOptions:Title**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value** : **ASP.NET** **Core 9**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the **DynamicConfiguration:GlobalOptions:Title** key. This key represents
    a hierarchy following the pattern **<Group Settings>:<Section>** . In this case,
    it is the name of the previously created settings class, configuration, or desired
    property of the configuration class format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Labels in Azure App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: The **Label** parameter in Azure Application Configuration is used to differentiate
    configuration settings based on different contexts or environments.
  prefs: []
  type: TYPE_NORMAL
- en: Labels allow you to separate configurations for different environments (for
    example, development, staging, production).
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach brings benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**• Flexibility** : Easily switch between different sets of configurations'
  prefs: []
  type: TYPE_NORMAL
- en: '**• Isolation** : Keep settings for different environments or scenarios isolated
    and organized'
  prefs: []
  type: TYPE_NORMAL
- en: '**• Testing** : Safely test new configurations without affecting other environments'
  prefs: []
  type: TYPE_NORMAL
- en: Settings that do not have a **Label** parameter will be treated as default settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about labels, visit the following URL: [https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core](https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the application is integrated with Azure App Configuration, open the
    terminal and access the application directory. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, access the application URL available on your terminal via the following
    URL: **http://localhost:<port>** . In the example shown in *Figure 9* *.9* , the
    URL is **http://localhost:5295** . We can also see in *Figure 9* *.9* a welcome
    message with the value defined in the App Configuration resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Application getting settings from Azure App Configuration](img/B21788_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Application getting settings from Azure App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the configurations are being loaded directly from the Azure resource.
  prefs: []
  type: TYPE_NORMAL
- en: With the application still running, access the Azure portal ( [http://portal.azure.com](http://portal.azure.com)
    ) and the Azure App Configuration resource.
  prefs: []
  type: TYPE_NORMAL
- en: Then, access the **Configuration explorer** option. We will change the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, in the settings display grid, click on the three dots ( **...**
    ) as shown in *Figure 9* *.10* and click **Edit** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Editing configurations](img/B21788_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Editing configurations
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DynamicConfiguration:GlobalOptions:Title** : **ASP.NET Core 9 With** **Dynamic
    config**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DynamicConfiguration:Sentinel** : **2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wait a few seconds, access the application again, and refresh the page. The
    page body message was changed, as shown in *Figure 9* *.11* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Application obtaining configurations dynamically](img/B21788_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Application obtaining configurations dynamically
  prefs: []
  type: TYPE_NORMAL
- en: Despite being a simple implementation example, using a config server is a good
    practice in cloud-native applications, as suggested in The Twelve-Factor App methodology
    ( [https://12factor.net](https://12factor.net) ), and ASP.NET Core 9 provides
    several extensibility mechanisms, such as the one we use when integrating with
    Azure’s App Configuration feature.
  prefs: []
  type: TYPE_NORMAL
- en: This approach in large application scenarios in production environments can
    bring several benefits by offering an immediate response to certain changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Twelve-Factor App methodology
  prefs: []
  type: TYPE_NORMAL
- en: 'The Twelve-Factor App methodology is a methodology used as a reference in creating
    **SaaS** ( **Software as a Service** ) application and has 12 factors, technology
    agnostic, that offer best practices for developing cloud-native solutions. One
    of the factors is related to configuration management, related to what we learned
    in this chapter, and you can learn more about this factor through the following
    URL: [https://12factor.net/config](https://12factor.net/config) .'
  prefs: []
  type: TYPE_NORMAL
- en: Managing configurations on a server such as Azure App Configuration brings several
    benefits, the most important being security. With the easy integration with ASP.NET
    Core 9 applications, we can allow our applications to change settings dynamically
    and even segregate them by environment. This approach is very important in a CI/CD
    process. We will talk more about CI/CD in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Another approach that can be used to bring greater capacity to our applications
    in addition to improving user experience, among other benefits, is real-time behavior
    management, which we will learn about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting an ASP.NET Core 9 application to Azure App Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Surely at some point, you have already used a mechanism that dynamically changes
    the behavior of an application. Imagine a scenario where you install, for example,
    a messaging app that allows users to send videos, photos, and audio.
  prefs: []
  type: TYPE_NORMAL
- en: These media are automatically downloaded when you receive messages, which requires
    data consumption on your smartphone. In general, the first action we would take
    would be to disable the automatic media download option. This setting is found
    in a settings menu; however, this setting completely changes, in real time, the
    way the application will behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned example is a simple concept of changing the behavior of
    applications in real time. Likewise, at some point, web applications may have
    their behavior dynamically managed, and their use brings several benefits, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlled releases** : Gradually release features to a subset of users to
    monitor performance and user feedback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A/B testing** : Conduct experiments by rotating features for different groups
    of users to determine the best approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instant rollbacks** : Quickly disable a feature if it causes problems, without
    redeploying the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technique that allows changing the behavior of applications in real time
    is called feature toggles or feature flags .
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles, also known as feature flags, are a software development technique
    that allows you to enable or disable features in an application at runtime without
    deploying new code, bringing flexibility for better risk management and improving
    the deployment process, enabling teams to release resources to specific users
    or environments, and improving overall development and operational efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of coding, a feature toggle can be represented as shown in *Figure
    9* *.12* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Representation of the feature toggle concept](img/B21788_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Representation of the feature toggle concept
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 9* *.12* , the feature toggle is basically a decision
    point in the application’s source code. This decision point checks whether a certain
    value, called a toggle, is activated. To check if a toggle is activated, we can
    obtain this value through a configuration file, environment variables, and even
    on a remote server, which is the most recommended way.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs: []
  type: TYPE_NORMAL
- en: Implementing feature toggles in ASP.NET Core 9 should follow best practices
    to make your code cleaner, easier to maintain, and more scalable. When using feature
    toggles, it is bad practice to lump multiple behaviors into a single class, such
    as handling different features or switching between old and new logic within a
    service. This approach can lead to code that is difficult to understand and modify.
    A good practice is to follow the **Single Responsibility Principle** ( **SRP**
    ), which means that each class should handle only one responsibility or feature.
    By keeping each class focused on one task, you reduce complexity and make your
    application easier to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, using factory methods with DI in ASP.NET Core 9 allows you to
    easily swap out different implementations based on feature toggles without breaking
    the SRP. If you need to add a new feature, you can simply create a new class for
    that feature, isolating the existing logic. To learn more about the SRP, access
    the following URL: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: All the details surrounding the use of the feature toggle technique and its
    respective benefits not only for development teams but also for management and
    complexity aspects go beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We already have a basic knowledge of using this technique, and now, it’s time
    to use it in an ASP.NET Core 9 application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing feature toggles with Azure App Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous topic, we used the Azure App Configuration feature for configuration
    management; however, this service also includes feature flags, which you can use
    to enable or disable a feature. Through the UI in the Azure portal, we can create
    and manage the feature flags of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make some changes to the **DynamicConfiguration** project code, created
    previously, and add feature toggles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and go to the application directory. Then, run the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These packages are necessary to incorporate the SDK for managing toggles in
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the application in Visual Studio Code, then we will edit the **Program.cs**
    file, which will have the following updated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Basically, we make three changes to the **Program.cs** file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**using Microsoft.FeatureManagement** : Adding the namespaces necessary to
    add the SDK’s toggle management features.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Services.AddFeatureManagement()** : Adding services to the application’s
    DIC.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.UseFeatureFlags** : We changed the connection settings with Azure App Configuration,
    informing us that the toggle management feature will be used. Additionally, a
    5-second cache was defined using the **featureFlagsOptions.CacheExpirationInterval**
    standard.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the Azure App Configuration SDK, we can work with toggles directly
    in the code of controllers or services, using the **IFeatureManager** interface,
    the **FeatureGate** attribute, or a **tag helper** directly in views. For this
    example, we will use a tag helper.
  prefs: []
  type: TYPE_NORMAL
- en: Using IFeatureManagement and the FeatureGate attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we can analyze whether a toggle is activated or not through
    the **IFeatureManagement** interface, which is injected into a class and provides
    us with methods to test the values, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public class MyController :** **Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**private readonly** **IFeatureManager _featureManager;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public** **MyController(IFeatureManager featureManager)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_featureManager =** **featureManager;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**private async** **Task MyMethod()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if (await** **_featureManager**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.** **IsEnableAsync("FeatureToggleName"))**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console.WriteLine("New Approach");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console.WriteLine("Legacy Approach");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, it is possible to annotate an action or controller with the
    **FeatureGate** attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '**using Microsoft.FeatureManagement.Mvc;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[** **FeatureGate("FeatureToggleName)]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public class MyController :** **Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// ....**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: This way, it is possible to benefit from the use of toggle management with different
    implementations but the same concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the application to use a tag helper, which will use the feature
    toggle. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, edit the **Views/_ViewImports.cshtml** file and add
    the following code to the file, below the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds a tag helper from the Azure App Configuration SDK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, open the **Views/Home/Index.cstml** file and use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the use of the feature tag, which will basically obtain information on
    whether a toggle is enabled. If yes, the new **div** tag will be displayed on
    the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that everything is configured in the application, let’s add the feature
    toggle in Azure App Configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ) and access the App Configuration resource created in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the **Feature manager** menu, **Create** | **Feature flag**
    , as shown in *Figure 9* *.13* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Adding a new feature flag](img/B21788_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Adding a new feature flag
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, set the **New feature flag** field to the **NewFeature**
    value and leave the rest at their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Apply** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A new feature flag will be created and disabled, as shown in *Figure 9* *.14*
    :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Application using a disabled feature flag](img/B21788_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Application using a disabled feature flag
  prefs: []
  type: TYPE_NORMAL
- en: We did this configuration on purpose. Now, run the application again using the
    **dotnet run** command, executed through the terminal in the application directory
    and you’ll see there is no changes on the application. The reason the new **Div**
    tag was not displayed is that we created the toggle as **Enabled= false** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the application running, access the Azure portal again, and enable the
    toggle by clicking on the **Enabled** column in the grid, as shown in *Figure
    9* *.15* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Enabling the feature flag](img/B21788_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Enabling the feature flag
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the application again, and we can see in *Figure 9* *.16* that a new
    HTML element has been added to the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Application behavior changed at runtime](img/B21788_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Application behavior changed at runtime
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and implementing dynamic configurations and feature toggles,
    we can create robust, flexible, and responsive ASP.NET Core 9 applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have used Azure App Configuration as a feature flag manager.
    However, ASP.NET Core 9 has integrations with several other types of toggle management
    servers using the same techniques learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of configuration management techniques and feature flags is
    very powerful for different application contexts, mainly interacting with cloud
    resources in a scenario of continuous delivery of value through automated mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to host our applications in cloud environments using automated
    processes in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into good practices for managing application configurations
    by understanding the concepts and abstractions of the IConfiguration interface.
    We also worked with concepts related to the ASP.NET Core 9 configuration provider,
    along with the implementation of the Options pattern. Finally, we worked with
    changing application configurations and behavior in real time using Microsoft
    Azure’s Azure App Configurator to implement the concept of feature flags or feature
    toggles. Working with cloud resources is an important premise for Software Engineers
    and in the next chapter, we will explore how to deploy applications in a Cloud
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Hosting, Deploying, and Preparing to the Cloud'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications are dynamic, and as software engineers, our work doesn’t
    end after synchronizing the latest code developed. In a scenario where the market
    is constantly changing, it is necessary for applications to be dynamic enough
    to meet constant market demands. Therefore, development teams must adapt to the
    new topics surrounding the modern development model. ASP.NET Core 9 is prepared
    to provide high-quality solutions, suitable for cloud environments. In this part,
    we will learn about aspects involving the continuous delivery of solutions through
    the understanding and implementation of application publishing flows in a cloud
    environment with the support of automated pipelines such as **Continuous Integration**
    ( **CI** ) and **Continuous Delivery** ( **CD** ), processes associated with the
    DevOps culture. We will understand what a cloud-native mindset is and how to direct
    our solutions to a constantly changing market.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) *, Deploying and Hosting Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21788_11.xhtml#_idTextAnchor183) *, Cloud-Native Development
    with* *ASP.NET Core 9*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
