- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Deployment Dramas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Deployment* *and Distribution*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow me to make a confession: I love writing code. The whole process that
    starts with a vague idea, followed by writing the first lines of code, then finding
    issues and debugging the code, gives me a thrill. There is something magical about
    creating something out of thin air and seeing it come to life before my eyes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But there comes a moment when the software is “good enough” and it needs to
    move into production. After all, we write software with a purpose: it needs to
    be used. And that usually means moving it away from your development machine to
    a production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many challenges in this process. But don’t worry: we will tackle
    all of them! We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What does deployment mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you use the Publish wizard from Visual Studio?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is CI/CD, and how do I use it in Azure DevOps or GitHub?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I build an installer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I deploy with Docker?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if you are ready to let the world see the fruits of your labor but are unsure
    how to get that out there, this is the chapter for you.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code in this chapter in our repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along with the CI/CD samples in Azure, you’ll need an
    Azure subscription. You can sign up for a free trial for Azure at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a go with GitHub Actions, you’ll need to sign up for a GitHub account.
    You can get a free one here: [https://github.com/signup](https://github.com/signup).'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along when we talk about the setup projects, you must
    install **Visual Studio Extension Microsoft Visual Studio Installer Projects 2022**.
    You can find this by going to the **Extensions** menu item and choosing **Manage
    extensions**. From there, in the **Online** tab, search for that extension.
  prefs: []
  type: TYPE_NORMAL
- en: With this tool, you can follow along and build your own installers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to work with the Docker sample, install Docker Desktop. You can
    find it here: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  prefs: []
  type: TYPE_NORMAL
- en: All the software mentioned here is free or has a free trial.
  prefs: []
  type: TYPE_NORMAL
- en: From development to production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will come a moment when you’re developing your application when you decide
    it is time for other people to try out the fruits of your labor. This means moving
    your application from your development machine to another environment. This could
    be another developer’s machine or a production system.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of your system, moving the bits away could involve
    anything from a simple file copy to building a complex installer application.
    You also have to think about ways to remove your application from their system
    and about ways to update or upgrade your application. All these tasks are gathered
    under the term *deployment*.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment should be as seamless as possible. The users should be able to take
    your application and prepare it for use effortlessly. This means all the hard
    work lies with us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a deployment scenario involves thinking about the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying your binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying the binaries your system depends on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying additional files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting user rights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying settings and altering them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and copying secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering system settings such as paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering your application in the host environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uninstalling your applications means reversing this process: in an ideal world,
    an uninstall leaves no trace of your application and the associated files on the
    host machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading and updating is a mix of these scenarios: deploying new code, changing
    settings, and removing things you no longer need in the latest version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If all you have is a simple, standalone console application, deployment is
    a breeze: just copy the files needed. Suppose you’re deploying a complex system,
    such as a background worker; this needs configuration settings to connect to external
    systems. In that case, you have a lot more work to do. But there is good news:
    for each of those and other scenarios, there are strategies to follow. And that
    is what the rest of this chapter is all about. So, do a final build of your app,
    do a quick local test, and let’s deploy our work!'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing and file copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to deploy an application is to use Visual Studio’s Publish mechanism.
    Let’s assume I have a simple console application. I don’t have any configuration
    settings that I need to change when running on a production environment. So, I
    can just copy what I have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a simple console application. You’ve tested it, and you’re
    ready to deliver. There are two options: use **Visual Studio** or use the **CLI**.'
  prefs: []
  type: TYPE_NORMAL
- en: Publish using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Visual Studio, in the **Solution Explorer** area, right-click on your project
    and select **Publish**. You’ll see the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Publishing via Visual Studio](img/B20924_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Publishing via Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure**: This means deploying your system to Azure so that it runs there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ClickOnce**: ClickOnce is a technique for building a simple installer. Updates
    and uninstallation are part of the mechanism. However, ClickOnce is meant for
    Windows applications that the users start. Therefore, this is not a solution for
    us system programmers. For that reason, I will not cover ClickOnce here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Container Registry**: This is a great way to package and deploy systems.
    We will discuss this later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Folder**: This is the simplest way to publish as it just copies all files
    needed to a folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Import Profile**: If you’ve already defined deployment methods, you can use
    those settings here by importing them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we’ll choose **Folder**. Upon doing so, you’ll get a new dialog
    asking if you want to use **ClickOnce** for the folder deployment or whether you
    wish to deploy to the filesystem. Choose **Folder** to pick the latter. At this
    point, you can enter the path to which you want to publish. For now, leave it
    as the default setting. Click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: Although you clicked `FolderProfile.pubxml`, and you can find it in the **Solution
    Explorer** area in your project under **Properties** > **PublishProfiles**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio will open the profile and show you what it looks like. From here,
    we can click the big **Publish** button; however, we might want to tweak the profile
    before doing that. Click **More Actions** and choose **Edit**. This results in
    the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: The Profile settings dialog](img/B20924_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: The Profile settings dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can tweak the profile a lot here. Let’s walk through the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration**: You can choose any configuration you might have defined
    in your project. By default, these are the **Debug** and **Release** configurations.
    I suggest that you use **Release** for deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target framework**: Here, you can choose any compatible and installed framework
    you want for your application. Just leave this set to what you used when you were
    building your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment mode**: Here, you can choose between **Framework-dependent** and
    **Self-contained**. If you pick **Framework-dependent**, the application will
    assume the .NET runtime is installed on the target machine. However, if you select
    **Self-contained**, all needed assemblies will be part of the publication. Your
    package will be much bigger since it contains everything you need from the .NET
    runtime. However, it does not rely on others to install the .NET runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target runtime**: This is where you decide on the architecture of the target.
    If you know what architecture that machine is, you can choose it from the drop-down
    menu. This results in more optimized code but restricts where you can use it.
    For instance, if you decide to use Win-X64, you cannot deploy your code to a Linux
    machine. If you do not want to make that decision, leave it set to **Portable**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target location**: This is the location where the files will be copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose you decided to go with the **Self-contained** option. In that case,
    you get three additional choices: **Produce Single file**, **Enable ReadyToRun
    compilation**, and **Trim** **unused code**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is self-explanatory: you get one big file instead of dozens
    of small files. **ReadyToRun** is a form of **ahead-of-time** (**AOT**) compilation.
    This means the code is pre-compiled and thus starts faster. It is not a real AOT
    compilation: the resulting files contain both the compiled code and the IL. Still,
    it saves startup time. The **Trim unused code** option removes all code from the
    runtime you don’t need. Selecting this option makes the final package a lot smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make your changes and then click **Save**. After that, click **Publish**. When
    Visual Studio is finished, go to the folder you picked as the destination and
    inspect what has happened (*hint*: you can click on the **Target location** value
    in the **Publish Profile** dialog to open an **Explorer** window and go to the
    location directly).'
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to copy the resulting files to the target machine. Then,
    you can run it on that machine to see if everything is working fine and you are
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations: you just deployed your application!'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing using the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Visual Studio wizard is very good at helping you build the profile. Still,
    if you already know what you’re doing or want to make publishing part of a pipeline,
    you can use the CLI to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base command is simple – in the directory where you have your `.csproj`
    file, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command takes all the default settings in the dialog box and uses them
    to publish your application. Of course, you can change what `publish` does: all
    you have to do is supply the correct parameters. The following table shows the
    most common ones and their possible values. Most parameters have two variants
    – a full parameter name (often preceded by two dashes) and a shorthand (often
    preceded by one dash):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** | **Possible Values** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-``o`/`--output` | The output directory to place the published artifacts
    in | The directory where you want to place the published application |'
  prefs: []
  type: TYPE_TB
- en: '| `--``sc`/`--self-contained` | Includes the runtime with your application
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| `-``f`/`--framework` | The target framework you want to deploy to | `net6.0``net7.0``net8.0`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``r`/`--runtime` | The target runtime to publish for | `win-x64``linux-x64``linux-arm`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``c`/`--configuration` | The build configuration | `Release``Debug` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.1: dotnet publish options'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to build a self-contained deployment, you can add three more
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `-``p:PublishSingleFile=true` | Creates a single file |'
  prefs: []
  type: TYPE_TB
- en: '| `-``p:PublishReadyToRun=true` | Compiles to Ready To Run AOT binaries |'
  prefs: []
  type: TYPE_TB
- en: '| `-``p:PublishTrimmed=true` | Removes all unnecessary code from the binaries
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.2: Self-Contained extra options'
  prefs: []
  type: TYPE_NORMAL
- en: You could specify that you do not want these options by setting them to `False`,
    but I suggest that you omit that parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to publish your console application to a specific folder, create a self-contained
    deployment in a single file that’s ready to run, and trim all unnecessary code
    for a `win-x64` architecture running on `net.80`. To do so, issue the following
    code (all on a single line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you go to the `d:\temp\publish` folder, you can take the file there,
    copy that to your production machines, and run it. At this point, you can sit
    back, knowing your hard work is finally being used.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure DevOps and GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your code is meant to be used in the cloud, such as on Azure or AWS, you
    can use Azure DevOps and GitHub. Which one you pick depends on where you currently
    have your source code. Both DevOps and GitHub allow for **continuous integration
    and continuous deployment** (**CI/CD**) scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: The idea with CI/CD is that when you change your source code, the system notices
    this and builds your software. Then, it can run tests optionally (in my view,
    it is not optional, but mandatory). After, it automatically deploys the new binaries
    to the production environment. This way of working means that you can do a lot
    of minor, incremental updates to your system and get early feedback on what you
    did. If this fits your use case, it is a great tool!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at Azure DevOps first.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I assume you have an Azure DevOps project set up, have defined the working process,
    and have a repo available to host your code.
  prefs: []
  type: TYPE_NORMAL
- en: You can connect Visual Studio to that project if you have done so. In my case,
    I have created a simple Function App. A Function App is a service that runs in
    Azure. In this case, I have decided to use a simple HTTP-based trigger. In other
    words, the function responds to a REST API call and returns a string with a pleasant
    greeting. This chapter is not about writing Azure Functions but about deploying
    code, so I won’t dive into the details of how the code works. For now, it’s a
    REST API that you call with a parameter called `name`; it returns a friendly greeting
    containing that name. That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to make things more interesting, I have called my program `MyFileConverterFunctionApp`.
    Trust me: it doesn’t do anything interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have the code up and running locally, it is time to prepare your system
    for deployment. There are two steps we need to take.
  prefs: []
  type: TYPE_NORMAL
- en: Create a publish profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish the system to Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Building the publish profile for Azure DevOps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before I show you how to deploy your application to Azure, let’s review the
    prerequisites if you want to follow along. First, you need a project to deploy.
    But besides this obvious prerequisite, these are the things you’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A resource group (mine is called `SystemsProgrammingRg`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Key Vault to store secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A storage account. We’ll need this for deployment later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have these, you’re ready to start the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio, right-click on your project’s name and select **Publish**.
    You’ll be taken to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: Default publishing dialog](img/B20924_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Default publishing dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, this is the same dialog we saw previously. However, this time, select **Azure**
    as your target.
  prefs: []
  type: TYPE_NORMAL
- en: The following dialog will ask you what kind of service you want to deploy. I
    chose **Azure Function App (Windows)**. You could go for a Linux deployment. Don’t
    worry about the container options for now; we will discuss Docker and containers
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to tell Visual Studio about the final location of our application.
    Likely, you won’t have a Function App you can use (that wasn’t part of the prerequisites,
    after all), so you can create one now. You’ll be presented with a dialog asking
    you about your environment and preferences. Mine looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Creating a new Function App in Visual Studio](img/B20924_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Creating a new Function App in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve blacked out my Azure account details since I want you to use yours. You
    need to choose the options that are best for you. This dialog is also where you
    must specify the storage account I told you to create (in my case, it is `dvstorageaccountsp`).
    I also decided to add **Application Insights**. Using **Application Insights**
    helps me monitor and troubleshoot my application if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click **Create**, the system will build your environment. This takes
    a while, but we can move to the next screen when it is done. This next screen
    gives you an overview of all app services in the given resource group and all
    the deployment slots. Since we haven’t deployed yet, this list is empty. Click
    **Next**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: Choosing what to generate as a publishing mechanism](img/B20924_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Choosing what to generate as a publishing mechanism'
  prefs: []
  type: TYPE_NORMAL
- en: We can choose whether to use a publish profile or GitHub Actions here. We will
    look at GitHub Actions shortly, so let’s go with **Publish** for now. Visual Studio
    will generate the Publish profile for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'When that is done, we’ll get an overview, including a nice, big, inviting **Publish**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Overview of the Publish profile](img/B20924_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Overview of the Publish profile'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s click that **Publish** button!
  prefs: []
  type: TYPE_NORMAL
- en: Again, this takes a little while, but when your code has been published, you’ll
    get a hyperlink that allows you to go to the resource. You can click that, but
    it won’t be exciting. It’s just a web page saying your Function App is up and
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what happened, go to the Azure portal, find your resource group, and
    locate the Function App we created. There, you can test the function right inside
    the Azure web portal. Or better yet, open Visual Studio Code (if you have that
    installed), create a new file called `test.http`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace my URL with yours, and click the **Send Request** link at the top of
    the first line. This will call the server. You’ll get some results that should
    look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Your data will be different, but the important part is that we get the `HTTP/1.1
    200 OK` result. This shows that our app works!
  prefs: []
  type: TYPE_NORMAL
- en: Enabling continuous integration in Azure DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pushing to Azure directly from your development environment is convenient. Once
    you’ve set up the publishing profile, right-click on your program and click **Publish**
    to move your changes to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a better way of doing this, though: you can enable CI/CD so that any
    change you make is automatically deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: Branching and CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: 'In all my samples, I use a single branch: `main`. I push changes from `main`
    on my machine directly to the online source repositories and let the systems build
    from that. In a real-world scenario, that is a terrible idea. You should pick
    up a branching strategy that allows for a good separation between the daily work
    and the deployments. You need things such as pull requests and merging strategies
    to preserve the quality of the work. Please don’t do what I’ve done here and have
    only a single branch.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we achieve this magic? How do we get our changes “auto-magically”
    in our production environment? The answer is to use pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Azure DevOps environment, go to the project. You’ll see a **Pipelines**
    tab in the left sidebar. Click that. You’ll greeted with a page saying you haven’t
    got any pipelines yet. Let’s change that. Click the **Create Pipeline** button.
    You’ll be taken to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Creating an Azure DevOps pipeline](img/B20924_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Creating an Azure DevOps pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, select **Azure Repos Git**. When you click that, you’ll get a
    dialog asking for your project. Select the repository containing the code you
    want to deploy automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done that, you’re done. Yes – it was that easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the pipeline manually to see if everything works. Building
    your solution will take a couple of minutes, but when it’s done, you’ll see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: Successful pipeline run](img/B20924_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Successful pipeline run'
  prefs: []
  type: TYPE_NORMAL
- en: To test if your code has been published, rerun the test from Visual Studio Code
    (or whatever tool you use to test REST calls).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time for the cool stuff.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, make a change to the code. You could do something simple,
    such as change the text the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: Save your changes and push them to your repository. Once you’ve done that, go
    to Azure DevOps and find the pipeline – you’ll see that it’s already running!
    Just wait a few minutes until it is done and rerun your tests. You should see
    that your results have been propagated to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: That’s what I call easy deployment!
  prefs: []
  type: TYPE_NORMAL
- en: In case you were wondering, the pipeline gets all the necessary information
    from your Publish profile. Remember when I said it was easier to do this if you
    publish manually first? Now you know why! You should look at the generated YAML
    files to see how things work. If you’re ready to take your deployment skills to
    the next level, I suggest that you search for this online. Dozens of books have
    been written on this topic, so I’m sure you can find what you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CI from GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure DevOps is a great way to collaborate with people in the same organization.
    However, if you want to work with people across organizations, GitHub might be
    a better choice. GitHub is more geared toward open collaboration, such as open
    source projects. But that doesn’t mean you can’t have the same continuous integration
    as you have with Azure DevOps: you can achieve the same thing with GitHub Actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having our source code in Azure DevOps, we host it in GitHub. Originally,
    GitHub was nothing more than a bunch of repositories, but they have expanded a
    lot since then. One of the more astonishing things they have added is GitHub actions.
  prefs: []
  type: TYPE_NORMAL
- en: Actions are the equivalent of the pipelines we just looked at. The syntax is
    different, and they support many more environments than the default pipelines
    in Azure, but the idea remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub offers wizards to help you write your Actions, but there is a straightforward
    way to get our first Action up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Azure Function project in Visual Studio, but this time store it
    in your GitHub account. Once you’ve done that, test it locally and publish it
    to Azure. I always do this to make sure it works.
  prefs: []
  type: TYPE_NORMAL
- en: Once the publishing is done, create a test for your code using Visual Studio
    Code or your preferred test tool.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s set up CI/CD from GitHub!
  prefs: []
  type: TYPE_NORMAL
- en: In the Azure portal, navigate to your function. Then, in the left sidebar, select
    **Deployment Center**. Then, under **Source**, select **GitHub**. After doing
    that, you can enter your details. You must log in to GitHub and select the correct
    organization, repository, and source branch you want to publish.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to specify how you wish to authenticate. The GitHub action
    needs to log in to Azure to deploy your code, so the wizard will create an account
    for you. Use a user-assigned identity to make this happen. The identity will be
    created automatically. Once this has happened, click **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: And that is it – you’ve just set up your first GitHub Action! If you don’t believe
    me, go to your GitHub account, select your project, and go to **Actions**. You
    should see the action there, and it should show that it has already run as well!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: First Action](img/B20924_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: First Action'
  prefs: []
  type: TYPE_NORMAL
- en: To check that it works as intended, you can change your code, commit the changes
    to the repository, and see the Action come to life. You can click on the run to
    see the details. When you’re done, it will have updated the code in your Azure
    environment. Test it and see the changes!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, a lot of our code doesn’t run on Azure. As system programmers, we
    often have to deploy to local hardware. In that case, these techniques won’t work.
    We have to figure out a better way. And there is: using installers!'
  prefs: []
  type: TYPE_NORMAL
- en: Building installers with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installers are nothing new – they were the only way to get an application on
    your system for a long time. Installers were primarily used to install Windows-based
    applications on the users’ machines. They aren’t used that often anymore since
    this has become obsolete for most use cases. But installers are a great and simple
    way to get the job done if you wish to install a background worker process and
    need to do some custom work.
  prefs: []
  type: TYPE_NORMAL
- en: Installers and Wix
  prefs: []
  type: TYPE_NORMAL
- en: The standard Microsoft Installer project works just fine. Still, many developers
    have moved away in favor of using Wix. Wix is a third-party solution for building
    installers. It is incredibly versatile, and thus, it is pretty hard to start using.
    Many books, articles, and how-tos are available to help you get up and running.
    But in our case, we don’t need that complexity. The standard installer is enough
    for most system programmers. But if you want more control, I urge you to dive
    into Wix and see what it can do for you.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you installed the **Microsoft Visual Studio Installer Projects 2022**
    extension in Visual Studio. In that case, you can add an installer project to
    your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that!
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple installer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the **New Project** dialog, select the **Setup Wizard** template. This will
    start a typical “next, next, finish” type wizard. There are five steps to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: Setup Wizard (1 of 5)](img/B20924_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Setup Wizard (1 of 5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the screens are self-explanatory. The first real question asks
    you whether you want to build a setup program for a Windows application, a setup
    program for a web application, or whether you want to create a redistributable
    package. We want the first option: a setup for a Windows application since that
    is what a background worker system still is.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the wizard will want to know what you want to install. From the dropdown,
    select the **Publish Items from…** option. Those are all the executables and dependencies,
    so we want those.
  prefs: []
  type: TYPE_NORMAL
- en: After, you’ll be asked if there are any other files you want to include. There
    aren’t, so just click **Next**. The last step is a summary of the previous steps.
    Review this page and click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can test it, we need to set some properties. Select your project
    in the **Solution Explorer** area and look at the **Properties** window. Here,
    you can fill in all the details you think matter to you. Mine looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: Setting up project properties](img/B20924_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Setting up project properties'
  prefs: []
  type: TYPE_NORMAL
- en: You should at least change the `C:\Program Files (x86)` folder. If that’s not
    what you want, change the `TargetPlatform` property from `C:\Program Files` the
    default folder. Of course, you should only do that when your application is indeed
    64-bit (the **x64** option) instead of the older 32-bit (**x86**) format.
  prefs: []
  type: TYPE_NORMAL
- en: Why is 64-bit X64, but 32-bit X86?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, people get confused by these names. People seem to get that X64
    means 64-bit, but why on earth is 32-bit called X86? The answer is rather simple:
    X64 indeed is just 64-bit, but the X86 refers to the original Intel 8086 processor
    from long ago, when machines ran 16-bit or at most 32-bit software. It’s just
    a weird thing that you now know and can brag about to your friends!'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to test it all out!
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your **Setup** project, select **Build**, and see if everything
    builds. If it does, you can right-click on the project again, but select **Install**
    this time. If all goes well, your system will be installed! You can navigate to
    the folder you chose during installation and see your files there.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up, you only have to click **uninstall** in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Custom Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is nice, but it’s not enough. Especially for us system programmers, several
    other things need to be done during or after installation. For instance, a worker
    process must be registered as a Windows service to start automatically. Or let’s
    say we have a secret that must be encrypted before we can store it in a settings
    file. How would we do that? The answer is we write a Custom Action.
  prefs: []
  type: TYPE_NORMAL
- en: '*A Custom Action is some code in an external assembly that gets deployed with
    the Installer and called at the* *right time.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not hard to write them: it’s all done in C#. And we know that language!'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s discuss what we want to do.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed secrets. We discovered we can use the
    .NET system to generate keys to encrypt and decrypt data. That key would only
    work on that machine since it is tied to the installed version of Windows for
    that particular user. That means we must encrypt any secret in the `appsettings`
    file on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: So, suppose we deploy an unencrypted secret in a settings file. In that case,
    we must make sure that we encrypt the target machine during installation.
  prefs: []
  type: TYPE_NORMAL
- en: In my sample, I am just replacing a placeholder with a new `GUID` to show how
    it’s done. But the principle stands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new Class Library to the solution. However, there is one caveat: select
    the **.NET Framework** version of the Class Library. The MSI installer uses the
    “old” .NET framework, so any add-ons must be built with that technology.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a reference to **System.Configuration.Install** to the class library project,
    as I did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: Adding the System.Configuration.Install reference](img/B20924_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Adding the System.Configuration.Install reference'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new item to the class library that’s of the `Installer` type. You can
    do that by right-clicking on the project and selecting `Installer`. Call it `SecretsInstaller`.
    This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: Adding an installer class](img/B20924_14_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Adding an installer class'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the code so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code gets called by `Installer`. Here, I found the `appsettings.json` file,
    loaded it in memory, found the `SECRET_PLACEHOLDER` string, and replaced it with
    a `Guid` value. Finally, I wrote it back to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is the line where I get the path to the file. I return
    to that one later, so keep that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to register this class with `Installer`. Add a new `Installer` class
    to our class library, `ProjectInstaller`, and change the constructor. This code
    is even simpler than the last one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we create an instance of the `SecretsInstaller` class and
    add it to our `Installer`. This is a list of classes the install system looks
    at and then calls `Install` on.
  prefs: []
  type: TYPE_NORMAL
- en: That is all the code we need to write. Let’s use it!
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the custom action in the setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go back to **Setup program**. Right-click on the project, select **Add…**, then
    **Project output**. Select the primary output of the **Custom Action** project.
    This ensures our DLL is part of the files that are being installed on the target
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Setup program** again but select **View**, then **Custom Actions…**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a screen with four categories. This determines when the custom
    action should be called. These options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install**: This is when all files are installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit**: This is when the setup has finalized everything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rollback**: When the setup fails, this is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uninstall**: When the user decides to install, these actions are performed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we need to use **Install**. Right-click on that and select **Add
    Custom Action**. Once again, you’ll be presented with a dialog showing the target
    machine’s file structure. These are all the locations where our files can end
    up. Since we added our project output of the custom action to the regular installation,
    we can find it in the **Application Folder** area. Select the primary output from
    your Custom Action and click **OK**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14: Adding the Custom Action assembly](img/B20924_14_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Adding the Custom Action assembly'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t leave the Custom Action view yet. Click on the new item in the **Install**
    section, and look at the **Properties** area. Here, you can add all sorts of items,
    but the most important is **CustomActionData**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is data from outside that gets passed as parameters to our custom action.
    Remember when I said I would get back to how I would get the path to the target
    directory? This is where I do that. Add the following line to that property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes. A “backslash, space, closing quote” is at the end of that line. Don’t
    leave those out. Trust me: I spent hours determining why my actions didn’t work.
    The reason: I forgot that extra slash and space. It just doesn’t work without
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: You can now build and then run **Install**.
  prefs: []
  type: TYPE_NORMAL
- en: Look up the folder where the installation took place and marvel at the changes
    in the JSON file!
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most used excuse developers use when someone complains the system doesn’t
    work as expected is “But it works on my machine!” Of course, the only suitable
    response is, “We do not ship your machine; we ship software.”
  prefs: []
  type: TYPE_NORMAL
- en: Docker aims to be a solution to that problem.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a highly complex topic. If you’re unaware of what it can do, please
    skip this part of this chapter until you’re more familiar with it. In short, Docker
    can act like a complete virtual machine. This principle means you can develop
    on that virtual machine, test on that virtual machine, and then deploy that virtual
    machine. In other words, if it works on that machine, it will work everywhere.
    The reason it will work everywhere is that with Docker, we ship your machine.
    Well, the virtual one, at least.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio has completely embraced Docker. The IDE comes packed with handy
    add-ons and wizards to help you use Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker support to your background worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you create a new project, such as a background worker, you can choose to
    add Docker support. But if you already have a project, you must add support later.
    It’s not hard to do: just right-click on the project, select **Add**, and then
    click **Docker support**. You can choose between **Windows** and **Linux**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15: Adding Docker to an existing project](img/B20924_14_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Adding Docker to an existing project'
  prefs: []
  type: TYPE_NORMAL
- en: Docker – using Windows or Linux?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve been working with Visual Studio for some time, you will likely choose
    Windows over Linux. After all, you probably know that platform very well. Why
    should you move to Linux? However, containerization comes from the Linux world:
    it is baked into the core of the operating system. Linux is a far better platform
    for containers than Windows. If you don’t need Windows features, I suggest that
    you take Linux as the base container. Your apps will benefit from that if you
    decide to use Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you do this, a lot of things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: A new file called `Dockerfile` is added to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `launchSettings.json` file is changed to add Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the background, all the necessary support images are installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default start action is set to **Container** (Dockerfile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you start debugging, Visual Studio will build the Docker image with your
    binaries and start a container. You can add breakpoints to your code, and Visual
    Studio will also ensure the debugger is deployed in the container. Hence, it knows
    how to tunnel the debug information back and forth. The whole process is streamlined:
    you hardly notice you’re running on a Docker image instead of your host machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve finished working on your code base and are ready to deploy it,
    you must figure out where to deploy it. There are three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Docker Hub. This is the standard repository where you can store your images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Azure/AWS/Google Cloud to store your images. These are much more secure
    since you control these environments. For instance, you can create a container
    registry in Azure and then upload your images. Everybody in your organization
    can then pull that image and run it locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use your own repository. Suppose you don’t want to depend on a cloud provider
    but want complete control over where your images are. In that case, you can build
    your own repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option is the most used one for our scenarios. Of course, you can
    use Docker Hub or Azure. Nothing is getting in your way. It’s just that for the
    things we build, the third option is probably the best.
  prefs: []
  type: TYPE_NORMAL
- en: Building an actual repository is hard. But the good news is that someone else
    has already done it. And they have put it in a Docker image. So, all we have to
    do is download that image and start it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we do that, we need to think about security. There are many ways
    to secure the repository, but the easiest (and least secure) way is to assign
    a username/password. You need some code to generate those, but don’t worry: there’s
    a Docker image for that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a folder named `C:\Auth`. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads the `http:2` image and runs it, gives it a username of
    `yourusername` and a password of `yourpassword` (I suggest that you use other
    values for those parameters), and stores the result in the `htpasswd` file in
    the `c:\auth` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start the repository. Run the following command, all on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command pulls the `registry:2` image from Docker Hub and starts it. It
    connects the internal folder, `/auth`, to our `c:\auth` directory and gives it
    some parameters.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the repo, you must log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can tag and push your images there. In my case, my C# worker process
    image from Visual Studio is called `image13workerfordocker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can tag it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is all one line. Now, I can push it to my local repository, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If I want to reuse my image, I can pull it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I can use this repository just like I can with the ones at Docker Hub, Azure,
    AWS, or Google.
  prefs: []
  type: TYPE_NORMAL
- en: Production-ready Docker repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What I’ve shown you here is just to show you the uttermost beginnings. The repository
    isn’t secure or stable and doesn’t even survive a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several things you need to do if you want to use this in a real production
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Harden the security by using TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install a volume so that you can store the images instead of using a container
    (hint: map a volume to `/var/lib/registry`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use actual authentication instead of the single username/password I have just
    shown you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the repository in a fail-safe environment such as Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But even with this setup, you can have your own repository. This will ensure
    that if the code works on your machine, it works everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed many ways you can get your software from your
    machine to other machines. Some were easy, others were hard. To be honest, this
    chapter was more about helping you start thinking about deployment. Each topic
    could fill hundreds of pages. For instance, I mentioned Wix. Well, dozens of books
    have been written on Wix alone. We discussed CI/CD in Azure in a couple of pages.
    It turns out people make a complete career out of that topic. We also looked at
    Docker: people spend weeks, if not months, getting up to speed on that topic.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways you can get your code out there, and this chapter only scratched
    the surface.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to show you the most common ones that fit scenarios we will most likely
    run into. It is up to you to determine which is the best for your use case and
    then dive deeper into it.
  prefs: []
  type: TYPE_NORMAL
- en: But before I let you go, I need to say something about the dialog regarding
    Docker. The dialog asked if you wanted to use Linux or Windows. I suggest that
    you choose Linux as often as you can. If you think, “But I know very little about
    Linux,” don’t worry. The next chapter will tell you all you need to know about
    that operating system. So, let’s have a look, shall we?
  prefs: []
  type: TYPE_NORMAL
