<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;There's More"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. There's More</h1></div></div></div><p>In this chapter, we will look through a new programming paradigm in the Windows 10 operating system. Also, you will learn how to run .NET programs on OS X and Linux. You will learn the following recipes in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using a timer in a Universal Windows Platform application</li><li class="listitem" style="list-style-type: disc">Using WinRT from usual applications</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">BackgroundTask</code> in Universal Windows Platform applications</li><li class="listitem" style="list-style-type: disc">Running a .NET Core application on OS X</li><li class="listitem" style="list-style-type: disc">Running a .NET Core application on Ubuntu Linux</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec88"/>Introduction</h1></div></div></div><p>Microsoft released the first public beta build of Windows 8 at the Build conference on September 13, 2011. The new OS tried to address almost every problem that Windows had by introducing features such as a responsive UI suitable for tablet devices with touch, lower power consumption, a new application model, new asynchronous APIs, and tighter security.</p><p>The core of Windows API improvements was a new multiplatform component system, <span class="strong"><strong>WinRT</strong></span>, which is a logic<a id="id420" class="indexterm"/>al development of COM. With WinRT, a programmer can use native C++ code, C# and .NET, and even JavaScript and HTML to develop applications. Another change is the introduction of a centralized application store, which did not exist on the Windows platform before.</p><p>Being a new application platform, Windows 8 had backward compatibility and allowed us to run the usual Windows applications. This lead to a situation where there were two major classes of applications: the Windows Store applications, where new programs are distributed via the Windows Store, and the usual classic applications that had not changed since the previous version of Windows.</p><p>However, Windows 8 was only the first step toward the new application model. Microsoft got a lot of feedback from the users, and it became clear that Windows Store applications were too different from what people were used to. Besides that, there was a separate smartphone OS, Windows 8 Phone, that had a different application store and a slightly different set of APIs. This made an application developer create two separate applications for desktop and smartphone platforms.</p><p>To improve the situation, the new Windows 10 OS was introduced as a unified platform for all Windows-powered devices. There is a single application store that supports every device family, and now, it is possible to create an application that works on phones, tablets, and desktops. Thus, Windows Store applications are now called Universal Windows Platform applications (UWP apps). This, of course, means a lot of limitations for your application—it should not use any platform-specific APIs, and as a programmer, you have to comply with specific rules. The program has to respond in a limited time to start up or to finish, keeping the whole operating system and other applications responsive. To save the battery, your applications are no longer running in the background by default; instead of that, they get suspended and actually stop executing.</p><p>New Windows APIs are asynchronous, and you can only use whitelisted API functions in your application. For example, you are not allowed to create a new <code class="literal">Thread</code> class instance anymore. You have to use a system-managed thread pool instead. A lot of usual APIs cannot be used anymore, and you have to study new ways to achieve the same goals as before.</p><p>But this is not all. Microsoft began to understand that supporting operating systems other than Windows is also important. And now, you can write cross-platform applications using a new subset of .NET that is called .NET Core. Its source can be found on GitHub, and it is supported on platforms such as OS X and Linux. You can use any text editor, but I would suggest you take a look at Visual Studio Code—a new lightweight, cross-platform code editor, which runs on OS X and Linux and understands the C# syntax well.</p><p>In this chapter, we will see how a Universal Windows Platform application is different from the usual Windows application and how we can use some of the WinRT benefits from the usual applications. We will also go through a simplified scenario of a Universal Windows Platform application with background notifications. You will also learn to run a .NET program on OS X and Linux.</p></div></div>
<div class="section" title="Using a timer in a Universal Windows Platform application"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Using a timer in a Universal Windows Platform application</h1></div></div></div><p>This recipe<a id="id421" class="indexterm"/> shows you how to <a id="id422" class="indexterm"/>use a simple timer in Universal Windows Platform applications.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec221"/>Getting ready</h2></div></div></div><p>To go through this recipe, you will need Visual Studio 2015 and the Windows 10 operating system. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe1</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec222"/>How to do it...</h2></div></div></div><p>To<a id="id423" class="indexterm"/> understand how to use a timer in a Windows Store application, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual <a id="id424" class="indexterm"/>Studio 2015. Create a new C# <span class="strong"><strong>Blank App (Universal Windows)</strong></span> project in the <code class="literal">Windows\Universal</code> folder.<div class="mediaobject"><img src="graphics/B05292_11_01.jpg" alt="How to do it..."/></div></li><li class="listitem">If you are asked to enable developer mode for Windows 10, you have to enable it in the control panel.<div class="mediaobject"><img src="graphics/B05292_11_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Then, confirm<a id="id425" class="indexterm"/> that you <a id="id426" class="indexterm"/>are sure you want to turn on developer mode.<div class="mediaobject"><img src="graphics/B05292_11_03.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">MainPage.xaml</code> file, add the <code class="literal">Name</code> attribute to the <code class="literal">Grid</code> element:<div class="informalexample"><pre class="programlisting">&lt;Grid Name="Grid" Background="{StaticResource  ApplicationPageBackgroundThemeBrush}"&gt;</pre></div></li><li class="listitem">In the <code class="literal">MainPage.xaml.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;</pre></div></li><li class="listitem">Add the<a id="id427" class="indexterm"/> following code snippet above the <code class="literal">MainPage</code> constructor definition:<div class="informalexample"><pre class="programlisting">private readonly DispatcherTimer _timer;
private int _ticks;</pre></div></li><li class="listitem">Replace<a id="id428" class="indexterm"/> the <code class="literal">MainPage()</code> constructor with the following code snippet:<div class="informalexample"><pre class="programlisting">public MainPage()
{
  InitializeComponent();
  _timer = new DispatcherTimer();
  _ticks = 0;
}</pre></div></li><li class="listitem">Add the <code class="literal">OnNavigatedTo()</code> method under the <code class="literal">MainPage</code> constructor definition:<div class="informalexample"><pre class="programlisting">protected override void OnNavigatedTo(NavigationEventArgs e)
{
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">OnNavigatedTo</code> method:<div class="informalexample"><pre class="programlisting">base.OnNavigatedTo(e);Grid.Children.Clear();
var commonPanel = new StackPanel
{
  Orientation = Orientation.Vertical,
  HorizontalAlignment = HorizontalAlignment.Center
};

var buttonPanel = new StackPanel
{
  Orientation = Orientation.Horizontal,
  HorizontalAlignment = HorizontalAlignment.Center
};

var textBlock = new TextBlock
{
  Text = "Sample timer application",
  FontSize = 32,
  HorizontalAlignment = HorizontalAlignment.Center,
  Margin = new Thickness(40)
};

var timerTextBlock = new TextBlock
{
  Text = "0",
  FontSize = 32,
  HorizontalAlignment = HorizontalAlignment.Center,
  Margin = new Thickness(40)
};

var timerStateTextBlock = new TextBlock
{
  Text = "Timer is enabled",
  FontSize = 32,
  HorizontalAlignment = HorizontalAlignment.Center,
  Margin = new Thickness(40)
};

var startButton = new Button { Content = "Start",FontSize = 32};
var stopButton = new Button { Content = "Stop",FontSize = 32};

buttonPanel.Children.Add(startButton);
buttonPanel.Children.Add(stopButton);

commonPanel.Children.Add(textBlock);
commonPanel.Children.Add(timerTextBlock);
commonPanel.Children.Add(timerStateTextBlock);
commonPanel.Children.Add(buttonPanel);

_timer.Interval = TimeSpan.FromSeconds(1);
_timer.Tick += (sender, eventArgs) =&gt;
{
  timerTextBlock.Text = _ticks.ToString(); _ticks++;
};
_timer.Start();

startButton.Click += (sender, eventArgs) =&gt;
{
  timerTextBlock.Text = "0";
  _timer.Start();
  _ticks = 1;
  timerStateTextBlock.Text = "Timer is enabled";
};

stopButton.Click += (sender, eventArgs) =&gt;
{
  _timer.Stop();
  timerStateTextBlock.Text = "Timer is disabled";
};

Grid.Children.Add(commonPanel);</pre></div></li><li class="listitem">Right-click on the project in Visual Studio <span class="strong"><strong>Solution Explorer</strong></span> and choose <span class="strong"><strong>Deploy</strong></span>.</li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec223"/>How it works...</h2></div></div></div><p>When the program runs, it <a id="id429" class="indexterm"/>creates an instance of a <code class="literal">MainPage</code> class. Here, we instantiate <code class="literal">DispatcherTimer</code> in the constructor and initialize the <code class="literal">ticks</code> counter to <code class="literal">0</code>. Then, in the <code class="literal">OnNavigatedTo</code> event handler, we create our UI controls and bind the start and stop buttons to the corresponding lambda expressions, which contain the <code class="literal">start</code> and <code class="literal">stop</code> logics.</p><p>As you can <a id="id430" class="indexterm"/>see, the <code class="literal">timer</code> event handler works directly with the UI controls. This is okay because <code class="literal">DispatcherTimer</code> is implemented in such a way that the handlers of the <code class="literal">Tick</code> event of <code class="literal">timer</code> are run by the UI thread. However, if you run the program and then switch to something else and then switch to the program after a couple of minutes, you may notice that the seconds counter is far behind the real amount of time that passed. This happens because Universal Windows Platform applications have completely different life cycles.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Be aware that Universal Windows Platform applications behave much like the applications on smartphone and tablet platforms. Instead of running in the background, they become suspended after some time, and this means that they are actually frozen until the user switches back to them. You have a limited time to save the current application state before it becomes suspended, and you are able to restore the state when the applications run again.</p></div></div><p>While this behavior could save power and CPU resources, it creates significant difficulties for program applications that are supposed to do some processing in the background. Windows 10 has a set of special APIs to program such applications. We will go through such a scenario later in this chapter.</p></div></div>
<div class="section" title="Using WinRT from usual applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Using WinRT from usual applications</h1></div></div></div><p>This recipe<a id="id431" class="indexterm"/> shows you how to create a console application that will be able to use the WinRT API.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec224"/>Getting ready</h2></div></div></div><p>To go through this recipe, you will need Visual Studio 2015 and the Windows 10 operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe2</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec225"/>How to do it...</h2></div></div></div><p>To understand how to use WinRT from usual applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Right-click on the created project in Visual Studio <span class="strong"><strong>Solution Explorer</strong></span> and select the <span class="strong"><strong>Unload Project…</strong></span> menu option.</li><li class="listitem">Right-click on the unloaded project and select the <span class="strong"><strong>Edit ProjectName.csproj</strong></span> menu option.</li><li class="listitem">Add the following XML code below the <code class="literal">&lt;TargetFrameworkVersion&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;TargetPlatformVersion&gt;10.0&lt;/TargetPlatformVersion&gt;</pre></div></li><li class="listitem">Save the <code class="literal">.csproj</code> file, right-click on the unloaded project in Visual Studio <span class="strong"><strong>Solution Explorer</strong></span>, and select the <span class="strong"><strong>Reload Project</strong></span> menu option.</li><li class="listitem">Right-click on the project and select <span class="strong"><strong>Add Reference</strong></span> from the <span class="strong"><strong>Core</strong></span> library under <span class="strong"><strong>Windows</strong></span>. Then, click on the <span class="strong"><strong>Browse</strong></span> button.</li><li class="listitem">Navigate to <code class="literal">C:\Program Files (x86)\Windows Kits\10\UnionMetadata</code> and click on <code class="literal">Windows.winmd</code>.</li><li class="listitem">Navigate to <code class="literal">C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5</code> and click on the <code class="literal">System.Runtime.WindowsRuntime.dll</code> file.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Threading.Tasks;
using Windows.Storage;</pre></div></li><li class="listitem">Add the<a id="id432" class="indexterm"/> following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">async static Task AsynchronousProcessing()
{
  StorageFolder folder = KnownFolders.DocumentsLibrary;

  if (await folder.DoesFileExistAsync("test.txt"))
  {
    var fileToDelete = await folder.GetFileAsync("test.txt");
    await fileToDelete.DeleteAsync(StorageDeleteOption.PermanentDelete);
  }

  var file = await folder.CreateFileAsync("test.txt",CreationCollisionOption.ReplaceExisting);
  using (var stream = await file.OpenAsync(FileAccessMode.ReadWrite))
  using (var writer = new StreamWriter(stream.AsStreamForWrite()))
  {
    await writer.WriteLineAsync("Test content");
    await writer.FlushAsync();
  }

  using (var stream = await file.OpenAsync(FileAccessMode.Read))
  using (var reader = new StreamReader(stream.AsStreamForRead()))
  {
    string content = await reader.ReadToEndAsync();
    Console.WriteLine(content);
  }

  Console.WriteLine("Enumerating Folder Structure:");

  var itemsList = await folder.GetItemsAsync();
  foreach (var item in itemsList)
  {
    if (item is StorageFolder)
    {
      Console.WriteLine("{0} folder", item.Name);
    }
    else
    {
      Console.WriteLine(item.Name);
    }
  }
}</pre></div></li><li class="listitem">Add the following code snippet to the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var t = AsynchronousProcessing();
t.GetAwaiter().GetResult();
Console.WriteLine();
Console.WriteLine("Press ENTER to continue");
Console.ReadLine();</pre></div></li><li class="listitem">Add the<a id="id433" class="indexterm"/> following code snippet below the <code class="literal">Program</code> class definition:<div class="informalexample"><pre class="programlisting">static class Extensions
{
  public static async Task&lt;bool&gt; DoesFileExistAsync(thisStorageFolder folder, string fileName)
  {
    try
    {
      await folder.GetFileAsync(fileName);
      return true;
    }
    catch (FileNotFoundException)
    {
      return false;
    }
  }
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec226"/>How it works...</h2></div></div></div><p>Here, we used quite a tricky way to consume the WinRT API from a common .NET console application. Unfortunately, not all available APIs will work in this scenario, but still, it could be useful to work with movement sensors, GPS location services, and so on.</p><p>To reference WinRT in Visual Studio, we manually edit the <code class="literal">.csproj</code> file, specifying the target platform for the application as Windows 10. Then, we manually reference <code class="literal">Windows.winmd</code> to get access to Windows 10 APIs and <code class="literal">System.Runtime.WindowsRuntime.dll</code> to leverage the <code class="literal">GetAwaiter</code> extension method implementation for WinRT asynchronous operations. This allows us to use <code class="literal">await</code> on WinRT APIs directly. There is a backward conversion as well. When we create a WinRT library, we have to expose the WinRT native <code class="literal">IAsyncOperation</code> interfaces family for asynchronous operations, so they could be consumed from JavaScript and C++ in a language-agnostic manner.</p><p>File operations<a id="id434" class="indexterm"/> in WinRT are quite self-descriptive; here, we have asynchronous file create and delete operations. Still, file operations in WinRT contain security restrictions, encouraging you to use special Windows folders for your application and not allowing you to work with just any file path on your disk drive.</p></div></div>
<div class="section" title="Using BackgroundTask in Universal Windows Platform applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec91"/>Using BackgroundTask in Universal Windows Platform applications</h1></div></div></div><p>This recipe walks<a id="id435" class="indexterm"/> you through the<a id="id436" class="indexterm"/> process of creating a background task in a Universal Windows Platform application, which updates the application's live tile on a desktop.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec227"/>Getting ready</h2></div></div></div><p>To go through this recipe, you will need Visual Studio 2015 and the Windows 10 operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe3</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec228"/>How to do it...</h2></div></div></div><p>To understand how to use <code class="literal">BackgroundTask</code> in Universal Windows Platform applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# <span class="strong"><strong>Blank App (Universal Windows)</strong></span> project under <code class="literal">Windows\Universal</code> folder. If you need to enable the Windows 10 developer mode, refer to the <span class="emphasis"><em>Using a timer in a Windows Store application</em></span> recipe for detailed instructions.</li><li class="listitem">Open the <code class="literal">Package.appxmanifest</code> file. In the <span class="strong"><strong>Declarations</strong></span> tab, add <span class="strong"><strong>Background Tasks</strong></span> to <span class="strong"><strong>Supported Declarations</strong></span>. Under <span class="strong"><strong>Properties</strong></span>, check the supported properties <span class="strong"><strong>System event</strong></span> and <span class="strong"><strong>Timer</strong></span> and set the name of <span class="strong"><strong>Entry point</strong></span> to <code class="literal">YourNamespace.TileSchedulerTask</code>. <code class="literal">YourNamespace</code> should be the namespace of your application.<div class="mediaobject"><img src="graphics/B05292_11_04.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">MainPage.xaml</code> file, insert the following XAML code into the <code class="literal">Grid</code> element:<div class="informalexample"><pre class="programlisting">&lt;StackPanel Margin="50"&gt;
  &lt;TextBlock Name="Clock"
             Text="HH:mm"
             HorizontalAlignment="Center"
             VerticalAlignment="Center"
             Style="{StaticResource HeaderTextBlockStyle}"/&gt;
&lt;/StackPanel&gt;</pre></div></li><li class="listitem">In the<a id="id437" class="indexterm"/> <code class="literal">MainPage.xaml.cs</code> file, add<a id="id438" class="indexterm"/> the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Xml.Linq;
using Windows.ApplicationModel.Background;
using Windows.Data.Xml.Dom;
using Windows.System.UserProfile;
using Windows.UI.Notifications;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;</pre></div></li><li class="listitem">Add the following code snippet above the <code class="literal">MainPage</code> constructor definition:<div class="informalexample"><pre class="programlisting">private const string TASK_NAME_USERPRESENT ="TileSchedulerTask_UserPresent";
private const string TASK_NAME_TIMER ="TileSchedulerTask_Timer";

private readonly CultureInfo _cultureInfo;
private readonly DispatcherTimer _timer;</pre></div></li><li class="listitem">Replace the <a id="id439" class="indexterm"/><code class="literal">MainPage</code> constructor with the following code snippet:<div class="informalexample"><pre class="programlisting">public MainPage()
{
InitializeComponent();

string language = GlobalizationPreferences.Languages.First();
_cultureInfo = new CultureInfo(language);

_timer = new DispatcherTimer();
_timer.Interval = TimeSpan.FromSeconds(1);
_timer.Tick += (sender, e) =&gt; UpdateClockText();
}</pre></div></li><li class="listitem">Add the<a id="id440" class="indexterm"/> following code snippet above the <code class="literal">OnNavigatedTo</code> method:<div class="informalexample"><pre class="programlisting">private void UpdateClockText()
{
  Clock.Text = DateTime.Now.ToString(_cultureInfo.DateTimeFormat.FullDateTimePattern);
}

private static async void CreateClockTask()
{
  BackgroundAccessStatus result = awaitBackgroundExecutionManager.RequestAccessAsync();
  if (result == BackgroundAccessStatus.AllowedMayUseActiveRealTimeConnectivity ||result == BackgroundAccessStatus.AllowedWithAlwaysOnRealTimeConnectivity)
  {
    TileSchedulerTask.CreateSchedule();

    EnsureUserPresentTask();
    EnsureTimerTask();
  }
}

private static void EnsureUserPresentTask()
{
  foreach (var task in BackgroundTaskRegistration.AllTasks)
    if (task.Value.Name == TASK_NAME_USERPRESENT)
      return;

  var builder = new BackgroundTaskBuilder();
  builder.Name = TASK_NAME_USERPRESENT;
  builder.TaskEntryPoint =(typeof(TileSchedulerTask)).FullName;
  builder.SetTrigger(new SystemTrigger(SystemTriggerType.UserPresent, false));
  builder.Register();
}

private static void EnsureTimerTask()
{
  foreach (var task in BackgroundTaskRegistration.AllTasks)
    if (task.Value.Name == TASK_NAME_TIMER)
      return;

  var builder = new BackgroundTaskBuilder();
  builder.Name = TASK_NAME_TIMER;
  builder.TaskEntryPoint = (typeof(TileSchedulerTask)).FullName;
  builder.SetTrigger(new TimeTrigger(180, false));
  builder.Register();
}</pre></div></li><li class="listitem">Add the<a id="id441" class="indexterm"/> following code <a id="id442" class="indexterm"/>snippet to the <code class="literal">OnNavigatedTo</code> method:<div class="informalexample"><pre class="programlisting">_timer.Start();
UpdateClockText();
CreateClockTask();</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">MainPage</code> class definition:<div class="informalexample"><pre class="programlisting">public sealed class TileSchedulerTask : IBackgroundTask
{
  public void Run(IBackgroundTaskInstance taskInstance)
  {
    var deferral = taskInstance.GetDeferral();
    CreateSchedule();
    deferral.Complete();
  }

  public static void CreateSchedule()
  {
    var tileUpdater = TileUpdateManager.CreateTileUpdaterForApplication();
    var plannedUpdated = tileUpdater.GetScheduledTileNotifications();

    DateTime now = DateTime.Now;
    DateTime planTill = now.AddHours(4);

    DateTime updateTime = new DateTime(now.Year, now.Month,now.Day, now.Hour, now.Minute, 0).AddMinutes(1);
    if (plannedUpdated.Count &gt; 0)
      updateTime = plannedUpdated.Select(x =&gt;x.DeliveryTime.DateTime).Union(new[] { updateTime}).Max();
    XmlDocument documentNow = GetTilenotificationXml(now);

    tileUpdater.Update(new TileNotification(documentNow) {ExpirationTime = now.AddMinutes(1) });

    for (var startPlanning = updateTime;startPlanning &lt; planTill; startPlanning =startPlanning.AddMinutes(1))
    {
      Debug.WriteLine(startPlanning);
      Debug.WriteLine(planTill);

      try
      {
        XmlDocument document = GetTilenotificationXml(startPlanning);

        var scheduledNotification = newScheduledTileNotification(document,new DateTimeOffset(startPlanning))
        {
          ExpirationTime = startPlanning.AddMinutes(1)
        };

        tileUpdater.AddToSchedule(scheduledNotification);
      }
      catch (Exception ex)
      {
        Debug.WriteLine("Error: " + ex.Message);
      }
    }
  }

  private static XmlDocument GetTilenotificationXml(DateTime dateTime)
  {
    string language =GlobalizationPreferences.Languages.First();
    var cultureInfo = new CultureInfo(language);

    string shortDate = dateTime.ToString(cultureInfo.DateTimeFormat.ShortTimePattern);
    string longDate = dateTime.ToString(cultureInfo.DateTimeFormat.LongDatePattern);

    var document = XElement.Parse(string.Format(@"&lt;tile&gt;
    &lt;visual&gt;
      &lt;binding template=""TileSquareText02""&gt;
        &lt;text id=""1""&gt;{0}&lt;/text&gt;
        &lt;text id=""2""&gt;{1}&lt;/text&gt;
      &lt;/binding&gt;
      &lt;binding template=""TileWideText01""&gt;
        &lt;text id=""1""&gt;{0}&lt;/text&gt;
        &lt;text id=""2""&gt;{1}&lt;/text&gt;
        &lt;text id=""3""&gt;&lt;/text&gt;
        &lt;text id=""4""&gt;&lt;/text&gt;
      &lt;/binding&gt;  
    &lt;/visual&gt;
  &lt;/tile&gt;", shortDate, longDate));

    return document.ToXmlDocument();
  }
}

public static class DocumentExtensions
{
  public static XmlDocument ToXmlDocument(thisXElement xDocument)
  {
    var xmlDocument = new XmlDocument();
    xmlDocument.LoadXml(xDocument.ToString());
    return xmlDocument;
  }
}</pre></div></li><li class="listitem">Run<a id="id443" class="indexterm"/> the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec229"/>How it works...</h2></div></div></div><p>The preceding program shows how to create a background time-based task and how to show the updates from this task on a live tile on the Windows 10 start menu. Programming Universal Windows Platform applications is quite a challenging task itself—you have to care about an application suspending/restoring its state and many other things. Here, we are going to concentrate on our main task, leaving behind the secondary issues.</p><p>Our main goal is<a id="id444" class="indexterm"/> to run some code when the application itself is not in the foreground. First, we create an implementation of the <code class="literal">IBackgroundTask</code> interface. This is our code, and the <code class="literal">Run</code> method will be called when we get a trigger signal. It is important that if the <code class="literal">Run</code> method contains <a id="id445" class="indexterm"/>asynchronous code with <code class="literal">await</code> in it, we have to use a special deferral object as shown in the recipe to explicitly specify when we begin and end the <code class="literal">Run</code> method execution. In our case, the method call is synchronous, but to illustrate this requirement, we work with the deferral object.</p><p>Inside our task in the <code class="literal">Run</code> method, we create a set of tile updates each minute for 4 hours and register it in <code class="literal">TileUpdateManager</code> with the help of the <code class="literal">ScheduledTaskNotification</code> class. A tile uses a special XML format to specify exactly how the text should be positioned in it. When we trigger our task from the system, it schedules one-minute tile updates for the next 4 hours. Then, we need to register our background task. We do this twice; one registration provides a <code class="literal">UserPresent</code> trigger, which means that this task will be triggered when a user is logged in. The next trigger is a time trigger, which runs the task once every 3 hours.</p><p>When the program runs, it creates a timer, which runs when the application is in the foreground. At the same time, it tries to register background tasks; to register these tasks, the program needs user permission, and it will show a dialog requesting permissions from the user. Now, we have scheduled live tile updates for the next 4 hours. If we close our application, the live tile will continue to show the new time every minute. In the next 3 hours, the time trigger will run our background task once again, and we will schedule another live tile update.</p></div></div>
<div class="section" title="Running a .NET Core application on OS X"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec92"/>Running a .NET Core application on OS X</h1></div></div></div><p>This recipe<a id="id446" class="indexterm"/> shows how to install a .NET Core application <a id="id447" class="indexterm"/>on OS X and how to build and run a .NET console application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec230"/>Getting ready</h2></div></div></div><p>To go through this recipe, you will need a Mac OS X operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe4</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec231"/>How to do it...</h2></div></div></div><p>To understand how to run .NET Core applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install .NET <a id="id448" class="indexterm"/>Core on your OS X machine. You can visit <a class="ulink" href="http://dotnet.github.io/getting-started/">http://dotnet.github.io/getting-started/</a> and follow the installation instructions there. Since .NET Core is in the pre-release stage, the installation and usage scenarios could change before this book is published. Refer to the site instructions in that case.</li><li class="listitem">After you have downloaded the <code class="literal">.pkg</code> file, hold the <span class="emphasis"><em>Control</em></span> key while opening it. It will unblock the file and will allow you to install it.</li><li class="listitem">After you have installed the package, you will need to install OpenSSL. The easiest way is to install the homebrew package manager first. Open the terminal window and run the following command:<div class="informalexample"><pre class="programlisting">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</pre></div></li><li class="listitem">Then, you can install OpenSSL by typing the following in it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>brew install openssl</strong></span>
</pre></div></li><li class="listitem">There is also the small catch that .NET Core at the time of writing needs to increase the open files limit. This can be achieved by typing the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sysctl -w kern.maxfiles=20480</strong></span>
<span class="strong"><strong>sudo sysctl -w kern.maxfilesperproc=18000</strong></span>
<span class="strong"><strong>sudo ulimit -S -n 2048</strong></span>
</pre></div></li><li class="listitem">Now you have installed .NET Core and are ready to go. To create a sample Hello World application, you can create a directory and create an empty application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir HelloWorld</strong></span>
<span class="strong"><strong>cd HelloWorld</strong></span>
<span class="strong"><strong>dotnet new</strong></span>
</pre></div></li><li class="listitem">Let's check whether the default application works. To run the code, we have to restore dependencies and build and run the application. To achieve this, type the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dotnet restore</strong></span>
<span class="strong"><strong>dotnet run</strong></span>
</pre></div></li><li class="listitem">Now, let's try<a id="id449" class="indexterm"/> to run some asynchronous<a id="id450" class="indexterm"/> code. In the <code class="literal">Program.cs</code> file, change the code to the following:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
namespace OSXConsoleApplication
{
  class Program
  {
    static void Main(string[] args)
    {
      WriteLine(".NET Core app on OS X");
      RunCodeAsync().GetAwaiter().GetResult();
    }
    static async Task RunCodeAsync()
    {
      try
      {
        string result = await GetInfoAsync("Async 1");
        WriteLine(result);
        result = await GetInfoAsync("Async 2");
        WriteLine(result);
      }
      catch (Exception ex)
      {
        WriteLine(ex);
      }
    }
    static async Task&lt;string&gt; GetInfoAsync(string name)
    {
      WriteLine($"Task {name} started!");
      await Task.Delay(TimeSpan.FromSeconds(2));
      if(name == "Async 2")
        throw new Exception("Boom!");
      return
          $"Task {name} completed successfully!"
// + $"Thread id {System.Threading.Thread.CurrentThread.ManagedThreadId}."
                    ;
    }
  }
}</pre></div></li><li class="listitem">Run the program with the <code class="literal">dotnet run</code> command.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec232"/>How it works...</h2></div></div></div><p>Here, we download a <code class="literal">.pkg</code> file with the .NET Core installation package from the site and install it. We also<a id="id451" class="indexterm"/> install the OpenSSL library using the homebrew package manager (which also gets installed). Besides that, we increase the open files limit in OS X to be able to restore .NET Core dependencies.</p><p>Then, we create a<a id="id452" class="indexterm"/> separate folder for the .NET Core application, create a blank console application, and check whether everything works fine with restoring dependencies and running the code.</p><p>Finally, we create a simple asynchronous code and try to run it. It should run well, showing the messages that the first task completed successfully. The second task caused an exception, which was correctly handled. But if you try to uncomment a line that is intended to show the thread-specific information, the code will not be compiled, since .NET Core has no support for Thread APIs.</p></div></div>
<div class="section" title="Running a .NET Core application on Ubuntu Linux"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec93"/>Running a .NET Core application on Ubuntu Linux</h1></div></div></div><p>This recipe shows how<a id="id453" class="indexterm"/> to install a .NET Core <a id="id454" class="indexterm"/>application on Ubuntu and how to build and run a .NET console application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec233"/>Getting ready</h2></div></div></div><p>To go through this recipe, you will need an Ubuntu Linux 14.04 operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe5</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec234"/>How to do it...</h2></div></div></div><p>To understand how to run .NET Core applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install .NET Core on your Ubuntu machine. You can visit <a class="ulink" href="http://dotnet.github.io/getting-started/">http://dotnet.github.io/getting-started/</a> and follow the installation<a id="id455" class="indexterm"/> instructions there. Since .NET Core is in the pre-release stage, the installation and usage scenarios could change by the time this book is published. Refer to the site instructions in that case.</li><li class="listitem">First, open a terminal window and run the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sh -c 'echo "deb [arch=amd64] http://apt-mo.trafficmanager.net/repos/dotnet/ trusty main" &gt; /etc/apt/sources.list.d/dotnetdev.list'</strong></span>
<span class="strong"><strong>sudo apt-key adv --keyserver apt-mo.trafficmanager.net --recv-keys 417A0893</strong></span>
<span class="strong"><strong>sudo apt-get update</strong></span>
</pre></div></li><li class="listitem">Then, you <a id="id456" class="indexterm"/>can install .NET Core by typing the following in the terminal window:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install dotnet=1.0.0.001331-1</strong></span>
</pre></div></li><li class="listitem">Now, you<a id="id457" class="indexterm"/> have installed .NET Core and are ready to go. To create a sample Hello World application, you can create a directory and create an empty application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir HelloWorld</strong></span>
<span class="strong"><strong>cd HelloWorld</strong></span>
<span class="strong"><strong>dotnet new</strong></span>
</pre></div></li><li class="listitem">Let's check whether the default application works. To run the code, we have to restore dependencies and build and run the application. To achieve this, type the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dotnet restore</strong></span>
<span class="strong"><strong>dotnet run</strong></span>
</pre></div></li><li class="listitem">Now, let's try to run some asynchronous code. In the <code class="literal">Program.cs</code> file, change the code to the following:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
namespace OSXConsoleApplication
{
  class Program
  {
    static void Main(string[] args)
    {
      WriteLine(".NET Core app on Ubuntu");
      RunCodeAsync().GetAwaiter().GetResult();
    }
    static async Task RunCodeAsync()
    {
      try
      {
        string result = await GetInfoAsync("Async 1");
        WriteLine(result);
        result = await GetInfoAsync("Async 2");
        WriteLine(result);
      }
      catch (Exception ex)
      {
        WriteLine(ex);
      }
    }
    static async Task&lt;string&gt; GetInfoAsync(string name)
    {
      WriteLine($"Task {name} started!");
      await Task.Delay(TimeSpan.FromSeconds(2));
      if(name == "Async 2")
        throw new Exception("Boom!");
      return
          $"Task {name} completed successfully!"
// + $"Thread id {System.Threading.Thread.CurrentThread.ManagedThreadId}."
                    ;
    }
  }
}</pre></div></li><li class="listitem">Run the program with <code class="literal">dotnet run</code> command.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec235"/>How it works...</h2></div></div></div><p>Here, we start with setting up the apt-get feed that hosts the .NET Core packages that we need. This is<a id="id458" class="indexterm"/> necessary since at the time of writing, .NET Core for Linux may not have been released. For sure, when the release <a id="id459" class="indexterm"/>happens, it will get into normal apt-get feeds and you won't have to add custom feeds to it. After completing this, we use apt-get to install the currently working version of .NET Core.</p><p>Then, we create a separate folder for the .NET Core application, create a blank console application, and check whether everything works fine with restoring dependencies and running the code.</p><p>Finally, we create a simple asynchronous code and try to run it. It should run well, showing<a id="id460" class="indexterm"/> messages that the first task completed <a id="id461" class="indexterm"/>successfully, and the second task caused an exception, which was correctly handled. But if you try to uncomment a line that is intended to show the thread-specific information, the code will not be compiled, since .NET Core has no support for Thread APIs.</p></div></div></body></html>