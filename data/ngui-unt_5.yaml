- en: Chapter 5. Building a Scrollable Viewport
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。构建可滚动的视口
- en: In this chapter, we will create a new scene and build a functional scrollable
    viewport in which we can drop objects that will stick to it. We will add interesting
    features such as scroll bars and keyboard scrolling with arrows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的场景，并构建一个可滚动的视口，我们可以将其中的对象拖放到视口中。我们将添加如滚动条和箭头键盘滚动等有趣的功能。
- en: This scrollable viewport will be the base of our game from the previous chapter.
    So, from here, the user will become the player. The idea is that the player can
    scroll and drag barriers on a viewport, which will take a few seconds to build.
    Enemies will come down from the top of the screen. If an enemy touches a barrier,
    he or she will be destroyed along with the barrier—but we will deal with enemies
    in [Chapter 7](ch07.html "Chapter 7. Creating a Game with NGUI"), *Creating a
    Game with NGUI.*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可滚动的视口将是上一章游戏的基础。因此，从这里开始，用户将成为玩家。想法是玩家可以在视图中滚动和拖动障碍物，这将需要几秒钟来构建。敌人将从屏幕顶部下降。如果敌人接触到障碍物，他和障碍物都将被摧毁——但我们将在[第7章](ch07.html
    "第7章。使用NGUI创建游戏")*使用NGUI创建游戏*中处理敌人。
- en: The more barriers there are on the scene, the longer the building process will
    be for the future barriers— this is the same idea with the barriers' cooldown.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的障碍物越多，未来障碍物的构建过程就越长——这与障碍物的冷却时间相同。
- en: Preparing the Game scene
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备游戏场景
- en: We will need to have our **GameManager** and **Notification** GameObjects as
    prefabs for this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将**GameManager**和**Notification**游戏对象作为本章的预制体。
- en: From our **Menu** scene, create these two prefabs by dragging them separately
    in the folder of your choice in the **Project** view.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的**菜单**场景中，通过在**项目**视图中选择文件夹并将它们分别拖动到您选择的文件夹中，创建这两个预制体。
- en: 'Now, let''s create a new scene with *Ctrl* + *N* and perform the following
    steps:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用*Ctrl* + *N*创建一个新的场景，并执行以下步骤：
- en: Press *Ctrl* + *S* to save it, and enter `Game` as the scene's name.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *S*保存它，并将场景名称输入为`Game`。
- en: In our new scene, delete the **Main Camera** GameObject. We won't need it for
    this scene.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新场景中，删除**主相机**游戏对象。在这个场景中我们不需要它。
- en: Drag our **GameManager** prefab from the **Project** view into the **Hierarchy**
    view.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**GameManager**预制体从**项目**视图拖动到**层次结构**视图中。
- en: Open the **UI Tool** wizard by navigating to **NGUI** | **Create a New UI**.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建新的UI**来打开**UI工具**向导。
- en: Add a new **Layer** named `Game`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Game`的新**层**。
- en: Select this **Game** layer for the **Layer** parameter in our **UI Tool** wizard.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**UI工具**向导中，将**层**参数设置为这个**Game**层。
- en: Click on the **Create Your UI** button.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建您的UI**按钮。
- en: 'Select our new **Camera** GameObject, and set its **Background Color** to **R**:
    `0`, **G**: `0`, **B**: `0`, and **A**: `255`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的新**相机**游戏对象，并将其**背景颜色**设置为**R**：`0`，**G**：`0`，**B**：`0`，和**A**：`255`。
- en: Note
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure your **Color** selector popup is in the **RGBA** values and not **HSVA**.
    This can be done by using the button next to the **Sliders** option when you click
    on a **Color** parameter.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保您的**颜色**选择器弹出窗口处于**RGBA**值，而不是**HSVA**。这可以通过在点击**颜色**参数时使用**滑块**选项旁边的按钮来完成。
- en: 'Select our **UI Root (2D)** GameObject and then perform the following steps:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**UI根（2D）**游戏对象，然后执行以下步骤：
- en: Set its **Scaling Style** parameter to **FixedSize**.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**缩放样式**参数设置为**固定大小**。
- en: Set its **Manual Height** to `1080`.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**手动高度**设置为`1080`。
- en: 'Ok, our scene and UI are ready. Your **UI Root (2D)** script should be as shown
    in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的场景和UI已经准备好了。您的**UI根（2D）**脚本应该如下所示：
- en: '![Preparing the Game scene](img/8667OT_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备游戏场景](img/8667OT_05_01.jpg)'
- en: Let's start creating our scrollable viewport.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的可滚动的视口。
- en: The scrollable viewport
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可滚动的视口
- en: 'We will start by creating a clipped, draggable background, and then add linked
    scroll bars as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个剪切的可拖动背景，然后添加如以下截图所示的链接滚动条：
- en: '![The scrollable viewport](img/8667OT_05_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![可滚动的视口](img/8667OT_05_02.jpg)'
- en: Draggable background
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可拖动背景
- en: We want the player to be able to scroll on both axes. That means we need a background
    both larger and taller than the screen size. For this game, we will need quite
    a large environment to force him or her to scroll regularly. Let's create one
    that is twice the screen's size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家能够在两个轴上滚动。这意味着我们需要一个比屏幕尺寸更大和更高的背景。对于这个游戏，我们需要一个相当大的环境来强制玩家经常滚动。让我们创建一个两倍于屏幕尺寸的环境。
- en: 'Perform the following steps to create the environment:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建环境：
- en: 'Select our **Panel** GameObject and perform the following steps:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **面板** GameObject 并执行以下步骤：
- en: Rename it as `Viewport`.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `Viewport`。
- en: Set its **Clipping** parameter to **Alpha Clip**.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**裁剪**参数设置为 **Alpha Clip**。
- en: Set its **Clipping** **Size** to `1920` x `1080`.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **裁剪** **大小** 设置为 `1920` x `1080`。
- en: 'Add a **Draggable Panel** component to it by navigating to **Component** |
    **NGUI** | **Interaction** and perform the following steps:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **组件** | **NGUI** | **交互** 来添加一个 **Draggable Panel** 组件并执行以下步骤：
- en: Set its **Drag Effect** parameter to **Momentum**. We don't want the player
    to scroll out of bounds with the spring effect.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **拖动效果** 参数设置为 **动量**。我们不希望玩家使用弹簧效果滚动出界。
- en: Set its **Momentum Amount** value to `10`. Over 10, the background will continue
    scrolling too much on release.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**动量量**值设置为 `10`。超过 10，释放时背景将继续滚动过多。
- en: Set its **Scale** parameter to {`1`, `1`, `0`} to enable X and Y scrolling.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**缩放**参数设置为 `{`1`, `1`, `0`} 以启用 X 和 Y 滚动。
- en: Attach a **Drag Panel Contents** component to it by navigating to **Component**
    | **NGUI** | **Interaction**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **组件** | **NGUI** | **交互** 来将其附加一个 **Drag Panel Contents** 组件。
- en: Attach a collider to it by navigating to **NGUI** | **Attach a Collider**, and
    set its **Size** to {`3840`, `2160`, `1`}.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **NGUI** | **附加一个碰撞器** 来将其附加一个碰撞器，并将其**大小**设置为 `{`3840`, `2160`, `1`}。
- en: 'Now that our **Draggable Panel** is set up, let''s add a tiling background
    as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 **Draggable Panel**，让我们添加一个如以下截图所示的平铺背景：
- en: '![Draggable background](img/8667OT_05_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![可拖动背景](img/8667OT_05_03.jpg)'
- en: 'Open the **Widget Tool** wizard by navigating to **NGUI** | **Create a Widget**.
    Then perform the following steps:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **NGUI** | **创建一个 Widget** 打开 **Widget 工具** 向导。然后执行以下步骤：
- en: If the **Atlas** field is set to **None**, drag the **SciFi Atlas** prefab in
    it by navigating to **Assets** | **NGUI** | **Examples** | **Atlases**.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **Atlas** 字段设置为 **None**，则通过导航到 **资产** | **NGUI** | **示例** | **Atlases**
    来将其中的 **SciFi Atlas** 预制拖动到其中。
- en: Select the **Sprite** template.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Sprite** 模板。
- en: Select the **Honeycomb** sprite.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Honeycomb** sprite。
- en: With our **Viewport** selected; click on the **Add To** button.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **Viewport**，然后点击 **添加到** 按钮。
- en: 'Select the new **Sprite (Honeycomb)** GameObject and then perform the following
    steps:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的 **Sprite (Honeycomb)** GameObject 然后执行以下步骤：
- en: Rename it as `Background`.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `Background`。
- en: Set its **Sprite Type** to **Tiled**.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Sprite 类型** 设置为 **Tiled**。
- en: Set its **Color Tint** value to {`0`, `40`, `40`, `255`}.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **颜色色调** 值设置为 `{`0`, `40`, `40`, `255`}。
- en: Set its **Depth** value to `0`.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **深度** 值设置为 `0`。
- en: Set its **Dimensions** to `3840` x `2160`.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**尺寸**设置为`3840` x `2160`。
- en: Click on the play button. That's it, we now have a scrollable viewport. You
    can drag the background by dragging your mouse while clicking.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。就这样，我们现在有一个可滚动的视口。您可以通过在点击的同时拖动鼠标来拖动背景。
- en: Linking scroll bars
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接滚动条
- en: 'Let''s add scroll bars to know where we are on the viewport. They must be on
    a separate panel rendered over our viewport, so that they won''t move with the
    draggable background. Perform the following steps to add the scroll bars:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加滚动条以了解我们在视口中的位置。它们必须位于一个单独的面板上，该面板在视口之上渲染，这样它们就不会随着可拖动背景而移动。执行以下步骤以添加滚动条：
- en: Select our **Anchor** GameObject.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **锚点** GameObject。
- en: Create a new child with *Alt* + *Shift* + *N* and rename it as `UI`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Alt* + *Shift* + *N* 创建一个新的子项并重命名为 `UI`。
- en: Add a **Panel** component to it by navigating to **Component** | **NGUI** |
    **UI**, and set its **Depth** to `1` so that it can be displayed over the viewport.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **组件** | **NGUI** | **UI** 来添加一个 **Panel** 组件，并将其 **深度** 设置为 `1` 以确保它可以在视口上显示。
- en: 'Open the **Widget tool** wizard by navigating to **NGUI** | **Create a Widget**.
    Then perform the following steps:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **NGUI** | **创建一个 Widget** 打开 **Widget 工具** 向导。然后执行以下步骤：
- en: Select **Scrollbar** for the **Template** field.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **模板** 字段设置为 **Scrollbar**。
- en: Select **Dark** sprite as **Background**.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **背景** 设置为 **Dark** sprite。
- en: Select **Highlight** sprite as **Foreground**.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **前景** 设置为 **Highlight** sprite。
- en: Select **Horizontal** for **Direction**.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **方向** 设置为 **水平**。
- en: With our **UI** GameObject selected, click on the **Add To** button.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **UI** GameObject，然后点击 **添加到** 按钮。
- en: On our **Widget Tool** wizard window, select **Vertical** for **Direction**.
    With our **UI** GameObject selected, click on the **Add To** button.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 **Widget 工具** 向导窗口中，将 **方向** 设置为 **垂直**。选择我们的 **UI** GameObject，然后点击 **添加到**
    按钮。
- en: 'We have created both our horizontal and vertical scroll bars at the center
    of the scene as shown in the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已在场景中心创建了水平和垂直滚动条，如以下截图所示：
- en: '![Linking scroll bars](img/8667OT_05_04.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![链接滚动条](img/8667OT_05_04.jpg)'
- en: Now, we need to place them correctly and adjust their size to fit the entire
    screen.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要将它们正确放置并调整大小以适应整个屏幕。
- en: Select the vertical **Scroll Bar** GameObject and rename it as `VerticalScrollbar`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择垂直**Scroll Bar**游戏对象并将其重命名为`VerticalScrollbar`。
- en: 'Attach an **Anchor** component to it by navigating to **NGUI** | **Attach**
    and perform the following steps:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **Attach**将其附加一个**Anchor**组件并执行以下步骤：
- en: Drag our **Viewport** GameObject in the **Container** field.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**Viewport**游戏对象拖动到**Container**字段中。
- en: Set its **Side** parameter to **TopRight**.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Side**参数设置为**TopRight**。
- en: Set its **Pixel Offset** to {`-11`, `0`}.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Pixel Offset**设置为{`-11`, `0`}。
- en: 'Select our **Background** GameObject from **VerticalScrollbar**. Then perform
    the following steps:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**VerticalScrollbar**中选择我们的**Background**游戏对象。然后执行以下步骤：
- en: Set its **Color Tint** to {`130`, `255`, `245`, `110`}.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Color Tint**设置为{`130`, `255`, `245`, `110`}。
- en: Set the **Center** coordinates of **Box Collider** to {`0`, `-540`, `0`}.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Box Collider**的**Center**坐标设置为{`0`, `-540`, `0`}。
- en: Set the **Size** of **Box Collider** to {`22`, `1080`, `0`}.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Box Collider**的**Size**设置为{`22`, `1080`, `0`}。
- en: Attach a **Stretch** component to it by navigating to **Component** | **NGUI**
    | **UI**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**Component** | **NGUI** | **UI**将其附加一个**Stretch**组件。
- en: Set its **Style** parameter to **Vertical**.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Style**参数设置为**Vertical**。
- en: Set its **Relative Size** values to {`1`, `0.983`} in order to leave space for
    our horizontal scroll bar at the bottom of the screen.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Relative Size**值设置为{`1`, `0.983`}，以便在屏幕底部为水平滚动条留出空间。
- en: Select the **Foreground** GameObject from **VerticalScrollbar**, and set its
    **Color Tint** to {`0`, `255`, `128`, `255`}.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**VerticalScrollbar**中选择**Foreground**游戏对象，并将其**Color Tint**设置为{`0`, `255`,
    `128`, `255`}。
- en: Our vertical scroll bar is configured. Let's do the same for the horizontal
    scroll bar.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的垂直滚动条已配置。让我们为水平滚动条做同样的设置。
- en: Select the horizontal **Scroll Bar** GameObject, and rename it as `HorizontalScrollbar`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择水平**Scroll Bar**游戏对象，并将其重命名为`HorizontalScrollbar`。
- en: 'Attach an **Anchor** component to it by navigating to **NGUI** | **Attach**.
    Then perform the following steps:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **Attach**将其附加一个**Anchor**组件。然后执行以下步骤：
- en: Drag our **Viewport** GameObject into the **Container** field.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**Viewport**游戏对象拖动到**Container**字段中。
- en: Set its **Side** parameter to **BottomLeft**.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Side**参数设置为**BottomLeft**。
- en: Set its **Pixel Offset** to {`0`, `11`}.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Pixel Offset**设置为{`0`, `11`}。
- en: 'Select our **Background** GameObject from **HorizontalScrollbar** and perform
    these steps:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HorizontalScrollbar**中选择我们的**Background**游戏对象并执行这些步骤：
- en: Set its **Color Tint** to {`130`, `255`, `245`, `110`}.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Color Tint**设置为{`130`, `255`, `245`, `110`}。
- en: Set the **Center** coordinates of **Box Collider** to {`960`, `0`, `0`}.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Box Collider**的**Center**坐标设置为{`960`, `0`, `0`}。
- en: Set the **Size** of **Box Collider** to {`1920`, `22`, `0`}.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Box Collider**的**Size**设置为{`1920`, `22`, `0`}。
- en: Attach a **Stretch** component to it by navigating to **Component** | **NGUI**
    | **UI**, and set its **Style** parameter to **Horizontal**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**Component** | **NGUI** | **UI**将其附加一个**Stretch**组件，并将其**Style**参数设置为**Horizontal**。
- en: Select the **Foreground** GameObject from **HorizontalScrollbar**, and set its
    **Color Tint** to {`0`, `255`, `128`, `255`}.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HorizontalScrollbar**中选择**Foreground**游戏对象，并将其**Color Tint**设置为{`0`, `255`,
    `128`, `255`}。
- en: 'Good. Both our horizontal and vertical scroll bars are set up. Now, we need
    to assign them to our scrollable viewport by performing the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们的水平和垂直滚动条都已设置。现在，我们需要通过以下步骤将它们分配给可滚动的视口：
- en: Select our **Viewport** GameObject.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Viewport**游戏对象。
- en: Drag our **HorizontalScrollbar** GameObject from **UI** to the **Horizontal
    Scroll Bar** field in **UIDraggable Panel**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**UI**拖动我们的**HorizontalScrollbar**游戏对象到**UIDraggable Panel**中的**Horizontal
    Scroll Bar**字段。
- en: Drag our **VerticalScrollbar** GameObject from **UI** to the **Vertical Scroll
    Bar** field in **UIDraggable Panel**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**VerticalScrollbar**游戏对象从**UI**拖动到**UIDraggable Panel**中的**Vertical Scroll
    Bar**字段。
- en: Change the **Show Scroll Bars** parameter to **Always**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Show Scroll Bars**参数更改为**Always**。
- en: 'Click on the play button. That''s it. Our scroll bars can be used to scroll,
    and they indicate where we are on the viewport as we scroll. Your hierarchy should
    be as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。就这样。我们的滚动条可以用来滚动，并且在我们滚动时指示我们在视口中的位置。您的层次结构应如图所示：
- en: '![Linking scroll bars](img/8667OT_05_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![链接滚动条](img/8667OT_05_05.jpg)'
- en: Now, let's add keyboard scrolling.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加键盘滚动。
- en: Keyboard scrolling
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘滚动
- en: 'For this game, scrolling with the keyboard is important. In order to do so,
    we will create a custom script that will force our scroll bars to move depending
    on the pressed key. Select our **Viewport** GameObject, and attach a new `KeyboardScroll.cs`
    script to it. Open this new script, and declare the required variables and the
    `Awake()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这款游戏，使用键盘滚动很重要。为了做到这一点，我们将创建一个自定义脚本，该脚本将根据按下的键强制我们的滚动条移动。选择我们的**Viewport**游戏对象，并将其新的`KeyboardScroll.cs`脚本附加到它上。打开这个新脚本，并声明所需的变量和`Awake()`方法：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, we have both of our scroll bars on `Awake()`, and a float value for sensitivity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的两个滚动条都在`Awake()`中，并且有一个用于灵敏度的浮点值。
- en: 'Now, let''s check the horizontal and vertical input axes at each frame, and
    change our scroll bars'' values consequently:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在每个帧中检查水平和垂直输入轴，并相应地更改滚动条的值：
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the script and click on the play button. You can now scroll using the keyboard
    arrows. You may also adjust the **Sensitivity** parameter in the **Inspector**
    window as you see fit.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并点击播放按钮。现在您可以使用键盘箭头滚动。您还可以根据需要调整**检查器**窗口中的**灵敏度**参数。
- en: Now, it's time to create draggable barriers that we can drop inside our **Viewport**
    GameObject.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建我们可以将其拖放到我们的**Viewport**游戏对象中的可拖动屏障了。
- en: Creating draggable barriers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可拖动的屏障
- en: 'It is time to create our draggable barriers. The player will be able to drag-and-drop
    the **BarrierObject** prefab in the **Viewport** GameObject. This **BarrierObject**
    prefab will look as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的可拖动屏障了。玩家将能够将**BarrierObject**预设拖放到**Viewport**游戏对象中。这个**BarrierObject**预设将如下面的截图所示：
- en: '![Creating draggable barriers](img/8667OT_05_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![创建可拖动的屏障](img/8667OT_05_06.jpg)'
- en: The BarrierObject prefab
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BarrierObject预设
- en: 'First, we need to create our **BarrierObject** prefab''s holder that will contain
    the draggable object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的**BarrierObject**预设的持有者，它将包含可拖动的对象：
- en: Select our **UI** GameObject.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**UI**游戏对象。
- en: Create a new child with *Alt* + *Shift* + *N* and rename it as `Barrier`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Alt* + *Shift* + *N*创建一个新的子对象，并将其重命名为`Barrier`。
- en: 'Open the **Widget Tool** wizard by navigating to **NGUI** | **Open** and perform
    the given steps:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **打开**并执行给定的步骤来打开**Widget Tool**向导：
- en: Select **Sprite** for the **Template** parameter.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**模板**参数的**精灵**设置为**Sprite**。
- en: Select **Dark** sprite for the **Sprite** field.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sprite**字段的**精灵**选择为**Dark**。
- en: With our **Barrier** GameObject selected, click on the **Add To** button.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**Barrier**游戏对象被选中时，点击**添加到**按钮。
- en: 'Select our new barrier''s **Sprite (Dark)** GameObject and perform the following
    steps:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们新屏障的**Sprite (Dark)**游戏对象并执行以下步骤：
- en: Rename it as `Background`.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`Background`。
- en: Set its **Sprite Type** to **Sliced**.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**精灵类型**设置为**Sliced**。
- en: Set its **Color Tint** to {`0`, `250`, `250`, `170`}.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**颜色色调**设置为 `{`0`, `250`, `250`, `170`}`。
- en: Set its **Depth** value to `0`.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**值设置为`0`。
- en: Set its **Dimensions** to `200` x `200`.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**尺寸**设置为`200` x `200`。
- en: Select our **Barrier** GameObject.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Barrier**游戏对象。
- en: 'Attach a collider to it by navigating to **NGUI** | **Attach a Collider** and
    perform the following steps:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **附加一个碰撞器**来将其附加一个碰撞器，并执行以下步骤：
- en: Set its **Center** coordinates in **Box Collider** to {`0`, `0`, `0`}.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Box Collider**中的**中心**坐标设置为 `{`0`, `0`, `0`}`。
- en: Set the **Size** parameter of **Box Collider** to {`200`, `200`, `1`}.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Box Collider**的**大小**参数设置为 `{`200`, `200`, `1`}`。
- en: Attach **Anchor** to it by navigating to **NGUI** | **Attach**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **附加**来将其**锚点**附加到它上。
- en: Drag our **Viewport** GameObject in its **Container** field.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**Viewport**游戏对象拖动到其**容器**字段中。
- en: Set its **Side** parameter to **TopLeft**.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**侧面**参数设置为**TopLeft**。
- en: Set its **Pixel Offset** to {`100`, `-100`}.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**像素偏移**设置为 `{`100`, `-100`}`。
- en: 'Ok, we have our **BarrierObject** holder''s background at the top left-hand
    corner as shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的**BarrierObject**持有者的背景现在在左上角，如下面的截图所示：
- en: '![The BarrierObject prefab](img/8667OT_05_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![BarrierObject预设](img/8667OT_05_07.jpg)'
- en: 'Let''s create the actual **BarrierObject** prefab, which will be a custom button:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建实际的**BarrierObject**预设，它将是一个自定义按钮：
- en: Select our **Barrier** GameObject.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Barrier**游戏对象。
- en: 'Open the **Widget tool** wizard by navigating to **NGUI** | **Create a Widget**
    and perform the following steps:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建一个Widget**打开**Widget tool**向导并执行以下步骤：
- en: Drag the **SciFi Font – Normal** prefab into the **Widget Tool** wizard's **Font**
    field by navigating to **Assets** | **NGUI** | **Examples** | **Atlases** | **SciFi**.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**资产** | **NGUI** | **示例** | **图集** | **SciFi**将**SciFi Font – Normal**预设拖动到**Widget
    Tool**向导的**字体**字段中。
- en: Select **Button** for the **Template** field.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 **Template** 字段选择 **Button**。
- en: Select the **Highlight** sprite for the **Background** field.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 **Background** 字段选择 **Highlight** 精灵。
- en: With our **Barrier** GameObject selected, click on the **Add To** button.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择我们的 **Barrier** 游戏对象后，点击 **Add To** 按钮。
- en: Select our new **Button** GameObject from **Barrier**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Barrier** 中选择我们的新 **Button** 游戏对象。
- en: Rename it as `BarrierObject`.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `BarrierObject`。
- en: Set its **Center** coordinates **Box Collider** to {`0`, `0`, `0`}.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Center** 坐标 **Box Collider** 设置为 `{`0`, `0`, `0`}`。
- en: Set **Size** of **Box Collider** to {`160`, `160`, `0`}.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Box Collider** 的 **Size** 设置为 `{`160`, `160`, `0`}`。
- en: 'Drag the **Background** GameObject from **BarrierObject** into the **Target**
    field in **UIButton**. Then perform the following steps:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **BarrierObject** 中的 **Background** 游戏对象拖动到 **UIButton** 的 **Target** 字段中。然后执行以下步骤：
- en: Set its **Normal Color** to {`125`, `255`, `155`, `130`}.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Normal Color** 设置为 `{`125`, `255`, `155`, `130`}`。
- en: Set its **Hover Color** to {`100`, `255`, `60`, `255`}.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Hover Color** 设置为 `{`100`, `255`, `60`, `255`}`。
- en: Set its **Pressed Color** to {`20`, `255`, `0`, `160`}.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Pressed Color** 设置为 `{`20`, `255`, `0`, `160`}`。
- en: Set its **Disabled Color** to {`115`, `115`, `155`, `255`}.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Disabled Color** 设置为 `{`115`, `115`, `155`, `255`}`。
- en: 'Select the **Background** GameObject from **BarrierObject** and perform the
    following steps:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **BarrierObject** 中选择 **Background** 游戏对象并执行以下步骤：
- en: Set its **Depth** value to `1`.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Depth** 值设置为 `1`。
- en: Set its **Dimensions** to `160` x `160`.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Dimensions** 设置为 `160` x `160`。
- en: 'Select the **Label** GameObject from **BarrierObject** and then perform the
    given steps:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **BarrierObject** 中选择 **Label** 游戏对象并执行给定的步骤：
- en: Set its text to `[99FF99]Barrier`.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其文本设置为 `[99FF99]Barrier`。
- en: Set its **Depth** to `2`.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Depth** 设置为 `2`。
- en: 'Ok. We now have our **BarrierObject** in the **Barrier** holder. Let''s make
    it draggable by performing the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们现在有了 **BarrierObject** 在 **Barrier** 持有者中。让我们通过以下步骤使其可拖动：
- en: Select our **BarrierObject** GameObject.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **BarrierObject** 游戏对象。
- en: Attach a **Drag Object** component to it by navigating to **Component** | **NGUI**
    | **Interaction**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **Component** | **NGUI** | **Interaction** 为其附加一个 **Drag Object** 组件。
- en: Drag our **BarrierObject** GameObject in its **Target** field.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 **BarrierObject** 游戏对象拖动到其 **Target** 字段中。
- en: Set its **Scale** parameter to {`1`, `1`, `0`} to avoid Z scrolling.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Scale** 参数设置为 `{`1`, `1`, `0`} 以避免 Z 轴滚动。
- en: Set its **Drag Effect** parameter to **None**. We want it to be precise.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Drag Effect** 参数设置为 **None**。我们希望它更精确。
- en: Create and attach a new `BarrierObjectController.cs` C# script to it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其创建并附加一个新的 `BarrierObjectController.cs` C# 脚本。
- en: Click on the play button. The **BarrierObject** prefab is now draggable. Now,
    it is time to handle the drop on the **Viewport** GameObject.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。现在，**BarrierObject** 预制件现在是可拖动的。现在，是时候处理在 **Viewport** 游戏对象上的放置操作了。
- en: Before we continue, drag our **BarrierObject** in a folder of your choice in
    the **Project** view to make it a prefab.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，将我们的 **BarrierObject** 拖动到 **Project** 视图中你选择的文件夹中，使其成为一个预制件。
- en: Dropping a barrier on Viewport
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中放下障碍物
- en: 'In order to drop a barrier inside the **Viewport** GameObject, we need to catch
    the **Viewport** GameObject''s `OnDrop()` event and check what was dropped:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 **Viewport** 游戏对象内部放下一个障碍物，我们需要捕获 **Viewport** 游戏对象的 `OnDrop()` 事件并检查放下的是什么：
- en: Select our **Viewport** GameObject.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **Viewport** 游戏对象。
- en: Create and attach a new `ViewportHolder.cs` C# script to it.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其创建并附加一个新的 `ViewportHolder.cs` C# 脚本。
- en: Open this new `ViewportHolder.cs` script.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的 `ViewportHolder.cs` 脚本。
- en: 'In this script, we can add a new `OnDrop()` method that will be called when
    an object is dropped on it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们可以添加一个新的 `OnDrop()` 方法，当对象放在它上面时将被调用：
- en: '[PRE2]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the script and click on the play button. Surprisingly, when you drop the
    **BarrierObject** on the **Viewport** GameObject, nothing happens!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并点击播放按钮。令人惊讶的是，当你将 **BarrierObject** 放在 **Viewport** 游戏对象上时，什么也没有发生！
- en: That's because, like in [Chapter 3](ch03.html "Chapter 3. Enhancing your UI"),
    *Enhancing your UI*, the Collider of **BarrierObject** is enabled when the `OnPress(false)`
    event occurs. This obstructs the collision detection of **UICamera**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，就像在 [第 3 章](ch03.html "第 3 章。增强你的 UI") 中一样，*增强你的 UI*，当 `OnPress(false)`
    事件发生时，**BarrierObject** 的碰撞器被启用。这阻碍了 **UICamera** 的碰撞检测。
- en: 'We just have to disable the collider while dragging, and re-enable it when
    dropping it. Let''s also make it reposition itself if it isn''t dropped on the
    **Viewport** GameObject. Open our `BarrierObjectController.cs` script, and add
    following `OnPress()` method to do so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在拖动时禁用碰撞器，并在放下时重新启用它。如果它没有放在 **Viewport** 游戏对象上，我们还要让它重新定位。打开我们的 `BarrierObjectController.cs`
    脚本，并添加以下 `OnPress()` 方法来实现这一点：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the script and click on the play button. This time, the collider is disabled
    when the **BarrierObject** prefab is dropped. So, it is indeed dropped on the
    collider of **Viewport** and destroyed instantly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并点击播放按钮。这次，当**BarrierObject**预制体被放置时，碰撞器被禁用。因此，它确实被放置在**视口**的碰撞器上并立即被销毁。
- en: If it is dropped somewhere else (out of screen or on the barrier's container),
    it is automatically replaced at the center of the barrier's container. Let's make
    this **BarrierObject** a prefab by dragging it in the folder of your choice inside
    the **Project** view.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它被放置在其他地方（屏幕外或障碍物容器上），它将自动替换到障碍物容器的中心。让我们将这个**BarrierObject**作为预制体拖动到**项目**视图中您选择的文件夹中。
- en: We can now create an **ActiveBarrier** prefab that will be instantiated on the
    **Viewport** GameObject.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个将在**视口**GameObject上实例化的**ActiveBarrier**预制体。
- en: Creating an ActiveBarrier prefab
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个**ActiveBarrier**预制体
- en: 'When a **BarrierObject** is dropped on the **Viewport** GameObject, we want
    to instantiate an **ActiveBarrier** prefab that will take a few seconds to build,
    using a slider as status indicator as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当**BarrierObject**被放置在**视口**GameObject上时，我们希望实例化一个将花费几秒钟构建的**ActiveBarrier**预制体，并使用滑块作为状态指示器，如下截图所示：
- en: '![Creating an ActiveBarrier prefab](img/8667OT_05_08.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![创建ActiveBarrier预制体](img/8667OT_05_08.jpg)'
- en: The ActiveBarrier prefab
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ActiveBarrier预制体
- en: 'Let''s create the **ActiveBarrier** prefab by performing the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建**ActiveBarrier**预制体：
- en: Select our **Viewport** GameObject.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**视口**GameObject。
- en: Create a new child with *Alt* + *Shift* + *N*.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Alt* + *Shift* + *N* 创建一个新的子对象。
- en: Select this new child and rename it as `ActiveBarrier`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新的子对象并将其重命名为 `ActiveBarrier`。
- en: 'Open the **Widget Tool** wizard by navigating to **NGUI** | **Create a Widget**
    and perform the following steps:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建小部件**打开**小部件工具**向导并执行以下步骤：
- en: Select **Progress Bar** for the **Template** field.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**进度条**作为**模板**字段。
- en: Set **Dark** sprite as **Empty**.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**暗**精灵设置为**空**。
- en: Set the **Highlight** sprite as **Full**.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**高亮**精灵设置为**全**。
- en: With our **ActiveBarrier** GameObject selected, click on the **Add To** button.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ActiveBarrier** GameObject被选中时，点击**添加到**按钮。
- en: 'A **Progress Bar** has just been created as child of the **ActiveBarrier**
    GameObject as shown in the following screenshot:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下截图所示，**进度条**已作为**ActiveBarrier** GameObject的子对象创建：
- en: '![The ActiveBarrier prefab](img/8667OT_05_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![ActiveBarrier预制体](img/8667OT_05_09.jpg)'
- en: 'It doesn''t look like anything. Let''s configure it to look like an **ActiveBarrier**
    prefab by performing the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来什么都没有。让我们通过以下步骤配置它，使其看起来像**ActiveBarrier**预制体：
- en: 'Select our new **Background** GameObject from **Progress Bar** and perform
    the following steps:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**进度条**中选择我们的新**背景**GameObject并执行以下步骤：
- en: Uncheck its **Fill Center** boolean to only keep edges.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中其**填充中心**布尔值以仅保留边缘。
- en: Set its **Color Tint** to {`100`, `200`, `100`, `255`}.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**颜色色调**设置为 `{`100`, `200`, `100`, `255`}。
- en: Set its **Depth** to `1` so that it can be rendered over the **Viewport** background.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**设置为 `1` 以确保它可以在**视口**背景之上渲染。
- en: Set its **Dimensions** to `160` x `160`.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**尺寸**设置为 `160` x `160`。
- en: 'Select our **Foreground** GameObject from **Progress Bar** and perform the
    following steps:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**进度条**中选择我们的**前景**GameObject并执行以下步骤：
- en: Set its **Color Tint** to {`75`, `190`, `95`, `255`}.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**颜色色调**设置为 `{`75`, `190`, `95`, `255`}。
- en: Set its **Depth** value to `2`.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**值设置为 `2`。
- en: Set its **Dimensions** to `160` x `160`.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**尺寸**设置为 `160` x `160`。
- en: 'Select our **Progress Bar** from **ActiveBarrier** and perform the following
    steps:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**ActiveBarrier**中选择我们的**进度条**并执行以下步骤：
- en: Rename it as `Slider`.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `Slider`。
- en: Set its **Transform Position** to {`-80`, `0`, `0`} to center it.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**变换位置**设置为 `{`-80`, `0`, `0`} 以使其居中。
- en: Set the **UISlider** value to `0` to make sure it's empty at start.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UISlider**值设置为 `0` 以确保它从开始时就是空的。
- en: Select our **ActiveBarrier** GameObject.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**ActiveBarrier** GameObject。
- en: Attach a collider to it by navigating to **NGUI** | **Attach**, and set its
    **Size** to {`160`, `160`, `1`}.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **附加**将其附加到一个碰撞器上，并设置其**大小**为 `{`160`, `160`, `1`}。
- en: The slider of **ActiveBarrier** GameObject is ready. If you click on the play
    button and change the **Slider** value in the **Inspector** view during runtime,
    you will see the **ActiveBarrier** prefab building itself.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**ActiveBarrier** GameObject的滑块已准备就绪。如果您在运行时点击播放按钮并在**检查器**视图中更改**滑块**值，您将看到**ActiveBarrier**预制体正在构建。'
- en: 'Let''s add a label that will show the status of **ActiveBarrier**: either **Building**
    or **Built**.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个标签来显示**ActiveBarrier**的状态：要么是**Building**，要么是**Built**。
- en: 'Duplicate our **Label** GameObject in **BarrierObject** and perform the following
    steps:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BarrierObject**中复制我们的**Label**游戏对象并执行以下步骤：
- en: Drag it inside our **ActiveBarrier** GameObject.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它拖动到我们的**ActiveBarrier**游戏对象内部。
- en: Reset its **Transform Position** to {`0`, `0`, `0`}.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置其**Transform Position**为`{`0`, `0`, `0`}`。
- en: Set its **Depth** to `3`.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Depth**设置为`3`。
- en: Add a Localize component to it by navigating to **Component** | **NGUI** | **UI**.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**Component** | **NGUI** | **UI**为其添加一个本地化组件。
- en: Set the key of **UILocalize** to `BuildingBarrier`.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UILocalize**的键设置为`BuildingBarrier`。
- en: Drag our **ActiveBarrier** in the folder of your choice inside the **Project**
    view to make it a prefab.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的选择文件夹中的**ActiveBarrier**拖动到**Project**视图以使其成为预制件。
- en: Delete the **ActiveBarrier** instance from the scene.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除**ActiveBarrier**实例。
- en: 'Ok, our **ActiveBarrier** prefab is ready. Now, add the following localization
    strings to `English.txt`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的**ActiveBarrier**预制件已经准备好了。现在，在`English.txt`中添加以下本地化字符串：
- en: '[PRE4]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, add the following localization strings to `French.txt`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在`French.txt`中添加以下本地化字符串：
- en: '[PRE5]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, everything is set for our **ActiveBarrier** prefab.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的**ActiveBarrier**预制件已经设置好了。
- en: Instantiating the ActiveBarrier prefab
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化ActiveBarrier预制件
- en: Now that we have our prefab, we need to instantiate it when a **BarrierObject**
    prefab is dropped inside the **Viewport** GameObject.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了预制件，当**BarrierObject**预制件被拖放到**Viewport**游戏对象内部时，我们需要实例化它。
- en: 'Open our `ViewportHolder.cs` script and declare our necessary variables:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们的`ViewportHolder.cs`脚本并声明必要的变量：
- en: '[PRE6]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the script. Let''s go back to the scene and assign these variables in
    the **Inspector** view:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。让我们回到场景，并在**Inspector**视图中分配这些变量：
- en: Select the **Viewport** GameObject.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Viewport**游戏对象。
- en: Drag the **BarrierObject** prefab from the **Project** view in the **BarrierObject**
    prefab field of **Viewport Holder**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**BarrierObject**预制件从**Project**视图拖动到**Viewport Holder**中的**BarrierObject**预制件字段。
- en: Drag the **ActiveBarrier** prefab from the **Project** view in the **ActiveBarrier**
    prefab field **Viewport Holder**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ActiveBarrier**预制件从**Project**视图拖动到**Viewport Holder**中的**ActiveBarrier**预制件字段。
- en: Drag the **Barrier** GameObject in **UI** from the **Hierarchy** view to the
    **Barrier Container** field in **Viewport Holder**.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Barrier**游戏对象从**Hierarchy**视图拖动到**Viewport Holder**中的**Barrier Container**字段。
- en: 'The necessary variables are assigned. Go back to our `ViewportHolder.cs` script,
    and add the following two lines to call the appropriate methods, after `Destroy(droppedObj)`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的变量已经分配。回到我们的`ViewportHolder.cs`脚本，并在`Destroy(droppedObj)`之后添加以下两行来调用适当的方法：
- en: '[PRE7]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can add these two methods that will recreate our **BarrierObject**
    prefab. Also, we can add an **ActiveBarrier** prefab to the **Viewport** GameObject:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加这两个方法来重新创建我们的**BarrierObject**预制件。我们还可以将一个**ActiveBarrier**预制件添加到**Viewport**游戏对象：
- en: '[PRE8]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Click on the play button. When you drag the **BarrierObject** prefab onto the
    **Viewport** GameObject, it creates our **ActiveBarrier** prefab; and it recreates
    a **BarrierObject** prefab to be able to drag another one.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。当你将**BarrierObject**预制件拖动到**Viewport**游戏对象上时，它将创建我们的**ActiveBarrier**预制件；并且重新创建一个**BarrierObject**预制件以便可以拖动另一个。
- en: Barrier's building process
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 障碍物构建过程
- en: 'Right now, our dropped **ActiveBarrier** instances stay empty and never build.
    Let''s make them fill themselves at a speed depending on the number of barriers
    in the scene:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们掉落的**ActiveBarrier**实例保持为空且永远不会构建。让我们让它们以场景中障碍物数量的速度填充：
- en: Select our **ActiveBarrier** prefab in the **Project** view.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**视图中选择我们的**ActiveBarrier**预制件。
- en: Create and add an `ActiveBarrierController.cs` script to it.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为它创建并添加一个`ActiveBarrierController.cs`脚本。
- en: 'Open this new `ActiveBarrierController.cs` script, and add these necessary
    variables and the `Awake()` method to initialize them:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个新的`ActiveBarrierController.cs`脚本，并添加必要的变量和`Awake()`方法来初始化它们：
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have our necessary variables initialized, let''s add a coroutine
    that will increase the **UISlider** value over time, at a rate depending on a
    given `buildTime`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了必要的变量，让我们添加一个协程，它将随着时间的推移增加**UISlider**值，速率取决于给定的`buildTime`：
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ok. Let''s add the `BuildFinished()` method that will set the **Slider** value
    to `1` (in case this value is higher), and change the **UILocalize** key:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在让我们添加`BuildFinished()`方法，将**Slider**值设置为`1`（如果这个值更高），并更改**UILocalize**键：
- en: '[PRE11]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Good. We just need to edit the `ViewportHolder.cs` script to add a `barrierCount`
    variable, and start the new `Build()` coroutine from **ActiveBarrier**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们只需要编辑`ViewportHolder.cs`脚本，添加一个`barrierCount`变量，并从**ActiveBarrier**开始新的`Build()`协程。
- en: 'Open the `ViewportHolder.cs` script and declare a new `int` after our `barrierContainer`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`ViewportHolder.cs`脚本，并在我们的`barrierContainer`之后声明一个新的`int`：
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s add these two simple lines of code to update the `barrierCount`
    variable and start the `Build()` coroutine on our new **ActiveBarrier** prefab:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加这两行简单的代码来更新`barrierCount`变量，并在我们新的**ActiveBarrier**预制体上启动`Build()`协程：
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click on the play button. Now, our **ActiveBarrier** prefab builds itself depending
    on the number of **ActiveBarriers** on the scene!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。现在，我们的**ActiveBarrier**预制体将根据场景中**ActiveBarriers**的数量自行构建！
- en: Forwarding events to viewport
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将事件转发到视口
- en: You may have noticed that you cannot scroll if you click on an **ActiveBarrier**
    prefab. That's because it catches the events instead of our viewport.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，如果你点击**ActiveBarrier**预制体，就无法滚动。这是因为它捕获了事件而不是我们的视口。
- en: 'Let''s simply forward its events to the viewport:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单地将其事件转发到视口：
- en: Select our **ActiveBarrier** prefab in the **Project** view.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中选择我们的**ActiveBarrier**预制体。
- en: 'Attach a **Forward Events** component to it by navigating to **Component**
    | **NGUI** | **Interaction** and perform the following steps:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**组件** | **NGUI** | **交互**，将其附加一个**转发事件**组件，并执行以下步骤：
- en: Check its **On Press** Boolean.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查其**On Press**布尔值。
- en: Check its **On Drag** Boolean.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查其**On Drag**布尔值。
- en: Open the `ActiveBarrierController.cs` script that is attached to it.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开附加到其上的`ActiveBarrierController.cs`脚本。
- en: 'We need to assign the target variable of the **UIForward Event** component
    when the **ActiveBarrier** prefab is created. To do so, add a new `Start()` method
    with the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在创建**UIForward Event**组件时分配目标变量。为此，添加一个新的`Start()`方法，如下所示：
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now scroll no matter what. We are missing something: a cooldown on the
    BarrierObjects that also depends on the number of ActiveBarriers.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以随意滚动。我们缺少一些东西：一个依赖于活动障碍物数量的冷却时间。
- en: BarrierObject cooldown
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 障碍物对象冷却
- en: 'We will implement the cooldown system that will deactivate the **BarrierObject**
    button as shown in the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个冷却系统，该系统将根据以下截图所示禁用**BarrierObject**按钮：
- en: '![BarrierObject cooldown](img/8667OT_05_10.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![障碍物对象冷却](img/8667OT_05_10.jpg)'
- en: Then, we will make the barrier's apparition smoother by tweening its scale.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过缓动使障碍物的出现更加平滑。
- en: Cooldown implementation
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冷却实现
- en: 'In order to implement the required cooldown, we need to open the `BarrierObjectController.cs`
    script and add the following two necessary variables with an initialization on
    `Awake()`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现所需的冷却，我们需要打开`BarrierObjectController.cs`脚本，并在`Awake()`中添加以下两个必要的变量及其初始化：
- en: '[PRE15]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have the button and label, we can add a `Cooldown()` coroutine
    that will deactivate the button and update the label to show the remaining time
    to the player:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了按钮和标签，我们可以添加一个`Cooldown()`协程，该协程将禁用按钮并更新标签以显示剩余时间给玩家：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous coroutine updates the label and decreases the cooldown. We can
    now add the `CooldownFinished()` method that will reactivate the button and reset
    the label:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的协程更新了标签并减少了冷却时间。我们现在可以添加`CooldownFinished()`方法，该方法将重新激活按钮并重置标签：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Great, everything is ready for our cooldown. We just need to start the `Cooldown()`
    coroutine when a new **BarrierObject** prefab is created.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，一切准备就绪，我们的冷却。我们只需要在创建新的**BarrierObject**预制体时启动`Cooldown()`协程。
- en: 'In order to do this, let''s go back to our `ViewportHolder.cs` script and add
    the following line at the very end of the `RecreateBarrierObject()` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们回到我们的`ViewportHolder.cs`脚本，并在`RecreateBarrierObject()`方法的末尾添加以下行：
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Perfect. Here, we needed to pass `barrierCount +1` as argument because at this
    stage it is not yet updated (it is incremented in the `CreateActiveBarrier()`
    method).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。在这里，我们需要将`barrierCount +1`作为参数传递，因为在这个阶段它还没有更新（它在`CreateActiveBarrier()`方法中增加）。
- en: Click on the play button. When you drop a **BarrierObject** prefab on the **Viewport**
    GameObject, you will only be able to drop another one when the cooldown is finished.
    The more barriers you have, the longer the cooldown.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。当你将**BarrierObject**预制体拖放到**视口**游戏对象上时，你只能在冷却完成时才能放下另一个。障碍物越多，冷却时间越长。
- en: BarrierObject smooth apparition
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 障碍物对象平滑出现
- en: 'Let''s add a TweenScale to make the barrier''s availability more obvious to
    the player. Go back to our `BarrierObjectController.cs` script and add the following
    two lines at the very end of the `CooldownFinished()` method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个 TweenScale 来使障碍物的可用性对玩家更加明显。回到我们的 `BarrierObjectController.cs` 脚本，并在
    `CooldownFinished()` 方法的最后添加以下两行代码：
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's better. Now, the animated apparition of **BarrierObject** attracts the
    player's eye. But, hey, we created a notification in the previous chapter. Let's
    reuse it to make it even more obvious!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。现在，**BarrierObject** 的动画出现吸引了玩家的注意。但是，嘿，我们在上一章中创建了一个通知。让我们重用它来让它更加明显！
- en: The barrier availability tool tip
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 障碍物可用提示
- en: 'Let''s set up notifications in the game using our previous work:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前的工作在游戏中设置通知：
- en: Drag our **Notification** prefab inside our **UI** GameObject.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 **Notification** 预制体拖入我们的 **UI** GameObject 中。
- en: 'Select the new **Notification** GameObject in the **Hierarchy** view, and then
    perform the following steps:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 视图中选择新的 **Notification** GameObject，然后执行以下步骤：
- en: Change its **Layer** to **Game** (in the top right-hand corner of the **Inspector**
    view).
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Layer** 改为 **Game**（在 **Inspector** 视图的右上角）。
- en: A pop up will appear. Click on **Yes**, and change children.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个弹出窗口。点击 **是**，并更改子项。
- en: Open the `NotificationManager.cs` script that is attached to it.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开与之相连的 `NotificationManager.cs` 脚本。
- en: 'First, we need to add a new notification type. This is done by adding a third
    line to our type `enum`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个新的通知类型。这是通过在我们的类型 `enum` 中添加第三行来完成的：
- en: '[PRE20]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, add the following localization string to `English.txt`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下本地化字符串添加到 `English.txt`：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, add the following localization string to `French.txt`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将以下本地化字符串添加到 `French.txt`：
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Everything is set. Now, go back to our `BarrierObjectController.cs` script,
    and add the following line of code at the very end of the `CooldownFinished()`
    method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置完毕。现在，回到我们的 `BarrierObjectController.cs` 脚本，并在 `CooldownFinished()` 方法的最后添加以下代码行：
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Click on the play button. A localized notification will appear as soon as a
    new barrier is available. This way, we are sure that the player will not miss
    it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。一旦有新的障碍物可用，就会立即显示本地化的通知。这样我们就可以确保玩家不会错过它。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create a scrollable viewport using a scrollable
    background. Also, we linked the mouse drag, scroll bars, and keyboard arrows to
    it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用可滚动的背景创建可滚动的视口。我们还将其与鼠标拖动、滚动条和键盘箭头链接起来。
- en: We used the **UIDrag Object** component to create our drag-and-drop system,
    allowing us to drag objects inside the scrollable viewport.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 **UIDrag Object** 组件来创建我们的拖放系统，允许我们在可滚动的视图中拖动对象。
- en: Coroutines helped us to create the barriers' building process and cooldown system.
    The **UIForward Events** component was used to forward events to the viewport.
    Finally, we reused our **Notification** prefab inside our new **Game** scene.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 协程帮助我们创建了障碍物的建造过程和冷却系统。使用了 **UIForward Events** 组件将事件转发到视图中。最后，我们在新的 **Game**
    场景中重新使用了我们的 **Notification** 预制体。
- en: We now have the basic elements for [Chapter 7](ch07.html "Chapter 7. Creating
    a Game with NGUI"), *Creating a Game with NGUI*. Now, it is time to discover how
    to add sprites and fonts to NGUI with [Chapter 6](ch06.html "Chapter 6. Atlas
    and Font Customization"), *Atlas and Font Customization*. We will then use our
    own assets to create a game!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了 [第 7 章](ch07.html "第 7 章。使用 NGUI 创建游戏")，*使用 NGUI 创建游戏* 的基本元素。现在，是时候发现如何使用
    [第 6 章](ch06.html "第 6 章。图集和字体自定义")，*图集和字体自定义* 来向 NGUI 添加精灵和字体了。然后我们将使用我们自己的资产来创建一个游戏！
