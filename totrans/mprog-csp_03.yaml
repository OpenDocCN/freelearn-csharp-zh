- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying through Existing Real-World Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look into how Microsoft’s **ASP.NET** leverages metaprogramming
    in order to automate tedious configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Since the first release of **ASP.NET MVC** back in 2009, there has been quite
    a lot of automation going on to make developers more productive. The main objective
    of this chapter is to demystify what metaprogramming is by showing that you might
    already be leveraging something that takes advantage of metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how ASP.NET leverages metaprogramming
    with a non-intrusive approach and see the benefits of automation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with either Windows, macOS, or Linux installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **.NET** **6 SDK**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferably, a code editor or IDE (such as Visual Studio Code, Visual Studio,
    or JetBrains Rider)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3)'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for your system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive concretely into code, so you need to have your system
    prepared.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we’ll need is the Microsoft .NET SDK. Go to [https://dot.net](https://dot.net)
    and download the SDK by clicking the **Download** button.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This book is based on *version 7* of the .NET SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and edit files, it all depends on your own preferences and also what
    system you’re running on. Visual Studio Code and JetBrains Rider are both available
    on Windows, macOS, and Linux. Visual Studio is only available for Windows and
    macOS. You can download any of these editors from the following links; if you
    don’t have a preference, VSCode is lightweight and will get you up and running
    very fast:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VSCode** ([https://code.visualstudio.com/](https://code.visualstudio.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JetBrains** **Rider** ([https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual** **Studio** ([https://visualstudio.com/](https://visualstudio.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve picked your editor, go ahead and follow the installation process
    relevant to the product you chose.
  prefs: []
  type: TYPE_NORMAL
- en: To call on APIs, you can use the web browser, **Wget**, or **cURL**, but I recommend
    using **Postman** ([https://www.postman.com/](https://www.postman.com/)) for this.
    Samples in this book will use Postman.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being explicit with registering artifacts of your application is very common
    among different frameworks. Discovering the artifacts and just doing an automated
    self-registration of them is becoming more popular. But it’s very common that
    you will have to go and explicitly add everything manually.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is very clear what is going on with these registrations, the downside
    of manual registration is that you are basically adding code that is not directly
    contributing to the business value you’re trying to achieve. It is also code that
    is highly repeatable and tends to end up in large files with all the initialization
    going on.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, with **ASP.NET Core 6** we got a brand-new minimal API, which
    is designed to have a smaller footprint and less ceremony to get started. You
    can start creating a Web API with three lines of setup code and then add your
    API as HTTP methods with routes at will.
  prefs: []
  type: TYPE_NORMAL
- en: This is all fine and dandy, but can quite easily become unmaintainable as the
    project grows.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive more concretely into how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for this on your system called [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041).
    In this folder, we want to create a simple ASP.NET web application. This can be
    done in various ways, depending on the editor/IDE choice you made and also your
    personal preferences. However, throughout the book, we’ll just stick with doing
    it from the command line, as that will work in all environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a command-line interface (Windows CMD, macOS Terminal, Linux bash,
    or similar). Navigate to the folder you created for this ([*Chapter 3*](B19418_03.xhtml#_idTextAnchor041)).
    Then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a minimal setup to get started. Open the folder/project in
    your editor/IDE. Your **Program.cs** file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It basically sets up a web application and adds a route at the root level that
    will return **"Hello World!"** when navigating to it using your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: The **app.MapGet()** call is a very simple way to expose an endpoint and could
    in fact be used to build simple REST APIs. Let’s create a simple one for returning
    employees of a system.
  prefs: []
  type: TYPE_NORMAL
- en: Custom HTTP Get handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a new file called **Employee.cs** and adding the following
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This holds just a simple representation of an employee with their first and
    last name. Obviously, in a proper system, you would add more properties to this.
    But for the sake of this sample, this will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Employee** type in place, we can now change our **Get** action to
    a different route and also just return a collection of the **Employee** type.
    Swap out the **.MapGet()** method call with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, you also need to add a **using** statement for the
    **Chapter3** namespace. The new **Program.cs** file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this using **dotnet run** from your terminal/console or if you
    prefer to run it with your IDE, you should get a running program listing something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The two lines saying **Now listening on:** will have different ports on your
    computer, as it is randomly assigned when creating the project. Combine the URL
    with **/api/employees** from the **.MapGet()** method. It should be something
    like **https://localhost:7027/api/employees** or the non-HTTPS **http://localhost:5016/api/employees**,
    just remember to put your ports into it. Take this combined URL and navigate to
    it in your browser. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, if you’re adding a bunch of these API endpoints right there in the
    program file with additional logic within the handler method, this file will become
    big and hard to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we can improve a lot and let ASP.NET be clever. Let’s start by
    creating a controller for this instead.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new file called **EmployeesController.cs** to the project. Make the file
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will now create a Web API controller that leverages explicit metadata using
    the available C# attributes found in ASP.NET. In front of the **EmployeesController**
    class, you have the **[Route]** attribute, which tells at which base route the
    controller will be located. Then we have a method we want to represent a particular
    HTTP verb; this is the **[****HttpGet]** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now rigged our code to be automatically discovered and configured by
    the ASP.NET engine itself. All we need to do is change the startup of this application
    and instruct ASP.NET to add controllers to our system. Open the **Program.cs**
    file and replace the content with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The **builder.Services.AddControllers()** call will instruct ASP.NET to discover
    all the controllers in the current assembly. The second call you’ll notice is
    **app.MapControllers()**. This call maps all the controllers to the routes specified
    in the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: By running this application and navigating the browser to the same URL as before,
    we should see the exact same result.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty now with this model is that we can quite easily add a second controller
    without having to go into the configuration of our application to get it configured.
    It will just be discovered and automatically be there.
  prefs: []
  type: TYPE_NORMAL
- en: That means we can now concentrate on building out the business value and it
    is by default more manageable and maintainable, especially when you bring other
    developers into it to work together or if someone is inheriting your code base.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing HTTP requests against ASP.NET, it goes through a pipeline consisting
    of different middlewares with specific responsibilities. This pipeline is completely
    configurable and extensible by you as a developer. Out of the box, it comes pre-configured
    with a specific middleware that handles the validation of objects sent to a request.
    The validation engine behind this recognizes rules in the form of metadata that
    can be applied to the objects. This metadata again is based on C# attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by changing our **Employee** object a bit. Open the **Employee.cs**
    file and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This makes the **FirstName** and **LastName** properties required by adding
    the **[Required]** attribute to them. The ASP.NET pipeline will pick this up and
    check any input being sent to see if these properties have values.
  prefs: []
  type: TYPE_NORMAL
- en: However, ASP.NET does not decide for you how to treat invalid objects; it just
    populates an object called **ModelState** for you to decide how you want to deal
    with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to deal with something like registering a new employee, we need to have
    an action in our controller that deals with that. Open **EmployeesController**
    and add the **Register** method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice the **ModelState.IsValid** statement. If there are validation rules that
    are not valid, it will return **ValidationProblem** as the result containing the
    errors found in **ModelState**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and open Postman as discussed earlier. In Postman, you
    can create a new request by clicking on the button with the **+** sign on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.1_B19418.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 -Creating a new request in Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a new tab, much like a regular web browser that contains everything
    for the request. Select **POST** as an HTTP verb in the left dropdown of the request,
    then enter the URL for our API. Now you can simply click the **Send** button and
    see the result in the lower part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.2_B19418.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Creating a new tab that contains the request details
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re not really passing it an object, none of the properties are set.
    The errors listed will therefore say that the properties are required.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically hooking up model state handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ASP.NET, everything revolves around what is known as middlewares – small,
    special-purpose code blocks that perform a single task and then hand over to the
    next middleware. Every HTTP request that is handled by ASP.NET has these, and
    even the code that handles the controller is one of these. Every middleware can
    decide whether it should continue to the next middleware or whether it should
    exit with or without an error.
  prefs: []
  type: TYPE_NORMAL
- en: Controller handlers are just one of many formalized middlewares we can tap into.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more details on middlewares here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0)'
  prefs: []
  type: TYPE_NORMAL
- en: If you never want to allow an invalid state to enter your controllers and want
    to get rid of the possibility of developers doing this manually, then there is
    a particular middleware we can put into the pipeline that allows us to stop it
    before we even hit the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET has the concept of an **action filter**. This gets called before the
    controller performs any action and lets us decide whether we want to continue
    with the pipeline or not. You can read more about action filters here: [https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new file called **ValidationFilter.cs** and make it look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This takes over the checking of whether **ModelState** is valid. The line with
    **await next()** is the continuation of the pipeline. So by only calling this
    when things are valid, we avoid getting to the controller if we’re in an invalid
    state. Instead, we then create the same object the ASP.NET pipeline creates when
    calling the **ValidationProblem** method from the controller and return this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then simplify the controller to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code does not need to consider **ModelState** at all and just assumes it
    is taken care of, simplifying the implementation of every controller and making
    it focus on its single purpose of registering an employee. For most controllers,
    this would be fine and, in fact, you’re now removing the possibility of developers
    forgetting to check for validity before doing their business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is to hook it up in the ASP.NET pipeline. Open
    the **Program.cs** file and change the content to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The **.AddControllers()** call takes a delegate that lets us configure **MvcOptions**.
    Within this, we can add our new action filter.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application and verify that you get the exact same result by clicking
    the **Send** button inside postman.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how an existing piece of technology leverages the
    power of the .NET runtime to make it easier for developers using the technology
    to do so. From the use of metadata in the right context, we get to focus on delivering
    business value and don’t have to worry about how it is all configured. It also
    automatically gives us a certain structure to abide by, which in the long run
    will yield a more maintainable, extensible, and predictable code base. By adding
    the action filter as we did, we added what we call a cross-cutting concern, something
    we will revisit in more detail in [*Chapter 13*](B19418_13.xhtml#_idTextAnchor206),
    *Applying* *Cross-Cutting Concerns*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into how frameworks such as ASP.NET are capable
    of doing discovery and automation, and how we can leverage the .NET runtime type
    system to discover types and metadata to achieve something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Leveraging the Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will see how powerful the .NET runtime is and dive into the
    details of its capabilities for metaprogramming. You’ll see the different metaprogramming
    models the runtime provides and get an idea of how they can be leveraged with
    real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using
    Reflection*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19418_06.xhtml#_idTextAnchor098), *Dynamic Proxy Generation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19418_07.xhtml#_idTextAnchor118), *Reasoning about Expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19418_08.xhtml#_idTextAnchor132), *Building and Executing Expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19418_09.xhtml#_idTextAnchor146), *Taking Advantage of the Dynamic
    Language Runtime*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
