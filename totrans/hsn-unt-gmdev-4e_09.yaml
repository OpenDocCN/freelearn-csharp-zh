- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: 'Collisions and Health: Detecting Collisions Accurately'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞与健康：准确检测碰撞
- en: As games try to simulate real-world behaviors, one important aspect of simulating
    is physics, which dictates how objects move and how they collide with each other,
    such as the collision of players and walls or bullets and enemies. Physics can
    be difficult to control due to the myriad of reactions that can happen after a
    collision, so we will learn how to properly configure our game to create physics
    as accurately as we can. This will generate the desired arcade movement feeling
    based on realistic collisions—after all, sometimes, real life is not as interesting
    as video games!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏试图模拟现实世界的表现，模拟的一个重要方面是物理，它决定了物体如何移动以及它们如何相互碰撞，例如玩家与墙壁或子弹与敌人的碰撞。由于碰撞后可能发生的无数反应，物理可能难以控制，因此我们将学习如何正确配置我们的游戏，以尽可能精确地创建物理效果。这将基于现实世界的碰撞生成期望的街机运动感觉——毕竟，有时候，现实生活并不像电子游戏那样有趣！
- en: 'In this chapter, we will examine the following collision concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下碰撞概念：
- en: Configuring physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置物理
- en: Detecting collisions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Moving with physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理移动
- en: First, we will learn how to properly configure physics, a step needed for the
    collisions between objects to be detected by our scripts, using new Unity events
    that we will learn. All of this is needed in order to detect when our bullets
    reach our enemies and damage them. Then, we are going to discuss the difference
    between moving with `Transform`, as we have done so far, and moving with Rigidbody,
    as well as the pros and cons of each of these two methods. We will use these to
    experiment with different ways of moving our player and let you decide which one
    you want to use. Let’s start by discussing the physics settings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何正确配置物理设置，这是为了使我们的脚本能够检测到物体之间的碰撞，我们将学习新的Unity事件。所有这些都需要，以便检测我们的子弹何时到达敌人并对其造成伤害。然后，我们将讨论使用`Transform`移动，这是我们迄今为止所做的方式，以及使用Rigidbody移动之间的区别，以及这两种方法的优缺点。我们将使用这些方法来实验不同的移动玩家方式，并让你决定你想使用哪一种。让我们先从讨论物理设置开始。
- en: Configuring physics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置物理
- en: 'Unity’s physics system is prepared to cover a great range of possible gameplay
    applications, so properly configuring it is important to get the desired result.
    In this section, we will examine the following physics settings concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理系统已经准备好覆盖广泛的可能游戏应用，因此正确配置它对于获得期望的结果非常重要。在本节中，我们将探讨以下物理设置概念：
- en: Setting shapes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置形状
- en: Physics object types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理对象类型
- en: Filtering collisions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞过滤
- en: We are going to start by learning about the different kinds of colliders that
    Unity offers and then learn about different ways to configure those to detect
    different kinds of physics reactions (**collisions** and **triggers**). Finally,
    we will discuss how to ignore collisions between specific objects to prevent situations
    such as the player’s bullets damaging the player.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解Unity提供的不同类型的碰撞体，然后学习如何配置这些碰撞体以检测不同类型的物理反应（**碰撞**和**触发器**）。最后，我们将讨论如何忽略特定对象之间的碰撞，以防止玩家子弹损坏玩家等情况。
- en: Setting shapes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置形状
- en: 'At the beginning of this book, we learned that objects usually have two shapes:
    the visual shape (which is basically the 3D mesh) and the physical one (the collider—the
    one that the physics system will use to calculate collisions). Remember that the
    idea of this is to allow you to have a highly detailed visual model surrounding
    a simplified physics shape to increase performance.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我们了解到物体通常有两种形状：视觉形状（基本上是3D网格）和物理形状（碰撞体——物理系统将使用它来计算碰撞）。请记住，这个想法是允许你围绕简化的物理形状拥有高度详细的可视模型，以提高性能。
- en: 'Unity has several types of colliders, so here, we will recap the common ones,
    starting with the primitive types—that is, **Box**, **Sphere**, and **Capsule**.
    These shapes are the cheapest ones (in terms of performance) to detect collisions
    due to the fact that the collisions between them are done via mathematical formulae,
    unlike other colliders such as the **Mesh Collider**, which allows you to use
    any mesh as the physics body of the object, but with a higher performance cost
    and some limitations. The idea is that you should use a primitive type to represent
    your objects or a combination of them; for example, an airplane could be made
    with two Box colliders, one for the body and the other one for the wings. You
    can find an example of this in the following screenshot, where you can see a weapons
    collider made from primitives:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有多种类型的碰撞体，因此在这里，我们将回顾常见的几种，从原始类型开始——即**盒子**、**球体**和**胶囊体**。这些形状由于碰撞是通过数学公式完成的，因此在检测碰撞方面是最便宜的（从性能角度来看），与其他碰撞体不同，例如**网格碰撞体**，它允许你使用任何网格作为对象的物理体，但性能成本更高，并且有一些限制。想法是应该使用原始类型来表示你的对象或它们的组合；例如，一架飞机可以用两个盒子碰撞体来制作，一个用于机身，另一个用于机翼。你可以在下面的屏幕截图中找到一个例子，其中可以看到由原始形状制成的武器碰撞体：
- en: '![](img/B21361_07_01_PRE_BOOK.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_01_PRE_BOOK.png)'
- en: 'Figure 7.1: Compound colliders'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：复合碰撞体
- en: Anyway, this is not always necessary; if we want a weapon to just fall to the
    ground, maybe a Box collider covering the entire weapon can be enough, considering
    those kinds of collisions don’t need to be accurate, thereby increasing performance.
    Also, some shapes cannot be represented even with a combination of primitive shapes,
    such as ramps or pyramids, where your only solution is to use a Mesh Collider,
    which asks for a 3D mesh to use for collisions. However, we won’t use them in
    this book, given their high-performance impact; we will solve all of our physics
    colliders with primitives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这并不总是必要的；如果我们只想让武器掉到地上，也许一个覆盖整个武器的盒子碰撞体就足够了，考虑到这类碰撞不需要非常精确，从而提高性能。此外，一些形状即使通过原始形状的组合也无法表示，例如斜坡或金字塔，在这种情况下，你唯一的解决方案是使用网格碰撞体，它需要一个3D网格用于碰撞。然而，鉴于它们对性能的高影响，我们不会在本书中使用它们；我们将使用原始形状解决所有物理碰撞体。
- en: Now, let’s add the necessary colliders to our scene to prepare it to calculate
    collisions properly. If you used an Asset Store environment package other than
    mine, you might already have the scene modules with colliders; I will show the
    work I needed to do in my case but try to extrapolate the main ideas here into
    your scene.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加必要的碰撞体到我们的场景中，以便正确地计算碰撞。如果你使用了除了我的以外的Asset Store环境包，你可能已经有了带有碰撞体的场景模块；我将展示我需要做的我的案例，但尝试将主要思想扩展到你的场景中。
- en: 'To add the colliders, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加碰撞体，请按照以下步骤操作：
- en: Select a wall in the base, and check the object and possible child objects for
    collider components; in my case, I have no colliders. If you detect any Mesh Collider,
    you can leave it if you want, but I would suggest you remove it and replace it
    with another option in the next step. The idea is to add the collider to it, but
    the problem I detected here is that, due to the fact my wall is not an instance
    of a Prefab, I need to add a collider to every wall in the scene.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基础中选一个墙，检查对象和可能的子对象是否有碰撞组件；在我的情况下，我没有碰撞体。如果你检测到任何网格碰撞体，你可以保留它，如果你想的话，但我建议你在下一步中将其移除并替换为另一个选项。想法是向其添加碰撞体，但我在这里发现的问题是，由于我的墙不是预制体的实例，我需要为场景中的每个墙添加碰撞体。
- en: 'One option is to create a Prefab and replace all of the walls with instances
    of it (the recommended solution); alternatively, you can just select all walls
    in the Hierarchy (by clicking them while pressing *Ctrl* or *command* on a Mac)
    and with them selected, use the **Add Component** button to add a collider to
    all of them. In my case, I will use the `Box Collider` component, which will adapt
    the size of the collider to the mesh. If it doesn’t adapt, you can just change
    the **Size** and **Center** properties of the **Box Collider** components to cover
    the entire wall:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个选项是创建一个预制体，并用它的实例替换所有墙壁（推荐解决方案）；或者，你可以只选择层次结构中的所有墙壁（通过在Mac上按住*Ctrl*或*command*键的同时点击它们）并选择它们，然后使用**添加组件**按钮为它们添加碰撞体。在我的情况下，我将使用`Box
    Collider`组件，它将调整碰撞体的尺寸以适应网格。如果它不适应，你只需更改**盒子碰撞体**组件的**大小**和**中心**属性，以覆盖整个墙壁：
- en: '![](img/B21361_07_02_PRE_BOOK.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_02_PRE_BOOK.png)'
- en: 'Figure 7.2: A Box Collider added to a wall'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：添加到墙上的盒子碰撞体
- en: Repeat *steps 1* and *2* for the corners, floor tiles, and any other obstacle
    that will block player and enemy movement.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1*和*步骤2*，为角落、地板砖和任何其他会阻挡玩家和敌人移动的障碍物。
- en: Now that we have added the needed colliders to the walls and floor, we can continue
    with the player and enemy. We will be adding the **Capsule Collider** to them,
    the usual collider to use in movable characters, due to the fact that the rounded
    bottom will allow the object to smoothly climb ramps. Being horizontally rounded
    allows the object to easily rotate in corners without getting stuck, along with
    other conveniences of that shape.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为墙壁和地板添加了所需的碰撞器，我们可以继续处理玩家和敌人。我们将为它们添加**胶囊碰撞器**，这是在可移动角色中使用的常用碰撞器，因为圆形底部将允许对象平滑地爬坡。水平圆形允许对象在角落中轻松旋转而不会卡住，以及其他该形状的便利性。
- en: You might want to create an enemy Prefab based on one of the characters we downloaded
    before, so you can add the collider to that Prefab. Our player is a simple GameObject
    in the scene, so you will need to add the collider to that one but do consider
    creating a Prefab for the player for convenience.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要基于我们之前下载的角色之一创建一个敌人Prefab，这样您就可以将碰撞器添加到该Prefab上。我们的玩家是场景中的一个简单GameObject，所以您需要将碰撞器添加到该GameObject上，但请考虑为玩家创建一个Prefab以方便操作。
- en: You may be tempted to add several Box colliders to the bones of the character
    to create a realistic shape of the object. While we can use this approach to vary
    the damage based on where enemies were shot on their bodies, note that we are
    primarily creating movement colliders, and using a Capsule collider is sufficient
    for this purpose. In advanced damage systems, both capsule and Bone colliders
    will coexist, one for movement and the other for damage detection, but we will
    simplify this in our game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为角色的骨骼添加多个盒子碰撞器以创建对象的逼真形状。虽然我们可以使用这种方法根据敌人身体被射击的位置来改变伤害，但请注意，我们主要是在创建运动碰撞器，使用胶囊碰撞器就足够了。在高级伤害系统中，胶囊和骨骼碰撞器将共存，一个用于运动，另一个用于伤害检测，但我们将简化我们的游戏。
- en: 'Also, sometimes, the collider won’t adapt well to the visual shape of the object,
    and in my case, the Capsule collider didn’t fit the character very well. I needed
    to fix its shape to match the character by setting its values as shown in the
    following screenshot: **Center** to `0,1,0,` **Radius** to `0.5`, and **Height**
    to `2`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时碰撞器不会很好地适应对象的视觉形状，在我的情况下，胶囊碰撞器与角色不太匹配。我需要通过设置以下截图中的值来修复其形状以匹配角色：**中心**到`0,1,0,`
    **半径**到`0.5`，和**高度**到`2`：
- en: '![](img/B21361_07_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_03.png)'
- en: 'Figure 7.3: Character collider'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：角色碰撞器
- en: The bullet we created with the Sphere already had a Sphere collider, but if
    you replaced the mesh of the bullet with another one, you might want to change
    the collider. For the time being, we don’t need other objects in our game, so
    now that everything has its proper collider, let’s see how to set the different
    physics settings to each object to enable proper collision detection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用球体创建的子弹已经有一个球体碰撞器，但如果您用另一个网格替换子弹的网格，您可能想要更改碰撞器。目前，我们游戏中不需要其他对象，所以现在所有对象都有了合适的碰撞器，让我们看看如何为每个对象设置不同的物理设置以启用适当的碰撞检测。
- en: If you check the Terrain’s components, you will see that it has its own kind
    of collider, the **Terrain collider**. For Terrains, that’s the only collider
    to use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查地形组件，您会看到它有自己的碰撞器类型，即**地形碰撞器**。对于地形，这是唯一要使用的碰撞器。
- en: Physics object types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理对象类型
- en: 'Now that we have added colliders to every object by making the objects have
    a presence in the physics simulation, it is time to configure them to have the
    exact physics behavior we want. We have a myriad of possible combinations of settings,
    but we will discuss a set of common profiles that cover most situations. Remember,
    besides colliders, we saw the Rigidbody component at the beginning of this book,
    which is the one that applies physics to the object. The following profiles are
    created with a combination of colliders and Rigidbody settings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过使对象在物理模拟中具有存在感为每个对象添加了碰撞器，是时候配置它们以具有我们想要的精确物理行为。我们有无数可能的设置组合，但我们将讨论一组常见的配置文件，这些配置文件涵盖了大多数情况。记住，除了碰撞器之外，我们在本书的开头看到了Rigidbody组件，这是将物理应用于对象的一个组件。以下配置文件是通过组合碰撞器和Rigidbody设置创建的：
- en: '**Static Collider**: As the name suggests, this kind of collider is not supposed
    to move, aside from some specific exceptions. Most of the environment objects
    fall into this category, such as walls, floors, obstacles, and terrain. These
    kinds of colliders are just colliders with no `Rigidbody` component, so they have
    a presence in the physics simulation but don’t have any physics applied to them;
    they cannot be moved by other objects’ collisions, they won’t have physics, and
    they will be fixed in their position no matter what. Take into account that this
    has nothing to do with the **Static** checkbox at the top-right part of the editor;
    that is for systems that we will explore later in several chapters (such as *Chapter
    12*, *Enlightening Worlds: Illuminating Scenes with the Universal Render Pipeline*),
    so you can have a Static Collider with that checkbox unchecked if needed.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态碰撞体**: 如其名所示，这种碰撞体不应该移动，除了某些特定的例外。大多数环境对象都属于这一类别，例如墙壁、地板、障碍物和地形。这类碰撞体只是没有`Rigidbody`组件的碰撞体，因此它们存在于物理模拟中，但不会对它们应用任何物理效果；它们不能被其他对象的碰撞移动，它们不会有物理效果，并且无论发生什么情况，它们都将固定在其位置。请注意，这与编辑器右上角的**静态**复选框无关；那个是为我们将在几章中探讨的系统准备的（例如*第12章*，*启迪世界：使用通用渲染管道照亮场景*），因此如果需要，你可以有一个未勾选该复选框的静态碰撞体。'
- en: '**Physics Collider**: These are colliders with a `Rigidbody` component, like
    the example of the falling ball we created in the first part of this book. These
    are fully physics-driven objects that have gravity and can be moved through forces;
    other objects can push them, and they perform every other physics reaction you
    can expect. You can use this for the player, grenade movement, falling crates,
    or all objects in heavily physics-based games, such as *The Incredible Machine*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理碰撞体**: 这些是具有`Rigidbody`组件的碰撞体，就像我们在本书第一部分创建的掉落球体的例子。这些是完全由物理驱动的对象，具有重力并且可以通过力移动；其他对象可以推动它们，并且它们会执行你所能预期的所有其他物理反应。你可以用这个来处理玩家、手榴弹移动、掉落的箱子，或者所有在基于物理的游戏中的对象，例如*不可思议的机器*。'
- en: '**Kinematic Collider**: These are colliders that have a `Rigidbody` component
    but have the **Is Kinematic** checkbox checked. These don’t have physics reactions
    to collisions and forces like **Static Colliders**, but they are expected to move,
    allowing **Physics Colliders** to handle collisions against them properly when
    moving. These can be used in objects that need to move using animations or custom
    scripting movements, such as moving platforms.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动学碰撞体**: 这些是具有`Rigidbody`组件但勾选了**是运动学**复选框的碰撞体。它们对碰撞和力的物理反应与**静态碰撞体**不同，但预期会移动，允许**物理碰撞体**在移动时正确处理与它们的碰撞。这些可以用于需要使用动画或自定义脚本移动的对象，例如移动平台。'
- en: '**Trigger Static Collider**: This is a regular Static Collider but with the
    **Is Trigger** checkbox of the collider checked. The difference is that when kinematic
    and physics objects pass through it, a `Trigger` event is automatically generated;
    this can be captured via scripting, which allows us to detect when something is
    inside the collider. This event can be used to create buttons or trigger objects
    in areas of the game when the player passes through something happening, such
    as a wave of enemies being spawned, a door being opened, or winning the game if
    that area is the goal of the player. Note that regular Static Colliders won’t
    generate a trigger event when passing through this type because those aren’t supposed
    to move.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发静态碰撞体**: 这是一个普通的静态碰撞体，但勾选了碰撞体的**是触发**复选框。区别在于，当运动学和物理对象通过它时，会自动生成一个`Trigger`事件；这可以通过脚本捕获，这允许我们检测是否有东西在碰撞体内部。这个事件可以用来在玩家通过发生某些事情的区域时创建按钮或触发对象，例如敌人波生成、门打开，或者如果该区域是玩家的目标，则赢得游戏。请注意，普通的静态碰撞体在通过这种类型时不会生成触发事件，因为它们不应该移动。'
- en: '**Trigger Kinematic Collider**: Kinematic Colliders don’t generate collisions,
    so they will pass through any other object, but they will generate `Trigger` events,
    so we can react via scripting. This can be used to create moveable power-ups that,
    when touched, disappear and give us points, or bullets that move with custom scripting
    movements and no physics, just straight like our bullets, but damage other objects
    when they touch them.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发运动学碰撞体**: 运动学碰撞体不会生成碰撞，因此它们会穿过任何其他对象，但它们会生成`Trigger`事件，因此我们可以通过脚本进行响应。这可以用来创建可移动的奖励物品，当接触时消失并给我们加分，或者子弹以自定义脚本移动，没有物理效果，就像我们的子弹一样，但它们接触其他对象时会造成伤害。'
- en: Of course, other profiles can exist aside from the specified ones to use in
    some games with specific gameplay requirements, but it’s down to you to experiment
    with all possible combinations of physics settings to see whether they are useful
    for your case; the described profiles will cover 99% of cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了指定的配置文件外，还可以存在其他配置文件，用于满足某些游戏的具体游戏玩法要求，但实验所有可能的物理设置组合是否适用于你的情况取决于你；所描述的配置文件将涵盖99%的情况。
- en: 'To recap the previous scenarios, check out the following table showing the
    reaction of contact between all the types of colliders. You will find a row per
    each profile that can move; remember that static profiles aren’t supposed to move.
    Each column represents the reaction when they collide with the other types: `Nothing`
    means the object will pass through with no effect, `Trigger` means the object
    will pass through but raise `Trigger` events, and `Collision` means the first
    object won’t be able to pass through the second object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾之前的场景，请查看以下表格，显示所有类型碰撞器的接触反应。你将找到每个可以移动的配置文件的一行；请记住，静态配置文件不应该移动。每一列代表它们与其他类型碰撞时的反应：“无”表示对象将无效果地穿过，而“触发”表示对象将穿过但会引发“触发”事件，“碰撞”表示第一个对象无法穿过第二个对象：
- en: '|  | **Collides with Static** | **Collides with Dynamic** | **Collides with
    Kinematic** | **Collides with Trigger Static** | **Collides with Trigger Kinematic**
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  | **与静态碰撞** | **与动态碰撞** | **与动力学碰撞** | **与触发静态碰撞** | **与触发动力学碰撞** |'
- en: '| Dynamic | Collision | Collision | Collision | Trigger | Trigger |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 动态 | 碰撞 | 碰撞 | 碰撞 | 触发 | 触发 |'
- en: '| Kinematic | Nothing | Collision | Nothing | Trigger | Trigger |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 动力学 | 无 | 碰撞 | 无 | 触发 | 触发 |'
- en: '| Trigger Kinematic | Trigger | Trigger | Trigger | Trigger | Trigger |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 触发动力学 | 触发 | 触发 | 触发 | 触发 | 触发 |'
- en: 'Table 7.01: Collision Reaction Matrix'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.01：碰撞反应矩阵
- en: Considering this, let’s start configuring the physics of our scene’s objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们开始配置场景对象的物理属性。
- en: 'The walls, corners, floor tiles, and obstacles should use the Static Collider
    profile, so there is no `Rigidbody` component on them, and their colliders will
    have the **Is Trigger** checkbox unchecked:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 墙壁、角落、地板砖和障碍物应使用静态碰撞器配置文件，因此它们上没有`Rigidbody`组件，并且它们的碰撞器将不会勾选**是触发**复选框：
- en: '![](img/B21361_07_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_04.png)'
- en: 'Figure 7.4: Configuration for floor tiles; remember that the Static checkbox
    is for lighting only'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：地板砖的配置；请记住，静态复选框仅用于照明
- en: 'The player should move and generate collisions against objects, so we need
    the player to have a **Dynamic** profile. This profile will generate funny behavior
    with our current movement script (which I encourage you to test), especially when
    colliding against walls, so it won’t behave as you expected. We will deal with
    this later in this chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该移动并与其他物体产生碰撞，因此我们需要玩家拥有一个**动态**配置文件。这个配置文件将与我们当前的移动脚本（我鼓励你测试）产生有趣的行为，尤其是在与墙壁碰撞时，它不会像你预期的那样表现。我们将在本章后面处理这个问题：
- en: '![](img/B21361_07_05_PRE_BOOK.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_05_PRE_BOOK.png)'
- en: 'Figure 7.5: Dynamic settings on the player'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：玩家上的动态设置
- en: 'The `Enemy` Prefab we suggested you create previously will use the Kinematic
    profile because we will move this object with Unity’s AI systems later in the
    book, so we don’t need physics here. Also, as we want the player to collide with
    the Enemy Prefab objects, we need a collision reaction here, so there’s no `Trigger`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前建议你创建的`Enemy`预制件将使用动力学配置文件，因为我们将在本书后面使用Unity的AI系统移动这个对象，所以这里不需要物理。此外，由于我们希望玩家与`Enemy`预制件对象发生碰撞，我们需要在这里设置碰撞反应，因此没有`触发`：
- en: '![](img/B21361_07_06.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_06.png)'
- en: 'Figure 7.6: Kinematic settings for the enemy'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：敌人的动力学设置
- en: 'The `Bullet` Prefab moves with simplistic movement via scripting (it just moves
    forward) and not physics. We don’t need collisions here; we will code the bullet
    to destroy itself as soon as it touches something and will damage the collided
    object (if possible), so a Kinematic Trigger profile is enough for this one. We
    will use the `Trigger` event to script the contact reactions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`预制件通过脚本进行简单的移动（它只是向前移动）而不是物理移动。这里我们不需要碰撞；我们将编写代码，使子弹在接触任何东西时立即销毁，并尽可能损坏碰撞的对象，因此动力学触发配置文件就足够了。我们将使用`触发`事件来编写接触反应的脚本：'
- en: '![](img/B21361_07_07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_07.png)'
- en: 'Figure 7.7: The Kinematic Trigger settings for our bullet, Is Trigger and Is
    Kinematic, are checked'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：子弹的动力学触发设置，已勾选“是触发”和“是动力学”
- en: Now that we have properly configured the objects let’s check how to filter undesired
    collisions between certain object types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置了对象，让我们来看看如何过滤某些对象类型之间的不希望发生的碰撞。
- en: Filtering collisions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞过滤
- en: Sometimes, we want certain objects to ignore each other, like the bullets shot
    by the player, which shouldn’t collide with the player itself. We can always filter
    that with an `if` statement in the C# script, checking whether the hit object
    is from the opposite team or whatever filtering logic you want, but by then, it
    is too late; the physics system wasted resources by checking a collision between
    objects that were never meant to collide. Here is where the Layer Collision Matrix
    can help us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望某些对象相互忽略，例如玩家射出的子弹，它不应该与玩家本身碰撞。我们总是可以通过C#脚本中的`if`语句来过滤它，检查被击中的对象是否来自敌方或任何过滤逻辑，但那时已经太晚了；物理系统浪费了资源，检查了本不应该碰撞的对象之间的碰撞。这就是图层碰撞矩阵能帮到我们的地方。
- en: The **Layer Collision Matrix** sounds scary, but it is a simple setting of the
    physics system that allows us to specify which groups of objects should collide
    with other groups. For example, the player’s bullets should collide with enemies,
    and enemy bullets should collide with the player. In this case, the enemies’ bullets
    will pass through enemies, but this is desirable in our case. The idea is to create
    groups and put our objects inside them; in Unity, these groups are called **layers**.
    We can create layers and set the layer property of the GameObject (the top part
    of the **Inspector**) to assign the object to that group or layer. Note that you
    have a limited number of layers, so try to use them wisely.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**图层碰撞矩阵**听起来很吓人，但它只是物理系统的一个简单设置，允许我们指定哪些对象组应该与其他组发生碰撞。例如，玩家的子弹应该与敌人碰撞，敌人的子弹应该与玩家碰撞。在这种情况下，敌人的子弹会穿过敌人，但这种情况在我们的案例中是可取的。我们的想法是创建组并将我们的对象放入其中；在Unity中，这些组被称为**图层**。我们可以创建图层，并将GameObject（**检查器**的顶部部分）的图层属性设置为将对象分配到该组或图层。请注意，您有有限的图层数量，因此请尽量明智地使用它们。'
- en: 'We can achieve this by doing the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式实现：
- en: 'Go to **Edit | Project Settings**, and inside it, look for the **Tags and Layers**
    option from the left pane:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑 | 项目设置**，然后在其中，从左侧面板查找**标签和图层**选项：
- en: '![](img/B21361_07_08_PRE_BOOK.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_08_PRE_BOOK.png)'
- en: 'Figure 7.8: The Tags and Layers settings'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：标签和图层设置
- en: 'From the **Layers** section, fill the empty spaces to create layers. We will
    use this for the bullet scenario, so we need four layers: `Player`, `Enemy`, `PlayerBullet`,
    and `EnemyBullet`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图层**部分，填写空白区域以创建图层。我们将使用此功能处理子弹场景，因此我们需要四个图层：`Player`、`Enemy`、`PlayerBullet`和`EnemyBullet`：
- en: '![](img/B21361_07_09_PRE_BOOK.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_09_PRE_BOOK.png)'
- en: 'Figure 7.9: Creating layers'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：创建图层
- en: 'Select the `Player` GameObject in the Hierarchy, and from the top part of the
    Inspector, change the **Layer** property to `Player`. Also, change the `Enemy`
    Prefab to have the `Enemy` layer. A window will appear, asking you whether you
    want to also change the child objects; select **Yes**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`Player`GameObject，然后从检查器的顶部部分更改**图层**属性为`Player`。同时，将`Enemy`Prefab的图层更改为`Enemy`。会出现一个窗口，询问您是否想同时更改子对象；选择**是**：
- en: '![](img/B21361_07_10_PRE_BOOK.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_10_PRE_BOOK.png)'
- en: 'Figure 7.10: Changing the layers of the player and the enemy Prefab'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：更改玩家和敌人Prefab的图层
- en: 'In the case of the bullet, we have a problem; we have one Prefab but two layers,
    and a Prefab can only have one layer. We have two options: changing the layer
    according to the shooter via scripting or creating two `bullet` Prefabs with different
    layers. For simplicity, I will choose the latter, also taking the chance to apply
    another material to the enemy bullet to make it look different.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子弹的情况下，我们有一个问题；我们有一个Prefab但有两个图层，而Prefab只能有一个图层。我们有两种选择：通过脚本根据射击者更改图层或创建两个具有不同图层的`bullet`Prefab。为了简单起见，我将选择后者，并借此机会将另一种材质应用到敌人子弹上，使其看起来不同。
- en: We will create a Prefab **Variant** of the player bullet. Remember that a Variant
    is a Prefab that is based on an original one, like class inheritance. When the
    original Prefab changes, the Variant will change, but the Variant can have differences,
    which will make it unique.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为玩家子弹创建一个Prefab **变体**。请记住，变体是基于原始Prefab的Prefab，就像类继承一样。当原始Prefab发生变化时，变体也会变化，但变体可以有不同的差异，这将使其独特。
- en: Drop a bullet Prefab into the scene to create an instance.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子弹Prefab拖放到场景中创建一个实例。
- en: Drag the instance again to the `Prefabs` folder, this time selecting the **Prefab**
    **Variant** option in the window that will appear.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将实例拖动到`Prefabs`文件夹中，这次在出现的窗口中选择**Prefab** **Variant**选项。
- en: Rename it `Enemy Bullet`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`Enemy Bullet`。
- en: Destroy the Prefab instance in the scene.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中销毁预制体实例。
- en: Create a second material similar to the player bullet with a different color,
    and put it on the enemy bullet Prefab Variant.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于玩家子弹的第二种材料，颜色不同，并将其放在敌人子弹预制体变体上。
- en: Select the enemy bullet Prefab, set its layer to `EnemyBullet`, and do the same
    for the original Prefab (`PlayerBullet`). Even if you changed the original Prefab
    layer, as the Variant modified it, the modified version (or override) will prevail,
    allowing each Prefab to have its own layer.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择敌人子弹预制体，将其层设置为`EnemyBullet`，并对原始预制体（`PlayerBullet`）执行相同的操作。即使你更改了原始预制体的层，由于变体修改了它，修改后的版本（或覆盖）将占优，允许每个预制体有自己的层。
- en: 'Now that we have configured the layers, let’s configure the physics system
    to use them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了层，让我们配置物理系统以使用它们：
- en: Go to **Edit | Project Settings** and look for the **Physics** settings (not
    **Physics 2D**).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑** | **项目设置**并查找**物理**设置（不是**物理2D**）。
- en: 'Scroll down until you see the **Layer Collision Matrix**, a half grid of checkboxes.
    You will notice that each column and row is labeled with the names of the layers,
    so each checkbox in the cross of a row and column will allow us to specify whether
    these two should collide. In our case, we configured the Layer Collision Matrix
    as shown in the following screenshot so that player bullets do not hit the player
    or other player bullets, and enemy bullets do not hit enemies or other enemy bullets:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动直到您看到**层碰撞矩阵**，一个半网格的复选框。您会注意到每一列和行都标有层的名称，因此每一行和列交叉处的每个复选框都将允许我们指定这两个是否应该碰撞。在我们的情况下，我们配置了层碰撞矩阵，如以下截图所示，以便玩家子弹不会击中玩家或其他玩家子弹，敌人子弹不会击中敌人或其他敌人子弹：
- en: '![](img/B21361_07_11_PRE_BOOK.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_11_PRE_BOOK.png)'
- en: 'Figure 7.11: Making player bullets collide with enemies and enemy bullets collide
    with the player'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：使玩家子弹与敌人碰撞，以及敌人子弹与玩家碰撞
- en: It is worth noting that, sometimes, filtering logic won’t be that rigid or predictable.
    For example, it might involve only hit objects that have a certain amount of life,
    objects that don’t have an invisibility temporal buff or conditions that can change
    during the game and are difficult to generate for all possible layers for all
    possible groups. So, in these cases, we should rely on manual filtering after
    the **Trigger** or **Collision** event.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时过滤逻辑可能不会那么严格或可预测。例如，它可能只涉及具有一定生命值的击中对象，没有隐形时间增益的对象，或者可以在游戏过程中改变的条件，并且难以为所有可能的层和组生成。因此，在这些情况下，我们应该在**触发**或**碰撞**事件之后依赖手动过滤。
- en: Now that we have filtered collisions, let’s check whether our settings are working
    properly by reacting to collisions in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经过滤了碰撞，让我们通过下一节中的碰撞来检查我们的设置是否正常工作。
- en: Detecting collisions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: As you can see, proper physics settings can be complicated and very important,
    but now that we have tackled that, let’s perform some tasks with those settings
    by reacting to the contact in different ways, creating a **health system** in
    the process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，适当的物理设置可能很复杂且非常重要，但既然我们已经解决了这个问题，让我们通过以不同的方式对接触做出反应来执行一些任务，在这个过程中创建一个**健康系统**。
- en: 'In this section, we will examine the following collision concepts:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下碰撞概念：
- en: Detecting Trigger events
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测触发事件
- en: Modifying the other object
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改其他对象
- en: First, we are going to explore the different collision and trigger events Unity
    offers us to react to contact between two objects, through Unity **collision**
    events. This allows us to execute any reaction code we want to place, but here,
    we are going to explore how to modify the contacted object components using the
    `GetComponent` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨Unity为我们提供的不同碰撞和触发事件，以便对两个对象之间的接触做出反应，通过Unity **碰撞**事件。这允许我们执行我们想要放置的任何反应代码，但在这里，我们将探讨如何使用`GetComponent`函数修改接触到的对象组件。
- en: Detecting Trigger events
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测触发事件
- en: 'If objects are properly configured, as previously discussed, we can get two
    reactions: collisions or triggers. The **Collision** reaction has a default effect
    that blocks the movement of the objects, but we can add custom behavior on top
    of that using scripting; however, with a **Trigger**, unless we add custom behavior,
    it won’t produce any noticeable effect. Either way, we can script reactions to
    both possible scenarios, such as adding a score, reducing health, and losing the
    game. To do so, we can use the suite of **Physics events**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象配置得当，如前所述，我们可以得到两种反应：碰撞或触发。**碰撞**反应有一个默认效果，可以阻止对象的移动，但我们可以通过脚本添加自定义行为；然而，使用**触发器**，除非我们添加自定义行为，否则它不会产生任何明显的效果。无论如何，我们可以为两种可能的场景编写脚本，例如添加分数、减少生命值和输掉游戏。为此，我们可以使用**物理事件**套件。
- en: These events are split into two groups, **Collision events** and **Trigger events**,
    so according to your object setting, you will need to pick the appropriate group.
    Both groups have three main events, **Enter**, **Stay**, and **Exit**, telling
    us when a collision or trigger began (*Enter*), whether it is still happening
    or still in contact (*Stay*), and when it stopped contacting (*Exit*). For example,
    we can script a behavior such as playing a sound when two objects first make contact
    in the Enter event, such as a friction sound, and stop it when the contact ends
    in the Exit event.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件分为两组，**碰撞事件**和**触发事件**，因此根据你的对象设置，你需要选择适当的组。两组都有三个主要事件，**进入**、**持续**和**退出**，告诉我们碰撞或触发何时开始（*进入*），是否仍在发生或仍在接触（*持续*），以及何时停止接触（*退出*）。例如，我们可以在进入事件中编写一个行为，例如在两个物体首次接触时播放声音，如摩擦声，并在退出事件中停止播放。
- en: 'Let’s test this by creating our first contact behavior: the bullet being destroyed
    when coming into contact with something. Remember that the bullets are configured
    to be triggers, so they will generate `Trigger` events on contact with anything.
    You can do this with the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建我们的第一个接触行为来测试这个：子弹在接触物体时被销毁。记住，子弹被配置为触发器，因此它们在与任何物体接触时将生成`触发器`事件。你可以按照以下步骤操作：
- en: Create and add a script called `ContactDestroyer` on the **Player Bullet** Prefab;
    as the **Enemy Bullet** Prefab is a Variant of it, it will also have the same
    script.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**玩家子弹**预制件上创建并添加一个名为 `ContactDestroyer` 的脚本；由于**敌人子弹**预制件是其变体，它也将拥有相同的脚本。
- en: To detect when a trigger happens, such as with **Start** and **Update**, create
    an event function named `OnTriggerEnter`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检测触发器何时发生，例如使用**开始**和**更新**，创建一个名为 `OnTriggerEnter` 的事件函数。
- en: 'Inside the event, use the `Destroy(gameObject);` line to make the bullet destroy
    itself when touching something:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件内部，使用 `Destroy(gameObject);` 行来使子弹在接触物体时销毁自身：
- en: '![](img/B21361_07_12_PRE_BOOK.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_12_PRE_BOOK.png)'
- en: 'Figure 7.12: Auto-destroying on contact with something'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：与物体接触时自动销毁
- en: Save the script, and shoot the bullets against the walls to see how they disappear
    instead of passing through them. Here, we don’t have a collision but a trigger
    that destroys the bullet on contact. This way, we are sure that the bullet will
    never pass through anything, but we are still not implementing a physics-based
    movement.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并将子弹射向墙壁以观察它们是如何消失而不是穿过墙壁的。在这里，我们不是处理碰撞，而是一个触发器，它在接触时销毁子弹。这样，我们可以确保子弹永远不会穿过任何东西，但我们还没有实现基于物理的运动。
- en: After enabling these components, for now, we won’t need the other Collision
    events, but if you need them, they will work similarly; just create a function
    called `OnCollisionEnter` instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用这些组件之后，目前我们不需要其他碰撞事件，但如果你需要它们，它们的工作方式将类似；只需创建一个名为 `OnCollisionEnter` 的函数即可。
- en: 'Now, let’s explore another version of the same function. We’ll configure it
    to not only tell us that we hit something but also what we came into contact with.
    We will use this to make our **Contact Destroyer** also destroy the other object.
    To do this, follow these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索同一函数的另一个版本。我们将配置它，不仅告诉我们我们击中了什么，而且还告诉我们我们接触了什么。我们将使用这个来使我们的**接触销毁器**也销毁其他对象。为此，请按照以下步骤操作：
- en: 'Replace the `OnTriggerEnter` method signature with the one in the following
    screenshot. This one receives a parameter of the `Collider` type, indicating the
    exact collider that hit us:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OnTriggerEnter` 方法签名替换为以下截图中的那个。这个方法接收一个 `Collider` 类型的参数，表示撞击我们的确切碰撞体：
- en: '![](img/B21361_07_13_PRE_BOOK.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_13_PRE_BOOK.png)'
- en: 'Figure 7.14: Version of the trigger event that tells us which object we collided
    with'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：告诉我们我们碰撞了哪个对象的触发事件版本
- en: 'We can access the GameObject of that collider using the `gameObject` property.
    We can use this to destroy the other one as well, as shown in the following screenshot.
    If we just use the `Destroy` function by passing the `other` variable, it will
    only destroy the `Collider` component:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`gameObject`属性访问那个collider的GameObject。我们可以使用这个来摧毁另一个对象，如下面的截图所示。如果我们只是通过传递`other`变量来使用`Destroy`函数，它将只会摧毁`Collider`组件：
- en: '![](img/B21361_07_14_PRE_BOOK.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_07_14_PRE_BOOK.png)'
- en: 'Figure 7.14: Destroying both objects'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：摧毁两个对象
- en: Save and test the script. You will notice that the bullet will destroy everything
    it touches. Remember to verify that your enemy has a Capsule collider for the
    bullet to detect collisions against it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并测试脚本。你会注意到子弹会摧毁它接触到的所有东西。记得验证你的敌人有一个胶囊碰撞器，这样子弹才能检测到与之的碰撞。
- en: 'The equivalent version in visual scripting would be like the following figure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视化脚本中的等效版本如下所示：
- en: '![](img/B21361_07_15_PRE_BOOK.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_07_15_PRE_BOOK.png)'
- en: 'Figure 7.15: Destroying both objects with Visual Scripting'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：使用可视化脚本摧毁两个对象
- en: 'As you can see, we created an **On Trigger Enter** node and chained it to two
    **Destroy** nodes. To specify which object each **Destroy** node will destroy,
    we used the **Component: Get GameObject** node twice. The right one was created
    with no node connected to its left input pin, which means it will return the GameObject
    that currently executes this script (hence, the **This** label in the node left
    pin), in this case, the bullet. For the second one, we needed to connect the **Collider**
    output pin at the right of the **OnTriggerEnter** node to the **Get GameObject**
    node; this way, we specify that we want to obtain the GameObject that contains
    the collider our bullet collided with.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，我们创建了一个**On Trigger Enter**节点并将其连接到两个**Destroy**节点。为了指定每个**Destroy**节点将摧毁哪个对象，我们使用了**Component:
    Get GameObject**节点两次。右边的一个没有节点连接到其左侧输入引脚，这意味着它将返回当前执行此脚本的GameObject（因此，节点左侧的**This**标签），在这种情况下，子弹。对于第二个，我们需要将**OnTriggerEnter**节点右侧的**Collider**输出引脚连接到**Get
    GameObject**节点；这样，我们指定我们想要获取子弹碰撞到的包含collider的GameObject。'
- en: Now, in our game, we don’t want the bullet to destroy everything on contact;
    instead, we will make the enemies and the player have a life amount; the bullets
    will reduce that life amount until it reaches 0, so let’s find out how to do that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的游戏中，我们不希望子弹在接触时摧毁一切；相反，我们将让敌人和玩家拥有生命值；子弹将减少生命值，直到它达到0，所以让我们找出如何做到这一点。
- en: Modifying the other object
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改其他对象
- en: For the bullet to damage the collided object, we will need to access a `Life`
    component to change its amount, so we will need to create this `Life` component
    to hold a float field with the amount of life. Every object with this component
    will be considered a damageable object. To access the `Life` component from our
    bullet scripts, we will need the `GetComponent` function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让子弹损坏碰撞的对象，我们需要访问一个`Life`组件来更改其数量，所以我们需要创建这个`Life`组件来保存一个包含生命值的浮点字段。具有此组件的每个对象都将被视为可损坏的对象。要从我们的子弹脚本中访问`Life`组件，我们需要`GetComponent`函数。
- en: 'If you have a reference to a GameObject or component, you can use `GetComponent`
    to access a specific component if the object contains it (if not, it will return
    `null`). Let’s see how to use that function to make the bullet lower the amount
    of life of the other object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个GameObject或组件的引用，你可以使用`GetComponent`来访问对象中包含的特定组件（如果没有，它将返回`null`）。让我们看看如何使用这个函数来使子弹减少其他对象的生命值：
- en: 'Create and add a `Life` component with a `public float` field, called `amount`,
    to both the player and enemy Prefabs. Remember to set the value as `100` (or whatever
    life amount you want to give them) in the **Amount** field for both in the Inspector:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为玩家和敌人Prefab创建并添加一个带有`public float`字段的`Life`组件，称为`amount`。记得在检查器中为两者设置值为`100`（或你想要给他们的任何生命值）：
- en: '![](img/B21361_07_16_PRE_BOOK.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_07_16_PRE_BOOK.png)'
- en: 'Figure 7.17: The Life component'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：生命组件
- en: Remove the `ContactDestroyer` component from the player bullet, which will also
    remove it from the **Enemy Bullet Variant**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从玩家子弹中移除`ContactDestroyer`组件，这也会将其从**Enemy Bullet Variant**中移除。
- en: Add a new script called `ContactDamager` to both the enemy and the player.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为敌人和玩家添加一个新的脚本名为`ContactDamager`。
- en: Add an `OnTriggerEnter` event that receives the `other` collider as a parameter,
    and just add the `Destroy` function call that auto-destroys itself, not the one
    that destroys the other object; our script won’t be responsible for destroying
    it, just reducing its life.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个接收`other`碰撞器作为参数的`OnTriggerEnter`事件，并仅添加自动销毁自己的`Destroy`函数调用，而不是销毁其他对象的那个；我们的脚本不会负责销毁它，只是减少其生命值。
- en: Add a float field called `damage` so that we can configure the amount of damage
    to inflict on the other object. Remember to save the file and set a value before
    continuing.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`damage`的浮点字段，以便我们可以配置对其他对象造成的伤害量。记住在继续之前保存文件并设置一个值。
- en: 'Use `GetComponent` on the reference to the other collider to get a reference
    to its `Life` component and save it in a variable:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetComponent`在另一个碰撞器的引用上获取其`Life`组件的引用，并将其保存在一个变量中：
- en: '![](img/B21361_07_17_PRE_BOOK.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_17_PRE_BOOK.png)'
- en: 'Figure 7.18: Accessing the collided object’s Life component'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：访问碰撞对象的Life组件
- en: Before reducing the life of the object, we must check that the `Life` reference
    isn’t `null`, which would happen if the other object didn’t have the `Life` component,
    as in the case of walls and obstacles. The idea is that the bullet will destroy
    itself when anything collides with it and reduce the life of the other object
    if it is a damageable object that contains the `Life` component.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在减少对象的寿命之前，我们必须检查`Life`引用不是`null`，这会在其他对象没有`Life`组件的情况下发生，例如墙壁和障碍物。想法是子弹在遇到任何东西时都会销毁自己，如果它是包含`Life`组件的可伤害对象，则会减少其他对象的生命值。
- en: 'In the following screenshot, you will find the full script:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您将找到完整的脚本：
- en: '![](img/B21361_07_18_PRE_BOOK.png)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_18_PRE_BOOK.png)'
- en: 'Figure 7.18: Reducing the life of the collided object'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.18：减少碰撞对象的寿命
- en: Place an enemy in the scene and set its speed to `0` to prevent it from moving.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中放置一个敌人，并将其速度设置为`0`以防止其移动。
- en: Select it in the Hierarchy before hitting **Play**, and start shooting at it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按**播放**之前在层次结构中选择它，并开始向它射击。
- en: You can see how the life value reduces in the Inspector. You can also press
    the *Esc* key to regain control of the mouse and select the object while in **Play**
    mode, seeing the **life** field change during the runtime in the editor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在检查器中看到生命值是如何减少的。你还可以按*Esc*键恢复鼠标控制，并在**播放**模式下选择对象，同时看到编辑器中运行时**生命**字段的更改。
- en: 'Now, you will notice that life is decreasing, but it will become negative;
    we want the object to destroy itself when life is below 0 instead. We can do this
    in two ways: one is to add an `Update` to the `Life` component, which will check
    all of the frames to see whether life is below 0, destroying itself when that
    happens.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会注意到生命正在减少，但它会变成负数；我们希望当生命低于0时对象会销毁自己。我们可以通过两种方式做到这一点：一种是在`Life`组件中添加一个`Update`，它会检查所有帧以查看生命是否低于0，并在发生这种情况时销毁自己。
- en: The second way is by encapsulating the life field and checking its value inside
    the setter to prevent all frames from being checked. I would prefer the second
    way, but we will implement the first one to make our scripts as simple as possible
    for beginners.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是通过封装生命字段并在setter中检查其值来防止所有帧都被检查。我更喜欢第二种方法，但我们将实现第一种方法，以使脚本对初学者尽可能简单。
- en: 'To do this, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: Add `Update` to the `Life` component.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Update`添加到`Life`组件中。
- en: Add `If` to check whether the amount field is below or equals `0`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`If`以检查数量字段是否小于或等于`0`。
- en: Add `Destroy` in case the `if` condition is `true`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`条件为`true`的情况下，添加`Destroy`。
- en: 'The full `Life` script will look like the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的`Life`脚本将如下截图所示：
- en: '![](img/B21361_07_19_PRE_BOOK.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_19_PRE_BOOK.png)'
- en: 'Figure 7.19: The Life component'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：Life组件
- en: Save and see how the object is destroyed once `Life` becomes `0`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并查看当`Life`变为`0`时对象是如何被销毁的。
- en: 'The Visual Scripting version for the `Life` component would look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Life`组件的视觉脚本版本看起来如下：'
- en: '![](img/B21361_07_20_PRE_BOOK.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_20_PRE_BOOK.png)'
- en: 'Figure 7.20: The Life component in Visual Scripting'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：视觉脚本中的Life组件
- en: 'The script is pretty straightforward—we check if our `Life` variable is less
    than 0 and then destroy ourselves, as we did previously. Now, let’s check the
    **Damager** script:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本相当简单——我们检查我们的`Life`变量是否小于0，然后销毁自己，就像我们之前做的那样。现在，让我们检查**Damager**脚本：
- en: '![](img/B21361_07_21_PRE_BOOK.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_21_PRE_BOOK.png)'
- en: 'Figure 7.21: The Damager component in Visual Scripting'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：视觉脚本中的Damager组件
- en: 'This version is a little bit different from our C# counterpart. At first glance,
    it looks the same: we use the **Get Variable** as before to read the life, and
    then we use the **Subtract** node to subtract **damage** from **life**, and the
    result of that calculation becomes the new value of **life**, with the **Set Variable**
    node used to alter the current value of that variable.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与我们的C#版本略有不同。乍一看，它看起来相同：我们像之前一样使用**获取变量**来读取生命值，然后使用**减去**节点从**生命**中减去**伤害**，计算结果成为新的**生命**值，使用**设置变量**节点来改变该变量的当前值。
- en: The first difference we can see here is the absence of any `GetComponent` node.
    In C#, we used that instruction to get the `Life` component on the collided object
    in order to read and alter its **amount** variable, reducing the remaining life.
    But as in Visual Scripting, our node graphs don’t have variables, so we don’t
    need to access the component to read them. Instead, knowing that the enemy has
    a `Life` variable in its **Variables** component, we use the **Get Variable**
    node, connecting it to the collider we hit (the **Collider** output pin of **On
    Trigger Enter**), so essentially, we are reading the value of the `Life` variable
    of the collided object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到的第一个区别是缺少任何`GetComponent`节点。在C#中，我们使用该指令来获取碰撞对象的`Life`组件，以便读取和修改其**数量**变量，减少剩余的生命值。但在Visual
    Scripting中，我们的节点图没有变量，因此我们不需要访问组件来读取它们。相反，我们知道敌人其**变量**组件中有一个名为`Life`的变量，我们使用**获取变量**节点，将其连接到我们撞击的碰撞器（**On
    Trigger Enter**的**Collider**输出引脚），因此本质上，我们正在读取被撞击对象的`Life`变量值。
- en: 'The same goes for changing its value: we use the **Set Value** node, connecting
    it to the collider, specifying that we want to alter the value of the `Life` variable
    of the collider object, not ours (as bullets don’t have a `Life` variable). Note
    that this can raise an error if the collided object doesn’t have the `Life` variable,
    which is why we added the **Object Has Variable** node, which checks if the object
    has a variable called `Life`. If it doesn’t, we just do nothing, which is useful
    when we collide with walls or other non-destructible objects. Finally, we make
    the **Damager** (the bullet in this case) auto-destroy itself.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于更改其值：我们使用**设置值**节点，将其连接到碰撞器，指定我们想要更改碰撞器对象的`Life`变量值，而不是我们自己的（因为子弹没有`Life`变量）。请注意，如果被撞击的对象没有`Life`变量，这可能会引发错误，这就是为什么我们添加了**对象有变量**节点，它检查对象是否有一个名为`Life`的变量。如果没有，我们就什么也不做，这在与墙壁或其他不可破坏的对象碰撞时很有用。最后，我们让**伤害者**（在这个例子中是子弹）自动销毁自己。
- en: You can instantiate an object when this happens, such as a sound, a particle,
    or maybe a power-up. I will leave this as a challenge for you. By using a similar
    script, you can implement a life power-up that increases the life value or a speed
    power-up that accesses the `PlayerMovement` script and increases the **Speed**
    field; from now on, use your imagination to create exciting behaviors using the
    previously acquired knowledge.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，你可以实例化一个对象，比如声音、粒子，或者可能是一个增强道具。我将把这个留给你作为挑战。通过使用类似的脚本，你可以实现一个增加生命值的生命增强道具，或者一个通过访问`PlayerMovement`脚本并增加**速度**字段的加速增强道具；从现在开始，发挥你的想象力，使用之前获得的知识来创建令人兴奋的行为。
- en: Now that we have explored how to detect collisions and react to them, let’s
    explore how to fix the player falling when hitting a wall.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何检测碰撞并对其做出反应，让我们来探讨如何修复玩家在撞击墙壁时掉落的问题。
- en: Moving with physics
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用物理移动
- en: So far, the player, the only object that moves with the **Dynamic Collider Profile**
    and the one that will move with physics, actually moves through custom scripting
    using the Transform API. Instead, every dynamic object should move using the Rigidbody
    API functions in a way the physics system understands better. As such, here, we
    will explore how to move objects, this time through the **Rigidbody** component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，玩家是唯一一个使用**动态碰撞器配置文件**移动的对象，并且将根据物理规则移动，实际上是通过自定义脚本使用Transform API来移动的。相反，每个动态对象都应该使用Rigidbody
    API函数以物理系统更易理解的方式移动。因此，在这里，我们将探讨如何移动对象，这次是通过**Rigidbody**组件。
- en: 'In this section, we will examine the following physics movement concepts:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下物理运动概念：
- en: Applying forces
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用力
- en: Tweaking physics
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整物理
- en: We will start by seeing how to move objects the correct physical way through
    forces, and we will apply this concept to the movement of our player. Then, we
    will explore why real physics is not always fun and how we can tweak the physics
    properties of our objects to have a more responsive and appealing behavior.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何通过力以正确的方式移动对象，并将此概念应用于玩家的移动。然后，我们将探讨为什么现实中的物理并不总是有趣的，以及我们如何调整对象的物理属性以使其行为更加灵敏和吸引人。
- en: Applying forces
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用力
- en: The physically accurate way of moving an object is through forces, which affect
    the object’s velocity. To apply force, we need to access `Rigidbody` instead of
    `Transform` and use the `AddForce` and `AddTorque` functions to move and rotate,
    respectively. These are functions where you can specify the amount of force to
    apply to each axis of position and rotation. This method of movement will have
    full physics reactions; the forces will accumulate on the velocity to start moving
    and will suffer drag effects that will make the speed slowly decrease, and the
    most important aspect here is that they will collide against walls, blocking the
    object’s way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 移动物体的物理准确方式是通过力，这会影响物体的速度。要施加力，我们需要访问`Rigidbody`而不是`Transform`，并使用`AddForce`和`AddTorque`函数分别进行移动和旋转。这些函数允许您指定要施加到位置和旋转每个轴上的力的大小。这种移动方式将具有完整的物理反应；力将累积在速度上以开始移动，并受到阻力效应的影响，这将使速度逐渐减小，而且这里最重要的方面是它们将碰撞到墙壁，阻挡物体的路径。
- en: 'To get this kind of movement, we can do the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这种移动，我们可以执行以下操作：
- en: 'Create a `Rigidbody` field in the `PlayerMovement` script, but this time, make
    it `private`—that is, do not write the `public` keyword in the field, which will
    make it disappear in the editor; we will get the reference another way:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerMovement`脚本中创建一个`Rigidbody`字段，但这次将其设置为`private`——也就是说，不要在字段中写入`public`关键字，这将使其在编辑器中消失；我们将以另一种方式获取引用：
- en: '![](img/B21361_07_22_PRE_BOOK.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_22_PRE_BOOK.png)'
- en: 'Figure 7.22: The private Rigidbody reference field'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：私有Rigidbody引用字段
- en: Note that we named this variable `rb` just to prevent our scripts from being
    too wide, making the screenshots of the code in the book too small. It’s recommended
    to name the variable properly in your scripts—in this case, it would be named
    `rigidbody`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们之所以将这个变量命名为`rb`，只是为了防止我们的脚本过于宽泛，使得书中代码的截图太小。建议在您的脚本中正确命名变量——在这种情况下，它应该命名为`rigidbody`。
- en: 'Using `GetComponent` in the `Start` event function, get our Rigidbody and save
    it in the field. We will use this field to cache the result of the `GetComponent`
    function; calling that function every frame to access the Rigidbody is not performant.
    Also, note here that the `GetComponent` function can be used to retrieve not only
    components from other objects (like the collision example) but also your own:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`事件函数中使用`GetComponent`，获取我们的Rigidbody并将其保存在字段中。我们将使用此字段来缓存`GetComponent`函数的结果；每帧调用该函数以访问Rigidbody是不高效的。此外，请注意，`GetComponent`函数不仅可以用来检索其他对象的组件（如碰撞示例），还可以用来检索自己的组件：
- en: '![](img/B21361_07_23_PRE_BOOK.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_07_23_PRE_BOOK.png)'
- en: 'Figure 7.23: Caching the Rigidbody reference for future usage'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：缓存Rigidbody引用以供将来使用
- en: Replace the `transform.Translate` calls with `rb.AddRelativeForce`. This will
    call the add force functions of the Rigidbody, specifically the relative ones,
    which will consider the current rotation of the object. For example, if you specify
    a force in the *z*-axis (the third parameter), the object will apply its force
    along with its forward vector.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`transform.Translate`调用替换为`rb.AddRelativeForce`。这将调用Rigidbody的加力函数，特别是相对的函数，这将考虑对象的当前旋转。例如，如果您在*z*轴（第三个参数）上指定一个力，则对象将沿着其前进向量施加力。
- en: 'Replace the `transform.Rotate` calls with `rb.AddRelativeTorque`, which will
    apply rotation forces:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`transform.Rotate`调用替换为`rb.AddRelativeTorque`，这将应用旋转力：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_07_24_PRE_BOOK.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述的图片，自动生成](img/B21361_07_24_PRE_BOOK.png)'
- en: 'Figure 7.24: Using the Rigidbody forces API'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24：使用Rigidbody力API
- en: Check that the player GameObject Capsule collider does not intersect with the
    floor and is just a little bit over it. If the player intersects, the movement
    won’t work properly. If this is the case, move it upward.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查玩家GameObject的胶囊碰撞体是否不与地板相交，并且略微高于地板。如果玩家相交，则移动将无法正常工作。如果是这种情况，请将其向上移动。
- en: If you have used Unity before, you might find it odd to use `Update` instead
    of `FixedUpdate` to apply physics forces. FixedUpdate is a special update that
    runs at a fixed rate, regardless of the actual game’s **Frames per Second** (**FPS**),
    and here is where the Physics system executes. It is configured by default to
    run 50 times per frame. This means that if the game runs at 200 FPS, the FixedUpdate
    will execute every 4 frames, but if the game runs at 25 FPS, the fixed update
    will execute twice per frame. This is done this way to enhance the stability of
    the physics calculations, given their complexity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过Unity，您可能会觉得使用`Update`而不是`FixedUpdate`来应用物理力很奇怪。FixedUpdate是一种特殊的更新，它以固定的速率运行，不受实际游戏**每秒帧数**（**FPS**）的影响，而物理系统就在这里执行。默认情况下，它被配置为每帧运行50次。这意味着如果游戏以200
    FPS运行，FixedUpdate将每4帧执行一次，但如果游戏以25 FPS运行，则固定更新将每帧执行两次。这样做是为了增强物理计算的稳定性，考虑到它们的复杂性。
- en: While it would be correct to call any Rigidbody method that applies forces and
    torque in the FixedUpdate, it is not necessarily wrong to do that in the `Update`
    method. For simplicity, we kept our code in the Update method, given that FixedUpdate
    can be tricky to use for beginners, as it can execute more than once per frame
    or even skip some frames. One example is checking if a key is pressed using methods
    like `Input.GetKeyDown`, given the key pressure happens in specific frames. If
    you call that method in the FixedUpdate and FixedUpdate skips the frame where
    the key was pressed, the key pressure won’t be detected, making the game feel
    unresponsive. A classic fix would be to detect key presses in the Update method
    and store them if they were pressed in boolean variables to check them later in
    the FixedUpdate. But again, due to simplicity, we decided to leave it as is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在FixedUpdate中调用任何应用力和扭矩的Rigidbody方法可能是正确的，但在Update方法中这样做也不一定错误。为了简单起见，我们保留了代码在Update方法中，因为FixedUpdate对于初学者来说可能难以使用，因为它可能每帧执行多次，甚至跳过一些帧。一个例子是使用`Input.GetKeyDown`等方法检查按键是否被按下，因为按键压力发生在特定的帧中。如果您在FixedUpdate中调用该方法，而FixedUpdate跳过了按键被按下的帧，则按键压力将不会被检测到，使得游戏感觉不响应。一个经典的修复方法是使用Update方法检测按键压力，并将它们存储在布尔变量中，以便稍后在FixedUpdate中检查。但再次强调，由于简单起见，我们决定保持原样。
- en: 'In the Visual Scripting version, the change is the same: replace the **Transform**and
    **Rotate** nodes with the **Add Relative Force**and **Add Relative Torque** nodes,
    respectively. An example of **Add Relative Force** would be the following one:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Scripting版本中，变化是相同的：将**Transform**和**Rotate**节点分别替换为**添加相对力**和**添加相对扭矩**节点。以下是一个**添加相对力**的示例：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_07_25_PRE_BOOK.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图  描述由低置信度自动生成](img/B21361_07_25_PRE_BOOK.png)'
- en: 'Figure 7.25: Using the Rigidbody Forces API'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：使用Rigidbody Forces API
- en: 'And for rotation like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的旋转：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_07_26_PRE_BOOK.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B21361_07_26_PRE_BOOK.png)'
- en: 'Figure 7.26: Using the Rigidbody torque API'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26：使用Rigidbody扭矩API
- en: You can see that we don’t need to use the **GetComponent** nodes here either,
    given that just using the **Add Relative Force** or **Torque** nodes makes Visual
    Scripting understand that we want to apply those actions on our own Rigidbody
    component (explaining the use of the This label again). If, in any other case,
    we needed to call those functions on a Rigidbody other than ours, we would need
    the **GetComponent** node there, but let’s explore that later.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在这里我们也不需要使用**GetComponent**节点，因为仅仅使用**添加相对力**或**扭矩**节点就足以让Visual Scripting理解我们想要在我们的Rigidbody组件上应用这些动作（再次解释This标签的使用）。如果在任何其他情况下，我们需要在我们的Rigidbody组件之外调用这些函数，我们则需要在该处使用**GetComponent**节点，但让我们稍后再探讨这一点。
- en: Now, if you save and test the results, you will probably find the player falling,
    and that’s because now we are using real physics, which contains floor friction,
    and due to the force being applied at the center of gravity, it will make the
    object fall. Remember that, in terms of physics, you are a capsule; you don’t
    have legs to move, and here is where standard physics is not suitable for our
    game. The solution is to tweak physics to emulate the kind of behavior we need.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你保存并测试结果，你可能会发现玩家正在下落，这是因为我们现在使用的是真实物理，其中包含地板摩擦，由于作用力在质心处，这会使物体下落。记住，在物理方面，你是一个胶囊；你没有腿可以移动，这就是标准物理不适合我们的游戏的地方。解决方案是调整物理以模拟我们需要的这种行为。
- en: Tweaking physics
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整物理
- en: To make our player move like in a regular platformer game, we will need to freeze
    certain axes to prevent an object from falling. Remove the friction to the ground
    and increase the air friction (drag) to make the player reduce its speed automatically
    when releasing the keys.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的玩家像在常规平台游戏一样移动，我们需要冻结某些轴以防止物体下落。移除地面摩擦，并增加空气摩擦（阻力）以使玩家在释放按键时自动减速。
- en: 'To do this, follow these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，请按照以下步骤进行：
- en: 'In the `Rigidbody` component, look at the **Constraints** section at the bottom
    and check the **X** and **Z** axes of the **Freeze Rotation** property:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rigidbody`组件中，查看底部的**约束**部分，并检查**冻结旋转**属性的**X**和**Z**轴：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_07_27_PRE_BOOK.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由低置信度自动生成](img/B21361_07_27_PRE_BOOK.png)'
- en: 'Figure 7.27: Freezing the rotation axes'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27：冻结旋转轴
- en: This will prevent the object from falling sideways but will allow it to rotate
    horizontally. You might also freeze the *y*-axis of the **Freeze Position** property
    if you don’t want the player to jump, preventing some undesired vertical movement
    on collisions.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将防止物体向侧面下落，但允许它在水平方向上旋转。如果你不希望玩家跳跃，也可以冻结**冻结位置**属性的**y**轴，以防止在碰撞时出现一些不希望的垂直移动。
- en: You will probably need to change the speed values because you changed from a
    meters-per-second value to newtons-per-second, the expected value of the **Add
    Force** and **Add Torque** functions. Using 1,000 in speed and 160 in rotation
    speed was enough for me.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要更改速度值，因为你从每秒米值更改为每秒牛顿值，这是**添加力**和**添加扭矩**函数的预期值。对我来说，速度为1,000，旋转速度为160就足够了。
- en: 'Now, you will probably notice that the speed will increase a lot over time,
    as will the rotation. Remember that you are using forces, which affect your velocity.
    When you stop applying forces, the velocity is preserved, and that’s why the player
    keeps rotating even if you are not moving the mouse. The fix to this is to increase
    the **Drag** and **Angular Drag**, which emulates air friction and will reduce
    the movement and rotation, respectively, when no force is applied. Experiment
    with values that you find suitable; in my case, I used `2` for **Drag** and `10`
    for **Angular Drag**, needing to increase **Rotation Speed** to `150` to compensate
    for the drag increase:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可能会注意到速度和旋转会随着时间的推移而大幅增加。记住，你正在使用力，这会影响你的速度。当你停止施加力时，速度会被保留，这就是为什么即使你不移动鼠标，玩家也会继续旋转。解决这个问题的方法是增加**阻力**和**角阻力**，这模拟了空气摩擦，并将分别在无力作用时减少移动和旋转。尝试找到适合你的值；在我的情况下，我使用了`2`作为**阻力**，`10`作为**角阻力**，需要将**旋转速度**增加到`150`以补偿阻力的增加：
- en: '![](img/B21361_07_28.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_07_28.png)'
- en: 'Figure 7.28: Setting air friction for rotation and movement'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28：设置旋转和移动的空气摩擦
- en: Now, if you move while touching the wall, instead of sliding, like in most games,
    your player will stick to the obstacles due to contact friction. We can remove
    this by creating a `Physics Material`, an asset that can be assigned to the colliders
    to control how they react in those scenarios.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你在接触墙壁时移动，而不是像大多数游戏那样滑动，你的玩家会因为接触摩擦而粘附在障碍物上。我们可以通过创建一个`Physics Material`来移除这一点，这是一个可以分配给碰撞体以控制它们在这些场景中如何反应的资产。
- en: Start creating one by clicking on the **+** button in the **Project** window
    and selecting **Physics Material** (not the 2D version). Call it `Player`, and
    remember to put it in a folder for those kinds of assets.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**项目**窗口中的**+**按钮并选择**物理材质**（不是2D版本）来开始创建一个。将其命名为`Player`，并记得将其放入一个用于此类资产的文件夹中。
- en: 'Select it, and set **Static Friction** and **Dynamic Friction** to `0` and
    **Friction Combine** to `Minimum`, which will make the **Physics** system pick
    the minimum friction of the two colliding objects, which is always the minimum—in
    our case, zero:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它，并将**静摩擦**和**动摩擦**设置为`0`，将**摩擦组合**设置为`最小`，这将使**物理**系统选择两个碰撞物体中的最小摩擦，这总是最小的——在我们的案例中，是零：
- en: '![](img/B21361_07_29.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_07_29.png)'
- en: 'Figure 7.29: Creating a physics material'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29：创建物理材质
- en: 'Select the player, and drag this asset to the **Material** property of the
    **Capsule Collider**:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择玩家，并将此资产拖动到**胶囊碰撞体**的**材质**属性：
- en: '![](img/B21361_07_30_PRE_BOOK.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_07_30_PRE_BOOK.png)'
- en: 'Figure 7.30: Setting the physics material of the player'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30：设置玩家的物理材质
- en: If you play the game now, you may notice that the player will move faster than
    before because we don’t have any kind of friction on the floor, so you may need
    to reduce the movement force.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你可能会注意到玩家会比以前移动得更快，因为我们没有在地板上施加任何类型的摩擦，所以你可能需要减少移动力。
- en: As you can see, we needed to bend the physics rules to allow a responsive player
    movement. You can get more responsiveness by increasing drags and forces so that
    speeds are applied faster and reduced faster, but that depends, again, on the
    experience you want your game to have.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们需要弯曲物理规则以允许玩家有响应性的移动。你可以通过增加阻力和力来获得更多的响应性，这样速度可以更快地应用和减少，但这又取决于你希望游戏拥有的体验。
- en: 'Some games want an immediate response with no velocity interpolation, going
    from 0 to full speed and vice versa, from one frame to the other. In these cases,
    you can override the velocity and rotation vectors of the player directly at your
    will or even use other systems instead of physics, such as the Character Controller
    component, which has special physics for platform characters. You can read more
    about it here: [https://docs.unity3d.com/Manual/CharacterControllers.html](https://docs.unity3d.com/Manual/CharacterControllers.html).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏希望得到即时的响应，没有速度插值，从0到全速，反之亦然，从一个帧到另一个帧。在这些情况下，你可以直接根据自己的意愿覆盖玩家的速度和旋转向量，甚至可以使用物理以外的其他系统，例如具有专门物理特性的Character
    Controller组件。你可以在这里了解更多：[https://docs.unity3d.com/Manual/CharacterControllers.html](https://docs.unity3d.com/Manual/CharacterControllers.html)。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Every game has physics, in some way or another, for movement, collision detection,
    or both. In this chapter, we learned how to use the physics system for both being
    aware of proper settings to make the system work properly, reacting to collisions
    to generate gameplay systems, and moving the player in such a way that it collides
    with obstacles, keeping its physically inaccurate movement. We used these concepts
    to create our player and bullet movement and make our bullets damage the enemies,
    but we can reuse this knowledge to create a myriad of other possible gameplay
    requirements, so I suggest you play around a little bit with the physics concepts
    seen here; you can discover a lot of interesting use cases.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都以某种方式包含物理，无论是为了移动、碰撞检测还是两者兼而有之。在本章中，我们学习了如何使用物理系统，包括了解适当的设置以使系统正常工作，对碰撞做出反应以生成游戏系统，以及以使玩家以物理不准确的方式移动并与其碰撞的方式移动玩家。我们使用这些概念来创建我们的玩家和子弹移动，并使我们的子弹对敌人造成伤害，但我们也可以重用这些知识来创建无数其他可能的游戏需求，所以我建议你在这里的物理概念上稍微玩一玩；你可以发现很多有趣的用例。
- en: In the next chapter, we will discuss how to program the visual aspects of the
    game, such as effects, and make the UI react to the input.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何编程游戏的视觉方面，例如效果，并使UI对输入做出反应。
- en: Learn more on Discord
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家和作者本人一起阅读这本书。提问，为其他读者提供解决方案，通过Ask Me Anything会议与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
