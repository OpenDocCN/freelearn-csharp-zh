<html><head></head><body>
		<div><h1 id="_idParaDest-184" class="chapter-number"><a id="_idTextAnchor183"/>8</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>CI/CD – Publishing with GitHub Actions</h1>
			<p>One of the features of microservices is their ability to continuously build and deploy services. In the previous chapters, we automatically created the infrastructure that’s used by our service solution.</p>
			<p>In this chapter, we’ll continue to automatically build and update services and use protection rules before deploying applications to staging and production environments. While doing this, you’ll learn how to use feature flags with Azure App Configuration.</p>
			<p>In this chapter, you’ll learn how to do the following:</p>
			<ul>
				<li>Use GitHub Actions</li>
				<li>Build and test the application automatically after a pull request</li>
				<li>Deploy the application to test environments</li>
				<li>Use deployment protection rules before deploying the application to production environments</li>
				<li>Publish NuGet packages</li>
				<li>Use feature flags with modern deployment patterns</li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Technical requirements</h1>
			<p>In this chapter, similar to the previous chapter, you’ll need an Azure subscription, the Azure CLI, the Azure Developer CLI, and .NET Aspire. You’ll also need your own GitHub repository so that you can store secrets, create environments, and run GitHub actions. These features are available in public repositories. If you create a private repository, the GitHub Team feature is required for creating environments (see <a href="https://github.com/pricing">https://github.com/pricing</a>).</p>
			<p>The source code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>.</p>
			<p>The <code>ch08</code> folder contains the following projects, along with the output for this chapter:</p>
			<ul>
				<li><code>Codebreaker.GameAPIs</code>: The <code>game-apis</code> project we used in the previous chapter has been enhanced using feature flags.</li>
				<li><code>Codebreaker.Bot</code>: This is the implementation of <code>bot-service</code>, which plays games.</li>
				<li><code>Codebreaker.GameAPIs.KiotaClient</code>: This is the client library we created in <a href="B21217_04.xhtml#_idTextAnchor092"><em class="italic">Chapter 4</em></a> to be used by clients.</li>
				<li><code>Workflows</code>: This folder is new. Here, you will find all the GitHub Actions workflows. However, these don’t become active until you copy them to the <code>.github/workflows</code> folder in your repository.</li>
			</ul>
			<p>To work through the code with this chapter, you can use the <code>service</code> and <code>bot</code> projects from the previous chapter, as well as the <code>Kiota</code> library from <a href="B21217_04.xhtml#_idTextAnchor092"><em class="italic">Chapter 4</em></a>.</p>
			<p>For this chapter, you’ll need GitHub rights to run GitHub workflows, as well as to create and use GitHub environments with protection rules. The easiest way to do this is to create a public repository and copy just the code from this chapter into it. Create the <code>src</code> folder in this new repository and copy the source code to this folder.</p>
			<p>Check out the README file in the <code>ch08</code> folder of this book’s GitHub repository for the latest updates.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Preparing the solution using the Azure Developer CLI</h1>
			<p>First, let’s prepare<a id="_idIndexMarker536"/> the solution<a id="_idIndexMarker537"/> using the Azure Developer CLI. When initializing the solution, set the current folder to the root folder of the repository (not the folder of the solution file, as we did previously):</p>
			<pre class="console">
azd init</pre>
			<p>Select <code>bot</code> and <code>game-apis</code> as projects to be exposed to the internet, and enter a new environment name – for example, <code>codebreaker-08-dev</code>. The generated <code>azure.yaml</code> file, which contains a link to the AppHost project file, needs to be committed<a id="_idIndexMarker538"/> to the source code repository. The generated <code>.azure</code> folder can contain<a id="_idIndexMarker539"/> secrets and has been – because of the generated <code>.gitignore</code> file – excluded from the source code repository.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The reason to use the root directory of the <code>azd pipeline</code> command used later; At the time of writing, this command requires the <code>.github/workflows</code> directory to be in the same folder. Some changes are planned for a later release, so please check the README file for this chapter for updates.</p>
			<p>Now, let’s deploy the resources to Azure:</p>
			<pre class="console">
azd auth login
azd up</pre>
			<p>With <code>azd up</code>, the resources are deployed to your configured environment. Select the Azure subscription you wish to use and the Azure region where you want to deploy the resources.</p>
			<p>The generated file, <code>azure.yaml</code>, references the AppHost project. The generated folder, <code>.azure</code> (which has been excluded from the source code repository because of possible secrets being stored), contains the current environment and a folder that has the same name as the environment. This folder contains the <code>config.json</code> file, which lists the publicly accessible service configuration, and the <code>.env</code> file, which contains variables referencing the created Azure resources.</p>
			<p>Now, we are ready to use GitHub Actions. You can remove the Azure resources with <code>azd down</code> again since the complete infrastructure should have been deployed via GitHub Actions:</p>
			<pre class="console">
azd down</pre>
			<p>Answer <code>y</code> to delete the resources, and then <code>y</code> again to permanently delete the resources that have soft delete enabled.</p>
			<p>If you want to permanently delete resources, open the Azure portal (<a href="https://portal.azure.com">https://portal.azure.com</a>), go to <strong class="bold">Key Vault</strong>, and click on <strong class="bold">Manage deleted vaults</strong>. Key vaults that are deleted<a id="_idIndexMarker540"/> need to be purged<a id="_idIndexMarker541"/> so that you can create a resource with the same name again. Purge the key vaults. Similarly, check for Azure App Configuration services that need to be purged.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Exploring GitHub Actions</h1>
			<p><strong class="bold">GitHub Actions</strong> is a feature of GitHub<a id="_idIndexMarker542"/> that you can use to automatically build, test, and deploy source code. GitHub Actions is a product that consists of <em class="italic">workflows</em>, <em class="italic">events</em>,  <em class="italic">jobs</em>, <em class="italic">actions</em>, and <em class="italic">runners</em>:</p>
			<ul>
				<li>A <code>.github/workflows</code> folder<a id="_idIndexMarker543"/> of a repository. A workflow contains events and jobs.</li>
				<li>An <strong class="bold">event</strong> specifies what triggers a<a id="_idIndexMarker544"/> workflow. When should the workflow be started?</li>
				<li>A <strong class="bold">job</strong> consists of steps<a id="_idIndexMarker545"/> that are<a id="_idIndexMarker546"/> executed on a <strong class="bold">runner</strong> machine.</li>
				<li>A <strong class="bold">step</strong> can run a script or an<a id="_idIndexMarker547"/> action.</li>
				<li>An <strong class="bold">action</strong> is a reusable GitHub extension<a id="_idIndexMarker548"/> that reduces the need to write scripts. Many of these reusable extensions can be used to build and deploy applications.</li>
			</ul>
			<p>Now that we’ve set the foundation with these terms, let’s get into the details by creating a workflow using the Azure portal.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>Creating a GitHub Actions workflow</h2>
			<p>There are several options<a id="_idIndexMarker549"/> to automatically create GitHub Actions workflows to deploy services to Microsoft Azure. Using the Azure portal, upon opening <strong class="bold">Container App</strong>, you can select <strong class="bold">Continuous deployment</strong> under <strong class="bold">Settings</strong>, as shown in <em class="italic">Figure 8</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21217_08_01.jpg" alt="Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal</p>
			<p>Using the Azure portal, you can select <a id="_idIndexMarker550"/>the GitHub repository, configure the Azure Container Registry you wish to use, and specify a <strong class="bold">Service Principal</strong> or a <strong class="bold">User-assigned Identity</strong> value to be used to publish the project.</p>
			<p>Another option is to use<a id="_idIndexMarker551"/> Visual Studio. With Visual Studio, you can select a project (for example, <code>game-apis</code>) and select <strong class="bold">Publish…</strong> from the context menu. Upon adding a new publish profile, which you can do by selecting <strong class="bold">Azure</strong> | <strong class="bold">Azure Container Apps (Linux)</strong>, then selecting <strong class="bold">Container App</strong>, then Container Registry, the following dialogue appears:</p>
			<div><div><img src="img/B21217_08_02.jpg" alt="Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio</p>
			<p>From this dialogue, you can directly publish to the Azure Container App or create a GitHub Actions workflow.</p>
			<p>What’s common with these options is that you can publish service by service. Here, you used <code>azd up</code> to deploy the complete solution. Let’s have a look at what the Azure Developer CLI has to offer to create GitHub Actions workflows.</p>
			<p>First, you need to create a <code>.github</code> folder in the root directory of the repository. Files that are used by specific GitHub functionality are stored in this folder. To this folder, add a <code>workflows</code> folder (<code>.github/workflows</code>). All the GitHub Actions workflows need to be stored within this folder.</p>
			<p>Next, create the <code>codebreaker-deploy.yml</code> file. Now, copy the content of the <code>azure-deploy.yaml</code> file to this file. This file<a id="_idIndexMarker552"/> is from the <em class="italic">Azure-Samples</em> repository: <a href="https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml">https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml</a>.</p>
			<p>Now that we’ve created this workflow file, we can take a closer look at it.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>Workflow file with YAML syntax</h2>
			<p>The syntax of<a id="_idIndexMarker553"/> workflow files<a id="_idIndexMarker554"/> makes use of <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>, a recursive acronym) syntax. YAML<a id="_idIndexMarker555"/> is a data-oriented human-readable serialization language that uses indentation to specify what belongs together.</p>
			<p>See <a href="https://yaml.org/">https://yaml.org/</a> for the YAML spec and<a id="_idIndexMarker556"/> links to libraries. You can check out the following cheat sheet for the syntax: <a href="https://yaml.org/refcard.html">https://yaml.org/refcard.html</a>.</p>
			<p>Let’s take a closer look at the workflow file while making some small changes.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Triggers</h2>
			<p>A workflow file starts<a id="_idIndexMarker557"/> with a name followed by a trigger:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
name: Codebreaker backend workflow
<strong class="bold">on:</strong>
<strong class="bold">  workflow-dispatch:</strong>
<strong class="bold">  </strong><strong class="bold">push:</strong>
<strong class="bold">    branches:</strong>
<strong class="bold">      - main</strong>
<strong class="bold">    paths:</strong>
<strong class="bold">    - 'src/**'</strong></pre>
			<p>The name of a workflow is shown in the list of workflows. The <code>on</code> keyword specifies the events that trigger the workflow. GitHub offers many events that can be used with workflows. In this YAML file, the workflow is triggered with a <code>workflow_dispatch</code> event. This allows you to manually trigger the workflow. The second event, <code>push</code>, is triggered when changes are pushed to the repository. Because of the filtering that follows as part of <code>push</code>, the trigger is only done with a push to the <code>main</code> branch with changes specified by the files specified with <code>path</code>. If we don’t specify branches and path filters, the workflow<a id="_idIndexMarker558"/> will be triggered with every change in this repository.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Permissions for secretless Azure federated credentials</h2>
			<p>The <code>permissions</code> section is a new construct<a id="_idIndexMarker559"/> that’s used with secretless Azure federated credentials to deploy to Azure:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
<strong class="bold">permissions:</strong>
<strong class="bold">  id-token: write</strong>
<strong class="bold">  contents: read</strong></pre>
			<p>Permissions are used to access the identity token and the content. With <code>contents read</code>, the workflow has read access to the content of the repository. <code>id-token write</code> grants write access to the identity token. This token is used to authenticate GitHub with Azure.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>Jobs and runners</h2>
			<p>In the workflow file, after<a id="_idIndexMarker560"/> the trigger<a id="_idIndexMarker561"/> is defined, the <code>jobs</code> keyword can be used to list one or more jobs that should run:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
<strong class="bold">jobs</strong>:
  build-and-deploy:
    <strong class="bold">runs-on:</strong> <strong class="bold">ubuntu-latest</strong>
<strong class="bold">    env:</strong>
      AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}</pre>
			<p><code>build-and-deploy</code> is the name<a id="_idIndexMarker562"/> of the job. A job needs a runner. GitHub offers hosted runners to run jobs on Linux, Windows, and Mac. You can find out what runners<a id="_idIndexMarker563"/> are available, as well as their versions, at: <a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources">https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources</a>. If other hardware or operating system versions are needed, a custom runner can be used.</p>
			<p>Using the <code>env</code> keyword, environment<a id="_idIndexMarker564"/> variables are defined that can be used with the steps in this runner. The values for these variables come from the GitHub project variables using the <code>vars</code> object. The <code>${{ }}</code> expressions are evaluated during the execution of the workflow, and the values that are retrieved are added to the workflow at runtime. We will specify these values later using <code>azd </code><code>pipeline config</code>.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Steps and actions</h2>
			<p>A job consists<a id="_idIndexMarker565"/> of steps<a id="_idIndexMarker566"/> and actions:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
<strong class="bold">    steps:</strong>
<strong class="bold">      - name: Checkout</strong>
<strong class="bold">        uses: actions/checkout@v4</strong>
<strong class="bold">      - name: Install azd</strong>
<strong class="bold">        uses: Azure/setup-azd@v1.0.0</strong>
<strong class="bold">      - name: Install .NET Aspire workload</strong>
<strong class="bold">        run: dotnet workload install aspire</strong>
# Code removed for brevity</pre>
			<p>The first step consists<a id="_idIndexMarker567"/> of an action, <code>actions/checkout@v4</code>. This action checks out the source<a id="_idIndexMarker568"/> code to ensure it’s available alongside the runner. <code>@v4</code> defines the version number to be used for this GitHub action. Actions are available via GitHub Marketplace: <a href="https://github.com/marketplace?category=&amp;query=&amp;type=actions">https://github.com/marketplace?category=&amp;query=&amp;type=actions</a>. Every action has documentation that you can read to learn which parameters are available. <code>actions/checkout</code>, for example, allows you to include submodules at checkout and also allows you to check out source code from other repositories.</p>
			<p>The next action installs the Azure Developer CLI using <code>Azure/setup-azd</code>.</p>
			<p>.NET is installed with the hosted runner, but we need to make sure we install the .NET Aspire workload. This can be done using a one-line script specified with the <code>run</code> field – that is, <code>dotnet workload </code><code>install aspire</code>.</p>
			<p> Next, the <code>azd auth</code> command is used:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
      - name: Log in with Azure (Federated Credentials)
        <strong class="bold">if: ${{ env.AZURE_CLIENT_ID != '' }}</strong>
  <strong class="bold">      run: |</strong>
<strong class="bold">          </strong><strong class="bold">azd auth login `</strong>
<strong class="bold">            --client-id "$Env:AZURE_CLIENT_ID" `</strong>
<strong class="bold">            --federated-credential-provider "github" `</strong>
<strong class="bold">            --tenant-id «$Env:AZURE_TENANT_ID»</strong>
<strong class="bold">        shell: pwsh</strong></pre>
			<p>Here, we have the step<a id="_idIndexMarker569"/> where the permissions we defined earlier are needed: authentication<a id="_idIndexMarker570"/> with Federated Identity. <code>if</code> specifies that this step is conditional – only if <code>AZURE_CLIENT_ID</code> is not empty. We’ll have another option for authentication if <code>AZURE_CLIENT_ID</code> is empty with the following step. This step is not using a GitHub action; instead, the <code>run</code> field defines that it will invoke a multi-line script. Using multiple lines is specified by <code>|</code> at the end of the line. PowerShell (which is specified with the <code>shell</code> field) uses the backtick (<code>`</code>) as a line continuation character.</p>
			<p>The command that’s running with PowerShell is <code>azd auth login</code>, passing a few parameters. <code>--client-id</code> uses the identifier of the service principal, which has the necessary Azure permissions. <code>--federated-credential-provider</code> uses GitHub for federated authentication. Federated authentication allows you to use GitHub identities to access resources on Azure. <code>--tenant-id</code> specifies the Azure directory identifier that is used with Azure authentication.</p>
			<p>The next step uses another conditional script if the <code>AZURE_CREDENTIALS</code> variable is set:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
- name: Log in with Azure (Client Credentials)
   if: ${{ env.AZURE_CREDENTIALS != '' }}
   run: |
<strong class="bold">     $info = $Env:AZURE_CREDENTIALS | ConvertFrom-Json -AsHashtable;</strong>
<strong class="bold">     Write-Host "::add-mask::$($info.clientSecret)"</strong>
<strong class="bold">     azd auth login `</strong>
<strong class="bold">       --client-id "$($info.clientId)" `</strong>
<strong class="bold">       --client-secret "$($info.clientSecret)" `</strong>
<strong class="bold">       --tenant-id "$($info.tenantId)"</strong>
   shell: pwsh
   env:
<strong class="bold">     AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}</strong></pre>
			<p>The <code>AZURE_CREDENTIALS</code> environment<a id="_idIndexMarker571"/> variable is stored as a JSON script. This is converted <a id="_idIndexMarker572"/>into a PowerShell hash table variable named <code>info</code> and allows us to access each part of the JSON content, such as the client ID, the client secret, and the tenant ID. These parts are then passed to the <code>azd auth login</code> command. <code>AZURE_CREDENTIALS</code> itself is retrieved using <code>secrets.AZURE_CREDENTIALS</code>. Secrets are stored encrypted alongside the GitHub project and are not part of the source code of the repository. We’ll configure these secrets in the next section.</p>
			<p>Finally, two one-line commands are invoked:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
      - name: Provision Infrastructure
<strong class="bold">        run: azd provision --no-prompt</strong>
      - name: Deploy Application
<strong class="bold">        run: azd deploy --no-prompt</strong></pre>
			<p>The first command, <code>azd provision</code>, creates the Azure infrastructure, as specified by the ap<code>p-model</code> definition of the AppHost project. If the infrastructure already exists, it is checked if a change is needed, and only updates are applied. <code>azd deploy</code> then deploys the services to Azure, thus building the Docker images, publishing them to Azure Container Registry, and creating various Azure Container Apps with the created images. The <code>--no-prompt</code> option doesn’t wait for the user to interact with this command and just uses defaults.</p>
			<p>The <code>azd up</code> command we used previously used <code>azd provision</code> and <code>azd deploy</code>.</p>
			<p>Create the <code>.github/workflows</code> folder in your<a id="_idIndexMarker573"/> repository and copy<a id="_idIndexMarker574"/> the <code>codebreaker-deploy.yml</code> workflow file to this folder.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>GitHub variables and secrets</h2>
			<p>Secrets shouldn’t be part of the<a id="_idIndexMarker575"/> source code, and the workflow file is stored<a id="_idIndexMarker576"/> with the source code. GitHub has a vault where you can store secrets outside of the source code repository. Using <code>azd</code>, secrets and variables can automatically be configured with GitHub.</p>
			<p>The <code>azd pipeline</code> command supports this. Start by having the current directory set to the root folder of the repository. <code>azd pipeline</code> needs the .<code>github/workflows</code> folder to be in the same directory where you run <code>azd pipeline</code>; you must also have the .NET Aspire application initialized in this directory. This requirement might change – check the README file in this chapter’s GitHub repository for more information.</p>
			<p>Run the following command to configure the pipeline:</p>
			<pre class="console">
azd auth login
azd pipeline config --auth-type federated --principal-name github-codebreaker-dev</pre>
			<p><code>azd pipeline config</code> uses the Azure subscription you configured earlier to create GitHub variables and secrets, as well as create an Azure app registration, which allows GitHub to deploy to Azure. By default, the principal name created starts with <code>az-dev-</code> and contains the date and time it was created. Here, we specify the principal name as <code>github-codebreaker-dev</code>. Repository variables for <code>AZURE_ENV_NAME</code>, <code>AZURE_LOCATION</code>, <code>AZURE_SUBSCRIPTION_ID</code>, <code>AZURE_TENANT_ID</code>, and <code>AZURE_CLIENT_ID</code> are created.</p>
			<p>Open the GitHub repository in your browser. In the portal, click <strong class="bold">Settings</strong>. With the <strong class="bold">Security</strong> category open in the left pane, you’ll see <strong class="bold">Secrets and variables</strong>. In this sub-category, when you open <strong class="bold">Actions</strong>, you’ll see the <strong class="bold">Actions secrets and variables</strong> page, which contains <strong class="bold">Repository secrets</strong>. This is shown in <em class="italic">Figure 8</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/B21217_08_03.jpg" alt="Figure 8.3 – Repository secrets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Repository secrets</p>
			<p>The <code>AZD_INITIAL_ENVIRONMENT_CONFIG</code> secret contains the content of the <code>.azure/[environment]/config.json</code> file. This file contains a list of publicly accessible services and is read by <code>azd deploy</code> to configure the Ingress controller. The needed environment name, location, subscription ID, and other details are stored within repository variables.</p>
			<p>Because <code>azd pipeline config</code> creates Federated Identity credentials for GitHub, secrets to access Azure are not required with the default (federated) configuration. Instead of using a value of <code>federated</code>, you can pass <code>client-credentials</code>, which configures credentials to be stored within a repository secret.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>, you understood how to separate secrets and variables with Azure Container Apps, and then with Azure App Configuration and Key Vault in <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>. The reason for this separation is similar here using GitHub Actions.</p>
			<p>GitHub allows you to specify<a id="_idIndexMarker577"/> different levels where you can store secrets <a id="_idIndexMarker578"/>and variables. The organization level can be used when secrets should be shared across different repositories within the organization. Repository secrets are stored within the scope of the repository and are not available from other repositories. Environment secrets are scoped within deployment environments. These will be covered later in the <em class="italic">Using deployment </em><em class="italic">environments</em> section.</p>
			<p>Run the GitHub Actions workflow now – either by pushing a source code update to the GitHub repository or by running the workflow explicitly from the GitHub portal. You’ll see that the workflow is in progress before it completes:</p>
			<div><div><img src="img/B21217_08_04.jpg" alt="Figure 8.4 – Workflow in progress"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Workflow in progress</p>
			<p>At this stage, you might need to wait until an agent is available. When it’s in progress, you can click on it to see progress information about what’s going on. <em class="italic">Figure 8</em><em class="italic">.5</em> shows the steps that appear when the workflow is completed successfully:</p>
			<div><div><img src="img/B21217_08_05.jpg" alt="Figure 8.5 – Workflow steps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Workflow steps</p>
			<p>Upon checking the logs, you’ll see all the steps that have been completed. In the preceding figure, you can see that federated credentials have been used, and not the client credentials. You can click on each of these steps to find more details.</p>
			<p>When creating a GitHub Actions<a id="_idIndexMarker579"/> workflow with <code>azd</code>, just a few statements are required<a id="_idIndexMarker580"/> to deploy the complete solution. With every source code change<a id="_idIndexMarker581"/> that is not pushed to the main<a id="_idIndexMarker582"/> branch, the deployment is updated.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Getting more with GitHub Actions</h2>
			<p>It’s great to have an easy way to create a GitHub action using integration from Visual Studio, the Azure portal, or via the <code>azd pipeline</code> command. <code>azd pipeline</code> is great for deploying a complete solution, but because of its early development stages, some features are missing. With our solution, some more features are required; we’ll customize these manually.</p>
			<p>Let’s have a look at some of the goals<a id="_idIndexMarker583"/> we have:</p>
			<ul>
				<li>All the services should be built, tested, and deployed</li>
				<li>NuGet packages should be published to GitHub Packages and made available there</li>
				<li>We don’t want to repeat code, so we’ll create reusable workflows</li>
				<li>Deploying should be done to multiple environments, such as development, staging, and production</li>
			</ul>
			<p>Let’s get into the details.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor196"/>Enhancing GitHub Actions workflows</h1>
			<p>To build our services, we must<a id="_idIndexMarker584"/> create reusable workflows. First, let’s configure the variables and secrets that are needed by these workflows.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Configuring variables and secrets</h2>
			<p>We’ve configured<a id="_idIndexMarker585"/> variables <a id="_idIndexMarker586"/>and secrets using <code>az pipeline config</code> previously. if you need more customization, you might need to set these values yourself. You’ve already seen how to access the repository secrets and variables with the GitHub portal. Now, let’s add these to secrets:</p>
			<ul>
				<li><code>AZURE_TENANT_ID</code></li>
				<li><code>AZURE_SUBSCRIPTION_ID</code></li>
				<li><code>AZURE_CLIENT_ID</code></li>
			</ul>
			<p>To get the tenant ID, use the Azure CLI:</p>
			<pre class="console">
az account show --query tenantId -o tsv</pre>
			<p><code>az account show</code> returns JSON information about the logged-in Azure account. With the JSONPath <code>--query tenantId</code> query, the Microsoft Entra tenant ID is returned. <code>-o tsv</code> returns the result in tab-separated values. Set the returned value with the <code>AZURE_TENANT_ID</code> repository secret.</p>
			<p>The subscription ID can also be listed with <code>az </code><code>account show</code>:</p>
			<pre class="console">
az account show --query id -o tsv</pre>
			<p>Here, <code>id</code> contains the subscription ID. Set this value with the <code>AZURE_SUBSCRIPTION_ID</code> repository secret.</p>
			<p>Earlier in this chapter, we used<a id="_idIndexMarker587"/> the <code>azd pipeline</code> command to create<a id="_idIndexMarker588"/> an account for federated authentication. Let’s check out this account within the Microsoft Entra portal: <a href="https://entra.microsoft.com">https://entra.microsoft.com</a>. After logging in, from the left bar, within the <code>github-codebreaker-dev</code>. If you didn’t supply a name, <code>azd</code> creates an account starting with <code>az-dev</code>. Open this account and, within the <strong class="bold">Manage</strong> category, click <strong class="bold">Certificates &amp; secrets</strong>. Open <strong class="bold">Federated credentials</strong>. You will see credentials named based on the GitHub organization and the repository, with entity types of <strong class="bold">Pull request</strong> and <strong class="bold">Branch</strong>. A predefined federated credential scenario for GitHub actions deploying Azure resources will be available.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To create a new app registration with federated credentials using the Azure portal, the Azure CLI, or Azure PowerShell, check<a id="_idIndexMarker589"/> out the following documentation: <a href="https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials">https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials</a>.</p>
			<p>Copy the value for <code>AZURE_CLIENT_ID</code> repository<a id="_idIndexMarker591"/> secret.</p>
			<p>Now that we’ve specified the necessary secrets and variables, let’s get back to creating workflows.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Running unit tests</h2>
			<p>When triggering the workflow<a id="_idIndexMarker592"/> by updating the source<a id="_idIndexMarker593"/> code of a service, the first step should be to run unit tests. Let’s create a reusable workflow:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/shared-test.yml</p>
			<pre class="source-code">
name: Shared workflow to build and test a .NET project
<strong class="bold">on:</strong>
<strong class="bold">  workflow_call:</strong>
<strong class="bold">    inputs:</strong>
<strong class="bold">      project-name:</strong>
        description: 'The name of the project'
        required: true
        type: string
<strong class="bold">      solution-path:</strong>
        description: 'The solution file of the project to build and run tests'
        required: true
        type: string
<strong class="bold">      dotnet-version:</strong>
        description: 'The version of .NET to use'
        required: false
        type: string
<strong class="bold">        default: '8.0.x'</strong></pre>
			<p>A reusable workflow is triggered by calling this workflow. The trigger specified by <code>on</code> uses the <code>workflow_call</code> keyword. At this point, the input values that are needed are also defined. With this workflow, <code>project-name</code> and <code>solution-path</code> are required input values. The <code>dotnet-version</code> input value has a default value assigned and is not required.</p>
			<p>After the trigger and the input<a id="_idIndexMarker594"/> values, a job with a runner<a id="_idIndexMarker595"/> is defined, followed by the steps to be invoked:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">work flows/shared-test.yml</p>
			<pre class="source-code">
jobs:
  run-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout to the branch
        uses: <strong class="bold">actions/checkout@v4</strong>
      - name: Setup .NET
        uses: <strong class="bold">actions/setup-dotnet@v4</strong>
        with:
          dotnet-version: ${{ inputs.dotnet-version }}
      - name: Install .NET Aspire workload
        run: dotnet workload install aspire
      - name: Restore NuGet Packages
<strong class="bold">        run: dotnet restore ${{ inputs.solution-path }}</strong>
      - name: Run unit tests
<strong class="bold">        run: dotnet test --logger trx --results-directory "TestResults-${{ inputs.project-name}}" --no-restore ${{ inputs.solution-path }}</strong>
      - name: Upload the test results
<strong class="bold">        uses: actions/upload-artifact@v4</strong>
<strong class="bold">        with:</strong>
<strong class="bold">          name: test-results-${{ inputs.project-name}}</strong>
          path: TestResults-${{ inputs.project-name}}
      <strong class="bold">  if: always()</strong></pre>
			<p>After checking out the source code with the <code>actions/checkout</code> action, the .NET SDK is installed using <code>actions/setup-dotnet</code>. Here, the .NET version is retrieved from the input values. As the .NET SDK is now installed with this runner, the .NET CLI can be used. In the next step, instead of invoking an action, the <code>run</code> keyword is used to execute the <code>dotnet restore</code> command. <code>dotnet restore</code> retrieves the NuGet packages of the referenced solution. If this fails, there’s no need to continue with the next step. The next step runs the unit tests using <code>dotnet test</code>.  The <code>--logger</code> option specifies to write log output<a id="_idIndexMarker596"/> with the TRX logger format – a Visual Studio <code>actions/upload-artifact</code> action. Artifacts<a id="_idIndexMarker597"/> can be used to share data between runners and also downloaded with workflow runs. By default, a step only runs if the previous<a id="_idIndexMarker598"/> step succeeds. In this case, we want to download<a id="_idIndexMarker599"/> the test result from the artifacts if the test fails – that’s why <code>if: always()</code> was added on uploading the artifact.</p>
			<p>This shared workflow is started from the <code>codebreaker-test.yml</code> workflow:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-test.yml</p>
			<pre class="source-code">
# code removed for brevity
<strong class="bold">jobs:</strong>
<strong class="bold">  build-and-test:</strong>
<strong class="bold">    uses: ./.github/workflows/shared-test.yml</strong>
<strong class="bold">    with:</strong>
<strong class="bold">      project-name: 'Codebreaker-Backend'</strong>
<strong class="bold">      solution-path: 'src/Chapter08.sln'</strong></pre>
			<p>The job that’s been defined uses the name <code>build-and-test</code>, references the shared workflow file with the <code>uses</code> keyword, and sets the input values using the <code>with</code> keyword.</p>
			<p>This workflow is triggered when a change<a id="_idIndexMarker600"/> is made in the specified<a id="_idIndexMarker601"/> files and folders in the main branch, explicitly. <em class="italic">Figure 8</em><em class="italic">.6</em> shows the result of running the workflow:</p>
			<div><div><img src="img/B21217_08_06.jpg" alt="Figure 8.6 – Running the workflow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Running the workflow</p>
			<p>With this result, you can see the downloadable<a id="_idIndexMarker602"/> artifacts for viewing<a id="_idIndexMarker603"/> the test results.</p>
			<p>Now that we’ve run the unit tests, let’s combine this with the previously created build and deploy job.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Running multiple jobs</h2>
			<p>To run multiple jobs <a id="_idIndexMarker604"/>from one workflow, we’ll need<a id="_idIndexMarker605"/> to create a shared workflow from the deployment project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/shared-deploy.yml</p>
			<pre class="source-code">
name: Shared workflow to deploy a .NET Aspire project
<strong class="bold">on:</strong>
<strong class="bold">  workflow_call:</strong>
    inputs:
# code removed for brevity
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true</pre>
			<p>Because this is a shared workflow that’s triggered from other workflows, <code>on</code> specifies <code>workflow_call</code>. This workflow is very similar to the previously created deployment workflow, so the code for this hasn’t been repeated here. Check out the source code repository for the complete workflow. What’s important here is that not only inputs are passed from the calling workflow, but also secret information. These secrets are referenced using the <code>$ {{ secrets.&lt;secret&gt; }}</code> expression.</p>
			<p>The <code>codebreaker-testanddeploy.yml</code> workflow<a id="_idIndexMarker606"/> invokes both shared<a id="_idIndexMarker607"/> workflows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-testanddeploy.yml</p>
			<pre class="source-code">
# code removed for brevity
jobs:
  <strong class="bold">build-and-test:</strong>
    uses: ./.github/workflows/shared-test.yml
    with:
      project-name: Codebreaker-Backend
      solution-path: src/Chapter08.sln
<strong class="bold">  build-and-deploy:</strong>
<strong class="bold">    needs:  build-and-test</strong>
<strong class="bold">    uses: ./.github/workflows/shared-deploy.yml</strong>
<strong class="bold">    with:</strong>
<strong class="bold">      environment-name: ${{ vars.AZURE_ENV_NAME }}</strong>
<strong class="bold">      location: ${{ vars.AZURE_LOCATION }}</strong>
<strong class="bold">    secrets:</strong>
<strong class="bold">      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}</strong>
<strong class="bold">      </strong><strong class="bold">AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}</strong>
<strong class="bold">      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}</strong></pre>
			<p>Using the <code>needs</code> keyword, the <code>build-and-deploy</code> job is defined<a id="_idIndexMarker608"/> to require the <code>build-and-test</code> job to run<a id="_idIndexMarker609"/> beforehand. If the <code>build-and-test</code> job does not succeed, <code>build-and-deploy</code> will not run. Secrets need to be forwarded to the shared workflow. With secrets, you can specify every secret to pass with the calling workflow, or to share all the secrets available from the calling workflow with the called workflow. Inheriting these secrets is required when using environments (as shown in a later section).</p>
			<p>When you run the workflow at this stage, you’ll see a graphical view of how the two jobs are connected, as shown in <em class="italic">Figure 8</em><em class="italic">.7</em>:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21217_08_07.jpg" alt="Figure 8.7 – Running multiple jobs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Running multiple jobs</p>
			<p>Both jobs were<a id="_idIndexMarker610"/> completed <a id="_idIndexMarker611"/>successfully.</p>
			<p>Next, we’ll dive into environments that can be used from multiple jobs to, for example, deploy the solution to staging and production environments.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Using deployment environments</h1>
			<p>When running the solution<a id="_idIndexMarker612"/> locally on the developer system, projects can be built and debugged locally. Just a few services, such as App Insights and Key Vault, need to be run in the Azure cloud environment. This is done automatically by .NET Aspire, which provisions <code>app-model</code> in the AppHost project. You just need to make sure you configure <code>Azure:SubscriptionId</code> with the user secrets. To run and test the application while it’s running within Azure, and to try out different Azure offerings, every developer of the team can use <code>azd init</code> and <code>azd up</code> to have all the services running in the personal Azure subscription that’s part of the Visual Studio Professional and Enterprise offerings.</p>
			<p>It’s also useful to use a shared environment where the services of the solution running in Microsoft Azure are used together by the developer team. One example is for client application developers to use a new daily build<a id="_idIndexMarker613"/> to test the client applications accessing the services in the cloud. This is the <em class="italic">development environment</em>.</p>
			<p>To run load <a id="_idIndexMarker614"/>tests, it’s useful to have <em class="italic">test environments</em>. Such environments can be created on demand before running the load test. They can be deleted again after the load tests are finished and the results have been documented. See <a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a> for more details on running tests.</p>
			<p>Before moving into<a id="_idIndexMarker615"/> production, <em class="italic">staging environments</em>, which mirror the <em class="italic">production environments</em>, are used to make final<a id="_idIndexMarker616"/> tests if the application is behaving as expected.</p>
			<p>We can deploy the solution<a id="_idIndexMarker617"/> to all these environments by using GitHub Actions. However, some of these environments are more restrictive, which means that deployments can only be done when it’s been verified that the solution runs successfully with the defined constraints.</p>
			<p>Let’s take a closer look.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Create environments with the Azure Developer CLI</h2>
			<p>To create environments<a id="_idIndexMarker618"/> with the Azure Developer<a id="_idIndexMarker619"/> CLI, you can use the <code>azd env </code><code>new</code> command:</p>
			<pre class="console">
azd env new codebreaker-08-prod</pre>
			<p>This not only creates a new environment named <code>codebreaker-08-prod</code> but also sets the current environment to this new one. To show all environments that have been configured, run the following command:</p>
			<pre class="console">
azd env list</pre>
			<p>This shows all the environments that have been configured, as well as the currently selected environment. To change the current one, run the following command:</p>
			<pre class="console">
azd env select codebreaker-dev</pre>
			<p>Creating an environment with <code>azd</code> creates the <code>.azure</code> subdirectory. Upon opening this folder, you will see the <code>config.json</code> file. This shows the currently selected environment.</p>
			<p>With every environment that’s created, a subdirectory containing the name of the environment is created that contains values for the resource group, the Azure region, and the Azure subscription ID. When you’re creating a new environment, you can change the subscription with the <code>--subscription</code> option. To change the location of the resources, use <code>--location</code>.</p>
			<p>To see the configuration values for an environment, run the following command:</p>
			<pre class="console">
azd env get-values</pre>
			<p>To change the Azure region afterward, you can use <code>azd </code><code>env set</code>:</p>
			<pre class="console">
azd env set AZURE_LOCATION eastus3</pre>
			<p>While the Azure Developer CLI supports using multiple environments, using this in combination with GitHub environments is (not yet) directly available but can be easily customized. At the time of writing, the <code>azd pipeline config</code> command only supports one environment per repository. However, this is expected to change, and integration with GitHub environments is already being discussed. Check the README file in this chapter’s repository for updates.</p>
			<p>You can still use <code>azd pipeline</code> to create federated accounts for every environment:</p>
			<pre class="console">
azd pipeline config --auth-type federated --principal-name github-codebreaker-prod</pre>
			<p>This creates the account<a id="_idIndexMarker620"/> that we’ll use<a id="_idIndexMarker621"/> with the <code>codebreaker-08-prod</code> environment.</p>
			<p>At this point, we need to learn how to use GitHub environments. So, we’ll start by creating GitHub environments.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Creating GitHub environments</h2>
			<p>Before using GitHub environments, you need <a id="_idIndexMarker622"/>to be aware that this GitHub feature is only available for free with public repositories. With private repositories, a Team license is required (see <a href="https://github.com/pricing">https://github.com/pricing</a>).</p>
			<p>Open your GitHub repository in your browser and click <strong class="bold">Settings</strong>. In the left pane, under the <strong class="bold">Code and automation</strong> category, click <strong class="bold">Environments</strong>. <em class="italic">Figure 8</em><em class="italic">.8</em> shows the environments for development, testing, staging, and production:</p>
			<div><div><img src="img/B21217_08_08.jpg" alt="Figure 8.8 – GitHub environments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – GitHub environments</p>
			<p>You can create these environments<a id="_idIndexMarker623"/> using your browser by accessing your repository. As the environments are being created, protection rules can be applied.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Defining deployment protection rules</h2>
			<p>Before publishing to<a id="_idIndexMarker624"/> another environment, you can enforce <strong class="bold">deployment protection rules</strong>. Publishing to the production environment might only be allowed from <strong class="bold">protected branches</strong>, specific branches that fulfill a naming<a id="_idIndexMarker625"/> convention, and only with commits from specific tag names. Up to six reviewers can be specified to approve the deployment. There’s also the option to implement custom protection rules, which, for example, might check the results of different test runs (tests will be covered in <a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>) or check for issues within the GitHub repository. Third-party protection rules are also available.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With the first few versions of the application, where you’ll start with deployments across different environments, it’s good practice to add reviewers that do some manual checks. Before<a id="_idIndexMarker626"/> the solution is deployed<a id="_idIndexMarker627"/> to the <strong class="bold">production</strong> environment, it needs to be deployed to the <strong class="bold">staging</strong> environment. In the staging environment, manual checks are used. On the road to improving the CI/CD process, you might add more and more automatic checks. Automated tests, code analysis, checking for issues, and more can be done before moving on to the next stage. You just need to be able to trust how you set up the environment and have your tests running.</p>
			<p>Within the production environment, add yourself as a required reviewer with deployment protection, as shown in <em class="italic">Figure 8</em><em class="italic">.9</em>:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21217_08_09.jpg" alt="Figure 8.9 – Required reviewers with GitHub environments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Required reviewers with GitHub environments</p>
			<p>Other than requiring reviewers, you can use rules<a id="_idIndexMarker628"/> defined by existing apps from GitHub partner applications to require some source code or issue checks, and also implement custom protection rules</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When using deployment protection rules for branches and tags, you should specify that not everyone is allowed to create branches and tags that are used with the rules. See <em class="italic">Configuring tag protection rules</em> at <a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules">https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules</a> for more details.</p>
			<p>Next, we’ll configure secrets and variables with environments.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Setting environment secrets and variables</h2>
			<p>With environments, you can also<a id="_idIndexMarker629"/> specify variables and secrets<a id="_idIndexMarker630"/> that are only available within these environments. We need the tenant ID, the subscription ID , and the account ID of the federated account we created earlier. This information was configured in the <em class="italic">Enhancing GitHub Actions </em><em class="italic">workflows</em> section.</p>
			<p>As a reminder, to get the tenant ID, use <code>az account show –query tenantId -o tsv</code>). To get the subscription ID, use <code>az account show --query id -o tsv</code>. With the account, to use an environment, an additional credential is required.</p>
			<p>Open the Entra portal (<a href="https://entra.microsoft.com">https://entra.microsoft.com</a>) and select <code>az-dev&lt;date&gt;</code>. Select <code>repo:&lt;github org/repo&gt;:pull_request</code> and <code>repo:&lt;github org/repo:refs/heads/main</code> subject identifiers were added. Add a new credential and select <strong class="bold">GitHub Actions deploying Azure resources</strong>, as shown in <em class="italic">Figure 8</em><em class="italic">.10</em>:</p>
			<div><div><img src="img/B21217_08_10.jpg" alt="Figure 8.10 – Environment credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Environment credentials</p>
			<p>Within this dialogue, add<a id="_idIndexMarker631"/> your GitHub <strong class="bold">Organization</strong> and <strong class="bold">Repository</strong>, select <strong class="bold">Environment</strong> for <strong class="bold">Entity type</strong>, enter the <strong class="bold">GitHub environment name</strong> value<a id="_idIndexMarker632"/> that matches your GitHub environment, and provide <strong class="bold">Credential details</strong>.</p>
			<p>To configure the secret, copy the <strong class="bold">Application (client) ID</strong> value of this app registration.</p>
			<p>Once you have these values, open the environment in the GitHub portal and add <strong class="bold">Environment secrets</strong> and <strong class="bold">Environment variables</strong>, as shown in <em class="italic">Figure 8</em><em class="italic">.11</em>:</p>
			<div><div><img src="img/B21217_08_11.jpg" alt="Figure 8.11 – Configuring Environment secrets and Environment variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Configuring Environment secrets and Environment variables</p>
			<p>The following variables<a id="_idIndexMarker633"/> are required:</p>
			<ul>
				<li><code>AZURE_ENV_NAME</code>: The resource group<a id="_idIndexMarker634"/> name that should be used without the <code>rg-</code> prefix – for example, <code>codebreaker-08-prod</code></li>
				<li><code>AZURE_LOCATION</code>: Your preferred Azure region</li>
			</ul>
			<p>You will need the following secrets:</p>
			<ul>
				<li><code>AZURE_SUBSCRIPTION_ID</code></li>
				<li><code>AZURE_TENANT_ID</code></li>
				<li><code>AZURE_CLIENT_ID</code></li>
			</ul>
			<p>With this configuration in place, let’s update the workflows.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>Using environments with workflows</h2>
			<p>To use an environment<a id="_idIndexMarker635"/> from a workflow, all you need<a id="_idIndexMarker636"/> to do is reference the environment name. Copy the shared workflow, <code>shared-deploy.yml</code>, to <code>shared-deploy-withenvironment.yml</code> and enhance it with an environment configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/shared-deploy-withenvironment.yml</p>
			<pre class="source-code">
# code removed for brevity
  workflow_call:
<strong class="bold">    </strong><strong class="bold">inputs:</strong>
<strong class="bold">      environment-name:</strong>
        description: 'The environment to deploy to'
        required: true
        type: string
jobs:
  build-and-publish:
    runs-on: ubuntu-latest
<strong class="bold">    environment: ${{ inputs.environment-name }}</strong></pre>
			<p>When configuring the job, the <code>environment</code> keyword is used to reference an environment name. With this implementation, a required input parameter is used to pass the name of the environment. No changes need to be made regarding the secrets and variables. When running in the environment, these values are retrieved from the environment configuration.</p>
			<p>The <code>codebreaker-production.yml</code> workflow, which uses the various workflows to create and push the Docker image and publish the Container App, is different from the development environment, as shown here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker- produnction.yml</p>
			<pre class="source-code">
# code removed for brevity
jobs:
  build-and-deploy:
    uses: ./.github/workflows/shared-deploy-withenvironment.yml
<strong class="bold">    secrets: inherit</strong>
    with:
<strong class="bold">      environment-name: codebreaker-08-prod</strong></pre>
			<p>The environment parameter<a id="_idIndexMarker637"/> is now set<a id="_idIndexMarker638"/> to <code>codebreaker-08-prod</code>. This time, the secrets are not explicitly declared, but all secrets this workflow has access to are given to the called workflow. Because of the environment specified by the called workflow, secrets and variables are referenced from the GitHub environment.</p>
			<p>Now, you can try triggering the workflow. The first stage runs, but the second stage must be reviewed, as shown in <em class="italic">Figure 8</em><em class="italic">.12</em>:</p>
			<div><div><img src="img/B21217_08_12.jpg" alt="Figure 8.12 – Workflow review requested"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Workflow review requested</p>
			<p>Review the results<a id="_idIndexMarker639"/> of the workflow<a id="_idIndexMarker640"/> and approve it, as shown in <em class="italic">Figure 8</em><em class="italic">.13</em>:</p>
			<div><div><img src="img/B21217_08_13.jpg" alt="Figure 8.13 – Approve and deploy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Approve and deploy</p>
			<p>At this point, you need to wait a few minutes until all the resources are deployed to the production environment. Verify that the deployment succeeded. After a successful deployment, you can use a client, update<a id="_idIndexMarker641"/> the link to the new environment, and play<a id="_idIndexMarker642"/> a game.</p>
			<p>For the client programmers, we’ll create a NuGet package.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Publishing NuGet packages</h1>
			<p>With our solution, we also have libraries<a id="_idIndexMarker643"/> that are used by client applications. Having NuGet packages helps with using these libraries. By creating a GitHub action, we can automatically build and publish the NuGet package. If you want to make a package publicly available, you can publish it to the NuGet server (you’ve already used packages that are available for this book). To make packages<a id="_idIndexMarker644"/> private with authentication, GitHub offers <strong class="bold">GitHub Packages</strong>.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Preparing the library project</h2>
			<p>Adding some metadata, such<a id="_idIndexMarker645"/> as a README Markdown file to the project describing the package, and a custom icon to replace the default icon, enhances usability.</p>
			<p>The <code>Codebreaker.GameAPIs.KiotaClient</code> project contains a <code>readme.md</code> file and a JPG file for an icon. These additions need to be uploaded within the project file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj</p>
			<pre class="source-code">
  &lt;ItemGroup&gt;
    &lt;None Include="package/readme.md" Pack="true" PackagePath="\" /&gt;
    &lt;None Include="package/codebreaker.jpeg" Pack="true" 
     PackagePath="\" /&gt;
  &lt;/ItemGroup&gt;</pre>
			<p>The README file and the icon don’t need to be built into the library, which is why <code>None</code> is used within <code>ItemGroup</code> to exclude them from the build result of the library. Adding these items to the NuGet package is specified by the <code>Pack</code> attribute. <code>PackagePath</code> specifies the folder within the package where these items can be found.</p>
			<p>The following <code>PropertyGroup</code> definitions specify the use of the README file and the package icon and add some metadata:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj</p>
			<pre class="source-code">
  &lt;PropertyGroup&gt;
    &lt;PackageId&gt;
      CNinnovation.Codebreaker.KiotaClient
    &lt;/PackageId&gt;
    &lt;PackageTags&gt;
      Codebreaker;CNinnovation;Kiota
    &lt;/PackageTags&gt;
    &lt;Description&gt;
      This library contains Kiota-generated classes for communication 
      with the Codebreaker games API service.
      See https://github.com/codebreakerapp for more information on 
        the complete solution.
    &lt;/Description&gt;
    &lt;PackageReadmeFile&gt;readme.md&lt;/PackageReadmeFile&gt;
    &lt;PackageIcon&gt;codebreaker.jpeg&lt;/PackageIcon&gt;
  &lt;/PropertyGroup&gt;</pre>
			<p>Adding metadata to the package is specified with the <code>PackageId</code>, <code>PackageTags</code>, and <code>Description</code> elements.</p>
			<p>It’s also a good idea to define the version of the package. With the source code repository, the <code>VersionPrefix</code> element, which is defined within the <code>Directory.Build.props</code> file, specifies the first part of the version for all the projects found in subdirectories. Using a GitHub action, a <code>VersionSuffix</code> element is added dynamically that increments with every build. This versioning scheme is used with <code>alpha</code>, <code>beta</code>, and <code>prerelease</code> versions.</p>
			<p>As soon as the library is released, the <code>Version</code> element is added to specify the complete version of the package. Adding the <code>Version</code> element to the project overrides <code>VersionPrefix</code> and <code>VersionSuffix</code>, and just this version is used. After the release, when the next beta versions are available, the <code>Version</code> element is removed again, and the <code>VersionPrefix</code> element is incremented to the next<a id="_idIndexMarker646"/> iteration.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>Creating access tokens</h2>
			<p>To publish a package<a id="_idIndexMarker647"/> to GitHub Packages, a <strong class="bold">personal access token (classic)</strong> is required. At the time of<a id="_idIndexMarker648"/> writing, the new fine-grained personal access tokens cannot be used with GitHub Packages.</p>
			<p>You can create a personal access token by clicking on the user icon in the top-right corner, selecting <strong class="bold">Settings</strong>, and then clicking on <strong class="bold">Developer Settings</strong> in the left pane. Select <strong class="bold">Personal access tokens</strong> and click <strong class="bold">Tokens (classic)</strong>. To create a new token, select <strong class="bold">Generate new token (classic)</strong>. Select an expiration date. The scope that is required to publish packages is <strong class="bold">write:packages</strong>. Selecting this scope also adds other scopes, such as reading packages and access to the repository. Click <strong class="bold">Generate token</strong>. You need to copy this generated token – it will not be visible again after you close the screen. Just make sure you store it in a safe place. You can create a new token in case you don’t have one anymore, or when the token has expired.</p>
			<p>For the GitHub action you wish<a id="_idIndexMarker649"/> to use, store this token alongside the secrets of the <code>PAT_PUBLISHPACKAGE</code> repository.</p>
			<p>Now that we’ve stored this secret, let’s use it with a GitHub action.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Creating a GitHub action to publish a GitHub package</h2>
			<p>The GitHub actions that are used<a id="_idIndexMarker650"/> to create a NuGet package have similarities with the GitHub actions we created previously. Check out the source code repository for details.</p>
			<p>The <code>shared-create-nuget.yml</code> shared workflow builds the NuGet package and uploads it with GitHub artifacts. The following steps are completed in this workflow:</p>
			<ol>
				<li>Check out the source code.</li>
				<li>Set up .NET.</li>
				<li>Calculate the build number (using a configured offset to the GitHub build number).</li>
				<li>Build the library using <code>dotnet build</code>.</li>
				<li>Test the library using <code>dotnet test</code>.</li>
				<li>Create a NuGet package using <code>dotnet pack</code>.</li>
				<li>Upload the package with GitHub artifacts.</li>
			</ol>
			<p>The next shared workflow (<code>shared-githubpackages.yml</code>) uploads the package to GitHub Packages by following these steps:</p>
			<ol>
				<li>Download the GitHub artifact.</li>
				<li>Set up .NET.</li>
				<li>Set the NuGet source with <code>dotnet nuget </code><code>add source</code>.</li>
				<li>Push the package to GitHub Packages with <code>dotnet </code><code>nuget push</code>.</li>
			</ol>
			<p>Pushing the package makes use of the configured access token.</p>
			<p>The <code>kiota-lib.yml</code> workflow connects the two shared workflows and passes parameters. Upon running this workflow successfully, you can verify the packages with the organization of your GitHub repository, as shown in <em class="italic">Figure 8</em><em class="italic">.14</em>:</p>
			<div><div><img src="img/B21217_08_14.jpg" alt="Figure 8.14 – GitHub Packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – GitHub Packages</p>
			<p>Using GitHub environments, you can enhance the creation of NuGet packages and define environments, such as those to publish to the publicly available NuGet server only after successfully using a private feed<a id="_idIndexMarker651"/> with GitHub Packages.</p>
			<p>With modern deployments, there’s more than just using development, staging, and production environments. We’ll discuss this next.</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/>Using modern deployment patterns</h1>
			<p>Using development, staging, and production environments is one of the “traditional” deployment patterns. Nowadays, other deployment<a id="_idIndexMarker652"/> patterns are used as well:</p>
			<ul>
				<li>When using <strong class="bold">canary releases</strong>, different versions of an application<a id="_idIndexMarker653"/> are available for the user to choose from. This is evident from the Edge browser, which offers a Beta channel that’s updated monthly, a Dev channel that’s updated weekly, and a Canary channel that’s updated daily. The user can decide<a id="_idIndexMarker654"/> what version to test. See <a href="https://www.microsoft.com/en-us/edge/download/insider">https://www.microsoft.com/en-us/edge/download/insider</a> for more details.</li>
				<li>With <strong class="bold">A/B testing</strong>, users randomly receive<a id="_idIndexMarker655"/> one of two different user interfaces. When using this pattern, you can monitor which UI allows the user to be more productive.</li>
				<li><strong class="bold">Blue-green deployments</strong> allow you to quickly roll back an installation<a id="_idIndexMarker656"/> by installing to a staging server, swapping staging with production. If something fails, an easy rollback can be done.</li>
				<li><strong class="bold">Dark launching</strong> is a pattern that you can use to publish<a id="_idIndexMarker657"/> a new version of the application while ensuring that the new features are hidden until they are activated by turning on a switch. One example of this is when a feature should be available at a specific time. This switch can be turned on by a time event – there’s no need to redeploy the application.</li>
				<li><strong class="bold">Feature toggles</strong> allow you to turn each feature<a id="_idIndexMarker658"/> on/off. One option is to enable some of the features for a specific group of users, such as early adopters. Users themselves can also decide which of the new features they want to test. Such toggles are available with Microsoft Azure and Visual Studio.</li>
			</ul>
			<p>In <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>, you saw Azure App Configuration in action. This Azure service not only supports a central application configuration but also offers feature flags. This functionality of Azure App Configuration can be used with several of the modern deployment patterns by using different feature flag filters.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>Configuring feature flags</h2>
			<p>Let’s open the Azure App Configuration <a id="_idIndexMarker659"/>service that was created with Bicep scripts. In the left pane, within the <strong class="bold">Operations</strong> category, open <strong class="bold">Feature manager</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might not have access to this resource to add configuration data since the resource was created from Bicep scripts. Using <strong class="bold">Access control (IAM)</strong>, add your user to the <strong class="bold">App Configuration Data Owner</strong> or <strong class="bold">Contributor</strong> role. You might need to wait about 15 minutes before the role changes.</p>
			<p>Create a new feature flag, as shown in <em class="italic">Figure 8</em><em class="italic">.15</em>:</p>
			<div><div><img src="img/B21217_08_15.jpg" alt="Figure 8.15 – Creating feature flags"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Creating feature flags</p>
			<p>Set the feature flag’s name to <code>Feature8x5Game</code>, add a description, and check the <code>FeatureGame6x4Mini</code>, <code>FeatureGame6x4</code>, and <code>FeatureGame5x5x4</code>. Don’t add filters for the first two; just enable one of these. For the last one, add a time filter so that it can be enabled in the future, but don’t set an expiration date.</p>
			<p>The <strong class="bold">targeting filter</strong> allows you to open a feature<a id="_idIndexMarker660"/> for a specific user group (early adopters). It can also act as a percentage filter, so you can turn this feature on for a random percentage of users. The <a id="_idIndexMarker661"/>other built-in filter is the <strong class="bold">time window filter</strong>. Using this filter, you can specify start and end times when this feature should be enabled. You can also create a custom<a id="_idIndexMarker662"/> implementation for a filter.</p>
			<p>Now that we’ve configured this feature flag, let’s use this from the <code>game-apis</code> service.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>DI and middleware configuration for feature flags</h2>
			<p>To use Feature<a id="_idIndexMarker663"/> Management, add<a id="_idIndexMarker664"/> the <code>Microsoft.FeatureManagement.AspNetCore</code> NuGet package<a id="_idIndexMarker665"/> to the <code>Codebreaker.GameAPIs</code> project. The DI container needs<a id="_idIndexMarker666"/> to be configured for feature flags, as shown here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
builder.Services.AddFeatureManagement()
  .AddFeatureFilter&lt;TargetingFilter&gt;()
  .AddFeatureFilter&lt;TimeWindowFilter&gt;();</pre>
			<p>The <code>AddFeatureManagement</code> extension method registers types that are needed for feature flags. Every filter that is used is added using the <code>AddFeatureFilter</code> extension method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Feature Management API can also be used without Azure App Configuration. Upon viewing the source code in this book’s GitHub repository, you’ll see that the Feature Management API can be configured without using Azure as well. In this case, an overload of the <code>AddFeatureManagement</code> API is invoked to pass an <code>IConfiguration</code> object. With this, feature flags can be configured with the .NET configuration options. Revisit <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a> for more information on configuration.</p>
			<p>To connect Feature Management with Azure App Configuration, you must update the <code>AddAzureAppConfiguration</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
  builder.Configuration.AddAzureAppConfiguration(options =&gt;
  {
    options.Connect(new Uri(endpoint), credential)
      .Select("GamesAPI*")
      .ConfigureKeyVault(kv =&gt;
      {
        kv.SetCredential(credential);
      })
<strong class="bold">      .UseFeatureFlags();</strong>
  });</pre>
			<p><code>UseFeatureFlags</code> is a method of the <code>AzureAppConfigurationOptions</code> class for connecting feature flags.</p>
			<p>When using feature<a id="_idIndexMarker667"/> flags, the Azure App Configuration<a id="_idIndexMarker668"/> middleware<a id="_idIndexMarker669"/> also needs<a id="_idIndexMarker670"/> to be configured:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
var app = builder.Build();
if (solutionEnvironment == "Azure")
{
<strong class="bold">  app.UseAzureAppConfiguration();</strong>
}</pre>
			<p>With the setup in place, we can check if feature flags have been set.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>Using feature flags</h2>
			<p>Now, we can use the feature manager<a id="_idIndexMarker671"/> to check if features are available. We’ll start by creating an extension method for the <code>IFeatureManager</code> interface:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Extensions/FeatureManagerExtensions.cs</p>
			<pre class="source-code">
public static class FeatureManagerExtensions
{
  private static List&lt;string&gt;? s_featureNames;
  public static async Task&lt;bool&gt; IsGameTypeAvailable(<strong class="bold">this </strong>
    <strong class="bold">IFeatureManager featureManager</strong>, GameType gameType)
  {
    async Task&lt;List&lt;string&gt;&gt; GetFeatureNamesAsync()
    {
      List&lt;string&gt; featureNames = [];
<strong class="bold">      await foreach (string featureName in featureManager.</strong>
<strong class="bold">        GetFeatureNamesAsync())</strong>
      {
        featureNames.Add(featureName);
      }
      return featureNames;
    }
    string featureName = $"Feature{gameType}";
    if ((s_featureNames ?? await GetFeatureNamesAsync()).
    Contains(featureName))
    {
<strong class="bold">      return await featureManager.IsEnabledAsync(featureName);</strong>
    }
    else
    {
      return true;
    }
  }
}</pre>
			<p>This method uses<a id="_idIndexMarker672"/> the <code>GetFeatureNamesAsync</code> and <code>IsEnabledAsync</code> methods defined by the <code>IFeatureManager</code> interface. On the first invocation of this method, the list of features registered with the feature manager is retrieved and added to the <code>_featureNames</code> collection. Not every game type is registered as a feature. For the game types that are not registered as features, the method returns <code>true</code> to inform us that this type is available. With all the game types registered as a feature, the <code>IsEnabledAsync</code> method is used to check if the feature is enabled.</p>
			<p>Next, let’s inject <code>IFeatureManager</code> with the minimal API:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
group.MapPost("/", async Task&lt;Results&lt;Created&lt;CreateGameResponse&gt;, BadRequest&lt;GameError&gt;&gt;&gt; (
  CreateGameRequest request,
  IGamesService gameService,
<strong class="bold">  IFeatureManager featureManager,</strong>
  HttpContext context,
  CancellationToken cancellationToken) =&gt;
  {
    Game game;
    try
    {
<strong class="bold">      bool featureAvailable = await featureManager.</strong>
        <strong class="bold">IsGameTypeAvailable(request.GameType);</strong>
      if (!featureAvailable)
      {
        GameError error = new(ErrorCodes.
          GameTypeCurrentlyNotAvailable, "Game type currently not 
          available", context.Request.GetDisplayUrl());
        return TypedResults.BadRequest(error);
      }
      game = await gameService.StartGameAsync(request.GameType.
        ToString(), request.PlayerName, cancellationToken);}
// code removed for brevity</pre>
			<p>On starting a game<a id="_idIndexMarker673"/> using the API, the <code>IFeatureManagement</code> interface is injected to check the requested game type for the feature to be enabled using the previously created extension method, <code>IsGameTypeAvailable</code>. Depending on the result, an error is returned, or a new game is created.</p>
			<p>With this implementation, you can run the application and test these feature flags. The <code>game-apis</code> project contains an HTTP file that you can use to create all the different game types and see the results that were returned when using feature flags. You can test this locally on your developer system. Upon pushing an update to your GitHub repository, a workflow is ready to be triggered. Then, you just need to configure the link of your API service within the HTTP<a id="_idIndexMarker674"/> file to test the service that’s running with Azure Container Apps.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Summary</h1>
			<p>After creating Azure services with Bicep scripts in <a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>, in this chapter, you learned how to use <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) with GitHub Actions. Here, you changed the source code, created and merged a pull request, tested code, and deployed Azure Container Apps. Using GitHub Actions, you learned how to build NuGet packages and push them to GitHub Packages.</p>
			<p>Using GitHub environments, you created multiple deployment environments where additional checks are required before deployment is extended to another stage.</p>
			<p>After, you learned how to configure Azure App Configuration, as well as how to use feature flags, which are needed for modern deployment patterns such as A/B testing, blue-green deployments, and dark launching.</p>
			<p>The next chapter covers another important topic: authentication and authorization. In <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>, you learned how to run Azure services with managed identities. In <a href="B21217_09.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a>, we’ll restrict the applications that are allowed to invoke APIs, authenticate users to restrict functionality for anonymous users, and add APIs that are only allowed to be used by specific user groups.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the following links:</p>
			<ul>
				<li><em class="italic">GitHub Actions </em><em class="italic">documentation</em>: <a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></li>
				<li><em class="italic">azd: configure a </em><em class="italic">pipeline</em>: <a href="https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline">https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline</a></li>
				<li><em class="italic">Using environments for </em><em class="italic">deployments</em>: <a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment</a></li>
				<li><em class="italic">Creating custom protection </em><em class="italic">rules</em>: <a href="https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules">https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules</a></li>
				<li><em class="italic">Microsoft Feature Management </em><em class="italic">documentation</em>: <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet">https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet</a></li>
			</ul>
		</div>
	</body></html>