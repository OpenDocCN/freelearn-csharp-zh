- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Best Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In the previous chapters, we focused on how to collect, enrich, correlate, and
    use individual telemetry signals. In this chapter, we’re going to discuss what
    information to collect and how to represent it efficiently using all the available
    signals. We’ll start by providing recommendations on how to pick a suitable telemetry
    signal and suggest cross-signal cost optimization strategies. Finally, we’ll explore
    about OpenTelemetry semantic conventions and use them to create consistent telemetry
    supported by most observability vendors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们专注于如何收集、丰富、关联和使用单个遥测信号。在本章中，我们将讨论需要收集哪些信息以及如何使用所有可用的信号高效地表示这些信息。我们将首先提供关于如何选择合适的遥测信号的建议，并提出跨信号成本优化策略。最后，我们将探讨
    OpenTelemetry 语义约定，并使用它们来创建大多数可观察性供应商支持的统一遥测。
- en: 'You’ll learn how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习以下内容：
- en: Find telemetry signals that work for your scenarios
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到适用于您场景的遥测信号
- en: Control telemetry costs with aggregation, sampling, and verbosity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过聚合、采样和详细程度控制遥测成本
- en: Follow common practices when reporting telemetry with OpenTelemetry semantic
    conventions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 语义约定报告遥测数据时的常见做法
- en: By the end of this chapter, you will be able to use existing semantics for common
    technologies or create your own cross-signal and cross-service conventions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用现有语义处理常见技术或创建自己的跨信号和跨服务约定。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no specific requirements for this chapter, and there are no associated
    code files either.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有具体要求，也没有相关的代码文件。
- en: Choosing the right signal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的信号
- en: 'When we discussed individual telemetry signals in *Chapters 6* to *8*, we provided
    suggestions on when to use each of them. Let’s do a quick recap:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 6 章到第 8 章讨论单个遥测信号时，我们提供了何时使用每个信号的建议。让我们快速回顾一下：
- en: '**Distributed traces** describe individual network calls and other interesting
    operations in detail. Spans have causal relationships, allowing us to understand
    the request flow in distributed systems.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式跟踪**详细描述了单个网络调用和其他有趣的操作。跨度具有因果关系，使我们能够理解分布式系统中的请求流程。'
- en: Traces document the request flow through the system and are essential for investigating
    errors or outliers in the long tail of latency distribution. Traces provide means
    to correlate other telemetry signals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪记录了系统中的请求流程，对于调查延迟分布长尾中的错误或异常至关重要。跟踪提供了关联其他遥测信号的手段。
- en: '**Metrics** collect aggregated data with low-cardinality attributes and provide
    a low-resolution view of the overall system state. They help optimize telemetry
    collection and reduce storage costs and query time.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**收集具有低基数属性的聚合数据，并提供对整体系统状态的低分辨率视图。它们有助于优化遥测收集，降低存储成本和查询时间。'
- en: '**Events** provide highly structured information about individual occurrences
    of important things. The key difference between spans and events is that spans
    have unique contexts and describe something that lasts.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**提供了关于重要事物单个发生的高度结构化信息。与跨度相比，事件的关键区别在于跨度具有唯一上下文，并描述了持续的东西。'
- en: Events have high-cardinality attributes and can help answer ad hoc questions
    about system behavior and usage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事件具有高基数属性，可以帮助回答关于系统行为和使用的即兴问题。
- en: '**Logs** provide details about operations in a human-readable and less structured
    format.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**以人类可读和不太结构化的格式提供操作细节。'
- en: They are useful for debugging things when other signals don’t provide enough
    information. Also, logs are the only signal that supports verbosity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他信号提供的信息不足时，它们对于调试事物非常有用。此外，日志是唯一支持详细程度的信号。
- en: '**Profiles** are low-level performance data describing individual operations
    within a single process that helps optimize performance and identify resource
    bottlenecks.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**是描述单个进程内单个操作的底层性能数据，有助于优化性能和识别资源瓶颈。'
- en: When instrumenting some specific scenario, we usually need a combination of
    signals.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在对特定场景进行仪器化时，我们通常需要信号组合。
- en: For example, to get observability into network calls, we need traces to ensure
    we can track the request flow across services and correlate other signals. Logs
    are necessary to record exceptions and warnings, describe local operations, and
    provide debug-level data for complicated investigations. Finally, we may need
    metrics to record non-sampled measurements, optimize collection, and reduce query
    time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了将可观察性引入网络调用，我们需要跟踪以确保我们可以跟踪服务之间的请求流并关联其他信号。日志是必要的，用于记录异常和警告，描述本地操作，并为复杂的调查提供调试级别的数据。最后，我们可能需要指标来记录非采样测量，优化收集并减少查询时间。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before thinking about signals, we should have an idea of what information we
    want to be available, how we’re going to use it, how fast and frequently we need
    it, how many details we want to capture, for how long we need it, how much we
    can afford, and the downtime cost.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑信号之前，我们应该有一个想法，即我们希望哪些信息可用，我们将如何使用它，我们需要多快多频繁地获取它，我们希望捕获多少细节，我们需要它多长时间，我们负担得起多少，以及停机成本。
- en: The answers to these questions should shape our decisions around observability.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案应该塑造我们关于可观察性的决策。
- en: Essentially, we have multiple trade-offs between having enough data to investigate
    issues fast and the cost of the observability solution. For example, collecting
    too many traces would give us all the details we need to investigate all sorts
    of issues. It would have a noticeable performance impact and significantly increase
    observability backend costs. As a result, traces might become so deep and detailed
    that it would be hard to understand where the problems are.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在足够的数据来快速调查问题和可观察性解决方案的成本之间有很多权衡。例如，收集过多的跟踪会给我们提供调查所有类型问题的所有必要细节。它会对性能产生明显的影响，并显著增加可观察性后端成本。结果，跟踪可能会变得非常深入和详细，以至于很难理解问题所在。
- en: The conversation about a good set of telemetry signals is not possible without
    talking about costs. Let’s see how we can control them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论一套良好的遥测信号集时，如果不提及成本，这样的讨论是不可能的。让我们看看我们如何控制它们。
- en: Getting more with less
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用更少的资源获得更多
- en: Since we usually need to collect multiple signals about the same component,
    we need to be able to tune them individually, depending on our needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常需要收集关于同一组件的多个信号，我们需要能够根据我们的需求单独调整它们。
- en: The key is to reduce the volume of expensive, but not essential, data, potentially
    replacing it with cheaper options while keeping the system observable. We saw
    how we can do this by combining hot and cold storage or changing the retention
    period in [*Chapter 8*](B19423_08.xhtml#_idTextAnchor131), *Writing Structured
    and Correlated Logs*. Here, let’s focus on the collection side.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是减少昂贵但非必要的数据量，可能用更便宜的选择替换，同时保持系统可观察。我们在[*第8章*](B19423_08.xhtml#_idTextAnchor131)，“编写结构化和关联日志”中看到了如何通过结合热存储和冷存储或更改保留期来实现这一点。在这里，让我们专注于收集方面。
- en: While observability vendors have different pricing models, it’s common for them
    to bill for traces, logs, and events depending on the volume, and for metrics
    depending on the number of time series. Queries (or API calls) can also be charged
    for and may have concurrency limits.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可观察性供应商有不同的定价模式，但它们通常根据数据量对跟踪、日志和事件收费，根据时间序列的数量对指标收费。查询（或API调用）也可能收费，并且可能有并发限制。
- en: 'Of course, we can always add or remove instrumentations or stop writing logs
    and events, but there are a few more factors affecting how much telemetry is collected:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们总是可以添加或删除仪器或停止编写日志和事件，但还有一些其他因素会影响收集遥测数据的数量：
- en: We can control tracing volume with the sampling rate and by adding or removing
    new attributes
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过采样率和添加或删除新属性来控制跟踪量
- en: To control the number of metric time series, we can add or remove resource attributes
    or drop dimensions or instruments
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了控制指标时间序列的数量，我们可以添加或删除资源属性或丢弃维度或仪器
- en: We can tune logging verbosity for individual categories or do so globally and
    add or remove attributes
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调整单个类别的日志详细程度，或者全局调整，并添加或删除属性
- en: Applications’ needs may vary, depending on their maturity, the number of changes,
    the downtime they can afford, and other factors – let’s go through several examples
    to demonstrate possible compromises they can apply.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的需求可能因它们的成熟度、更改的数量、它们可以承受的停机时间以及其他因素而异——让我们通过几个例子来展示它们可以应用的可能的折衷方案。
- en: Building a new application
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建新的应用程序
- en: When writing the first version of an application, telemetry can play a critical
    role in helping teams investigate issues and move faster. The interesting part
    here is that we don’t know which type of telemetry we need and how we’re going
    to use it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写应用程序的第一个版本时，遥测在帮助团队调查问题和加快进度方面可以发挥关键作用。这里有趣的部分是我们不知道需要哪种类型的遥测以及我们将如何使用它。
- en: We can leverage existing instrumentations that allow us to focus our efforts
    on building the application and having all means to debug it as it evolves, while
    also finding answers to questions about telemetry we outlined before.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用现有的仪器，使我们能够专注于构建应用程序，并在其发展过程中拥有所有调试手段，同时找到我们之前概述的遥测问题的答案。
- en: The initial stages are a great time to design the observability story and it
    makes sense to start with the most flexible signals – traces, events, and logs.
    Initially, telemetry volume is likely to be low, so recording traces with a high
    sampling rate or just rate-limiting should be affordable. Also, we probably don’t
    have strict SLAs yet and don’t use dashboards and alerts much.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始阶段，是设计可观察性故事的好时机，并且从最灵活的信号——跟踪、事件和日志开始是有意义的。最初，遥测数据量可能很低，因此以高采样率记录跟踪或仅进行速率限制应该是负担得起的。此外，我们可能还没有严格的SLA，也不太使用仪表板和警报。
- en: Until we get some real users, metrics or events might be unnecessary, but this
    is a good time to experiment and get familiar with them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得一些真实用户之前，指标或事件可能是不必要的，但这是进行实验和熟悉它们的好时机。
- en: Even if the telemetry volume is quite low and we can capture verbose data, we
    should avoid adding excessive amounts of telemetry and should remove unused signals.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使遥测数据量相当低，我们能够捕获详细的数据，我们也应避免添加过多的遥测数据，并应删除未使用的信号。
- en: Evolving applications
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的发展
- en: As our application starts getting some real users, getting performance data
    quickly becomes critical. By this time, we have more clarity on what’s important
    to measure in the application and how to debug issues (hopefully not relying on
    verbose logging).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序开始获得一些真实用户，快速获取性能数据变得至关重要。到这时，我们对应用程序中需要测量的内容以及如何调试问题（希望不是依赖于冗长的日志）有了更多的了解。
- en: This is the time to optimize and tune telemetry collection. As the load grows,
    we usually want to lower the sampling rate for traces and reduce log verbosity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优化和调整遥测收集的时间。随着负载的增长，我们通常希望降低跟踪的采样率并减少日志的冗余。
- en: Also, we would probably need to create alerts and build dashboards that are
    much more efficient when done over metrics, as we discussed in [*Chapter 7*](B19423_07.xhtml#_idTextAnchor115),
    *Adding Custom Metrics*. While instrumentation libraries should cover the basics,
    we might need to add custom metrics where we previously relied on queries over
    traces. As we scale up, the number of time series only increases with the number
    of service instances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能需要创建警报并构建比在[*第7章*](B19423_07.xhtml#_idTextAnchor115)中讨论的基于指标的仪表板和警报更高效的仪表板，正如我们在[*第7章*](B19423_07.xhtml#_idTextAnchor115)中讨论的，*添加自定义指标*。虽然仪器库应该涵盖基础知识，但我们可能需要在之前依赖于跟踪查询的地方添加自定义指标。随着规模的扩大，时间序列的数量仅随着服务实例数量的增加而增加。
- en: At this stage, we might also decide to collect precise and unsampled usage data
    with events and metrics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可能还决定使用事件和指标收集精确且未采样的使用数据。
- en: The application is still changing a lot and we frequently need to investigate
    functional issues for specific requests and optimize requests from the long tail
    of latency. So, tracing still plays a key role in day-to-day work. We might need
    to instrument more layers in the application to capture logical operations or
    add applications-specific context. At the same time, we may find some auto-instrumentations
    too verbose and can tune them to remove unnecessary attributes or suppress some
    spans.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仍在不断变化，我们经常需要调查特定请求的功能性问题并优化来自延迟长尾的请求。因此，跟踪在日常工作中仍然发挥着关键作用。我们可能需要为应用程序的更多层进行仪器化以捕获逻辑操作或添加应用程序特定的上下文。同时，我们可能发现一些自动仪器化过于冗长，可以调整它们以删除不必要的属性或抑制一些跨度。
- en: Sometimes, we need to capture profiles or use diagnostic tools to investigate
    lower-level issues, so having a continuous profiler or adding `dotnet-monitor`
    in a sidecar could make such investigations much easier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要捕获配置文件或使用诊断工具来调查低级问题，因此拥有一个持续的性能分析器或在边车中添加 `dotnet-monitor` 可以使这种调查变得容易得多。
- en: If the application (or some parts of it) becomes more stable due to having fewer
    and fewer issues, it makes sense to remove non-essential traces and reduce the
    sampling rate for stable services or endpoints. Tail-based sampling could help
    capture more traces for failures or long requests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序（或其某些部分）由于问题越来越少而变得更加稳定，那么删除非必要跟踪并减少稳定服务或端点的采样率是有意义的。基于尾部的采样可以帮助捕获更多失败或长时间请求的跟踪。
- en: When the application is not changing anymore except for basic maintenance, but
    more importantly, if it does not have many issues and investigations, it could
    be reasonable to reduce tracing to just incoming and outgoing requests, potentially
    forwarding logs to colder storage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序不再发生变化，除了基本维护之外，更重要的是，如果没有许多问题和调查，那么将跟踪仅限于传入和传出请求，可能将日志转发到较冷的存储，可能是合理的。
- en: Performance-sensitive scenarios
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能敏感场景
- en: Instrumentation introduces performance overhead. Between traces, metrics, and
    logs, traces are the most expensive. When instrumenting an HTTP request, this
    overhead is usually negligible compared to the call itself.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器引入了性能开销。在跟踪、指标和日志之间，跟踪是最昂贵的。在仪器化HTTP请求时，与调用本身相比，这种开销通常是可以忽略不计的。
- en: But in some cases, instrumentation costs can be too high. For example, when
    returning cached responses or rate-limiting requests across all service instances,
    logging or tracing all such calls can significantly impact performance. Moreover,
    if we recorded a trace for every request, a DDOS attack or buggy client might
    kill our observability pipeline, if not the whole service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，仪器成本可能过高。例如，当返回缓存响应或对所有服务实例进行速率限制时，记录或跟踪所有此类调用可能会显著影响性能。此外，如果我们为每个请求都记录了跟踪信息，DDOS攻击或存在错误的客户端可能会破坏我们的可观察性管道，甚至可能影响整个服务。
- en: Tracing overhead, to some extent, can be reduced with sampling, which protects
    the observability pipeline and reduces the number of allocations when populating
    attributes, but a new `Activity` is created and a new `SpanId` is generated, regardless
    of the sampling decision.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采样，在一定程度上可以减少跟踪开销，这可以保护可观察性管道并在填充属性时减少分配的数量，但无论采样决策如何，都会创建一个新的`Activity`并生成一个新的`SpanId`。
- en: 'Adding tracing for a hot path should be done with caution. Keep the number
    of traces to a minimum: trace incoming requests only if the corresponding request
    is going to be processed by your application and avoid tracing outgoing network
    calls to the leaf services if they’re extremely fast or reliable. For example,
    it makes sense to report an event instead of a span when talking to Redis.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于热路径添加跟踪应谨慎进行。尽量减少跟踪的数量：仅当相应的请求将由您的应用程序处理时才跟踪传入请求，并且如果出站网络调用非常快或可靠，则避免跟踪这些调用。例如，与Redis通信时报告事件而不是跨度是有意义的。
- en: Metrics are the most performant telemetry signal and should be preferred for
    a hot path when possible. For example, reporting the Redis call duration as a
    metric with a cache hit/miss dimension would likely be cheaper than an event.
    And for tracing purposes, we can put a hit/miss flag as an attribute on an existing
    current span (for example, one representing an incoming request).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是性能最佳的遥测信号，在可能的情况下应优先选择用于热路径。例如，将Redis调用持续时间作为具有缓存命中/未命中维度的指标报告，可能比事件更便宜。并且对于跟踪目的，我们可以在现有的当前跨度（例如，代表传入请求的一个跨度）上添加一个命中/未命中标志作为属性。
- en: Recording exceptions and errors is usually fine from a performance perspective
    since exceptions create a huge overhead anyway. But in the case of a failure storm,
    we get too many of them, so it’s a good idea to throttle exception reporting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，记录异常和错误通常是可行的，因为异常本身就会产生巨大的开销。但在失败风暴的情况下，我们会得到太多的异常，因此限制异常报告是一个好主意。
- en: Implementing efficient, useful, but minimalistic instrumentation usually requires
    several iterations. Luckily, OpenTelemetry provides a set of semantic conventions
    for common scenarios that can help with it. Let’s see how.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实现高效、有用但简约的仪器通常需要多次迭代。幸运的是，OpenTelemetry提供了一套针对常见场景的语义约定，可以帮助实现这一点。让我们看看如何。
- en: Staying consistent with semantic conventions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持与语义约定的一致性
- en: One of the most important questions we’re yet to discuss is what information
    to add to telemetry signals to make them useful – this is where OpenTelemetry
    semantic conventions come into play.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未讨论的最重要的问题之一是向遥测信号添加哪些信息才能使其有用——这正是OpenTelemetry语义约定发挥作用的地方。
- en: Semantic conventions describe what information to collect for specific technologies,
    such as HTTP or gRPC calls, database operations, messaging scenarios, serverless
    environments, runtime metrics, resource attributes, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 语义约定描述了为特定技术（如HTTP或gRPC调用、数据库操作、消息场景、无服务器环境、运行时指标、资源属性等）收集哪些信息。
- en: Semantic conventions are part of the OpenTelemetry specification and have been
    published in the specification repository at [https://github.com/open-telemetry/opentelemetry-specification](https://github.com/open-telemetry/opentelemetry-specification).
    They apply to all instrumentations authored by the OpenTelemetry project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 语义约定是OpenTelemetry规范的一部分，并已发布在规范存储库[https://github.com/open-telemetry/opentelemetry-specification](https://github.com/open-telemetry/opentelemetry-specification)。它们适用于OpenTelemetry项目编写的所有仪器。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, semantic conventions are in an experimental status.
    The community is actively working on stabilization and the attributes I use in
    this book will likely be renamed or changed in other ways.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，语义约定处于实验状态。社区正在积极努力进行稳定化，本书中使用的属性可能会被重命名或以其他方式更改。
- en: The goal of semantic conventions is to unify telemetry collection for specific
    scenarios or technology across languages, runtimes, and libraries. For example,
    traces and metrics for all HTTP clients look very similar, making it possible
    to visualize or query HTTP telemetry or diagnose problems in the same way for
    any application. Let’s look at HTTP semantic conventions to understand how they
    work and give you an idea of what other conventions look like.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 语义约定的目标是统一特定场景或技术跨语言、运行时和库的遥测收集。例如，所有HTTP客户端的跟踪和指标看起来非常相似，这使得可视化或查询HTTP遥测或以相同方式诊断任何应用程序中的问题成为可能。让我们看看HTTP语义约定，了解它们是如何工作的，并给你一个其他约定看起来如何的印象。
- en: Semantic conventions for HTTP requests
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求的语义约定
- en: The conventions cover tracing and metrics for incoming and outgoing HTTP requests.
    Spans with `client` kind describe outgoing requests, whereas `server` spans describe
    incoming requests. Instrumentations create a new span for each attempt.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定涵盖了入站和出站HTTP请求的跟踪和指标。具有`client`类型的span描述出站请求，而`server`类型的span描述入站请求。仪器为每个尝试创建一个新的span。
- en: '`client` HTTP spans contain attributes that describe the request, response,
    and remote destination. According to the current version, a minimal HTTP client
    instrumentation must report the following attributes: `http.method`, `http.url`,
    `net.peer.name`, `net.peer.port`, and `http.status_code`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`client` HTTP span包含描述请求、响应和远程目的地的属性。根据当前版本，最小HTTP客户端仪器必须报告以下属性：`http.method`、`http.url`、`net.peer.name`、`net.peer.port`和`http.status_code`。'
- en: If a response is not received, the `http.status_code` attribute is not populated;
    instead, the span status would indicate an error and provide a status description
    that explained what happened. The port (`net.peer.port`) attribute may be skipped
    if it’s 80 or 443\. Other attributes are required, so all instrumentations that
    follow conventions must populate them in all scenarios. These attributes, combined
    with the span start timestamp, duration, and status, provide a minimal necessary
    description of the HTTP request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有收到响应，则`http.status_code`属性不会被填充；相反，span状态将指示错误并提供一个状态描述，解释发生了什么。如果端口号（`net.peer.port`）是80或443，则可能会跳过该属性。其他属性是必需的，因此所有遵循约定的仪器都必须在所有场景中填充它们。这些属性与span开始时间戳、持续时间以及状态相结合，提供了HTTP请求的最小必要描述。
- en: All the attributes except `http.status_code` should be provided at the span
    start time – this allows us to make sampling decisions based on these attributes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`http.status_code`之外的所有属性应在span开始时间提供——这允许我们根据这些属性做出采样决策。
- en: You probably noticed that the host and port information is available inside
    the URL and via separate attributes. The URL is a high-cardinality attribute,
    but the host and port are very likely to be of low cardinality, so reporting all
    of them allows us to unify instrumentation code and report traces and metrics
    in one place. It also makes it possible to calculate metrics from traces and simplify
    queries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，主机和端口信息在URL内部以及通过单独的属性中可用。URL是一个高基数属性，但主机和端口很可能具有低基数，因此报告所有这些信息允许我们统一仪器代码，并在一个地方报告跟踪和指标。这也使得从跟踪中计算指标并简化查询成为可能。
- en: Minimal HTTP server instrumentation reports the `http.method`, `http.status_code`,
    `http.scheme`, `http.target`, `net.host.name`, `net.host.port`, and `http.route`
    attributes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最小 HTTP 服务器工具报告了 `http.method`、`http.status_code`、`http.scheme`、`http.target`、`net.host.name`、`net.host.port`
    和 `http.route` 属性。
- en: Since HTTP servers don’t have full URLs readily available, instrumentations
    don’t construct them and report individual URL components instead. Route information
    is provided by an HTTP framework such as ASP.NET Core and even there, you may
    handle requests in middleware without using routing. Reporting route is quite
    important for metrics, as we’ve seen in [*Chapter 7*](B19423_07.xhtml#_idTextAnchor115),
    *Adding Custom Metrics*, so if you don’t have the route available out of the box,
    you might want to provide one manually to distinguish different classes of API
    calls. HTTP client and server instrumentations usually also report recommended
    attributes, such as the `User-Agent` header, request and response content length,
    HTTP protocol version, and remote IP address.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HTTP 服务器没有现成的完整 URL，因此工具不会构建它们，而是报告单个 URL 组件。路由信息由 ASP.NET Core 等HTTP 框架提供，即使在那些框架中，您也可以在中间件中处理请求而不使用路由。报告路由对于指标非常重要，正如我们在[*第
    7 章*](B19423_07.xhtml#_idTextAnchor115)中看到的，*添加自定义指标*，所以如果您没有现成的路由，您可能需要手动提供一个以区分不同类别的
    API 调用。HTTP 客户端和服务器工具通常还会报告推荐属性，例如 `User-Agent` 头部、请求和响应内容长度、HTTP 协议版本和远程 IP 地址。
- en: Conventions also standardize attribute value types – for example, `http.status_code`
    has an integer type, simplifying comparison at query time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 约定还标准化了属性值类型 - 例如，`http.status_code` 具有整型，简化了查询时的比较。
- en: You can find the full HTTP tracing conventions at [https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http)
    找到完整的 HTTP 跟踪约定。
- en: Metrics are based on the same tracing attributes and cover request duration,
    content size, and the number of active requests on servers. The metrics conventions
    are available at [https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics](https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 指标基于相同的跟踪属性，包括请求持续时间、内容大小和服务器上的活动请求数量。指标约定可在 [https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics](https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics)
    找到。
- en: HTTP semantic conventions provide a good set of default things to collect. You
    can move between teams, companies, and web frameworks, or start using a different
    programming language, but OpenTelemetry instrumentations would provide a common
    baseline everywhere.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 语义约定提供了一套很好的默认收集项。您可以在团队、公司、Web 框架之间移动，或者开始使用不同的编程语言，但 OpenTelemetry 工具会在任何地方提供一个共同的基线。
- en: Having a reliable set of required attributes helps the backend visualize traces
    and service maps, build dashboards, and automate analysis and issue detection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一组可靠的必需属性有助于后端可视化跟踪和服务映射，构建仪表板，并自动化分析和问题检测。
- en: General considerations
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般性考虑
- en: When you need to instrument some specific technology or scenario and no suitable
    instrumentation library is available, make sure to also check whether there is
    an applicable semantic convention. By following it, you will be able to leverage
    any experiences built on top of it by your observability backend, prevent inconsistent
    signals coming from different parts of your system, and also save some time designing
    and polishing your signals.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要工具化某些特定的技术或场景，并且没有合适的工具库可用时，请确保还检查是否存在适用的语义约定。遵循它，您将能够利用在可观察性后端之上构建的任何经验，防止来自系统不同部分的信号不一致，并且还可以节省一些设计和完善信号的时间。
- en: But what if you want to instrument something very specific to your application,
    such as adding spans for logical operations or adding usage metrics? Let’s see.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您想对应用程序中非常具体的东西进行工具化，比如添加逻辑操作的跨度或添加使用指标，该怎么办呢？让我们看看。
- en: Tracing
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪
- en: As we’ve seen in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing Your
    Code*, we can create a new `Activity` instance without specifying any parameters.
    By default, it’s named after the caller method and has an `internal` kind.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 6 章*](B19423_06.xhtml#_idTextAnchor098)中看到的，*跟踪您的代码*，我们可以创建一个新的 `Activity`
    实例而不指定任何参数。默认情况下，它以调用方法命名，并具有 `internal` 类型。
- en: OpenTelemetry recommends using low-cardinality span names. HTTP client span
    names follow the `HTTP <method>` pattern (for example, `HTTP GET`), while the
    HTTP server span name looks like `<method> <route>` (for example, `GET /users/{userId}`).
    The span name describes a class of operations and is frequently used to group
    common spans.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry建议使用低基数span名称。HTTP客户端span名称遵循`HTTP <method>`模式（例如，`HTTP GET`），而HTTP服务器span名称看起来像`<method>
    <route>`（例如，`GET /users/{userId}`）。span名称描述了一类操作，并经常用于对常见span进行分组。
- en: 'Another important property is the span kind: it helps backends visualize and
    query traces them. `client` spans represent outgoing requests – their context
    is propagated over the wire, and they become remote parents of `server` spans.
    When instrumenting a remote call, we would typically want to create a new span
    for each attempt so that we know how long an attempt took, how many there were,
    and what the backoff interval was.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的属性是span类型：它有助于后端可视化并查询跟踪它们。`client` span代表出站请求——它们的上下文通过网络传播，并成为`server`
    span的远程父级。在监控远程调用时，我们通常会为每个尝试创建一个新的span，以便我们知道尝试花费了多长时间，有多少个尝试，以及退避间隔是多少。
- en: The `server` spans are those that track incoming requests; they either have
    no parents or have a remote parent.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`server` span是跟踪传入请求的span；它们要么没有父级，要么有一个远程父级。'
- en: OpenTelemetry also defines `consumer` and `producer` kinds – they are used in
    asynchronous scenarios where a request-response pattern is not applicable. A `producer`
    span could be a parent of a `consumer` span (or be linked to it), but it usually
    ends before the corresponding `consumer` span.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry还定义了`consumer`和`producer`类型——它们用于请求-响应模式不适用的异步场景。`producer` span可以是`consumer`
    span的父级（或与之相关联），但它通常在相应的`consumer` span之前结束。
- en: All other spans are `internal`. For example, to represent an I/O operation or
    a local long-running call, we should use the `internal` kind. When instrumenting
    client library calls or logical operations that can do multiple HTTP requests
    underneath, it makes sense to describe them as `internal` spans.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他span都是`internal`。例如，为了表示I/O操作或本地长时间运行的调用，我们应该使用`internal`类型。在监控客户端库调用或可以进行多个HTTP请求的逻辑操作时，将它们描述为`internal`
    span是有意义的。
- en: If an operation ends with an error, we should reflect it with a span status,
    but this can be tricky. For example, HTTP semantic conventions recommend setting
    the status to an error on the client side if a response was not received, there
    were too many redirects, or when the status code was in the 4xx or 5xx ranges.
    But for HTTP servers, a 4xx response does not indicate an error and should be
    left unset. Even for client requests, status codes such as 404 (`Not Found`) do
    not necessarily indicate an error and can be used to check whether some resource
    exists.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个操作以错误结束，我们应该用span状态来反映它，但这可能很棘手。例如，HTTP语义约定建议在客户端未收到响应、存在太多重定向或状态码在4xx或5xx范围内时，将状态设置为错误。但对于HTTP服务器来说，4xx响应并不表示错误，应该保持未设置。即使是客户端请求，状态码如404（未找到）也不一定表示错误，可以用来检查某些资源是否存在。
- en: When recording errors, the status description can be used to record some predictable
    and short information about it, such as its exception type and/or message. Exceptions
    follow their own semantic conventions – we discussed this in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098),
    *Tracing Your Code*. They can be huge (because of stack traces), so we should
    avoid recording handled exceptions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录错误时，状态描述可以用来记录一些可预测的简短信息，例如其异常类型和/或消息。异常遵循它们自己的语义约定——我们曾在[*第6章*](B19423_06.xhtml#_idTextAnchor098)，“追踪你的代码”中讨论过。它们可能非常大（因为堆栈跟踪），因此我们应该避免记录已处理的异常。
- en: Attributes
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性
- en: Application-specific context or details about an operation can be recorded in
    attributes. Before inventing a new attribute name, make sure you check existing
    semantic conventions to see whether something similar is defined there already.
    For example, you can use general network attributes to describe remote destinations
    or host and RPC calls.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用特定的上下文或关于操作的详细信息可以记录在属性中。在发明新的属性名称之前，请确保您检查现有的语义约定，看看是否已经定义了类似的内容。例如，您可以使用通用网络属性来描述远程目的地或主机和RPC调用。
- en: If you must create a new attribute, use a short name that consists of basic
    Latin characters. OpenTelemetry recommends using namespaces to avoid naming collisions
    (they are delimited with the dot (`.`) character) and using `snake_case` to separate
    words. For example, in `http.status_code`, `http` is a namespace. So, if you’re
    defining a new attribute specific to your company, it makes sense to use the company
    name in the namespace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须创建一个新的属性，请使用由基本拉丁字符组成的简短名称。OpenTelemetry建议使用命名空间来避免命名冲突（它们由点（`.`）字符分隔）并使用`snake_case`来分隔单词。例如，在`http.status_code`中，`http`是一个命名空间。因此，如果您正在定义一个针对您公司的特定属性，在命名空间中使用公司名称是有意义的。
- en: The number of attributes per span is limited to 128 by default, but this limit
    can be increased.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个跨度中属性的默认数量限制为128，但这个限制可以被增加。
- en: Keeping consistent names and value types across your system can be challenging,
    so it’s a good idea to come up with some registry to keep them consistent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个系统中保持名称和值类型的一致性可能具有挑战性，因此制定一些注册表以保持它们一致是个好主意。
- en: So, which information would you add to attributes? Anything that describes your
    operation, except sensitive information or secrets. Be cautious with long values
    and avoid adding something that needs to be serialized or calculated – use verbose
    logging for it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您会添加哪些信息到属性中呢？任何描述您操作的信息，除了敏感信息或机密信息。对长值要谨慎，避免添加需要序列化或计算的内容——使用详细日志记录这些内容。
- en: It’s also a good idea to avoid duplication and record a reasonable set of information,
    moving static attributes to resources instead of spans.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 避免重复并记录合理的信息集也是一个好主意，将静态属性移动到资源而不是跨度中。
- en: Metrics
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指标
- en: When creating instruments, we can provide a name, unit, and description.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建仪器时，我们可以提供名称、单位和描述。
- en: Instrument names are case-insensitive and consist of alphanumeric characters,
    underscores, dots, and dashes. Instrument names must be short – up to 63 characters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器名称不区分大小写，由字母数字字符、下划线、点和破折号组成。仪器名称必须简短——最多63个字符。
- en: Instrument names are formatted similarly to attribute names and support namespaces
    – for example, the `http.server.active_requests` counter or the `http.server.duration`
    histogram, which represent the number of active HTTP requests and server-side
    duration of requests, respectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器名称的格式与属性名称类似，并支持命名空间——例如，`http.server.active_requests`计数器或`http.server.duration`直方图，分别代表活动HTTP请求数量和服务器端请求持续时间。
- en: Units usually follow UCUM standards ([https://ucum.org/](https://ucum.org/))
    and it’s important to keep them consistent for the same instrument across the
    whole system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 单位通常遵循UCUM标准([https://ucum.org/](https://ucum.org/))，并且在整个系统中保持它们的一致性是很重要的。
- en: Attribute naming conventions are common between different signals and usually,
    metrics rely on a subset of tracing attributes. The most important characteristic
    of metric attributes is low cardinality, which we described in [*Chapter 7*](B19423_07.xhtml#_idTextAnchor115),
    *Adding* *Custom Metrics*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 属性命名规范在不同信号之间是通用的，通常，指标依赖于跟踪属性的一个子集。指标属性最重要的特征是低基数性，我们在[*第7章*](B19423_07.xhtml#_idTextAnchor115)中描述了这一点，即*添加*
    *自定义指标*。
- en: Before adding custom metrics, make sure to check whether there is an existing
    instrumentation library or an OpenTelemetry semantic convention. For example,
    there is a generic one for RPC requests, process and system resource utilization
    metrics, databases, and other technology-specific ones, such as Kafka.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加自定义指标之前，请确保检查是否存在现有的仪器库或OpenTelemetry语义约定。例如，有一个通用的用于RPC请求、进程和系统资源利用率指标、数据库以及其他特定技术的，如Kafka。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed suggestions and recommendations for telemetry
    collection. To describe some scenario or operation, we usually need multiple signals:
    tracing enables correlation and causation, logs provide additional information
    not covered by traces, events collect usage information, and metrics optimize
    instrumentations, queries, and alerts.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了遥测收集的建议和推荐。为了描述某些场景或操作，我们通常需要多个信号：跟踪使关联和因果关系成为可能，日志提供由跟踪未涵盖的额外信息，事件收集使用信息，而指标优化了仪器、查询和警报。
- en: Depending on your application’s needs and stability, you can control costs by
    tuning the sampling rate on tracing and using metrics for performance data and
    events for usage reports.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您应用程序的需求和稳定性，您可以通过调整跟踪上的采样率和使用指标来控制性能数据和使用报告的事件的成本。
- en: OpenTelemetry semantic conventions provide instrumentation recipes for common
    technologies and concepts. By following them, you can create high-quality instrumentations
    with good defaults that you can tune to your needs. Observability backends can
    provide their best experiences to help you visualize, detect anomalies, and perform
    other semi-automated analyses. For proprietary technologies or application-specific
    instrumentation, where there are no existing conventions, it’s important to follow
    general the OpenTelemetry specification and naming patterns and report telemetry
    consistently across your system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry语义约定为常见技术和概念提供了配置工具。通过遵循它们，你可以创建具有良好默认值的高质量配置，这些默认值可以根据你的需求进行调整。可观察性后端可以提供它们最好的体验，帮助你可视化、检测异常并执行其他半自动分析。对于专有技术或特定于应用程序的配置，在没有现有约定的场合，遵循通用的OpenTelemetry规范和命名模式，并在整个系统中一致地报告遥测数据非常重要。
- en: With this, you should be ready to instrument advanced scenarios with multiple
    signals and provide a rich context while following the available practices. In
    the next chapter, we’re going to apply these skills to instrument gRPC streaming
    calls that are not covered by any existing conventions. Stay tuned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，你应该准备好使用多个信号来配置高级场景，并在遵循现有实践的同时提供丰富的上下文。在下一章中，我们将应用这些技能来配置gRPC流调用，这些调用不受任何现有约定的覆盖。敬请期待。
- en: Questions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you instrument a tiny stateless RESTful microservice with tracing only?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否仅使用跟踪来配置一个微小的无状态RESTful微服务？
- en: When working on an application that processes thousands of requests per second
    on each instance, which sampling rate would you choose?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在处理每个实例每秒处理数千个请求的应用程序上工作时，你会选择什么样的采样率？
- en: Your application communicates with client devices over web sockets. How would
    you approach instrumenting this communication?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序通过WebSockets与客户端设备通信。你将如何处理这种通信的配置？
