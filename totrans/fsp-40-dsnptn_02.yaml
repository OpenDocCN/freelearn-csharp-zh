- en: Chapter 2. Dissecting F# Origins and Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter reviews F# features from the historical perspective tracking them
    back to origins where possible. The review covers:'
  prefs: []
  type: TYPE_NORMAL
- en: F# evolvement timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predecessor inherited language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET imposed language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrinsic F# language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although F# is a functional-first programming language, at the same time, you
    should not forget that it is a multi-paradigm tool that allows paradigms to be
    combined if required. Another important aspect you should keep in mind is that
    F# is designed for a .NET platform, so certain language facilities are shaped
    by underlying implementation mechanisms and interoperability requirements. The
    goal of this chapter is to dissect the language into components in a way that
    allows you to grasp the origins and the logic behind a contemporary F# design.
  prefs: []
  type: TYPE_NORMAL
- en: The evolvement of F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Press began mentioning ([http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language](http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language)
    ) the F# programming language in the Summer of 2002 as a research project at Microsoft
    Research Cambridge ([http://research.microsoft.com/en-us/labs/cambridge/](http://research.microsoft.com/en-us/labs/cambridge/)
    ) aiming to create a dialect of **OCaml** language ([https://ocaml.org/](https://ocaml.org/)
    ) running on top of the .NET platform. Computer scientist Don Syme ([http://research.microsoft.com/en-us/people/dsyme/](http://research.microsoft.com/en-us/people/dsyme/)
    ) was in charge of design and the first implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Predecessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The F# project of Microsoft Research Cambridge didn't come from scratch. F#
    belongs to ML ([https://en.wikipedia.org/wiki/ML_(programming language)](https://en.wikipedia.org/wiki/ML_(programming%20language))
    ) programming language family. It predecessors are Standard ML ([https://en.wikipedia.org/wiki/Standard_ML](https://en.wikipedia.org/wiki/Standard_ML)
    ) and **OCaml** . Moreover, F# initially had a twin project at Microsoft Research
    Cambridge named SML.NET, which aimed at bringing **Standard ** **ML** ( **SML**
    ) to the .NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: F# Version 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first release took place in December of 2004, labelled as a Microsoft Research
    project. This means that at that time, it didn't have the status of a Microsoft
    product, although it was providing integration with Visual Studio 2003 and Visual
    Studio 2005 Beta.
  prefs: []
  type: TYPE_NORMAL
- en: F# Version 1.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Released in October 2005, this version is signified by bringing its object-oriented
    features to the language. It represents the milestone where F# had turned into
    a genuinely multi-paradigm language.
  prefs: []
  type: TYPE_NORMAL
- en: '*"The major addition to the F# language itself in this release is what we''re
    calling the "F# Object and Encapsulation Extensions". This combines what I''ve
    found to be the best features of the .NET object oriented paradigm with the functional
    programming model that lies at the core of F#. This means that F# has become a
    mixed functional/imperative/object-oriented programming language." *Don Syme (*
    [http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx](http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx)
    *) in his blog on August 23, 2005.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another feature that makes version 1.1 ponderous is introducing of F# Interactive,
    also known as FSI, the tool providing F# scripting capabilities and the manner
    of code development by frequenting REPL along the course. This release was suitable
    for use within the final version of Visual Studio 2005.
  prefs: []
  type: TYPE_NORMAL
- en: After the version 1.1 milestone, the language continued to have frequent releases
    and introduce new major features. On October 17, 2007, Microsoft Corp officially
    declared a transition of F# from research to product development organization,
    aiming to productize F# into another first class programming language on the .NET
    platform fully integrated into Visual Studio. Following another year of intensive
    work, in December 2008 came the announcement of F# to be shipped as the integral
    part of Visual Studio 2010.
  prefs: []
  type: TYPE_NORMAL
- en: F# Version 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In February 2010, it was announced that the version of F# to be included into
    Visual Studio 2010 will be incremented to 2.0\. Shortly afterwards, in April 2010,
    F# 2.0 was released, indeed, as part of Visual Studio 2010 and also as the matching
    installation for Visual Studio 2008 and standalone compiler for other platforms.
    The F# version 2.0 milestone reflects almost 5 years of F# 1.x evolvement, which
    has added to object-oriented facilities on top of its functional programming base
    such major language features as active patterns, sequence expressions, asynchronous
    and parallel computations, and significant library refinements. Also, it worth
    noting that integration with Visual Studio provided developers using F# on Microsoft
    platform with world class tooling such as, debugging, IntelliSense, and the project
    system. At this point, F# 2.0 is completely ready for enterprise software development.
  prefs: []
  type: TYPE_NORMAL
- en: Also, F# version 2.0 delineates the stage of language evolvement that is usually
    recognized as *full-fledged* F# in comparison with primordial versions that lack
    some core features.
  prefs: []
  type: TYPE_NORMAL
- en: F# Version 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another intensive year and a half of F# evolvement brought to life a preview
    version of F# 3.0 in the September of 2011\. This version proclaimed targeting
    information-rich programming.
  prefs: []
  type: TYPE_NORMAL
- en: '*"A growing trend in both the theory and practice of programming is the interaction
    between programming and rich information spaces. From databases to web services
    to the semantic web to cloud-based data, the need to integrate programming with
    heterogeneous, connected, richly structured, streaming and evolving information
    sources is ever-increasing. Most modern applications incorporate one or more external
    information sources as integral components. Providing strongly typed access to
    these sources is a key consideration for strongly-typed programming languages,
    to insure low impedance mismatch in information access." *Technical Report MSR-TR-2012-101
    of Microsoft Research* ([http://research.microsoft.com/apps/pubs/?id=173076](http://research.microsoft.com/apps/pubs/?id=173076)
    ).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With this goal, the language acquires query expressions, an incredibly powerful
    mechanism of type providers along with numerous reference implementations of type
    providers for major enterprise information exchange technologies. It took another
    year for F# 3.0 to get released as part of Visual Studio 2012 in September 2012.
  prefs: []
  type: TYPE_NORMAL
- en: The following year, 2013, signified an explosive burst of activity around F#,
    indicating that the language reached some critical mass. Xamarin ([https://xamarin.com](https://xamarin.com)
    ) announced support for F#, reaching multiplatform mobile development, and multiple
    break-through developments took place in the fields of machine learning, cloud
    programming, finance time series, numeric libraries, and type providers.
  prefs: []
  type: TYPE_NORMAL
- en: This period also signifies strong cross-platform open engineering community
    effort, factually turning F# into an open source cross-platform shared implementation
    not fundamentally dependent on Microsoft anymore. The Microsoft affiliation with
    F# got limited to Visual F#, also known as *The F# Tools for Visual Studio* ,
    and even in this space, Microsoft turned to enabling community contributions and
    open engineering.
  prefs: []
  type: TYPE_NORMAL
- en: F# Version 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Announced in late 2014, F# 4.0 provided some new capabilities: type constructors
    were turned into first-class functions, mutable values could be captured by closures,
    and there were high-dimensional arrays, slicing syntax for lists, normalized collections
    in core run-time libraries, among others.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting you equipped with the vision of more than a dozen years of the language's
    exciting historical evolution, I now turn to the dissection of language features.
    In this chapter, these features are to be outlined only briefly, postponing the
    complete details of idiomatic usage to later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Predecessor inherited language features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# inherits the core of the features associated with its functional-first nature
    from ML and OCaml. This means that its chief fashion of expressing computations
    is via the definition and application of functions.
  prefs: []
  type: TYPE_NORMAL
- en: F# functions are first-class entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to define and apply functions is a common feature of many programming
    languages. However, F# follows ML and other functional programming languages in
    treating functions similarly to, say, numeric values. The ways of treating functions
    in F# go well beyond the limits usually associated with stored-program computer
    concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions can be used as arguments to other functions; the latter are higher-order
    functions in this case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be returned from other functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be computed from other functions, for example, with the help of
    function composition operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be elements of structures usually associated with data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are free of side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computations with functions have the main form of *evaluating expressions*  as
    opposed to *making assignments to variables* . Expressions do not carry the stigma
    of ever-changing values stored in rewritable memory. When the function `triple
    x` is applied to argument value `3` , it evaluates some inner expression and returns
    `9.` We are sure that this result is consistent, may be repeatedly reproduced,
    and may change from `9` only if the argument value changes from `3` to something
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can be curried and partially evaluated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currying is a method of converting a function of many arguments evaluation into
    an equivalent evaluation of a sequence of functions of a single argument each.
    Partial evaluation binds one or more first arguments of a curried function, effectively
    producing a new function of fewer (non-bound) arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Functions may be anonymous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why bother giving a name to a function that is passed to a higher-order function
    or is returned from it? For the sake of succinctness F# allows using generic `fun`
    and `function` forms of function definitions that will not be invoked from elsewhere,
    hence the name is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Functions may be recursive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A frequently used example of recursive function ([https://en.wikipedia.org/wiki/Recursive_function](https://en.wikipedia.org/wiki/Recursive_function)
    ) implementation is a divide and conquer algorithm ([https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)
    ) when a problem gets broken into a few of the same problems with less dimensions,
    so the same solving function can be applied. This breaking down continues until
    solutions get simple, and then smaller solutions are combined back to in the solution
    of the original size.
  prefs: []
  type: TYPE_NORMAL
- en: Functions may raise exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not every expression may always bring back a result value; the most beaten up
    example of such a situation is a number divided by zero. Another typical example
    would be invalid argument value that does not allow to return result. In such
    cases instead of returning the result an exception is to be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Functions may reference external values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of an external value freezes it in the function definition, creating
    a so called **closure** .
  prefs: []
  type: TYPE_NORMAL
- en: F# is a statically typed language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expressions and their constituents carry unique types that can be inferred by
    the F# compiler. As a rule, no implicit type conversions have place ever. F# compiler
    type checks programs and catches errors that may otherwise occur at run-time for
    dynamically typed languages.
  prefs: []
  type: TYPE_NORMAL
- en: F# type inference provides type generalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type assignment algorithm performed by the compiler often allows the programmer
    to omit type declarations if the context unambiguously determines them. It finds
    most general type possible for value binding and expression evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: F# supports parametric polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function may allow a generic type of argument(s); for example, the implementation
    of a function calculating the sum of the list elements of `int` , or `int64` ,
    or `bigint` may be the same.
  prefs: []
  type: TYPE_NORMAL
- en: F# inherits the variety of aggregate data structures from ML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inherited data structures include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple or values of the algebraic product type, allowing you to represent values
    of heterogeneous types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list or a finite sequence of zero or more values of the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discriminated union or a custom algebraic sum type defined via a mechanism similar
    to the ML data type, in particular, allows recursive type definition (for example,
    binary tree)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option to represent the absence or the presence of a value of a certain
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A record that is like a tuple with components named rather than ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array, of course
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence, which is implemented as extension of the data type with lazily evaluated
    value constructors in ML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# supports pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is a powerful mechanism of data structure decomposition, allowing
    you to disassemble the data aggregate into components or define the processing
    depending on a particular structure/attributes of the data aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: F# supports data references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data references were introduced in ML in order to support mutable storage and,
    more broadly, imperative programming. F# inherits this feature for backward compatibility
    with ML without reservations. Values of the `ref` type allow you to achieve mutability,
    changing states and representing global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are non-recursive by default
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# follows OCaml in this respect, so recursive function binding should be labeled
    with the `rec` attribute. `let rec` immediately puts the name of the function
    into the scope shadowing the potential duplicate from the outer scope. In absence
    of `rec` attribute `let` puts the name of the function into the scope only after
    the body is fully defined, making the reference either unavailable within the
    function body, or in the worst case using an unintentionally shadowed outer one
    in place of the intended.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following ML and OCaml, F# offers modules as a way of grouping together related
    values, functions, and types. Effectively modules resemble static classes of C#
    and provide developers with means of grouping together, maintaining, and extending
    related entities.
  prefs: []
  type: TYPE_NORMAL
- en: .NET-imposed language features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the features inherited from the language predecessors, the multitude
    of F# features was brought into the language for the sake of interoperability
    with the .NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: F# adheres to .NET Common Language Infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run-time arrangement for the F# code has been defined by .NET **Common ** **Language **
    **Infrastructure** ( **CLI** ) and does not anyhow differ from the same of C#
    or VB.NET. F# compiler ingests F# source code file(s) and produces the intermediate
    code in assembly language named MSIL packaged as binary .NET assembly(ies). During
    code execution stage MSIL is converted into machine code as needed, or **Just-in-time**
    ( **JIT** ). Interoperability with other .NET languages is achieved as F#-produced
    assemblies do not anyhow differ from assemblies produced by C# or VB.NET. Similarly,
    the JIT compiler takes care of the target hardware platform providing portability.
    CLI also takes the burden of memory management on itself, making F# programs subject
    to .NET garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: F# has nominal type system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a significant deviation off OCaml and ML having a structural object
    system. Apparently, this design decision was dictated by the necessity to exist
    within and interact with the .NET object system, which is nominal.
  prefs: []
  type: TYPE_NORMAL
- en: F# fully embraces .NET object orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# allows you to follow the object-oriented paradigm of .NET from both the direction
    of using the existing .NET frameworks and object-oriented libraries as well as
    the direction of contributing F# code in the form of .NET libraries, frameworks,
    and tools.
  prefs: []
  type: TYPE_NORMAL
- en: All F# entities are inherited from a single root type of `System.Object` , or
    `obj` . As such, they come with some common methods that are overridable and customizable.
    For custom F# entities such as discriminated unions, the compiler generates the
    implementation of these common `obj` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the use of .NET classes, F# allows you to create your own custom
    classes consisting of *data* in the form of **fields** and *functions* manipulating
    these fields in the form of **methods** and **properties** . Special methods named
    **constructors** initialize instances of each class assigning certain values to
    fields. Classes may be further parameterized by type parameters getting generic
    this way. A class may inherit from the single **base class** and implement many
    **interfaces** . The subclass may modify the behavior of the base class by *overriding*
    its properties and methods. The custom classes are consumable from other tenants
    of .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: F# requires calling the method of an explicit interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'F# differs from other .NET languages in this matter, so let me explain this
    with a short coding example as following (`Ch2_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `MyImpl` class implements the `MyInterface` interface. However,
    an attempt to use the implementation fails implicitly as if `MyImpl` does not
    have the method at all. Only after the explicit upcast of the `MyImpl` instance
    into `MyInterface` does the implementation get accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The justification of this design decision that comes to my mind is this: it
    would disambiguate situations when there is a need for implementing more than
    one interface that has similarly named methods. Also, this matter gets less annoying
    if we consider typical interface use as in the preceding `doit` function that
    has the `doer` parameter of type `IMyInterface` . In this case, the compiler does
    the cast for using `MyImpl` in place of `IMyInterface` implicitly. The execution
    of the preceding script illustrates this subtlety in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![F# requires calling the method of an explicit interface](img/Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Object expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'F# offers the way to implement an interface without bothering to create a custom
    type just for that purpose. The following code illustrates the implementation
    of `IMyInterface` from the preceding code with an object expression ([https://msdn.microsoft.com/en-us/library/dd233237.aspx](https://msdn.microsoft.com/en-us/library/dd233237.aspx)
    ), followed by the implementation usage (`Ch2_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# completely embraces .NET Reflection, allowing access to the metadata information
    of the program code at run-time. It is possible from F# as well as from other
    .NET languages to introspect the running application and get to type metadata
    and to attributes decorating the source code. The final goal of such exercises
    is usually to modify the run-time behavior of the already executing code. For
    example, the goal might be dynamically adding new components, or resolving dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: F# core library contains the comprehensive tools for run-time analyzing and
    constructing F#-specific types and values within `Microsoft.FSharp.Reflection`
    namespace ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D)
    )
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes and modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# allows a very unobtrusive way to extend classes and modules ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions)
    ). The first form usually referred as **intrinsic extension** is similar to *partial
    classes* of C#. Unfortunately, in F#, this form of class augmentation cannot cross
    boundaries of the source file, namespace, or assembly.
  prefs: []
  type: TYPE_NORMAL
- en: The other form of extension, referred to as **optional extension** , goes through
    source files with ease. Its purpose clearly is augmenting any modules. Although
    much more widely applicable, this type of augmentation is not visible for reflection
    and cannot be utilized outside of F# from C# or VB.NET. We will take a close look
    at these augmentation methods later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerations in F# ([https://msdn.microsoft.com/en-us/library/dd233216.aspx](https://msdn.microsoft.com/en-us/library/dd233216.aspx)
    ) mimic C# enumerations, allowing you to create named numeric constants. As these
    are not discriminated unions, their use with pattern matching is limited. Also,
    they may be of use when manipulating combinations of binary flags.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structures in F# ([https://msdn.microsoft.com/en-us/library/dd233233.aspx](https://msdn.microsoft.com/en-us/library/dd233233.aspx)
    ) are lightweight classes represented with value types. As such, their instances
    can be put on the stack, they take less memory than reference types, and they
    may not be required to participate in garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# events ([https://msdn.microsoft.com/en-us/library/dd233189.aspx](https://msdn.microsoft.com/en-us/library/dd233189.aspx)
    ) allow interoperation with .NET events of CLI. However, F# goes further than
    CLI, providing powerful aggregation, filtering, and partitioning in observer-observable
    and publish-subscribe scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nullable types ([https://msdn.microsoft.com/en-us/library/dd233233.aspx](https://msdn.microsoft.com/en-us/library/dd233233.aspx)
    ) address `null` value related problems that normally do not exist in F# due to
    idiomatic `option` types usage. As a rule, in any internal scenario F# allows
    to cover absence of value with `None` case of correspondent `option` type. However,
    F# code interoperation with C# and VB.NET code as well as low-level database manipulations
    from F# when `option` types cannot be used may require using nullable types instead
    for expressing the absence of values.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperation with the managed code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# and VB.NET using F# code only can access public methods implemented in F#,
    leaving F#-specific data types or functions out of scope. Fortunately, the access
    in the opposite direction is easier as F# supersets C# and VB.NET features.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperation with unmanaged code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to these infrequent cases of interoperation with legacy code or
    the use of libraries written in C/C++, F# follows C# using **P/Invoke** or **COM
    Interop** .
  prefs: []
  type: TYPE_NORMAL
- en: Intrinsic F# language features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with features inherited from F# predecessors, the F# language carries
    its own set of notable novel facilities. The outline of these facilities is discussed
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation-aware syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, this is correct; the F# compiler is sensitive to indentation in the source
    code ([https://msdn.microsoft.com/en-us/library/dd233191.aspx](https://msdn.microsoft.com/en-us/library/dd233191.aspx)
    ), so correct code formatting is not just a matter of aesthetics. Why? Firstly,
    the improved code readability is enforced by the compiler, and secondly, this
    design choice dramatically decreases the amount of noise in the F# source code
    as block markers (such as curly brackets in C#) do not present, overall making
    the F# source code significantly shorter than the equivalent C# one.
  prefs: []
  type: TYPE_NORMAL
- en: Units of measure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This feature ([https://msdn.microsoft.com/en-us/library/dd233243.aspx](https://msdn.microsoft.com/en-us/library/dd233243.aspx)
    ) allows you to decorate values with associated units and statically validate
    unit usage correctness by the compiler as well as infer units associated with
    the expression value based on units of operands. Let us look at the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have defined two measures: `<m>` meters for distance and `<s>` seconds
    for time. Knowing how to find speed from acceleration and distance from physics,
    I defined a `fallSpeed` function to find the speed of objects falling from the
    given argument `height` at the time of hitting the ground as shown in the following
    code (`Ch2_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now using this function, it is easy to find that a water bottle that accidentally
    dropped from the top of the Empire State Building hit the pavement of 5th Avenue
    in New York City with a speed of 86.46 meters per second (`<m/s>` ), hopefully
    not hurting a random bystander from the tourist crowd hanging out near the entrance.The
    following code represents the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the compiler will not allow anything but float decorated with `<m>`
    as the argument for `fallSpeed` . Also, the function correctly infers that units
    of measure for the resulting speed are meters per second. Neat, right? But seriously,
    consider this CNN article back from 1999 titled *Metric mishap caused loss of
    NASA orbiter* ([http://www.cnn.com/TECH/space/9909/30/mars.metric.02/](http://www.cnn.com/TECH/space/9909/30/mars.metric.02/)
    ). The $125 million loss of satellite would not occur if units of measure checks
    were in place. Unfortunately, NASA and Lockheed Martin software systems used for
    the satellite flight control were operating each in its own system of measures
    and integration tests failed to discover this defect prior to the actual flight
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# allows the overloading ([https://msdn.microsoft.com/en-us/library/dd233204.aspx](https://msdn.microsoft.com/en-us/library/dd233204.aspx)
    ) of the existing operators as well as creating new unary and infix operators.
    It allows providing multiplicity of implementations for unary (prefix) and infix
    operations based on concrete types of operands. For example, an implementation
    of rational fractions arithmetic may use three versions of addition operation
    represented by infix operator `+` applicable to adding fraction to integer, integer
    to fraction, and fraction to fraction. Overloading has a positive side allowing
    to express semantic of manipulating objects of some domain tersely. But this feature
    is good in moderation as excessive overloading may be detrimental to code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Inline Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inline functions ([https://msdn.microsoft.com/en-us/library/dd548047.aspx](https://msdn.microsoft.com/en-us/library/dd548047.aspx)
    ) represent a specific compilation technique. Normally a compiled function with
    non-generic type of arguments is associated with a single piece of MSIL and each
    function reference is compiled into invocation of this code and receiving back
    the evaluated result. However, it is impossible to have compiled MSIL for generic
    arguments within .NET type system. F# offers a smart workaround by statically
    evaluating arguments of each specific function invocation and creating MSIL adjusted
    for non-generic argument types of this particular function invocation. By following
    the outlined technique F# achieves function argument generalization under very
    limited support from .NET type system.
  prefs: []
  type: TYPE_NORMAL
- en: Type constraints and statically resolved type parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is sufficient to have genuinely generic function type arguments in only
    very limited number of design and implementation situations . Usually, the addition
    of a custom combination of distinctive additional properties of the argument type
    is required in order to give the F# compiler a way of statically checking whether
    the type generalization is specific enough for the task. In most such cases, type
    inference is smart enough to derive such constraining from the static context,
    but sometimes, it may be desired that the developer provide some extra constraining.
    The process and further details of supplying the additional static constraints
    is described by the link: [https://msdn.microsoft.com/en-us/library/dd233203.aspx](https://msdn.microsoft.com/en-us/library/dd233203.aspx)
    . The book puts this matter under scrutiny in [Chapter 10](text00071.html#ch10
    "Chapter 10. Type Augmentation and Generic Computations") , *Type Augmentation
    and Generic Computations* .'
  prefs: []
  type: TYPE_NORMAL
- en: Active Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Active patterns ([https://msdn.microsoft.com/en-us/library/dd233248.aspx](https://msdn.microsoft.com/en-us/library/dd233248.aspx)
    ) tremendously amplify the power of pattern matching by allowing the usage of
    custom functions within pattern matching rules. In other words, pattern matching
    can be specialized for any desired level of sophistication. Active patterns are
    absolutely essential for mastery over F#, and I will devote a lot of attention
    to them in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Computation Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computation expressions ([https://msdn.microsoft.com/en-us/library/dd233182.aspx](https://msdn.microsoft.com/en-us/library/dd233182.aspx)
    ) represent quite an advanced topic. They provide tools for representation of
    complex nested computations sequenced and bound with simple looking syntax sugar.
    Some of F# language's very own features are implemented with the help of computation
    expressions, namely sequence expressions, query expressions, and asynchronous
    computations. F# also allows you to write custom computation expressions, providing
    tremendous extensibility power.
  prefs: []
  type: TYPE_NORMAL
- en: Query Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query expressions ([https://msdn.microsoft.com/en-us/library/hh225374.aspx](https://msdn.microsoft.com/en-us/library/hh225374.aspx)
    ) represent the language-provided form of computation expressions addressing language
    integrated queries, also known as LINQ in F#. They are a part of mechanics addressing
    the information rich programming I've mentioned earlier, allowing data consumed
    from the multiplicity of sources and in the multiplicity of forms to be manipulated
    uniformly. For example, data obtained off OData service, web service defined with
    WSDL, or SQL server can be transformed to a certain extent without taking into
    consideration the specifics of their origin.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous workflows ([https://msdn.microsoft.com/en-us/library/dd233250.aspx](https://msdn.microsoft.com/en-us/library/dd233250.aspx)
    ) in F# are presented, in a manner similar to query expressions, by a language-provided
    form of computation expressions, and they demonstrate the mechanism's power and
    universal nature. They allow you to execute asynchronous code against implicitly
    provided thread pool at a high level of abstraction from asynchronous computations'
    arrangement details. As a corollary, writing F# asynchronous code is almost as
    simple as synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Meta-programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meta-programming ([https://msdn.microsoft.com/en-us/library/dd233212.aspx](https://msdn.microsoft.com/en-us/library/dd233212.aspx)
    ) is an extremely powerful and exciting technique that allows programs to write
    other programs. It may take different forms and occur at different levels: at
    native machine-level code, at MSIL level, or even at the source code level of
    F# or another programming language. A few years ago, I was quite excited about
    this feature and blogged a short series on this matter: **F# Metaprogramming part
    1: JIT Some Native Code on the Fly** ([https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/](https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/)
    ), **F# Metaprogramming part 2: Dynamic synthesis of executable F# code** ([https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/](https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/)
    ), and **F# Metaprogramming part 3: Creating MSIL on the Fly** ([https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/](https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: However, usually, when developers consider F# meta-programming, a different
    program level is involved, namely F#, but in a partially compiled form associated
    with the language feature known as **quoted expressions** . When the F# compiler
    comes across specifically delimited F# code, then instead of making this code
    part of the program, it compiles it into a special object representing the F#
    expression. The great power of this feature is that when compiled in this manner,
    F# expressions can be further transformed into the form that's good for execution
    in a completely different environment, for example, inside a web browser in the
    form of JavaScript or in some **Graphic** **Processing ** **Unit** ( **GPU** ),
    reaching, in principle, a vast amount of diverse computational platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Type providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type providers ([https://msdn.microsoft.com/en-us/library/hh156509.aspx](https://msdn.microsoft.com/en-us/library/hh156509.aspx)
    ) represent the meta-programming feature as well. However, instead of transforming
    some form of source code into executable form type providers does something completely
    different. A typical type provider represents a data source of certain kind as
    an assortment of types with their methods and properties ready to be seamlessly
    used exactly the same way as human-written types or libraries. It's worth noting
    that the provided types carry the same qualities as the hand-written ones. They
    can be statically checked, introspected by Intellisense, inferred by F# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the SqlClient type provider ([http://fsprojects.github.io/FSharp.Data.SqlClient/](http://fsprojects.github.io/FSharp.Data.SqlClient/)
    ) allows F# developers to get type-safe access to the complete set of features
    of the Microsoft SQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Another fantastically powerful use case for type providers is the interoperability
    between F# and other programming languages. One of the big successes in this field
    is F# R Type Provider ([http://bluemountaincapital.github.io/FSharpRProvider/](http://bluemountaincapital.github.io/FSharpRProvider/)
    ), allowing access from F# to a vast amount of R programming language libraries
    for statistical computing. Using F# in tandem with **R Type Provider** gave a
    big boost to using F# in the fields of machine learning and data science.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter familiarized you with F# features dissected according to origins
    and design motives. You now better understand where the each language feature
    comes from, what features come from the ML breed, what language design decisions
    are dictated by the hosting .NET platform, what features of F# are unique, and
    what the causes for their inclusion into the language were.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with this knowledge, you are now ready to absorb the main contents.
    In the next chapter, I''ll turn to the feature at the core of F#: functions and
    their uses.'
  prefs: []
  type: TYPE_NORMAL
