<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor129"/>4</h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor130"/>Variants of Lists</h1>
<p>In the previous chapter, you learned about arrays and their types. Of course, an array is not the only way of storing data. Another popular and even more powerful group of data structures contains <a id="_idIndexMarker356"/>various variants of <strong class="bold">lists</strong>. In this chapter, you will see such data structures in action, together with illustrations, explanations, and descriptions.</p>
<p>First, you will see a <strong class="bold">simple list</strong> as an array list and a generic list, in which you can easily add and remove elements according to your needs. Then, you will get to know <strong class="bold">sorted lists</strong>, which keep an order of elements. Next, you will learn about four variants of the <strong class="bold">linked list</strong>, namely a singly linked list, a doubly linked list, a circular singly linked list, and a circular doubly linked list. Finally, you will familiarize yourself with three list-related interfaces that you can use while developing applications. Does this sound a bit complicated? If so, don’t worry. You will be guided throughout.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Simple lists</li>
<li>Sorted lists</li>
<li>Linked lists</li>
<li>List-related interfaces<a id="_idTextAnchor131"/></li>
</ul>
<h1 id="_idParaDest-82"><a id="_idTextAnchor132"/>Simple lists</h1>
<p>Arrays are really useful data structures and they are applied in many algorithms. However, in some cases, their application could be complicated due to their nature, which does not <a id="_idIndexMarker357"/>allow you to increase or decrease the length of the already-created array. What should you do if you do not know the total number of elements to store in the collection? Do you need to create a very big array and just not use unnecessary elements? Such a solution does not sound good, does it? A much better approach is to use a data structure that makes it possible to dynamically increase and decrease the size of the collection if necessary.</p>
<p class="callout-heading">Imagine a simple list</p>
<p class="callout">If you want to better visualize a simple list and distinguish it from an array, close your eyes for a moment and try to think back to when you were just a few years old and Christmas was <a id="_idIndexMarker358"/>approaching. You and your family were preparing a chain to hang on the Christmas tree. You took another piece of paper, passed it through the last piece of the chain, and glued the new piece of the chain together. In this way, your chain grew by another element, and you could add more and more elements to the chain, basically endlessly. Well, maybe the limitation was the amount of paper and glue or your tiredness. A list works somewhat similarly, where you can easily add new elements. You can also remove them, just like you can remove a piece of chain and then glue it back together and you can still hang it on your beautiful Christmas tre<a id="_idTextAnchor133"/><a id="_idTextAnchor134"/>e!</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor135"/>Array lists</h2>
<p>The first data <a id="_idIndexMarker359"/>structure that allows you to <code>ArrayList</code> class from the <code>System.Collections</code> namespace. You can use this class to store big collections <a id="_idIndexMarker360"/>of data, to which you can easily add new elements when necessary. Of course, you can also remove them, count items, and find an index of a particular value stored within the array list. How can you do this? Let’s take a look at the following code:</p>
<pre class="source-code">
using System.Collections;
<strong class="bold">ArrayList</strong> arrayList = <strong class="bold">new() { 5 }</strong>;
arrayList.<strong class="bold">Add</strong>(6);
arrayList.<strong class="bold">AddRange</strong>(new int[] { -7, 8 });
arrayList.<strong class="bold">AddRange</strong>(new object[] { "Marcin", "Kate" });
arrayList.<code>ArrayList</code> class is created and <code>5</code> is added as the first element. This can be simplified, as shown here:</p>
<pre class="source-code">
ArrayList arrayList = <code>Add</code>, <code>AddRange</code>, and <code>Insert</code> methods to add new elements to the array list. The difference between them is as follows:</p>
<ul>
<li><code>Add</code> adds a new item at the end of the list</li>
<li><code>AddRange</code> adds a collection of elements at the end of the array list</li>
<li><code>Insert</code> places an element in a specified location within the collection</li>
</ul>
<p>When the <a id="_idIndexMarker361"/>preceding code is executed, the array list contains the following elements: <code>5</code>, <code>6</code>, <code>-7</code>, <code>8</code>, <code>"Marcin"</code>, <code>7.8</code>, and <code>"Kate"</code>. Please keep in mind that all the <a id="_idIndexMarker362"/>items stored within the array list are of the <code>object</code> type. Thus, you can place various types of data in the same collection at the same time.</p>
<p class="callout-heading">Do you need to specify a type?</p>
<p class="callout">Using <code>object</code> instead of a particular type is not always a good idea. So, if you want to specify a type of each element stored within the list, you can use the generic <code>List</code> class, which will be described just after <code>ArrayList</code>. I encourage you to use a strongly typed version of a collection whenever possible.</p>
<p>It is worth mentioning that you can easily access a particular element within the array list using an index, as shown in the following two lines of code:</p>
<pre class="source-code">
object first = arrayList<strong class="bold">[0]</strong>!;
int third = (int)arrayList<code>int</code> in the second line. Such casting is necessary because the array list stores <code>object</code> values. As in the case of arrays, the zero-based indices are used while accessing particular elements within the collection. When you run the preceding lines of code, <code>first</code> will be equal to <code>5</code>, while <code>third</code> will be equal to <code>-7</code>.</p>
<p>Of course, you can use a <code>foreach</code> loop to iterate through all items, as follows:</p>
<pre class="source-code">
<strong class="bold">foreach</strong> (object element in arrayList)
{
     Console.WriteLine(element);
}</pre> <p>That’s not all – the <code>ArrayList</code> class has a set of properties and methods that you can use while developing applications utilizing the aforementioned data structure. To start with, let’s take a look at the <code>Count</code> and <code>Capacity</code> properties:</p>
<pre class="source-code">
int count = arrayList.<strong class="bold">Count</strong>;
int capacity = arrayList.<code>Count</code>) returns the number of elements stored currently in the array list, while the other property (<code>Capacity</code>) indicates how many elements can be stored within it. If you <a id="_idIndexMarker363"/>check the value of the <code>Capacity</code> property after adding <a id="_idIndexMarker364"/>new elements to the array list, you will see that this value is automatically increased to prepare a place for new items. This is shown in the following figure, which presents the difference between <code>Count</code> (marked as <code>A</code>) and <code>Capacity</code> (<code>B</code>):</p>
<div><div><img alt="Figure 4.1 – The difference between Count and Capacity" src="img/B18069_04_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The difference between Count and Capacity</p>
<p>The next common and important task is checking whether the array list contains an element with a particular value. You can perform this operation by calling the <code>Contains</code> method, as shown in the following line of code:</p>
<pre class="source-code">
bool containsMarcin = arrayList.<code>true</code> is returned. Otherwise, <code>false</code> is returned. But how can you find an index of this element? To do so, you can use the <code>IndexOf</code> or <code>LastIndexOf</code> method, as shown in the following line of code:</p>
<pre class="source-code">
int minusIndex = arrayList.<code>IndexOf</code> method returns an index of the first occurrence of the element in the array list, while <code>LastIndexOf</code> returns an index of the last occurrence. If a value is not found, <code>-1</code> is returned by the methods. Thus, you can use <code>IndexOf</code> to check whether the array list contains a given element. If the result is smaller than zero, this means that the element is <a id="_idIndexMarker365"/>not available. On the other hand, if the result is greater than or equal to zero, it indicates that the item is found, as presented in the following line:</p>
<pre class="source-code">
bool containsAnn = arrayList.<code>Remove</code>, <code>RemoveAt</code>, <code>RemoveRange</code>, and <code>Clear</code> methods, as shown here:</p>
<pre class="source-code">
arrayList.<strong class="bold">Remove</strong>(5);
arrayList.<strong class="bold">RemoveAt</strong>(1);
arrayList.<strong class="bold">RemoveRange</strong>(1, 2);
arrayList.<strong class="bold">Clear</strong>();</pre> <p>The difference between the mentioned methods is as follows:</p>
<ul>
<li><code>Remove</code> removes the first occurrence of a given value</li>
<li><code>RemoveAt</code> removes an item with a provided index</li>
<li><code>RemoveRange</code> removes a given number of elements starting from some index</li>
<li><code>Clear</code> removes all elements</li>
</ul>
<p>Among other methods, it is worth mentioning <code>Reverse</code>, which reverses the order of the elements within the array list, as well as <code>ToArray</code>, which returns an array with all items stored in the <code>ArrayList</code> instance.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can <a id="_idIndexMarker367"/>find content regarding<a id="_idIndexMarker368"/> an array list at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist">https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist</a>. </p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor136"/>Generic lists</h2>
<p>As you can see, the <code>ArrayList</code> class contains a broad range of features, but it has a significant <a id="_idIndexMarker369"/>drawback – that is, it is not a strongly typed list. If you want to benefit from a strongly typed list, you can use the generic <code>List</code> class, which represents the <a id="_idIndexMarker370"/>collection whose size can be increased and decreased as necessary. This class is available in the <code>System.Collections.Generic</code> namespace.</p>
<p>The generic <code>List</code> class contains many properties and methods that are useful while developing applications that store data. Many members are named the same as in the <code>ArrayList</code> class. An example is the following two properties:</p>
<ul>
<li><code>Count</code>, which returns the current number of elements in the list</li>
<li><code>Capacity</code>, which indicates how many elements can be currently stored in the list</li>
</ul>
<p>There are also many similar methods, including the following ones:</p>
<ul>
<li><code>Add</code> adds an item at the end of the list</li>
<li><code>AddRange</code> adds a collection of elements at the end of the list</li>
<li><code>Insert</code> places an element in a specified location within the list</li>
<li><code>InsertRange</code> places a collection of items in a specified location in the list</li>
<li><code>Contains</code> checks whether the list contains a given element</li>
<li><code>IndexOf</code> returns an index of the first occurrence of a given item</li>
<li><code>LastIndexOf</code> returns an index of the last occurrence of a given item</li>
<li><code>Remove</code> removes the first occurrence of a given value</li>
<li><code>RemoveAt</code> removes an item with a provided index</li>
<li><code>RemoveRange</code> removes a given number of elements starting from some index</li>
<li><code>Clear</code> removes all elements from the list</li>
<li><code>Reverse</code> reverses the order of items within the list</li>
<li><code>ToArray</code> returns an array with all items stored in the list</li>
</ul>
<p>You can get a particular element from the list using the <code>[]</code> operator with an index.</p>
<p>Apart from <a id="_idIndexMarker371"/>the already-described features, you can use a comprehensive <a id="_idIndexMarker372"/>set of extension methods from the <code>System.Linq</code> namespace. Some of them are as follows:</p>
<ul>
<li><code>Min</code> finds the minimum value in the list</li>
<li><code>Max</code> finds the maximum value in the list</li>
<li><code>Sum</code> returns a sum of all elements in the list</li>
<li><code>Average</code> calculates the average value of elements in the list</li>
<li><code>All</code> checks whether all elements in the list satisfy a condition</li>
<li><code>Any</code> verifies whether at least one element in the list satisfies a condition</li>
<li><code>ElementAtOrDefault</code> returns an element at a given index in the collection or a default value if the index is out of bounds</li>
<li><code>Distinct</code> returns a collection with only unique elements, namely without duplicates</li>
<li><code>OrderBy</code> and <code>OrderByDescending</code> order all elements in the list in ascending or descending order, as well as return the ordered collection</li>
<li><code>Skip</code> returns a collection bypassing a given number of elements in the list</li>
<li><code>Take</code> returns a given number of elements from the list</li>
</ul>
<p>After this theoretical introduction, let’s see such methods in action! First, let’s get the minimum, maximum, sum, and average values from the list, as shown here:</p>
<pre class="source-code">
List&lt;int&gt; list = [6, 90, -20, 0, 4, 1, 8, -20, 41];
int min = list.<strong class="bold">Min</strong>();
int max = list.<strong class="bold">Max</strong>();
int sum = list.<strong class="bold">Sum</strong>();
double avg = list.<code>min</code> is equal to <code>-20</code>, <code>max</code> is equal to <code>90</code>, <code>sum</code> is equal to <code>110</code>, and <code>avg</code> is near <code>12.22</code>.</p>
<p>Now, let’s check out some conditions on the list elements:</p>
<pre class="source-code">
bool allPositive = list.<strong class="bold">All</strong>(x =&gt; x &gt; 0);
bool anyZero = list.<code>allPositive</code> is equal to <code>false</code>, while <code>anyZero</code> to <code>true</code>.</p>
<p>The next <a id="_idIndexMarker373"/>part of the code is shown in the following block:</p>
<pre class="source-code">
int existingElement = list.<strong class="bold">ElementAtOrDefault</strong>(5);
int nonExistingElement = list.<code>ElementAtOrDefault</code> method to get a value of the element with an index equal to <code>5</code> and <code>100</code>. In the first case, <code>1</code> is returned and stored as a value of the <code>existingElement</code> variable. When you try to get an element with the index equal to <code>100</code>, a default value for <code>int</code> is used instead and returned, namely <code>0</code>.</p>
<p>The next extension method is named <code>Distinct</code> and can be used as follows:</p>
<pre class="source-code">
List&lt;int&gt; unique = list.<code>IEnumerable&lt;int&gt;</code> type, which you can convert into <code>List&lt;int&gt;</code> by calling the <code>ToList</code> extension method. The resulting list contains <code>6</code>, <code>90</code>, <code>-20</code>, <code>0</code>, <code>4</code>, <code>1</code>, <code>8</code>, and <code>41</code>.</p>
<p>Let’s order the list using the <code>OrderBy</code> extension method, as follows:</p>
<pre class="source-code">
List&lt;int&gt; ordered = list.<code>-20</code>, <code>-20</code>, <code>0</code>, <code>1</code>, <code>4</code>, <code>6</code>, <code>8</code>, <code>41</code>, and <code>90</code>.</p>
<p>Another interesting group of methods consists of <code>Skip</code> and <code>Take</code>, as shown here:</p>
<pre class="source-code">
List&lt;int&gt; skipped = list.<strong class="bold">Skip</strong>(4).ToList();
List&lt;int&gt; taken = list.<code>Skip</code> method skips <code>4</code> elements and returns the collection with the remaining elements, namely <code>4</code>, <code>1</code>, <code>8</code>, <code>-20</code>, and <code>41</code>.</p>
<p>The <code>Take</code> method simply takes <code>3</code> first elements – that is, <code>6</code>, <code>90</code>, and <code>-20</code>.</p>
<p>Do you have any idea how to combine <code>Skip</code> with <code>Take</code> in some real-world examples? If not, just think <a id="_idIndexMarker375"/>about the <strong class="bold">pagination</strong> mechanism, which you can find on many websites. It allows you to navigate between pages of data, where each page contains a specified number of elements. How you can get such items for a given page? The answer is as follows:</p>
<pre class="source-code">
int page = 1;
int size = 10;
List&lt;int&gt; items = list
    .<strong class="bold">Skip</strong>((page - 1) * size)
    .<strong class="bold">Take</strong>(size)
    .ToList();</pre> <p>Of course, these are <a id="_idIndexMarker376"/>not the only features available for developers while creating <a id="_idIndexMarker377"/>applications using generic lists in the C# language. I strongly encourage you to discover more possibilities on your own. Next, we’ll look at two examples that show how to use a gene<a id="_idTextAnchor137"/>r<a id="_idTextAnchor138"/>ic list in practice.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a generic list at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1</a>.</p>
<h3>Example – average value</h3>
<p>The first example utilizes the generic <code>List</code> class to store floating-point values (of the <code>double</code> type) entered by the user. After typing a number, the average value is calculated and <a id="_idIndexMarker378"/>presented in the console. The program stops the <a id="_idIndexMarker379"/>operation when an incorrect value is entered. The code is as follows:</p>
<pre class="source-code">
<strong class="bold">List&lt;double&gt; num = [];</strong>
do
{
    Console.Write("Enter the number: ");
    string numStr = Console.ReadLine() ?? string.Empty;
    if (!double.TryParse(numStr, out double n)) { break; }
    <strong class="bold">num.Add(n);</strong>
    Console.WriteLine($"Average value: {<strong class="bold">num.Average()</strong>}");
}
while (true);</pre> <p>First, an instance of the <code>List</code> class is created. Then, within the infinite loop (<code>do-while</code>), the program <a id="_idIndexMarker380"/>waits until the user enters a number. If it is correct, the entered <a id="_idIndexMarker381"/>value is added to the list (by calling <code>Add</code>), and an average value from elements in the list is calculated (by calling <code>Average</code>). The result is shown in the console:</p>
<pre class="console">
Enter the number: 10.5
Average value: 10.5 (...)
Enter the number: 15.5
Average value: 9.375</pre> <p>In this section, you saw how to use a list that stores <code>double</code> values. However, can it also store instances of user-defined classes or records? Of course! You will see how to achieve this <a id="_idTextAnchor139"/>g<a id="_idTextAnchor140"/>oal in the next example.</p>
<h3>Example – list of people</h3>
<p>This second example shows you how to use a list to create a very simple database of people. For each, a name, an age, and a country are stored. When the program is launched, some data <a id="_idIndexMarker382"/>of people are added to the list. Then, such data is sorted and presented in the console.</p>
<p>Let’s start <a id="_idIndexMarker383"/>with the declaration of the <code>Person</code> record:</p>
<pre class="source-code">
public record <code>Name</code>, <code>Age</code>, and <code>Country</code>, which stores a country code. In the main part of the code, you create a new instance of the <code>List</code> class and add the data of a few people with different names, ages, and countries, as shown here:</p>
<pre class="source-code">
<strong class="bold">List&lt;Person&gt; people</strong> =
[
    new("Marcin", 35, "PL"),
    new("Sabine", 25, "DE"),
    new("Mark", 31, "PL")
];</pre> <p>In the next line, you sort the list by names of people in ascending order:</p>
<pre class="source-code">
List&lt;Person&gt; r = people.<strong class="bold">OrderBy</strong>(p =&gt; p.Name).ToList();</pre> <p>This line <a id="_idIndexMarker384"/>can be simplified using the collection expression, as follows:</p>
<pre class="source-code">
List&lt;Person&gt; r = <code>foreach</code> loop:</p>
<pre class="source-code">
<strong class="bold">foreach (Person p in r)</strong>
{
    string line = $"{p.Name} ({p.Age}) from {p.Country}.";
    Console.WriteLine(line);
}</pre> <p>After running the program, the following results will be presented:</p>
<pre class="console">
Marcin (35) from PL.
Mark (31) from PL.
Sabine (25) from DE.</pre> <p>That’s all! Now, let’s talk a bit more about the LINQ expressions, which can be used not only to order elements but also to filter items based on the provided criteria, and even more.</p>
<p>As an example, let’s take <a id="_idIndexMarker386"/>a look at the following query, which is using the <strong class="bold">method syntax</strong>:</p>
<pre class="source-code">
List&lt;string&gt; names = people
    .<strong class="bold">Where</strong>(p =&gt; p.Age &lt;= 30)
    .<strong class="bold">OrderBy</strong>(p =&gt; p.Name)
    .<strong class="bold">Select</strong>(p =&gt; p.Name)
    .<code>Select</code> clause) of all people whose age is lower than or equal to <code>30</code> years (the <code>Where</code> clause), ordered by names (the <code>OrderBy</code> clause). The query is then executed and the results are returned as a list (<code>ToList</code>).</p>
<p>The same <a id="_idIndexMarker387"/>task can be accomplished <a id="_idIndexMarker388"/>using the <code>ToList</code> method:</p>
<pre class="source-code">
List&lt;string&gt; names = (<strong class="bold">from</strong> p in people
                      <strong class="bold">where</strong> p.Age &lt;= 30
                      <strong class="bold">orderby</strong> p.Name
                      <code>ArrayList</code> class and the generic <code>List</code> class to store data in collections, the size of which could be dynamically adjusted. However, this is not the end of list-related topics within this chapter. Are you ready to get to know another data structure that maintains the elements in the sorted order? If so, let’s proceed to the next section<a id="_idTextAnchor141"/><a id="_idTextAnchor142"/>, which focuses on sorted lists.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor143"/>Sorted lists</h1>
<p>So far, you’ve learned how to store data using simple lists. However, do you know that you can even <a id="_idIndexMarker390"/>use a data structure that ensures that the elements are sorted all the time? If not, let’s get to know the <code>SortedList</code> generic class (from the <code>System.Collections.Generic</code> namespace), <code>null</code>.</p>
<p class="callout-heading">Imagine a sorted list</p>
<p class="callout">If you want to imagine a sorted list, think about a business holder in which you put business cards that you have received from other people. Since you like order and want to always be able to quickly find a business card for a specific person, you make sure that they are all arranged in alphabetical order, by last name. What a terrible waste of time, especially if you have dozens of business cards and suddenly you have to put in a card for Mrs. Ana Ave. Oh, no... almost all the business cards have to be moved. What can help you at this point is a sorted list! On its basis, your magic business card holder works, which automatically inserts a new business card into the appropriate place in the business card holder. Thanks to this, you always have order and you do not have to waste time constantly taking out and inserting business cards. Congratulations!</p>
<p>You can easily add an element to a sorted list using the <code>Add</code> method, as well as remove a specified item using the <code>Remove</code> method. Among other methods, it is worth noting <code>ContainsKey</code> and <code>ContainsValue</code> for checking whether the collection contains an item with a given key or value, as well as <code>IndexOfKey</code> and <code>IndexOfValue</code> for returning an index of an element by its key or value.</p>
<p>As a sorted list <a id="_idIndexMarker391"/>stores key-value pairs, you have also access to the <code>Keys</code> and <code>Values</code> properties. Particular keys and values can be easily obtained using the <code>[]</code> operator together with an index. As you can see, this data structure is quite similar to the ones that have already been presented. However, it has some significant differences. So, let’s take a look at an example that will show you how to use this data structure. You will also see differences in code compared with th<a id="_idTextAnchor144"/><a id="_idTextAnchor145"/>e previously described <code>List</code> class.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a sorted list at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2</a>.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor146"/>Example – address book</h2>
<p>This example uses the <code>SortedList</code> class to create a very simple address book, which is sorted by <a id="_idIndexMarker392"/>names of people. For each person, the following data is stored: <code>Name</code>, <code>Street</code>, <code>PostalCode</code>, <code>City</code>, and <code>Country</code>. The declaration of the <code>Person</code> record is shown in the following code:</p>
<pre class="source-code">
public record <strong class="bold">Person</strong>(
    string Name,
    string Street,
    string PostalCode,
    string City,
    string Country);</pre> <p>In the main part of the code, you create a new instance of <code>SortedList</code>. You need to specify types for keys and values, namely <code>string</code> and <code>Person</code>. Within the following part of the code, you also initialize the sorted list with data for <code>Marcin</code> and <code>Martyna</code>:</p>
<pre class="source-code">
<strong class="bold">SortedList&lt;string, Person&gt;</strong> people = new()
{
    { "Marcin Jamro", new("Marcin Jamro",
      "Polish Street 1/23", "35-001", "Rzeszow", "PL") },
    { "Martyna Kowalska", new("Martyna Kowalska",
      "World Street 5", "00-123", "Warsaw", "PL") }
};</pre> <p>Then, you can <a id="_idIndexMarker393"/>easily add data to the sorted list by calling the <code>Add</code> method, passing two parameters, namely a key (that is, a name), and a value (that is, an instance of the <code>Person</code> record), as shown in the following code snippet regarding <code>Mark</code>:</p>
<pre class="source-code">
people.<strong class="bold">Add</strong>("Mark Smith", new("Mark Smith",
    "German Street 6", "10000", "Berlin", "DE"));</pre> <p>When all the data is stored within the collection, you can easily iterate through its elements (namely through key-value pairs) using a <code>foreach</code> loop. It is worth mentioning that a type of the variable that’s used in the loop is <code>KeyValuePair&lt;string, Person&gt;</code>. However, you can use a value tuple to get access to a key (<code>k</code>) and a value (<code>p</code>):</p>
<pre class="source-code">
foreach (<strong class="bold">(string k, Person p)</strong> in people)
{
    Console.WriteLine($"{<strong class="bold">k</strong>}: {<strong class="bold">p.Street</strong>}, {<strong class="bold">p.PostalCode</strong>}
        {<strong class="bold">p.City</strong>}, {<strong class="bold">p.Country</strong>}.");
}</pre> <p>When the program is launched, you receive the following result in the console:</p>
<pre class="console">
Marcin Jamro: Polish Street 1/23, 35-001 Rzeszow, PL.
Mark Smith: German Street 6, 10000 Berlin, DE.
Martyna Kowalska: World Street 5, 00-123 Warsaw, PL.</pre> <p>As you can see, the collection is automatically sorted by names, which are used as keys for the sorted list. However, you need to remember that keys must be unique, so you cannot add more than one person with<a id="_idTextAnchor147"/><a id="_idTextAnchor148"/> the same full name in this example.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor149"/>Linked lists</h1>
<p>While using the <code>List</code> generic class, you can easily get access to particular elements of the collection using indices. However, when you get a single element, how can you move to the <a id="_idIndexMarker394"/>next element of the collection? Is it possible? To do so, you may consider the <code>IndexOf</code> method to get an index of the element. Unfortunately, it returns an index of the first occurrence of a given value in the collection, so it will not always work as expected in this scenario. Fortunately, <strong class="bold">linked lists</strong> exist and can help you with this problem! In this section, you will learn about a few variants.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor150"/>Singly linked lists</h2>
<p>A <strong class="bold">singly linked list</strong> is a data <a id="_idIndexMarker395"/>structure in which <strong class="bold">each list element contains a</strong> <strong class="bold">pointer to the next element</strong>. Thus, you can easily <strong class="bold">move from any element to the next one, but you cannot go back</strong>. Of course, the last element in <a id="_idIndexMarker396"/>the list has an empty pointer to the next element because there is nothing more located in the list.</p>
<p class="callout-heading">Imagine a singly linked list</p>
<p class="callout">If you want to better visualize a singly linked list, think about how to represent the phases of human development. Life after birth consists of the neonatal period, infancy, post-infanthood, preschool, school, adolescence, adulthood, and old age. From each phase, you can only go to the next one and you can never go back, even if you try very, very hard. It’s similar to a linked list, where you can easily move from a given item to the next item, but you don’t have any data to return to the item that brought you here. But it would be nice to be able to go back a dozen or so years and repeat some phase of development, right? Unfortunately, there is no “back” button here. :-)</p>
<p>Here’s an example of a singly linked list:</p>
<div><div><img alt="Figure 4.2 – Illustration of a singly linked list" src="img/B18069_04_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Illustration of a singly linked list</p>
<p>Is it possible <a id="_idIndexMarker397"/>to further expand this data structure so that you can both <a id="_idIndexMarker398"/>go forward and backward from a given list element? Of course! Let’s take a look.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor151"/>Doubly linked lists</h2>
<p>A <strong class="bold">doubly linked list</strong> is another <a id="_idIndexMarker399"/>data structure that <strong class="bold">allows you to navigate both forward and backward from each list item</strong>. It can be created <a id="_idIndexMarker400"/>based on the singly linked list by adding a second pointer, namely to the previous element.</p>
<p class="callout-heading">Imagine a doubly linked list</p>
<p class="callout">If you want to better imagine a doubly linked list, open a text editor and start describing your day in it. Whenever you make a mistake, you press the “undo” button and you see the earlier version. You can also press “redo” and suddenly, you see what was in the document just before you undone the changes. Of course, you can perform such an operation many times, and the system remembers many previous and next operations. This is how you can think of a doubly linked list. In each element of the list, you can easily go to both the next element (equivalent to a “redo” operation) and the previous element (equivalent to a “back” operation). Just look how easy it is to find applications for various data structures in everyday life!</p>
<p>The following figure illustrates a doubly linked list:</p>
<div><div><img alt="Figure 4.3 – Illustration of a doubly linked list" src="img/B18069_04_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Illustration of a doubly linked list</p>
<p>As you can see, the <code>FIRST</code> box indicates the first element in the list. Each item has two properties that point to the previous and next element (<code>PREV</code> and <code>NEXT</code>, respectively). If there is no previous element, the <code>PREV</code> property is equal to <code>null</code>. Similarly, when there is no next element, the <code>NEXT</code> property is <a id="_idIndexMarker401"/>set to <code>null</code>. Moreover, the doubly linked list contains the <code>LAST</code> box that indicates the last element. </p>
<p>Do you need <a id="_idIndexMarker402"/>to implement such a data structure on your own if you want to use it in your C#-based applications? Fortunately, no! It is already available as the <code>LinkedList</code> generic class in the <code>System.Collections.Generic</code> namespace. While creating an instance of this class, you need to specify the type parameter that indicates a type of a value stored in each element <a id="_idIndexMarker403"/>in the list, such as <code>int</code> or <code>string</code>.  Each element (also referred to as a <em class="italic">node</em>) is represented by an instance of the <code>LinkedListNode</code> generic class, such as <code>LinkedListNode&lt;int&gt;</code> or <code>LinkedListNode&lt;string&gt;</code>.</p>
<p>Some additional explanation is necessary for the methods of adding new nodes to the doubly linked list. For <a id="_idIndexMarker404"/>this purpose, you can use a set of methods:</p>
<ul>
<li><code>AddFirst</code> adds an element at the beginning of the list</li>
<li><code>AddLast</code> adds an element at the end of the list</li>
<li><code>AddBefore</code> adds an element before the specified node in the list</li>
<li><code>AddAfter</code> adds an element after the specified node in the list</li>
</ul>
<p>All these methods return an instance of the <code>LinkedListNode</code> class. Moreover, there are some <a id="_idIndexMarker405"/>other methods:</p>
<ul>
<li><code>Contains</code> checks whether the specified value exists in the list</li>
<li><code>Remove</code> removes a node from the list</li>
<li><code>Clear</code> removes all elements from the list</li>
</ul>
<p>After this short introduction, let’s take a look at an example that shows how to apply the doubly linked list, im<a id="_idTextAnchor152"/>p<a id="_idTextAnchor153"/>lemented as the <code>LinkedList</code> class, in practice.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a linked list at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1</a>.</p>
<h3>Example – book reader</h3>
<p>As an example, you will <a id="_idIndexMarker406"/>prepare a simple application <a id="_idIndexMarker407"/>that allows a user to read a book by changing pages. The user should be able to move to the next page (if it exists) after pressing the <em class="italic">N</em> key, and go back to the previous page (if it exists) after pressing the <em class="italic">P</em> key. The content of the current page, together with the page number, should be shown in the console, as presented in the screenshot:</p>
<div><div><img alt="Figure 4.4 – Screenshot of the book reader example" src="img/B18069_04_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Screenshot of the book reader example</p>
<p>Let’s start with a declaration of the <code>Page</code> record, as shown in the following code:</p>
<pre class="source-code">
public record <code>Content</code> property. Then, you create a few instances of the <code>Page</code> class, representing six pages of the book:</p>
<pre class="source-code">
Page p1 = new("Welcome to (...)");
Page p2 = new("While reading (...)");
Page p3 = new("As a developer (...)");
Page p4 = new("In the previous (...)");
Page p5 = new("So far, you (...)");
Page p6 = new("The current (...)");</pre> <p>When the <a id="_idIndexMarker408"/>instances have been created, you can <a id="_idIndexMarker409"/>construct the doubly linked list using a few addition-related methods, as shown in the following lines of code:</p>
<pre class="source-code">
<strong class="bold">LinkedList&lt;Page&gt; pages = new();</strong>
pages.<strong class="bold">AddLast</strong>(p2);
LinkedListNode&lt;Page&gt; n4 = pages.<strong class="bold">AddLast</strong>(p4);
pages.<strong class="bold">AddLast</strong>(p6);
pages.<strong class="bold">AddFirst</strong>(p1);
pages.<strong class="bold">AddBefore</strong>(n4, p3);
pages.<strong class="bold">AddAfter</strong>(n4, p5);</pre> <p>In the first line, a new empty list is created. Then, the given operations are performed:</p>
<ol>
<li>Add the second page at the end (<code>[2]</code>).</li>
<li>Add the fourth page at the end (<code>[</code><code>2, 4]</code>).</li>
<li>Add the sixth page at the end (<code>[2, </code><code>4, 6]</code>).</li>
<li>Add the first page at the beginning of the list (<code>[1, 2, </code><code>4, 6]</code>).</li>
<li>Add the third page before the fourth page (<code>[1, 2, 3, </code><code>4, 6]</code>).</li>
<li>Add the fifth page after the fourth page (<code>[1, 2, 3, 4, </code><code>5, 6]</code>).</li>
</ol>
<p>The next part of the code is responsible for presenting a page in the console, as well as for navigating <a id="_idIndexMarker410"/>between pages after pressing the <a id="_idIndexMarker411"/>appropriate keys. The code is as follows:</p>
<pre class="source-code">
<strong class="bold">LinkedListNode&lt;Page&gt; c = pages.First!;</strong>
int number = 1;
while (c != null)
{
    Console.Clear();
    string page = $"- {number} -";
    int spaces = (90 - page.Length) / 2;
    Console.WriteLine(page.PadLeft(spaces + page.Length));
    Console.WriteLine();
    string content = c.Value.Content;
    for (int i = 0; i &lt; content.Length; i += 90)
    {
        string line = content[i..];
        line = line.Length &gt; 90 ? line[..90] : line;
        Console.WriteLine(line.Trim());
    }
    Console.WriteLine($"\nQuote from (...)");
    Console.Write(<strong class="bold">c.Previous != null</strong>
        ? "&lt; PREV [P]" : GetSpaces(14));
    Console.Write(<strong class="bold">c.Next != null</strong>
        ? "[N] NEXT &gt;".PadLeft(76) : string.Empty);
    Console.WriteLine();
    ConsoleKey key = Console.ReadKey(true).Key;
    if (key == ConsoleKey.N &amp;&amp; <strong class="bold">c.Next != null</strong>)
    {
        <strong class="bold">c = c.Next;</strong>
        number++;
    }
    else if (key == ConsoleKey.P &amp;&amp; <strong class="bold">c.Previous != null</strong>)
    {
        <strong class="bold">c = c.Previous;</strong>
        number--;
    }
}</pre> <p>In the first line, the value of the <code>c</code> variable is <a id="_idIndexMarker412"/>set to the first node in the doubly linked list. Generally speaking, the <code>c</code> variable represents the page that is currently <a id="_idIndexMarker413"/>presented in the console. Then, the initial value for the page number is set to <code>1</code> (the <code>number</code> variable). However, the most interesting and complicated part of the code is shown in the <code>while</code> loop.</p>
<p>Within the loop, the current content of the console is cleared and the string for presenting the page number is properly formatted to display. Before and after it, the <code>-</code> characters are added. Moreover, leading spaces are inserted (using the <code>PadLeft</code> method) to prepare the string that is centered horizontally.</p>
<p>Then, the content of the page is divided into lines of no more than <code>90</code> characters and written in the <a id="_idIndexMarker414"/>console. To divide a string, the <code>Length</code> property and the <code>content[i..]</code>. Similarly, additional information is presented in the console. Then, <code>PREV</code> and <code>NEXT</code> captions are shown, if a previous or a next page is available.</p>
<p class="callout-heading">Can you improve this example?</p>
<p class="callout">This example divides the text into a few lines while not taking spaces into account. I encourage you to modify the code so that it supports more user-friendly text wrapping. Good luck!</p>
<p>In the following <a id="_idIndexMarker415"/>part of the code, the program waits <a id="_idIndexMarker416"/>until the user presses any key and does not present it in the console (by passing <code>true</code> as a parameter of <code>ReadKey</code>). When the user presses <em class="italic">N</em>, the <code>c</code> variable is set to the next node, using the <code>Next</code> property. Of course, the operation should not be performed when the next page is unavailable. The <em class="italic">P</em> key is handled similarly, which causes the user to be navigated to the previous page. It is worth mentioning that the number of the page (the <code>number</code> variable) is modified alongside changing the value of the <code>c</code> variable.</p>
<p>Finally, the code of the auxiliary <code>GetSpaces</code> method is shown:</p>
<pre class="source-code">
string <strong class="bold">GetSpaces</strong>(int number) =&gt; string.Join(
    null, Enumerable.Range(0, number).Select(n =&gt; " "));</pre> <p>This prepares and returns<a id="_idTextAnchor154"/> the <code>string</code> variable with the specified number of spaces. Of course, there are several ways to perform this task. However, in this book, I wanted to show you various approaches, even those that are not so typical. The aim is to show you various ways of achieving your goal and making your horizons as broad as possible.</p>
<p>With this, you should be ready to continue your adventure regarding lists. In the next section, y<a id="_idTextAnchor155"/>ou’ll learn about circular lists and their two subtypes.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor156"/>Circular singly linked lists</h2>
<p>In the previous <a id="_idIndexMarker417"/>two sections, you learned about linked lists. As you should remember, in a singly linked list, you can navigate between the <a id="_idIndexMarker418"/>nodes using the <code>Next</code> property. However, the <code>Next</code> property of the last node is set to <code>null</code>. Do you know that you can easily expand this approach to create a <strong class="bold">circular singly linked list</strong>, where <strong class="bold">the last node points to the first element, creating a list that can be </strong><strong class="bold">iterated endlessly?</strong></p>
<p class="callout-heading">Imagine a circular singly linked list</p>
<p class="callout">If you want to better imagine a circular singly linked list, think for a moment about a screensaver showing photos from a specific folder. After a certain period of inactivity, your screen starts showing photos, one after the other. When the last photo is displayed, the first one from the catalog is shown automatically. Of course, you can’t control the photos yourself, because any interaction with the keyboard or mouse turns off the screensaver. A circular singly linked list works similarly. Here, only information about the next list element is saved, without the possibility of going back. The last element of the list takes you to the very beginning. It’s so easy once you can imagine a real-life case, right? Now, move your mouse to make the screensaver disappear, and get back to learning more about data structures and algorithms!</p>
<p>The following <a id="_idIndexMarker419"/>figure illustrates a circular singly linked list:</p>
<div><div><img alt="Figure 4.5 – Illustration of a circular singly linked list" src="img/B18069_04_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Illustration of a circular singly linked list</p>
<p>After this <a id="_idIndexMarker420"/>short introduction to the topic of circular singly linked lists, it is time to take a look at the implementation code. As this data structure is not available by default while developing in C#, you will learn how to implement it on your own, based on a linked list. Let’s start with the following code snippet:</p>
<pre class="source-code">
using System.Collections;
public class <strong class="bold">CircularLinkedList&lt;T&gt;</strong>
    : <strong class="bold">LinkedList&lt;T&gt;</strong>
{
    <strong class="bold">public new IEnumerator GetEnumerator() =&gt;</strong>
        <strong class="bold">new CircularEnumerator&lt;T&gt;(this);</strong>
}</pre> <p>The implementation can be created as a generic class that extends <code>LinkedList</code>, as shown in the preceding code. It is worth mentioning the implementation of the <code>GetEnumerator</code> method, which uses the <code>CircularEnumerator</code> class. By creating it, you will be <a id="_idIndexMarker421"/>able to endlessly iterate through all <a id="_idIndexMarker422"/>the elements of a circular linked list using a <code>foreach</code> loop. The code of <code>CircularEnumerator</code> is as follows:</p>
<pre class="source-code">
public class <strong class="bold">CircularEnumerator&lt;T&gt;</strong>(LinkedList&lt;T&gt; list)
    : IEnumerator&lt;T&gt;
{
    private LinkedListNode&lt;T&gt;? <strong class="bold">_current</strong> = null;
    public T <strong class="bold">Current</strong> =&gt; _current != null
        ? _current.Value
        : default!;
    object <strong class="bold">IEnumerator.Current</strong> =&gt; Current!;
    public bool <strong class="bold">MoveNext</strong>()
    {
        if (_current == null)
        {
            <strong class="bold">_current = list?.First;</strong>
            return _current != null;
        }
        else
        {
            <strong class="bold">_current = _current.Next</strong>
                <strong class="bold">?? _current!.List?.First;</strong>
            return true;
        }
    }
    public void <strong class="bold">Reset</strong>()
    {
        _current = null;
    }
    public void <strong class="bold">Dispose</strong>() { }
}</pre> <p>The <code>CircularEnumerator</code> class implements the <code>IEnumerator</code> interface. This class declares the <code>private</code> field, which represents the current node (<code>_current</code>) in the iteration over the list. It also contains two properties, namely <code>Current</code> and <code>IEnumerator.Current</code>, which are required by the <code>IEnumerator</code> interface.</p>
<p>One of the most important parts of the code is the <code>MoveNext</code> method. This checks whether the <a id="_idIndexMarker423"/>current element is equal to <code>null</code>. If so, it tries to get the first element from the list and starts iterating from it. If it does not exist, the method <a id="_idIndexMarker424"/>returns <code>false</code> since there are no items in the list. If the current element is not equal to <code>null</code>, it changes the current element to the next one or the first node in the list, if the next node is unavailable. In the <code>Reset</code> method, you just set a value of the <code>_current</code> field to <code>null</code>.</p>
<p>Finally, you create the <code>Next</code> extension method that navigates to the first element while trying to get the next element from the last item in the list. To simplify the implementation, such a feature will be available as a method, instead of the <code>Next</code> property. The code is shown here:</p>
<pre class="source-code">
public static class <strong class="bold">CircularLinkedListExtensions</strong>
{
    public static LinkedListNode&lt;T&gt;? <strong class="bold">Next</strong>&lt;T&gt;(
        this LinkedListNode&lt;T&gt; n)
    {
        <strong class="bold">return n != null &amp;&amp; n.List != null</strong>
            <strong class="bold">? n.Next ?? n.List.First</strong>
            <strong class="bold">: null;</strong>
    }
}</pre> <p>The method <a id="_idIndexMarker425"/>checks whether the node exists and whether <a id="_idIndexMarker426"/>the list is available. In such a case, it returns a value of the <code>Next</code> property of the node (if such a value is not equal to <code>null</code>) or returns a reference to the first element in the list using the <code>First</code> property.</p>
<p>That’s all! You’ve just completed the C#-based implementation of a circular singly linked list that you can use in various applications. But how? Let’s take<a id="_idTextAnchor157"/> a look at the following example, which uses this data structure.</p>
<h3>Example – spin the wheel</h3>
<p>This example <a id="_idIndexMarker427"/>simulates a game in which <a id="_idIndexMarker428"/>a user spins a wheel at a random speed. The wheel rotates slower and slower until it stops. Then, the user can spin it again, from the previous stop position, as shown in the following figure:</p>
<div><div><img alt="Figure 4.6 – Illustration of the spin the wheel example" src="img/B18069_04_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Illustration of the spin the wheel example</p>
<p>Let’s proceed to the first part of the code:</p>
<pre class="source-code">
<strong class="bold">CircularLinkedList&lt;string&gt;</strong> categories = new();
categories.<strong class="bold">AddLast</strong>("Sport");
categories.<strong class="bold">AddLast</strong>("Culture");
categories.<strong class="bold">AddLast</strong>("History");
categories.<strong class="bold">AddLast</strong>("Geography");
categories.<strong class="bold">AddLast</strong>("People");
categories.<strong class="bold">AddLast</strong>("Technology");
categories.<strong class="bold">AddLast</strong>("Nature");
categories.<code>CircularLinkedList</code> class is <a id="_idIndexMarker430"/>created, which represents a circular singly linked list with <code>string</code> elements. Then, eight values are added, namely <code>Sport</code>, <code>Culture</code>, <code>History</code>, <code>Geography</code>, <code>People</code>, <code>Technology</code>, <code>Nature</code>, and <code>Science</code>.</p>
<p>The following part of the code performs the most important operations:</p>
<pre class="source-code">
bool isStopped = true;
Random random = new();
DateTime targetTime = DateTime.Now;
int ms = 0;
<strong class="bold">foreach (string category in categories)</strong>
{
    if (isStopped)
    {
        Console.WriteLine("Press [Enter] to start.");
        ConsoleKey key = Console.ReadKey().Key;
        if (key == ConsoleKey.Enter)
        {
            ms = random.Next(1000, 5000);
            targetTime = DateTime.Now.AddMilliseconds(ms);
            isStopped = false;
            <strong class="bold">Console.WriteLine(category);</strong>
        }
        else { return; }
    }
    else
    {
        int remaining = (int)(targetTime
            - DateTime.Now).TotalMilliseconds;
        int waiting = Math.Max(100, (ms - remaining) / 5);
        <strong class="bold">await Task.Delay(waiting);</strong>
        if (DateTime.Now &gt;= targetTime)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            isStopped = true;
        }
        <strong class="bold">Console.WriteLine(category);</strong>
        Console.ResetColor();
    }
}</pre> <p>First, a few variables are declared:</p>
<ul>
<li><code>isStopped</code>, which indicates whether the wheel is currently stopped</li>
<li><code>random</code>, for drawing random values of wheel spin in milliseconds</li>
<li><code>targetTime</code>, which is the target time when the wheel should stop</li>
<li><code>ms</code>, which is the last drawn number of milliseconds for wheel-spinning</li>
</ul>
<p>Then, the <code>foreach</code> loop is used to iterate through all the elements within a circular singly linked list. If there are no <code>break</code> or <code>return</code> instructions within such a loop, it will execute indefinitely due to the nature of a circular linked list. If the last item is reached, the first element in the list is taken automatically in the next iteration.</p>
<p>In this loop, you check <a id="_idIndexMarker431"/>whether the wheel is <a id="_idIndexMarker432"/>currently stopped or has not been started yet. If so, the message is presented to the user and the program waits until the <em class="italic">Enter</em> key is pressed. In such a situation, the new spinning operation is configured by drawing the total time of spinning, setting the expected stop time, indicating that the wheel is not stopped, as well as writing the current category. When the user presses any other key, the program stops its execution.</p>
<p>If the wheel is currently not stopped, you calculate the remaining number of milliseconds and the waiting time. This formula makes it possible to provide smaller times at the beginning (the wheel spins faster) and bigger times at the end (the wheel spins slower). Then, the program waits for the specified number of milliseconds.</p>
<p>At the end, you check whether the target time is reached. If so, the foreground color is changed to red and you indicate that the wheel is stopped. Then, the currently chosen category on the spinning wheel is presented in the console.</p>
<p>When you run the application, you will get the result similar to the following one:</p>
<div><div><img alt="Figure 4.7 – Screenshot of the spin the wheel example" src="img/B18069_04_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Screenshot of the spin the wheel example</p>
<p>With th<a id="_idTextAnchor158"/>at, we’ve <a id="_idIndexMarker433"/>looked at an example <a id="_idIndexMarker434"/>that uses a circular singly linked list. Are you curious whether you can expand it further to create a circular doubly linked list?</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor159"/>Circular doubly linked lists</h2>
<p>The last data <a id="_idIndexMarker435"/>structure we’ll cover in this chapter is named the <strong class="bold">circular doubly linked list</strong>. It is similar to the circular singly linked list but <strong class="bold">allows you not only to iterate indefinitely in the forward direction but also in the backward direction</strong>. You can achieve this by adding pointers to previous elements for <a id="_idIndexMarker436"/>each item in the list. Of course, you also need to point to the last element in the list as the previous element of the first one in the list.</p>
<p class="callout-heading">Imagine a circular doubly linked list</p>
<p class="callout">If you want to better visualize a circular doubly linked list, grab your camera and start browsing the gallery of photos you’ve taken. Here, you can easily go from the first photo to the last one by clicking “back.” You can also go from the last photo to the first one by clicking “next.” Of course, you can also switch between subsequent photos in the photo gallery by clicking “back” and “next.” There is no issue with you taking another photo, at which point it will be added to the collection of photos you’ve already taken. Take a look for yourself! This is how a circular doubly linked list works. Snap, photo taken, and... let’s move on!</p>
<p>A circular <a id="_idIndexMarker437"/>doubly linked list is presented in the <a id="_idIndexMarker438"/>following diagram:</p>
<div><div><img alt="Figure 4.8 – Illustration of a circular doubly linked list" src="img/B18069_04_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Illustration of a circular doubly linked list</p>
<p>Here, the <code>PREV</code> property of the first node navigates to the last one, while the <code>NEXT</code> property of the last node navigates to the first. This data structure can be useful in s<a id="_idTextAnchor160"/>ome specific cases, as you will see while developing a real-world example.</p>
<p>After this short introduction to the topic of circular doubly linked lists, it is time to take a look at the implementation code. If you use the code that’s already been prepared for the circular singly linked list, you only need to add one extension method, as shown here:</p>
<pre class="source-code">
public static class <strong class="bold">CircularLinkedListExtensions</strong>
{
    public static LinkedListNode&lt;T&gt;? Next&lt;T&gt;(
        this LinkedListNode&lt;T&gt; n)
    {
        return n != null &amp;&amp; n.List != null
            ? n.Next ?? n.List.First
            : null;
    }
<strong class="bold">    public static LinkedListNode&lt;T&gt;? Prev&lt;T&gt;(</strong>
<strong class="bold">        this LinkedListNode&lt;T&gt; n)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        return n != null &amp;&amp; n.List != null</strong>
<strong class="bold">            ? n.Previous ?? n.List.Last</strong>
<strong class="bold">            : null;</strong>
<strong class="bold">    }</strong>
}</pre> <p>The <code>Prev</code> method <a id="_idIndexMarker439"/>checks whether the node exists and whether the <a id="_idIndexMarker440"/>list is available. In such a case, it returns a value of the <code>Previous</code> property of the node (if such a value is not equal to <code>null</code>) or returns a reference to the last element in the<a id="_idTextAnchor161"/><a id="_idTextAnchor162"/> list using the <code>Last</code> property. That’s all! Let’s take a look at the example.</p>
<h3>Example – art gallery</h3>
<p>This example <a id="_idIndexMarker441"/>is a viewer of drawings <a id="_idIndexMarker442"/>presented in the console. Does this sound strange? It could be, but let’s try to create some console-based art!</p>
<p class="callout-heading">Real art in the console exists!</p>
<p class="callout">The topic of creating console-based graphics is quite popular and some amazing art has already been created by various authors! If you are curious about this topic, just search for <em class="italic">ASCII arts</em> in your web browser. Will you join this community with your drawings? If so, please share them with me as well!</p>
<p>When a <a id="_idIndexMarker443"/>user presses <em class="italic">the right </em>or<em class="italic"> left arrow</em>, the drawing is changed to the next or the <a id="_idIndexMarker444"/>previous one, respectively. As a result, the following art can be viewed in the console:</p>
<div><div><img alt="Figure 4.9 – ﻿Screenshots of the art gallery example" src="img/B18069_04_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Screenshots of the art gallery example</p>
<p>The code uses the <code>CircularLinkedList</code> class, as shown here:</p>
<pre class="source-code">
string[][] arts = GetArts();
<strong class="bold">CircularLinkedList&lt;string[]&gt; images = new();</strong>
<strong class="bold">foreach (string[] art in arts) { images.AddLast(art); }</strong>
<strong class="bold">LinkedListNode&lt;string[]&gt; node = images.First!;</strong>
ConsoleKey key = ConsoleKey.Spacebar;
do
{
    if (key == ConsoleKey.RightArrow)
    {
        <strong class="bold">node = node.Next()!;</strong>
    }
    else if (key == ConsoleKey.LeftArrow)
    {
        <strong class="bold">node = node.Prev()!;</strong>
    }
    Console.Clear();
    <strong class="bold">foreach (string line in node.Value)</strong>
    <strong class="bold">{</strong>
        <strong class="bold">Console.WriteLine(line);</strong>
    <strong class="bold">}</strong>
}
while ((key = Console.ReadKey().Key) != ConsoleKey.Escape);</pre> <p>You create <a id="_idIndexMarker445"/>a circular doubly linked list consisting of a few elements. Each stores an array of strings. Such an array represents a <a id="_idIndexMarker446"/>particular image, namely the following rows forming the art. When you populate the list with data of all images, you store a reference to the first image as <code>node</code>. Then, you use a <code>do-while</code> loop that is executed until the <em class="italic">Escape</em> button is pressed. If the user presses the right arrow, you update the <code>node</code> variable using the <code>Next</code> method. If the left arrow is pressed, the <code>Prev</code> method is used instead. In each iteration, you clear the console and print the art so that you can receive a simple animation of a dancing figure.</p>
<p>If you are curious how such images are defined, take a look at the following code:</p>
<pre class="source-code">
string[][] <strong class="bold">GetArts</strong>() =&gt; [
    [
        "<strong class="bold">  +-----+  </strong>",
        "<strong class="bold">o-| o o |-o</strong>",
        "<strong class="bold">  </strong><strong class="bold">|  -  |  </strong>",
        "<strong class="bold">  +-----+  </strong>",
        "<strong class="bold">    | |    </strong>"
    ],
    [
        "<strong class="bold">o +-----+  </strong>",
        "<strong class="bold"> \\| o o |\\ </strong>",
        "<strong class="bold">  |  -  | o</strong>",
        "<strong class="bold">  +-----+  </strong>",
        "<strong class="bold">    / |    </strong>"
    ],
    [
        "<strong class="bold">  </strong><strong class="bold">+-----+ o</strong>",
        "<strong class="bold"> /| o o |/ </strong>",
        "<strong class="bold">o |  -  |  </strong>",
        "<strong class="bold">  +-----+  </strong>",
        "<strong class="bold">    | \\    </strong>"
    ]
];</pre> <p>With that, you’ve <a id="_idIndexMarker447"/>learned how to use a circular doubly linked list. In the <a id="_idIndexMarker448"/>final section of this chapter, we’ll learn about three list-related interfaces.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor163"/>List-related interfaces</h1>
<p>While developing <a id="_idIndexMarker449"/>applications in C#, you frequently use various collections, including lists. For this reason, it is worth mentioning three common interfaces:</p>
<ul>
<li><code>IEnumerable</code></li>
<li><code>ICollection</code></li>
<li><code>IList</code></li>
</ul>
<p>The order of them is important because <code>IEnumerable</code> is the base interface for <code>ICollection</code> and <code>IList</code>, while <code>ICollection</code> is the base interface for <code>IList</code>. However, what is inside such interfaces? Let’s take a look!</p>
<p><code>IEnumerable</code> only provides you with a <code>GetEnumerator</code> method.</p>
<p>The <code>ICollection</code> interface <a id="_idIndexMarker450"/>adds the following methods for <strong class="bold">manipulating </strong><strong class="bold">the collection</strong>:</p>
<ul>
<li><code>Add</code> adds a given item to the collection</li>
<li><code>Clear</code> removes all the items from the collection</li>
<li><code>Contains</code> checks whether a given item exists in the collection</li>
<li><code>Remove</code> removes the first occurrence of a given item from the collection</li>
</ul>
<p>It also exposes the <code>Count</code> and <code>IsReadOnly</code> properties, as well as the <code>CopyTo</code> method for copying the collection to an array.</p>
<p>The last interface I’ll mention here is <code>IList</code>. It allows you to <strong class="bold">access items within the collection by an index</strong>. Thus, the interface contains the indexer for getting or setting an item at a specified index in the collection, as well as methods:</p>
<ul>
<li><code>IndexOf</code> returns an index of a given item in the collection</li>
<li><code>Insert</code> inserts a given item at a specified index in the collection</li>
<li><code>RemoveAt</code> removes an item at a specified index in the collection</li>
</ul>
<p>As an example, do you know that the <code>LinkedList</code> generic class implements both generic and non-generic variants of the <code>ICollection</code> and <code>IE</code><code>numerable</code> interfaces? I strongly encourage you to take a look at other collections to see what interfaces are implemented by them. You can see this by clicking on the collection name in your code (such as <code>List</code> or <code>ArrayList</code>) and choosing the <strong class="bold">Go To Definition</strong> option from the context menu or simply by pressing <em class="italic">F12</em>.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding the mentioned interfaces at: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable">https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.icollection">https://learn.microsoft.com/en-us/dotnet/api/system.collections.icollection</a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.ilist">https://learn.microsoft.com/en-us/dotnet/api/system.collections.ilist</a>.</p>
<p>Next, I’ll summarize this chapter.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor164"/>Summary</h1>
<p>This chapter was dedicated to <strong class="bold">lists</strong>, which are among the most common data structures that are used while developing various kinds of applications. However, this topic is not very easy because there are various variants of lists, including simple, sorted, and linked ones. Even this structure can be further divided as you saw while reading this chapter.</p>
<p>First, you learned about <strong class="bold">simple lists</strong>, which can be implemented as an <strong class="bold">array list</strong> or as a <strong class="bold">generic list</strong>. One of the most important differences between them is that the array list is not strongly typed, while the generic list is. You learned about various properties and methods available for these data structures, together with extension methods. Such information was supported by code snippets.</p>
<p>Next, you learned about <strong class="bold">sorted lists</strong>, which ensures a proper order of elements available in the collection. It is a bit of a different data structure but can be useful in various development scenarios. You learned how to use it while creating an address book, which is always sorted by names.</p>
<p>Finally, you took a closer look at linked lists, starting with <strong class="bold">singly linked lists</strong> and <strong class="bold">doubly linked lists</strong>. They allow you to navigate between elements, either in only one direction or in both directions. Such a data structure can be easily extended to a <strong class="bold">circular linked list</strong>, either in singly or doubly linked variants. Therefore, you can benefit from the features of suitable structures without the significant development effort.</p>
<p>The available types of data structures can sound quite complicated. However, in this chapter, you saw detailed descriptions of particular data structures, together with illustrations and C#-based implementations. These should have helped simplify things for you and can be used as a basis for your future projects.</p>
<p>Are you ready to learn other data structures? If so, proceed to the next chapter and read about <strong class="bold">stacks</strong> and <strong class="bold">queues</strong>!</p>
</div>
</body></html>