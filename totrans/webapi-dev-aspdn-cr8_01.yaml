- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Fundamentals of Web APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络API基础
- en: In today’s world, **web APIs** are the backbone of the web. Millions of people
    use web APIs every day to purchase commodities, book a flight, get weather information,
    and more. In this chapter, we will learn about the fundamentals of web APIs. You
    might be wondering why we will start with the fundamental concepts. The answer
    is simple – we need to understand the basic concepts of web APIs before we build
    one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，**网络API**是网络的骨架。每天有成千上万的人使用网络API来购买商品、预订航班、获取天气信息等等。在本章中，我们将学习网络API的基础知识。你可能想知道为什么我们要从基本概念开始。答案很简单——在我们构建一个API之前，我们需要理解网络API的基本概念。
- en: This chapter introduces a couple of different web API styles, such as a REST-based
    API, a **remote procedure call** (**RPC**)-based API, a GraphQL API, and a real-time
    API. We will also learn about how to design them. If you would like to start developing
    a web API, feel free to jump to the next chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几种不同的网络API风格，例如基于REST的API、基于**远程过程调用**（**RPC**）的API、GraphQL API和实时API。我们还将学习如何设计它们。如果你想要开始开发网络API，请随时跳到下一章。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a web API?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是网络API？
- en: What is a REST API?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是REST API？
- en: Designing a REST-based API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计基于REST的API
- en: What are RPC and GraphQL APIs?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC和GraphQL API是什么？
- en: What is a real-time API?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是实时API？
- en: After reading this chapter, you will have a basic understanding of web APIs
    and be able to pick the right style for your project. Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将基本了解网络API，并能够为你的项目选择正确的风格。让我们开始吧！
- en: What is a web API?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是网络API？
- en: '**API** stands for **application programming interface**. A web API, as the
    name suggests, is a set of programming interfaces for the web. For example, when
    you book a flight on a website, the browser makes a request to the airline’s server
    through a web API to access the airline’s database. The airline’s server then
    returns the information about the flight to the browser, allowing you to book
    your flight in it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**代表**应用程序编程接口**。正如其名所示，网络API是一组网络编程接口。例如，当你在一个网站上预订航班时，浏览器通过网络API向航空公司的服务器发出请求，以访问航空公司的数据库。然后，航空公司的服务器将航班信息返回给浏览器，让你能够在其中预订航班。'
- en: APIs have been delivered by organizations for decades. With the appearance of
    the World Wide Web, people needed a way to communicate between the server and
    the client.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 组织已经为几十年提供了API。随着万维网的兴起，人们需要一种在服务器和客户端之间进行通信的方法。
- en: We can build web APIs using different technologies, such as Java, Python, Ruby,
    PHP, .NET, and so on. Also, they have various styles. You might have heard of
    terms such as **SOAP**, **Web Service**, and **REST**. They are all based on the
    **HTTP** protocol but communicate in different ways.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的技术来构建网络API，例如Java、Python、Ruby、PHP、.NET等等。此外，它们还有各种风格。你可能听说过**SOAP**、**Web服务**和**REST**等术语。它们都是基于**HTTP**协议，但以不同的方式进行通信。
- en: In this book, we consider web APIs as a wider concept than REST. In the digital
    world, the way machines communicate with each other changes as either the demands
    or the infrastructure evolves. In the 1990s, people focused on how to improve
    the internal networks that used the same platforms. TCP/IP came to be the standard
    for this kind of communication. After a few years, people needed to find a way
    to optimize communication across multiple platforms. Web Services appeared, and
    they used the **Simple Object Access Protocol** (**SOAP**), which was defined
    for enterprises, and it ensured that programs built on different platforms could
    easily exchange data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将网络API视为比REST更广泛的概念。在数字世界中，随着需求或基础设施的变化，机器之间交流的方式也在变化。在20世纪90年代，人们关注的是如何改进使用相同平台的内部网络。TCP/IP成为了这种通信的标准。几年后，人们需要找到一种方法来优化跨多个平台的通信。Web服务出现了，它们使用了**简单对象访问协议**（**SOAP**），这是为企业定义的，并确保基于不同平台构建的程序可以轻松交换数据。
- en: However, SOAP XML is quite heavy, which means it requires more bandwidth for
    its usage. In the early 2000s, **Windows Communication Foundation** (**WCF**)
    was released by Microsoft. This helped developers manage the complexities of working
    with SOAP. WCF is RPC-based but still uses SOAP as the underlying protocol. Over
    time, some old standards, such as SOAP, have been transitioned to REST APIs, which
    will be discussed in the next section. We will start with REST APIs and then move
    on to the other styles of web-based APIs, such as gRPC APIs, GraphQL APIs, and
    SignalR APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SOAP XML相当庞大，这意味着它在使用时需要更多的带宽。在2000年代初，微软发布了**Windows Communication Foundation**（**WCF**）。这帮助开发者管理使用SOAP的复杂性。WCF基于RPC，但仍然使用SOAP作为底层协议。随着时间的推移，一些旧标准，如SOAP，已经过渡到REST
    API，这将在下一节中讨论。我们将从REST API开始，然后继续讨论其他基于Web的API风格，例如gRPC API、GraphQL API和SignalR
    API。
- en: What is a REST API?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是REST API？
- en: '**REST**, also known as **Representational State Transfer**, is an architectural
    style of web APIs that was created by Roy Fielding in his Ph.D. dissertation *Architectural
    Styles and the Design of Network-based Software Architectures* in 2000\. Today,
    generally speaking, REST APIs are based on HTTP, but actually, Roy Fielding’s
    paper just outlines the core concepts and constraints for understanding an architectural
    style, and it does not require any specific protocol for REST-based architecture,
    such as HTTP. However, since HTTP is the most widely used protocol for web APIs,
    we will use HTTP as the protocol for REST APIs.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**，也称为**表示状态转移**，是由Roy Fielding在2000年他的博士论文《架构风格和网络软件架构设计》中提出的Web API架构风格。今天，一般来说，REST
    API基于HTTP，但实际上，Roy Fielding的论文只是概述了理解架构风格的核心概念和约束，并不要求基于REST的架构有任何特定的协议，如HTTP。然而，由于HTTP是Web
    API中最广泛使用的协议，我们将使用HTTP作为REST API的协议。'
- en: Just keep in mind that REST is just a style, not a rule. When you build a web
    API, you do not have to follow the REST style. You can use any other style you
    like. You can build a web API that works well, but it might not be *REST enough*.
    REST is the recommended style because it helps us establish constraints, which
    contribute to the design of web APIs. It also helps developers easily integrate
    with other REST APIs if they follow the same style.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，REST只是一种风格，而不是规则。当您构建Web API时，您不必遵循REST风格。您可以使用您喜欢的任何其他风格。您可以构建一个运行良好的Web
    API，但它可能不是*足够REST*。REST是推荐的风格，因为它帮助我们建立约束，这有助于Web API的设计。它还帮助开发者如果他们遵循相同的风格，可以轻松地与其他REST
    API集成。
- en: The core concept of REST is the term *representational state transfer*. Think
    about a web system, which is a collection of resources. For example, it might
    have a resource called *books*. The collection of books is a resource. A book
    is a resource too. When you request the list of the books, you select a link (for
    example, [http://www.example.com/books](http://www.example.com/books)), which
    will return a JSON string that contains all the books, resulting in the next resource’s
    representation, such as the link of a specific book (for example, [http://www.example.com/books/1](http://www.example.com/books/1)).
    You can continue to request the book with this link. In this process, the representation
    state is transferred to the client and rendered for the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: REST的核心概念是术语*表示状态转移*。考虑一个Web系统，它是一组资源的集合。例如，它可能有一个名为*books*的资源。书籍的集合是一个资源。一本书也是一个资源。当您请求书籍列表时，您选择一个链接（例如，[http://www.example.com/books](http://www.example.com/books))，这将返回一个包含所有书籍的JSON字符串，从而产生下一个资源的表示，例如特定书籍的链接（例如，[http://www.example.com/books/1](http://www.example.com/books/1))。您可以使用这个链接继续请求书籍。在这个过程中，表示状态被转移到客户端并渲染给用户。
- en: 'There are loads of resources that explain REST. If you would like to know more
    about REST, you can read the following article on Wikipedia: *REST: The Web Framework
    for Representational State* *Transfer* ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解释REST的资源非常多。如果您想了解更多关于REST的信息，可以阅读维基百科上的以下文章：*REST：表示状态转移的Web框架* ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer))。
- en: Let’s take a look at the constraints of REST, following which we will show you
    a simple example of REST APIs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看REST的约束，之后我们将向您展示一个简单的REST API示例。
- en: The constraints of REST
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST的约束
- en: 'Roy Fielding’s paper defines the following six constraints for REST APIs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding的论文为REST API定义了以下六个约束：
- en: '**Client-server**: This pattern enforces the principle of separation of concerns.
    The server and the client act independently. The client sends the request and
    the server responds, following which the client receives and interprets the response.
    The client does not need to know how the server works, and vice versa.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：此模式强制执行关注点分离的原则。服务器和客户端独立操作。客户端发送请求，服务器响应，之后客户端接收并解释响应。客户端不需要知道服务器的工作方式，反之亦然。'
- en: '**Statelessness**: The server does not maintain any state of the client. The
    client should provide the necessary information in the request. This stateless
    protocol is important to scale out the capacity of the server because it does
    not need to remember the session state of the clients.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：服务器不维护任何客户端状态。客户端应在请求中提供必要的信息。这种无状态协议对于扩展服务器的容量很重要，因为它不需要记住客户端的会话状态。'
- en: '**Cacheability**: The response of the server must implicitly or explicitly
    contain information about whether the response is cacheable, allowing the client
    and intermediaries to cache the response. The cache can be performed on the client
    machine in memory, in browser cache storage, or in a **content delivery network**
    (**CDN**). It is also important to improve the scalability and performance of
    web APIs.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存性**：服务器的响应必须隐式或显式地包含有关响应是否可缓存的信息，允许客户端和中间件缓存响应。缓存可以在客户端机器的内存中、浏览器缓存存储中或在
    **内容分发网络**（**CDN**）中执行。这对于提高 Web API 的可扩展性和性能也很重要。'
- en: '**The layered system**: The client does not know how it is connected to the
    server. There may be multiple layers between the client and the server. For example,
    a security layer, a proxy, or a load balancer can be placed between the client
    and the server without impacting the client or server code.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：客户端不知道它如何连接到服务器。客户端和服务器之间可能存在多个层级。例如，可以在客户端和服务器之间放置一个安全层、代理或负载均衡器，而不会影响客户端或服务器代码。'
- en: '**Code on demand (optional)**: The client can request code from the server
    for client-side use. For example, the web browser can request JavaScript files
    to perform some tasks.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码（可选）**：客户端可以从服务器请求用于客户端使用的代码。例如，网络浏览器可以请求 JavaScript 文件以执行某些任务。'
- en: '**Uniform interface**: This one is essential for a RESTful system. It contains
    resource identification, resource manipulation through representations, self-descriptive
    messages, and hypermedia as the engine of the application state. It simplifies
    and decouples the architecture of the system, which enables each part to evolve
    independently.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：这对于 RESTful 系统至关重要。它包含资源标识、通过表示进行资源操作、自描述消息以及作为应用程序状态引擎的超媒体。它简化并解耦了系统的架构，使得每个部分可以独立演进。'
- en: If you feel these principles are a little bit distant or theoretical, let’s
    look at an example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这些原则有点遥远或理论化，让我们来看一个例子。
- en: A REST API example
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API 示例
- en: 'The website [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    is a fake REST API that generates fake JSON data. Open the following link in your
    browser: [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    You will see a JSON string returned:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网站 [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    是一个生成假 JSON 数据的假 REST API。在您的浏览器中打开以下链接：[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)。您将看到一个返回的
    JSON 字符串：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding request, we can get the resource for the collection of the
    posts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的请求中，我们可以获取帖子集合的资源。
- en: 'Now, we can request a specific post by its ID. For example, we can request
    the post with ID `1` using the following URL: [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1).
    The response is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过其 ID 请求特定的帖子。例如，我们可以使用以下 URL 请求 ID 为 `1` 的帖子：[https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1)。响应如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And that’s it! The URLs we used in the preceding examples are the identifiers
    of the resources. The responses (the JSON strings) are the representations of
    the resources. A resource is manipulated through hypertext representations that
    are transferred in messages between clients and servers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在前面的例子中使用的 URL 是资源的标识符。响应（JSON 字符串）是资源的表示。资源通过在客户端和服务器之间传输的消息中的超文本表示来操作。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some documents use URI. A `http`, `https` or `ftp`. Nowadays, the term *URL*
    remains widely used, so, we will use that in this book. However, we should know
    they have different scopes. URI is the superset of URL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文档使用URI。一个 `http`、`https` 或 `ftp`。如今，术语 *URL* 仍然被广泛使用，因此，我们将在这本书中使用它。然而，我们应该知道它们有不同的范围。URI是URL的超集。
- en: 'To get a post resource, we send a `GET` request. There are some other methods
    for manipulating resources, such as `POST`, `PUT`, `PATCH`, and `DELETE`, as shown
    here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取帖子资源，我们发送一个 `GET` 请求。还有一些其他方法用于操作资源，例如 `POST`、`PUT`、`PATCH` 和 `DELETE`，如下所示：
- en: '| **HTTP method** | **URL** | **Operation** | **Description** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **URL** | **操作** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `GET` | `/``posts` | Read | Read the collection of the posts |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/posts` | 读取 | 读取帖子集合 |'
- en: '| `GET` | `/``posts/1` | Read | Read a post by its ID |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/posts/1` | 读取 | 通过ID读取一篇帖子 |'
- en: '| `GET` | `/``posts/1/comments` | Read | Read the comments of the post |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/posts/1/comments` | 读取 | 读取帖子的评论 |'
- en: '| `POST` | `/``posts` | Create | Create a new post |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/posts` | 创建 | 创建一个新的帖子 |'
- en: '| `PUT` | `/``posts/1` | Update | Update a post by its ID |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/posts/1` | 更新 | 通过ID更新帖子 |'
- en: '| `PATCH` | `/``posts/1` | Update (partial) | Update part of a post by its
    ID |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | `/posts/1` | 更新（部分） | 通过ID更新帖子的部分内容 |'
- en: '| `DELETE` | `/``posts/1` | Delete | Delete a post by its ID |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/posts/1` | 删除 | 通过ID删除帖子 |'
- en: Table 1.1 – HTTP methods and URLs for manipulating resources
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 – 操作资源的HTTP方法和URL
- en: There are other methods that are less frequently used, such as `HEAD`, `OPTIONS`,
    and `TRACE`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些不太常用的方法，例如 `HEAD`、`OPTIONS` 和 `TRACE`。
- en: As we can see, the HTTP methods are mapped to the **create, update, read, and
    delete** (**CURD**) operations. But was it always this way?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，HTTP方法映射到 **创建、更新、读取和删除** （**CURD**）操作。但这是否一直如此？
- en: Is my web API RESTful?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的Web API是否是RESTful的？
- en: As already mentioned, REST is not a rule or a specification. There is no *official*
    standard for REST APIs. Contrary to popular opinion, it does not require JSON.
    Furthermore, it does not require the use of CRUD patterns. But REST implementation
    does make use of standards, such as HTTP, URL, JSON, XML, and so on. People apply
    HTTP methods and JSON to implement REST, but they may not intentionally apply
    the constraints as originally described in Fielding’s paper. This leads people
    to disagree on whether their APIs are RESTful or not. Many developers describe
    their APIs as RESTful, even though these APIs do not satisfy all of the constraints
    described in Fielding’s paper.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，REST不是一个规则或规范。没有 *官方* 的REST API标准。与普遍看法相反，它不要求使用JSON。此外，它也不要求使用CRUD模式。但REST实现确实使用了标准，例如HTTP、URL、JSON、XML等。人们应用HTTP方法和JSON来实现REST，但他们可能没有有意地应用Fielding论文中最初描述的约束。这导致人们对他们的API是否是RESTful存在分歧。许多开发者描述他们的API为RESTful，即使这些API并不满足Fielding论文中描述的所有约束。
- en: 'Frankly, it is not beneficial to argue whether a web API is *REST enough* or
    not. The goal is to make something work, rather than wasting time on a discussion
    of this kind of problem. Not everyone has read the original paper. Technology
    also evolves rapidly. There is a Chinese saying: *It doesn’t matter whether it
    is a white cat or a black cat; as long as it catches mice, it is a* *good cat.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，争论一个Web API是否 *足够RESTful* 并没有好处。目标是让某物工作，而不是浪费时间在这种问题的讨论上。并非每个人都阅读了原始论文。技术也在快速发展。有句中国谚语：*不管是白猫还是黑猫，只要能捉老鼠，就是好猫*。
- en: 'However, it would be ideal if we follow conventions when we start a greenfield
    project. Generally, a REST-based API is defined with the following aspects:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们从零开始一个新项目，遵循约定将更加理想。通常，基于REST的API通过以下方面定义：
- en: A base URL, which is the root of the API, such as `http://api.example.com`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础URL，即API的根地址，例如 `http://api.example.com`。
- en: Semantics of HTTP methods, such as `GET`, `POST`, `PUT`, `DELETE`, and so on.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法的语义，例如 `GET`、`POST`、`PUT`、`DELETE` 等。
- en: A media type, which defines state transition data elements, such as `application/json`,
    `application/xml`, and so on.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体类型，它定义了状态转换数据元素，例如 `application/json`、`application/xml` 等。
- en: In this book, we will try to follow these conventions when we develop the REST
    APIs with ASP.NET Core.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将尝试在开发基于ASP.NET Core的REST API时遵循这些约定。
- en: Now that we have had an overview of a REST API, let’s see how to design one
    following the conventions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对REST API有一个概述，让我们看看如何遵循约定来设计一个。
- en: Designing a REST-based API
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计基于REST的API
- en: To build a REST-based API, there are many steps to take before we write code.
    The development team needs to communicate with stakeholders and analyze the requirements.
    Then, they need to write user stories (or job stories) to define the desired outcomes.
    This requires the insights of domain experts or subject matter experts. We will
    not cover this part in this book. Instead, next, we will focus on the API design,
    which is closer to what developers do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，构建基于REST的API有许多步骤要走。开发团队需要与利益相关者沟通并分析需求。然后，他们需要编写用户故事（或工作故事）来定义期望的结果。这需要领域专家或主题专家的见解。本书不会涵盖这部分内容。相反，接下来，我们将专注于API设计，这更接近开发者所做的工作。
- en: In the past few years, the concept of **API-first** has gained more traction.
    The API-first approach means that the APIs are treated as first-class citizens
    for your project. This creates a contract for how the API is supposed to behave
    before any code is written. In this way, the development teams can work in parallel
    because the contract will be established first. Developers do not have to wait
    for the API to be released before integrating with frontend or mobile apps. They
    can mock and test the APIs based on the contract. Using tools such as **Swagger**,
    the process of building APIs can be automated, such as API documentation, mock
    APIs, SDKs, and so on. Automation can significantly speed up the development of
    APIs and applications, which helps to increase the speed to market.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，**API优先**的概念获得了更多的关注。API优先的方法意味着API被视为项目的第一公民。这意味着在编写任何代码之前，API应该如何表现已经有一个合同。这样，开发团队可以并行工作，因为合同将首先建立。开发者不必等待API发布就可以与前端或移动应用集成。他们可以根据合同模拟和测试API。使用像**Swagger**这样的工具，构建API的过程可以自动化，例如API文档、模拟API、SDK等。自动化可以显著加快API和应用程序的开发速度，有助于提高上市速度。
- en: 'Here are some steps we can follow to design a REST-based API:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些我们可以遵循的步骤来设计基于REST的API：
- en: Identify the resources.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定资源。
- en: Define the relationships between resources.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义资源之间的关系。
- en: Identify operation events.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别操作事件。
- en: Design the URL paths for resources.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为资源设计URL路径。
- en: Map API operations to HTTP methods.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将API操作映射到HTTP方法。
- en: Assign response codes.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配响应代码。
- en: Document the API.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录API。
- en: If you are familiar with the preceding steps, you can skip them. However, if
    you are not, read the following sections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉前面的步骤，你可以跳过它们。但是，如果你不熟悉，请阅读以下章节。
- en: A popular API description format is **OpenAPI Specification** (**OAS**). We
    can use it to describe API modeling and other details of an API. We do not need
    to include the implementation details at this stage, because we just want to make
    a contract. SwaggerHub ([https://app.swaggerhub.com/home](https://app.swaggerhub.com/home))
    is a tool we can use to design an API.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的API描述格式是**OpenAPI规范**（**OAS**）。我们可以用它来描述API建模和其他API的细节。在这个阶段，我们不需要包括实现细节，因为我们只想制定一个合同。SwaggerHub
    ([https://app.swaggerhub.com/home](https://app.swaggerhub.com/home)) 是一个我们可以用来设计API的工具。
- en: Identifying the resources
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定资源
- en: REST-based APIs center on resources. A resource is a collection of data, such
    as a collection of posts or a collection of users. A resource is identified by
    a URL. The client requests a resource using the URL, and the server responds with
    a representation of the resource. The representation of the resource is sent in
    the hypertext format, which can be interpreted by the widest possible range of
    clients.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基于REST的API以资源为中心。资源是一组数据，例如帖子集合或用户集合。资源通过URL进行标识。客户端使用URL请求资源，服务器以资源表示的形式响应。资源的表示以超文本格式发送，可以被尽可能广泛的客户端解释。
- en: It is important to identify the scope of the domain and the relationships between
    the resources. For example, if you are building a blog system, you may have a
    collection of posts, and each post has a collection of comments. The scope of
    an API may evolve as time goes by. More resources may be added to the current
    domain, or some resources will be removed. Also, relationships may change.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 识别领域范围和资源之间的关系非常重要。例如，如果你正在构建一个博客系统，你可能有一个帖子集合，每个帖子都有一个评论集合。API的范围可能会随着时间的推移而演变。可能需要向当前领域添加更多资源，或者某些资源将被删除。此外，关系也可能发生变化。
- en: 'Let’s start small. We can use the blog system as an example. After the requirement
    analysis, we can identify the following resources:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始。我们可以用博客系统作为例子。在需求分析之后，我们可以确定以下资源：
- en: Posts
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子
- en: Categories
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类
- en: Comments
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释
- en: Users
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Tags
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: You may want to include some properties of each resource in this step. For example,
    a post has a title, a body, and a published datetime. A comment has a body, a
    publish datetime. A user has a name and an email. You may find more properties
    during development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在这一步包括每个资源的某些属性。例如，一个帖子有一个标题、正文和发布时间。一个评论有一个正文和发布时间。一个用户有一个名字和电子邮件。在开发过程中，您可能会发现更多属性。
- en: Defining the relationships between resources
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义资源之间的关系
- en: Once the resources are identified, we can define the relationships between them.
    For example, a post has a collection of comments. A comment has a post. A user
    has a collection of posts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了资源，我们就可以定义它们之间的关系。例如，一个帖子有一个评论集合。一个评论属于一个帖子。一个用户有一个帖子集合。
- en: The relationship is defined by how these resources relate to each other. Sometimes,
    these relationships exist in the database as well, but sometimes, they are specific
    to the REST resources only.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系是通过这些资源如何相互关联来定义的。有时，这些关系在数据库中也存在，但有时，它们仅针对REST资源。
- en: 'There are some terms we can use to describe the relationships:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些术语来描述这些关系：
- en: '**Independent resource**: This resource can exist independently. It does not
    require another resource to exist. An independent resource can reference other
    independent or dependent resources. For example, a post is an independent resource,
    and it can reference its author. The authors resource is also an independent resource.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立资源**：这种资源可以独立存在。它不需要另一个资源存在。一个独立资源可以引用其他独立或依赖资源。例如，一个帖子是一个独立资源，它可以引用其作者。作者资源也是一个独立资源。'
- en: '**Dependent resource**: This resource requires another resource to exist. It
    can still reference other independent or dependent resources, but it cannot exist
    without the existence of the parent resource. For example, a comment requires
    a post as its parent resource; otherwise, it cannot exist. A comment can reference
    its author, which is an independent resource.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖资源**：这种资源需要另一个资源存在。它可以引用其他独立或依赖资源，但不能在没有父资源存在的情况下存在。例如，一个评论需要一个帖子作为其父资源；否则，它不能存在。一个评论可以引用其作者，这是一个独立资源。'
- en: '`Id` property, which can uniquely identify itself.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id` 属性，它可以唯一地识别自身。'
- en: '`PostId` property, which references a post.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostId` 属性，它引用了一个帖子。'
- en: 'There are three relationship types that these resources can have:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源可以有以下三种关系类型：
- en: '**One-to-many**: This is when a resource has many related resources. For example,
    a user has many posts, but a post has only one author. This is also called the
    *parent-child (children)* relationship, which is the most common pattern for relationships
    we can see in the REST-based API world.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**：这是指一个资源有多个相关资源。例如，一个用户有多个帖子，但一个帖子只有一个作者。这也被称为*父子（子）*关系，这是在基于REST的API世界中可以看到的最常见的模式。'
- en: '**One-to-one**: This is when a resource has one related resource. For example,
    a post has a single author, and one house has only one address. The one-to-one
    relationship is a special case of the one-to-many relationship.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：这是指一个资源有一个相关资源。例如，一个帖子有一个唯一的作者，一栋房子只有一个地址。一对一关系是一对多关系的特例。'
- en: '**Many-to-many**: This is when a resource has many related resources and vice
    versa. For example, a blog has many tags, and a tag has many blogs. A movie can
    have many genres, and a genre can have many movies. In many systems, a user can
    have many roles, and a role can have many users.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**：这是指一个资源有多个相关资源，反之亦然。例如，一个博客有多个标签，一个标签也有多个博客。一部电影可以有多个类型，一个类型也可以有多个电影。在许多系统中，一个用户可以有多个角色，一个角色也可以有多个用户。'
- en: Identifying operations
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别操作
- en: Next, we can think about what operations are needed for each resource. These
    operations may come from user stories that are defined beforehand. Generally,
    each resource has its CRUD operations. Note that the operations may include more
    beyond CRUD. For example, a post can be published, or it can be unpublished. A
    comment can be approved, or it can be rejected. During this process, we may need
    to create a new resource or property to reflect the operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以考虑每个资源需要的操作。这些操作可能来自事先定义的用户故事。通常，每个资源都有其CRUD操作。请注意，操作可能包括CRUD之外的内容。例如，一个帖子可以被发布，或者可以被取消发布。一个评论可以被批准，或者可以被拒绝。在这个过程中，我们可能需要创建一个新的资源或属性来反映这个操作。
- en: It is important to consider the scope of the domain. CRUD operations are easy
    to understand, but for some complicated relationships, we may need help from domain
    experts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑域的范围很重要。CRUD操作容易理解，但对于一些复杂的关系，我们可能需要来自领域专家的帮助。
- en: When we work on these operations, we need to include important input and output
    details. We will use them in the next steps. However, it is not necessary to include
    all the details of each resource. We have enough time later to capture the complete
    design.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理这些操作时，需要包括重要的输入和输出细节。我们将在下一步中使用它们。然而，没有必要包括每个资源的所有细节。我们以后有足够的时间来捕捉完整的设计。
- en: 'For the example of the blog system, we can identify these operations for the
    `Post` resource (including but not limited to the following):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于博客系统的示例，我们可以为 `Post` 资源（包括但不限于以下）识别这些操作：
- en: '| **Operation name** | **Resource(s)** | **Input** | **Output** | **Description**
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **资源(s)** | **输入** | **输出** | **描述** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `createPost()` | `Post, category,` `user, tag` | Post detail |  | Create
    a new post |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `createPost()` | `Post, category,` `user, tag` | Post detail |  | 创建新帖子 |'
- en: '| `listPosts()` | `Post` |  | A list of posts | List all posts |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `listPosts()` | `Post` |  | 一系列帖子 | 列出所有帖子 |'
- en: '| `listPostsByCategory()` | `Post` `and category` | Category ID | A list of
    posts | List posts by category |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByCategory()` | `Post` `and category` | Category ID | 一系列帖子 | 按类别列出帖子
    |'
- en: '| `listPostsByTag()` | `Post` `and tag` | Tag or Tag ID | A list of posts |
    List posts by tag |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByTag()` | `Post` `and tag` | Tag or Tag ID | 一系列帖子 | 按标签列出帖子 |'
- en: '| `searchPosts()` | `Post` | Search keyword | A list of posts | Search for
    Posts by title, author, and content |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `searchPosts()` | `Post` | Search keyword | A list of posts | 通过标题、作者和内容搜索帖子
    |'
- en: '| `viewPost()` | `Post, category,` `and user` | Post ID | Post detail | View
    a post detail |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `viewPost()` | `Post, category,` `and user` | Post ID | Post detail | 查看帖子详情
    |'
- en: '| `deletePost()` | `Post` | Post ID |  | Delete a post |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `deletePost()` | `Post` | Post ID |  | 删除帖子 |'
- en: '| `updatePost()` | `Post` `and category` | Post detail |  | Update a post |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `updatePost()` | `Post` `and category` | Post detail |  | 更新帖子 |'
- en: '| `publishPost()` | `Post` | Post ID |  | Publish a post |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `publishPost()` | `Post` | Post ID |  | 发布帖子 |'
- en: '| `unpublishPost()` | `Post` | Post ID |  | Unpublish a post |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `unpublishPost()` | `Post` | Post ID |  | 下线帖子 |'
- en: Table 1.2 – Operations for the Post resource
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2 – 帖子资源的操作
- en: For some operations, such as `createPost` and `deletePost`, the output is the
    results of the operation. This can be represented with the HTTP status code. We
    will discuss this later.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '对于某些操作，如 `createPost` 和 `deletePost`，输出是操作的结果。这可以用HTTP状态码表示。我们将在稍后讨论这个问题。 '
- en: We can list more operations for other resources as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为其他资源列出更多操作。
- en: Designing the URL paths for resources
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计资源URL路径
- en: The next step is to design the URL paths for each resource. The clients use
    URLs to access the resources. Even though REST is not a standard, there are some
    guidelines or conventions for designing URL paths.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设计每个资源的URL路径。客户端使用URL来访问资源。尽管REST不是一个标准，但在设计URL路径方面有一些指南或约定。
- en: Using nouns instead of verbs
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名词而不是动词
- en: The operation events we identified in the previous step are some actions, such
    as `Create`, `List`, `View`, `Delete`, and so on. However, the URL paths are not
    usually presented by verbs. Because HTTP methods such as `GET`, `POST`, `PUT`,
    and `DELETE` are already verbs, it is not necessary to include verbs in the URL
    paths. Instead, we should use nouns to represent the resources – for example,
    `/posts`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中我们识别的操作事件是一些动作，例如 `Create`、`List`、`View`、`Delete` 等。然而，URL路径通常不会用动词表示。因为HTTP方法如
    `GET`、`POST`、`PUT` 和 `DELETE` 已经是动词了，所以没有必要在URL路径中包含动词。相反，我们应该使用名词来表示资源——例如，`/posts`。
- en: Using plural nouns to represent collections
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用复数名词表示集合
- en: If a resource is a collection, we should use plural nouns to represent the resource.
    For example, `/posts` is the URL path for the collection of posts. To get a single
    post by its ID, we can use `/posts/{postId}`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个资源是集合，我们应该使用复数名词来表示该资源。例如，`/posts` 是帖子集合的URL路径。要获取单个帖子的ID，我们可以使用 `/posts/{postId}`。
- en: Using logical nesting to represent relationships
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用逻辑嵌套表示关系
- en: For the resources that have a relationship, normally, the child resource (i.e.,
    the dependent resource) should be nested under the parent resource, and the path
    should include the parent identifier. However, this does not reflect the database
    structure. For example, a post can have a collection of comments; the URL looks
    like `/posts/{postId}/comments`. It clearly shows that the comments are related
    to the post.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有关联关系的资源，通常，子资源（即依赖资源）应该嵌套在父资源之下，并且路径应包含父标识符。然而，这并不反映数据库结构。例如，一篇文章可以有一个评论集合；URL看起来像
    `/posts/{postId}/comments`。这清楚地表明评论与文章相关。
- en: However, if the relationships are too deep or complicated, the nesting URL path
    can be too long. In this case, we can rethink how to better represent those resources.
    For example, if we want to retrieve an author’s information from one comment,
    we could use `/posts/{postId}/comments/{commentId}/author`. But this goes too
    far. Instead, if we know the `UserId` of the author, we can use `/users/{userId}`.
    Avoid using deep nesting in URL paths because it makes an API more complicated
    and not readable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果关系太深或太复杂，嵌套的URL路径可能会太长。在这种情况下，我们可以重新思考如何更好地表示这些资源。例如，如果我们想从一个评论中检索作者的信息，我们可以使用
    `/posts/{postId}/comments/{commentId}/author`。但这太过分了。相反，如果我们知道作者的 `UserId`，我们可以使用
    `/users/{userId}`。避免在URL路径中使用深层嵌套，因为它会使API更复杂且不便于阅读。
- en: Allowing filtering, sorting, and pagination
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许过滤、排序和分页
- en: Returning all records simultaneously is not a good idea. We can use filtering,
    sorting, and pagination to return a subset of the records that a client needs.
    These operations can improve the performance of the APIs and provide a better
    user experience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同时返回所有记录不是一个好主意。我们可以使用过滤、排序和分页来返回客户端需要的记录子集。这些操作可以提高API的性能并提供更好的用户体验。
- en: For example, if we want to search a list of posts for a specific keyword, we
    can use a query parameter, such as `/posts?search=keyword`. If we want to sort
    posts by the date, we can use `/posts?sort=date`. To get the second page of the
    posts, we can use `/posts?page=2`. These query parameters can be combined with
    each other.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想搜索特定关键词的文章列表，我们可以使用查询参数，例如 `/posts?search=keyword`。如果我们想按日期排序文章，我们可以使用
    `/posts?sort=date`。要获取文章的第二页，我们可以使用 `/posts?page=2`。这些查询参数可以组合使用。
- en: What if I cannot find a proper verb in HTTP methods for an operation?
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果我找不到适当的动词来表示HTTP方法中的操作怎么办？
- en: Generally, HTTP methods can represent CRUD operations. However, in the real
    world, there are many more complexities! For example, besides the basic CRUD operations,
    there are other operations, such as publishing or unpublishing a post. So, what
    HTTP methods should we use?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HTTP方法可以表示CRUD操作。然而，在现实世界中，有更多复杂性！例如，除了基本的CRUD操作外，还有其他操作，如发布或取消发布文章。那么，我们应该使用哪些HTTP方法呢？
- en: This is where things can get tricky. This subject is open to debate, but remember
    that we are not arguing whether an API is *RESTful* enough. We just want to make
    it work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情可能会变得复杂。这个主题是开放的，但请记住，我们不是在争论API是否足够 *RESTful*。我们只是想让它工作。
- en: 'There are different approaches for these scenarios:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些场景，有不同方法：
- en: 'One possible solution could be treating such operations like a sub-resource.
    So, you can use `/posts/{postId}/publish` to publish a post. GitHub uses the following
    URL to star a gist: `/gists/{gist_id}/star`. For more information, check out [https://docs.github.com/en/rest/gists/gists#star-a-gist](https://docs.github.com/en/rest/gists/gists#star-a-gist).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将此类操作视为子资源。因此，您可以使用 `/posts/{postId}/publish` 来发布文章。GitHub使用以下URL来标记一个gist：`/gists/{gist_id}/star`。更多信息，请参阅[https://docs.github.com/en/rest/gists/gists#star-a-gist](https://docs.github.com/en/rest/gists/gists#star-a-gist)。
- en: The post should have an `IsPublished` field to indicate whether it is published.
    So, actually, the `publish` action is an update action, which updates the `IsPublished`
    field only. Then, you can treat it the same as the `updatePost()` operation.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章应该有一个 `IsPublished` 字段来指示它是否已发布。因此，实际上，`publish` 动作是一个更新动作，它只更新 `IsPublished`
    字段。然后，您可以将其视为与 `updatePost()` 操作相同。
- en: 'Here are some resource URLs for the blog system:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些博客系统的资源URL：
- en: '| **Operation name** | **URL** | **Input** | **Output** | **Description** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **URL** | **输入** | **输出** | **描述** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `createPost()` | `/``posts` | Post detail |  | Create a new post |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `createPost()` | `/posts` | 文章详情 |  | 创建一个新的文章 |'
- en: '| `listPosts()` | `/``posts` |  | A list of posts | List all posts |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `listPosts()` | `/posts` |  | 一系列文章 | 列出所有文章 |'
- en: '| `listPostsByCategory()` | `/``posts?categoryId={categoryId}` | Category ID
    | A list of posts | List posts by category |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByCategory()` | `/posts?categoryId={categoryId}` | 类别 ID | 一系列文章
    | 通过类别列出文章 |'
- en: '| `listPostsByTag()` | `/``posts?tag={tagId}` | Tag or Tag ID | A list of posts
    | List posts by tag |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByTag()` | `/posts?tag={tagId}` | 标签或标签 ID | 一系列文章 | 通过标签列出文章 |'
- en: '| `searchPosts()` | `/``posts?search={keyword}` | Search keyword | A list of
    posts | Search for posts by title, author, and content |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `searchPosts()` | `/posts?search={keyword}` | 搜索关键字 | 一系列文章 | 通过标题、作者和内容搜索文章
    |'
- en: '| `viewPost()` | `/``posts/{postId}` | Post ID | Post detail | View a post
    detail |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `viewPost()` | `/posts/{postId}` | 文章 ID | 文章详情 | 查看文章详情 |'
- en: '| `deletePost()` | `/``posts/{postId}` | Post ID |  | Delete a post |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `deletePost()` | `/posts/{postId}` | 文章 ID |  | 删除文章 |'
- en: '| `updatePost()` | `/``posts/{postId}` | Post detail |  | Update a post |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `updatePost()` | `/posts/{postId}` | 文章详情 |  | 更新文章 |'
- en: '| `publishPost()` | `/``posts/{postId}/publish` | Post ID |  | Publish a post
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `publishPost()` | `/posts/{postId}/publish` | 文章 ID |  | 发布文章 |'
- en: '| `unpublishPost()` | `/``posts/{postId}/unpublish` | Post ID |  | Unpublish
    a post |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `unpublishPost()` | `/posts/{postId}/unpublish` | 文章 ID |  | 取消发布文章 |'
- en: Table 1.3 – URLs for the Post resource
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.3 – 文章资源的 URL
- en: Some URLs are identical, such as `deletePost()` and `updatePost()`, because
    we will use HTTP methods to differentiate those operations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 URL 是相同的，例如 `deletePost()` 和 `updatePost()`，因为我们将通过 HTTP 方法来区分这些操作。
- en: Mapping API operations to HTTP methods
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 API 操作映射到 HTTP 方法
- en: Next, we need to identify which HTTP method is appropriate for each operation.
    As we mentioned before, there are some common HTTP methods for CRUD operations.
    For example, when we request a resource, we should use the `GET` method. When
    we create a new resource, we should use the `POST` method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定每个操作适合哪种 HTTP 方法。正如我们之前提到的，有一些常见的 HTTP 方法用于 CRUD 操作。例如，当我们请求资源时，我们应该使用
    `GET` 方法。当我们创建新资源时，我们应该使用 `POST` 方法。
- en: 'When we map the API operations to HTTP methods, we also need to consider the
    safety of the operations and HTTP methods. There are three types of safety for
    HTTP operations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 API 操作映射到 HTTP 方法时，我们还需要考虑操作的安全性以及 HTTP 方法的安全性。HTTP 操作有三种安全性类型：
- en: '`GET` request to `/posts/{postId}`, it will return the same result, no matter
    how many times the same request is sent. For some cases, the resource might be
    updated by a third party, and the next `GET` request will return the updated result.
    But this was not caused by the client, so it is important to understand whether
    the state change is caused by the client who sent the request.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `/posts/{postId}` 的 `GET` 请求，无论发送多少次相同的请求，它都会返回相同的结果。在某些情况下，资源可能被第三方更新，下一次
    `GET` 请求将返回更新后的结果。但这并非由客户端引起，因此了解状态变化是否由发送请求的客户端引起非常重要。
- en: '`DELETE` request to `/posts/{postId}` to delete it. If the request is a success,
    we will get a `200 OK` or a `204 No Content` response. If we send the same request
    to `/posts/{postId}` again, it may return a `404 Not found` response because the
    resource was already deleted, but it will not cause any other side effects. If
    an operation is idempotent and the client knows whether the previous request failed,
    it is safe to reissue the request without any side effects.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/posts/{postId}` 发送 `DELETE` 请求以删除它。如果请求成功，我们将收到 `200 OK` 或 `204 No Content`
    响应。如果我们再次向 `/posts/{postId}` 发送相同的请求，它可能返回 `404 Not found` 响应，因为资源已经被删除，但这不会引起任何其他副作用。如果一个操作是幂等的，并且客户端知道之前的请求是否失败，那么重新发出请求是安全的，不会产生任何副作用。
- en: '`POST` request to `/posts` to create a new post. If we send the same `POST`
    request again, it will create another new post with the same title and content,
    and so on.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/posts` 发送 `POST` 请求以创建一篇新文章。如果我们再次发送相同的 `POST` 请求，它将创建另一篇具有相同标题和内容的新文章，依此类推。
- en: 'All safe methods are also idempotent, but not all idempotent methods are safe.
    The following table lists the safety of each HTTP method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安全方法也都是幂等的，但并非所有幂等方法都是安全的。以下表格列出了每个 HTTP 方法的安全性：
- en: '| **HTTP method** | **Safe** | **Idempotent** | **Common operations** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 方法** | **安全** | **幂等** | **常见操作** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `GET` | Yes | Yes | Read, list, view, search, show, and retrieve |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 是 | 是 | 读取、列出、查看、搜索、显示和检索 |'
- en: '| `HEAD` | Yes | Yes | `HEAD` is used to check the availability of a resource
    without actually downloading it. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 是 | 是 | `HEAD` 用于检查资源的可用性，而不实际下载它。 |'
- en: '| `OPTIONS` | Yes | Yes | `OPTIONS` is used to retrieve the available HTTP
    methods for a given resource. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 是 | 是 | `OPTIONS` 用于检索给定资源的可用 HTTP 方法。 |'
- en: '| `TRACE` | Yes | Yes | `TRACE` is used to get diagnostic information about
    a request/response cycle. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `TRACE` | 是 | 是 | `TRACE` 用于获取请求/响应周期的诊断信息。 |'
- en: '| `PUT` | No | Yes | Update and replace |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 否 | 是 | 更新和替换 |'
- en: '| `DELETE` | No | Yes | Delete, remove, and clear |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 否 | 是 | 删除、移除和清除 |'
- en: '| `POST` | No | No | Create, add, and update |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 否 | 否 | 创建、添加和更新 |'
- en: '| `PATCH` | No | No | Update |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 否 | 否 | 更新 |'
- en: Table 1.4 – Safety of HTTP methods
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.4 – HTTP 方法的安全性
- en: 'The following table shows how operations are mapped to HTTP methods:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了如何将操作映射到 HTTP 方法：
- en: '| **Operation name** | **URL** | **HTTP method** | **Description** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **URL** | **HTTP 方法** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `createPost()` | `/``posts` | `POST` | Create a new post |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `createPost()` | `/posts` | `POST` | 创建新帖子 |'
- en: '| `listPosts()` | `/``posts` | `GET` | List all posts |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `listPosts()` | `/posts` | `GET` | 列出所有帖子 |'
- en: '| `listPostsByCategory()` | `/``posts?categoryId={categoryId}` | `GET` | List
    posts by category |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByCategory()` | `/posts?categoryId={categoryId}` | `GET` | 通过类别列出帖子
    |'
- en: '| `listPostsByTag()` | `/``posts?tag={tagId}` | `GET` | List posts by tag |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByTag()` | `/posts?tag={tagId}` | `GET` | 通过标签列出帖子 |'
- en: '| `searchPosts()` | `/``posts?search={keyword}` | `GET` | Search for posts
    by title, author, and content |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `searchPosts()` | `/posts?search={keyword}` | `GET` | 通过标题、作者和内容搜索帖子 |'
- en: '| `viewPost()` | `/``posts/{postId}` | `GET` | View a post detail |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `viewPost()` | `/posts/{postId}` | `GET` | 查看帖子详情 |'
- en: '| `deletePost()` | `/``posts/{postId}` | `DELETE` | Delete a post |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `deletePost()` | `/posts/{postId}` | `DELETE` | 删除帖子 |'
- en: '| `updatePost()` | `/``posts/{postId}` | `PUT` | Update a post |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `updatePost()` | `/posts/{postId}` | `PUT` | 更新帖子 |'
- en: '| `publishPost()` | `/``posts/{postId}/publish` | `PUT` | Publish a post |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `publishPost()` | `/posts/{postId}/publish` | `PUT` | 发布帖子 |'
- en: '| `unpublishPost()` | `/``posts/{postId}/unpublish` | `PUT` | Unpublish a post
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `unpublishPost()` | `/posts/{postId}/unpublish` | `PUT` | 取消发布帖子 |'
- en: Table 1.5 – Mapping HTTP methods for the Post resource
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.5 – 为 Post 资源映射 HTTP 方法
- en: 'You may have seen some other cases, such as using `POST` to update a resource.
    That works, but it does not follow the HTTP standard. Generally speaking, we can
    state the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过一些其他情况，例如使用 `POST` 来更新资源。这可以工作，但它并不遵循 HTTP 标准。一般来说，我们可以陈述以下内容：
- en: '`GET` is used to read resources.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 用于读取资源。'
- en: '`POST` is used to create child resources with a server-defined URL, such as
    `/posts`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 用于使用服务器定义的 URL（如 `/posts`）创建子资源。'
- en: '`PUT` is used to create or replace the resource with a client-defined URL,
    such as `/posts/{postId}`.. In many cases, `PUT` can also be used to update a
    resource.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 用于使用客户端定义的 URL（如 `/posts/{postId}`）创建或替换资源。在许多情况下，`PUT` 也可以用于更新资源。'
- en: '`PATCH` is used to update parts of the resource with a client-defined URL,
    such as `/posts/{postId}`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH` 用于使用客户端定义的 URL（如 `/posts/{postId}`）更新资源的部分。'
- en: Assigning response codes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配响应代码
- en: 'It is time to assign the HTTP response codes for the operations. There are
    some main response code categories:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为操作分配 HTTP 响应代码了。有一些主要的响应代码类别：
- en: '`2xx` **codes – success**: The action requested by the client was received,
    understood, and accepted.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2xx` **代码 – 成功**：客户端请求的操作已被接收、理解并接受。'
- en: '`3xx` **codes – redirection**: The client must take additional action to complete
    the request. It is often used to indicate that the client should be redirected
    to a new location.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3xx` **代码 – 重定向**：客户端必须采取额外操作以完成请求。这通常用于指示客户端应重定向到新位置。'
- en: '`4xx` **code – client errors**: The operation was not successful, but the client
    can try again.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4xx` **代码 – 客户端错误**：操作未成功，但客户端可以再次尝试。'
- en: '`5xx` **codes – server errors**: The server has encountered an error or is
    incapable of performing the request. The client can retry in the future.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5xx` **代码 – 服务器错误**：服务器遇到错误或无法执行请求。客户端可以在将来重试。'
- en: 'A common issue is that some developers invent their own response codes. For
    example, if we create a new post, we expect the server to return a `201 Created`
    response code. Some developers may use `200 OK` and include a status code in the
    response body. This is not a good idea. There are many layers between the server
    and the client. Using your own codes will probably cause problems for these middleware
    components. Make sure to use the right code for the right reason. Here are some
    common response codes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见问题是，一些开发者发明了自己的响应代码。例如，如果我们创建一个新帖子，我们期望服务器返回 `201 已创建` 响应代码。一些开发者可能会使用 `200
    OK` 并在响应体中包含状态代码。这不是一个好主意。服务器和客户端之间有很多层。使用你自己的代码可能会给这些中间件组件带来问题。请确保根据正确的理由使用正确的代码。以下是一些常见的响应代码：
- en: '| **HTTP** **response code** | **Description** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 响应代码** | **描述** |'
- en: '| --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `200 OK` | The standard response for successful HTTP requests. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `200 OK` | 成功 HTTP 请求的标准响应。 |'
- en: '| `201 Created` | The request has been fulfilled, resulting in a new resource
    being created. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `201 已创建` | 请求已得到满足，导致新资源被创建。 |'
- en: '| `202 Accepted` | The request has been accepted for processing, but processing
    has not been completed. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `202 已接受` | 请求已被接受处理，但处理尚未完成。 |'
- en: '| `204` `No Content` | The server has successfully processed the request but
    does not return any content. This is common for delete operations. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `204` `无内容` | 服务器已成功处理请求，但不返回任何内容。这在删除操作中很常见。 |'
- en: '| `400` `Bad Request` | The server cannot understand or process the request
    due to a client error, such as malformed syntax, a request size too large, or
    invalid input. The client should not repeat the request without modifications.
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `400` `错误请求` | 服务器无法理解或处理请求，因为客户端错误，例如语法错误、请求大小过大或无效输入。客户端不应在不修改请求的情况下重复请求。
    |'
- en: '| `401 Unauthorized` | The request requires user authentication. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `401 未授权` | 请求需要用户身份验证。 |'
- en: '| `403 Forbidden` | The server understood the request but is refusing action.
    This may be due to the fact that the client does not have the necessary permissions
    or is attempting a prohibited action. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `403 禁止` | 服务器理解了请求，但拒绝执行。这可能是因为客户端没有必要的权限或尝试了禁止的操作。 |'
- en: '| `404` `Not Found` | The requested resource could not be found. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `404` `未找到` | 请求的资源找不到。 |'
- en: '| `500 Internal` `Server Error` | A generic error message. The server encountered
    an unexpected condition, so it cannot process the request, and no more specific
    messages are suitable at this time. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `500 内部服务器错误` | 一个通用的错误消息。服务器遇到意外情况，因此无法处理请求，此时没有更具体的消息是合适的。 |'
- en: '| `503` `Service Unavailable` | The server is currently unable to handle the
    request due to temporary overloading or maintenance of the server. The response
    should contain a `Retry-After` header if possible so that the client can retry
    after the estimated time, |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `503` `服务不可用` | 服务器当前无法处理请求，可能是由于临时过载或服务器维护。如果可能，响应应包含 `Retry-After` 标头，以便客户端在估计时间后重试，
    |'
- en: Table 1.6 – Common HTTP response codes
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.6 – 常见 HTTP 响应代码
- en: 'Here is the table that shows the response codes for each operation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是显示每个操作响应代码的表格：
- en: '| **Operation name** | **URL** | **HTTP method** | **Response** | **Description**
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **URL** | **HTTP 方法** | **响应** | **描述** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `createPost()` | `/``posts` | `POST` | `Post, 201` | Create a new post |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `createPost()` | `/posts` | `POST` | `Post, 201` | 创建新帖子 |'
- en: '| `listPosts()` | `/``posts` | `GET` | `Post[], 200` | List all posts |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `listPosts()` | `/posts` | `GET` | `Post[], 200` | 列出所有帖子 |'
- en: '| `listPostsByCategory()` | `/``posts?categoryId={categoryId}` | `GET` | `Post[],
    200` | List posts by category |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByCategory()` | `/posts?categoryId={categoryId}` | `GET` | `Post[],
    200` | 按类别列出帖子 |'
- en: '| `listPostsByTag()` | `/``posts?tag={tagId}` | `GET` | `Post[], 200` | List
    posts by tag |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `listPostsByTag()` | `/posts?tag={tagId}` | `GET` | `Post[], 200` | 按标签列出帖子
    |'
- en: '| `searchPosts()` | `/``posts?search={keyword}` | `GET` | `Post[], 200` | Search
    for posts by title, author, and content |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `searchPosts()` | `/posts?search={keyword}` | `GET` | `Post[], 200` | 通过标题、作者和内容搜索帖子
    |'
- en: '| `viewPost()` | `/``posts/{postId}` | `GET` | `Post, 200` | View a post detail
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `viewPost()` | `/posts/{postId}` | `GET` | `Post, 200` | 查看帖子详情 |'
- en: '| `deletePost()` | `/``posts/{postId}` | `DELETE` | `204, 404` | Delete a post
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `deletePost()` | `/posts/{postId}` | `DELETE` | `204, 404` | 删除帖子 |'
- en: '| `updatePost()` | `/``posts/{postId}` | `PUT` | `200` | Update a post |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `updatePost()` | `/posts/{postId}` | `PUT` | `200` | 更新帖子 |'
- en: '| `publishPost()` | `/``posts/{postId}/publish` | `PUT` | `200` | Publish a
    post |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `publishPost()` | `/posts/{postId}/publish` | `PUT` | `200` | 发布帖子 |'
- en: '| `unpublishPost()` | `/``posts/{postId}/unpublish` | `PUT` | `200` | Unpublish
    a post |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `unpublishPost()` | `/posts/{postId}/unpublish` | `PUT` | `200` | 取消发布帖子
    |'
- en: Table 1.7 – Response codes for the Post resource
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.7 – Post资源的响应码
- en: It is essential to utilize the correct response code in order to prevent any
    misunderstandings. This will ensure that all communication is clear and concise,
    thus avoiding any potential confusion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用响应码至关重要，以防止任何误解。这将确保所有通信都是清晰和简洁的，从而避免任何潜在的混淆。
- en: What if I want to create my own status codes?
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果我想创建自己的状态码怎么办？
- en: 'Technically, you can create your own status codes, but in practice, please
    stick as closely to the standards as possible. If you invent your own status codes,
    that would be risky. Your users might be in trouble consuming your APIs because
    they do not know your status codes. You should think about what the benefits are
    to have your own status codes. The convention is to respect the HTTP status codes
    defined in RFC. Before you create your own status codes, make sure you check the
    list of HTTP status codes first. Do not create your own status code unless you
    have strong reasons. You can find more information here: [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以创建自己的状态码，但在实践中，请尽可能遵循标准。如果你发明了自己的状态码，那将是危险的。你的用户可能会在使用你的API时遇到麻烦，因为他们不知道你的状态码。你应该考虑拥有自己的状态码的好处。惯例是尊重RFC中定义的HTTP状态码。在你创建自己的状态码之前，请确保首先检查HTTP状态码列表。除非你有充分的理由，否则不要创建自己的状态码。你可以在这里找到更多信息：[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)。
- en: 'However, there might be some special situations where you want to indicate
    a more specific status in the response. For example, you might have an API that
    can process a task, but it might fail for different reasons. You might want to
    indicate a more detailed message in the response to let your users know what happened,
    rather than returning a common `4xx` code. You should think about the business
    logic carefully and differentiate between HTTP status codes and business status
    codes. If you cannot find a proper code in the HTTP status codes, and you do want
    to show a business-related status in the response, you can choose the HTTP status
    code to indicate the category of the response, and then attach a response body
    that contains your business status code. For example, you can return a response
    as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在一些特殊情况，你希望在响应中指示更具体的状态。例如，你可能有一个可以处理任务的API，但它可能因不同原因而失败。你可能希望在响应中提供更详细的消息，以便让你的用户知道发生了什么，而不是返回常见的`4xx`代码。你应该仔细考虑业务逻辑，区分HTTP状态码和业务状态码。如果你在HTTP状态码中找不到合适的代码，而你又想在响应中显示与业务相关的状态，你可以选择HTTP状态码来指示响应的类别，然后附加一个包含你的业务状态码的响应体。例如，你可以返回如下所示的响应：
- en: '[PRE2]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, the HTTP status code represents the common status of the operation, and
    in the response body, you can include some information that is specific to your
    system. We will discuss how to handle errors using the `Problem Details` object
    in [*Chapter 16*](B18971_16.xhtml#_idTextAnchor671).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，HTTP状态码表示操作的通用状态，在响应体中，你可以包含一些特定于你系统的信息。我们将在[*第16章*](B18971_16.xhtml#_idTextAnchor671)中讨论如何使用`Problem
    Details`对象来处理错误。
- en: Documenting the API
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录API
- en: OpenAPI is a popular REST API specification. It is a programming language-agnostic
    interface description for REST APIs, allowing both humans and computers to discover
    and understand the capabilities of a service without access to source code. Similar
    to an interface, it describes the inputs and outputs of an API, as well as how
    they should be transmitted. It is also known as the Swagger specification.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI是一种流行的REST API规范。它是对REST API的编程语言无关的接口描述，允许人类和计算机在无需访问源代码的情况下发现和理解服务的功能。类似于接口，它描述了API的输入和输出，以及它们应该如何传输。它也被称为Swagger规范。
- en: Swagger versus OpenAPI
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger与OpenAPI
- en: Sometimes, *Swagger* and *OpenAPI* are used interchangeably. The Swagger project
    was developed in early 2010s to define a simple contract for an API that contains
    everything needed to produce or consume an API. It was donated to the OpenAPI
    initiative in 2015\. So, OpenAPI refers to the API specification, and Swagger
    refers to the open-source and commercial projects from SmartBear, which work with
    the OpenAPI specification. In short, OpenAPI is a specification, and Swagger is
    tooling that uses the OpenAPI specification. Swagger UI is also one of the Swagger
    tools. At the time of writing, the latest version of OpenAPI was 3.1.0.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，*Swagger* 和 *OpenAPI* 可以互换使用。Swagger项目在2010年代初开发，用于定义一个简单的API合同，该合同包含生成或消费API所需的一切。它在2015年被捐赠给了OpenAPI倡议。因此，OpenAPI指的是API规范，Swagger指的是与OpenAPI规范一起工作的SmartBear的开源和商业项目。简而言之，OpenAPI是一个规范，Swagger是使用OpenAPI规范的工具。Swagger
    UI也是Swagger工具之一。在撰写本文时，OpenAPI的最新版本是3.1.0。
- en: 'We can use SwaggerHub to design an API based on the previous steps. Here is
    an example, which defines a simple API for a blog system:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SwaggerHub根据之前的步骤设计API。以下是一个示例，它定义了一个简单的博客系统API：
- en: '[PRE3]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The other file of this file has been omitted.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的另一个文件已被省略。
- en: The preceding API documentation is a YAML file, which defines two models (resources)
    – `Post` and `Category` – and two operations – `GET` for searching posts and `POST`
    for creating a new post. For each operation, there are details about the input
    and output, including the expected response codes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的API文档是一个YAML文件，它定义了两个模型（资源）- `Post` 和 `Category` - 以及两个操作 - `GET` 用于搜索帖子，`POST`
    用于创建新帖子。对于每个操作，都有关于输入和输出的详细信息，包括预期的响应代码。
- en: 'After the API design is done, we can share the API documentation with other
    developers for integrations, as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成API设计后，我们可以将API文档与其他开发者共享，以便进行集成，如下所示：
- en: '![Figure 1.1 – The SwaggerHub UI](img/B18971_01_01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – SwaggerHub用户界面](img/B18971_01_01.jpg)'
- en: Figure 1.1 – The SwaggerHub UI
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – SwaggerHub用户界面
- en: Note that you might need to add more properties, based on your user stories
    and domains, before you share the API documentation with other teams. The API
    contract should be quite stable; otherwise, it will impact the consumers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在将API文档与其他团队共享之前，你可能需要根据你的用户故事和领域添加更多属性。API合同应该相当稳定；否则，它将影响消费者。
- en: We have explained how to design a REST API. If you would like to learn how to
    start developing with ASP.NET Core, you can move on to [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了如何设计REST API。如果你想学习如何开始使用ASP.NET Core进行开发，你可以继续阅读[*第2章*](B18971_02.xhtml#_idTextAnchor068)。
- en: REST API is one of the most popular API styles. In the next section, we will
    introduce other API styles, such as RPC APIs, GraphQL APIs, and real-time APIs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: REST API是最受欢迎的API风格之一。在下一节中，我们将介绍其他API风格，例如RPC API、GraphQL API和实时API。
- en: RPC and GraphQL APIs
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC和GraphQL API
- en: While REST-based APIs are widely used in many scenarios today, it is not the
    only style of web API. For some scenarios, RPC-based APIs or GraphQL APIs may
    be better suited. It is important to understand the advantages and disadvantages
    of each style of API so that you can choose the right styles for your scenarios.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于REST的API在许多场景中被广泛使用，但它并不是唯一的Web API风格。对于某些场景，基于RPC的API或GraphQL API可能更适合。了解每种API风格的优缺点非常重要，这样你就可以为你的场景选择正确的风格。
- en: What is an RPC-based API?
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于RPC的API是什么？
- en: RPC has existed for many years. It is the earliest, simplest form of web interaction.
    It is like a local call in some other languages, but it executes over a network.
    The client is given a list of available methods. Each method takes pre-defined,
    typed, and ordered parameters, returning a structured response result. So, the
    client can run on a different machine or in a different process but still work
    with the server, such as in the same application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: RPC已经存在很多年了。它是Web交互的最早、最简单的形式。在某些语言中，它就像一个本地调用，但它在网络上执行。客户端被提供一个可用方法的列表。每个方法都接受预定义的、类型化和有序的参数，返回一个结构化的响应结果。因此，客户端可以在不同的机器或不同的进程中运行，但仍然可以与服务器一起工作，例如在同一个应用程序中。
- en: In this way, the client is tightly coupled to the server. If the server changes
    these methods or any parameters, the client will be affected. Developers must
    update the code of the client to match the new server methods. This can be a disadvantage
    of RPC-based APIs, but it can offer better performance.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，客户端与服务器紧密耦合。如果服务器更改这些方法或任何参数，客户端将受到影响。开发者必须更新客户端的代码以匹配新的服务器方法。这可能是基于RPC的API的缺点，但它可以提供更好的性能。
- en: The remote procedures are defined with the **interface definition language**
    (**IDL**). The IDL defines the methods and parameters of the remote procedure.
    Normally, some code generators can generate the client and server stubs based
    on the IDL. The code is strongly typed, which provides better type safety and
    error handling.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 远程过程是通过**接口定义语言**（**IDL**）定义的。IDL定义了远程过程的方法和参数。通常，一些代码生成器可以根据IDL生成客户端和服务器存根。代码是强类型的，这提供了更好的类型安全和错误处理。
- en: To implement an RPC-based API, there are some specifications for different languages.
    For example, WCF was a popular framework for RPC a couple of years ago. Some other
    popular frameworks include XML-RPC, SOAP PRC, JSON-RPC, and gRPC.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现基于RPC的API，不同语言有一些规范。例如，WCF是几年前流行的RPC框架。其他一些流行的框架包括XML-RPC、SOAP PRC、JSON-RPC和gRPC。
- en: 'Because RPC is like a local method call, you often see verbs in the method
    names. Unlike REST, RPC supports various operations beyond CRUD. Here is an example
    of a JSON-RPC request and response:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为RPC就像本地方法调用一样，你经常在方法名中看到动词。与REST不同，RPC支持CRUD以外的各种操作。以下是一个JSON-RPC请求和响应的示例：
- en: 'Request:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请求：
- en: '[PRE4]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Response:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 响应：
- en: '[PRE5]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One of the most popular RPC frameworks is gRPC, which we will discuss in the
    next section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的RPC框架之一是gRPC，我们将在下一节讨论。
- en: What is gRPC?
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是gRPC？
- en: One of the most popular RPC frameworks is gRPC. It is a high-performance, open-source
    modern RPC framework for building network services and distributed applications.
    gRPC was initially created by Google, which used a RPC framework called Stubby.
    In March 2015, Google decided to make it open-source, resulting in gRPC, which
    is now used in many organizations outside of Google.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的RPC框架之一是gRPC。它是一个高性能、开源的现代RPC框架，用于构建网络服务和分布式应用程序。gRPC最初由Google创建，它使用一个名为Stubby的RPC框架。2015年3月，Google决定将其开源，从而产生了gRPC，现在许多Google以外的组织都在使用它。
- en: 'gRPC has some awesome features, such as the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC有一些很棒的功能，如下所示：
- en: '**Interoperability**: gRPC uses a **Protocol Buffer** (**protobuf**) file to
    declare services and messages, which enables gRPC to be completely language- and
    platform-agnostic. You can find gRPC tools and libraries for all major programming
    languages and platforms.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：gRPC使用**协议缓冲**（**protobuf**）文件来声明服务和消息，这使得gRPC能够完全语言和平台无关。你可以找到适用于所有主要编程语言和平台的gRPC工具和库。'
- en: '`protobuf` is a binary format, which has a smaller size and faster performance
    than JSON. It is not readable by humans, but it is readable by computers. HTTP/2
    also supports multiplexing requests over a single connection. It needs fewer resources,
    even in slower networks.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protobuf`是一种二进制格式，它比JSON具有更小的尺寸和更快的性能。它对人类不可读，但对计算机可读。HTTP/2还支持在单个连接上多路复用请求。即使在较慢的网络中，它也需要更少的资源。'
- en: '**Streaming**: gRPC is based on the HTTP/2 protocol, which makes it support
    bidirectional streaming.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流式传输**：gRPC基于HTTP/2协议，这使得它支持双向流式传输。'
- en: '`.proto`) to describe services with input and output. Then, they can use the
    `.proto` files to generate stubs for different languages or platforms. It is similar
    to the OpenAPI specification. Teams can focus on business logic and work on the
    same service in parallel.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.proto`文件来描述具有输入和输出的服务。然后，他们可以使用`.proto`文件为不同的语言或平台生成存根。这与OpenAPI规范类似。团队可以专注于业务逻辑，并并行工作在相同的服务上。
- en: '**Security**: gRPC is designed to be secure. HTTP/2 is built on top of **Transport
    Layer Security** (**TLS**) end-to-end encrypted connection. It also supports client
    certificate authentication.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：gRPC被设计成是安全的。HTTP/2建立在**传输层安全**（**TLS**）端到端加密连接之上。它还支持客户端证书认证。'
- en: With these benefits, gRPC is a good choice for microservices-style architecture.
    It can efficiently connect services in and across data centers, even across load
    balancers. It is applicable in the last mile of distributed systems because service-to-service
    communication needs low latency and high performance. Also, the polyglot systems
    may have multiple languages or platforms, and gRPC can support different languages
    and platforms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些好处，gRPC是微服务架构的一个很好的选择。它可以高效地连接数据中心内和跨数据中心的各个服务。它适用于分布式系统的最后一英里，因为服务到服务的通信需要低延迟和高性能。此外，多语言系统可能包含多种语言或平台，而gRPC可以支持不同的语言和平台。
- en: 'Here is an example of a gRPC `.``proto` file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个gRPC `.proto`文件的示例：
- en: '[PRE6]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ASP.NET Core provides great support for gRPC. With the `.proto` file, the .NET
    types for services, clients, and messages can be automatically generated in a
    .NET project. We will learn how to develop the gRPC service in [*Chapter 11*](B18971_11.xhtml#_idTextAnchor438).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core为gRPC提供了极大的支持。使用`.proto`文件，可以在.NET项目中自动生成服务、客户端和消息的.NET类型。我们将在[*第11章*](B18971_11.xhtml#_idTextAnchor438)中学习如何开发gRPC服务。
- en: 'However, gRPC is not a silver bullet. There are several factors we need to
    consider before we choose gRPC:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，gRPC并非万能的银弹。在选择gRPC之前，我们需要考虑几个因素：
- en: '**Tight coupling due to protocol changes**: The client and server are tightly
    coupled because of the protocol. Once the protocol changes, the client and server
    must be updated, even just changing the order of the parameters.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于协议变更导致的紧密耦合**：客户端和服务器由于协议而紧密耦合。一旦协议变更，客户端和服务器必须更新，即使是仅仅更改参数的顺序。'
- en: '`protobuf` is a non-human readable format, so debugging is not convenient.
    Developers need additional tools to analyze the payloads.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protobuf`是一种非人类可读的格式，因此调试不方便。开发者需要额外的工具来分析有效载荷。'
- en: '`grpcweb`, that can provide a library to perform conversions between gRPC and
    HTTP/1.1.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grpcweb`，它可以提供一个库来在gRPC和HTTP/1.1之间进行转换。'
- en: '`POST` method, which is not cacheable for the clients.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`方法，对于客户端来说不可缓存。'
- en: '**A steeper learning curve**: Unlike REST, which is human-readable, many teams
    find gRPC challenging to learn. They need to learn protobuf and HTTP/2 and look
    for proper tools to deal with the message content.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更陡峭的学习曲线**：与人类可读的REST不同，许多团队发现gRPC难以学习。他们需要学习protobuf和HTTP/2，并寻找适当的工具来处理消息内容。'
- en: So, should we choose gRPC or REST?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该选择gRPC还是REST？
- en: Should I use gRPC instead of a REST API?
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该使用gRPC而不是REST API吗？
- en: It is challenging to choose gRPC over REST for most server-client scenarios.
    A REST-based API is well supported by all browsers, so it has a wider adoption
    nowadays. If you need to support browser clients, REST is a better choice compared
    with gRPC. However, gRPC has some features that are useful in certain circumstances,
    such as high-performance communication, real-time communication, low bandwidth,
    and multiple language environments. So, it is a good choice for microservices-style
    architecture.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数服务器-客户端场景，选择gRPC而不是REST具有挑战性。基于REST的API得到了所有浏览器的良好支持，因此现在有更广泛的采用。如果您需要支持浏览器客户端，与gRPC相比，REST是一个更好的选择。然而，gRPC在某些情况下具有一些有用的功能，例如高性能通信、实时通信、低带宽和多语言环境。因此，它是微服务架构的一个很好的选择。
- en: 'In a microservices architecture, the services are loosely coupled, and each
    one does a specific task or processes specific data. They need to be able to communicate
    with each other with simplicity and efficiency without considering browser compatibility.
    gRPC is suitable for this scenario because it is based on HTTP/2, which is a high-performance
    protocol and provides bidirectional streaming, binary messaging, and multiplexing.
    **Dapr**, which is a portable, event-driven runtime for microservices, implements
    gRPC APIs so that apps can communicate with each other via gRPC. We will not discuss
    Dapr in this book, but if you are interested, you can find more information here:
    [https://dapr.io/](https://dapr.io/).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务是松散耦合的，每个服务都执行特定的任务或处理特定的数据。它们需要能够以简单和高效的方式相互通信，而不必考虑浏览器兼容性。gRPC适合这种场景，因为它基于高性能协议HTTP/2，提供了双向流、二进制消息和复用。**Dapr**是一个可移植的事件驱动运行时，用于微服务，实现了gRPC
    API，以便应用程序可以通过gRPC相互通信。本书中不会讨论Dapr，但如果您感兴趣，可以在此处找到更多信息：[https://dapr.io/](https://dapr.io/)。
- en: In conclusion, using gRPC or REST depends on your use-case demands.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用gRPC或REST取决于您的用例需求。
- en: gRPC API design
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC API设计
- en: The gRPC API design process is very similar to the REST API design process.
    In fact, the first three steps are similar to the REST API design process. We
    need to identify the resources, define the relationships between resources, and
    identify operation events as well.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC API 设计过程与 REST API 设计过程非常相似。实际上，前三个步骤与 REST API 设计过程相似。我们需要识别资源，定义资源之间的关系，以及识别操作事件。
- en: Next, use the information from the first three steps to design and document
    the gRPC API. When we convert the operation events to gRPC operations, there are
    some differences. REST API uses HTTP methods to represent the operations. In gRPC,
    these operations are like the methods of the service, which means we can use verbs
    in the method names. For example, the method to get a post can be represented
    as `GetPost()`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用前三个步骤中的信息来设计和记录 gRPC API。当我们把操作事件转换为 gRPC 操作时，有一些差异。REST API 使用 HTTP 方法来表示操作。在
    gRPC 中，这些操作就像服务的方法一样，这意味着我们可以在方法名称中使用动词。例如，获取帖子的方法可以表示为 `GetPost()`。
- en: 'gRPC uses protobuf as the IDL. When we design a gRPC API, we actually need
    to author the `.proto` files. These `.proto` files consist of two parts:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 protobuf 作为 IDL。当我们设计 gRPC API 时，实际上我们需要编写 `.proto` 文件。这些 `.proto` 文件由两部分组成：
- en: The definition of the gRPC service
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 服务的定义
- en: The messages that are used in the service
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务中使用的消息
- en: 'This is similar to the REST OpenAPI definition but has a different syntax.
    Each request needs a type-defined message that includes the sorted input parameters.
    Each response returns a message, an array of messages, or an error status response.
    We can have a `.proto` file for the blog system, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 REST OpenAPI 定义类似，但语法不同。每个请求都需要一个类型定义的消息，该消息包括排序后的输入参数。每个响应返回一个消息、消息数组或错误状态响应。我们可以为博客系统创建一个
    `.proto` 文件，如下所示：
- en: '[PRE7]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s it! Now, the `.proto` file has a basic gRPC service definition, including
    the message definitions. Next, we can use various tools to generate the code for
    the gRPC service and the client. In the development stage, we may need to frequently
    change the gRPC protocol definition by updating the `.proto` files. The changes
    will be reflected in the generated code. So, please consider carefully before
    you publish the service for consumption. We will discuss more about gRPC in [*Chapter
    11*](B18971_11.xhtml#_idTextAnchor438). If you would like to start gRPC development
    with .NET 8 now, please jump to that chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在，`.proto` 文件已经有一个基本的 gRPC 服务定义，包括消息定义。接下来，我们可以使用各种工具生成 gRPC 服务和客户端的代码。在开发阶段，我们可能需要频繁地通过更新
    `.proto` 文件来更改 gRPC 协议定义。这些更改将反映在生成的代码中。因此，在发布服务供消费之前，请仔细考虑。我们将在 [*第 11 章*](B18971_11.xhtml#_idTextAnchor438)
    中讨论更多关于 gRPC 的内容。如果您想现在就开始使用 .NET 8 开发 gRPC，请跳转到该章节。
- en: Next, let’s look at the GraphQL API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 GraphQL API。
- en: What is a GraphQL API?
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 GraphQL API？
- en: 'Think about the scenarios that use REST APIs. We may find some issues:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 REST API 的场景。我们可能会发现一些问题：
- en: '`/posts` endpoint, which returns a list of the posts. When we show a post list
    page, we only need some properties such as `Title`, `PublishDate`, and `Category`.
    But the posts returned from the endpoint may contain more information about the
    posts, such as `IsPublished`, which is useless for clients.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/posts` 端点，返回帖子的列表。当我们展示帖子列表页面时，我们只需要一些属性，如 `Title`、`PublishDate` 和 `Category`。但端点返回的帖子可能包含更多关于帖子的信息，如
    `IsPublished`，这对于客户端来说是无用的。'
- en: '`/posts/{postId}` endpoint that shows the post information and a `/posts/{postId}/related`
    endpoint that shows related posts. If we want to show a post detail, the client
    will need to call the `/posts/{postId}` endpoint, but the related posts are not
    provided in the response. So, the client will have to make another request to
    `/posts/{postId}/related` to get the related posts. The N+1 problem often refers
    to the parent-child relationship. The endpoint that returns the collection resource
    does not provide enough information about the child resources for the clients.
    For example, the `/posts` endpoint returns a list of posts, but the response does
    not have the content summary for each post. To show the content summary on the
    post list page, the client will have to call the `/posts/{postId}` endpoint for
    each post to get the content summary. So, the total number of requests will be
    `n + 1`, where `n` is the number of posts.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/posts/{postId}`端点显示帖子信息和`/posts/{postId}/related`端点显示相关帖子。如果我们想显示帖子详情，客户端将需要调用`/posts/{postId}`端点，但相关帖子没有包含在响应中。因此，客户端将不得不再次请求`/posts/{postId}/related`以获取相关帖子。N+1问题通常指的是父子关系。返回集合资源的端点没有为客户端提供足够关于子资源的信息。例如，`/posts`端点返回帖子列表，但响应中没有每个帖子的内容摘要。要在帖子列表页面上显示内容摘要，客户端将不得不为每个帖子调用`/posts/{postId}`端点以获取内容摘要。因此，总请求数将是`n
    + 1`，其中`n`是帖子的数量。'
- en: The over- and under-fetching problems are some of the most common problems with
    REST-based APIs. Because REST-based APIs center on resources, for each endpoint,
    the response structure is fixed and encoded in the URL, so it is not flexible
    for client requirements.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 过度和不足获取问题是基于REST的API中最常见的问题之一。因为基于REST的API以资源为中心，对于每个端点，响应结构是固定的，并且编码在URL中，所以它不灵活地满足客户端的需求。
- en: These problems can be overcome with a GraphQL API. A GraphQL API is another
    API style, which offers powerful query capabilities. It supports fetching data
    with a flexible structure based on the client’s needs. It can fetch data by a
    resource identifier, paginated listing, filtering, and sorting. It also supports
    mutating data as well, like CRUD in REST.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过GraphQL API来解决。GraphQL API是另一种API风格，它提供了强大的查询能力。它支持根据客户端的需求以灵活的结构获取数据。它可以按资源标识符、分页列表、过滤和排序来获取数据。它还支持数据变更，就像REST中的CRUD一样。
- en: Introduction to GraphQL
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL简介
- en: GraphQL is a powerful query language for executing queries with a flexible data
    structure. It was developed internally by Facebook in 2012, following which it
    was released publicly in 2015\. Now, it is open-source and maintained by a large
    community of companies and individuals from all around the world.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一种强大的查询语言，用于执行具有灵活数据结构的查询。它于2012年由Facebook内部开发，随后于2015年公开发布。现在，它是开源的，并由来自世界各地的许多公司和个人维护。
- en: GraphQL solves the over- and under-fetching problem by providing more flexibility
    and efficiency. It is not tied to any database or storage engine, nor to any specific
    languages. There are many libraries to implement GraphQL services and clients.
    A GraphQL service defines types and fields on your resource types, and then provides
    functions for each field on each type.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL通过提供更大的灵活性和效率来解决过度和不足获取的问题。它不依赖于任何数据库或存储引擎，也不依赖于任何特定的语言。有许多库可以用来实现GraphQL服务和客户端。一个GraphQL服务定义了资源类型上的类型和字段，然后为每个类型上的每个字段提供函数。
- en: Unlike REST, which uses *resources* as its core concept and defines URLs that
    return a fixed data structure for each resource, the conceptual model of GraphQL
    is an entity graph. So, all GraphQL operations are performed through a single
    HTTP `POST`- or `GET`-based endpoint, which is usually `/graphql`. It is completely
    flexible and allows the client to decide what data structure it needs. The GraphQL
    service receives GraphQL queries to validate whether a query refers to the correct
    types and fields defined, and then it executes the functions to return the correct
    data structure. The format of requests and responses is JSON.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用*资源*作为其核心概念并定义返回每个资源固定数据结构的URL的REST不同，GraphQL的概念模型是一个实体图。因此，所有GraphQL操作都是通过单个基于HTTP
    `POST`或`GET`的端点执行的，这通常是一个`/graphql`。它是完全灵活的，允许客户端决定它需要什么数据结构。GraphQL服务接收GraphQL查询以验证查询是否引用了正确定义的类型和字段，然后执行函数以返回正确的数据结构。请求和响应的格式是JSON。
- en: 'Besides solving the over- and under-fetching problem, GraphQL has some other
    advantages:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解决过度和不足获取的问题外，GraphQL还有一些其他优点：
- en: GraphQL reduces the complexity of maintaining API versions. There is only one
    endpoint and one version of the graph. It allows the API to evolve without breaking
    the existing clients.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 减少了维护 API 版本的复杂性。只有一个端点和一种图版本。它允许 API 在不破坏现有客户端的情况下进行演变。
- en: GraphQL uses a strong type system to define the types and fields in a schema
    using SDL. The schema behaves as the contract, which reduces the miscommunication
    between the client and the server. Developers can develop frontend applications
    by mocking the required data structures. Once the server is ready, they can switch
    to the actual API.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 使用强类型系统，通过 SDL 定义模式中的类型和字段。该模式作为合同，减少了客户端和服务器之间的误解。开发者可以通过模拟所需的数据结构来开发前端应用程序。一旦服务器准备就绪，他们可以切换到实际的
    API。
- en: GraphQL does not define the specific application architecture, which means it
    can work on top of an existing REST API to reuse some code.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 没有定义特定的应用程序架构，这意味着它可以在现有的 REST API 上运行以重用一些代码。
- en: The payload is smaller because clients get what they exactly request without
    over-fetching.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载更小，因为客户端得到他们确切请求的内容，而没有过度获取。
- en: 'However, there are also some disadvantages of using GraphQL:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 GraphQL 也有一些缺点：
- en: GraphQL presents a high learning curve for REST API developers.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 REST API 开发者来说，GraphQL 具有较高的学习曲线。
- en: The implementation of the server is more complicated. The query could be complex.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器实现更复杂。查询可能很复杂。
- en: GraphQL uses a single endpoint, which means it cannot leverage the full capabilities
    of HTTP. It does not support HTTP content negotiation for multiple media types
    beyond JSON.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 使用单个端点，这意味着它无法充分利用 HTTP 的全部功能。它不支持除 JSON 之外的多媒体类型的 HTTP 内容协商。
- en: It is challenging to enforce the authorization because, normally, the API gateway
    enforces access control based on URLs. Rate-limiting is also often associated
    with the path and HTTP methods. So, you need more consideration to adopt the new
    style.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制授权具有挑战性，因为通常 API 网关根据 URL 执行访问控制。速率限制通常也与路径和 HTTP 方法相关联。因此，您需要更多考虑来采用新样式。
- en: Caching is complicated to implement because the service does not know what data
    clients need.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存实现复杂，因为服务不知道客户端需要什么数据。
- en: File uploads are not allowed, so a separate API for file handling is needed.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许文件上传，因此需要单独的 API 来处理文件。
- en: GraphQL API design
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL API 设计
- en: A GraphQL query is flexible, so clients can send various queries based on their
    requirements. To design the GraphQL API, we need to define the GraphQL schema
    first, which is the core of every GraphQL API.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 查询非常灵活，因此客户端可以根据其需求发送各种查询。为了设计 GraphQL API，我们首先需要定义 GraphQL 模式，这是每个
    GraphQL API 的核心。
- en: GraphQL uses the GraphQL SDL to define GraphQL schemas. SDL has a type system
    that allows us to define the data structure, like the other strongly typed languages,
    such as C#, Java, TypeScript, Go, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 使用 GraphQL SDL 定义 GraphQL 模式。SDL 具有类型系统，允许我们定义数据结构，就像其他强类型语言一样，例如 C#、Java、TypeScript、Go
    等。
- en: 'We can define the following types and fields in the GraphQL schema:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 GraphQL 模式中定义以下类型和字段：
- en: '[PRE8]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A GraphQL request uses a query language to describe the desired fields and
    structure the client needs. The following is a simple query:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 请求使用查询语言来描述所需的字段并结构化客户端所需的内容。以下是一个简单的查询：
- en: '[PRE9]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding query, we can omit the `isPublished` field and include related
    posts in the response, so the client does not need to send more requests.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询中，我们可以省略 `isPublished` 字段并在响应中包含相关帖子，这样客户端就不需要发送更多请求。
- en: 'To modify data or perform a calculation logic, GraphQL establishes a convention
    called *mutation*. We can think of mutation as a way to update the data. The following
    request is a mutation:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改数据或执行计算逻辑，GraphQL 建立了一种称为 *mutation* 的约定。我们可以将 mutation 视为更新数据的一种方式。以下请求是一个
    mutation：
- en: '[PRE10]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are some tools to generate GraphQL documents and test the service, such
    as GraphiQL,GraphQL Playground, and so on. We will not discuss GraphQL much further
    now. In [*Chapter 12*](B18971_12.xhtml#_idTextAnchor484), we will learn how to
    use ASP.NET Core 8 to develop GraphQL APIs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以生成 GraphQL 文档并测试服务，例如 GraphiQL、GraphQL Playground 等。我们现在不会过多讨论 GraphQL。在
    [*第 12 章*](B18971_12.xhtml#_idTextAnchor484) 中，我们将学习如何使用 ASP.NET Core 8 开发 GraphQL
    API。
- en: Next, we will discuss another API style, which is the real-time API.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一种 API 风格，即实时 API。
- en: Real-time APIs
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时 API
- en: We have introduced some web API styles, such as REST-based APIs, gRPC APIs,
    and GraphQL APIs. They all follow the request/response pattern – the client sends
    a request to the server, and the server returns a response. This pattern is easy
    to understand. However, this pattern may not be suitable for some scenarios.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一些Web API风格，例如基于REST的API、gRPC API和GraphQL API。它们都遵循请求/响应模式——客户端向服务器发送请求，服务器返回响应。这种模式易于理解。然而，这种模式可能不适合某些场景。
- en: Let’s say we have an application that contains two parts – the server, which
    is a fire station, and the clients, which are the fire engines. How can we notify
    the fire engines when an incident occurs?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含两个部分的应用程序——服务器，它是一个消防站，客户端是消防车。我们如何通知消防车发生事故？
- en: If we use the request/response pattern, the clients need to send requests to
    the server to get the latest notification regarding the incident. But what is
    the best frequency of sending requests? 1 minute, or 10 seconds? Think about how
    urgent the incident is. If the fire engine gets a notification after a 10-second
    delay, this might be a problem, as the fire might be more serious and urgent!
    So, what about sending requests every 1 second? Then, the server would be very
    busy, and most of the time, it just returns a `No incident` response. With the
    request/response pattern, the server cannot push the notifications to the clients,
    so it is not suitable for this case. This leads us to the problem of API polling.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用请求/响应模式，客户端需要向服务器发送请求以获取有关事故的最新通知。但发送请求的最佳频率是多少？1分钟，还是10秒？考虑事故的紧急程度。如果消防车在10秒延迟后收到通知，这可能会成为问题，因为火势可能更加严重和紧急！那么，每秒发送请求怎么样？然后，服务器将会非常繁忙，而大多数时间，它只是返回一个`无事故`的响应。在请求/响应模式中，服务器无法将通知推送到客户端，因此它不适合这种情况。这导致我们面临API轮询的问题。
- en: The problem with API polling
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API轮询的问题
- en: The request/response pattern has limitations. The server cannot notify the clients
    about what changes are happening on the server side. If the client needs to get
    the latest data, it has to frequently send requests to the server before receiving
    any updates.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请求/响应模式存在局限性。服务器无法通知客户端服务器端发生的变化。如果客户端需要获取最新数据，它必须在收到任何更新之前频繁地向服务器发送请求。
- en: For example, if the client would like to know when a new post is published,
    it needs to call `/posts/latest` to get the latest post. The client may set up
    an interval to send the request periodically. This pattern is called API polling,
    which is a common solution for clients that need to be updated for resource changes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果客户端想知道何时发布新帖子，它需要调用`/posts/latest`来获取最新帖子。客户端可能设置一个间隔，定期发送请求。这种模式称为API轮询，它是客户端需要更新资源变化时的常见解决方案。
- en: API polling does not have many differences from the common REST APIs. It can
    be implemented based on the request/response pattern. However, it is not the ideal
    solution for this kind of scenario. Normally, the frequency of resource changes
    is not predictable, so it is hard to decide the frequency of the requests. If
    the interval is too short, the client may send too many unnecessary requests and
    the server will handle too many queries. However, if the interval is too long,
    the clients cannot get the latest changes in time. In particular, if the application
    needs to notify clients in real-time, then the system would be very busy.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: API轮询与常见的REST API没有太大区别。它可以基于请求/响应模式实现。然而，对于这种场景来说，它并不是理想的解决方案。通常，资源变化的频率是不可预测的，因此很难决定请求的频率。如果间隔太短，客户端可能会发送过多的不必要请求，服务器将处理过多的查询。然而，如果间隔太长，客户端无法及时获取最新的变化。特别是，如果应用程序需要实时通知客户端，那么系统将会非常繁忙。
- en: 'There are more challenges when we use API polling:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用API轮询时，会面临更多挑战：
- en: The logic to check the resource changes is complex. It may implement the logic
    in the server, so the server needs to check the timestamp in the request and then
    query the data, based on the timestamp. Alternatively, the client queries all
    the data and compares the collection with the data from the previous request.
    It brings a lot of complexity.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查资源变化的逻辑很复杂。它可能需要在服务器上实现逻辑，因此服务器需要检查请求中的时间戳，然后根据时间戳查询数据。或者，客户端查询所有数据，并将集合与之前请求的数据进行比较。这带来了很多复杂性。
- en: It is hard to check whether a specific event has occurred – for example, creating
    resources and updating resources.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查特定事件是否发生很难——例如，创建资源和更新资源。
- en: Rate-limiting may block the client from sending too many requests at the desired
    intervals.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制可能会阻止客户端在期望的间隔内发送过多的请求。
- en: The ideal way to solve the problem of API polling is to allow the server to
    send events to the clients in real-time, rather than constantly polling and implementing
    the logic to check for changes. This is a different pattern from the request/response
    pattern. It supports real-time communication between servers and clients, which
    enables new possibilities for the application. This is what a real-time API can
    do.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 解决API轮询问题的理想方式是允许服务器实时向客户端发送事件，而不是不断轮询并实现检查变化的逻辑。这与请求/响应模式不同。它支持服务器和客户端之间的实时通信，为应用程序提供了新的可能性。这就是实时API所能做到的。
- en: What is a real-time API?
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是实时API？
- en: 'A real-time API goes beyond the traditional REST APIs. It provides some benefits:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 实时API超越了传统的REST API。它提供了一些好处：
- en: The application can respond to internal events in real-time. For example, if
    a new post is published, the client can get the notification immediately.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以实时响应内部事件。例如，如果发布了新的帖子，客户端可以立即收到通知。
- en: It can improve API efficiency by reducing the number of requests. The clients
    do not need API polling to check the resource changes. Instead, the server sends
    messages to clients when some events occur. It reduces the resources required
    during communication.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过减少请求数量来提高API效率。客户端不需要API轮询来检查资源变化。相反，当某些事件发生时，服务器会向客户端发送消息。它减少了通信过程中所需的资源。
- en: Some technologies can implement real-time APIs, such as long polling, **Server-Sent
    Events** (**SSE**), WebSocket, SignalR, and gRPC streaming.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一些技术可以实现实时API，例如长轮询、**服务器发送事件**（**SSE**）、WebSocket、SignalR和gRPC流。
- en: Let’s take a quick look at these.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下这些。
- en: Long polling
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长轮询
- en: The API polling problem we described previously is called short polling or regular
    polling, which is easy to implement but less efficient. The client cannot receive
    an update from the server in real-time. To overcome this issue, long polling is
    another choice.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的API轮询问题被称为短轮询或常规轮询，它易于实现但效率较低。客户端无法实时从服务器接收更新。为了克服这个问题，长轮询是另一个选择。
- en: Long polling is a variation of short polling, but it is based on *Comet*, which
    is a web application model in which a long-held HTTPS request allows a web server
    to push data to a browser, without it having to request it explicitly. Comet contains
    multiple techniques to implement long polling. It also has many names, such as
    Ajax push, HTTP streaming, and HTTP server push.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 长轮询是短轮询的一种变体，但它基于*Comet*，这是一种Web应用程序模型，其中长时间保持的HTTPS请求允许Web服务器在不显式请求的情况下向浏览器推送数据。Comet包含多种技术来实现长轮询。它也有许多名称，如Ajax推送、HTTP流和HTTP服务器推送。
- en: To use long polling, the client sends the request to the server but with the
    expectation that the server may not respond immediately. When the server receives
    the request, if there is no new data for the client, the server will keep the
    connection alive. If there is something available, the server will send the response
    to the client and complete the open request. The client receives the response
    and usually makes a new request right away or after a pre-defined interval to
    establish the connection again. The operation is repeated. In this way, it can
    effectively emulate the server push feature.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用长轮询，客户端向服务器发送请求，但预期服务器可能不会立即响应。当服务器收到请求时，如果没有新的数据供客户端，服务器将保持连接活跃。如果有可用的数据，服务器将向客户端发送响应并完成打开的请求。客户端收到响应后，通常会立即或在一个预定义的间隔后发出新的请求以重新建立连接。操作会重复进行。这样，它可以有效地模拟服务器推送功能。
- en: There are some considerations when using long polling. The server needs to manage
    multiple connections and preserve the session state. If the architecture becomes
    more complex (for example, when multiple servers or load balancers are in use),
    then it leads to the session stickiness issue, which means the subsequent client
    requests with the same session must be routed to the same server to which the
    original request was handled. It is hard to scale the application. Also, it is
    hard to manage the message order. If the browser has two tabs open and sends multiple
    requests simultaneously to write data, the server will not know which request
    is the latest.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用长轮询时有一些考虑因素。服务器需要管理多个连接并保持会话状态。如果架构变得更加复杂（例如，当使用多个服务器或负载均衡器时），则会导致会话粘性问题的出现，这意味着具有相同会话的后续客户端请求必须路由到处理原始请求的同一服务器。这很难扩展应用程序。同时，也难以管理消息顺序。如果浏览器有两个打开的标签页并且同时发送多个请求来写入数据，服务器将不知道哪个请求是最新的。
- en: Long polling is supported by many web browsers. In recent years, SSE and WebSocket
    have been widely adopted, so long polling is not the first choice anymore. Now,
    it is usually accompanied by other technologies or as a fallback. For example,
    SignalR uses long polling as a fallback when WebSocket and SSE are not available.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网页浏览器支持长轮询。近年来，SSE和WebSocket已被广泛采用，因此长轮询不再是首选。现在，它通常与其他技术一起使用或作为后备方案。例如，当WebSocket和SSE不可用时，SignalR使用长轮询作为后备方案。
- en: SSE
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSE
- en: SSE is a server push technology that allows the server to send events to the
    web browser. SSE was first proposed in 2004 as part of the *WHATWG Web Applications
    1.0*. It is based on the EventSource API, which is a standard API of HTML5\. The
    Opera web browser implemented this feature in 2006\. Now, all modern browsers
    support SSE.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: SSE是一种服务器推送技术，允许服务器向网页浏览器发送事件。SSE最初于2004年作为*WHATWG Web Applications 1.0*的一部分被提出。它基于HTML5的标准API，即EventSource
    API。Opera网页浏览器在2006年实现了这一功能。现在，所有现代浏览器都支持SSE。
- en: In SSE, the client behaves as a subscriber, initializing the connection by creating
    a new JavaScript `EventSource` object, passing the URL of the endpoint to the
    server over a regular HTTP `GET` request with the media type of `text/event-stream`.
    Once connected, the server keeps the connection open and pushes new events separated
    by a newline character to the client, until it has no more events to send, or
    until the client explicitly closes the connection by calling the `EventSource.close()`
    method.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSE中，客户端的行为像一个订阅者，通过创建一个新的JavaScript `EventSource`对象来初始化连接，通过带有`text/event-stream`媒体类型的常规HTTP
    `GET`请求将端点的URL传递给服务器。一旦连接，服务器保持连接打开，并将新事件以换行符分隔推送到客户端，直到没有更多事件要发送，或者直到客户端通过调用`EventSource.close()`方法显式关闭连接。
- en: If the client lost the connection for any reason, it could reconnect to receive
    new events. To recover from the failure, the client can provide a `Last-Event-ID`
    header to the server to specify the last event ID that the client received. Then,
    the server can use this information to determine whether the client missed any
    events.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端由于任何原因丢失了连接，它可以重新连接以接收新的事件。为了从故障中恢复，客户端可以向服务器提供一个`Last-Event-ID`头，以指定客户端接收到的最后一个事件ID。然后，服务器可以使用这些信息来确定客户端是否错过了任何事件。
- en: SSE is suitable for scenarios where real-time notifications have to be sent
    to the client when the data changes from the server, in order to keep a user interface
    in sync with the latest data state. Examples include Twitter updates, stock price
    updates, news feeds, alerts, and so on.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据从服务器变化时，SSE适用于需要向客户端发送实时通知的场景，以保持用户界面与最新的数据状态同步。例如包括Twitter更新、股票价格更新、新闻源、警报等等。
- en: The limitation of SSE is that it is unidirectional, so it cannot be used to
    send data from the client to the server. Once the client connects to the server,
    it can receive responses only, but it cannot send new requests on the same connection.
    If you need bidirectional communication, WebSocket may be a better option.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: SSE的限制在于它是单向的，因此不能用来从客户端向服务器发送数据。一旦客户端连接到服务器，它只能接收响应，但不能在同一个连接上发送新的请求。如果您需要双向通信，WebSocket可能是一个更好的选择。
- en: WebSocket
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebSocket
- en: WebSocket is a protocol that provides full-duplex communication between a client
    and a server within a single TCP connection. It allows the client to send requests
    to the server, while the server can push events and responses back to the client
    in real-time. WebSocket was first referenced as a TCP-based socket API in the
    HTML5 specification. In 2008, the WebSocket protocol was standardized by W3C.
    Google Chrome was the first browser to support WebSocket in 2009\. Now, WebSocket
    is supported in most modern browsers, including Google Chrome, Microsoft Edge,
    Firefox, Safari, and Opera.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 是一种协议，它在一个 TCP 连接内提供客户端和服务器之间的全双工通信。它允许客户端向服务器发送请求，同时服务器可以实时地将事件和响应推回客户端。WebSocket
    首次在 HTML5 规范中被引用为基于 TCP 的套接字 API。2008 年，WebSocket 协议由 W3C 标准化。2009 年，Google Chrome
    成为第一个支持 WebSocket 的浏览器。现在，WebSocket 在大多数现代浏览器中都得到了支持，包括 Google Chrome、Microsoft
    Edge、Firefox、Safari 和 Opera。
- en: Unlike the HTTP protocol, WebSocket enables a two-way ongoing conversation between
    the client and server. The communication is usually done over a TCP port `443`
    connection (or `80` if there is an unsecure connection), so it can be easily configured
    in a firewall.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTTP 协议不同，WebSocket 允许客户端和服务器之间进行双向的持续对话。通信通常通过 TCP 端口 `443` 连接（如果存在不安全的连接，则为
    `80`），因此它可以在防火墙中轻松配置。
- en: 'From a WebSocket perspective, the message content is opaque. A subprotocol
    is required to specify an agreement between the client and server. WebSocket can
    support both text and binary format subprotocols. As part of the initial handshake
    process, the client can specify which subprotocols it supports. Then, the server
    must pick one of the protocols that the client supports. This is called subprotocol
    negotiation. You can find many subprotocols officially registered here: [https://www.iana.org/assignments/websocket/websocket.xml](https://www.iana.org/assignments/websocket/websocket.xml).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从 WebSocket 的角度来看，消息内容是透明的。需要一个子协议来指定客户端和服务器之间的协议。WebSocket 可以支持文本和二进制格式的子协议。作为初始握手过程的一部分，客户端可以指定它支持哪些子协议。然后，服务器必须选择客户端支持的协议之一。这被称为子协议协商。您可以在以下位置找到许多官方注册的子协议：[https://www.iana.org/assignments/websocket/websocket.xml](https://www.iana.org/assignments/websocket/websocket.xml)。
- en: 'The WebSocket protocol defines `ws` and `wss` as the URI schemas that are used
    for unencrypted and encrypted connections, respectively. It is always recommended
    to use `wss` to make sure the transport security layer encrypts data. For example,
    we can use the following code to create a WebSocket connection in JavaScript:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议定义了 `ws` 和 `wss` 作为分别用于未加密和加密连接的 URI 架构。始终建议使用 `wss` 来确保传输安全层加密数据。例如，我们可以使用以下代码在
    JavaScript 中创建 WebSocket 连接：
- en: '[PRE11]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: WebSocket does not define how to manage the events for the connections, such
    as reconnection, authentication, and so on. The client and server would need to
    manage those events. There are various libraries to implement WebSocket for different
    languages. For example, *Socket.IO* ([https://socket.io](https://socket.io)) is
    a popular library that implements WebSocket servers and clients in JavaScript,
    Java, Python, and so on.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 没有定义如何管理连接的事件，例如重新连接、身份验证等。客户端和服务器需要管理这些事件。有各种库用于实现不同语言的 WebSocket。例如，*Socket.IO*
    ([https://socket.io](https://socket.io)) 是一个流行的库，它实现了 JavaScript、Java、Python 等语言的
    WebSocket 服务器和客户端。
- en: WebSocket is a great choice for real-time communications, such as online games,
    sales updates, sports updates, online chat, real-time dashboards, and so on.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 是实时通信（如在线游戏、销售更新、体育更新、在线聊天、实时仪表盘等）的一个很好的选择。
- en: Uni-directional versus bidirectional
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 单向与双向
- en: Uni-directional communication is like a radio. SSE is uni-directional because
    the server broadcasts data to clients, but clients cannot send data to the server.
    Bidirectional communication supports two-way communication. There are two types
    of bidirectional communication – half-duplex and full-duplex.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 单向通信就像收音机。SSE 是单向的，因为服务器向客户端广播数据，但客户端不能向服务器发送数据。双向通信支持双向通信。有两种类型的双向通信——半双工和全双工。
- en: Half-duplex communication is like a walkie-talkie. Both the server and client
    can send messages to each other, but only one party may send messages at a time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 半双工通信就像对讲机。服务器和客户端都可以互相发送消息，但一次只能有一方发送消息。
- en: Full-duplex communication is like a telephone. The message can be sent from
    either side at the same time. WebSocket is full-duplex.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 全双工通信就像电话。消息可以从任何一方同时发送。WebSocket 是全双工的。
- en: gRPC streaming
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC 流
- en: We introduced gRPC in the previous section. As we mentioned, gRPC is based on
    the HTTP/2 protocol, which provides a foundation for long-lived, real-time communication.
    Unlike HTTP/1.1, which requires a new TCP socket connection for each request,
    one HTTP/2 connection can be used for one or more simultaneous requests, so this
    avoids the overhead of creating new connections for each request. Also, HTTP/2
    supports pushing data to clients without them having to request it. It is a huge
    improvement over the request/response pattern of HTTP/1.1.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中介绍了 gRPC。正如我们提到的，gRPC 基于 HTTP/2 协议，这为长连接的实时通信提供了基础。与需要为每个请求创建新的 TCP 套接字连接的
    HTTP/1.1 不同，一个 HTTP/2 连接可以用于一个或多个同时进行的请求，这样就避免了为每个请求创建新连接的开销。此外，HTTP/2 支持在客户端不需要请求的情况下向客户端推送数据。这比
    HTTP/1.1 的请求/响应模式有了巨大的改进。
- en: 'gRPC takes advantage of the HTTP/2 protocol to support bidirectional communication.
    A gRPC service supports these streaming combinations:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 利用 HTTP/2 协议来支持双向通信。一个 gRPC 服务支持以下流组合：
- en: Unary (No streaming)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一（无流式传输）
- en: Server-to-client streaming
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器到客户端的流式传输
- en: Client-to-server streaming
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端到服务器的流式传输
- en: Bidirectional streaming
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向流式传输
- en: Both gRPC and WebSocket support full-duplex communication, but, unlike WebSocket,
    gRPC uses `protobuf` by default, so it does not need to select a subprotocol.
    However, browsers have no built-in support for gRPC, so gRPC streaming is often
    used for service-to-service communication.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 和 WebSocket 都支持全双工通信，但与 WebSocket 不同，gRPC 默认使用 `protobuf`，因此不需要选择子协议。然而，浏览器没有内置对
    gRPC 的支持，因此 gRPC 流通常用于服务到服务的通信。
- en: Which real-time communication technology is best for your application?
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪种实时通信技术最适合您的应用程序？
- en: There are a couple of choices for your real-time application. So, how do we
    choose? It is important to note that it depends on the circumstances and constraints
    of your application. For example, do you need a push-only application or bidirectional
    communication? Do you want to support most browsers or just server-to-service
    communication? Do you need to push data to multiple clients or just one client?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的实时应用程序，有几个选择。那么，我们该如何选择？重要的是要注意，这取决于您应用程序的具体情况和限制。例如，您是否需要一个单向推送应用程序或双向通信？您是否希望支持大多数浏览器，或者只是服务器到服务的通信？您是否需要将数据推送到多个客户端，或者只是单个客户端？
- en: Fortunately, Microsoft provides **SignalR** in ASP.NET Core to implement real-time
    communication. SignalR is an open-source library that enables real-time communication
    between clients and servers. It can automatically manage the connections and allow
    servers to send messages to all connected clients or a specific group of clients.
    Note that SignalR encapsulates multiple technologies, including WebSocket, SSE,
    and long polling. It hides the details and the complex implementations of these
    protocols. As a result, we do not need to worry about which technology is used
    for real-time communication. SignalR automatically chooses the best transport
    method for your application. WebSocket is the default protocol. If WebSocket is
    unavailable, SignalR will fall back to SSE, and then long polling.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Microsoft 在 ASP.NET Core 中提供了 **SignalR** 来实现实时通信。SignalR 是一个开源库，它使得客户端和服务器之间能够实现实时通信。它能够自动管理连接，并允许服务器向所有已连接的客户端或特定客户端组发送消息。请注意，SignalR
    封装了多种技术，包括 WebSocket、SSE 和长轮询。它隐藏了这些协议的细节和复杂的实现。因此，我们不需要担心用于实时通信的技术。SignalR 会自动为您的应用程序选择最佳的传输方法。WebSocket
    是默认协议。如果 WebSocket 不可用，SignalR 将回退到 SSE，然后是长轮询。
- en: 'SignalR is a good choice for these scenarios:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 是这些场景下的一个不错的选择：
- en: When clients require high-frequency updates or alerts/notifications from the
    server – for example, games, social networks, voting, auctions, maps, and so on
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端需要从服务器获取高频更新或警报/通知时——例如，游戏、社交网络、投票、拍卖、地图等
- en: Dashboard and monitoring applications – for example, system dashboard applications,
    instant diagram applications, sales data monitoring applications, and so on
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板和监控应用程序——例如，系统仪表板应用程序、即时绘图应用程序、销售数据监控应用程序等
- en: Collaborative applications – for example, chat applications,whiteboard applications,
    and so on
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作应用程序——例如，聊天应用程序、白板应用程序等
- en: ASP.NET Core also provides good support to gRPC. So, the next question is, how
    do you choose between gRPC and SignalR?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 也为 gRPC 提供了良好的支持。那么，下一个问题是，您如何在 gRPC 和 SignalR 之间进行选择？
- en: 'Here are some thoughts you may want to consider:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些您可能想要考虑的想法：
- en: If your need to build a real-time application that supports multiple clients
    (browsers), you may use SignalR because it is well-supported by browsers, and
    gPRC is not.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要构建一个支持多个客户端（浏览器）的实时应用程序，你可以使用SignalR，因为它得到了浏览器的良好支持，而gRPC则没有。
- en: If you need to build a distributed application or a microservices architecture
    application where you want to communicate between multiple servers, you may use
    gRPC because it is more suitable for server-to-server communication, and is more
    efficient than SignalR in this scenario.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要构建一个分布式应用程序或微服务架构应用程序，其中你希望在多个服务器之间进行通信，你可以使用gRPC，因为它更适合服务器之间的通信，并且在这个场景下比SignalR更高效。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced some different API styles, including REST-based
    APIs, gRPC APIs, and GraphQL APIs, and explored how to design them. We also introduced
    a couple of different ways to implement real-time communication, including WebSocket,
    gRPC streaming, and SignalR. So far, we have not touched on much code, but we
    have reviewed the basic concepts of web APIs.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些不同的API风格，包括基于REST的API、gRPC API和GraphQL API，并探讨了如何设计它们。我们还介绍了几种实现实时通信的不同方法，包括WebSocket、gRPC流和SignalR。到目前为止，我们还没有涉及太多代码，但我们已经回顾了Web
    API的基本概念。
- en: In the next chapter, we will start to learn how to use ASP.NET Core to implement
    them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习如何使用ASP.NET Core来实现它们。
