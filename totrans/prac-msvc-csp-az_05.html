<html><head></head><body>
		<div><h1 id="_idParaDest-111" class="chapter-number"><a id="_idTextAnchor110"/>5</h1>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Containerization of Microservices</h1>
			<p>After building clients and services with the previous chapters, now is the time to make the services ready for publishing. With Docker, we can prepare images that have everything included to run the complete solution.</p>
			<p>In this chapter, you’ll start learning the most important parts of Docker, building Docker images, running containers, and using .NET Aspire to run a solution consisting of multiple services locally on your developer system, including SQL Server running in a Docker container, as well as making use of native <strong class="bold">ahead-of-time</strong> (<strong class="bold">AOT</strong>) to create platform-specific native applications.</p>
			<p>In this chapter, you’ll learn about the following topics:</p>
			<ul>
				<li>Working with Docker</li>
				<li>Building a Docker image</li>
				<li>Running the solution with .NET Aspire</li>
				<li>Using native AOT with ASP.NET Core</li>
			</ul>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Technical requirements</h1>
			<p>What you need to go through this chapter is <strong class="bold">Docker Desktop</strong>. Docker Desktop is free for individual developers and education and open source communities. You can download Docker Desktop from <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>, best used with the <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>). Check the README file of this chapter to install WSL 2 and Docker Desktop.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>dotnet publish</code> command supports building and publishing Docker images. While some features of <code>dotnet publish</code> can be used without Docker Desktop being installed, we start using Docker directly, as this also helps in understanding what can be done using the .NET CLI, and often you need a lot more in regard to Docker than offered by the .NET CLI.</p>
			<p>The code for this chapter can be found in the following GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>.</p>
			<p>The <code>ch05</code> source code folder contains the code samples for this chapter. For different sections of this chapter, different subfolders are available. For a start, working through the instructions, you can use the <code>StartXX</code> folders. <code>StartDocker</code> contains the projects before creating Docker containers have been added and the <code>FinalDocker</code> folder contains the project in the final state after building the Docker container.</p>
			<p>The <code>StartAspire</code> folder contains multiple projects that the .NET Aspire-specific projects we created in the previous chapters are already part of. Use this as a starting point to work through the .NET Aspire part of this chapter. <code>FinalAspire</code> contains the complete result, which you can use as a reference. The <code>NativeAOT</code> folder contains the code for the games API that compiles with .NET native AOT.</p>
			<p>In the subfolders of the <code>ch05</code> folder, you’ll see these projects:</p>
			<ul>
				<li><code>Codebreaker.GameAPIs</code> – The games API project we used in the previous chapter from our client application. In this chapter, we make minor updates to specify the connection string to the SQL Server database. This project has a reference to NuGet packages with implementations of the <code>IGamesRepository</code> interface for SQL Server and Azure Cosmos DB.</li>
				<li><code>Codebreaker.Bot</code> – This is a new project that implements a REST API and calls the games API to automatically play games with random game moves. This project makes use of the client library we created in <a href="B21217_04.xhtml#_idTextAnchor092"><em class="italic">Chapter 4</em></a> – it has a reference to the <code>CNinnovation.Codebreaker.Client</code> NuGet package to call the games API.</li>
				<li><code>Codebreaker.AppHost</code> – This project is enhanced to orchestrate the different services.</li>
				<li><code>Codebreaker.ServiceDefaults</code> – This project is unchanged in this chapter.</li>
				<li><code>Codebreaker.GameAPIs.NativeAOT</code> – A new project that offers the same games API with some changes to support native AOT with .NET 8.</li>
			</ul>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Working with Docker</h1>
			<p>Although <a id="_idIndexMarker267"/>nowadays, it’s possible just to work with .NET tools to create microservices and run Docker containers, it helps to know about Docker. Thus, here, we look at the most important concepts about Docker, starting up a SQL Server instance running within a Docker container, creating a Dockerfile to build a Docker image for the games API service, and running these containers on the local system. In case you already know all about Docker, you can skip and move over to the <em class="italic">.NET Aspire</em> section, which does not need the Docker containers created here.</p>
			<p>Before diving into building Docker images, why do we need containers at all? When deploying an application, it often occurs that the application fails to run. Often, a reason for this is a missing runtime on the target system or wrong or missing configuration settings. One way to resolve this is to <a id="_idIndexMarker268"/>prepare <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) where everything is preinstalled. The disadvantage of this is the resources that the VM needs. A VM comes with an operating system and allocates CPU and memory resources. Docker is a lot more lightweight. A Docker image can be small as an operating system is not part of the image – and multiple Docker containers can share the same CPU and memory.</p>
			<p>Here’s a brief list of important terms when using Docker before going into the details:</p>
			<ul>
				<li>A Docker <strong class="bold">image</strong> is<a id="_idIndexMarker269"/> an executable package that contains everything to run an application</li>
				<li>One image might have different versions, which are identified by<a id="_idIndexMarker270"/> Docker <strong class="bold">tags</strong></li>
				<li>A <strong class="bold">Dockerfile</strong> is a<a id="_idIndexMarker271"/> text file with instructions to build a Docker image</li>
				<li>A Docker <strong class="bold">container</strong> is<a id="_idIndexMarker272"/> the running instance of a Docker image</li>
				<li>The Docker <strong class="bold">registry</strong> is<a id="_idIndexMarker273"/> where Docker images are stored</li>
				<li>A Docker <strong class="bold">repository</strong> is a<a id="_idIndexMarker274"/> collection of different versions of a Docker image in the registry</li>
			</ul>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Using Docker Desktop</h2>
			<p>Docker Desktop <a id="_idIndexMarker275"/>for Windows offers an environment to build Docker images and run Docker containers on Windows. You can configure it to use Windows or Linux containers. With a previous edition of Docker Desktop for Windows, it was required to install Hyper-V. Docker Desktop then used a Linux VM to run all Linux containers on this VM. Because Windows now supports Linux more natively with WSL, Docker Desktop<a id="_idIndexMarker276"/> can use WSL and doesn’t need a VM. With the Docker Desktop configuration, you can select WSL distros (see <em class="italic">Figure 5</em><em class="italic">.1</em>) that should use the same Docker environment as on the Windows system itself. Using these Linux distributions, you can use the same Docker commands to manage your Docker environment:</p>
			<div><div><img src="img/B21217_05_01.jpg" alt="Figure 5.1 – WSL integration in Docker Desktop"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – WSL integration in Docker Desktop</p>
			<p>Instead of configuring a VM with the amount of CPU and memory you allocate, WSL shares CPU and memory with Windows – but there are some limits for WSL. With the Windows build version 20176 and later, the memory is limited to 50% and 8 GB (whichever is less); with builds before that, WSL can use 80% of the total memory.</p>
			<p>For the number<a id="_idIndexMarker277"/> of logical processors, by default, all available can be used. You can change memory and CPU limits globally for the complete subsystem but also define different limits for each Linux distribution you install. Check the settings configuration in WSL at <a href="https://learn.microsoft.com/windows/wsl/wsl-config">https://learn.microsoft.com/windows/wsl/wsl-config</a>.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Running a Docker container</h2>
			<p>After <a id="_idIndexMarker278"/>you’ve installed Docker Desktop and you are running Windows, you can select to run Windows or Linux containers. While Windows containers are great for legacy applications that only run on Windows (for example, using .NET Framework), Linux containers offer more features, and Linux Docker images are smaller. The solution we build will run with Linux containers.</p>
			<p>The Docker Desktop environment needs to be started, then to run the first container, use this command:</p>
			<pre class="console">
docker run hello-world</pre>
			<p>On the first run, the <code>hello-world</code> Docker image is downloaded from the Docker registry and started. This container just writes a message to the screen to verify that everything is running. Starting it a second time, you’ll see that the image is no longer downloaded but started immediately.</p>
			<p>To see all images downloaded, you can use this command:</p>
			<pre class="console">
docker images</pre>
			<p>To see running containers, use the following command:</p>
			<pre class="console">
docker container ls</pre>
			<p>There’s also a shorthand notation to show all running containers: <code>docker ps</code>.</p>
			<p>You will not see the <code>hello-world</code> container because this already stopped immediately after writing the output.</p>
			<p>Running an image again and again, you start fresh again. But there’s also a state kept with a running image. This allows you to continue a previously stopped container with the same state as before. The <code>docker container ls -a</code> command not only shows running but also stopped containers. Using <code>docker container prune</code>, you can delete the state from all stopped containers.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Running SQL Server in a Docker container</h2>
			<p>In <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we <a id="_idIndexMarker279"/>used SQL Server and an Azure Cosmos DB emulator on the local system to access it from the games service. Instead<a id="_idIndexMarker280"/> of installing these products on your local system, you can also use Docker images.</p>
			<p>Let’s start downloading the Docker image for SQL Server:</p>
			<pre class="console">
docker pull mcr.microsoft.com/mssql/server:2022-latest</pre>
			<p>Previously, we used <code>docker run</code> to start a container and implicitly download it from a registry. <code>docker pull</code> just downloads the image from the registry. <code>mcr.microsoft.com</code> is the Microsoft repository where Microsoft stores images. <code>mssql/server</code> is the name of the image. You can read information about this image at <a href="https://hub.docker.com/_/microsoft-mssql-server">https://hub.docker.com/_/microsoft-mssql-server</a>. This is an Ubuntu-based image. <code>2022-latest</code> is a tag name. This is the actual version of SQL Server 2022. With SQL Server, other tags are <code>2019-latest</code>, <code>2017-latest</code>, and <code>latest</code>. These correspond to SQL Server 2019 and 2017. The <code>latest</code> tag is the latest version of SQL Server. At the time of this writing, the image is the same with both the <code>2022-latest </code>and the <code>latest</code> tags. If you download both images, a second download is not needed, and you will see images with the same image ID but with different tags.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The default configuration to use SQL Server with the Docker image is the SQL Server Developer Edition. You can also configure to use the Express, Standard, Enterprise, and Enterprise Core editions by setting an environmental variable. Pay attention to required licenses with non-developer editions. Read the image documentation for setting environment variables for the different editions.</p>
			<p class="callout">Another option to use a SQL Server edition within a Docker environment is Azure SQL Edge. Check <a href="https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment">https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment</a> for running Azure SQL Edge.</p>
			<p>To run the <a id="_idIndexMarker281"/>SQL Server image, you can use the following command:</p>
			<pre class="console">
docker run -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=Pa$$w0rd" -p 14333:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2022-latest</pre>
			<p>With this <a id="_idIndexMarker282"/>command, these options are used:</p>
			<ul>
				<li><code>-e</code> specifies an environmental variable. With the two variables, the license is accepted, and a password for the <code>sa</code> account is defined. <code>sa</code> is a privileged account configured, and a short name for <em class="italic">system administrator</em>.</li>
				<li>The <code>-p</code> option maps the port from the host to the container. On the target host, the same port cannot be used for multiple applications; for example, by having a local SQL Server running, the first value cannot use 1433. Make sure to use an available port.</li>
				<li>The <code>--name</code> option specifies a name for the container. By default, a random name combined from two lists is used.</li>
				<li>The <code>--hostname</code> option specifies the hostname for the container.</li>
				<li>The <code>-d</code> option runs the container in the background.</li>
			</ul>
			<p>For some useful information to find out what the container does, use <code>docker </code><code>container logs</code>:</p>
			<pre class="console">
docker container logs sql1</pre>
			<p>This command needs the name of the container. To connect and wait for all the logs to come, add the <code>-f</code> option (for <em class="italic">follow</em>).</p>
			<p>To open a command prompt within the container and see what’s there, use <code>docker exec -it sql1 bash</code>, which allocates a terminal, keeps <code>stdin</code> open (interactive mode), and executes the Bash shell within the container.</p>
			<p>After the container with SQL Server is running, we can publish the database we created in <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Using volumes with a Docker container</h2>
			<p>The Docker container<a id="_idIndexMarker283"/> for SQL Server contains state (the database files). We can start a previous running container again (using <code>docker start</code>). When using <code>docker run</code>, we start fresh again, and the previous state is not used. Using <code>docker commit</code>, you can create a new image from a container. This keeps the database and the state together, and the Docker images grow in size. A better practice is to keep the state outside of the Docker container. You can mount external directories, files, and Docker volumes within a container. Docker volumes are completely managed by Docker. Let’s use this for SQL Server.</p>
			<p>First, create a volume:</p>
			<pre class="console">
docker volume create gamessqlstorage</pre>
			<p>This creates a volume with the name <code>gamessqlstorage</code>. To check the volumes available, use <code>docker volume ls</code>. To get more information about a volume, execute <code>docker </code><code>volume inspect</code>.</p>
			<p>Let’s run the container with the database using this volume:</p>
			<pre class="console">
docker run -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=Pa$$w0rd" -p 14333:1433 --name codebreakersql1 --hostname codebreakersql1 -v gamessqlstorage:/var/opt/mssql -d mcr.microsoft.com/mssql/server:2022-latest</pre>
			<p>The <code>-v</code> option mounts the <code>/var/opt/mssql</code> folder within the container to the <code>gamessqlstorage</code> volume. All data written by SQL Server to this folder now goes into this volume. The state is now kept externally from the container. So, let’s create a database next.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When creating backups of the database, you should also use volumes.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Creating a database in the Docker container</h2>
			<p>As the <a id="_idIndexMarker284"/>container is running, you can access it with a tool such as <strong class="bold">SQL Server Object Explorer</strong> from Visual Studio or <strong class="bold">SQL Server Management Studio</strong>. The connection string you can use is shown in the following .NET configuration file:</p>
			<pre class="source-code">
{
  "ConnectionStrings": {
    "GamesSqlServerConnection": <strong class="bold">"server=host.docker.internal,14333;database=CodebreakerGames;user id=sa;password=Pa$$w0rd;TrustServerCertificate=true"</strong>
  }
}</pre>
			<p>With the <code>appsettings.json</code> file, you also need to change the <code>DataStore</code> key to the <code>SqlServer</code> value.</p>
			<p>Using Docker with a Linux host system, you can use the IP address of the Docker container with the port number to access services within the Docker container. This might not work with Windows. That’s why the <code>host.docker.internal</code> hostname was introduced: to map to the service via a gateway using the local port number. With the connection string to the database, you need to add the port number after the hostname, separated by a comma. To pass the user and password, use the <code>user id</code> and <code>password</code> keys. Because the certificate from the server Docker container might not be from a trusted authority on the Windows system, add the <code>TrustServerCertificate</code> setting to the connection string.</p>
			<p>In <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we published a database using the <code>dotnet ef</code> command line. Now is the time to create this database within the Docker container. With the following command, your current directory needs to be the directory of the games API service (<code>Codebreaker.GameAPIs</code>), the <code>DataStorage</code> configuration value in <code>appsettings</code> set to <code>SqlServer</code>, and the connection string specified as shown before:</p>
			<pre class="console">
cd Codebreaker.GameAPIs
dotnet ef database update -p ..\Codebreaker.Data.SqlServer -c GamesSqlServerContext</pre>
			<p>With this, the database is created – or migrated to the latest version. The <code>-p</code> option is needed because the EF Core context is in a different project than the <code>-c</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With the games service project, you have another option to create the database. For an easier way to create a SQL Server database, the <code>/createsql</code> API is offered now in addition to the other APIs. Sending a <code>POST</code> request creates or upgrades the database (if SQL Server is configured) using the EF Core <code>MigrateAsync</code> method.</p>
			<p>Next, let’s <a id="_idIndexMarker286"/>create a custom Docker image for the games API service. <em class="italic">Figure 5</em><em class="italic">.2</em> shows a C4 container diagram to give you an overview picture of the containers we use. The first container we create is the one on the right, hosting SQL Server. Next, we create a Docker image for the game APIs, which accesses the SQL Server container. The container on the left is the new bot project, which invokes the services running in the game APIs’ container to automatically play games:</p>
			<div><div><img src="img/B21217_05_02.jpg" alt="Figure 5.2 – C4 container diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – C4 container diagram</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Building a Docker image</h1>
			<p>The .NET CLI <code>dotnet publish</code> command supports creating Docker images without using a<a id="_idIndexMarker287"/> Dockerfile. However, to understand Docker, we need to know about Dockerfiles. That’s why we start building a Docker image defining a Dockerfile first.</p>
			<p>In this section, we will do the following:</p>
			<ul>
				<li>Create a Dockerfile for the games API</li>
				<li>Build a Docker image using the Dockerfile</li>
				<li>Run the games API with a Docker container</li>
				<li>Create a Docker image using <code>dotnet publish</code></li>
			</ul>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Creating a Dockerfile</h2>
			<p>Docker images<a id="_idIndexMarker288"/> are created using instructions in Dockerfiles. Using Visual Studio, you can easily create a Dockerfile from Solution Explorer, using <code>Codebreaker.GamesAPI</code> project creates a multi-stage Dockerfile. A multi-stage Dockerfile creates interim images for different stages.</p>
			<h3>Base stage</h3>
			<p>With the<a id="_idIndexMarker289"/> following code snippets, the different stages are explained. The first stage prepares a Docker image for the production environment:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Dockerfile</p>
			<pre class="source-code">
<strong class="bold">FROM</strong> mcr.microsoft.com/dotnet/aspnet:8.0 <strong class="bold">AS</strong> base
<strong class="bold">USER</strong> app
<strong class="bold">WORKDIR</strong> /app
<strong class="bold">EXPOSE</strong> 8080</pre>
			<p>Every Dockerfile starts with a <code>FROM</code> instruction. The <code>FROM</code> instruction defines the base image that is used. <code>mcr.microsoft.com/dotnet/aspnet</code> is an image optimized for production. With .NET 8, this image is based on Debian 12 (Bookworm). The <code>Debian:12-slim</code> image is defined by a Dockerfile with <code>FROM scratch</code>, so this is the root of the hierarchy of instructions. The <code>dotnet/aspnet</code> image contains the .NET runtime and the ASP.NET Core runtime. The .NET SDK is not available with this image. The <code>AS</code> instruction defines a name that allows using the result of this stage with another stage. The <code>USER</code> instruction defines the user that should be used with the instructions of the stage. The <code>WORKDIR</code> instruction sets the working directory for following instructions. If the directory does not exist in the image, it’s created. The last step in the first stage is the <code>EXPOSE</code> instruction. With <code>EXPOSE</code>, you define the ports that the application is listening to. By default, <code>TCP</code> is used, but you can also specify to have an <code>UDP</code> receiver.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">.NET 8 has some changes with Docker image generation: the default container images run with non-root users (the app user), and the default port is no longer port 80. Port 80 is a privileged port that requires the root user. The new default port is now 8080.</p>
			<h3>Build stage</h3>
			<p>The <a id="_idIndexMarker290"/>second stage builds the ASP.NET Core application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Dockerfile</p>
			<pre class="source-code">
<strong class="bold">FROM</strong> mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
<strong class="bold">WORKDIR</strong> /src
<strong class="bold">COPY</strong> ["Codebreaker.GameAPIs/Codebreaker.GameAPIs.csproj", "Codebreaker.GameAPIs/"]
<strong class="bold">RUN</strong> dotnet restore "./Codebreaker.GameAPIs/Codebreaker.GameAPIs.csproj"
<strong class="bold">COPY</strong> . .
<strong class="bold">WORKDIR</strong> "/src/Codebreaker.GameAPIs"
<strong class="bold">RUN</strong> dotnet build "./Codebreaker.GameAPIs.csproj" -c $BUILD_CONFIGURATION -o /app/build</pre>
			<p>With the second stage, we ignore the first stage for a moment and use a different base image: <code>dotnet/sdk</code>. This image contains the .NET SDK and is used to build the application. First, a <code>src</code> directory is created, and the current directory is set to <code>src</code>. The <code>ARG</code> instruction specifies an argument that can be passed when invoking building the Docker image. If this argument is not passed, the default value is <code>Release</code>. Next, you’ll see multiple <code>COPY</code> instructions to copy the project files to subfolders within the current directory. The project files contain the package references. In case the <code>dotnet restore</code> command that is started using the <code>RUN</code> instruction fails, there’s no need to continue with the next steps. <code>dotnet restore</code> downloads the NuGet packages. In case you use a different NuGet feed, the Dockerfile needs some changes to copy <code>nuget.config</code> as well. When <code>dotnet restore</code> succeeds, the complete source code from <code>.</code> is copied to the current directory (which is <code>src</code> at this time) with the <code>COPY</code> instruction. Next, the working directory is changed to the directory of the games API project, and the <code>dotnet build</code> command is invoked to create release code for the application. With <code>dotnet build</code>, the <code>BUILD_CONFIGURATION</code> argument is used, which was specified with <code>ARG</code>. Having the release build in the <code>src/app/build</code> folder is the result for the interim image after the last command.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To make sure that unnecessary files are not copied with instructions such as <code>COPY . .</code>, the <code>.dockerignore</code> file is used. Similar to the <code>.gitignore</code> file where files are specified to be ignored, with a <code>.dockerignore</code> file, you specify what files should not be copied to the image.</p>
			<h3>Publish stage</h3>
			<p>Next, the <a id="_idIndexMarker291"/>second stage is used as a base for the third stage:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Dockerfile</p>
			<pre class="source-code">
<strong class="bold">FROM</strong> build AS publish
ARG BUILD_CONFIGURATION=Release
<strong class="bold">RUN</strong> dotnet publish "./Codebreaker.GameAPIs.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false</pre>
			<p>The <code>FROM build</code> instruction uses the result from the previous stage and continues here. The <code>dotnet publish</code> command results in code that’s needed to publish the application. The files needed for publication are copied to the <code>/src/app/publish</code> folder. While the working directory was configured with the previous stage, continuing on the build image, the working directory is still set.</p>
			<h3>Final stage</h3>
			<p>With the final stage, we<a id="_idIndexMarker292"/> continue with the first stage, which was named <code>base</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Dockerfile</p>
			<pre class="source-code">
<strong class="bold">FROM</strong> base AS final
<strong class="bold">WORKDIR</strong> /app
<strong class="bold">COPY --from=publish /app/publish .</strong>
<strong class="bold">ENTRYPOINT</strong> ["dotnet", "Codebreaker.GameAPIs.dll"]</pre>
			<p>The first instruction with this stage is to set the working directory to <code>app</code>. Then, referencing the third state with <code>--from=publish</code>, the <code>/app/publish</code> directory from the <code>publish</code> stage is copied to the current directory. The <code>ENTRYPOINT</code> instruction defines <a id="_idIndexMarker293"/>what should be done on running the image: the <code>dotnet bootstrapper</code> command starts and receives <code>Codebreaker.GameAPIs.dll</code> as an argument. You can do this from the command line as well: <code>dotnet Codebreaker.GameAPIs.dll</code> starts the entry point of the application to kick off the Kestrel server, and the application is available to receive requests.</p>
			<p>Before building the Dockerfile, make sure the <code>DataStore</code> configuration in <code>appsettings.json</code> is set to <code>InMemory</code> to use the in-memory provider by default when starting the container.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Building a Docker image with a Dockerfile</h2>
			<p>To build<a id="_idIndexMarker294"/> the image, set the current directory to the directory of the solution, and use this command:</p>
			<pre class="console">
docker build . -f Codebreaker.GameAPIs\Dockerfile -t codebreaker/gamesapi:3.5.3 -t codebreaker/gamesapi:latest</pre>
			<p>With simple Dockerfiles, using just <code>docker build</code> can be enough to build the image. However, the Dockerfile we use contains references to other projects. With this, we need to pay attention to the context. With the games API service, multiple projects need to be compiled, and the paths used as specified with the Dockerfile use the parent directory. Setting the current directory to the directory of the solution, the context is set to this directory with the first argument after the build command (<code>.</code>). The <code>-f</code> option next references the location of the Dockerfile. With the <code>-t</code> option, the image is tagged. The repository name (<code>codebreaker/gamesapi</code>) needs to be lowercase, followed by the <code>3.5.3</code> tag name and the <code>latest</code> tag name. Tag names can be strings; there’s no requirement on the version. It’s just a good practice to always tag the latest version with the <code>latest</code> tag. Specifying the <code>-t</code> option two times, we get two image names that reference the same image with the same image identifier.</p>
			<p>To list the images built, use <code>docker images</code>. To restrict the output to <code>codebreaker</code> images, you can define a filter:</p>
			<pre class="console">
docker images codebreaker/*</pre>
			<p>To check a Docker image for how it was built, we can use the <code>docker </code><code>history</code> command:</p>
			<pre class="console">
docker history codebreaker/gamesapi:latest</pre>
			<p><em class="italic">Figure 5</em><em class="italic">.3</em> shows<a id="_idIndexMarker295"/> the result of the <code>docker history</code> command. This shows every instruction from the Dockerfile that was used to build the image. Of course, what you don’t see with the <code>codebreaker/gamesapi</code> image is the <code>dotnet build</code> and <code>dotnet restore</code> commands. The <code>build</code> and <code>publish</code> stages have only been used for interim images to build the application and to create the files needed. Comparing the output to the Dockerfile we created, you see <code>ENTRYPOINT</code> on top, followed by <code>COPY</code>, <code>WORKDIR</code>, and so on. With each of these instructions, you can also see the size result of the instruction. The <code>COPY</code> command copied 3,441 MB into the image. The <code>USER</code> instruction was the first instruction coming from our Dockerfile; the instructions before that (in the lines below the <code>USER</code> instruction) show the instructions when the base image was created:</p>
			<div><div><img src="img/B21217_05_03.jpg" alt="Figure 5.3 – Result of docker history command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Result of docker history command</p>
			<p>To see the exposed ports, environmental variables, the entry point, and more of an image, use the following command:</p>
			<pre class="console">
docker image inspect codebreaker/gamesapi:latest</pre>
			<p>The result is presented in JSON information and shows information such as exposed ports, environment variables, the entry point, the operating system, and the architecture this image is based on. When running the image, it helps to know what port number needs to be mapped and which environment variables could be useful to override.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Running the games API using Docker</h2>
			<p>You can <a id="_idIndexMarker296"/>start the Docker image of the games API service with the following command:</p>
			<pre class="console">
docker run -p 8080:8080 -d codebreaker/gamesapi:latest</pre>
			<p>Then, you can check the log output using <code>docker logs &lt;container-id&gt;</code> (get the  ID of the running container with <code>docker ps</code>). You can interact with the games service using any client using the following HTTP address: <code>http://localhost:8080</code>.</p>
			<p>With the default configuration of the data store, games are just stored in memory. To change this, we need to do the following:</p>
			<ol>
				<li>Configure a network to let multiple Docker containers directly communicate</li>
				<li>Start the Docker container for the SQL Server instance</li>
				<li>Pass configuration values to the Docker container for the games API to use the SQL Server instance</li>
			</ol>
			<h3>Configuring a network for Docker containers</h3>
			<p>To let <a id="_idIndexMarker297"/>containers communicate with each other, we create a network:</p>
			<pre class="console">
docker network create codebreakernet</pre>
			<p>Docker supports multiple network types, which can be set using the <code>--driver</code> option. The default is a <code>docker network ls</code> to show all networks.</p>
			<h3>Starting the Docker container with SQL Server</h3>
			<p>To start the<a id="_idIndexMarker298"/> Docker container for SQL Server where the database already exists, you can either use the Docker image we committed or access the state of the previous running container. Here, we do the latter, where we define the name <code>sql1</code> as the name of the container:</p>
			<pre class="console">
docker start sql1</pre>
			<p>Use <code>docker ps</code> to check for the running container and see the port mapping as it was defined earlier.</p>
			<p>Using the command<a id="_idIndexMarker299"/> adds the running container to the <code>codebreakernet</code> network:</p>
			<pre class="console">
docker network connect codebreakernet sql1</pre>
			<h3>Starting the Docker container with the games API</h3>
			<p>Now, we<a id="_idIndexMarker300"/> need to start the games API but override the configuration values. This can be done by setting environmental variables. Passing environmental variables at the start of a Docker container can not only be done by setting the <code>-e</code> option but also by using <code>--env-file</code> and passing a file with environmental variables. This is the content of the <code>gameapis.env</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">gameapis.env</p>
			<pre class="source-code">
DataStore=SqlServer
ConnectionStrings__GamesSqlServerConnection=sql1,1433;database=CodebreakerGames;user id=sa;password=&lt;enter your password&gt;;TrustServerCertificate=true</pre>
			<p>Creating the DI container of the application with the default container registers multiple configuration providers. A provider that uses environmental variables wins against the JSON file providers because of the order the providers are configured with the <code>WebApplicationBuilder</code> class (or the <code>Host</code> class). The <code>DataStore</code> key is used to select the storage provider. <code>GamesSqlServerConnection</code> is a key within the hierarchy of <code>ConnectionStrings</code>. Using command-line arguments to pass configuration values, you can specify a hierarchy of configuration values using <code>:</code> as a separator; for example, pass <code>ConnectionStrings:GamesSqlServerConnection</code>. Using <code>:</code> does not work everywhere; for example, with environmental variables on Linux. Using <code>__</code> translates to this hierarchy.</p>
			<p>With the environment variables file, the connection to the SQL Server Docker container is using the hostname of the Docker container and the port that is used by SQL Server. Being in the same network, the containers can communicate directly.</p>
			<p>Starting the container, the environmental variables file is passed using <code>--env-file</code>:</p>
			<pre class="console">
docker run -p 8080:8080 -d --env-file gameapis.env -d --name gamesapi codebreaker/gamesapi:latest
docker network connect codebreakernet gamesapi</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">In case you get an error that the container name is already in use, you can stop running containers with <code>docker container stop &lt;containername&gt;</code>. To remove the state of the container, you can use <code>docker container rm &lt;containername&gt;</code> or the <code>docker rm &lt;containername&gt;</code> shorthand notation. To delete the state of all stopped containers, use <code>docker container prune</code>. When starting a new container with <code>dotnet run</code>, you can also add the <code>--rm</code> option to remove a container after exit.</p>
			<p>Specifying<a id="_idIndexMarker301"/> the name of the <code>gamesapi</code> container, the container is added to the <code>codebreakernet</code> network. Now, we have two containers running communicating with each other, and can play games using the games service.</p>
			<p>Let’s create another Docker image, but this time without using a Dockerfile.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Building a Docker image using dotnet publish</h2>
			<p>In this chapter, we<a id="_idIndexMarker302"/> use multiple containers running at the same time. A project we didn’t use in previous chapters is <code>Codebreaker.Bot</code>. This project offers an API and is also a client to the games service – to automatically play games in the background after requested by some API calls. In this section, we’ll build a Docker image for this project – but without creating a Dockerfile first.</p>
			<p>Since .NET 7, the <code>dotnet publish</code> command <a id="_idIndexMarker303"/>directly supports creating Docker images without a Dockerfile. Using the <code>docker build</code> command, we had to pay attention to some specific .NET behaviors, such as the need to compile multiple projects. With this, it was necessary to specify the context when building the image. The .NET CLI knows about the solutions and project structure. The .NET CLI also knows about the default Docker base images that are used to build an application with ASP.NET Core.</p>
			<p>Options to configure the generation can be specified in the project file and using the parameters<a id="_idIndexMarker304"/> of <code>dotnet publish</code>. Here are some of the configurations specified in the project file:</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
<strong class="bold">  &lt;ContainerRegistry&gt;codebreaker/bot&lt;/ContainerRegistry&gt;</strong>
<strong class="bold">  </strong><strong class="bold">&lt;ContainerImageTags&gt;3.5.3;latest&lt;/ContainerImageTags&gt;</strong>
&lt;/PropertyGroup&gt;
&lt;ItemGroup&gt;
<strong class="bold">  &lt;ContainerPort Include="8080" Type="tcp" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
			<p><code>ContainerImageTags</code> and <code>ContainerPort</code> are just two of the elements that are used by <code>dotnet publish</code>. You can change the base image with <code>ContainerBaseImage</code>, specify container runtime identifiers (<code>ContainerRuntimeIdentifier</code>), name the registry (<code>ContainerRegistry</code>), define<a id="_idIndexMarker305"/> environmental variables, and more. See <a href="https://learn.microsoft.com//dotnet/core/docker/publish-as-container">https://learn.microsoft.com//dotnet/core/docker/publish-as-container</a> for details.</p>
			<p>With <code>dotnet publish</code>, the name of the repository is specified:</p>
			<pre class="console">
cd Codebreaker.Bot
dotnet publish Codebreaker.Bot.csproj --os linux --arch x64 /t:PublishContainer -c Release</pre>
			<p>The bot API service communicates with the games service, and the games service uses a container running SQL Server. Now, we already have three Docker containers collaborating. The games API needs a connection to the database, and the bot needs a link to the games API.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Running the solution with .NET Aspire</h1>
			<p>In <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, we added .NET Aspire <a id="_idIndexMarker306"/>to the solution, which contained only the games API service. In <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we added a SQL Server database running in a Docker container without keeping state. Here, we’ll extend the .NET Aspire configuration by using SQL Server running in a Docker container using a volume and configure the bot service to access the games API.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Configuring a Docker container for SQL Server</h2>
			<p>Using a <a id="_idIndexMarker307"/>Docker container with .NET Aspire can be orchestrated using .NET code – with extension methods of the <code>IDistributedApplication</code> interface:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
var sqlPassword = builder.AddParameter("SqlPassword", secret: true);
var sqlServer = builder.<strong class="bold">AddSqlServer</strong>("sql", sqlPassword)
  WithDataVolume("codebreaker-sql-data", isReadOnly: false)
 .<strong class="bold">AddDatabase</strong>("CodebreakerSql");
  var gameAPIs = builder.AddProject&lt;Projects.
<strong class="bold">    </strong>Codebreaker_GameAPIs&gt;("gameapis")
<strong class="bold">    .WithReference(sqlServer);</strong>
  // code removed for brevity</pre>
			<p>The <code>AddSqlServer</code> method adds SQL Server as a .NET Aspire resource to the app model. On the developer system, a Docker container is used to run SQL Server. When we created the container before in <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we assigned a password using the default password configuration. Here we explicitly create an app model parameter using the <code>AddParameter</code> method. With this, parameters are retrieved from the Parameters configuration section. Thus, the parameter named <code>SqlConfiguration</code> is retrieved from <code>Paramters:SqlConfiguration</code>. This parameter resource is passed with the second parameter of <code>AddSqlServer</code>. If the password is not assigned, and a parameter named with the resource (sql) postfixed with -password does not exist, a random password is created. This is great if no volume mounts are used, and the database is created newly every time the container starts up. Using a persistent volume, the<a id="_idIndexMarker308"/> same password needs to be used with every run of the container. This is done by supplying the password configuration. The password is needed with the database connection string to access the database. </p>
			<p>The <code>WithDataVolume</code> method <a id="_idIndexMarker309"/>defines the use of a Docker volume for the SQL Server container. Within the container, the database is stored within the <code>/var/opt/mssql</code> folder. Remember – without using a volume, the database is stored within the container itself, and the state is not kept when running a new container instance. While invoking <code>WithDataVolume</code>, there's no need to know what directories of the container need to mapped. This is known by the WithDataVolume method. We just pass the optional name of the volume, and if the volume should be read-only. With this volume, the database files are written to, thus it’s not read-only. In <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, when adding Grafana and Prometheus Docker containers, we’ll use read-only mounts.</p>
			<p>The <code>AddDatabase</code> method <a id="_idIndexMarker310"/>adds the SQL Server database as a child resource to SQL Server. The name passed here defines the name of the resource and the name of the database.</p>
			<p>So that .NET Aspire adds implicit service discovery, the database is referenced from the game APIs project using the <code>WithReference</code> method. With this, the <code>CodebreakerSql</code> database name can be used to reference the connection string.</p>
			<p>Using the <code>AddSqlServer</code> method, there’s no need to know the Docker image name for SQL Server or the environment variables that need to be specified, as we’ve done this earlier using the SQL Server Docker image. All this is done within the implementation of this method. To see how any Docker image can be added to the .NET Aspire app model, let’s look at the implementation of this method:</p>
			<pre class="source-code">
public static IResourceBuilder&lt;SqlServerServerResource&gt; 
  AddSqlServer(this IDistributedApplicationBuilder builder, string 
  name, string? password = null, int? port = null)
{
var passwordParameter = password?.Resource 
  ??  ParameterResourceBuilderExtensions.
  CreateDefaultPasswordPArameter(builder, $"{name}-password", 
  minLower: 1, minUpper: 1, minNumeric: 1);
  <strong class="bold">var sqlServer = new SqlServerServerResource(name, </strong>
    <strong class="bold">passwordParameter);</strong>
  return builder.<strong class="bold">AddResource</strong>(sqlServer)
    .<strong class="bold">WithEndpoint</strong>(<strong class="bold">1433, port, null</strong>, "tcp")
    .WithImage("mssql/server", "2022-latest")
    .WithImageRegistry("mcr.microsoft.com")
    .<strong class="bold">WithEnvironment</strong>("ACCEPT_EULA", "Y")
    .<strong class="bold">WithEnvironment</strong>(context =&gt;)
    {
      context.EnvironmentVariables["MSSQL_SA_PASSWORD"] =
        sqlServer.PasswordParameter;
    });
  }</pre>
			<p>With this code, an <a id="_idIndexMarker311"/>endpoint is defined to map a passed port number to the port number <code>1433</code> that is used by SQL Server running in the container; the container registry, image name, and tag values are specified, and environment variables are created to accept the <code>AddSqlServer</code> method. Using .NET Aspire, we don’t need to know this with available components.</p>
			<p>Before starting the application, make sure to set configuration via a user secret to store the password for SQL Server within the <code>Codebreaker.AppHost</code> project; for example, using the following command:</p>
			<pre class="console">
dotnet user-secrets set Parameters:SqlPassword "Password123!"</pre>
			<p>Now, we have to configure the .NET Aspire SQL Server component.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Configuring the .NET Aspire SQL Server component</h2>
			<p>With the<a id="_idIndexMarker313"/> games API, the EF Core context is configured with the DI container using the .NET Aspire SQL Server EF Core component:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
public static class ApplicationServices
{
  public static void AddApplicationServices(this 
    IHostApplicationBuilder builder)
  {
    static void ConfigureSqlServer(IHostApplicationBuilder builder)
    {
<strong class="bold">      builder.AddDbContextPool&lt;IGamesRepository, </strong>
        <strong class="bold">GamesSqlServerContext&gt;(options =&gt;</strong>
<strong class="bold">        {</strong>
<strong class="bold">          var connectionString = builder.Configuration.</strong>
            <strong class="bold">GetConnectionString("CodebreakerSql")</strong>
            <strong class="bold">?? throw new InvalidOperationException("Could not read SQL </strong>
            <strong class="bold">Server connection string");</strong>
<strong class="bold">          options.UseSqlServer(connectionString);</strong>
<strong class="bold">          options.UseQueryTrackingBehavior(</strong>
<strong class="bold">            QueryTrackingBehavior.NoTracking);</strong>
<strong class="bold">        });</strong>
         <strong class="bold">builder.EnrichSqlServerDbContext&lt;GamesSqlServerContext&gt;();</strong>
    }
    // code removed for brevity
    string? dataStore = builder.Configuration.
      GetValue&lt;string&gt;("DataStore");
    switch (dataStore)
    {
      case "SqlServer":
        ConfigureSqlServer(builder);
        break;
      default:
        ConfigureInMemory(builder);
      break;
    }
    builder.Services.AddScoped&lt;IGamesService, GamesService&gt;();
  }
}</pre>
			<p>The first <a id="_idIndexMarker314"/>part of the configuration is just the usual .NET EF Core configuration to specify the EF Core database provider and the connection string. Just make sure to use the connection string key that was used with the app model definition. The connection string is forwarded from the <code>AppHost</code> project to the games API service. The parameter with the value <code>CodebreakerSql</code> matches the name of the database that has been configured with the app model. Using .NET Aspire orchestration (which uses <code>Microsoft.Extensions.ServiceDiscovery</code>) gets the connection string with this name from the orchestrator configuration.</p>
			<p>The <code>EnrichSqlServerDbContext</code> method adds .NET Aspire configuration for retries, logging, and metrics.</p>
			<p>With this, the games API service with the database configuration is in place. Next, add interaction between the bot service and the games API service.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Configuring interaction with multiple services</h2>
			<p>Both the<a id="_idIndexMarker315"/> games API service and the bot service are configured by adding a project to the distributed application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var gameAPIs =</strong> builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithReference(sqlServer);
<strong class="bold">builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")</strong>
<strong class="bold">  .WithReference(gameAPIs);</strong></pre>
			<p>The SQL Server Docker container was added using the <code>AddSqlServer</code> method. All .NET projects that should be orchestrated with .NET Aspire need to be added using the <code>AddProject</code> method. The class definition for the project is created from a source generator when adding a project reference to the <code>AppHost</code> project. Adding a reference to the <code>Codebreaker.Bot</code> project created a class named <code>Codebreaker_Bot</code>. All project classes are defined within the <code>Projects</code> namespace.</p>
			<p>The bot service needs a reference to the games API, thus the <code>WithReference</code> method is used to generate implicit service discovery. The bot can use the name <code>http://gameapis</code> to reference the games API service.</p>
			<p>The configuration to retrieve the link to the games API is configured with the <code>HttpClient</code> configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder 
  builder)
{
<strong class="bold">  builder.Services.AddHttpClient&lt;GamesClient&gt;(client =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    client.BaseAddress = new Uri("http://gameapis");</strong>
<strong class="bold">  });</strong>
  builder.Services.AddScoped&lt;CodeBreakerTimer&gt;();
  builder.Services.AddScoped&lt;CodeBreakerGameRunner&gt;();
}</pre>
			<p>The <code>BaseAddress</code> of <code>HttpClient</code> is configured with the name of the games API, as defined <a id="_idIndexMarker316"/>with the <code>gameapis</code> orchestration configuration – prefixed with <code>http://</code>. There’s no need to specify .NET configuration to configure the link.</p>
			<p>With just these few updates in place, we can start the <code>Codebreaker.AppHost</code> project in the next step.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Running the solution with .NET Aspire</h2>
			<p>Using <code>dotnet run</code> to<a id="_idIndexMarker317"/> build and run the <code>Codebreaker.AppHost</code> project starts up the Docker container for SQL Server, the games API, the bot service, and the .NET Aspire dashboard. <em class="italic">Figure 5</em><em class="italic">.4</em> shows all started resources in the .NET Aspire dashboard. From here, you can see if services started successfully and access configured environment variables for services, logs, as well as accessible endpoints:</p>
			<div><div><img src="img/B21217_05_04.jpg" alt="Figure 5.4 – .NET Aspire resources in the dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – .NET Aspire resources in the dashboard</p>
			<p>With resources, make <a id="_idIndexMarker318"/>sure to open the <strong class="bold">Details</strong> column to see the environment variables configured. When checking logs with the SQL Server Docker container, you can see issues when using an invalid password – for example, a password that doesn’t fulfill the requirements or a password that doesn’t match the volume that was initially set.</p>
			<p>Clicking on the endpoint of the bot to show the OpenAPI test page, you can start multiple game runs, as shown in <em class="italic">Figure 5</em><em class="italic">.5</em>. Specify the number of games the bot should play in a sequence, the delay time between the games, and the delay time with every move, and click the <strong class="bold">Execute</strong> button:</p>
			<div><div><img src="img/B21217_05_05.jpg" alt="Figure 5.5 – OpenAPI test page for the bot service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – OpenAPI test page for the bot service</p>
			<p>With the<a id="_idIndexMarker319"/> logs of the bot service, you can monitor live information about games played by the bot. With every move set, the bot logs information about how good the result from the move was and how many possible options are remaining to find the solution:</p>
			<div><div><img src="img/B21217_05_06.jpg" alt="Figure 5.6 – Structured logging of the bot service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Structured logging of the bot service</p>
			<p>After the<a id="_idIndexMarker320"/> services are running, you can also access the games API service, see the games played today, and use the client created in the previous chapter to play some games. Monitor the running Docker container using the Docker CLI, and also check the volume created.</p>
			<p>Let’s get into an exciting feature with .NET 8 – native AOT – next.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Using native AOT with ASP.NET Core</h1>
			<p>Comparing Docker images with VM images, Docker images are a lot smaller as they don’t need to <a id="_idIndexMarker321"/>contain the operating system. With ASP.NET Core applications, the Docker image contains the application – and the .NET runtime. Over the last years, images have become smaller because more and more optimization has been done. Having smaller images means faster startup of the application.</p>
			<p>Since .NET 7, it’s possible to create native applications with C# using <strong class="bold">native AOT</strong>. With this, many changes are required with .NET. With .NET 7, the native AOT functionality was very limited. With .NET 8, we can already create ASP.NET Core services, which results in faster startup and less memory footprint.</p>
			<p>Using native AOT, an AOT compiler is used to <a id="_idIndexMarker322"/>compile <code>dotnet publish</code>.</p>
			<p>Not all <a id="_idIndexMarker323"/>applications can be changed to use native AOT: libraries cannot be dynamically loaded, runtime code generation is not possible… With native AOT, the code is trimmed, and all libraries need to be native AOT compatible. With .NET 8, EF Core is not part of the libraries supporting native AOT. It’s on the roadmap, and partial support is planned with EF Core 9.</p>
			<p>By creating a solution based on microservices, it’s possible to differentiate technologies with different services. What are the most used services where native AOT can give improvements?</p>
			<p>With the <code>codebreaker</code> solution, the games service can be enhanced with faster startup and less memory footprint. This is the most important service of the solution where the users should have a fast response at every point in time. However, with the lack of support in EF Core, using .NET 8, this is only possible with the in-memory games provider.</p>
			<p>To create an API project to support native AOT, a template is available:</p>
			<pre class="console">
dotnet new webapiaot -o Codebreaker.GameAPIs.NativeAOT</pre>
			<p>The most important difference with this project generated is the     <code>&lt;PublishAot&gt;true&lt;/PublishAot&gt;</code> setting in the project file. With this, using <code>dotnet publish</code> compiles the application to native platform-specific code. Because the compiler needs more time to compile native code, during development time, IL code is still generated, and the .NET runtime is used. As help during development to build native code, analyzers run and give compiler errors and warnings if code might not be compatible with native AOT.</p>
			<p>With the <code>Codebreaker.GameAPIs.NativeAOT</code> project, you can start copying the code from the <code>Codebreaker.GameAPIs</code> project, but some changes are required. We’ll focus on the changes needed for native AOT here.</p>
			<p>OpenAPI document generation is removed – including methods to enhance OpenAPI documentation. This feature makes use of reflection and dynamic code generation, which is not supported. The EF Core SQL Server and Cosmos providers are removed from this project as well. Instead, the project only uses the in-memory games repository.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">.NET 7 included an extremely limited functionality for native AOT. .NET 8 brings many more features, but many libraries are not supported yet. With .NET 8, you can’t use ASP.NET Core controllers, OpenAPI documentation is not available, the authentication library cannot be used, and most EF Core providers don’t support native AOT. Over time, more features will be added to support native AOT.</p>
			<p class="callout">Native AOT doesn’t allow the creation of code dynamically at runtime. Here, source generators are of big use. Instead of using reflection emit to create code at runtime, with source generators, code is created at compile time. This is not only an advantage with native AOT; even without using native AOT, source generators can improve the runtime performance.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Using the slim builder</h2>
			<p>Native AOT services make<a id="_idIndexMarker324"/> use of a slim application builder, as shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.NativeAOT/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateSlimBuilder(args);</pre>
			<p>Contrary to the default builder, the number of services registered with the DI container is reduced. Logging is reduced as well. The only logging provider that is configured with the slim builder is the simple console logging provider. In case more functionality is needed, additional services can be added. To reduce the number of registered services even further, the <code>CreateEmptyBuilder</code> method can be used.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Using the JSON serializer source generator</h2>
			<p>The use of<a id="_idIndexMarker325"/> the <code>System.Text.Json</code> serializer needs to be changed to use a source generator. Without a source generator, the serializer uses reflection and creates code at runtime. This is not supported with native AOT. To generate code at compile time, source generators are used. To use the <code>System.Text.Json</code> source generator, the <code>AppJsonSerializerContext</code> class is added:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.NativeAOT/Program.cs</p>
			<pre class="source-code">
[JsonSerializable(typeof(IEnumerable&lt;Game&gt;))]
[JsonSerializable(typeof(UpdateGameRequest))]
[JsonSerializable(typeof(UpdateGameResponse))]
[JsonSerializable(typeof(CreateGameResponse))]
[JsonSerializable(typeof(CreateGameRequest))]
[JsonSerializable(typeof(Game[]))]
internal partial class AppJsonSerializerContext : JsonSerializerContext
{
}</pre>
			<p>The class<a id="_idIndexMarker326"/> is declared partial to allow the source generator to create additional sources to extend the class with additional members. For every type that’s serialized with JSON, the <code>JsonSerializable</code> attribute is added.</p>
			<p>This class is used with the DI configuration of the JSON serialization:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.NativeAOT/Program.cs</p>
			<pre class="source-code">
builder.Services.ConfigureHttpJsonOptions(options =&gt;
{
    options.SerializerOptions.TypeInfoResolverChain.Insert(0,
       AppJsonSerializerContext.Default);
});</pre>
			<p>With this code, the default instance of the context class is added to the type resolvers of the <code>System.Text.Json</code> serializer.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Building for Windows</h2>
			<p>After <a id="_idIndexMarker327"/>removing the code for the OpenAPI, removing SQL Server and Cosmos library references, and adding the <code>PublishAot</code> element to the project file, after a successful build, <code>dotnet publish</code> can be used to create a native application. This is the command to create a native image for Windows:</p>
			<pre class="console">
cd Codebreaker.GameAPIs.NativeAOT
dotnet publish -r win-x64 -c Release -o pubwin</pre>
			<p>Using <code>dotnet publish</code> with the <code>win-x64</code> runtime identifier starts the native compiler and writes the binary to the <code>pubwin</code> directory. The code is trimmed to remove not-used types and members from the binary. As a result, you receive a trimmed native executable that doesn’t need to have the .NET runtime installed on the target system. Starting the application, you can use any client to play games with the in-memory provider.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Creating a Linux Docker image</h2>
			<p>This is<a id="_idIndexMarker328"/> the new Dockerfile we need for the native AOT games service:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.NativeAOT/Dockerfile</p>
			<pre class="source-code">
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
<strong class="bold">RUN apt-get update \</strong>
<strong class="bold">    &amp;&amp; apt-get install -y --no-install-recommends \</strong>
<strong class="bold">    clang zlib1g-dev</strong>
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Codebreaker.GameAPIs.NativeAOT.csproj", "."]
RUN dotnet restore "./Codebreaker.GameAPIs.NativeAOT.csproj"
COPY . .
WORKDIR "/src/."
RUN dotnet build "./Codebreaker.GameAPIs.NativeAOT.csproj" -c $BUILD_CONFIGURATION -o /app/build
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./Codebreaker.GameAPIs.NativeAOT.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=true
<strong class="bold">FROM mcr.microsoft.com/dotnet/runtime-deps:8.0 AS final</strong>
WORKDIR /app
EXPOSE 8080
COPY --from=publish /app/publish .
ENTRYPOINT ["./Codebreaker.GameAPIs.NativeAOT"]</pre>
			<p>To compile the<a id="_idIndexMarker329"/> application to native code, using the same SDK-included base image, the <code>clang</code> and <code>zlib1g-dev</code> dependencies need to be installed with the Linux environment. This is done as the first step before copying the project files. For production, a different base image is used: <code>dotnet/runtime-deps</code>. This is the new base image containing native dependencies needed by .NET. This image does not include the .NET runtime; instead, it can be used for self-contained applications.</p>
			<p>Building the Docker image can be done using the following command:</p>
			<pre class="console">
docker build . -f Codebreaker.GameAPIs.NativeAOT\Dockerfile -t codebreaker/gamesapi-aot:latest -t codebreaker/gamesapi-aot:3.5.6</pre>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Running the solution with the native AOT container</h2>
			<p>After <a id="_idIndexMarker330"/>building the image, you can start the Docker container and use different clients (for example, the bot service, the HTTP files, and the client from the previous chapter) to test the service. With this, you can also do some performance comparisons – but remember that some features have been removed to be native AOT compatible.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With .NET 8, native AOT is in its early stages. I expect many libraries to be updated to support native AOT in time. With a microservices architecture, for services that can improve from fast startup times, it can be useful to already use native AOT. A native AOT service can make use of gRPC (covered in <a href="B21217_14.xhtml#_idTextAnchor330"><em class="italic">Chapter 14</em></a>, <em class="italic">gRPC for Binary Communication</em>), and the service accessible via gRPC can access the database. In any case, non-AOT services can also get improvements from features you’ve seen here, such as the slim builder or the JSON serializer source generator.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Summary</h1>
			<p>In this chapter, you learned the foundation of Docker, pulling, creating, and running Docker images. You used containers that store state with volumes running databases in Docker containers, passed environmental variables and secrets to running Docker containers, and used .NET Aspire to run multiple containers at once.</p>
			<p>Using .NET Aspire, you configured orchestration for multiple services – including the configuration of a SQL Server Docker container. Comparing this to the work needed with Docker, this was an easy task – but it’s still useful to understand the foundations.</p>
			<p>With native AOT, you reduced startup times and the memory footprint, which you might be able to use with some of your services.</p>
			<p>Before moving on to the next chapter, using the bot, you can now easily play thousands of games. The bot uses a simple algorithm to set random moves from a list of possible moves. Using the games query, check the number of moves the bot needs to find the result. Try to play a game using the client you created in the previous chapter to access the Docker container from this chapter. Can you solve games in fewer moves?</p>
			<p>As you’ve seen in this chapter, you can run databases in Docker containers. With this, you still need to manage your database in the same way as you manage your natively installed on-premises database. Another option you’ll see in the next chapter is to use <strong class="bold">platform-as-a-service</strong> (<strong class="bold">PaaS</strong>) cloud services such as Azure Cosmos DB. In the next chapter, we’ll create Azure resources and publish Docker images we created in this chapter to <strong class="bold">Azure Container Registry</strong> (<strong class="bold">ACR</strong>) and Azure Container Apps.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li><em class="italic">Get started with Docker remote containers on WSL </em><em class="italic">2</em>: <a href="https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers">https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers</a></li>
				<li><em class="italic">How does Docker generate container names?</em>:  <a href="https://frightanic.com/computers/docker-default-container-names/">https://frightanic.com/computers/docker-default-container-names/</a></li>
				<li><em class="italic">Configure and customize SQL Server Docker </em><em class="italic">containers</em>: <a href="https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure">https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure</a></li>
				<li>Azure SQL Edge Docker image: <a href="https://hub.docker.com/_/microsoft-azure-sql-edge">https://hub.docker.com/_/microsoft-azure-sql-edge</a></li>
				<li>Run the Azure Cosmos DB emulator on Docker for Linux: <a href="https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux">https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux</a></li>
				<li>Dockerfile instructions: <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
				<li><em class="italic">Containerize a .NET app with dotnet </em><em class="italic">publish</em>: <a href="https://learn.microsoft.com/dotnet/core/docker/publish-as-container">https://learn.microsoft.com/dotnet/core/docker/publish-as-container</a></li>
				<li>.NET service discovery: <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery">https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery</a></li>
				<li><em class="italic">.NET Aspire </em><em class="italic">documentation</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire">https://learn.microsoft.com/en-us/dotnet/aspire</a></li>
				<li><em class="italic">Native AOT </em><em class="italic">deployment</em>: <a href="https://learn.microsoft.com/dotnet/core/deploying/native-aot/">https://learn.microsoft.com/dotnet/core/deploying/native-aot/</a></li>
			</ul>
		</div>
	</body></html>