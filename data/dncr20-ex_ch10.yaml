- en: Functional Programming with F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 F# 进行函数式编程
- en: In this chapter, we will learn how to build functional programs with F# that
    leverage .NET Core. We will also master data access layer implementation for microservices
    that use a SQL Server vNext database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 F# 构建函数式程序，并利用 .NET Core。我们还将掌握为使用 SQL Server vNext 数据库的微服务实现数据访问层。
- en: 'The topics to be covered in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to functional programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程简介
- en: Introduction to F#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 简介
- en: Data access layer with F#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 F# 的数据访问层
- en: Querying SQL vNext with F#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 F# 查询 SQL vNext
- en: Introduction to functional programming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程简介
- en: We briefly discussed functional programming and F# in [Chapter 1](ch01.html),
    *Getting Started*. In the F# primer section, we said that functional programming
    treats programs as mathematical expressions and evaluates expressions. It focuses
    on functions and constants, which don't change like variables and states. Functional
    programming solves complex problems with simple code; it is a very efficient programming
    technique for writing bug-free applications; for example, the null exception can
    be avoided using this technique.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 1 章](ch01.html)“入门”中简要介绍了函数式编程和 F#。在 F# 入门部分，我们说函数式编程将程序视为数学表达式并评估表达式。它侧重于函数和常量，它们不会像变量和状态那样改变。函数式编程用简单的代码解决复杂问题；它是编写无错误应用程序的非常高效的编程技术；例如，可以使用这种技术避免空指针异常。
- en: Functional programming is language-agnostic, which means it is not language-specific.
    Functional programming focuses on a structured approach; it doesn't have multiple
    entry and exit points. It doesn't have goto statements, so it is easy to create
    small modules and create large modules using small blocks of structured code (or
    in other words sub-modules), which increases the re-usability of code. One function
    can be used as the input of another function and that function can output a new
    function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是语言无关的，这意味着它与语言无关。函数式编程侧重于结构化方法；它没有多个入口和出口点。它没有 goto 语句，因此很容易创建小模块，并使用小块结构化代码（或者说子模块）创建大模块，这增加了代码的可重用性。一个函数可以作为另一个函数的输入，而那个函数可以输出一个新的函数。
- en: 'Here are some rules which make it easy for us to understand functional programming:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则，使我们更容易理解函数式编程：
- en: In functional programming, a function's output never gets affected by outside
    code changes and the function always gives the same result for the same parameters.
    This gives us confidence in the function's behavior that it will give the expected
    result in all the scenarios, and this is helpful for multithread or parallel programming.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式编程中，一个函数的输出永远不会受到外部代码更改的影响，并且对于相同的参数，函数总是给出相同的结果。这让我们对函数的行为有信心，即它在所有场景中都会给出预期的结果，这对多线程或并行编程很有帮助。
- en: In functional programming, variables are immutable, which means we cannot modify
    a variable once it is initialized, so it is easy to determine the value of a variable
    at any given point at program runtime.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式编程中，变量是不可变的，这意味着一旦初始化了变量，我们就不能修改它，因此在程序运行时可以很容易地确定变量在任何给定点的值。
- en: 'Functional programming works on referential transparency, which means it doesn''t
    use assignment statements in a function. For example, if a function is assigning
    a new value to a variable such as shown here:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程基于引用透明性，这意味着它不会在函数中使用赋值语句。例如，如果一个函数正在将新值赋给一个变量，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is changing the value of `x,` but if we write it as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在改变 `x` 的值，但如果我们像这样写：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is not changing the variable value and the function returns the same result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是改变变量值，函数返回相同的结果。
- en: Functional programming uses recursion for looping. A recursive function calls
    itself and runs till the condition is satisfied.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程使用递归进行循环。递归函数调用自身，直到满足条件。
- en: Functional programming features
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程特性
- en: 'Let''s discuss some functional programming features:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些函数式编程特性：
- en: Higher-order functions
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Purity
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯度
- en: Recursion
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Currying
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化
- en: Closure
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Function composition
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Higher-order functions (HOF)
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数 (HOF)
- en: 'One function can take an input argument as another function and it can return
    a function. This originated from calculus and is widely used in functional programming.
    Order can be determined by domain and range of order such as order `0` has no
    function data and order `1` has a domain and range of order `0`, if order is higher
    than `1`, it is called a higher-order function. For example, the `ComplexCalc`
    function takes another function as input and returns a different function as output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以将另一个函数作为输入参数，并且它可以返回一个函数。这起源于微积分，并且在函数式编程中被广泛使用。顺序可以通过域和范围来确定，例如，顺序 `0`
    没有函数数据，顺序 `1` 有顺序 `0` 的域和范围，如果顺序高于 `1`，则称为高阶函数。例如，`ComplexCalc` 函数接受另一个函数作为输入，并返回一个不同的函数作为输出：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous example, we created two functions, `sum` and `divide`. We pass
    these two functions as parameters to the `ComplexCalc` function, and it returns
    a value of `4` and `1`, respectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了两个函数，`sum` 和 `divide`。我们将这两个函数作为参数传递给 `ComplexCalc` 函数，它分别返回 `4`
    和 `1`。
- en: Purity
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯度
- en: In functional programming, a function is referred to as a pure function if all
    its input arguments are known and all its output results are also well known and
    declared; or we can say the input and output result has no side-effects. Now,
    you must be curious to know what the side-effect could be, let's discuss it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，如果一个函数的所有输入参数都是已知的，并且所有输出结果也是明确声明和已知的；或者我们可以这样说，输入和输出结果没有副作用，那么这个函数被称为纯函数。现在，你可能很好奇副作用可能是什么，让我们来讨论一下。
- en: 'Let''s look at the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous example, the function `sum` takes an integer input and returns
    an integer value and predefined result. This kind of function is referred to as
    a pure function. Let''s investigate the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，函数 `sum` 接受一个整数输入并返回一个整数值和预定义的结果。这类函数被称为纯函数。让我们调查以下示例：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the `verifyData()` function does not take any input
    parameter and does not return anything, but this function is internally calling
    the `getEmp()` function so `verifyData()` depends on the `getEmp()` function.
    If the output of `getEmp()` is not null, it calls another function, called `ProcessForm()` and
    we pass the `getEmp()` function output as input for `ProcessForm(emp)`. In this
    example, both the functions, `getEmp()` and `ProcessForm(),` are unknown at the `verifyData()`
    function level call, also `emp` is a hidden value. This kind of program, which
    has hidden input and output, is treated as a side-effect of the program. We cannot
    understand what it does in such functions. This is different from encapsulation;
    encapsulation hides the complexity but in such function, the functionality is
    not clear and input and output are unreliable. These kinds of function are referred
    to as impure functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`verifyData()` 函数不接受任何输入参数，也不返回任何内容，但这个函数在内部调用 `getEmp()` 函数，所以 `verifyData()`
    依赖于 `getEmp()` 函数。如果 `getEmp()` 的输出不为空，它将调用另一个函数，称为 `ProcessForm()`，我们将 `getEmp()`
    函数的输出作为 `ProcessForm(emp)` 的输入。在这个例子中，这两个函数，`getEmp()` 和 `ProcessForm()`，在 `verifyData()`
    函数的调用级别是未知的，而且 `emp` 是一个隐藏值。这种具有隐藏输入和输出的程序被视为程序的副作用。我们无法理解这些函数在做什么。这与封装不同；封装隐藏了复杂性，但在这样的函数中，功能不明确，输入和输出不可靠。这类函数被称为不纯函数。
- en: 'Let''s look at the main concepts of pure functions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看纯函数的主要概念：
- en: '**Immutable data**: Functional programming works on immutable data, it removes
    the side-effect of variable state change and gives guarantee of an expected result.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变数据**：函数式编程在不可变数据上工作，它消除了变量状态变化的副作用，并保证了预期的结果。'
- en: '**Referential transparency**: Large modules can be replaced by small code blocks
    and reuse any existing modules. For example, if `a = b*c` and `d = b*c*e` then
    the value of `d` can be written as `d = a*e`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用透明性**：大型模块可以被小的代码块替换，并可以重用任何现有的模块。例如，如果 `a = b*c` 和 `d = b*c*e`，那么 `d`
    的值可以写成 `d = a*e`。'
- en: '**Lazy evaluation**: Referential transparency and immutable data give us the
    flexibility to calculate the function at any given point of time and we will get
    the same result, because a variable will not change its state at any time.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惰性评估**：引用透明性和不可变数据给了我们灵活性，可以在任何给定的时间点计算函数，并且我们会得到相同的结果，因为变量在任何时候都不会改变其状态。'
- en: Recursion
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'In functional programming, looping is performed by recursive functions. In
    F#, to make a function recursive, we need to use the `rec` keyword. By default,
    functions are not recursive in F#, we have to rectify this explicitly using the `rec`
    keyword. Let''s take an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，循环是通过递归函数来执行的。在F#中，要使函数递归，我们需要使用`rec`关键字。默认情况下，F#中的函数不是递归的，我们必须显式地使用`rec`关键字来纠正这一点。让我们举一个例子：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, we used the keyword `rec` for the recursion function and if the
    value passed is `0` , the sum would be `0`; otherewise it will add `x + summation(x-1)`,
    like `1+0` then `2+1` and so on. We should take care with recursion because it
    can consume memory heavily.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用关键字`rec`表示递归函数，如果传入的值是`0`，则总和将是`0`；否则，它将添加`x + summation(x-1)`，例如`1+0`然后`2+1`等等。我们应该小心使用递归，因为它可能会大量消耗内存。
- en: Currying
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'This converts a function with multiple input parameter to a function which
    takes one parameter at a time, or we can say it breaks the function into multiple
    functions, each taking one parameter at a time. Here is an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个具有多个输入参数的函数转换为一次只接受一个参数的函数，或者说，它将函数分解成多个函数，每个函数一次只接受一个参数。以下是一个例子：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Closure
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closure is a feature which allows us to access a variable which is not in the
    scope of the current module. It is a way of implementing lexically scoped named
    binding, for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一种特性，它允许我们访问不在当前模块作用域内的变量。这是一种实现词法作用域命名绑定的方法，例如：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `add()` function is internally called by the `addTen()`
    function. In an ideal world, the variables `x` and `y` should not be accessible
    when the `add()` function finishes its execution, but when we are calling the
    function `addTen()`, it returns `15`. So, the state of the function `add()` is
    saved though code execution is finished, otherwise there is no way of knowing
    the `add(10)` value, where `x = 10`. We are able to find the value of `x` because
    of lexical scoping and this is called closure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`add()`函数是由`addTen()`函数内部调用的。在一个理想的世界里，当`add()`函数执行完毕时，变量`x`和`y`不应该被访问，但当我们调用函数`addTen()`时，它返回`15`。所以，尽管代码执行已经完成，函数`add()`的状态仍然被保存，否则就没有办法知道`add(10)`的值，其中`x
    = 10`。我们能够找到`x`的值是因为词法作用域，这被称为闭包。
- en: Function composition
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: As we discussed earlier about HOF, function composition means getting two functions
    together to create a third new function where the output of a function is the
    input of another function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的HOF（高阶函数），函数组合意味着将两个函数组合在一起创建一个新的第三个函数，其中一个函数的输出是另一个函数的输入。
- en: There are *n* number of functional programming features. Functional programming
    is a technique to solve problems and write code in an efficient way. It is not
    language-specific, but many languages support functional programming. We can also
    use non-functional languages (such as C#) to write programs in a functional way.
    F# is a Microsoft programming language for concise and declarative syntax. We
    will learn more about F# in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有*n*个函数式编程特性。函数式编程是一种以高效方式解决问题和编写代码的技术。它不是特定于语言的，但许多语言支持函数式编程。我们也可以使用非函数式语言（如C#）以函数式方式编写程序。F#是微软的一种编程语言，用于简洁和声明性语法。我们将在下一节中了解更多关于F#的内容。
- en: Introduction to F#
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#简介
- en: In [Chapter 1](ch01.html), *Getting Started*, we discussed the F# language and
    its functional programming features, basic keywords, operators, and variable declarations.
    We also looked at the difference between F# and C#, functions, and the basic input-output
    syntax. In this section, we will discuss F# in more detail.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html)“入门”中，我们讨论了F#语言及其函数式编程特性、基本关键字、运算符和变量声明。我们还探讨了F#与C#、函数以及基本输入输出语法的区别。在本节中，我们将更详细地讨论F#。
- en: Basics of classes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的基本概念
- en: 'Classes are types of object which can contain functions, properties, and events.
    An F# class must have a parameter and a function attached like a member. Both
    properties and functions can use the `member` keyword. The following is the class
    definition syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类是包含函数、属性和事件的类型。F#类必须有一个参数和一个附加的函数，就像一个成员。属性和函数都可以使用`member`关键字。以下是类定义的语法：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s discuss the preceding syntax for class declaration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下类声明的先前语法：
- en: '`type`: In the F# language, class definition starts with a `type` keyword.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：在F#语言中，类定义以`type`关键字开始。'
- en: '`access-modifier`: The F# language supports three access modifiers—`public`,
    `private`, and `internal`. By default, it considers the `public` modifier if no
    other access modifier is provided. The `Protected` keyword is not used in the
    F# language, and the reason is that it will become object oriented rather than
    functional programming. For example, F# usually calls a member using a lambda
    expression and if we make a member type protected and call an object of a different
    instance, it will not work.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access-modifier`: F#语言支持三种访问修饰符—`public`、`private`和`internal`。默认情况下，如果没有提供其他访问修饰符，它将考虑`public`修饰符。在F#语言中不使用`Protected`关键字，原因是它将变成面向对象而不是函数式编程。例如，F#通常使用lambda表达式调用成员，如果我们使成员类型为受保护的，并调用不同实例的对象，它将不起作用。'
- en: '`type-name`: It is any of the previously mentioned valid identifiers; the default
    access modifier is `public`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type-name`: 它是之前提到的任何有效标识符；默认访问修饰符是`public`。'
- en: '`type-params`: It defines optional generic type parameters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type-params`: 它定义了可选的泛型类型参数。'
- en: '`parameter-list`: It defines constructor parameters; the default access modifier
    for the primary constructor is `public`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameter-list`: 它定义了构造函数参数；主构造函数的默认访问修饰符是`public`。'
- en: '`identifier`: It is used with the optional `as` keyword, the `as` keyword gives
    a name to an instance variable which can be used in the type definition to refer
    to the instance of the type.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identifier`: 它与可选的`as`关键字一起使用，`as`关键字给一个实例变量命名，可以在类型定义中使用该名称来引用类型的实例。'
- en: '`Inherit`: This keyword allows us to specify the base class for a class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inherit`: 这个关键字允许我们指定类的基类。'
- en: '`let-bindings`: This is used to declare fields or function values in the context
    of a class.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let-bindings`: 这用于在类的上下文中声明字段或函数值。'
- en: '`do-bindings`: This is useful for the execution of code to create an object'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-bindings`: 这对于执行代码以创建对象很有用。'
- en: '`member-list`: The `member-list` comprises extra constructors, instance and
    static method declarations, abstract bindings, interface declarations, and event and
    property declarations.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`member-list`: `member-list`包括额外的构造函数、实例和静态方法声明、抽象绑定、接口声明以及事件和属性声明。'
- en: 'Here is an example of a class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个类的例子：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, we have not defined the parameter type. By default,
    the program considers it as a string value but we can explicitly define a data
    type, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们没有定义参数类型。默认情况下，程序将其视为字符串值，但我们可以显式地定义数据类型，如下所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Constructor of a class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的构造函数
- en: 'In F#, the constructor works in a different way to any other .NET language.
    The constructor creates an instance of a class. A parameter list defines the arguments
    of the primary constructor and class. The constructor contains `let` and `do`
    bindings, which we will discuss next. We can add multiple constructors, apart
    from the primary constructor, using the `new` keyword and it must invoke the primary
    constructor, which is defined with the class declaration. The syntax of defining
    a new constructor is as shown:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，构造函数的工作方式与任何其他.NET语言都不同。构造函数创建类的实例。参数列表定义了主构造函数和类的参数。构造函数包含`let`和`do`绑定，我们将在下一节讨论。我们可以使用`new`关键字添加多个构造函数，除了主构造函数之外，并且它必须调用用类声明定义的主构造函数。定义新构造函数的语法如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is an example to explain the concept. In the following code, the `StudentDetail`
    class has two constructors: a primary constructor that takes two arguments and
    another constructor that takes no arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来解释这个概念。在下面的代码中，`StudentDetail`类有两个构造函数：一个接受两个参数的主构造函数，另一个不接受任何参数的构造函数：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A let and do binding
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`let`和`do`绑定'
- en: A `let` and `do` binding creates the primary constructor of a class and runs
    when an instance of a class is created.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`和`do`绑定创建类的构造函数，并在创建类的实例时运行。'
- en: A function is compiled into a member if it has a `let` binding. If the `let`
    binding is a value which is not used in any function or member, then it is compiled
    into a local variable of a constructor; otherwise, it is compiled into a field
    of the class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有一个`let`绑定，它就会被编译成一个成员。如果`let`绑定是一个在任何函数或成员中都没有使用的值，那么它会被编译成构造函数的局部变量；否则，它会被编译成类的字段。
- en: The `do` expression executes the initialized code. As any extra constructors
    always call the primary constructor, `let` and `do` bindings always execute, irrespective
    of which constructor is called.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`表达式执行初始化代码。由于任何额外的构造函数总是调用主构造函数，所以`let`和`do`绑定总是执行，无论调用哪个构造函数。'
- en: 'Fields that are created by `let` bindings can be accessed through the methods
    and properties of the class, though they cannot be accessed from static methods,
    even if the static methods take an instance variable as a parameter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`let`绑定创建的字段可以通过类的方法和属性访问，尽管它们不能从静态方法中访问，即使静态方法以实例变量作为参数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Generic type parameters
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型参数
- en: 'F# also supports a generic parameter type. We can specify multiple generic
    type parameters separated by a comma. The syntax of a generic parameter declaration
    is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: F# 也支持泛型参数类型。我们可以通过逗号分隔来指定多个泛型类型参数。泛型参数声明的语法如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The type of the parameter infers where it is used. In the following code, we
    call the `MyGenericClassExample` method and pass a sequence of tuples, so here
    the parameter type became a sequence of tuples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的类型决定了它的使用位置。在下面的代码中，我们调用了`MyGenericClassExample`方法并传递了一个元组的序列，因此这里的参数类型变成了元组的序列：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Properties
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Values related to an object are represented by properties. In object-oriented
    programming, properties represent data associated with an instance of an object.
    The following snippet shows two types of property syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象相关的值通过属性表示。在面向对象编程中，属性表示与对象实例相关联的数据。以下代码片段显示了两种属性语法：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are two kinds of property declaration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 属性声明有两种类型：
- en: '**Explicitly specify the value**: We should use the explicit way to implement
    the property if it has non-trivial implementation. We should use a member keyword
    for the explicit property declaration.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式指定值**：如果属性有非平凡的实现，我们应该使用显式方式来实现属性。我们应该为显式属性声明使用成员关键字。'
- en: '**Automatically generate the value**: We should use this when the property
    is just a simple wrapper for a value.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动生成值**：当属性只是一个简单的值包装器时，我们应该使用这种方法。'
- en: 'There are many ways of implementing an explicit property syntax based on need:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，有许多实现显式属性语法的途径：
- en: '**Read-only**: Only the `get()` method'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读**：只有`get()`方法'
- en: '**Write-only**: Only the `set()` method'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只写**：只有`set()`方法'
- en: '**Read/write**: Both `get()` and `set()` methods'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写**：`get()`和`set()`方法'
- en: 'An example is shown as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Backing stores are private values that contain data for properties. The keyword, `member
    val` instructs the compiler to create backing stores automatically and then gives
    an expression to initialize the property. The F# language supports immutable types,
    but if we want to make a property mutable, we should use `get` and `set`. As shown
    in the following example, the `MyClassExample` class has two properties: `propExample1`
    is read-only and is initialized to the argument provided to the primary constructor,
    and `propExample2` is a settable property initialized with a string value `".Net
    Core 2.0"`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 后备存储是包含属性数据的私有值。关键字`member val`指示编译器自动创建后备存储，并给出一个表达式来初始化属性。F# 语言支持不可变类型，但如果我们想使属性可变，我们应该使用`get`和`set`。以下示例中的`MyClassExample`类有两个属性：`propExample1`是只读的，并初始化为主构造函数提供的参数，而`propExample2`是一个可设置的属性，初始化为字符串值`".Net
    Core 2.0"`：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Automatically implemented properties don't work efficiently with some libraries,
    for example, Entity Framework. In these cases, we should use explicit properties.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 自动实现的属性与某些库（例如Entity Framework）不高效。在这些情况下，我们应该使用显式属性。
- en: Static and instance properties
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和实例属性
- en: 'There can be further categorization of properties as static or instance properties.
    Static, as the name suggests, can be invoked without any instance. The self-identifier
    is neglected by the `static` property while it is necessary for the instance property.
    The following is an example of the `static` property:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以进一步分类为静态或实例属性。正如其名所示，静态属性可以在没有任何实例的情况下调用。`static`属性忽略了自标识符，而对于实例属性来说这是必要的。以下是一个`static`属性的示例：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Abstract properties
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象属性
- en: 'Abstract properties have no implementation and are fully abstract. They can
    be virtual. It should not be `private` and if one accessor is `abstract` all others
    must be `abstract`. The following is an example of the `abstract` property and
    how to use it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象属性没有实现，是完全抽象的。它们可以是虚拟的。它们不应该声明为`private`，如果有一个访问器是`abstract`，则所有其他访问器也必须是`abstract`。以下是一个`abstract`属性的示例以及如何使用它：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inheritance and casts
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和类型转换
- en: 'In F#, the inherit keyword is used while declaring a class. The following is
    the syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，使用`inherit`关键字声明类。以下是其语法：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a derived class, we can access all methods and members of the base class,
    but it should not be a private member. To refer to base class instances in the
    F# language, the base keyword is used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类中，我们可以访问基类的所有方法和成员，但不应该是私有成员。要在F#语言中引用基类实例，使用`base`关键字。
- en: Virtual methods and overrides
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚方法和重写
- en: 'In F#, the `abstract` keyword is used to declare a virtual member. So, here
    we can write a complete definition of the `member` as we use `abstract` for virtual.
    F# is not similar to other .NET languages. Let''s have a look at the following
    example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，使用`abstract`关键字来声明虚拟成员。因此，在这里我们可以像使用`abstract`关键字声明虚拟成员一样，写出`member`的完整定义。F#与其他.NET语言不同。让我们看看以下例子：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous example, we declared a virtual method, `virtualMethodExample`,
    in a base class, `MyClassExampleBase`, and overrode it in a derived class, `MyClassExampleDerived`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在基类`MyClassExampleBase`中声明了一个虚方法`virtualMethodExample`，并在派生类`MyClassExampleDerived`中重写了它。
- en: Constructors and inheritance
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和继承
- en: 'An inherited class constructor must be called in a derived class. If a base
    class constructor contains some arguments, then it takes parameters of the derived
    class as input. In the following example, we will see how derived class arguments
    are passed in the base class constructor with inheritance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类中必须调用继承的类构造函数。如果基类构造函数包含一些参数，那么它将派生类的参数作为输入。在下面的例子中，我们将看到派生类参数是如何在继承的基类构造函数中传递的：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If a class has multiple constructors, such as `new(str)` or `new()`, and this
    class is inherited in a derived class, we can use a base class constructor to
    assign values. For example, `DerivedClass`, which inherits `BaseClass`, has `new(str1,str2)`,
    and in place of the first string, we pass `inherit BaseClass(str1)`. Similarly
    for blank, we wrote `inherit BaseClass()`. Let''s explore the following example
    for more detail:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类有多个构造函数，例如`new(str)`或`new()`，并且这个类在派生类中被继承，我们可以使用基类构造函数来赋值。例如，继承自`BaseClass`的`DerivedClass`有`new(str1,str2)`，在第一个字符串的位置，我们传递`inherit
    BaseClass(str1)`。同样，对于空值，我们写`inherit BaseClass()`。让我们通过以下例子来了解更多细节：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Functions and lambda expressions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和Lambda表达式
- en: 'A lambda expression is one kind of anonymous function, which means it doesn''t
    have a name attached to it. But if we want to create a function which can be called,
    we can use the `fun` keyword with a lambda expression. We can pass the input parameter
    in the lambda function, which is created using the `fun` keyword. This function
    is quite similar to a normal F# function. Let''s see a normal F# function and
    a lambda function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一种匿名函数，这意味着它没有与之关联的名称。但如果我们想创建一个可以被调用的函数，我们可以使用`fun`关键字与Lambda表达式一起使用。我们可以在使用`fun`关键字创建的Lambda函数中传递输入参数。这个函数与正常的F#函数非常相似。让我们看看一个正常的F#函数和一个Lambda函数：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Handling data – tuples, lists, record types, and data manipulation
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据 - 元组、列表、记录类型和数据操作
- en: 'F# supports many data types, for example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: F#支持许多数据类型，例如：
- en: '**Primitive types**: `bool`, `int`, `float`, `string` values.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始类型**：`bool`、`int`、`float`、`string`值。'
- en: '**Aggregate type**: `class`, `struct`, `union`, `record`, and `enum`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合类型**：`class`、`struct`、`union`、`record`和`enum`'
- en: '**Array**: `int[]`, `int[ , ]`, and `float[ , , ]`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：`int[]`、`int[ , ]`和`float[ , , ]`'
- en: '**Tuple**: `type1 * type2 *` like (`a,1,2,true`) type is—`char * int * int
    * bool`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：`type1 * type2 *` 类型的（如 `a,1,2,true`）类型是 `char * int * int * bool`'
- en: '**Generic**: `list<’x>`, dictionary `< ’key, ’value>`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泛型**：`list<’x>`、`dictionary <’key, ’value>`'
- en: 'In an F# function, we can pass one tuple instead of multiple parameters of
    different types. Declaration of a `tuple` is very simple and we can assign values
    of a `tuple` to different variables, for example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#函数中，我们可以传递一个元组而不是多个不同类型的参数。`tuple`的声明非常简单，我们可以将`tuple`的值分配给不同的变量，例如：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding examples, we saw that `tuple` supports pattern matching. These
    are option types and an option type in F# supports the idea that the value may
    or not be present at runtime.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到`tuple`支持模式匹配。这些是可选类型，F#中的可选类型支持在运行时值可能存在或不存在这一概念。
- en: List
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'List is a generic type implementation. An F# list is similar to a linked list
    implementation in any other functional language. It has a special opening and
    closing bracket construct, a short form of the standard empty list (`[ ]`) syntax:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一种泛型类型实现。F#列表类似于任何其他函数式语言中的链表实现。它有一个特殊的开闭括号结构，这是标准空列表（`[ ]`）语法的简写形式：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `cons` operator is used to prepend an item to a list using a double colon `cons(prepend,::)`.
    To append another list to one list, we use the append operator—`@`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`cons` 操作符用于使用双冒号 `cons(prepend,::)` 将项目添加到列表的开头。要将另一个列表追加到列表中，我们使用追加操作符—`@`：'
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lists are decomposable using pattern matching into a head and a tail part,
    where the head is the first item in the list and the tail part is the remaining
    list, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以通过模式匹配分解为一个头和一个尾部分，其中头是列表中的第一个项目，尾部分是剩余的列表，例如：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Record type
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录类型
- en: 'The `class`, `struct`, `union`, `record`, and `enum` types come under aggregate
    types. The record type is one of them, it can have *n* number of members of any
    individual type. Record type members are by default immutable but we can make
    them mutable. In general, a record type uses the members as an immutable data
    type. There is no way to execute logic during instantiation as a record type don''t
    have constructors. A record type also supports match expression, depending on
    the values inside those records, and they can also again decompose those values
    for individual handling, for example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`、`struct`、`union`、`record` 和 `enum` 类型属于聚合类型。记录类型是其中之一，它可以有任意数量的成员，这些成员可以是任何单个类型。记录类型的成员默认是不可变的，但我们可以使它们可变。通常，记录类型使用成员作为不可变的数据类型。在实例化过程中无法执行逻辑，因为记录类型没有构造函数。记录类型还支持匹配表达式，根据记录内部值的不同，它们还可以再次分解这些值以进行单独处理，例如：'
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous example, we declared a `Box` with `float` a value `width` and
    an integer `height`. When we declare `giftbox`, the compiler automatically detects
    its type as `Box` by matching the value types. We can also specify type like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了一个具有 `float` 值 `width` 和整数 `height` 的 `Box`。当我们声明 `giftbox` 时，编译器会自动通过匹配值类型将其类型检测为
    `Box`。我们也可以这样指定类型：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: or
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This kind of type declaration is used when we have the same type of fields or
    field type declared in more than one type. This declaration is called a record
    expression.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型声明用于当我们有多个类型中声明了相同类型的字段或字段类型时。这种声明被称为记录表达式。
- en: Object-oriented programming in F#
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 中的面向对象编程
- en: 'F# also supports implementation inheritance, the creation of object, and interface
    instances. In F#, constructed types are fully compatible .NET classes which support
    one or more constructors. We can implement a `do` block with code logic, which
    can run at the time of class instance creation. The constructed type supports
    inheritance for class hierarchy creation. We use the `inherit` keyword to inherit
    a class. If the member doesn''t have implementation, we can use the `abstract`
    keyword for declaration. We need to use the `abstractClass` attribute on the class
    to inform the compiler that it is abstract. If the `abstractClass` attribute is
    not used and `type` has all abstract members, the F# compiler automatically creates
    an `interface` type. Interface is automatically inferred by the compiler as shown
    in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: F# 还支持实现继承、对象的创建和接口实例的创建。在 F# 中，构造类型与 .NET 类完全兼容，这些类支持一个或多个构造函数。我们可以实现一个带有代码逻辑的
    `do` 块，该块可以在类实例创建时运行。构造类型支持继承以创建类层次结构。我们使用 `inherit` 关键字来继承一个类。如果成员没有实现，我们可以使用
    `abstract` 关键字进行声明。我们需要在类上使用 `abstractClass` 属性来通知编译器它是抽象的。如果没有使用 `abstractClass`
    属性，并且 `type` 具有所有抽象成员，F# 编译器会自动创建一个 `interface` 类型。接口会自动由编译器推断，如下面的截图所示：
- en: '![](img/0f70fe4c-bfb1-46c7-bc41-22531b0061d0.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f70fe4c-bfb1-46c7-bc41-22531b0061d0.png)'
- en: The `override` keyword is used to override the base class implementation; to
    use the base class implementation of the same member, we use the `base` keyword.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`override` 关键字用于覆盖基类的实现；要使用相同成员的基类实现，我们使用 `base` 关键字。'
- en: In F#, interfaces can be inherited from another interface. In a class, if we
    use the construct interface, we have to implement all the members in the interface
    in that class, as well. In general, it is not possible to use interface members
    from outside the class instance, unless we upcast the instance type to the required
    interface type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，接口可以继承自另一个接口。在一个类中，如果我们使用接口构造，我们必须在该类中实现接口的所有成员。通常，不可能在类实例外部使用接口成员，除非我们将实例类型向上转换为所需的接口类型。
- en: 'To create an instance of a class or interface, the object expression syntax
    is used. We need to override virtual members if we are creating a class instance
    and need member implementation for interface instantiation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类或接口的实例，使用对象表达式语法。如果我们创建类实例并需要接口实例化的成员实现，则需要重写虚拟成员：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Exception handling
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: The `exception` keyword is used to create a custom exception in F#; these exceptions
    adhere to Microsoft best practices, such as constructors supplied, serialization
    support, and so on. The keyword `raise` is used to throw an exception. Apart from
    this, F# has some helper functions, such as `failwith`, which throws a failure
    exception at F# runtime, and `invalidop`, `invalidarg`, which throw the .NET Framework
    standard type invalid operation and invalid argument exception, respectively.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，使用`exception`关键字创建自定义异常；这些异常遵循Microsoft最佳实践，例如提供的构造函数、序列化支持等。关键字`raise`用于抛出异常。除此之外，F#还有一些辅助函数，如`failwith`，它在F#运行时抛出失败异常，以及`invalidop`、`invalidarg`，分别抛出.NET
    Framework标准类型无效操作和无效参数异常。
- en: '`try`/`with` is used to catch an exception; if an exception occurred on an
    expression or while evaluating a value, then the `try`/`with` expression could
    be used on the right side of the value evaluation and to assign the value back
    to some other value. `try`/`with` also supports pattern matching to check an individual
    exception type and extract an item from it. `try`/`finally` expression handling
    depends on the actual code block. Let''s take an example of declaring and using
    a custom exception:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`with`用于捕获异常；如果表达式或评估值时发生异常，则可以在值评估的右侧使用`try`/`with`表达式，并将值赋回某个其他值。`try`/`with`还支持模式匹配以检查单个异常类型并从中提取项。`try`/`finally`表达式处理取决于实际的代码块。让我们用一个声明和使用自定义异常的例子来说明：'
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the previous example, we created a custom exception called `MyCustomExceptionExample,`
    using the `exception` keyword, passing value fields which we want to pass. Then
    we used the `raise` keyword to raise exception passing values, which we want to
    display while running the application or throwing the exception. However, as shown
    here, while running this code, we don''t get our custom message in the error value
    and the standard exception message is displayed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用`exception`关键字创建了一个名为`MyCustomExceptionExample`的自定义异常，传递了我们想要传递的值字段。然后我们使用`raise`关键字来引发异常，传递我们希望在应用程序运行或抛出异常时显示的值。然而，如图所示，在运行此代码时，我们没有在我们的自定义消息中看到错误值，而是显示了标准的异常消息：
- en: '![](img/91765e3a-daf7-4587-b354-bd4fa2c4c6df.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91765e3a-daf7-4587-b354-bd4fa2c4c6df.png)'
- en: We can see in the previous screenshot that the exception message doesn't contain
    the message that we passed. In order to display our custom error message, we need
    to override the standard message property on the exception type. We will use pattern
    matching assignment to get two values and up-cast the actual type, due to the
    internal representation of the exception object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前的屏幕截图中看到异常消息不包含我们传递的消息。为了显示我们的自定义错误消息，我们需要在异常类型上重写标准消息属性。我们将使用模式匹配赋值来获取两个值并将实际类型向上转换，这是由于异常对象的内部表示。
- en: 'If we run this program again, we will get the custom message in the exception:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行此程序，我们将在异常中看到自定义消息：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will get the following error message:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将得到以下错误信息：
- en: '![](img/7a334951-89eb-43d2-a946-359d7c4bb5e6.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a334951-89eb-43d2-a946-359d7c4bb5e6.png)'
- en: 'In the previous screenshot, we can see our custom message with integer and
    string values included in the output. We can also use the helper function, `failwith`,
    to raise a failure exception, as it includes our message as an error message,
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，我们可以看到输出中包含了整数和字符串值的自定义消息。我们还可以使用辅助函数`failwith`来引发失败异常，因为它将我们的消息作为错误消息包含在内，如下所示：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding error message can be seen in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之前错误信息可以在以下屏幕截图中看到：
- en: '![](img/998a4b62-ba78-4fd6-95eb-ae01ae6220a6.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/998a4b62-ba78-4fd6-95eb-ae01ae6220a6.png)'
- en: 'Here is a detailed exception screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个详细的异常屏幕截图：
- en: '![](img/a29b4a48-f087-4184-9a18-1d6906e7d23f.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a29b4a48-f087-4184-9a18-1d6906e7d23f.png)'
- en: 'An example of the `invalidarg` helper function follows. In this factorial function,
    we are checking that the value of `x` is greater than zero. For cases where `x`
    is less than `0`, we call `invalidarg`, pass `x` as the parameter name that is
    invalid, and then some error message saying the value should be greater than 0\.
    The `invalidarg` helper function throws an invalid argument exception from the
    standard system namespace in .NET:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`invalidarg`辅助函数的一个例子。在这个阶乘函数中，我们检查`x`的值是否大于零。对于`x`小于`0`的情况，我们调用`invalidarg`，将`x`作为无效的参数名称传递，然后传递一些错误信息，说明值应该大于0。`invalidarg`辅助函数从.NET标准系统命名空间抛出一个无效参数异常：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Data access layer with F#
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用F#的数据访问层
- en: The F# type provider feature gives the flexibility to access different types
    of data, such as databases, structured types (that is, JSON, XML, CSV, HTML) and
    web-scale data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: F#类型提供者功能提供了访问不同类型数据的灵活性，例如数据库、结构化类型（即JSON、XML、CSV、HTML）和Web规模数据。
- en: First, let's look at data access resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看数据访问资源。
- en: CSV, HTML, JSON, and XML data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV、HTML、JSON和XML数据
- en: In F# applications and scripts, `FSharp.Data.dll` is used to implement the functionality
    to access data. It is also useful for structured file formats such as JSON, XML
    and for consuming freebase services. A sample document structure is used for type
    safe access to the document; it works as a type provider, like the CSV type provider
    takes a CSV sample as input and creates a column format data for that sample.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#应用程序和脚本中，`FSharp.Data.dll`用于实现访问数据的功能。它也适用于结构化文件格式，如JSON、XML，以及消费freebase服务。使用样本文档结构进行类型安全的文档访问；它作为一个类型提供者，就像CSV类型提供者一样，接受CSV样本作为输入并为此样本创建列格式数据。
- en: Providers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者
- en: 'F# supports different types of provider, such as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: F#支持不同类型的提供者，例如：
- en: '`HtmlProvider<>`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HtmlProvider<>`'
- en: '`JsonProvider<>`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonProvider<>`'
- en: '`XmlProvider<>`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlProvider<>`'
- en: '`WorldBankDataProvider<>`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorldBankDataProvider<>`'
- en: '`CsvProvider<>`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CsvProvider<>`'
- en: 'Let''s discuss one of them, for example, the CSV type provider. The `FSharp.Data` NuGet
    package contains `CsvProvider`. We can pass a `.csv` file and can read other `.csv`
    files; for example, we created a `.csv` file as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论其中之一，例如，CSV类型提供者。`FSharp.Data` NuGet包包含`CsvProvider`。我们可以传递一个`.csv`文件并读取其他`.csv`文件；例如，我们创建了一个`.csv`文件如下：
- en: '![](img/2b94d1a6-7324-412d-927d-9dcc439fe0df.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b94d1a6-7324-412d-927d-9dcc439fe0df.png)'
- en: 'Now, we have another `.csv` file which we want to read:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个我们想要读取的另一个`.csv`文件：
- en: '![](img/17bfca3d-c442-4757-9c16-da1a4e3d17f9.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17bfca3d-c442-4757-9c16-da1a4e3d17f9.png)'
- en: 'Here is a code snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码片段：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see what values are calculated by the F# compiler for `Salesitem`, as
    the `ExampleCSV` file is passed, for example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看F#编译器为`Salesitem`计算了哪些值，因为传递了`ExampleCSV`文件，例如：
- en: '![](img/cba4b196-ef5b-4374-ac90-48401a08ae84.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cba4b196-ef5b-4374-ac90-48401a08ae84.png)'
- en: 'Here, we can see the compiler is able to detect the header name and took it
    from the second `.csv` file. We can control column types by customizing them using
    the `InferRows` static parameter of `CsvProvider`. To use the full file, we can
    pass `0`. If the first row of a file is not a header, then we can pass the `HasHeaders`
    static parameter value to `false`, for example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到编译器能够检测到标题名称，并从第二个`.csv`文件中获取它。我们可以通过使用`CsvProvider`的`InferRows`静态参数自定义列类型。要使用整个文件，我们可以传递`0`。如果文件的第一行不是标题，则我们可以将`HasHeaders`静态参数值传递给`false`，例如：
- en: '![](img/42b792ae-5584-4f09-87c1-902afbfc51cf.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42b792ae-5584-4f09-87c1-902afbfc51cf.png)'
- en: The `FSharp.Data` library also contains helpers for parsing JSON, HTML files,
    and helpers to send HTTP requests. It is available with the name `FSharp.Data`
    on NuGet.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSharp.Data`库还包含解析JSON、HTML文件和发送HTTP请求的辅助函数。它在NuGet上可用，名称为`FSharp.Data`。'
- en: 'JSON.NET is a JSON framework for .NET. It has full support with F# serialization
    from and to JSON. We can install using NuGet by using the command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JSON.NET是.NET的JSON框架。它完全支持F#从JSON进行序列化和反序列化。我们可以通过使用NuGet命令安装：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Data access tools
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问工具
- en: 'We discussed data type providers earlier. F# also has dynamic API support for
    faster and dynamic data retrieval. It contains CSV, HTML, JSON parsers, and also
    tools for HTTP request parsing. Let''s briefly discuss each of them:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了数据类型提供者。F#还支持动态API，以实现更快和动态的数据检索。它包含CSV、HTML、JSON解析器，以及HTTP请求解析的工具。让我们简要地讨论每个：
- en: '**CSV parser**: To access data dynamically, we can use the CSV parser. The
    afore mentioned CSV provider is built on top of the F# CSV parser. The `FSharp.Data`
    namespace has the `CsvFile` type, which provides two methods for loading data:
    the `Parse` method for string data, and the `Load` method for reading data from
    a file or any web source (example: `CsvFIle.Load(<file path>)`).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSV解析器**：为了动态访问数据，我们可以使用CSV解析器。前面提到的CSV提供程序是在F# CSV解析器之上构建的。`FSharp.Data`命名空间中的`CsvFile`类型提供了两种加载数据的方法：`Parse`方法用于字符串数据，`Load`方法用于从文件或任何网络源（例如：`CsvFIle.Load(<file
    path>)`）读取数据。'
- en: '**HTML parser**: It parses HTML documents into the DOM. When it gets parsed
    into DOM, F# supports many extension functions for HTML DOM elements, to extract
    information from the web page. Let''s see an example where we will search `.NET
    Core` in Google and parse the first search result page, getting all URLs and hyperlinks:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML解析器**：它将HTML文档解析成DOM。当它被解析成DOM时，F#支持许多针对HTML DOM元素的扩展函数，以从网页中提取信息。让我们看一个例子，我们将搜索Google中的“.NET
    Core”并解析第一个搜索结果页面，获取所有URL和超链接：'
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the previous code, using `HtmlDocument.Load(),` we are parsing the web page
    into DOM. `resultsDocument` contains all data from the page, as this method will
    make a synchronous web call. We can also make an asynchronous call using the method, `HtmlDocument.AsyncLoad()`.
    To extract data from the result document, we first find all HTML anchor tags and
    then find all `href` tags to get the link and its text:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用`HtmlDocument.Load()`，我们将网页解析成DOM。`resultsDocument`包含页面上的所有数据，因为这个方法将进行同步网络调用。我们也可以使用该方法进行异步调用，即`HtmlDocument.AsyncLoad()`。要从结果文档中提取数据，我们首先找到所有HTML锚标签，然后找到所有`href`标签以获取链接及其文本：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output will show all first page search results for `.NET Core` in Google.
    The result looks like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示Google中“.NET Core”的第一页搜索结果。结果看起来像这样：
- en: '![](img/299b1578-dbb6-44fc-b43a-0edcf4267fb7.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/299b1578-dbb6-44fc-b43a-0edcf4267fb7.png)'
- en: '**JSON Parser**: The same as the CSV provider, the JSON provider is built on
    top of the JSON parser. We need the same library for all the parsers: `FSharp.Data.dll`.
    It has the `JsonValue` type for parsing. Here is an example:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON解析器**：与CSV提供程序相同，JSON提供程序是在JSON解析器之上构建的。我们需要为所有解析器使用相同的库：`FSharp.Data.dll`。它有`JsonValue`类型用于解析。以下是一个例子：'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`FSharp.Data.Extensions` supports many extension methods such as `value.Properties()` and
    gives a list of properties of a record node.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSharp.Data.Extensions`支持许多扩展方法，如`value.Properties()`，并提供记录节点属性列表。'
- en: '**HTTP Utilities**: In the `FSharp.Data` namespace, we have HTTP utilities,
    which are easy and quick for HTTP requests, post data or responses such as get
    status code. HTTP has a few overloaded methods, `requestString` and `AsyncRequest`
    or `AsyncRequestString` and `AsyncRequest`; these can create a simple request
    synchronously or asynchronously, respectively. Here is an example:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP工具**：在`FSharp.Data`命名空间中，我们有HTTP工具，它们用于HTTP请求、发送数据或获取状态码等响应，既简单又快捷。HTTP有几个重载方法，`requestString`和`AsyncRequest`或`AsyncRequestString`和`AsyncRequest`；这些可以分别同步或异步地创建简单请求。以下是一个例子：'
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '![](img/9ff45d98-d657-4f55-af0e-4b88dd0c30df.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ff45d98-d657-4f55-af0e-4b88dd0c30df.png)'
- en: SQL data access
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL数据访问
- en: 'In F#, there are multiple libraries for SQL data access. We can browse them
    in NuGet; a few of them are discussed as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，有多个用于SQL数据访问的库。我们可以在NuGet中浏览它们；以下将讨论其中的一些：
- en: '`FSharp.Data.SqlClient`: This library provides `SqlCommandProvider`, which
    gives type safe access to transactional SQL languages. `SqlProgrammabilityProvider`
    provides quick access to a SQL server **stored procedure** (**SP**), tables, and
    functions, and `SqlEnumProvider` generates an `enum` type on the ground of static
    lookup data from an ADO.NET-compliant source.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.Data.SqlClient`：这个库提供了`SqlCommandProvider`，它提供了对事务SQL语言的类型安全访问。`SqlProgrammabilityProvider`提供了对SQL服务器**存储过程**（**SP**）、表和函数的快速访问，而`SqlEnumProvider`基于来自ADO.NET兼容源静态查找数据生成一个`enum`类型。'
- en: 'To install the `FSharp.Data.SqlClient` library from NuGet, use the following
    command:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从NuGet安装`FSharp.Data.SqlClient`库，请使用以下命令：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`FSharp.Data.SQLProvider`: `SQLProvider` is a general .NET/Mono SQL database
    provider. This library supports automatic constraint navigation, CRUD operations
    with identity support, asynchronous operations, LINQ query, functions, SP support,
    record types mapping, .NET Core/.NET Standard, and so on. `SQLProvider` has explicit
    implementation for SQL Server, SQLite, Oracle, MySQL, MSAccess, Firebird, and
    so on. SQL Server and MS Access don''t require third-party ADO.NET connector objects,
    the rest all require this.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.Data.SQLProvider`: `SQLProvider` 是一个通用的 .NET/Mono SQL 数据库提供程序。这个库支持自动约束导航、具有身份支持的
    CRUD 操作、异步操作、LINQ 查询、函数、存储过程支持、记录类型映射、.NET Core/.NET Standard 等。`SQLProvider`
    对 SQL Server、SQLite、Oracle、MySQL、MSAccess、Firebird 等都有明确的实现。SQL Server 和 MS Access
    不需要第三方 ADO.NET 连接器对象，其余的都需要这个。'
- en: 'To install the `FSharp.Data.SqlProvider` library from NuGet, use the following
    command:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从 NuGet 安装 `FSharp.Data.SqlProvider` 库，请使用以下命令：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `SqlDataConnection`: `SqlDataConnection` type provider generates types,
    for data in SQL DB on live connections. It is for accessing SQL using LINQ queries.
    It requires a Microsoft SQL server. We need three references in a F# project—`FSharp.Data.TypeProviders`,
    `System.Data`, and `System.Data.Linq`. Here is an example:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SqlDataConnection`: `SqlDataConnection` 类型提供程序生成类型，用于在实时连接的 SQL 数据库中的数据。它是用于通过
    LINQ 查询访问 SQL 的。它需要一个 Microsoft SQL 服务器。在 F# 项目中我们需要三个引用—`FSharp.Data.TypeProviders`,
    `System.Data`, 和 `System.Data.Linq`。以下是一个示例：'
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `SqlEntityConnection`: `SqlEntityConnection` type provider is for accessing
    SQL through LINQ queries and Entity Framework. It works with many databases. We
    need `System.Data.Linq`, `System.Data.Entity`, and `Microsoft.FSharp.Data.TypeProviders`
    references. Here is an example:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SqlEntityConnection`: `SqlEntityConnection` 类型提供程序用于通过 LINQ 查询和 Entity Framework
    访问 SQL。它与许多数据库兼容。我们需要 `System.Data.Linq`, `System.Data.Entity`, 和 `Microsoft.FSharp.Data.TypeProviders`
    引用。以下是一个示例：'
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**ADO.NET**: It provides data access services and functionality for writing
    managed code and consistent data source access for SQL Server, and also data sources
    exposed through OLEDB or XML. Customers can use ADO.NET to connect with any data
    source to retrieve, manipulate, and update data. It can perform all CRUD operations.
    ADO.NET also supports frontend database creation, and middle-tier objects for
    application, tools, or browsers.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADO.NET**: 它提供数据访问服务和用于编写托管代码的功能，以及为 SQL Server 和通过 OLEDB 或 XML 暴露的数据源提供一致的数据源访问。客户可以使用
    ADO.NET 连接到任何数据源以检索、操作和更新数据。它可以执行所有 CRUD 操作。ADO.NET 还支持前端数据库创建、应用、工具或浏览器的中间层对象。'
- en: Web data access
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络数据访问
- en: The `FSharp.Data` library provides many type providers, and in F# it is very
    easy to integrate these data stores in programming. Additional web data stores
    can be accessed using JSON, XML, and CSV format support of F#.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSharp.Data` 库提供了许多类型提供程序，在 F# 中，将这些数据存储集成到编程中非常容易。可以通过 F# 的 JSON、XML 和 CSV
    格式支持访问额外的网络数据存储。'
- en: Querying SQL vNext with F#
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 F# 查询 SQL vNext
- en: 'SQL vNext is Microsoft''s major release for SQL open source and platform-independent
    DBs. It has introduced major features of the relational database to Linux: in-memory
    OLTP, in-memory columnstores, transparent data encryption, Always Encrypted, and
    row-level security, to make SQL Server the platform of choice across operating
    systems. It provides us with development language selection options, on-premise
    or cloud options, and operating system options such as Linux (Red Hat, SUSE, and
    Ubuntu), and Linux-based Docker containers or windows, adaptive query processing,
    SQL graphs, improvements to analysis services, reporting services, and integration
    services.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: SQL vNext 是微软针对 SQL 开源和平台无关数据库的主要发布版本。它将关系数据库的主要功能引入了 Linux：内存 OLTP、内存列存储、透明数据加密、始终加密和行级安全，使
    SQL Server 成为跨操作系统的首选平台。它为我们提供了开发语言选择、本地或云选项以及操作系统选项，如 Linux（Red Hat、SUSE 和 Ubuntu）、基于
    Linux 的 Docker 容器或 Windows、自适应查询处理、SQL 图、分析服务、报告服务和集成服务的改进。
- en: 'It has new features such as integration services; till now SQL Server 2016
    SSIS package execution was limited to one machine, but now integration services
    give high-performance package execution by distributing execution on multiple
    machines like parallel execution on different servers. It involves:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有新的功能，如集成服务；到目前为止，SQL Server 2016 SSIS 包执行仅限于一台机器，但现在集成服务通过在多台机器上分配执行（类似于在不同服务器上的并行执行）提供了高性能的包执行。它包括：
- en: '**SSIS Scale Out Master**: It is for scaling out management and receives package
    execution requests from the user'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSIS Scale Out Master**: 它用于扩展管理，并从用户那里接收包执行请求'
- en: '**SSIS Scale Out Worker**: It pulls execution tasks from the scaled out master
    and works on package execution'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSIS Scale Out Worker**：它从扩展的 master 中提取执行任务并在包执行上工作'
- en: 'In an F# program, we can read data using the LINQ query by writing in F# languages
    or by using ADO.NET classes, such as `SqlCommand`. Mostly ADO.NET classes are
    used when we need a simple query call but while calling SP, we must add multiple
    parameters using `SqlParameter` in this approach. We can use dynamic operators
    for dynamic invocations in F#. As we saw providers have helper functions, which
    are used but each has many drawbacks. Let''s discuss how to define a query and
    create helper functions with parameters. Here is some example code for illustration:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 程序中，我们可以通过编写 F# 语言或使用 ADO.NET 类（如 `SqlCommand`）来使用 LINQ 查询读取数据。通常在需要简单的查询调用时使用
    ADO.NET 类，但在调用存储过程时，我们必须使用 `SqlParameter` 添加多个参数。我们可以在 F# 中使用动态操作符进行动态调用。正如我们所见，提供者有辅助函数，这些函数被使用，但每个都有许多缺点。让我们讨论如何定义查询并使用参数创建辅助函数。以下是一些示例代码，用于说明：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To get `Sqlconnection` and other ADO.NET methods, install the NuGet package
    of `System.Data.SqlClient`. In the preceding code, we defined a type `SqlQueryExample`,where
    `Query` is a string and `Parameters` is a tuple type. We created a module, `QueryHelpersForFsharp`,
    where we defined `param` which takes two values, `name` and `value`, and a function, `sqlFunction`
    which takes two parameters, `query` and `parameters`; we are assigning these values:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `SqlConnection` 和其他 ADO.NET 方法，请安装 `System.Data.SqlClient` 的 NuGet 包。在前面的代码中，我们定义了一个类型
    `SqlQueryExample`，其中 `Query` 是一个字符串，`Parameters` 是元组类型。我们创建了一个模块 `QueryHelpersForFsharp`，在其中我们定义了
    `param`，它接受两个值，`name` 和 `value`，以及一个函数 `sqlFunction`，它接受两个参数，`query` 和 `parameters`；我们正在分配这些值：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can use the preceding module and use `sqlFunction` and the `param` parameter
    to run a `query.` The `sqlFunction.query<type>` function will run the query and
    it will convert each data row into a specified type object. `Query` is not created
    in the same place where the `query` execution code is written. It is a separate
    piece of code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的模块并使用 `sqlFunction` 和 `param` 参数来运行一个 `query`。`sqlFunction.query<type>`
    函数将运行查询，并将每一行数据转换为指定的类型对象。`Query` 不是在执行查询代码的地方创建的，它是一段独立的代码：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s see an example of data insertion using the ADO.NET function by `FsSql`.
    We will create an entity that is one row of a table and insert it into the DB:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 ADO.NET 函数 `FsSql` 的一个示例来查看数据插入的过程。我们将创建一个实体，它是表中的一行，并将其插入到数据库中：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To insert records, we created a type, `changeQueryObject`, which has `query`
    as string type and `parameters` as the `SqlParameter` type `list`. We created
    a `private insert ()` method which takes `Employee` data as input, and here `query`
    has the `insert sql query` string and `parameter` contains a list of `SqlParameters`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入记录，我们创建了一个类型 `changeQueryObject`，它具有字符串类型的 `query` 和 `SqlParameter` 类型的 `parameters`
    列表。我们创建了一个 `private insert ()` 方法，它接受 `Employee` 数据作为输入，在这里 `query` 包含 `insert
    sql query` 字符串，而 `parameter` 包含 `SqlParameters` 的列表：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To execute this, code the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请编写以下代码：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed functional programming and its features, such
    as higher-order functions, purity, lazy evaluation, currying, and so on. We learned
    about F# basics such as classes, `let` and `do` bindings, generic type parameters,
    properties in F#, how to write functions and lambda expressions in F#, exception
    handling, and so on. Also, we saw different types of data provider in F# and how
    different types of data parser work. We also learned about querying SQL vNext
    with F#. This brings us towards the end of this book but our journey of learning
    has just got started.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了函数式编程及其特性，如高阶函数、纯度、惰性求值、柯里化等。我们学习了 F# 的基础知识，如类、`let` 和 `do` 绑定、泛型类型参数、F#
    中的属性、如何在 F# 中编写函数和 lambda 表达式、异常处理等。我们还看到了 F# 中的不同类型的数据提供者以及不同类型的数据解析器的工作方式。我们还学习了如何使用
    F# 查询 SQL vNext。这使我们接近本书的结尾，但我们的学习之旅才刚刚开始。
