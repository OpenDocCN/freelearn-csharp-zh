- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The One with the Low-Level Secrets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有底层秘密的那一个
- en: '*Understanding* *low-level APIs*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*理解* *底层API*'
- en: Writing software can be a daunting task. You need to consider many things when
    you try to convert your ideas into something that works on the machine. After
    all, there are so many things you need to tell the computer before it does something
    useful.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件可能是一项艰巨的任务。当您试图将您的想法转化为机器上可以运行的东西时，您需要考虑许多因素。毕竟，在计算机执行任何有用的操作之前，您需要告诉计算机很多事情。
- en: But we are in luck. Many of the instructions we need to give the CPU are encapsulated
    in frameworks, tools, packages, and other pieces of software. These building blocks
    allow us to focus on what we want to build instead of how the CPU might interpret
    our instructions. That makes life a lot easier!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们很幸运。我们需要提供给CPU的许多指令都被封装在框架、工具、包和其他软件组件中。这些构建块使我们能够专注于我们想要构建的内容，而不是CPU如何解释我们的指令。这使得生活变得更加容易！
- en: 'This chapter looks into those building blocks, how they help us, and how we
    can best use them. This chapter also covers how .NET works and where it comes
    from. This is important: most developers take the advantages of .NET for granted.
    That is fine since the framework hides much complexity. However, when writing
    lower-level system software, it is essential to know why things in .NET work the
    way they do and how to use other solutions if needed. Also, it doesn’t hurt to
    be reminded of some basic things occasionally, especially when you might have
    to deviate from the road user-facing software developers take.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '本章探讨了这些构建块，它们如何帮助我们，以及我们如何最好地使用它们。本章还涵盖了.NET的工作原理及其来源。这很重要：大多数开发者都理所当然地认为.NET具有优势。这是可以接受的，因为框架隐藏了许多复杂性。然而，在编写底层系统软件时，了解.NET中的事物为何如此工作以及如何在需要时使用其他解决方案至关重要。此外，偶尔提醒一些基本的事情也无妨，尤其是在您可能需要偏离面向用户的软件开发者所走的道路时。 '
- en: 'So, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将涵盖以下主题：
- en: What are low-level APIs?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是底层API？
- en: How does the Base Class Library (BCL) help us .NET developers?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类库（BCL）如何帮助我们.NET开发者？
- en: What is the Common Language Runtime (CLR)?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是公共语言运行时（CLR）？
- en: What are Win32 APIs and how do we call them?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Win32 API是什么，我们如何调用它们？
- en: All in all, we are going low here and getting all technical.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，我们将深入探讨并全面了解技术。
- en: But before we dive into the building blocks the .NET ecosystem gives us, we
    need to chat about APIs – to be more precise, the difference between low-level
    and high-level APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入探讨.NET生态系统为我们提供的构建块之前，我们需要讨论API——更准确地说，是底层API和高级API之间的区别。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can visit the following link to view all the code in this chapter: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问以下链接查看本章中所有代码：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01)。
- en: What are low-level APIs, and how do they differ from higher-level abstractions?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层API是什么，它们与高级抽象有何不同？
- en: Well, maybe we are going a bit too fast. Before we can look at low-level and
    high-level APIs, we need to agree on what an API means.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许我们走得有点快了。在我们能够查看底层和高级API之前，我们需要就API的含义达成一致。
- en: API is an abbreviation for application programming interface. Although technically
    correct, it doesn’t tell us much. We need a better definition of API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: API是应用程序编程接口的缩写。虽然技术上正确，但它并没有告诉我们太多。我们需要一个更好的API定义。
- en: What are interfaces?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是什么？
- en: Let’s begin with the term **interface.** That alone can be defined entirely
    differently, depending on whom you ask.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从术语**接口**开始。仅凭这一点，根据您询问的人的不同，就可以完全不同地定义。
- en: An interface can be a **software interface**, which is the boundary between
    two pieces of software. For instance, a database such as SQL Server allows users
    to access data by accepting SQL queries. That is the main interface for that database
    system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以是一个**软件接口**，它是两块软件之间的边界。例如，SQL Server这样的数据库允许用户通过接受SQL查询来访问数据。这就是该数据库系统的主要接口。
- en: Another definition of an interface would be a **hardware interface**. The USB
    ports on your computer and the peripherals you connect to your machine using them
    are hardware interfaces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的一个另一种定义将是**硬件接口**。您电脑上的USB端口以及您通过它们连接到机器的外设都是硬件接口。
- en: Of course, in C#, we also have interfaces. Most object-oriented programming
    languages support interfaces in one way or another. For instance, C++ has the
    concept of pure virtual classes. Python supports abstract base classes, which
    serve the same purpose.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在C#中，我们也有接口。大多数面向对象编程语言以某种方式支持接口。例如，C++有纯虚类的概念。Python支持抽象基类，它们具有相同的目的。
- en: An API is the interface between a piece of software and other software meant
    for the programmer. This defines the boundaries of a given code set and how to
    interact with it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: API是软件与程序员使用的其他软件之间的接口。这定义了给定代码集的边界以及如何与之交互。
- en: So, it is possible to create a giant library filled with wondrous and highly
    complex code. As the library user, you get a list of methods, classes, interfaces
    (yes, the C# kind), enums, and other means of interacting with that library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以创建一个充满奇妙且高度复杂代码的巨大库。作为库用户，你将获得一系列方法、类、接口（是的，C#类型的）、枚举以及其他与该库交互的方式。
- en: This is awesome since you can use that library without worrying about writing
    code yourself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为你可以在不担心编写代码的情况下使用那个库。
- en: Low-level and high-level APIs
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 底层和高级API
- en: The level of an API is an arbitrary distinction to give you an idea of how close
    to the actual hardware an API is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: API的级别是一个任意的区分，用来给你一个API实际硬件接近程度的想法。
- en: No metric tells us when something is a lower or higher-level API. It is all
    relative and open for debate. This, however, is something we are not going to
    do here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何度量标准告诉我们何时某个东西是底层或高级API。一切都是相对的，并且可以公开讨论。然而，这里我们不会这样做。
- en: Generally, a low-level API gives you more granular control over the hardware
    than a higher-level API. A higher-level API, however, is usually more portable
    and can be used to achieve goals much quicker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，底层API比高级API提供对硬件更细粒度的控制。然而，高级API通常更易于移植，并且可以更快地实现目标。
- en: If that all sounds a bit abstract, don’t worry. Let me clarify this with some
    examples. For instance, imagine that you want to send some data across a network.
    Well, when I say network, I mean we send it to IP address `127.0.0.1`. In other
    words, we send it to localhost; we are speaking to ourselves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来有点抽象，不要担心。让我通过一些例子来澄清这一点。例如，想象你想通过网络发送一些数据。当我说网络时，我的意思是我们将它发送到IP地址`127.0.0.1`。换句话说，我们发送到本地主机；我们在和自己说话。
- en: 'To do this, we need to call a lot of low-level APIs that the Windows SDK gives
    us. The code looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要调用Windows SDK为我们提供的许多底层API。代码看起来是这样的：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, many things must happen for such a relatively simple task. I
    have omitted all the code we need to access the APIs and the definition of the
    classes and structs, such as `WSAData`. I also simplified this sample and didn’t
    use much error handling or memory management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，为了完成这样一个相对简单的任务，必须发生许多事情。我已经省略了所有我们需要访问API以及类和结构体（如`WSAData`）定义的代码。我还简化了这个示例，没有使用很多错误处理或内存管理。
- en: I won’t go through what’s happening in the preceding code as it isn’t part of
    what I’m trying to show you. We will revisit this later in this book when we discuss
    networking. I provided this code to show you what a low-level API looks like.
    Here, I want you to pay attention to the calls to `WSAStartup()`, `WSACleanup()`,
    `socket()`, `connect(`), `send()`, and `closesocket()`. These are APIs that come
    from the Windows SDK. They are the parts of Windows that help us set up connections
    to network interfaces, translate addresses, open and close sockets, and send data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释前面代码中发生的事情，因为它不是我要展示的内容的一部分。我们将在本书讨论网络时再次回到这个话题。我提供这段代码是为了展示底层API的样子。在这里，我希望你注意对`WSAStartup()`、`WSACleanup()`、`socket()`、`connect(`)、`send()`和`closesocket()`的调用。这些来自Windows
    SDK的API。它们是Windows中帮助我们设置网络接口连接、转换地址、打开和关闭套接字以及发送数据的部分。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is good to remember that the Windows SDK is a wrapper. The code inside the
    SDK, written mainly in C and a bit in C++, does the heavy lifting and calls the
    hardware. We don’t have to worry about this: the people at Microsoft have already
    figured out how to do all this.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Windows SDK是一个包装器是很好的。SDK内部的代码，主要用C语言编写，部分用C++编写，执行了繁重的任务并调用硬件。我们不必担心这一点：微软的人已经想出了如何完成所有这些。
- en: Like I said, low-level and high-level terms depend on how you look at them.
    It is all relative. You can consider Windows SDK APIs high-level APIs when you
    look at them from a C programmer’s perspective, who has to do all the heavy lifting.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的一样，低级和高级术语取决于你如何看待它们。这完全是相对的。当你从C程序员的视角来看时，他们必须做所有繁重的工作，你可以将Windows SDK
    API视为高级API。
- en: 'But we, as .NET developers, see this as rather low-level. This is because,
    as .NET developers, we have even easier tools to use. The preceding code isn’t
    something most developers will write. Instead, they will write the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为.NET开发者，我们将其视为相当低级。这是因为，作为.NET开发者，我们有更易于使用的工具。前面的代码不是大多数开发者会写的。相反，他们会写以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is much easier and a lot smaller. Most of the preceding code consists
    of catching exceptions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更容易且更小。前面的大部分代码都是捕获异常。
- en: The `TcpClient` class is doing the hard work. We instantiate an instance of
    it, give it the address we want to connect to, get a `NetworkStream` instance
    from it, and then write a bunch of bytes. Simple. It works brilliantly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`TcpClient`类正在做艰苦的工作。我们实例化它的一个实例，给它我们想要连接的地址，从它那里获取一个`NetworkStream`实例，然后写入一些字节。很简单。它工作得非常出色。'
- en: So, why would you care about the low-level stuff?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你为什么要关心这些低级的东西呢？
- en: 'Although the low-level code is a lot more work and complicated, it gives you
    one significant advantage: more control.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管低级代码工作量更大且更复杂，但它给你一个显著的优势：更多的控制。
- en: We use TCP/IP here. But what if the device you want to communicate with doesn’t
    have TCP? And before you say “Everything is IP-based these days,” I’m pretty sure
    you have computers in your house that communicate over older technology. You might
    use devices that don’t have TCP on board every day. I’m talking about remote controls
    for most television sets. They use infrared. Many devices still use infrared.
    It’s cheap, well-understood, quick to install, and robust in terms of its use
    cases. It is also not supported by .NET.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用TCP/IP。但如果你想要通信的设备没有TCP怎么办？在你还没来得及说“现在所有东西都是基于IP的”之前，我非常确信你家里的电脑可能还在使用较旧的技术进行通信。你可能每天都在使用没有TCP的设备。我指的是大多数电视机的遥控器。它们使用红外线。许多设备仍然使用红外线。它成本低，易于理解，安装快速，在用例方面稳健。它也不受.NET支持。
- en: 'But when it comes to low-level APIs, it is pretty simple. There are some differences
    in how to set up the connection: there is no IP address, so you have to use the
    device ID, but the connection itself is not that hard to use. Look at the line
    where we set up the call to `socket()`. We use `2` as the first parameter, which
    stands for `AF_INET`, which means TCP. Change that to `26 (AF_IRDA)`, and the
    underlying libraries switch to infrared devices.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但当涉及到低级API时，它相当简单。在设置连接的方式上存在一些差异：没有IP地址，所以你必须使用设备ID，但连接本身并不难使用。看看我们设置`socket()`调用的那行代码。我们使用`2`作为第一个参数，它代表`AF_INET`，意味着TCP。将其改为`26
    (AF_IRDA)`，底层库就会切换到红外设备。
- en: This can’t be done with the .NET libraries that are available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这不能用可用的.NET库来完成。
- en: The high-level APIs are amazing and help us write code that is easy to understand
    quickly. However, as systems programmers, we have to deal with hardware and other
    low-level systems. That’s when we have to use the low-level APIs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 高级API非常出色，帮助我们快速编写易于理解的代码。然而，作为系统程序员，我们必须处理硬件和其他低级系统。那时我们就必须使用低级API。
- en: Before we dive into how to use these APIs, let’s look at the .NET libraries
    themselves. While we’re at it, we’ll examine the CLR so that you have a clear
    picture of what .NET gives us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何使用这些API之前，让我们看看.NET库本身。在此过程中，我们将检查CLR，以便你对.NET能给我们带来什么有一个清晰的了解。
- en: Overview of .NET Core runtime components (CLR, BCL)
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core运行时组件概述（CLR、BCL）
- en: Previously, we examined the difference between low-level and high-level programming
    languages. Like the APIs, lower and higher mean how close to or far away you are
    from the actual machine. Programming in C means you are very close to the hardware;
    programming in C# means you are far away. Of course, being further away means
    you are working in abstractions. The advantage is that many things are simplified,
    as seen earlier in this chapter. Also, with many abstractions, moving your code
    to other platforms is more manageable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们探讨了低级和高级编程语言之间的区别。就像API一样，低级和高级意味着你离实际机器有多近或有多远。用C语言编程意味着你非常接近硬件；用C#编程意味着你远离。当然，距离越远意味着你在抽象层面工作。优点是许多事情都简化了，正如本章前面所看到的。此外，由于许多抽象，将你的代码迁移到其他平台更容易管理。
- en: The magic that makes this possible is the .NET runtime. Since the first version,
    the designers have always aimed to shield you from the low-level stuff as much
    as possible. This lets you write your code quickly and focus on functionality
    instead of boilerplate.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切成为可能的是.NET运行时。从第一个版本开始，设计者就始终致力于尽可能多地屏蔽低级内容。这让你可以快速编写代码，专注于功能而不是样板代码。
- en: .NET is a complex topic. But in short, it comes down to a set of tools in many
    different forms that help you achieve your goal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .NET是一个复杂的话题。但简而言之，它是一套以多种形式存在的工具，帮助你实现目标。
- en: Fun fact
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实
- en: 'Before its initial launch, the project’s code name was Project 42\. 42 is the
    answer to life, the universe, and everything in the books, TV shows, and the major
    motion picture from science fiction author Douglas Adams: *The Hitchhikers Guide
    to the Galaxy*. Adams wrote that 42 was the answer to everything; hence, the .NET
    designers thought it appropriate to name the solution to all developer problems
    Project 42.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最初发布之前，该项目的代码名称是Project 42。42是来自科幻作家道格拉斯·亚当斯的书、电视剧和主要科幻电影《银河系漫游指南》中，对生命、宇宙和万物之答案。亚当斯写道，42是万物的答案；因此，.NET设计者认为将所有开发者问题的解决方案命名为Project
    42是合适的。
- en: .NET does not solve all problems, but it makes life much easier. Let’s see how
    it does that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: .NET并不能解决所有问题，但它使生活变得更加容易。让我们看看它是如何做到这一点的。
- en: 'We can identify three major areas where .NET helps us:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确定.NET帮助我们解决三个主要领域：
- en: Development tools
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发工具
- en: The CLR
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR
- en: The BCL
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BCL
- en: I will not be spending time on development tools here. Instead, I want to discuss
    the CLR and the BCL. These two form the backbone of the .NET ecosystem. In later
    chapters, I will cover other essential parts of the .NET ecosystem, such as the
    **Common Type** **System** (**CTS**).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里花费时间讨论开发工具。相反，我想讨论CLR和BCL。这两个构成了.NET生态系统的核心。在后面的章节中，我将介绍.NET生态系统的其他重要部分，例如**公共类型系统**（**CTS**）。
- en: CLR
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLR
- en: CLR is the runtime environment in which our code runs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CLR是我们代码运行的运行时环境。
- en: The compiler (covered later in this book) compiles the code we have written.
    For now, we can imagine that the compiler takes our human-readable text and changes
    it into something a computer can understand and use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器（本书后面将详细介绍）编译我们编写的代码。目前，我们可以想象编译器将我们人类可读的文本转换为计算机可以理解和使用的某种形式。
- en: Well, not quite. I need to clarify things a bit here. Although what I wrote
    is technically correct when discussing compilers, this is only true for real compilers,
    such as those found using C or C++. This does not apply to the .NET-based world.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，并不完全是这样。我需要在这里澄清一些事情。虽然我在讨论编译器时写的内容在技术上是对的，但这只适用于真正的编译器，例如使用C或C++找到的编译器。这并不适用于.NET世界。
- en: The .NET compilers compile while targeting a common runtime instead of the hardware
    we run on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: .NET编译器在针对通用运行时而不是我们运行的硬件进行编译。
- en: The compiler’s output is not native to the hardware. Instead, it outputs something
    called Intermediate Language (IL). This is a sort of “in-between” form. It’s not
    human-readable, but it is too abstract for computers to understand. It is in between
    those two forms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的输出不是针对硬件的。相反，它输出一种称为中间语言（IL）的东西。这是一种“中间”形式。它不是人类可读的，但对于计算机来说又过于抽象。它介于这两种形式之间。
- en: Let me clarify that with an example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过一个例子来澄清这一点。
- en: 'I have written a .NET Console app with no top-level statements. In other words,
    this is the most simple piece of code we can write using .NET. The whole program
    consists of one single line:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个没有任何顶层语句的.NET控制台应用程序。换句话说，这是我们使用.NET可以编写的最简单的代码片段。整个程序由一行代码组成：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I don’t need to explain what I’m doing here, right?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要解释我在这里做什么，对吧？
- en: 'If we use Visual Studio to compile the code, it will take all of our files,
    give them to the compiler, and instruct it to build a binary. That looks like
    this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Visual Studio来编译代码，它将获取所有我们的文件，将它们交给编译器，并指示它构建一个二进制文件。这看起来是这样的：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a bit harder to understand but not too hard. First, there’s some code
    to set things up (`.maxstack 8`). We load the string with the call to the `ldstr`
    function and then call the `System.Console::WriteLine(string)` method, and we
    are done.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以理解，但并不太难。首先，有一些代码用于设置环境（`.maxstack 8`）。我们通过调用`ldstr`函数来加载字符串，然后调用`System.Console::WriteLine(string)`方法，然后我们就完成了。
- en: Again, this is not machine code. That looks a lot harder, and I’m not going
    to show you that. If compiled to something the CPU can understand and execute,
    this code is several pages long.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不是机器代码。那看起来要复杂得多，我不会向您展示。如果编译成CPU可以理解和执行的代码，这段代码会有几页长。
- en: 'However, I will show you part of it to give you a taster:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我将向您展示其中的一部分，以便您先尝尝味道：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This tiny assembly code segment instructs the CPU to take a pointer to the memory
    where the string is and then calls the first part of the `WriteLine` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段微小的汇编代码段指示CPU获取字符串所在内存的指针，然后调用`WriteLine`方法的第一部分。
- en: Again, the complete code would be several pages long.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，完整的代码会有几页长。
- en: 'I hope you are beginning to appreciate the brevity and simplicity of the .NET
    system. But I also want you to know what happens behind the scenes. When writing
    system software, we sometimes need to do things that aren’t possible in .NET.
    Then, we have to rely on other ways to achieve our results. We won’t write pure
    assembly in this book: that would be too much. But I do want you to know what’s
    happening as that will benefit you enormously later on.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您开始欣赏.NET系统的简洁性和简单性。但我也想让您知道幕后发生了什么。在编写系统软件时，我们有时需要做一些在.NET中不可能完成的事情。然后，我们必须依赖其他方式来实现我们的目标。我们不会在这本书中编写纯汇编代码：那会太复杂了。但我确实想让您知道正在发生的事情，这将在以后给您带来巨大的好处。
- en: Okay. Between the IL code I showed you and the assembly code I showed you is
    the place where the CLR lives.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。在我向您展示的IL代码和我向您展示的汇编代码之间，是CLR存在的地方。
- en: 'As stated in [https://learn.microsoft.com/en-us/dotnet/standard/clr](https://learn.microsoft.com/en-us/dotnet/standard/clr),
    the CLR offers us quite a lot of things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如[https://learn.microsoft.com/en-us/dotnet/standard/clr](https://learn.microsoft.com/en-us/dotnet/standard/clr)所述，CLR为我们提供了相当多的事物：
- en: Performance improvements
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能改进
- en: The ability to easily use components developed in other languages
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够轻松使用其他语言开发的组件
- en: Extensible types provided by a class library
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由类库提供的可扩展类型
- en: Language features such as inheritance, interfaces, and overloading for object-oriented
    programming
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程的语言特性，如继承、接口和重载
- en: Support for explicit free threading that allows multithreaded and scalable applications
    to be created
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持显式多线程，允许创建多线程和可扩展的应用程序
- en: Support for structured exception handling
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持结构化异常处理
- en: Support for custom attributes
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自定义属性
- en: Garbage collection
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: This information comes straight out of the documentation from Microsoft, so
    if you want to know more, I urge you to look it up and read more about it. Later
    chapters will discuss some of these items, such as threading, exception handling,
    and garbage collection. For now, it is enough to know that when we compile our
    code, we prepare it for the CLR to use and run it. The CLR will take care of the
    rest and make it work nicely on actual hardware.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息直接来自微软的文档，所以如果您想了解更多，我强烈建议您查找并阅读更多关于它的内容。后面的章节将讨论一些这些项目，例如线程、异常处理和垃圾回收。现在，了解当我们编译我们的代码时，我们为CLR使用和运行它做准备，CLR将负责其余部分，并在实际硬件上运行得很好就足够了。
- en: 'The code that runs on the CLR is what we call managed code. All other code
    (thus code not under the CLR’s control) is unmanaged. You will deal with managed
    code most of the time, but when writing system software, you’ll encounter unmanaged
    code quite frequently. But don’t worry: I will guide you through that!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLR上运行的代码就是我们所说的托管代码。所有其他代码（因此不在CLR控制下的代码）都是非托管的。您将大部分时间都在处理托管代码，但编写系统软件时，您会经常遇到非托管代码。但别担心：我会引导您通过这一过程！
- en: BCL
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BCL
- en: One of the goals the designers of .NET had in mind was to eliminate something
    developers called DLL Hell.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: .NET的设计者心中设定的一个目标就是消除开发者所说的DLL地狱。
- en: The idea was that, when writing software, developers quickly realized that writing
    the same code repeatedly would be tiresome and a nightmare to maintain. Instead,
    they created libraries with functions they could reuse. These libraries would
    be loaded on demand and linked to the calling code. That is where the name **Dynamic
    Link Library** (**DLL**) originated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，当编写软件时，开发者很快意识到反复编写相同的代码会感到乏味，并且难以维护。相反，他们创建了包含可重用函数的库。这些库将在需要时加载，并与调用代码链接。这就是**动态链接库**（**DLL**）这个名字的由来。
- en: Of course, developers, being developers, were not content with the DLLs they
    or someone else wrote earlier and made changes to them. These changes weren’t
    always backward compatible. That meant that as a user of a DLL, you had to make
    sure you used the correct version. You couldn’t easily upgrade without testing
    if that particular version of the DLL worked with your code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发者作为开发者，并不满足于他们或其他人之前写的DLL，并对它们进行了修改。这些修改并不总是向后兼容的。这意味着作为一个DLL的用户，你必须确保你使用了正确的版本。如果没有测试这个特定版本的DLL是否与你的代码兼容，你就不能轻易升级。
- en: There were two types of DLLs. One was proprietary to your code. You placed these
    DLLs in the same directory as your application, so all you needed to do was load
    the DLLs in your app directory. If a new application version came out, it came
    with its own set of DLLs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: DLL（动态链接库）有两种类型。一种专属于你的代码。你将这些DLL放在与你的应用程序相同的目录中，因此你只需要在你的应用程序目录中加载这些DLL。如果推出了新的应用程序版本，它将附带它自己的DLL集合。
- en: Since most of the DLLs didn’t change a lot (if they even changed at all) there
    were many repetitive and duplicate DLLs. So, instead of duplicating code, we were
    now duplicating DLLs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数DLL没有太多变化（如果它们甚至有所变化），因此有许多重复和重复的DLL。因此，我们不是在复制代码，而是在复制DLL。
- en: 'Fortunately, a solution was available: you could place DLLs in a shared space.
    On Windows, that was the `C:\Windows\System32` directory. The runtime knew that
    if it needed to load a DLL and couldn’t locate it in the `applications` directory,
    it could look at the `System32` directory and find it there.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方案：你可以将DLL放在共享空间中。在Windows上，那就是`C:\Windows\System32`目录。运行时知道，如果它需要加载一个DLL，但在`applications`目录中找不到它，它可以在`System32`目录中查找它。
- en: When doing this, you needed to be sure you maintained backward compatibility.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这件事的时候，你需要确保你保持了向后兼容性。
- en: Naturally, things went wrong. Updates would replace DLLs with newer, non-compatible
    versions. Sometimes, applications updated a DLL without realizing something else
    depended on it. Sometimes, an update would delete DLLs and thus break applications.
    In many cases, developers deployed the wrong versions. The list goes on and on.
    This caused many developers many frustrations and resulted in them calling this
    DLL Hell. Project 42 was set up to solve this. And in a way, it did.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，事情出了问题。更新会替换DLL为更新的、不兼容的版本。有时，应用程序更新DLL时没有意识到其他东西依赖于它。有时，更新会删除DLL，从而破坏应用程序。在许多情况下，开发者部署了错误的版本。问题层出不穷。这给许多开发者带来了许多挫折，并导致他们称之为DLL地狱。项目42被设立来解决这个问题。从某种意义上说，它确实做到了。
- en: 'A few decades ago, a `String` class was the first thing a new C++ programmer
    would write. C and C++ did not have such a thing: strings were not native to the
    language (they still aren’t, but the helper classes containing them are part of
    the standard now). A string can be pretty simple: it is just a pointer to a place
    in memory where all subsequent bytes form one long string. The string ends when
    the system sees a byte with a value of 0 (zero, not the character o). That’s it.
    A `String` class would contain the address of that array of bytes, some helper
    methods that allocate and clear the memory, and additional functions such as `Length()`.
    That’s it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，`String`类是新C++程序员会写的第一件事。C和C++没有这样的东西：字符串不是语言的原生部分（它们现在还不是，但现在包含它们的辅助类是标准的一部分）。字符串可以非常简单：它只是一个指向内存中某个位置的指针，所有后续的字节形成一个长字符串。字符串在系统看到值为0的字节时结束（零，不是字符o）。就是这样。`String`类将包含该字节数组的地址，一些分配和清除内存的辅助方法，以及如`Length()`这样的附加函数。就是这样。
- en: Soon, everybody wrote different versions, which would all be slightly different.
    .NET solved that by having a `String` class available. That class was part of
    a DLL that got shipped with the framework. The system registered that DLL, along
    with its version number. So, all developers needed to do was tell the system which
    version of the framework it was using, and by magic, things such as Strings were
    available. I am oversimplifying things here, but that is basically how things
    work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，每个人都编写了不同的版本，它们都会略有不同。.NET通过提供一个`String`类来解决这一问题。这个类是框架附带的一个DLL的一部分。系统注册了这个DLL及其版本号。因此，所有开发者需要做的只是告诉系统它正在使用哪个版本的框架，然后通过魔法，诸如字符串之类的功能就可用。我在这里简化了事情，但基本上就是这样工作的。
- en: There is a vast library that you can use as a .NET developer. You can see it
    in `C:\Windows\assembly`. If you use Windows Explorer, you’ll see a filtered view
    of the contents. You can see the actual contents using a terminal or command line.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET开发者，你可以使用一个庞大的库。你可以在`C:\Windows\assembly`中看到它。如果你使用Windows资源管理器，你会看到一个过滤后的内容视图。你可以使用终端或命令行查看实际内容。
- en: These DLLs are part of the BCL. The BCL is a set of helper classes, functions,
    methods, and enums that help you do your work. Instead of figuring out all the
    code yourself, it is part of the installation and ready to use.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DLL是BCL的一部分。BCL是一组辅助类、函数、方法和枚举，可以帮助你完成工作。你不需要自己弄清楚所有代码，它是安装的一部分，可以直接使用。
- en: 'The classes and other code constructs in the DLLs that form the BCL are organized
    into namespaces. The BCL contains lots of helpful code some of which are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 构成BCL的DLL中的类和其他代码结构被组织到命名空间中。BCL包含大量有用的代码，其中一些如下：
- en: '`System` namespace, which contains classes such as O`bject`, `String`, `Array`,
    and so on.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System`命名空间，其中包含`Object`、`String`、`Array`等类。'
- en: '`System.IO` namespace, for dealing with files, streams, and more.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO`命名空间，用于处理文件、流等。'
- en: '`System.Net` for dealing with networking.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net`用于处理网络。'
- en: '`System.Threading` for dealing with – you guessed it – multithreading.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading`用于处理——你猜对了——多线程。'
- en: '`System.Data` for dealing with data storage in databases and other ways of
    persisting data.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Data`用于处理数据库中的数据存储和其他持久化数据的方式。'
- en: '`System.Xml` here, which you can use to handle XML files and data.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Xml`在这里，你可以用它来处理XML文件和数据。'
- en: '`System.Diagnostics` helps you identify issues in your code. We will be diving
    into this one later.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics`帮助你识别代码中的问题。我们稍后会深入探讨这个问题。'
- en: '`System.Security` namespace, along with all things related to security and
    encryption.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Security`命名空间，以及所有与安全和加密相关的内容。'
- en: There are many more namespaces, but these are some of the most used ones. We
    will revisit them later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他命名空间，但这些都是最常用的几个。我们稍后会重新访问它们。
- en: However, remember that these classes are there to help you. They wrap complicated
    and extensive code in good ways for most developers. However, If you find that
    the BCL code doesn’t get you where you want to be, nothing is stopping you from
    writing the code yourself. As we saw earlier, the BCL code is awesome if you want
    to set up a TCP/IP connection, but if you want to use an infrared connection instead,
    you must do it yourself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，这些类是为了帮助你。它们以良好的方式封装了复杂和广泛的代码，对大多数开发者来说都是如此。但是，如果你发现BCL代码无法让你达到想要的目标，没有任何阻止你亲自编写代码。正如我们之前看到的，如果你想要设置TCP/IP连接，BCL代码是出色的，但如果你想要使用红外连接，你必须自己完成。
- en: The good news is that you can mix and match. Use the BCL where you can and low-level
    APIs where you need to.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是你可以混合使用。在可能的地方使用BCL，在需要的地方使用低级API。
- en: Using P/Invoke to call low-level APIs
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用P/Invoke调用低级API
- en: We have established that .NET gives you many tools to develop something quickly.
    It also helps you out by shielding you from the low-level details of the underlying
    operating system. But it also allows you to use low-level APIs if you need to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定.NET为你提供了许多快速开发工具。它还通过屏蔽底层操作系统的低级细节来帮助你。但它也允许你在需要时使用低级API。
- en: But how can we access those APIs? The answer is **Platform Invocation**, or
    (**P/Invoke**). We can use this tool to access the Win32 API directly. P/Invoke
    bridges the gap between the two platforms so that we can mix and match to our
    hearts’ content.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何访问这些API呢？答案是**平台调用**，或（**P/Invoke**）。我们可以使用这个工具直接访问Win32 API。P/Invoke在两个平台之间架起桥梁，这样我们就可以随心所欲地混合使用。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Win32 is the name of the SDK and the APIs made available. There is no such thing
    as a Win64 API. Our code is compiled against 64-bit Windows if you run that platform,
    yet we (and Microsoft) still call it the Win32 API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Win32是这个SDK和可用的API的名称。没有Win64 API这样的东西。如果你在64位Windows平台上运行代码，我们的代码是针对64位Windows编译的，但我们（以及微软）仍然称之为Win32
    API。
- en: How does P/Invoke work?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: P/Invoke是如何工作的？
- en: 'P/Invoke involves a couple of steps. These are the steps you must follow to
    use a Win32 API in a .NET application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: P/Invoke涉及几个步骤。这些是你必须遵循的步骤，以便在.NET应用程序中使用Win32 API：
- en: Find the API you want to use.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你想要使用的API。
- en: Find the DLL the API resides in.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到API所在的DLL。
- en: Load that DLL in your assembly.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的程序集加载该DLL。
- en: Declare a stub that tells your application how to call that API.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个存根，告诉你的应用程序如何调用该API。
- en: Convert the .NET data types into something the Win32 API can understand.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将.NET数据类型转换为Win32 API可以理解的形式。
- en: Use the API.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用API。
- en: Warning!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！
- en: 'You are out of the loving and caring hands of .NET Framework and the CLR. You
    are no longer protected against mistakes. You are in an unmanaged world now. In
    the old days, they probably would have marked this part of the documentation with
    the warning “Here be dragons.” You are now responsible for many more things than
    you might be used to, such as memory management and error handling. You have more
    power over the system now, but remember: great power comes with great responsibility!'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经离开了.NET Framework和CLR的关爱之手。你不再受到错误的保护。你现在处于一个非托管的世界。在旧时代，他们可能会在这个文档的部分标记上警告“此处有龙”。你现在需要负责比以往更多的事情，比如内存管理和错误处理。你现在对系统的控制力更强，但请记住：大权在握伴随着巨大的责任！
- en: Let me start with an example. This showcases the power of .NET Framework, but
    it also shows how the aforementioned steps work in practice. We are going to do
    a simple “Hello World.”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从一个例子开始。这展示了.NET Framework的强大功能，但也展示了之前提到的步骤在实际中是如何工作的。我们将进行一个简单的“Hello World”。
- en: 'To make sure we’re on the same page, let me show you the .NET version of this
    program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们处于同一页面上，让我给你展示这个程序的.NET版本：
- en: '`Console.WriteLine(“Hello,` `System Programmers!”);`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine(“Hello,` `System Programmers!”);`'
- en: Yes, this is the same sample we saw earlier. Hey, we have to start somewhere,
    right?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是我们之前看到的同一个示例。嘿，我们必须从某个地方开始，对吧？
- en: Now, `Console` is a class from the BCL. It has a static method, `WriteLine`,
    that outputs that string to the output. But what if we assume we don’t want to
    use that class? How should we go about this then? To frame this question another
    way, how does `WriteLine` work internally? After all, there has to be a point
    somewhere during execution where the code has to call the Win32 API. That can
    be done by the CLR or by us, but something or someone has to call it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Console`是BCL中的一个类。它有一个静态方法`WriteLine`，可以将字符串输出到输出。但如果我们假设我们不想使用这个类呢？那么我们应该如何处理这个问题？换一种方式来提出这个问题，`WriteLine`是如何在内部工作的？毕竟，在执行过程中，代码必须调用Win32
    API。这可以通过CLR或我们来实现，但必须有人或某物来调用它。
- en: 'Let’s rewrite the code using P/Invoke. I will show you the entire program first,
    then dissect it and explain how it works line by line:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用P/Invoke重写代码。我会先展示整个程序，然后逐行剖析并解释它是如何工作的：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s a lot of code, but let’s go through it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多，但让我们逐行分析。
- en: In *line 1*, we import the namespace that allows us to use P/Invoke. .NET uses
    the name `InteropServices` for this, so it makes sense to import that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1行*，我们导入了一个命名空间，它允许我们使用P/Invoke。.NET使用`InteropServices`这个名字，所以导入它是合理的。
- en: In *line 3*, we see the magic happening. Remember the steps we have to take?
    *Step 1* is to “Find the API you want to use.” Since we want to print something
    on the screen, the `WriteConsole` API sounds like a good fit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3行*，我们看到魔法发生了。还记得我们必须采取的步骤吗？*步骤1*是“找到你想要使用的API”。由于我们想在屏幕上打印一些东西，`WriteConsole`
    API听起来像是一个不错的选择。
- en: The official documentation from Microsoft states that the `WriteConsole` API
    “*Writes a character string to a console screen buffer beginning at the current
    cursor location.*” That sounds good to me.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的官方文档指出，`WriteConsole` API“*从当前光标位置开始将字符字符串写入控制台屏幕缓冲区。*”这听起来不错。
- en: 'The documentation then gives us the signature of this API:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 文档接着给出了这个API的签名：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re a .NET developer, this might look weird. A lot is going on that we
    don’t know about or understand. We need to translate those types into something
    the CLR understands. Luckily, somebody has already figured that out for us. To
    make life even easier, they did *Steps 2* (find the DLL) and *4* (declare the
    stub) for us as well. Given the correct parameters, the CLR takes care of *Step
    3* (load the DLL).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 .NET 开发者，这可能会看起来很奇怪。有很多我们不知道或理解的事情在发生。我们需要将这些类型转换为 CLR 能够理解的东西。幸运的是，有人已经为我们解决了这个问题。为了使生活更加简单，他们还为我们做了
    *步骤 2*（找到 DLL）和 *步骤 4*（声明存根）。给定正确的参数，CLR 会处理 *步骤 3*（加载 DLL）。
- en: That “someone who figured this out” is the people behind [https://pinvoke.net](https://pinvoke.net).
    You can search for APIs and learn how to use them there.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: “弄清楚这一点的人”是 [https://pinvoke.net](https://pinvoke.net) 背后的人。你可以在那里搜索 API 并学习如何使用它们。
- en: The official documentation has a part called `Kernel32.dll` (`Pinvoke.Net` also
    gives you that information).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档有一个名为 `Kernel32.dll` 的部分（`Pinvoke.Net` 也提供了这个信息）。
- en: '*Line 3* is what tells `InteropServices` to load the DLL. Let’s dive into that:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3行* 是告诉 `InteropServices` 加载 DLL 的部分。让我们深入探讨一下：'
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line tells the CLR to load `kernel32.dll`. It then specifies how to handle
    characters. Characters and strings can be complicated. There are several different
    ways to represent a single character. It can be an ASCII character, it can be
    Unicode, or it can be ANSI. They all have a different representation in memory.
    Here, we say we want to use `Auto`. When doing that, the system looks at the complete
    string we use, finds out which set it can use to represent the complete string,
    and uses the first one it can find. Since it starts by trying to fit it in an
    ASCII string and then “moves up” toward more complicated, slower, and more memory-intensive
    ways, this guarantees we get the best way to represent this string.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉 CLR 加载 `kernel32.dll`。然后指定如何处理字符。字符和字符串可能很复杂。表示单个字符有几种不同的方式。它可以是一个 ASCII
    字符，也可以是 Unicode，或者可以是 ANSI。它们在内存中都有不同的表示形式。在这里，我们说我们想要使用 `Auto`。当这样做时，系统会查看我们使用的完整字符串，找出它可以用来表示完整字符串的集合，并使用它找到的第一个。由于它首先尝试将其适应到
    ASCII 字符串中，然后“向上移动”到更复杂、更慢、更占用内存的方式，这保证了我们得到表示这个字符串的最佳方式。
- en: Next, we can see `SetLastError = true`. This instructs the system to inform
    us whenever something goes wrong. In case of an error, it calls the `GetLastError`
    API to get the error and return it to us. We will use this a lot later. For now,
    I advise you to always set `SetLastError` to `true`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到 `SetLastError = true`。这指示系统在发生错误时通知我们。在出现错误的情况下，它调用 `GetLastError`
    API 来获取错误并将其返回给我们。我们将在以后大量使用这个。现在，我建议你始终将 `SetLastError` 设置为 `true`。
- en: 'Our runtime now knows to load `kernel32.dll`. But we must tell it what specific
    API we want to use. That happens in the following line. The function’s signature
    must always follow that `DllImport` directly: they always belong together. If
    you want to load multiple functions from the same Dll, you must still use `DllImport`
    for each.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行时现在知道要加载 `kernel32.dll`。但我们必须告诉它我们想要使用哪个特定的 API。这发生在下一行。函数的签名必须始终紧跟在 `DllImport`
    之后：它们总是属于一起。如果你想要从同一个 DLL 加载多个函数，你仍然必须为每个函数使用 `DllImport`。
- en: 'The following line is the stub for the function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是函数的存根：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This looks like the code we saw from the official documentation, but now, the
    types have been translated into their .NET equivalents. Again, `Pinvoke.Net` is
    your friend here!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像我们从官方文档中看到的代码，但现在，类型已经被转换成了它们的 .NET 等价物。再次强调，`Pinvoke.Net` 是你的好朋友！
- en: 'The parameters are more or less self-explanatory, except for the first one.
    Let’s skip that one and look at the others:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 参数基本上是自我解释的，除了第一个。让我们跳过那个，看看其他的：
- en: '| **String lpBuffer** | **The string we want** **to print** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **String lpBuffer** | **我们想要打印的字符串** |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| nNumberOfCharsToWrite | The number of characters we want to print from the
    given string |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| nNumberOfCharsToWrite | 我们想要从给定字符串中打印的字符数 |'
- en: '| lpNumberOfCharsWritten | How many characters were written to the system |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| lpNumberOfCharsWritten | 写入系统的字符数 |'
- en: '| lpReserved | This isn’t used, so it can be ignored |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| lpReserved | 这个参数没有被使用，所以可以忽略 |'
- en: 'Table 1.1: Parameters for WriteConsole'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1：WriteConsole 的参数
- en: 'One thing to notice here is that Win32 APIs use the Hungarian notation for
    their parameters. This style says you have to prefix every parameter with an abbreviation
    of the type so that when you read the code later, you know what type this stands
    for. In the days before the current modern and fast IDEs, this helped a lot: you
    couldn’t hover your mouse over a variable to see what type it was; you had to
    scroll through the code to find the declaration. By prefixing it, you could see
    it immediately. These days, we don’t need to do that anymore, but C and C++ developers
    still use this standard.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，Win32 API 使用匈牙利命名法为其参数命名。这种风格规定你必须使用类型的缩写前缀来修饰每个参数，这样当你以后阅读代码时，就能知道这个参数代表什么类型。在当前现代和快速的
    IDE 出现之前，这非常有帮助：你不能将鼠标悬停在变量上以查看其类型；你必须滚动代码以找到其声明。通过前缀，你可以立即看到它。如今，我们不再需要这样做，但
    C 和 C++ 开发者仍然使用这个标准。
- en: So, as you can see, the string to print is a long pointer (lp), and the number
    of characters to write is a number (n).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，要打印的字符串是一个长指针（lp），要写入的字符数是一个数字（n）。
- en: But let’s have a look at `hConsoleOutput`. It is a handle (it starts with h),
    which translates it into `IntPtr` in .NET.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看 `hConsoleOutput`。它是一个句柄（以 h 开头），在 .NET 中将其转换为 `IntPtr`。
- en: A pointer is just an address of something in memory. In our case, this memory
    belongs to the place where the console is. But how do we get that? Where is the
    code that controls `Console`, which is located in memory?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 指针只是内存中某个东西的地址。在我们的例子中，这个内存属于控制台所在的位置。但我们如何获取它？控制 `Console` 的代码在哪里？
- en: The answer is that we don’t know. There is no fixed place; this can and will
    change every time you restart your program. So, we need to look for it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，我们不知道。没有固定的位置；这可以，并且每次你重启程序时都会改变。因此，我们需要去寻找它。
- en: 'Luckily, that isn’t that hard to do as there’s an API we can use to do so.
    This API is called `GetStdHandle` and it lives in `kernel32.dll`. We know how
    to import that, and we can see it in our code on *lines 11* and *12*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不难做，因为有一个我们可以使用的 API 来完成这个任务。这个 API 被称为 `GetStdHandle`，它位于 `kernel32.dll`
    中。我们知道如何导入它，我们可以在我们的代码的第 *11* 和 *12* 行中看到它：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are no strings, so we don’t need to set `CharSet`. However, we do need
    to set `SetLastError`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 没有字符串，所以我们不需要设置 `CharSet`。然而，我们需要设置 `SetLastError`。
- en: 'The method to find the address is called `GetStdHandle`, and it takes one parameter:
    `nStdHandle`. This tells this API what type of Console we are looking for. There
    are three types available: `STD_INPUT_HANDLE, STD_OUTPUT_HANDLE`, and `STD_ERROR_HANDLE`.
    These three constants have -10, -11, and -12 as values, respectively. You’re right
    if you think it’s strange that they’re negative values. It’s weird. However, in
    Win32, these values are unsigned. They are the end of the integer range, so they
    don’t get in the way of any other types of console you might define yourself.
    Casting a high value of an unsigned int to a signed int results in a negative
    value.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查找地址的方法被称为 `GetStdHandle`，它接受一个参数：`nStdHandle`。这告诉此 API 我们正在寻找哪种类型的控制台。有三种类型可供选择：`STD_INPUT_HANDLE,
    STD_OUTPUT_HANDLE` 和 `STD_ERROR_HANDLE`。这三个常量的值分别为 -10、-11 和 -12。如果你认为它们是负值很奇怪，那么你是正确的。这很奇怪。然而，在
    Win32 中，这些值是无符号的。它们是整数范围的终点，因此不会妨碍你定义的其他任何类型的控制台。将无符号整型的高值转换为有符号整型会导致负值。
- en: 'On *line 14*, we define the `STD_OUTPUT_HANDLE` constant and give it a value
    of `-11`. This sort of thing is common: the Win32 API is a mess with magic numbers
    and constants.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 14 行*，我们定义了 `STD_OUTPUT_HANDLE` 常量，并给它赋值为 `-11`。这类事情很常见：Win32 API 中充满了魔法数字和常量。
- en: On *line 16*, we use `GetStdHandle` to get the pointer to `Console` in memory,
    giving it `STD_OUTPUT_HANDLE`. If that goes wrong, we get a 0 (zero) back. But
    since .NET is strongly typed, we cannot use that number. Instead, we have to use
    the `IntPtr.Zero` constant, which is the same thing but in the correct type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 16 行*，我们使用 `GetStdHandle` 来获取内存中 `Console` 的指针，并给它传递 `STD_OUTPUT_HANDLE`。如果出错，我们会得到一个
    0（零）。但由于 .NET 是强类型的，我们不能使用这个数字。相反，我们必须使用 `IntPtr.Zero` 常量，它在正确的类型中做同样的事情。
- en: Every time you get a 0 back from a Win32 API, you have an error situation going
    on. We need to deal with that, but that is a topic for later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从 Win32 API 获取一个 0，都表示存在错误情况。我们需要处理这种情况，但这将是后续讨论的主题。
- en: Assuming all goes well, we can define our string, and the `out` variable tells
    us how many characters are written (*lines 23* and *24*).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，我们可以定义我们的字符串，`out` 变量会告诉我们写入了多少个字符（*第 23* 和 *24* 行）。
- en: 'Then, on *line 26*, we call the actual API:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 *第 26 行*，我们调用实际的 API：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This should be clear now. We call the API, give it the correct parameters, and
    check if the result is `0` (`IntPtr.Zero`).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚了。我们调用API，给它正确的参数，并检查结果是否为`0`（`IntPtr.Zero`）。
- en: The CLR converts the complex .NET `String` type into a simple array of bytes
    with a 0 at the end. We don’t have to worry about that. We can give this API a
    C# string and everything will work out fine.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: CLR将复杂的.NET `String`类型转换为以0结尾的简单字节数组。我们不必担心这一点。我们可以给这个API提供一个C#字符串，一切都会顺利。
- en: And that’s it. We have written something to the console using Win32 APIs!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经使用Win32 API向控制台写入了一些内容！
- en: Dealing with errors
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: In the previous examples, we did a little bit of error checking. If we couldn’t
    get the handle, we showed a message. We did the same thing if we couldn’t write
    to the console. I realize it’s funny to write to the console that the system cannot
    write to it (look at *line 33*, for instance), but you get what I mean here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们做了一些错误检查。如果我们无法获取句柄，我们会显示一个消息。如果我们无法写入控制台，我们也会这样做。我明白写入无法写入的系统控制台听起来很滑稽（例如，看看*第33行*），但你应该明白我的意思。
- en: But this isn’t good enough if you want to know what’s going on for real. We
    need a more thorough way of handling errors.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想知道真正的情况，这还不够。我们需要一种更彻底的方式来处理错误。
- en: In .NET, we are used to getting exceptions whenever things go wrong. We know
    how to deal with that. In the low-level world, things are different. When something
    goes wrong, we get `0` back, and we’re left to deal with it. We could continue
    with the code without being bothered by the error. We could even ignore the results
    of a call to an API. However, that would lead to disaster. You should always check
    and deal with the results of an API call. How to deal with that is something we
    discuss in this section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，我们习惯于在出现问题时获取异常。我们知道如何处理它。在低级世界中，事情有所不同。当出现问题时，我们会得到`0`，然后我们必须处理它。我们可以继续编写代码而不会被错误打扰。我们甚至可以忽略API调用的结果。然而，这将导致灾难。你应该始终检查并处理API调用的结果。如何处理这个问题是我们将在本节中讨论的内容。
- en: 'There is a low-level API called `GetLastError` that can help us out here. The
    signature for P/Invoke is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`GetLastError`的低级API可以帮助我们。P/Invoke的签名如下：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It seems pretty straightforward. There are no parameters to worry about, and
    we don’t have to set that `SetLastError` value here. Since `SetLastError` ensures
    that any error is saved in the registry so that `GetLastError` can read it, there’s
    no value in having that here. If there would be, and we set it to false, then
    how does `GetLastError` work?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简单。没有需要担心的参数，我们也不必在这里设置那个`SetLastError`值。由于`SetLastError`确保任何错误都保存在注册表中，以便`GetLastError`可以读取它，所以在这里设置它没有意义。如果设置了，并且将其设置为false，那么`GetLastError`将如何工作呢？
- en: This function returns an unsigned integer. This number corresponds with an error;
    you can look up what that number means in the documentation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个无符号整数。这个数字对应一个错误；你可以在文档中查找这个数字的含义。
- en: 'But there’s an issue: it doesn’t work. Well, it does, but there are no guarantees
    regarding the result.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有个问题：它不起作用。嗯，它确实起作用，但结果没有保证。
- en: 'The BCL and the `CLR` work with the low-level Win32 APIs constantly. That is
    obvious: the BCL is a wrapper around the Win32 API, and the CLR uses that wrapper
    to call into the core system of the operating system. We can call the APIs ourselves,
    as we have just done, but the CLR also calls it. Sometimes, it does it in the
    same thread. Other times, it calls it on another thread. Things can also go wrong
    during the CLR calls to the APIs. That results in `GetLastError` possibly returning
    no errors or the wrong errors. Well, technically, they aren’t the wrong errors,
    but they might not have to do anything with what we’re doing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: BCL和`CLR`始终与低级Win32 API一起工作。这是显而易见的：BCL是Win32 API的包装器，CLR使用这个包装器调用操作系统的核心系统。我们可以自己调用API，就像我们刚才做的那样，但CLR也会调用它。有时，它在同一个线程上调用。有时，它在另一个线程上调用。在CLR调用API的过程中也可能出错。这可能导致`GetLastError`返回没有错误或错误的错误。嗯，技术上，它们不是错误的错误，但它们可能与我们正在做的事情无关。
- en: Luckily, the designers of .NET have thought about that and have added a class
    called `Marshal` to the `System.Runtime.InteropServices` namespace. That class
    is used to marshal between managed and unmanaged code – or, to put it in the context
    of what we are doing here, between Win32 APIs and our C# .NET code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，.NET 的设计者考虑到了这一点，并在 `System.Runtime.InteropServices` 命名空间中添加了一个名为 `Marshal`
    的类。该类用于在托管和非托管代码之间进行封送处理——或者，用我们在这里所做的事情来说，就是在 Win32 API 和我们的 C# .NET 代码之间。
- en: Let’s assume we made a mistake. I know that’s hard to imagine but bear with
    me here. Instead of assigning `-11` to `STD_OUTPUT_HANDLE`, we set it to `11`.
    We all make mistakes, right?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们犯了一个错误。我知道这很难想象，但请在这里忍受一下。我们不是将 `-11` 分配给 `STD_OUTPUT_HANDLE`，而是将其设置为
    `11`。我们都会犯错误，对吧？
- en: 'We then call `GetStdHandle` with `11`. That isn’t correct; we know that. The
    documentation says that the function returns `0` (or `IntPtr.Zero` in C#) if anything
    goes wrong. But in our case, it returns something else: `0xffffffffffffffff`.
    This is the unsigned version of the signed value, `-1`. In other words, the call
    to the API returns `-1`, which is not a valid handle.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用 `GetStdHandle` 并传入 `11`。这是不正确的；我们都知道这一点。文档说明，如果发生任何错误，该函数返回 `0`（或在 C#
    中为 `IntPtr.Zero`）。但在我们的情况下，它返回了其他东西：`0xffffffffffffffff`。这是有符号值 `-1` 的无符号版本。换句话说，对
    API 的调用返回 `-1`，这不是一个有效的句柄。
- en: 'However, we don’t check that. We only check for the `0` value. This makes sense
    if you think about it. After all, `0` indicates something went wrong when calling
    that function. That didn’t happen: the function worked flawlessly. It just didn’t
    find anything matching the ID we gave it (`11` instead of `-11`). So, as far as
    the API is concerned, there are no errors.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有检查这一点。我们只检查 `0` 值。如果你这样想，这是有道理的。毕竟，`0` 表示在调用该函数时出了问题。这种情况没有发生：该函数工作得完美无缺。它只是没有找到与我们所提供的
    ID 匹配的内容（`11` 而不是 `-11`）。所以，从 API 的角度来看，没有错误。
- en: But then we get to the point where we call `WriteConsole`. We give it the handle
    of the console – or rather, we think we do. Instead, we give it a value of `-1`
    (`0xffffffffffffffff`). That is not a valid handle that `WriteConsole` can work
    with.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们来到了调用 `WriteConsole` 的地方。我们给它传递控制台的句柄——或者更确切地说，我们认为我们这样做。相反，我们传递了一个值为 `-1`（`0xffffffffffffffff`）。这不是
    `WriteConsole` 可以处理的有效的句柄。
- en: In .NET you would get an exception, but that doesn’t happen here. The code continues
    happily without complaining. It just doesn’t output anything.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，你会得到一个异常，但这里没有发生这种情况。代码继续愉快地运行，没有任何抱怨。它只是没有输出任何内容。
- en: 'These errors can be a pain to find and solve. In this case, it is quite straightforward,
    but imagine a situation where you try to set up a connection to an infrared receiver
    and something goes wrong. However, we keep going since we don’t check for that
    result. By the time we are ready to send data, nothing happens – or worse, the
    system crashes. We start to look at the code that does the actual sending, but
    nothing is wrong there. It takes much time and careful debugging to see that the
    error happens when we set up the connection. Let me repeat something I said earlier:
    you should always check the results of all API calls. That burden is on you. The
    .NET runtime generates exceptions in these cases, but if you are in unmanaged
    land, you are responsible for doing so.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误可能很难找到和解决。在这种情况下，它相当直接，但想象一下，当你尝试设置与红外接收器的连接并且出了问题的情况。然而，我们继续进行，因为我们没有检查那个结果。当我们准备发送数据时，什么也没有发生——或者更糟，系统崩溃了。我们开始查看实际发送数据的代码，但那里没有问题。需要花费很多时间和仔细的调试才能看到错误发生在我们设置连接时。让我重复一下我之前说过的话：你应该始终检查所有
    API 调用的结果。这个责任在你身上。.NET 运行时在这些情况下生成异常，但如果你处于非托管环境中，你必须负责这样做。
- en: Let’s improve our code a bit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进一下我们的代码。
- en: First, we’ll wrap our call to `WriteConsole` in a `try-catch` block and just
    catch `Exception`, although that is generally a bad idea. However, here, this
    is good enough.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们的 `WriteConsole` 调用包裹在一个 `try-catch` 块中，并捕获 `Exception`，尽管这通常是一个糟糕的想法。然而，在这里，这已经足够好了。
- en: 'If `WriteConsole` returns `IntPtr.Zero`, we have a problem and something goes
    wrong. In an unmanaged environment, you would call `GetLastError` to see what
    happens, but that doesn’t work here. Instead, we use that `Marshal` class I spoke
    about earlier:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `WriteConsole` 返回 `IntPtr.Zero`，我们就遇到了问题，并且出了错。在非托管环境中，你会调用 `GetLastError`
    来查看发生了什么，但在这里不起作用。相反，我们使用我之前提到的那个 `Marshal` 类：
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When running this with `STD_OUTPUT_HANDLE` set to `11`, the system reports that
    something went wrong. It even tells us that the error code is `6`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`STD_OUTPUT_HANDLE`设置为`11`时运行此代码，系统会报告出错了。它甚至告诉我们错误代码是`6`。
- en: 'Looking this up in the official documentation results in the following information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方文档中查找这个信息，结果如下：
- en: ERROR_INVALID_HANDLE
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ERROR_INVALID_HANDLE
- en: 6 (0x6)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 6 (0x6)
- en: The handle is invalid.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个句柄是无效的。
- en: This is precisely what’s going on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是正在发生的事情。
- en: “Wait a minute,” I can almost hear you say. “I can’t ask my users to look up
    the official documentation to see what an error message means every time something
    goes wrong!”
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，”我几乎能听到你这么说。“我不能要求我的用户每次出问题时都去查阅官方文档来查看错误消息的含义！”
- en: Well, you’ve got a point there. And the .NET design team agrees. They’ve added
    some ways to get that error message. There are two ways to get it, and you can
    choose which one you want.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你说的没错。.NET设计团队也同意这一点。他们增加了一些获取错误消息的方法。有两种方法可以获取它，你可以选择你想要的任意一种。
- en: 'First, if you want to have that error message, you can get it with the following
    code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你想获取那个错误消息，你可以用以下代码来获取：
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, we start by getting the error code. We always have to do this, and we
    should do it as quickly as possible before another error somewhere else messes
    things up.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先获取错误代码。我们总是必须这样做，而且我们应该尽可能快地这样做，以免其他地方的另一个错误破坏了事情。
- en: Then, we call the `Marshal.GetPInvokeErrorMessage` method and give it that `lastError`
    code. It returns a string telling us `The handle` `is invalid.`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`Marshal.GetPInvokeErrorMessage`方法，并给它那个`lastError`代码。它返回一个字符串告诉我们`The
    handle` `is invalid.`。
- en: 'Nice. But what if this error is so impactful that we cannot continue? .NET
    tells us to use exceptions in those cases. Good practice teaches us never to throw
    an exception but to use a specialized derived exception. We have just the right
    thing for that: `Win32Exception`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。但如果这个错误的影响如此之大以至于我们无法继续呢？.NET告诉我们在这种情况下使用异常。良好的实践教导我们永远不要抛出异常，而应该使用一个专门的派生异常。我们正好有这样一个东西：`Win32Exception`。
- en: 'We could throw that and set the message to the message we got from `GetPInvokeErrorMessage`,
    but since that is such a common scenario, .NET Framework gives us a shortcut to
    do just so. Look at the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个错误消息抛出，并将消息设置为从`GetPInvokeErrorMessage`获取的消息，但鉴于这是一个非常常见的场景，.NET Framework为我们提供了一个快捷方式来做这件事。看看下面的代码：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This looks a lot better. This code results in a message on our screen stating
    `Error: The handle is invalid`. Okay, since this is just a simple example, I fail
    to properly deal with the issue (a rethrow would be a good idea here). How you
    continue after such an error depends on your coding style, your use case, and
    what you want to achieve.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '这看起来要好得多。这段代码会在我们的屏幕上显示一条消息，内容为`Error: The handle is invalid`。好吧，既然这只是一个简单的例子，我未能正确处理这个问题（在这里重新抛出是个好主意）。在出现此类错误后如何继续取决于你的编码风格、用例以及你想要达到的目标。'
- en: 'There is one other way to get the error message. This one is quite nice but
    not as straightforward as the others we’ve discussed: `FormatMessage`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 获取错误消息还有另一种方法。这个方法相当不错，但不如我们之前讨论的其他方法直接：`FormatMessage`。
- en: 'The `FormatMessage` function comes from the Win32 API. Its declaration is as
    follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormatMessage`函数来自Win32 API。其声明如下：'
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we have an error code, we can use it as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有错误代码，我们可以这样使用它：
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we create `StringBuilder`. The API uses this to build up the string
    with the error message. We give it a size of `256` characters. This size should
    be enough for most, if not all, errors. We need to give this size since in C and
    C++, you need to allocate a buffer beforehand; it cannot expand dynamically (well,
    it could, but you wouldn’t do that if you want high performance). We call `FormatMessage`
    with the 0x00001000 flag. This flag means “use the error code provided.” We can
    use other flags, but this one is used most of the time. We don’t have a message
    we want to format, so the second parameter is `IntPtr.Zero`. Then, we give it
    `lastError`, 0 for the language (that is, the system default, usually English),
    the buffer, the size of the buffer, and another `IntPtr.Zero` parameter. This
    last one means we don’t use arguments. Here, arguments are the same as what we
    have in C# when we want to format a string:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`StringBuilder`。API使用它来构建带有错误消息的字符串。我们给它分配了`256`个字符的大小。这个大小对于大多数，如果不是所有错误来说应该足够了。我们需要给出这个大小，因为在C和C++中，你需要事先分配一个缓冲区；它不能动态扩展（嗯，它可以，但如果你想要高性能，你不会这样做）。我们使用0x00001000标志调用`FormatMessage`。这个标志意味着“使用提供的错误代码。”我们可以使用其他标志，但这个标志是最常用的。我们没有想要格式化的消息，所以第二个参数是`IntPtr.Zero`。然后，我们给它`lastError`，语言为0（即系统默认，通常是英语），缓冲区，缓冲区的大小，以及另一个`IntPtr.Zero`参数。最后一个参数意味着我们不使用参数。在这里，参数与我们在C#中想要格式化字符串时的参数相同：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `42` is the argument.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`42`是参数。
- en: We get that same “The handle is invalid” message when we run this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们会得到相同的“句柄无效”消息。
- en: You might want to use this API because it can do some nice tricks. For instance,
    replace `languageId` code 0 with the code 0x0413\. This `languageId` is the Windows
    language ID for Dutch (please use whatever language you want.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用这个API，因为它可以做一些很酷的技巧。例如，将`languageId`代码0替换为代码0x0413。这个`languageId`是荷兰的Windows语言ID（请使用你想要的任何语言。）
- en: The result is `De ingang is ongeldig`, which is more or less a good translation
    of the original error.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`De ingang is ongeldig`，这基本上是对原始错误的良好翻译。
- en: This way, you can have nicely formatted, translated error messages!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以有格式良好、翻译过的错误消息！
- en: 'There’s one last thing to cover here: many samples online use the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有最后一件事要说明：许多在线示例使用以下代码：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Technically, there’s nothing wrong with this. But this isn’t why exceptions
    are there. Creating one just to get the message is wrong. However, I have seen
    this so many times that I thought I should warn you against it. If you don’t want
    to throw an exception, don’t create one. In that case, call `Marshal.GetPInvokeErrorMessage`
    instead. You will do yourself and those maintaining your code a huge favor.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这并没有什么问题。但这并不是异常存在的原因。仅仅为了得到消息就创建一个异常是错误的。然而，我见过这种情况很多次，所以我认为我应该警告你。如果你不想抛出异常，就不要创建它。在这种情况下，调用`Marshal.GetPInvokeErrorMessage`代替。这将对你和那些维护你的代码的人大有裨益。
- en: Issues when debugging code with low-level APIs
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用低级API调试代码时的问题
- en: Working with low-level APIs such as the Win32 API opens up a treasure trove
    of new and powerful tools. However, it comes with a couple of downsides. Debugging
    your code suddenly gets a lot harder, and it also becomes more critical.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如Win32 API这样的低级API可以打开一个充满新且强大工具的宝库。然而，这也带来了一些缺点。调试你的代码突然变得困难得多，而且它也变得更加关键。
- en: 'There are a couple of areas you need to be aware of when you want to debug
    your code using low-level APIs:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用低级API调试代码时，有几个区域你需要注意：
- en: Error handling
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Interoperability
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互操作性
- en: Debugging tools
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具
- en: Compatibility and portability
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性和可移植性
- en: Documentation and community support
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档和社区支持
- en: Each of these can pose a challenge, requiring you to think about your debugging
    strategy before you start coding. Let’s go through the potential issues.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可能构成挑战，要求你在开始编码之前考虑你的调试策略。让我们看看潜在的问题。
- en: Error handling
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: As mentioned previously, you’re responsible for error handling when using low-level
    APIs. You don’t get exceptions from the functions you call when something goes
    wrong. You always have to be careful to check the return code of the calling code
    to see if it is 0\. And even then, there is no guarantee that things work out
    as you expected. For instance, the call to `GetStdHandle` worked fine when we
    gave it an invalid type of `ConsoleId`, but the result was still not what we expected.
    You have to be very careful with these kinds of calls. Ideally, we would have
    caught that problem immediately and informed the system that something went wrong.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用低级API时，错误处理由你负责。当调用函数出错时，你不会从函数中得到异常。你必须始终小心地检查调用代码的返回码，看它是否为0。即使如此，也不能保证事情会按照你预期的方向发展。例如，当我们给`GetStdHandle`函数一个无效的`ConsoleId`类型时，调用是正常的，但结果仍然不是我们预期的。你必须对这些类型的调用非常小心。理想情况下，我们会立即捕捉到这个问题，并通知系统出现了错误。
- en: Even if you catch all the error codes, that doesn’t mean you can identify what
    went wrong. Sometimes, the error messages are so cryptic that you must read the
    documentation to see what’s happening.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你捕捉到了所有的错误代码，这也并不意味着你可以确定发生了什么错误。有时，错误信息如此晦涩，你必须阅读文档才能了解发生了什么。
- en: There is a method in the API called `CoCreateInstance`. It deals with creating
    COM objects, which you use to connect to other systems, such as Word or Excel.
    To make that connection, give it the ID of the object you want to connect to.
    Those IDs are in the form of GUIDs, and you have to type them in. If there ever
    were a situation where it is easy to get things wrong, this would be it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: API中有一个名为`CoCreateInstance`的方法。它用于创建COM对象，这些对象用于连接到其他系统，例如Word或Excel。为了建立这种连接，给它你想要连接的对象的ID。这些ID的形式是GUID，你必须手动输入。如果曾经有过容易出错的情况，那可能就是这种情况。
- en: Using a non-existing `ClassID` returns an error code of `0x80004005`. If we
    use the methods described previously to get the error message, you would expect
    to read something like `Invalid ClassId` or `COM Object not found`. Unfortunately,
    what you get is `E_FAIL:` `Unspecified error`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不存在的`ClassID`会返回错误代码`0x80004005`。如果我们使用之前描述的方法来获取错误信息，你可能会读到类似`Invalid ClassId`或`COM对象未找到`的内容。不幸的是，你得到的是`E_FAIL:`
    `未指定错误`。
- en: Sigh.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 唉。
- en: That isn’t helpful at all, is it? It failed. Okay, we got that. But why? What
    failed? We don’t know. The system doesn’t help you here at all. You have to know
    what you’re doing and what the system expects and go through every single line
    of the code to spot the error. That’s not easy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全无助于解决问题，对吧？失败了。好吧，我们知道了。但是为什么？是什么失败了？我们不知道。系统在这里根本不帮助你。你必须知道你在做什么，系统期望什么，并且逐行检查代码以找出错误。这并不容易。
- en: Interoperability
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互操作性
- en: As we’ve discussed, one of the steps you must take when calling Win32 APIs is
    to translate the types used in C# into their Win32 equivalents and vice versa.
    Sometimes, that’s easy; sometimes, it can be pretty challenging.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，在调用Win32 API时，你必须采取的步骤之一是将C#中使用的类型转换为它们的Win32等效类型，反之亦然。有时，这很简单；有时，这可能相当具有挑战性。
- en: 'The framework designers did a lot to help us: when the Win32 API expects a
    string, you can usually give it a C# string, and the CLR marshals the type back
    and forth without you even knowing it. But still, there is some marshaling going
    on. A C-style string is a pointer to a place in memory where a character sits.
    The next character is next to it, and so on, until the system finds a value of
    0\. That is the end-of-string marker. This is entirely different from the `String`
    class we have in C# (internally, the `String` class still has that list of characters
    ending with 0 somewhere, but we never see that, so we can pretend it isn’t there
    at all).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 框架设计者做了很多工作来帮助我们：当Win32 API期望一个字符串时，你通常可以给它一个C#字符串，CLR会自动在两者之间进行类型转换，即使你不知道。但是，仍然有一些转换在进行。C风格字符串是内存中字符位置的指针。下一个字符紧挨着它，以此类推，直到系统找到一个值为0的值。这是字符串的结束标记。这与我们在C#中拥有的`String`类完全不同（内部，`String`类仍然有以0结尾的字符列表，但我们从未看到过，所以我们可以假装它根本不存在）。
- en: 'Most types in C# have a sibling in Win32\. Here’s a list of the most used types:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的大多数类型在Win32中都有一个兄弟类型。以下是最常用类型的列表：
- en: '| **C# Type** | **Win32 Type** | **Description** |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **C# 类型** | **Win32 类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `byte` | `BYTE` | 8-bit unsigned integer. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `BYTE` | 8-bit 无符号整数。 |'
- en: '| `sbyte` | `CHAR` | 8-bit signed integer, typically used for ASCII characters.
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `CHAR` | 8-bit 有符号整数，通常用于ASCII字符。 |'
- en: '| `short` | `SHORT` | 16-bit signed integer. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `SHORT` | 16位有符号整数。 |'
- en: '| `ushort` | `WORD` | 16-bit unsigned integer. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `ushort` | `WORD` | 16位无符号整数。 |'
- en: '| `int` | `INT` or `LONG` | 32-bit signed integer |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `INT` 或 `LONG` | 32位有符号整数 |'
- en: '| `uint` | `UINT` or `DWORD` | 32-bit unsigned integer. Also used for flags
    and enumerations. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | `UINT` 或 `DWORD` | 32位无符号整数。也用于标志和枚举。 |'
- en: '| `long` | `LONGLONG` | 64-bit signed integer. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `LONGLONG` | 64位有符号整数。 |'
- en: '| `ulong` | `ULONGLONG` | 64-bit unsigned integer. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | `ULONGLONG` | 64位无符号整数。 |'
- en: '| `float` | `FLOAT` | 32-bit floating-point number. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `FLOAT` | 32位浮点数。 |'
- en: '| `double` | `DOUBLE` | 64-bit floating-point number. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `DOUBLE` | 64位浮点数。 |'
- en: '| `char` | `WCHAR` or `TCHAR` | 16-bit Unicode character in C#, whereas `WCHAR`/`TCHAR`
    varies in Win32. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `WCHAR` 或 `TCHAR` | 在 C# 中为 16 位 Unicode 字符，而在 Win32 中 `WCHAR`/`TCHAR`
    则不同。 |'
- en: '| `bool` | `BOOL` | Boolean type. `True` or `False` in C#, and typically `TRUE`
    or `FALSE` in Win32\. Here, `FALSE` is defined as `0`, whereas `TRUE` is defined
    as `NOT FALSE`, meaning any other value, but usually, it is `1`. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `BOOL` | 布尔类型。在 C# 中为 `True` 或 `False`，在 Win32 中通常为 `TRUE` 或 `FALSE`。在这里，`FALSE`
    被定义为 `0`，而 `TRUE` 被定义为 `NOT FALSE`，即任何其他值，但通常为 `1`。 |'
- en: '| `IntPtr` | `HANDLE`, `HINSTANCE`, `HWND`, and so on | Represents a pointer
    or a handle. The type varies on context. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `IntPtr` | `HANDLE`、`HINSTANCE`、`HWND` 等 | 表示指针或句柄。类型根据上下文而变化。 |'
- en: '| `UIntPtr` | Rarely used in Win32 | An unsigned pointer or handle. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `UIntPtr` | 在 Win32 中很少使用 | 无符号指针或句柄。 |'
- en: '| `T[]` | `T*` or `SAFEARRAY` | An array of the `T` type. Its representation
    depends on the context in Win32. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `T[]` | `T*` 或 `SAFEARRAY` | `T` 类型的数组。其在 Win32 中的表示取决于上下文。 |'
- en: '| `DateTime` | `FILETIME` or `SYSTEMTIME` | Represents Date and Time. Representation
    varies in Win32. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `DateTime` | `FILETIME` 或 `SYSTEMTIME` | 表示日期和时间。在 Win32 中的表示不同。 |'
- en: '| `Guid` | `GUID` or `UUID` | GUID. 128-bit number. (GUID is usually tied to
    Windows platforms, while UUID is found on other platforms. They are basically
    the same, though.) |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `Guid` | `GUID` 或 `UUID` | GUID。128位数字。（GUID 通常与 Windows 平台相关联，而 UUID 在其他平台上找到。尽管如此，它们基本上是相同的。）
    |'
- en: '| `TimeSpan` | Typically represented by a combination of `DWORDs` | A time
    interval. This is not available on Win32. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `TimeSpan` | 通常由 `DWORDs` 的组合表示 | 时间间隔。在 Win32 上不可用。 |'
- en: 'Table1.2: C# and Win32 types'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2：C# 和 Win32 类型
- en: As you can see, most types can easily be translated between the platforms. When
    we dive into the more complex types, things get a bit more complicated since a
    lot of them are dependent on context or implementation. This makes marshaling
    types between the platforms a challenge.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大多数类型可以轻松地在平台之间转换。当我们深入研究更复杂的类型时，事情会变得有点复杂，因为许多类型都依赖于上下文或实现。这使得在平台之间传输类型具有挑战性。
- en: Another thing to consider is something called calling convention. A calling
    convention defines how to handle parameters when calling a function. The two most
    common types are `stdcall` and `cdecl`. Win32 APIs usually use `stdcall`, while
    most other C libraries expect `cdecl`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的是所谓的调用约定。调用约定定义了在调用函数时如何处理参数。最常见的是 `stdcall` 和 `cdecl`。Win32 API 通常使用
    `stdcall`，而大多数其他 C 库期望 `cdecl`。
- en: 'I won’t dive too deep into these two calling conventions. However, let’s summarize
    the most important differences:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨这两种调用约定。然而，让我们总结一下最重要的区别：
- en: '`stdcall`: The callee cleans the stack. It has a fixed number of arguments
    and it is commonly used in the Windows API. Here, function names usually get decorated.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdcall`：被调用者清理堆栈。它具有固定数量的参数，并且通常用于 Windows API。在这里，函数名称通常会被装饰。'
- en: '`cdecl`: The caller cleans the stack and allows variable-length argument lists.
    It is commonly used in the C standard library. Here, function names aren’t decorated.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cdecl`：调用者清理堆栈并允许可变长度的参数列表。它通常用于 C 标准库。在这里，函数名称不会被装饰。'
- en: As you can see, knowing how to call a function is essential. The wrong convention
    can mess up the stack, and the arguments are passed to the function or return
    the wrong results. You could even mess up the memory, which is almost unheard
    of when writing managed code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，了解如何调用函数是至关重要的。错误的约定可能会搞乱堆栈，并将参数传递给函数或返回错误的结果。你甚至可能会搞乱内存，这在编写托管代码时几乎是不可能的。
- en: When you don’t specify the calling convention, `stdcall` is assumed. You should
    give the correct calling convention if you need to call another library.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有指定调用约定时，默认为 `stdcall`。如果你需要调用另一个库，你应该提供正确的调用约定。
- en: 'Maybe an example would help here. We used `WriteConsole` to write to the console
    earlier, but there is a much easier way: the `printf` function. This function
    is part of the C runtime in the Microsoft `msvcrt.dll` library. If you want to
    use this function, import it with the now well-known `DllImport` declaration:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一个例子会在这里有所帮助。我们之前使用 `WriteConsole` 将内容写入控制台，但有一个更简单的方法：`printf` 函数。这个函数是 Microsoft
    `msvcrt.dll` 库中的 C 运行时的一部分。如果你想使用这个函数，可以使用现在众所周知的 `DllImport` 声明来导入它：
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since this function is not part of the Win32 API but instead resides in a separate
    DLL, you must be careful and specify the correct calling convention. Here, we
    need to use `cdecl`, which we can specify by setting `CallingConvention =` `CallingConvention.Cdecl`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数不是 Win32 API 的一部分，而是位于一个单独的 DLL 中，你必须小心并指定正确的调用约定。在这里，我们需要使用 `cdecl`，我们可以通过设置
    `CallingConvention =` `CallingConvention.Cdecl` 来指定它。
- en: Other types include `WinAPI`, `StdCall` (they are basically the same), `ThisCall`,
    and `FastCall`. You will hardly ever encounter the last two, but at least you
    have heard of them now.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型包括 `WinAPI`、`StdCall`（它们基本上是相同的）、`ThisCall` 和 `FastCall`。你几乎不会遇到后两种，但至少你现在已经听说过它们了。
- en: When you call an API and get weird errors or unexpected behavior, you might
    want to look into how to marshal the types or the calling conventions. The system
    doesn’t help you here by giving you good error messages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 API 并遇到奇怪的错误或意外行为时，你可能想要了解一下如何进行类型打包或调用约定。系统在这里并没有通过提供良好的错误信息来帮助你。
- en: Debugging tools
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试工具
- en: Visual Studio Debugger is awesome. However, when mixing managed with unmanaged
    code, things might get tricky. If something goes wrong, the system might halt
    and show you a breakpoint. But since the code that’s being called is not C#, the
    debugger might not show you what you need to see. It tries its best, so it will
    probably disassemble the code and show you the assembly code that is at fault.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 调试器很棒。然而，当混合托管代码和非托管代码时，事情可能会变得复杂。如果出现问题，系统可能会停止并显示一个断点。但由于被调用的代码不是
    C#，调试器可能不会显示你需要看到的内容。它会尽力而为，所以它可能会反汇编代码并显示出错的汇编代码。
- en: I showed you some assembly code at the beginning of this chapter. That isn’t
    something you might want to see if you want to find errors in your code. Well,
    I don’t know if that applies to you, but I certainly don’t want to see that.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章开头展示了些汇编代码。如果你想要在代码中查找错误，这并不是你想要看到的东西。好吧，我不知道这对你是否适用，但我知道我肯定不想看到那种。
- en: If that happens, you might want to use other debuggers, such as WinDbg. Later
    in this book, when we cover debugging, we take a closer look at this tool. But
    trust me, debugging mixed code is no walk in the park.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，你可能想要使用其他调试器，例如 WinDbg。在本书的后续章节中，当我们介绍调试时，我们会更详细地探讨这个工具。但请相信我，调试混合代码可不是件轻松的事情。
- en: Compatibility and portability
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性和可移植性
- en: Windows changes. Sometimes, it changes a lot; sometimes, the changes are subtle.
    Although Microsoft is known for trying to keep things backward compatible as much
    as possible, sometimes, APIs change. The signature might change, or the behavior
    might change. And you only find out about that when things go horribly wrong.
    Again, you see very few exceptions or error messages, so you’re left to debug
    the code and step through it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 会发生变化。有时，变化很大；有时，变化很微妙。尽管微软以尽可能保持向后兼容而闻名，但有时 API 会发生变化。签名可能会改变，或者行为可能会改变。而且你只有在事情变得非常糟糕时才会发现这一点。再次强调，你很少看到异常或错误信息，所以你只能自己调试代码并逐步执行。
- en: As soon as you start using Win32 APIs, you are tying yourself to a limited set
    of devices and platforms you can use.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始使用 Win32 API，你就是在将自己绑定到一组有限的设备和平台。
- en: And don’t even think about deploying the preceding code to a Linux platform.
    Sure, .NET runs fine on Linux, but not when you start using P/Invoke. And it might
    be that your code runs fine on one edition of Windows but breaks horribly on the
    next one that comes out of Redmond. We could call that “job security” since it
    will require us to update our code now and then, but I wouldn’t go as far as calling
    it fun.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 更不要考虑将前面的代码部署到 Linux 平台。当然，.NET 在 Linux 上运行得很好，但当你开始使用 P/Invoke 时就不一样了。而且可能你的代码在一个
    Windows 版本上运行得很好，但在下一个来自雷德蒙德的版本上却完全崩溃。我们可以称之为“工作保障”，因为这将要求我们不时更新我们的代码，但我不认为这很有趣。
- en: Documentation and community support
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档和社区支持
- en: The primary audience for the documentation of the Win32 API is C and C++ developers.
    As a C# developer, it is hard to find the information needed. Sites such as [https://pinvoke.net](https://pinvoke.net)
    help, but only if you know how they work.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API文档的主要受众是C和C++开发者。作为一个C#开发者，很难找到所需的信息。像[https://pinvoke.net](https://pinvoke.net)这样的网站有所帮助，但前提是你知道它们是如何工作的。
- en: The documentation of third-party DLLs you might want to use as a .NET developer
    is even harder to find. Sometimes, you must inspect a DLL, see how it works internally,
    and then translate it into the proper DLL import statement. If you do that, ensure
    you have the correct calling convention and types!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET开发者，你可能想要使用的第三方DLL的文档甚至更难找到。有时，你必须检查DLL，了解其内部工作方式，然后将其转换为正确的DLL导入语句。如果你这样做，确保你有正确的调用约定和数据类型！
- en: 'Community support when mixing managed and unmanaged code is also a challenge.
    Most developers fall into one of two camps: they work in the unmanaged world or
    they work in the managed world. Doing both is very rare.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合托管和非托管代码时，社区支持也是一个挑战。大多数开发者会落入两个阵营之一：他们在非托管世界中工作，或者他们在托管世界中工作。两者兼顾是非常罕见的。
- en: Good developers who can do both are scarce. The good news is that by reading
    this book, you are on the right path to becoming one of that very elite group!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 能够同时做到这两点的优秀开发者很少。好消息是，通过阅读这本书，你正走在成为那个非常精英群体中的一员的正确道路上！
- en: Next steps
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: This chapter looked at the difference between low-level and high-level APIs.
    We dove into the foundations of .NET by examining the BCL and CLR. Then, we examined
    how to call into low-level APIs such as the Win32 API. We did that by reimplementing
    the ubiquitous `Console.WriteLine` into code that the Windows operating system
    can run without using the BCL. That led us to discuss error discovery and error
    handling, and how to best go about them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了低级API和高级API之间的区别。我们通过检查BCL和CLR来深入研究.NET的基础。然后，我们探讨了如何调用低级API，例如Win32 API。我们通过重新实现无处不在的`Console.WriteLine`到Windows操作系统可以运行的代码中，而没有使用BCL来实现这一点。这导致我们讨论了错误发现和错误处理，以及如何最好地处理它们。
- en: We also discussed the issues you might encounter when you start doing that sort
    of coding. We mentioned the differences in type systems and the issues you might
    have when dealing with debuggers.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了你开始进行那种编码时可能会遇到的问题。我们提到了类型系统的差异以及你在处理调试器时可能遇到的问题。
- en: I hope this chapter has made you appreciate the .NET Framework and the hard
    work the BCL and CLR do for you as a developer. But I also hope you realize the
    power you get when using the Win32 API or other third-party libraries written
    in C or C++.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章让你更加欣赏.NET框架，以及BCL和CLR作为开发者为你所做的大量工作。但我也希望你意识到，当你使用Win32 API或其他用C或C++编写的第三方库时，你获得的强大能力。
- en: System programming relies heavily on these techniques. Although using these
    APIs ties you to the operating system you’re developing for or even a specific
    version of that system, this is often the only way to achieve your results. And
    to be honest, I think working with these APIs is fun. It is all about getting
    back to the basics.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程在很大程度上依赖于这些技术。尽管使用这些API将你绑定到正在为其开发的操作系统或该系统的特定版本，但这通常是实现你结果唯一的方法。坦白说，我认为与这些API一起工作很有趣。这完全是为了回归基础。
- en: Working with low-level APIs can be challenging. They can lead to a lot of hard-to-solve
    errors. But when used correctly, they can lead to better performance in your code.
    When writing system software, that is very important. As discussed previously,
    system software should not get in the way of the user or the systems the user
    directly interacts with. Instead, it should be as fast as possible. So, using
    the correct APIs might give you just that extra performance you need. I think
    this is so important that I wrote a complete chapter on performance, which happens
    to be the next chapter. We were born to run, so let’s run as fast as possible
    to the next part!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与低级API一起工作可能会很具挑战性。它们可能导致许多难以解决的错误。但是，当正确使用时，它们可以提高你的代码性能。在编写系统软件时，这一点非常重要。正如之前讨论的，系统软件不应该妨碍用户或用户直接与之交互的系统。相反，它应该尽可能快。因此，使用正确的API可能会给你带来所需的额外性能。我认为这一点非常重要，所以我专门写了一章关于性能的内容，恰好是下一章。我们生来就是为了奔跑，所以让我们尽可能快地奔向下一部分！
