- en: Dependency Injection and IoC Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入和IoC容器
- en: This chapter is intended to cover the Dependency Inversion principle in more
    depth. This means coverage of how it is used in already popular frameworks with
    different languages, like C#, or JavaScript. We will see what are its main advantages
    and caveats are, together with a brief analysis of why it is gaining momentum
    and consensus among developers all over the world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在更深入地探讨依赖反转原则。这意味着我们将涵盖它如何在不同语言的流行框架中使用，例如C#或JavaScript。我们将看到它的主要优点和缺点，以及对其在全球开发者中为何获得势头和共识的简要分析。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: In all, we'll talk about the concepts and implementation of software artifacts
    like Factories and Service Locators, and how they relate to Dependency Injection.
    Factories and Service Locators--concepts, implementations, and how they relate
    to Dependency Injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的来说，我们将讨论软件工件（如工厂和服务定位器）的概念和实现，以及它们如何与依赖注入相关。工厂和服务定位器——概念、实现以及它们与依赖注入的关系
- en: We'll also cover how IoC containers implement this concept, and what the main
    points that these IoC containers have in common are, beyond the language they're
    implemented in
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将涵盖IoC容器如何实现这个概念，以及这些IoC容器在它们实现的语言之外有哪些共同的主要点
- en: Then, we'll go through a brief introduction to Object Composition, Object Lifetime,
    and the different types of injection, ending with some commentaries about those
    cases in which Dependency Injection is not the best choice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将简要介绍对象组合、对象生命周期以及不同类型的注入，最后对那些依赖注入不是最佳选择的情况进行一些评论
- en: We will end up with some demos about popular IoC containers in use today for
    .NET Framework and a brief introduction to how DI is used in JavaScript frameworks,
    like AngularJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将以关于今天使用的流行.NET框架IoC容器的演示和一些关于在JavaScript框架（如AngularJS）中如何使用DI的简要介绍结束。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Factories and Service Locators--Concepts, Implementations, and how they relate
    to Dependency Injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂和服务定位器——概念、实现以及它们与依赖注入的关系
- en: IoC containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoC容器
- en: Demos about popular IoC containers in use today for .NET Framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于今天使用的流行.NET框架IoC容器的演示
- en: Introduction to Object Composition, Object Lifetime, and the different types
    of injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象组合、对象生命周期以及不同类型注入的介绍
- en: Brief introduction to how DI is used in JavaScript frameworks, like AngularJS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要介绍DI在JavaScript框架（如AngularJS）中的应用
- en: The Dependency Principle in more detail
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更详细的依赖原则
- en: 'But, before all that, let''s remember that we postponed a more detailed explanation
    of the principle for this chapter. In [Chapter 1](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml),
    *The SOLID Principles of Software Design*, we discussed the five SOLID principles
    in general, so it''s time to go deeper into the Dependency Principle. Actually,
    it''s not that difficult. It only requires to properly understand the two basic
    points, which Robert Martin highlights, and express the idea by means of some
    source code. Recall:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在所有这些之前，让我们记住，我们推迟了本章对原则的更详细解释。在[第1章](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml)，“软件设计的SOLID原则”，我们讨论了五个SOLID原则的一般性，所以现在是时候深入探讨依赖原则了。实际上，这并不难。它只需要正确理解罗伯特·马丁强调的两个基本点，并通过一些源代码表达这个想法。回想一下：
- en: '"High-level modules should not depend on low-level modules. Both should depend
    on abstractions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “高层模块不应当依赖于低层模块。两者都应当依赖于抽象。”
- en: Abstractions should not depend upon details. Details should depend upon abstractions."
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象不应当依赖于细节。细节应当依赖于抽象。”
- en: Remember, also, that we explained the intuitive notion of high-level and low-level
    classes, depending on their functionality for the application. For this respect,
    you can think of an app as if it was an organization hierarchy, with its different
    levels which depend on their role in the company.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们还解释了高层和低层类的直观概念，根据它们对应用程序的功能性。在这方面，你可以将应用程序视为一个组织层次结构，其中不同的级别依赖于他们在公司中的角色。
- en: Let's look at an example
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们看看一个例子
- en: So, let's see an example that violates the dependency principle, propose a solution,
    and see how that solution might take several flavors depending on the application's
    needs (or even the programmer's tastes, in many situations).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看一个违反依赖原则的例子，提出一个解决方案，并看看这个解决方案可能根据应用程序的需求（甚至在许多情况下根据程序员的喜好）有多种不同的风味。
- en: We're going to use a basic .NET app to settle the initial scenario. It's just
    a classic console application that reads a file with a movie's information from
    a specific directory, and presents the content in the console.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个基本的 .NET 应用程序来设置初始场景。它只是一个经典的控制台应用程序，从特定目录读取包含电影信息的文件，并在控制台中显示内容。
- en: 'We''ll start with a file called `MovieDB.xml` (in the XML format and stored
    in the app''s data subdirectory) with a data structure like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从名为 `MovieDB.xml` 的文件开始（该文件采用 XML 格式，存储在应用程序的数据子目录中）并具有以下数据结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, we can use LINQ to XML to easily read data from that file and iterate over
    the results to present a list of movie titles in the console. As a good practice,
    we'll define a class (the model) that represents the data to be read.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用 LINQ to XML 来轻松地从该文件读取数据，并遍历结果以在控制台中显示电影标题列表。作为一个好的实践，我们将定义一个表示要读取的数据的类（模型）。
- en: 'Consequently, we''ll have the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到以下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember that you can use the Edit menu in Visual Studio and select Paste Special
    to get the options Paste XML as classes and Paste JSON as classes, which will
    build a new class in the open editor page and insert a definition according to
    the data pasted, with the class name `Rootobject`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您可以在 Visual Studio 的编辑菜单中选择粘贴特殊选项，以获取粘贴 XML 作为类和粘贴 JSON 作为类的选项，这将在一个新的编辑页面中构建一个新的类，并根据粘贴的数据插入定义，类名为
    `Rootobject`。
- en: 'A first approach to the problem might end up with the following code (notice
    I''m using here the initial and simplest approach to have, both, a model to deal
    with, and the functionality required):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的第一个方法可能得到以下代码（请注意，我这里使用的是最初和最简单的方法，以便同时拥有模型和处理所需的功能）：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you see, we end up with a `List<Movie>` collection, and iterate over it,
    presenting the first ten results of the `Title` field in the console (see the
    following screenshot):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们最终得到一个 `List<Movie>` 集合，并遍历它，在控制台中显示 `Title` 字段的前十个结果（请参阅以下截图）：
- en: '![](img/0927f89d-2d97-4ce5-ba01-c4dd5b0fec53.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0927f89d-2d97-4ce5-ba01-c4dd5b0fec53.png)'
- en: Obviously, that's fine for a single use, but not for extended purposes. Since
    the `Program` class has several responsibilities, it should be decoupled accordingly.
    So, we can think of a `MovieReader` class which takes care of reading data and
    apply the first SOLID principle (separation of concerns).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这对于单次使用来说是不错的，但不适用于扩展用途。由于 `Program` 类有多个职责，因此应该相应地解耦。因此，我们可以考虑一个 `MovieReader`
    类，该类负责读取数据并应用第一个 SOLID 原则（关注点分离）。
- en: 'The new `MovieReader` class could look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `MovieReader` 类可能看起来像这样：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, we just moved the declarations required to access data to the new class
    and wrapped the reading functionality around a method `ReadMovies`, which reads
    and returns the required data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需将访问数据所需的声明移动到新类中，并在 `ReadMovies` 方法周围包装读取功能，该方法读取并返回所需的数据。
- en: 'Our `Main` entry point is now much simpler. Consider the following code snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Main` 入口点现在要简单得多。考虑以下代码片段：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's fine, but still, our `Program` class depends on the `XMLMovieReader`.
    What happens if we (or somebody else) needs to read data in another format, like
    JSON, for example?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们的 `Program` 类仍然依赖于 `XMLMovieReader`。如果我们（或其他人）需要以其他格式读取数据，例如 JSON，会发生什么？
- en: This is where Dependency Injection comes in. It would be much better than if
    our `Program` class could depend on an abstraction, not on a concrete class. It
    could be an abstract class, or it could be an interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是依赖注入发挥作用的地方。如果我们的 `Program` 类能够依赖于一个抽象，而不是一个具体类，那就好多了。它可以是抽象类，也可以是接口。
- en: This implies another class in charge of deciding which concrete implementation
    has to be served, depending on the file format. In this manner, it could also
    be possible to add further methods of reading data (like accessing a web service
    or database) without changing the already working code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着还需要另一个类来决定根据文件格式应该提供哪种具体实现。这样，也可以在不更改已工作的代码的情况下添加读取数据的其他方法（如访问 Web 服务或数据库）。
- en: 'So we could have another specialized reader called `JSONMovieReader` with this
    implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以有另一个专门的读取器，称为 `JSONMovieReader`，具有以下实现：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, we just have to implement the appropriate class depending on the format
    we use. Besides that, given that both files include exactly the same data, we
    would obtain identical results in both cases (I omitted the output for that reason).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需根据我们使用的格式实现适当的类。除此之外，鉴于两个文件包含完全相同的数据，两种情况下都会得到相同的结果（出于这个原因，我省略了输出）。
- en: Now, we should create an interface that defines the common operation that all
    readers will have in common; the `ReadMovies()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该创建一个接口，定义所有读取器都将具有的共同操作；`ReadMovies()` 方法。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This interface is the contract that both classes (and other possible candidates)
    implement, so, we just have to change both declarations to explicitly indicate
    that they indeed implement the `IMovieReader` interface. In this way, the final
    definitions will be:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口是两个类（以及其他可能的候选者）实现的合同，因此，我们只需更改两个声明，明确指出它们确实实现了 `IMovieReader` 接口。这样，最终的定义将是：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the last step consists of the creation of the new class in charge of deciding
    which reader has to be used (the `ReaderFactory`, in this demo):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个新的类，负责决定使用哪个读取器（在这个演示中是 `ReaderFactory`）：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that the constructor of `ReaderFactory` decides which type of reader
    is assigned to the `_IMovieReader` property. This could easily grow as needed.
    Our `Program` class has a new definition but it is an extensible one, and we can
    add as many reading methods as required with few or no changes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ReaderFactory` 构造函数决定了分配给 `_IMovieReader` 属性的读取器类型。这可以根据需要轻松扩展。我们的 `Program`
    类有一个新的定义，但它是一个可扩展的，我们可以添加所需的读取方法，而无需或只需少量更改：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, we offer an option to choose the file format, and, depending on
    the user's choice, the `IMovieReader` returned deals with the peculiarities of
    the format (you can think as well in other formats, such as Excel spreadsheets,
    pure text formats, comma-delimited files, databases, web services, and so on).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们提供了一个选项来选择文件格式，并且根据用户的选择，`IMovieReader` 返回的处理会处理该格式的特殊性（你也可以考虑其他格式，例如
    Excel 电子表格、纯文本格式、逗号分隔的文件、数据库、网络服务等）。
- en: 'The Class Diagram that Visual Studio generates from this architecture adopts
    the following aspect (just right-click on the name of the class--`Program3`, in
    this demo, and select View Class Diagram), to obtain a graphic structure like
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 从该架构生成的类图采用以下方面（只需右键单击类的名称--在这个演示中为 `Program3`，并选择查看类图），以获得以下图形结构：
- en: '![](img/da9281ae-feb7-42e8-9130-b5d2960e0c2d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da9281ae-feb7-42e8-9130-b5d2960e0c2d.png)'
- en: In summary, the `IMovieReader` interface is the contract that both classes agree
    upon. As long as any other class implements this interface, we'll be able to extend
    the potential data access mechanisms with new ways, as mentioned above.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`IMovieReader` 接口是两个类都同意的合同。只要任何其他类实现了这个接口，我们就能像上面提到的那样，以新的方式扩展潜在的数据访问机制。
- en: An important part of this implementation is the fact that, from the user interface,
    we access to a read-only property, `_IMovieReader` inside the `ReaderFactory`
    class. In that fashion, we avoid further changes in the property, once assigned
    a value. Finally, we get the `Name` property of the resulting type of `_IMovieReader`,
    to include it in the final output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的一个重要部分是，从用户界面，我们可以访问 `ReaderFactory` 类内部的一个只读属性 `_IMovieReader`。以这种方式，我们避免了属性一旦分配了值之后的进一步更改。最后，我们获取
    `_IMovieReader` 结果类型的 `Name` 属性，以将其包含在最终输出中。
- en: 'The list is like the previous one, only this time the user can select the type
    of format (XML or JSON):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表与之前类似，但这次用户可以选择格式的类型（XML 或 JSON）：
- en: '![](img/7572144e-243a-453f-9e91-4c45e0d87480.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7572144e-243a-453f-9e91-4c45e0d87480.png)'
- en: At first sight, you might think that we have to write more code when using the
    DI approach, but, this only happens when we're dealing with simple demos, like
    in this case.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能会认为在使用 DI 方法时我们需要编写更多的代码，但这种情况只发生在我们处理简单的演示时，就像在这个例子中一样。
- en: In real applications, with thousands or tenths of thousands of lines of code,
    the amount of required code usually diminishes and it greatly facilitates other
    aspects of the lifecycle, like maintainability, testability, extensibility, parallel
    development, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，随着数千或数万行代码，所需的代码量通常会减少，并且它极大地简化了生命周期的其他方面，如可维护性、可测试性、可扩展性、并行开发等。
- en: Aspects of Dependency Injection
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的方面
- en: However, before going on with the distinct aspects of Dependency Injection,
    it is advisable to recall some of the basic concepts that have a deep influence
    in the way this principle takes form, and that we should consider before its implementation.
    Concretely, there are three main points to evaluate--Object Composition, Object
    Lifetime, and Interception.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续探讨依赖注入的各个方面之前，建议回顾一些对形成这一原则有深远影响的基本概念，并在其实施之前考虑它们。具体来说，有三个主要点需要评估--对象组合、对象生命周期和拦截。
- en: Since these three topics are crucial in software development in general (not
    just when talking about DI), we will go back to them in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml),
    *Object Lifetime*, [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml), *Interception*,
    and [Chapter 8](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml), *Patterns - Dependency
    Injection*, but let's include now this light introduction to serving as a basic
    reminder of what is to come.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个主题在软件开发中至关重要（而不仅仅是讨论依赖注入时），我们将在第6章[对象生命周期](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml)、第7章[拦截](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml)和第8章[模式
    - 依赖注入](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml)中回到它们，但让我们现在先简要介绍，作为对即将到来的内容的提醒。
- en: Object Composition
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象组合
- en: One of the important notions behind Dependency Injection and other SOLID patterns
    is Object Composition, which, as Wikipedia ([https://en.wikipedia.org/wiki/Object_composition](https://en.wikipedia.org/wiki/Object_composition))
    reminds, "*is a way to combine simple objects or data types into more complex
    ones. Compositions are a critical building block of many basic data structures,
    including the tagged union, the linked list, and the binary tree, as well as the
    object used in object-oriented programming."*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入和其他SOLID模式背后的一个重要概念是对象组合，正如维基百科([https://en.wikipedia.org/wiki/Object_composition](https://en.wikipedia.org/wiki/Object_composition))提醒的，“*是一种将简单对象或数据类型组合成更复杂对象的方法。组合是许多基本数据结构的关键构建块，包括标记联合、链表和二叉树，以及面向对象编程中使用的对象。*”
- en: 'It puts a quite a clear example; types can often be divided into composite
    and non-composite types, and composition can be regarded as a relationship between
    types: an object of a composite type (for example, a car) *has an* object of a
    simpler type (for example, a wheel).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了一个相当清晰的例子；类型通常可以分为复合类型和非复合类型，组合可以被视为类型之间的关系：一个复合类型的对象（例如，一辆车）*拥有*一个更简单类型的对象（例如，一个轮子）。
- en: As you know, these relations have been at the heart of OOP, since the very beginning.
    It also has to do with Aggregation and should not be confused with inheritance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，这些关系自面向对象编程的起源以来一直是其核心。这也与聚合有关，不应与继承混淆。
- en: Actually, there is a well-known principle of the OOP called *Composition over
    Inheritance*, which states that "*classes should achieve polymorphic behavior
    and code reuse by their composition (by containing instances of other classes
    that implement the desired functionality) rather than inheritance from a base
    or parent class."*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，面向对象编程（OOP）中有一个著名的原则，称为**组合优于继承**，它指出“*类应该通过组合（通过包含实现所需功能的其他类的实例）而不是从基类或父类继承来实现多态行为和代码复用。*”
- en: 'Thus, the recommendation is to favor object composition over class inheritance:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议优先考虑对象组合而不是类继承：
- en: '![](img/1b34dfae-13e8-45a6-8560-ee849353b0d6.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b34dfae-13e8-45a6-8560-ee849353b0d6.png)'
- en: '(Image courtesy: [https://atomicobject.com/resources/oo-programming/object-oriented-aggregation](https://atomicobject.com/resources/oo-programming/object-oriented-aggregation))'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[https://atomicobject.com/resources/oo-programming/object-oriented-aggregation](https://atomicobject.com/resources/oo-programming/object-oriented-aggregation)）
- en: 'The previous schema shows the difference between both approaches: composition
    and aggregation. The individual elements used to compose a car are part of the
    car. The object could not perform its tasks without them.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示显示了两种方法之间的区别：组合和聚合。用于组合汽车的各个元素是汽车的一部分。没有它们，对象无法完成任务。
- en: In the second case, passengers could come and go (or even, now, since driverless
    cars don't require any), but they can eventually be managed by the car's instance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，乘客可以来去（或者现在，由于自动驾驶汽车不需要驾驶员，甚至可以不需要），但它们最终可以由汽车的实例来管理。
- en: Keep in mind that Wikipedia ([https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance))
    remarks that--"*Classes implementing the identified interfaces are built and added
    to business domain classes as needed. Thus, system behaviors are realized without
    inheritance. In fact, business domain classes may all be base classes without
    any inheritance at all. Alternative implementation of system behaviors is accomplished
    by providing another class that implements the desired behavior interface. Any
    business domain class that contains a reference to the interface can easily support
    any implementation of that interface and the choice can even be delayed until*
    *run time."*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，维基百科([https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance))指出——“*实现已识别接口的类根据需要构建并添加到业务域类中。因此，系统行为是通过不使用继承来实现的。实际上，业务域类可能全部是基类，没有任何继承。系统行为的替代实现是通过提供另一个实现所需行为接口的类来完成的。任何包含接口引用的业务域类都可以轻松支持该接口的任何实现，甚至可以选择在*运行时*进行选择。”*
- en: Object Lifetime
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: In the previous demo, we've seen a way to get rid of a classes' dependencies
    by means of abstractions, and the possibilities that we have later on to change
    those abstractions as needed, along with the application's lifecycle.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的演示中，我们看到了通过抽象来消除类依赖的方法，以及我们后来根据需要更改这些抽象的可能性，以及与应用程序的生命周期相关联的可能性。
- en: 'But, besides this fundamental ability, this practice allows us to determine
    abstractions'' life: when they are born (instantiated) and when they go out of
    scope (and leave the Garbage Collector in charge of the task of finishing the
    useful life).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了这种基本能力之外，这种做法还允许我们确定抽象的生命周期：它们何时诞生（实例化）以及何时超出作用域（并让垃圾回收器负责完成其有用生命周期的任务）。
- en: You know, when an object is not referenced by any other object it automatically
    becomes eligible for destruction, liberating its associated memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，当一个对象没有被其他对象引用时，它就会自动成为可销毁的候选对象，从而释放其关联的内存。
- en: 'The way the GC works is not trivial (although transparent to the user) and
    quite a few things should be considered, especially the way in which object generations
    are processed and the memory recovered, even in the Simplified Model (see the
    following image):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器的工作方式并不简单（尽管对用户来说是透明的），而且有很多事情需要考虑，特别是对象生成和处理以及内存回收的方式，即使在简化模型中也是如此（参见以下图片）：
- en: '![](img/c1bfa354-214e-45de-8d0c-bf93a03090ad.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1bfa354-214e-45de-8d0c-bf93a03090ad.png)'
- en: '(Image courtesy: [https://msdn.microsoft.com/en-us/library/ms973837.aspx](https://msdn.microsoft.com/en-us/library/ms973837.aspx))'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: (图片来源：[https://msdn.microsoft.com/en-us/library/ms973837.aspx](https://msdn.microsoft.com/en-us/library/ms973837.aspx))
- en: A little about Garbage Collection from Wikipedia ([https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)))--"*In
    computer science, garbage collection (GC) is a form of automatic memory management.
    The garbage collector, or just collector, attempts to reclaim garbage* *or memory
    occupied by objects that are no longer in use by the program. Garbage collection
    was invented by John McCarthy around 1959 to simplify manual memory management
    in Lisp*."
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于垃圾回收的一些信息来自维基百科([https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)))——“*在计算机科学中，垃圾回收（GC）是一种自动内存管理形式。垃圾回收器，或简称回收器，试图回收垃圾*
    *或程序不再使用的对象占用的内存。垃圾回收是由约翰·麦卡锡在1959年发明的，目的是简化Lisp中的手动内存管理。”*
- en: Bear in mind that problems might arise when two objects share an instance of
    the same interface, or when a new scenario shows up when we inject two distinct
    instances to different clients.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当两个对象共享同一接口的实例时，或者当我们向不同的客户端注入两个不同的实例时出现新的场景时，可能会出现问题。
- en: The way those objects are managed in memory also depends on our code to a large
    extent. Therefore, we will explain those intricacies in [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml),
    *Interception*, so you can have a detailed picture of this behavior and the implications
    it might have in your code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象在内存中的管理方式在很大程度上也取决于我们的代码。因此，我们将在[第7章](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml)，*拦截*中解释这些复杂性，以便你能详细了解这种行为及其可能对你的代码产生的影响。
- en: Interception
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截
- en: We can consider Interception as an application of the Decorator design pattern.
    For some authors, Interception is the process of pre-filtering a given call, in
    a way that we can include (or exclude) certain information from its standard (original)
    behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将拦截视为装饰器设计模式的运用。对于一些作者来说，拦截是预先过滤给定调用的过程，这样我们就可以从其标准（原始）行为中包含（或排除）某些信息。
- en: In the case of the IMovieReader implementation, the creation of a valid object
    capable of reading movies is redirected to the `ReaderFactory`, instead of the
    previous call to a concrete constructor. This is possible because abstractions
    allow us to defer instantiation and decide what to create depending on arguments,
    a system's configuration, configuration files, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在IMovieReader实现的案例中，创建一个能够读取电影的合法对象的过程被重定向到`ReaderFactory`，而不是之前的调用具体构造函数。这是可能的，因为抽象允许我们延迟实例化，并根据参数、系统配置、配置文件等决定创建什么。
- en: 'Another typical usage of interception relates to Instrumentation: distinct
    aspects of the application that go beyond application domains, like logging, auditing,
    validation and many others.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截的另一种典型用途与仪表化相关：超出应用程序域的应用程序的不同方面，如日志记录、审计、验证等。
- en: Finally, we can find interception when we capture the default behavior of system
    components using the so-called sub-classing technique, which allows for interleaving
    system calls and, effectively, change the system's behavior, substituting it for
    our own.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们使用所谓的子类化技术捕获系统组件的默认行为时，我们可以找到拦截。这种技术允许交织系统调用，并有效地改变系统的行为，用我们自己的行为来替代它。
- en: Ways to implement DI
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现DI的方法
- en: In this case, Dependency Injection is implemented by means of a constructor,
    which is the preferred way of today's implementation for many of the popular IoC
    containers we can find for the .NET Framework (and even, for other frameworks,
    like Angular).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，依赖注入是通过构造函数实现的，这是今天许多流行的IoC容器（对于.NET Framework以及甚至其他框架，如Angular）的首选实现方式。
- en: 'However, there are other two classical paths for DI implementation: via properties
    (also called setter injection) or methods.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他两种经典的DI实现路径：通过属性（也称为setter注入）或方法。
- en: In the Property Injection flavor, we're dealing with a scenario in which it
    makes sense to allow the user to change the dependency once the program is running.
    For instance, imagine that you start with a concrete implementation, and later
    on, the client or some program's condition, require change.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性注入的口味中，我们处理的是一种场景，在这种情况下，允许用户在程序运行时更改依赖项是有意义的。例如，想象一下，你从一个具体实现开始，后来客户端或某些程序的条件需要改变。
- en: There are situations in which that change doesn't require -strictly speaking-
    a new instance of the class, so it would not be coherent to create it just to
    change a given value. It's much better to keep the level of independence that
    DI promotes, but allow the client of the dependency to change that value once
    used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这种改变并不严格地需要一个新的类实例，因此仅仅为了改变一个特定的值而创建它是不可取的。保持DI所倡导的独立性水平要好得多，但允许依赖项的客户端在一旦使用后更改该值。
- en: To achieve this goal we must create a writable property (not a read-only one,
    like we did before). But, there's a danger. We have to avoid null values. We can
    do this easily by creating a default value, something very easy and concise to
    implement using C# latest techniques, as we'll see in a demo. So, a change of
    a dependency's value is the key to determining if we have to use properties in
    the injection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们必须创建一个可写属性（而不是像之前那样只读属性）。但是，存在一个风险。我们必须避免空值。我们可以通过创建一个默认值轻松地做到这一点，使用C#的最新技术，这将在演示中看到。因此，依赖项值的更改是确定是否需要在注入中使用属性的关键。
- en: In Method Injection, the code block that requires the dependency is usually
    a parameter of some method, and the purpose of the dependency's argument is to
    provide a context, which determines how the method should behave.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法注入中，需要依赖项的代码块通常是一些方法的参数，依赖项参数的目的是提供一个上下文，该上下文决定了方法应该如何行为。
- en: So, we can say that the scenario is scope-dependent. When the scope of the dependency
    is somehow local, as it happens when it is only being used in one concrete method
    (it does not affect the whole class), it's a good practice to limit the presence
    of the dependency exclusively to the method that it is going to use it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说这个场景是作用域相关的。当依赖项的作用域是局部的，比如它只在一个具体的方法中使用（它不会影响整个类）时，将依赖项的存在限制在将要使用它的方法中是一种良好的实践。
- en: Let's see a couple of samples about these two ways of implementing DI.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于这两种实现依赖注入的几个示例。
- en: Property Injection in action
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注入的实际应用
- en: Let's imagine something very simple for this demo. The code presents an initial
    configuration of color values for the current console, together with a message
    indicating those values. We offer the user the ability to change themes, to avoid
    unreadable combinations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个演示想象一个非常简单的场景。代码展示了当前控制台的颜色值初始配置，以及指示这些值的消息。我们为用户提供更改主题的能力，以避免难以阅读的组合。
- en: 'We reduce these combinations to light and dark, besides the initial one, which
    is black/white. We could define a very simple `ConsoleDisplayFactory` class with
    two default values that are assigned in its instantiation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些组合减少到亮色和暗色，除了初始的黑色/白色组合。我们可以定义一个非常简单的`ConsoleDisplayFactory`类，其中包含两个在其实例化时分配的默认值：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this definition, every time we create an instance, both properties (`ForeColor`
    and `BackColor`) are assigned the default theme configuration. Our `Program` class
    will depend on `ConsoleDisplayFactory`, but we make sure that both values hold
    a consistent color configuration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，每次我们创建一个实例时，两个属性（`ForeColor`和`BackColor`）都会被分配默认的主题配置。我们的`Program`类将依赖于`ConsoleDisplayFactory`，但我们确保这两个值保持一致的颜色配置。
- en: 'Now, our main entry point, located in `Program4`, would look like the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的主要入口点，位于`Program4`中，将如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Observe changes to console configuration that are performed via the `ConsoleDisplayFactory`
    instance, which is a property of the `Program4` class. For this initial version
    of the demo, we have opted for a method (which serves as a setter) that takes
    care of the values assigned.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 观察通过`ConsoleDisplayFactory`实例执行的控制台配置更改，该实例是`Program4`类的一个属性。对于这个演示的初始版本，我们选择了一个方法（作为设置器）来处理分配的值。
- en: Another approach could be to code the `ForeColor` and `BackColor` properties
    of the `ConsoleDisplayFactory` class in a way that the setters of each property
    would take care of assigning the suitable changes for each theme.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是以这种方式编写`ConsoleDisplayFactory`类的`ForeColor`和`BackColor`属性，即每个属性的设置器将负责为每个主题分配适当的更改。
- en: Though pretty simple, this code shows the idea behind Property Injection. We
    don't need the whole class to be re-instantiated, so we allow the client to change
    the required properties, but taking care that the results are injected according
    to business rules.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很简单，但这段代码展示了属性注入背后的理念。我们不需要整个类被重新实例化，因此我们允许客户端更改所需的属性，但要注意结果应按照业务规则进行注入。
- en: The fact that we use an injector method or program the setters directly will
    always depend on the architecture of the code and your necessities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用注入方法或直接编程设置器，这始终取决于代码的架构和您的需求。
- en: (We omit the output since it is quite trivial in this case).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: （我们省略了输出，因为在这种情况下它相当简单）。
- en: Method Injection in practice
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法注入的实际应用
- en: 'As we previously mentioned, the key here is that the injected resource makes
    sense inside a method of the client class. There are two main reasons for this,
    which are the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，关键在于注入的资源在客户端类的方法中是有意义的。这主要有两个原因，如下所述：
- en: The injected parameter affects the way the method behaves and it can change
    along its life-runtime (in distinct method calls)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入的参数会影响方法的行为方式，并且它可以在其生命周期内改变（在不同的方法调用中）。
- en: The injected parameter's functionality affects the method's block of code and
    nothing else. Therefore, there's no need to create a class-scope dependency when
    it is only used inside that block
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入参数的功能会影响方法代码块，而不影响其他任何内容。因此，当它仅在该代码块内部使用时，没有必要创建类作用域的依赖项。
- en: This scenario shows up when we are coding a method that has some functionality
    that is dynamic in nature (an HTTP context, access to a directory that contains
    files that might change during the execution, Web Sockets, and so on.).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个具有动态功能的方法时，会出现这种情况（例如HTTP上下文、访问在执行过程中可能发生变化的文件目录、Web Sockets等）。
- en: It is well-known that the .NET Framework already implements this feature in
    some classes belonging to a variety of namespaces. For example, in the **Base
    Class Libraries** (**BCL**), the `System.ComponentModel` namespace allows using
    the `TypeConverter` class which is especially useful in contexts where WPF is
    involved, to allow conversions between pure CLR types and XAML types or other
    business logic types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，.NET Framework已经在各种命名空间的一些类中实现了这个功能。例如，在**基类库**（**BCL**）中，`System.ComponentModel`命名空间允许使用`TypeConverter`类，这在涉及WPF的上下文中特别有用，允许在纯CLR类型和XAML类型或其他业务逻辑类型之间进行转换。
- en: Some of this classes' methods use an instance of `ITypeDescriptorContext` that
    carries information about the context in which the execution takes place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些此类方法的实现使用`ITypeDescriptorContext`的实例，它携带有关执行上下文的信息。
- en: 'But there''s a simpler and much more common scenario in which this is happening
    all the time: the structure of the .NET''s event system, and I think that understanding
    the way it works is very useful to realize how we can find implementations of
    this pattern in every-day situations, and how this is being used since the very
    beginning.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个更简单、更常见的场景，这种情况一直在发生：.NET事件系统的结构，我认为理解它是如何工作的对于意识到我们如何在日常情况下找到这种模式的实现非常有用，以及它从一开始就被如何使用。
- en: .NET event architecture as Model Injection
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET事件架构作为模型注入
- en: 'Let''s think of the event model for a second: in practice, method A calls method
    B and passes some arguments (two, by default). When you program a Click, `SelectedItemChanged`,
    of `FormClosing` event in classic (and modern) .NET, a communication process takes
    place.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下事件模型：在实践中，方法A调用方法B并传递一些参数（默认为两个）。当你用经典（和现代）.NET编程一个点击、`SelectedItemChanged`或`FormClosing`事件时，就会发生一个通信过程。
- en: 'The process involves a method responsible for calling (the sender) and the
    callee (the receiver). This can be represented with the classic scheme of any
    other communication process that we all know from the first books of Information
    Theory:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程涉及一个负责调用（发送者）和被调用者（接收者）的方法。这可以用我们所有人都从信息论第一本书中知道的任何其他通信过程的经典方案来表示：
- en: '![](img/0a08780c-c39b-4f75-87d0-4dc2a64d6876.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a08780c-c39b-4f75-87d0-4dc2a64d6876.png)'
- en: Aggregation is a simple collection, like a bag of marbles, while composition
    implies internal/functional dependencies, like the hinges on a box. Cars aggregate
    passengers; they get in and out without breaking the car's functionality but the
    tires are components; remove one and the car no longer functions correctly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一个简单的集合，就像一袋弹珠，而组合则意味着内部/功能依赖，就像盒子上的铰链。汽车聚合乘客；乘客上下车而不会破坏汽车的功能，但轮胎是组件；移除一个，汽车就不再正确工作。
- en: If you don't know these concepts (Composition and Aggregation), PACKT has excellent
    books to start with that, like *Learning Object-Oriented Programming* by Gaston
    C. Hillar ([https://www.packtpub.com/application-development/learning-object-oriented-programming](https://www.packtpub.com/application-development/learning-object-oriented-programming)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道这些概念（组合和聚合），PACKT有一些优秀的书籍可以开始阅读，比如Gaston C. Hillar的《面向对象编程》（[https://www.packtpub.com/application-development/learning-object-oriented-programming](https://www.packtpub.com/application-development/learning-object-oriented-programming)）。
- en: 'There is a correspondence between the two schemes in the four elements implied:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在四个隐含元素中，两种方案之间存在对应关系：
- en: 'Issuer (sender): It is the method that makes the call'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发起者（发送者）：它是进行调用的方法
- en: 'Receiver: It is another class (or the same) responding in another method'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者：它是另一个类（或相同的）在另一个方法中做出响应
- en: 'Channel: It is the environment, replaced by a managed environment in .NET'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道：它是环境，在.NET中由托管环境替代
- en: 'Message: The set of values passed to the receiver (the EventArgs in .NET)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：传递给接收者的值集（.NET中的`EventArgs`）
- en: 'Let''s think of a Windows app in which the user interface generates events,
    as, for example, when we use a button to close the window. The piece of code that
    represents such a scenario is expressed with some code like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一个Windows应用程序，其中用户界面生成事件，例如，当我们使用按钮关闭窗口时。表示这种场景的代码片段可以用以下代码表示：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/324631da-adcb-4d77-80f8-0e36b697c692.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/324631da-adcb-4d77-80f8-0e36b697c692.png)'
- en: 'Who launches the execution of this code? Well, the Button object, when we program
    the click event includes the following code in the designer''s section of the
    `Form` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 谁启动了这段代码的执行？嗯，当我们在`Form`类的设计器部分编程点击事件时，按钮对象包括以下代码：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This creates a delegate of type `EventHandler` (the default one) which is going
    to be in charge of calling the destination method, every time the user clicks
    on it. To avoid possible problems, that event is just a class with some characteristics:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个类型为`EventHandler`（默认类型）的代理，它将负责在用户点击时调用目标方法。为了避免可能的问题，该事件只是一个具有一些特性的类：
- en: Its signature is the same as the method to be called. In this manner, possible
    casting problems are avoided since there is no need for type conversions.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的签名与要调用的方法相同。以这种方式，避免了可能的类型转换问题。
- en: The delegate checks for the presence and availability of the `btnClose_Click`
    method before the call, so it guarantees there are no pointer-to-null problems.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理在调用之前检查`btnClose_Click`方法的可用性，因此它保证了没有空指针问题。
- en: Given that casting and pointers-to-nowhere were the two of the main causes of
    the infamous BSODs (Blue Screens of Death), the implantation of this architecture
    was something crucial from the very beginning of .NET.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型转换和空指针是臭名昭著的BSOD（蓝屏死机）的两个主要原因，因此从.NET的最初阶段开始，这种架构的实施是至关重要的。
- en: However, there is something else here that implies Method Injection, if you
    analyze the code and, even in those cases, like in the next demo, when the delegate
    is not the default.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里还有其他一些东西暗示了方法注入，如果您分析代码，即使在那些情况下，例如在下一个演示中，当代理不是默认时。
- en: 'To really appreciate this point, let''s program the `FormClosing` event that
    will be launched whenever the user clicks the Close button or tries to close the
    window in any of the other available ways: *Alt* + *F4*, the window''s x button,
    or the window''s menu:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解这一点，让我们编写一个`FormClosing`事件，它将在用户点击关闭按钮或以任何其他可用方式尝试关闭窗口时触发：*Alt* + *F4*，窗口的x按钮，或窗口的菜单：
- en: '![](img/1b7a2985-0940-4f35-8ffe-c240ca1ab426.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b7a2985-0940-4f35-8ffe-c240ca1ab426.png)'
- en: As you can see, this time the second argument of the `FormClosing` event is
    not the default, but an instance of an object that inherits from `EventArgs`,
    and encloses extra information providing the context, that we were talking about.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次`FormClosing`事件的第二个参数不是默认的，而是一个继承自`EventArgs`的对象实例，它包含了提供上下文的额外信息，这是我们之前提到的。
- en: 'Actually, that object holds two properties: `Cancel` (which is assignable and
    forces a stop in the exit procedure), and `CloseReason`, a read-only property
    that indicates which mechanism really launched the closing process.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，该对象包含两个属性：`Cancel`（可赋值并强制在退出过程中停止），以及`CloseReason`，一个只读属性，表示哪个机制真正触发了关闭过程。
- en: 'So, we''re not programming or instantiating this parameter: it is given to
    us via injection, every time we define an event procedure. And that internal injection
    system is responsible for providing the information relevant to the execution
    context. This is a clear sample of method injection.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是在编程或实例化这个参数：它是通过注入给我们，每次我们定义一个事件过程时。这个内部注入系统负责提供与执行上下文相关的信息。这是一个方法注入的明显示例。
- en: 'If you peek into the definition of the `FormClosingEventArgs` parameter, you
    will see that it is, indeed, another class that inherits from `CancelEventArgs`
    (which, in turn, inherits from EventArgs):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`FormClosingEventArgs`参数的定义，您将看到它确实是一个继承自`CancelEventArgs`（它反过来继承自`EventArgs`）的另一个类：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's interesting to note that `ClosingEventArgs` also belongs to the namespace
    `System.ComponentModel` that we mentioned previously.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要注意，`ClosingEventArgs`也属于我们之前提到的`System.ComponentModel`命名空间。
- en: So, even when we're doing something as simple as closing a window, we're implicitly
    using method injection, that is at the heart of the .NET Framework.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们在做像关闭窗口这样简单的事情时，我们也在隐式地使用方法注入，这是.NET框架的核心。
- en: This architecture can be extended by the user in many ways, even using techniques
    like event chaining when we need to concatenate processes that depend on the user's
    choice and that are usually generated via events, for example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构可以通过用户以多种方式扩展，甚至可以使用事件链等技术，当我们需要连接依赖于用户选择的过程时，这些过程通常通过事件生成，例如。
- en: A typical case for even chaining is when a user's selection from a combo (Like
    Select a Country), generates code that fills up another combo, let's say Select
    a City. You first have to select the country if you want the cities combo to be
    filled with the cities belonging to a given country.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于级联选择，一个典型的例子是当用户从一个组合框（例如选择一个国家）中进行选择时，会生成代码来填充另一个组合框，比如选择一个城市。你首先必须选择一个国家，这样城市组合框才能填充属于该国家的城市。
- en: One such case could be when the closing process of a window (something like
    the preceding code shown) requires an extra user intervention. For instance, imagine
    that you have to ask the user if he/she wants to save the audits (or perform any
    other action) but only in the case that a previous question is affirmative, like
    confirming that the user wants to exit the application (which might, in turn,
    depend on other conditions, like the `CloseReason` expressed in the previous code
    of the FormClosing event.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子可能是当一个窗口的关闭过程（类似于前面显示的代码）需要额外的用户干预时。例如，想象一下，你必须询问用户是否想要保存审计（或执行任何其他操作），但仅当先前的询问是肯定的，比如确认用户想要退出应用程序（这反过来可能取决于其他条件，如
    FormClosing 事件中表达的前一个代码中的 `CloseReason`）。
- en: One possible approach would be to create a generic event on our own, that could
    be launched if the requested conditions apply. Let's say that only if `ClosingReason`
    is `CloseReason.UserClosing`, we should ask the user to confirm application exit
    and, in case the answer is positive, ask him again if he/she wants to save the
    information.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法是创建一个我们自己的通用事件，如果满足请求的条件，则可以触发。比如说，只有当 `ClosingReason` 是 `CloseReason.UserClosing`
    时，我们应该询问用户是否确认应用程序退出，如果答案是肯定的，再询问他是否想要保存信息。
- en: 'We could write the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写以下代码：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we''re invoking the event `FormClosingExtended` only when the if block
    evaluates to true. But, using the new generic event handler we can pass login
    information to another event that jumps from there to a distinct event procedure:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仅在 if 块评估为真时调用 `FormClosingExtended` 事件。但是，使用新的通用事件处理器，我们可以将登录信息传递给另一个事件，该事件从那里跳转到不同的事件过程：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This event procedure receives data in the e argument and also asks the user
    if he/she wants to save it as audit information. In this manner, we don't have
    to concatenate two `MessageBox` calls and the code is clearly separated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件过程接收 e 参数中的数据，并询问用户是否希望将其保存为审计信息。这样，我们就不需要连接两个 `MessageBox` 调用，代码也更加清晰。
- en: Besides that, since the e argument could be a generic event handler of any kind,
    the type of information passed as the event argument, could also be of any kind,
    of any complexity level. For instance, it could be an object with its own methods
    suitable for validation purposes, security checking, etc.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 e 参数可以是任何类型的通用事件处理器，因此作为事件参数传递的信息类型也可以是任何类型，任何复杂程度。例如，它可以是具有适合验证目的、安全检查等自己方法的对象。
- en: 'The only thing missing in the code is to define the event handlers for each
    of the events implied in the process, which we can do inside the `MethodInjection`
    constructor:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中唯一缺少的是定义过程中涉及到的每个事件的处理器，这可以在 `MethodInjection` 构造函数内部完成：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, in terms of DI, we''re using the internal injection engine inside .NET
    Framework in two different ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 DI 方面，我们在 .NET Framework 中以两种不同的方式使用内部注入引擎：
- en: In the first case, to obtain information passed to us by the framework in relation
    to the cause that provoked that event to happen (`ClosingReason`).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，为了获取框架传递给我们的与引发该事件的原因相关的信息（`ClosingReason`）。
- en: In the second, because we have implemented our own event, that is executed in
    concatenation to the previous one and receives the required information expecting
    the user's approval.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，因为我们已经实现了一个自己的事件，该事件在连接到前一个事件后执行，并期望用户批准所需的信息。
- en: Note that, in case that no business logic argument is required for the second
    event handler, we could have registered it also for the FormClosing event, since
    events are multicast in .NET
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有为第二个事件处理器需要业务逻辑参数，我们也可以将其注册为 FormClosing 事件，因为事件在 .NET 中是可多播的。
- en: DI containers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI 容器
- en: In everyday practice, a good part of the plumbing to have DI working is not
    done via manual coding, but using something called DI Containers (also called
    IoC Containers). The previous demo using the .NET Framework event's system implies
    the existence of some DI Container.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常实践中，使 DI 工作的部分管道不是通过手动编码完成的，而是使用称为 DI 容器（也称为 IoC 容器）的东西。之前使用 .NET 框架事件系统的演示暗示了存在某些
    DI 容器。
- en: Basically, a DI Container is a software library that facilitates the use of
    Dependency Injection and its based methodologies, like object composition, lifetime
    management, and so on. This is quite convenient for the programmer, who doesn't
    have to worry about the details of creation, destruction, etc.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，DI 容器是一个软件库，它简化了依赖注入及其基于对象组合、生命周期管理等方法的用法。这对程序员来说非常方便，因为他们不必担心创建、销毁等细节。
- en: 'Many people have some confusion with DI and IoC. You can refer to this website
    to clear out any confusions: [http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection.](http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人对 DI 和 IoC 有一些混淆。您可以参考这个网站来消除任何混淆：[http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection.](http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection)
- en: In many cases, DI Containers enforce several good practices, like avoiding duplication
    of instances, by supplying singleton instances of the required component, like
    it happens in AngularJS since the initial versions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，DI 容器强制执行一些良好的实践，例如通过提供所需组件的单例实例来避免实例的重复，就像 AngularJS 从初始版本开始所做的那样。
- en: 'In .NET, as we have mentioned, IoC is present in several scenarios, and the
    following image shows some of the main components that use this technique:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，正如我们提到的，IoC 在几个场景中都存在，以下图像显示了使用此技术的某些主要组件：
- en: '![](img/da9d1376-b23a-441a-b0ee-5602c2c34a19.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da9d1376-b23a-441a-b0ee-5602c2c34a19.png)'
- en: '(Image courtesy: [https://hotproton.com/category/dependency-injection/](https://hotproton.com/category/dependency-injection/))'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[https://hotproton.com/category/dependency-injection/](https://hotproton.com/category/dependency-injection/))
- en: As you can see in the graphic, .NET (even in the previous versions), holds several
    components that provide Inversion of Control (IoC), either linked to Events and
    Delegates, as we've seen in previous demos, or as Service Locators, or DI Injection
    mechanisms.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图中看到的，.NET（甚至在之前的版本中）包含几个提供控制反转（IoC）的组件，这些组件要么与事件和委托相关联，正如我们在之前的演示中所见，要么作为服务定位器，或者作为
    DI 注入机制。
- en: Service locators
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器
- en: Basically, a service locator is just a design pattern that instructs the implementer
    on how to construct DI containers capable of obtaining a service with a strong
    abstraction layer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，服务定位器只是一个设计模式，它指导实现者如何构建能够通过强大的抽象层获取服务的 DI 容器。
- en: 'There''s a condition that all service locators require: services have to be
    registered, so they can be later found and served at the code''s request.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务定位器都需要满足一个条件：服务必须注册，以便可以在代码请求时找到并提供服务。
- en: 'Wikipedia ([http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection](http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection))
    summarizes the advantages of Service Locators in three main points:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科 ([http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection](http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection))
    总结了服务定位器的三个主要优点：
- en: The service locator can act as a simple run-time linker. This allows code to
    be added at run-time without re-compiling the application, and in some cases without
    having to even restart it.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器可以充当简单的运行时链接器。这允许在运行时添加代码，而无需重新编译应用程序，在某些情况下甚至无需重新启动它。
- en: Applications can optimize themselves at run-time by selectively adding and removing
    items from the service locator. For example, an application can detect that it
    has a better library for reading JPG images available than the default one, and
    alter the registry accordingly.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以通过从服务定位器中选择性地添加和删除项目来在运行时优化自己。例如，一个应用程序可以检测到它有一个比默认更好的库来读取 JPG 图像，并相应地更改注册表。
- en: Large sections of a library or application can be completely separated. The
    only link between them becomes the registry.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库或应用程序的大块区域可以完全分离。它们之间的唯一联系就是注册表。
- en: 'In general, we can say the application of the Dependency Inversion principle
    leads to the construction of IoC containers and they reflect in concrete DI techniques
    and Service Locators. (See the following diagram):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以这样说，依赖倒置原则的应用导致了IoC容器的构建，它们在具体的DI技术和服务定位器中得到了体现。（见以下图示）：
- en: '![](img/ae91c95e-f636-47b9-9073-e76f66fcfa59.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae91c95e-f636-47b9-9073-e76f66fcfa59.png)'
- en: '(Image courtesy: [http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/](http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/))'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/](http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/))
- en: Of course, these advantages don't go without their counterparts. Possible problems
    include the registry acting like a black box for the rest of the application,
    uniqueness, security vulnerabilities, hiding class dependencies, adding some testing
    difficulties, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些优势并非没有对应的缺点。可能出现的问题包括注册表像黑盒一样作用于应用程序的其他部分、唯一性、安全漏洞、隐藏类依赖关系、增加一些测试难度等等。
- en: DI Containers for .NET
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 的依赖注入容器
- en: Besides the internal functionality related to DI inside .NET, it is very common
    to use external containers that provide extra or extended functionality to programmers,
    and, being .NET--a very popular programming framework, many have proliferated
    in recent years.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与.NET内部DI相关的功能外，使用外部容器提供额外或扩展功能给程序员是非常常见的，而且作为非常流行的编程框架的.NET，近年来已经出现了许多这样的容器。
- en: So, our criteria here will be showing the basic implementation of those that
    seem to have a greater acceptance in the community, like Unity, Castle Windsor,
    StructureMap, and Autofac.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的标准将是展示那些在社区中似乎接受度更高的基本实现，如Unity、Castle Windsor、StructureMap和Autofac。
- en: Actually, the number of choices available has kept growing in the last few years,
    and some of them are pretty popular as well, like Ninject, Simple Injector, Dynamo,
    LinFu, Spring.NET, Hiro, and so on, so our choice, in this case, was mainly driven
    by the level of implementation in the community, their ease of use, their API's
    consistency, and the performance tests in the latest versions. Since I don't want
    to pronounce myself about any of those tests, you can take a look at different
    benchmarks available on the web, and you'll probably come to the same or similar
    conclusion as I did.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在过去几年中，可用的选择数量一直在增加，其中一些相当受欢迎，如Ninject、Simple Injector、Dynamo、LinFu、Spring.NET、Hiro等等，因此在这种情况下，我们的选择主要是由社区中的实现水平、易用性、API的一致性以及最新版本的性能测试驱动的。由于我不想对任何这些测试发表意见，你可以查看网络上可用的不同基准测试，你可能会得出与我相同的或类似的结论。
- en: 'These DI Containers (and others) share a few things in common: they all require
    a previous configuration, and they have the ability to resolve the required dependencies
    at runtime. The following schema shows an approach to this idea:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖注入容器（以及其他容器）有一些共同点：它们都需要之前的配置，并且能够在运行时解析所需的依赖项。以下图示展示了实现这一想法的方法：
- en: '![](img/06bfc163-a1c4-4682-82a1-e65663472e37.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06bfc163-a1c4-4682-82a1-e65663472e37.png)'
- en: In practice, this means we will instantiate and configure a container object,
    and later on, we'll ask the container to resolve the required dependencies in
    one or more locations within our code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着我们将实例化和配置一个容器对象，然后稍后，我们会要求容器在我们的代码中的一个或多个位置解析所需的依赖项。
- en: Besides that, in most of the cases, components are resolved from the same instance
    that we initially instantiate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在大多数情况下，组件都是从我们最初实例化的同一个实例中解析出来的。
- en: 'A common (and very simple) context for our demos:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示的常见（且非常简单）的上下文：
- en: Since complications will show up themselves when coding real-life applications,
    I've chosen a very, very, simple starting point, that can serve us as a common
    scenario to solve the DI problems it presents. It's based on our previous idea
    of the `MovieReader` but let's say in this case that we don't even read anything
    from disk (only display a message in the console), to focus on the code's architecture
    and not on the details of its implementation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在实际编码真实应用程序时会出现复杂性，我选择了一个非常简单、非常简单的起点，它可以作为一个常见的场景来解决它所提出的DI问题。它基于我们之前的`MovieReader`想法，但让我们说在这种情况下，我们甚至没有从磁盘读取任何内容（只显示控制台消息），以关注代码的架构而不是其实施的细节。
- en: 'The demo proposes the existence of two classes in charge of reading some books''
    information from the disk, and they both share a common interface `IBookReader`,
    which implements a unique method `ReadBooks()`. These three elements comprise
    the Data Access Layer:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 示例提出了两个负责从磁盘读取一些书籍信息的类的存在，它们都共享一个公共接口 `IBookReader`，该接口实现了一个独特的方法 `ReadBooks()`。这三个元素构成了数据访问层：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Pretty simple, right? Now, we build another succinct Business Layer, made up
    of a class called `BookManager`, whose only purpose is to perform business logic,
    so it exposes a public constructor that receives an instance of one of the two
    possible readers, and implements a call to the `ReadBooks` method, that in turn,
    will refer to the reading method that corresponds to each case:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？现在，我们构建另一个简洁的业务层，由一个名为 `BookManager` 的类组成，其唯一目的是执行业务逻辑，因此它公开了一个构造函数，接收两个可能读取器之一的实例，并实现了对
    `ReadBooks` 方法的调用，该调用将转而引用对应于每个情况的读取方法：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, in the user interface, that in this case is the `Console`, we ask
    the user to decide the reading mechanism and call the corresponding version of
    the `BookManager`, so we can call the `ReadBooks` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在用户界面中，在这个例子中是控制台，我们要求用户决定读取机制并调用相应的 `BookManager` 版本，以便我们可以调用 `ReadBooks`
    方法：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Up to this point, it's a very simple code, already using some dependency inversion,
    but still stuck to the creation of the type of reader in the user interface. That's
    exactly what we obtain when we use an external creation mechanism that takes care
    of this work for us.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码非常简单，已经使用了一些依赖反转，但仍然依赖于用户界面中读取器类型的创建。这正是当我们使用一个外部创建机制来为我们处理这项工作时我们所获得的结果。
- en: Let's see now how we can change this using the distinct DI Containers mentioned
    previously.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用之前提到的不同 DI 容器来改变这一点。
- en: Using Unity Container
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 容器
- en: The Unity container has been in place for quite a few years now. Somehow, it
    was the official Microsoft external container and has been linked to the *Patterns
    & Practices* initiative for many years.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 容器已经存在了好几年。某种程度上，它曾是官方的 Microsoft 外部容器，并且多年来一直与 *Patterns & Practices*
    创新计划相关联。
- en: 'Please note that Unity is not an official Microsoft product or does not belong
    to the Patterns & Practices team anymore. The project has been redirected to other
    people (Pablo Cibraro and Pedro Wood), as Immo Landwerth published in .NET Blog
    in 2015 ([https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/](https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/)),
    commenting: "*Dependency injection containers for .NET have continued to mature
    and evolve significantly. In addition, open source components are now more accepted.
    The need for having an "official" container from Microsoft is no longer as widespread
    as it once was.*"'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Unity 不是一个官方的 Microsoft 产品，也不再属于 Patterns & Practices 团队。该项目已被转交给其他人（Pablo
    Cibraro 和 Pedro Wood），正如 Immo Landwerth 在 2015 年的 .NET 博客中发布的消息（[https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/](https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/））中所述，评论道：“*依赖注入容器在
    .NET 中已经持续成熟和显著发展。此外，开源组件现在被更广泛地接受。拥有来自 Microsoft 的“官方”容器不再是像以前那样普遍的需求了。*”
- en: That said, Unity is still a very common feature in thousands of projects, and
    it has reached version 4.01, which you can install inside any project using the
    `NuGet Package Manager` available from the contextual menu of the `Solution Explorer,`
    or the `Project` menu as well, either in V. Studio 2017 or other versions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Unity 仍然是成千上万个项目中非常常见的功能，并且已经达到了 4.01 版本，你可以在任何项目中使用 `NuGet 包管理器` 安装它，该管理器可通过解决方案资源管理器的上下文菜单或项目菜单访问，无论是在
    V. Studio 2017 还是其他版本。
- en: 'Once installed, you''ll see that it really references two different libraries:
    Unity 4.01 and the CommonServiceLocator 1.30 library, as you can see in the following
    screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你会发现它实际上引用了两个不同的库：Unity 4.01 和 CommonServiceLocator 1.30 库，如下截图所示：
- en: '![](img/e4df937a-fc0a-47b4-b4d9-00d687b67d88.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4df937a-fc0a-47b4-b4d9-00d687b67d88.png)'
- en: 'Once installed, you''ll see four new references to DLL''s in the Solution''s
    Explorer: three of them belong to Unity and the fourth one to `CommonServiceLocator`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你会在解决方案资源管理器中看到四个新的 DLL 引用：其中三个属于 Unity，第四个属于 `CommonServiceLocator`：
- en: '![](img/f14847a3-8bd7-45c7-a3cd-d7c267bc37c3.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f14847a3-8bd7-45c7-a3cd-d7c267bc37c3.png)'
- en: Inside the `Microsoft.Practices.Unity.Configuration` library, you have utilities
    that allow writing the configuration required in an XML file, so that it serves
    as the initial settlement for the DI Container. Classes in that namespace will
    allow you to read and configure a given execution context based on that XML.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Microsoft.Practices.Unity.Configuration`库内部，您有工具允许您在XML文件中编写所需的配置，这样它就充当DI容器的初始设置。该命名空间中的类将允许您根据该XML读取和配置给定的执行上下文。
- en: On the other side, the `Microsoft.Practices.Unity.RegistrationByConvention`
    library is intended to provide a programmable way of configuration to register
    multiple types with the container automatically by using a set of rules and conventions,
    as the official documentation defines ([https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx](https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，`Microsoft.Practices.Unity.RegistrationByConvention`库旨在提供一种可编程的配置方式，通过使用一系列规则和约定，自动将多个类型与容器注册，正如官方文档所定义的([https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx](https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx))。
- en: 'Now, if we just want to register those classes belonging to our Business Layer
    and Data Access Layer, the most evident way to include all elements in our business
    model and have our data ready, would be something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只想注册属于我们的业务层和数据访问层的类，那么将所有元素包含在我们的业务模型中并使我们的数据准备就绪的最明显的方法可能如下所示：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice, however, that we're defining `BookManager` together with `XMLBookReader`
    and `JSONBookReader`. This means that if we run the code, we get an instance of
    the last registered class (`JSONBookReader`), which becomes the default option.
    The reason is that we're not naming these registrations, so they're assigned unnamed
    identifiers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，我们正在定义`BookManager`与`XMLBookReader`和`JSONBookReader`一起。这意味着如果我们运行代码，我们将得到最后一个注册的类的实例（`JSONBookReader`），它成为默认选项。原因是我们没有命名这些注册，因此它们被分配了未命名的标识符。
- en: You can test the demo inside `Chapter02_02.Unity` namespace and insert breakpoints
    to prove it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter02_02.Unity`命名空间内的演示中进行测试，并设置断点以证明它。
- en: To reproduce the initial situation in which the user selects the format, we
    need to register distinct aliases for registered types, so they can be resolved
    at runtime, passing the concrete version that we need.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重现用户选择格式的初始情况，我们需要为注册的类型注册不同的别名，以便它们可以在运行时解析，传递我们需要的具体版本。
- en: 'Besides that, notice that Unity plays the role that was previously playing
    the `BookManager` class. So in this case, we don''t need the `BookManager` class
    anymore:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，Unity扮演着之前由`BookManager`类扮演的角色。因此，在这种情况下，我们不再需要`BookManager`类：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, Unity resolves the dependency with the parameter we pass to the `Resolve()`
    method, as we can see it by setting a breakpoint in this line, or simply, watching
    the output.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Unity通过我们传递给`Resolve()`方法的参数解决依赖关系，正如我们可以通过在此行设置断点或简单地观察输出所看到的那样。
- en: 'The `UnityContainer` class admits alternative registration mechanisms. For
    example, we could use a new business layer class entirely dedicated to Unity registration,
    with the following code (notice that we should reference `Microsoft.Practices.Unity`
    in the `using` section of our code):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnityContainer`类接受替代注册机制。例如，我们可以使用一个完全致力于Unity注册的新业务层类，以下代码（注意我们应在代码的`using`部分中引用`Microsoft.Practices.Unity`）：'
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this manner, all classes from the loaded assemblies are registered for Unity,
    all mappings (or correspondences) are defined between the existing interfaces
    and their implementing classes, their default names are used and their lifetime
    is assigned to be managed by the container, so it's the container itself which
    decides at runtime when to leave object's instances to the Garbage Collector.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，所有从加载的组件中加载的类都将注册到Unity中，所有现有接口及其实现类之间的映射（或对应关系）都得到了定义，使用它们的默认名称，并将它们的生存期分配给容器管理，因此容器本身在运行时决定何时将对象实例留给垃圾回收器。
- en: Using Castle Windsor
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Castle Windsor
- en: One of the winners in benchmarks and usability tests, Castle Windsor has been
    around for quite some time, and now rallies all activities around its dedicated
    GitHub project site at [https://github.com/castleproject/Windsor.](https://github.com/castleproject/Windsor)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试和可用性测试中获胜的赢家之一，Castle Windsor已经存在一段时间了，现在它将所有活动都聚集在其专门的GitHub项目网站上[https://github.com/castleproject/Windsor.](https://github.com/castleproject/Windsor)
- en: 'The community around this project is very active and, at the time of writing
    these lines, has more than 500 stars and 265 forks, and they were preparing to
    release version 3.4\. Of course, you can download it and install it separately,
    or use `NuGet` and have it installed for your project in the usual manner:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目周围的社区非常活跃，在撰写这些行的时候，已经有超过500个星标和265次分支，他们正在准备发布3.4版本。当然，你可以单独下载并安装它，或者使用`NuGet`以通常的方式为你的项目安装它：
- en: '![](img/c227ceb1-14f2-4b9c-9a8f-425c8c373af2.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c227ceb1-14f2-4b9c-9a8f-425c8c373af2.png)'
- en: 'The process of installation really installs two components: Castle.Core 3.3
    and Castle.Windsor 3.4\. Both work together, although they include several namespaces
    to cover many of the possible programming situations in which we might need dependency
    injection (and other features).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程实际上安装了两个组件：Castle.Core 3.3和Castle.Windsor 3.4。它们共同工作，尽管它们包含了几个命名空间，以覆盖我们可能需要依赖注入（以及其他功能）的许多可能的编程场景。
- en: Castle Windsor's API set is very rich in possibilities and the documentation
    in the official site lets you start quickly with some samples (see [https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md](https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Castle Windsor的API集在可能性上非常丰富，官方网站上的文档让你可以通过一些示例快速开始（见[https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md](https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md)）。
- en: 'For our demo, we only have to reference those namespaces required to initialize
    the `WindsorContainer` class and proceed with the registration:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们只需要引用初始化`WindsorContainer`类所需的命名空间，然后进行注册：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first one allows the creation of a new `WindsorContainer` class, while
    the other defines the required classes for registration. The whole process is
    similar to the one we saw previously with Unity:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个允许创建一个新的`WindsorContainer`类，而另一个定义了注册所需的类。整个过程与我们之前看到的Unity类似：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how the Component class includes static, generic methods to allow definitions
    of any interface (`IBookReader`, here), and you can concatenate successive calls
    to indicate which class implements what interface and what name that we want to
    assign to each registration, so it can be solved at runtime later on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到组件类包含了静态、泛型方法，允许定义任何接口（例如这里的`IBookReader`），并且你可以通过连续调用来表示哪个类实现了什么接口以及我们想要为每个注册分配的名称，这样可以在运行时解决。
- en: Once the registration is completed, the way to resolve it in a concrete implementation
    accepts a format that is identical to the one we used with Unity.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，在具体实现中解析它的方式接受一个与我们之前使用Unity时相同的格式。
- en: The code just runs exactly the same as in the previous demo.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一个演示完全相同。
- en: Using StructureMap
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用StructureMap
- en: 'The official site for this DI container defines precisely the differences and
    spirit behind this implementation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个DI容器的官方网站精确地定义了这种实现背后的差异和精神：
- en: '`StructureMap` is the oldest, continuously used IoC/DI container for .NET dating
    back to its first public release and production usage all the way back in June
    2004 on .NET 1.1\. The current 4\. release represents 12+ years of lessons learned
    in the StructureMap and greater .NET community--while also wiping away a lot of
    legacy design decisions that no longer make sense today.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`StructureMap`是.NET中最早的、持续使用的IoC/DI容器，可以追溯到2004年6月的第一次公开发布和生产使用，当时是.NET 1.1。当前的4.0版本代表了StructureMap和更大的.NET社区12+年的经验教训--同时也摒弃了许多不再有意义的旧设计决策。'
- en: So, we're dealing with a veteran here, and that means stability, together with
    a wide presence in internet forums and coder's sites, like `StackOverflow`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里处理的是一个老手，这意味着稳定性，以及广泛的互联网论坛和开发者网站上的存在，如`StackOverflow`。
- en: 'The philosophy that lies behind usage and configuration is quite similar to
    the other two we''ve already seen, but it offers several ways to configure the
    application. As the official documentation states to this respect: "*from release
    3.0 onwards, StructureMap provides a streamlined fluent interface called the Registry
    DSL to configure a StructureMap Container with both explicit registrations and
    conventional auto-registrations.StructureMap no longer supports XML configuration
    or MEF-style attribute configuration -- but there is some facility for rolling
    your own attribute-based configuration support.*"'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference is that it recommends a configuration approach via lambda
    expressions, but still with similar mechanisms, as you can see in the following
    code used to create and configure the Container object in the same operation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The other main choice relies on creating a `Registry` object and then configuring
    the container based on it. Something like the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All this depends on the architecture and complexity of the application to build.
    For our demo purposes, we will first reference the library (this time there is
    only one namespace), via NuGet, that presents this installation option:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10aa6b00-9d5f-4a77-a005-05e3df34616a.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'And, for a basic configuration and usage, we only need to reference the basic
    `StructureMap` namespace:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The source code equivalent to the previous demos would be (with identical results
    in execution):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice how the container is configured by passing a lambda expression to the
    newly created instance of Container and, within the body expression, we use the
    following pattern:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding pattern allows us to express as many registrations as we want
    in a single operation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s only a slight variation in the way the `IBookReader` instance is obtained
    because it doesn''t use the resolve paradigm. In turn, we can find several methods
    of resolving instances, as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad0131e3-88bb-425f-a68b-a9e50357654d.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Of course, execution is the same as in the other cases and there is nothing
    really relevant in the output, which you can find in the source code for `Chapter02_02.StructureMap`
    demo.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Using Autofac
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll finish this short visit over .NET containers examining the basics of AutoFac,
    another DI Container well known in the community, and that claims to be up-to-date
    with versions that cover .NET Core, ASP.NET Core, Universal Windows Apps, and
    .NET Framework 4.5.1 and later versions. It also allows support for WCF-based
    applications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: It has its own dedicated site ([https://autofac.org/](https://autofac.org/))
    which serves as the starting point, although it is also referenced via `NuGet`
    packages. Besides this, you will find references to several libraries, some specialized,
    in this page or NuGet.org at [https://www.nuget.org/packages/Autofac/.](https://www.nuget.org/packages/Autofac/)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to keep on using `NuGet` from Visual Studio, you should find
    the following reference, once you search for Autofac in the NuGet package editor:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定继续在Visual Studio中使用`NuGet`，你应该在NuGet包编辑器中搜索Autofac时找到以下参考：
- en: '![](img/a4622db5-fe37-4b33-a89d-fc3cf4d6d10c.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4622db5-fe37-4b33-a89d-fc3cf4d6d10c.png)'
- en: The standard architecture is similar to the other three we've already seen,
    with minor differences. For example, the container here is named `ContainerBuilder`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 标准架构与我们已经看到的另外三个类似，有一些细微的差别。例如，这里的容器被命名为`ContainerBuilder`。
- en: After its instantiation, we have to configure the required types and interfaces
    and, finally, we should call to the `Build()` method of the `ContainerBuilder`
    to have everything ready.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化之后，我们必须配置所需的类型和接口，最后，我们应该调用`ContainerBuilder`的`Build()`方法，以确保一切准备就绪。
- en: 'Although we might use an approach similar to the other demos, in this case,
    we decided to inject only the version chosen by the user. This can be easily accomplished
    with the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能使用与其他演示类似的方法，但在这个案例中，我们决定只注入用户选择的版本。这可以通过以下代码轻松实现：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In short, we have many options regarding IoC containers, and many choices about
    the way to configure them, but all of them provide us with similar functionality:
    we can abstract dependencies that are resolved at a later time.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们在IoC容器方面有很多选择，并且在配置它们的方式上也有很多选择，但它们都为我们提供了类似的功能：我们可以抽象出在以后时间解决的依赖项。
- en: Of course, in this and other cases we could opt for other forms of configuration,
    like using XML or JSON files and also use more complex configuration classes to
    support all possible situations that our application requires.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，我们也可以选择其他形式的配置，比如使用XML或JSON文件，还可以使用更复杂的配置类来支持我们应用程序所需的任何可能的情况。
- en: 'Although this is only an introduction to IoC containers, if you are interested
    in these APIs, you will see that it is possible to handle the three aspects discussed
    at the beginning: Object Composition, Object Lifetime, and Interception.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个关于IoC容器的介绍，但如果你对这些API感兴趣，你会发现可以处理最初讨论的三个方面：对象组合、对象生命周期和拦截。
- en: Dependency Injection in other frameworks
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他框架中的依赖注入
- en: .NET or Java are not the only programming environments in which we can find
    Dependency Injection containers. Many of the most popular JavaScript frameworks
    also support DI from its inception. This is the case for AngularJS.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: .NET或Java并不是唯一可以找到依赖注入容器的编程环境。许多最流行的JavaScript框架也从一开始就支持DI。AngularJS就是这种情况。
- en: DI in Angular
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的DI
- en: 'AngularJS (1.x) and Angular (2.x, 4.x, etc) are perhaps the most popular frameworks
    for JavaScript applications in use today. They are pretty different in their programming
    model and general purpose, so I will distinguish them both:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS (1.x) 和 Angular (2.x, 4.x等) 可能是当今使用最广泛的JavaScript应用程序框架。它们在编程模型和通用目的上相当不同，所以我会区分它们两个：
- en: '![](img/c9990bd7-3496-422d-91c2-305e39ce312b.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9990bd7-3496-422d-91c2-305e39ce312b.png)'
- en: 'Angular frameworks are the result of a Google teamwork lead by Misko Hevery,
    Igor Minar, and Brad Green, which initially appeared in 2010\. The project has
    bifurcated into two distinct branches: AngularJS 1.x for small/medium projects
    and Angular 2 (or just Angular) which is intended to cover the needs of big/complex
    projects and uses TypeScript as the programming language due to its strongly typed
    nature.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架是Google团队Misko Hevery、Igor Minar和Brad Green领导的项目成果，最初于2010年出现。该项目已分为两个不同的分支：AngularJS
    1.x用于小型/中型项目，Angular 2（或简称Angular）旨在满足大型/复杂项目的需求，并由于其强类型特性而使用TypeScript作为编程语言。
- en: In December 2016, they announced the adoption of a semantic versioning approach,
    together with a continuous delivery roadmap that will publish a new version every
    six months, very careful of breaking changes. The latest version is Angular 4,
    which appeared in March 2017, and is totally backward compatible with Angular
    2.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年12月，他们宣布采用语义版本控制方法，并制定了一个持续交付路线图，每六个月发布一个新版本，非常注意避免破坏性变更。最新的版本是2017年3月出现的Angular
    4，它与Angular 2完全向后兼容。
- en: 'Both projects are also maintained by Google and, despite their different programming
    models and language, they share a few things in common: They promote the **Single
    Page Application** (**SPA**) model, and they use a **Model-view-controller** (**MVC**)
    architecture to provide a suitable separation of responsibilities from the first
    moment.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个项目也由 Google 维护，尽管它们的编程模型和语言不同，但它们有一些共同之处：它们都推广 **单页应用程序**（SPA）模型，并且使用 **模型-视图-控制器**（MVC）架构来提供从第一刻起的责任分离。
- en: AngularJS presents itself as a bunch of libraries so the user can choose only
    the ones needed for a given purpose, achieving that way a better granularity.
    All libraries are available via GitHub, NuGet, NPM, Bower, and so on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 以一系列库的形式呈现，用户可以选择特定目的所需的库，从而实现更好的粒度。所有库都可通过 GitHub、NuGet、NPM、Bower
    等方式获取。
- en: Our first demo
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一次演示
- en: Let's get down to work with our first demo, and, from this initial approach,
    we will test how AngularJS provides an excellent, integrated dependency injection
    system, that facilitates programmers' work to a large extent.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一次演示，并从这个初始方法中，我们将测试 AngularJS 提供的出色、集成的依赖注入系统，这在很大程度上简化了程序员的开发工作。
- en: By the way, we can use any IDE to work with Angular, since the three languages
    implied (two in case we don't care about the visual aspects provided by CSS) are
    just HTML and JavaScript.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们可以使用任何 IDE 来与 Angular 一起工作，因为涉及到的三种语言（如果不考虑 CSS 提供的视觉方面，则是两种语言）只是 HTML
    和 JavaScript。
- en: However, I'll keep on using Visual Studio, which has a very good support for
    Angular programming and provides native Intellisense on Angular directives, and
    a pretty good debugging experience.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我将继续使用 Visual Studio，它对 Angular 编程有非常好的支持，并提供原生 Intellisense 功能，以及对 Angular
    指令的相当不错的调试体验。
- en: So, let's start a new project or a new website (we don't need any compiled libraries).
    We can choose an Empty Project in the ASP.NET section. This creates a project
    with only a `web.config` file in case we need to configure the **Internet Information
    Server** (**IIS**).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始一个新的项目或一个新的网站（我们不需要任何编译的库）。我们可以在 ASP.NET 部分选择一个空项目。这会创建一个只包含 `web.config`
    文件的项目，以防我们需要配置 **互联网信息服务**（IIS）。
- en: Inside the project, we'll create a new HTML file, and once the project is saved
    we can add the Angular libraries in the usual manner, via the `NuGet Package Manager`.
    We should see that AngularJS is now in versions 1.6.x or higher (we should select
    Angular.Core for this demo, which is the basic module).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，我们将创建一个新的 HTML 文件，一旦项目保存，我们就可以以通常的方式添加 Angular 库，通过 `NuGet 包管理器`。我们应该看到
    AngularJS 现在是 1.6.x 或更高版本（我们应该选择 Angular.Core 用于此演示，这是基本模块）。
- en: Once we accept the installation, we'll see a new `Scripts` folder containing
    the development (`angular.js`) and deployment (`angular.min.js`) versions of Angular
    1.6, plus a Mock library for testing purposes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们接受安装，我们将看到一个包含 Angular 1.6 的开发（`angular.js`）和部署（`angular.min.js`）版本的 `Scripts`
    文件夹，以及用于测试目的的模拟库。
- en: We just have to include the development library and create the minimum required
    plumbing to see Angular in action--just by including the library, some objects
    and services are loaded into memory and ready to go.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要包含开发库并创建所需的最小管道，就可以看到 Angular 的实际应用——只需包含库，一些对象和服务就会被加载到内存中并准备就绪。
- en: Especially, there is a `$injector` object that will take care of retrieving
    object instances, instantiate types, load modules and invoke methods.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是存在一个 `$injector` 对象，它会负责检索对象实例、实例化类型、加载模块和调用方法。
- en: 'Also, Angular creates an initial, basic model which serves as the root model
    for the application ($rootScope), and expects that the user marks an HTML element
    as the scope of the app. We''ll do that in the `<body> tag`, name it `app`, and
    define a module with the same name, with the following syntax:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular 创建了一个初始的基本模型，作为应用程序的根模型（$rootScope），并期望用户将一个 HTML 元素标记为应用程序的作用域。我们将在
    `<body>` 标签中这样做，命名为 `app`，并使用以下语法定义一个具有相同名称的模块：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice we use an Angular-specific attribute (`ng-app`) to mark the scope of
    our application. These attributes are called directives in Angular and they allow
    us to modify the DOM to suit our needs (All predefined directives start with `ng-`).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用 Angular 特定的属性（`ng-app`）来标记应用程序的作用域。这些属性在 Angular 中被称为指令，它们允许我们修改 DOM
    以满足我们的需求（所有预定义的指令都以 `ng-` 开头）。
- en: Now, we want our page to show the local time when it loads in the browser. The
    angular mode to do this is to select a target area of the DOM and assign a controller
    to that area. We can do that including the `ng-controller` directive inside the
    corresponding tag.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望我们的页面在浏览器加载时显示本地时间。在 Angular 中实现这一点的模式是选择 DOM 的一个目标区域，并将控制器分配给该区域。我们可以通过在相应的标签中包含
    `ng-controller` 指令来实现这一点。
- en: As you can see in the code, next to the page's title we've included a `<h3>`
    tag to hold that information, and inside that tag's text, a message, followed
    by `{{ time }}`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在代码中所见，在页面标题旁边，我们包含了一个 `<h3>` 标签来包含该信息，在该标签的文本中，一个消息，后面跟着 `{{ time }}`。
- en: 'The double brackets syntax is one of the possible binding mechanisms that Angular
    uses to link data inside the model with the active view, and it''s called **moustache
    syntax**. Thus, we modify the tag in this way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 双大括号语法是 Angular 使用的一种可能的绑定机制，用于将模型内部的数据与活动视图链接起来，它被称为**胡子语法**。因此，我们以这种方式修改标签：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we have a `ng-controller` directive named `TimeController`, that we need
    to define inside the script. Controllers are defined by calling the app's main
    module, that we previously created, and passing a function as the second argument
    that will be in charge of the logic linked to that controller.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为 `TimeController` 的 `ng-controller` 指令，我们需要在脚本中定义它。控制器是通过调用我们之前创建的应用程序主模块来定义的，并将一个函数作为第二个参数传递，该函数将负责与该控制器相关的逻辑。
- en: And, here, we finally get to the Dependency Injection mechanism of AngularJS.
    This function should have access to the specific model created by Angular to hold
    the information managed by the controller. We do that via the `$scope` object.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于来到了 AngularJS 的依赖注入机制。这个函数应该能够访问 Angular 创建的特定模型，以存储控制器管理的信息。我们通过 `$scope`
    对象来实现这一点。
- en: Every controller has its own $scope (it's like a sub-model), which allows read/write
    operations in memory and permits binding between the moustache expressions in
    the DOM and data stored in that model.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器都有自己的 `$scope`（它就像一个子模型），这允许在内存中进行读写操作，并允许在 DOM 中的胡子表达式和该模型中存储的数据之间进行绑定。
- en: 'So, how does the user code access to that (or any other) service? Via DI, of
    course. The final code is surprisingly simple:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，用户代码是如何访问那个（或任何其他）服务的呢？当然是通过依赖注入。最终的代码非常简单：
- en: '[PRE34]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you see, the controller's definition receives a string to identify the controller's
    name, and an anonymous function, to hold the functionality linked to that controller.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，控制器的定义接收一个字符串来标识控制器的名称，以及一个匿名函数，用于包含与该控制器相关的功能。
- en: 'And, in that function, we just declared the $scope object: the Angular''s injection
    system takes care of the rest. In the next line of code, we can use that object,
    with a total guarantee of its existence. Even further, Angular provides services
    and objects of this type using a Singleton approach, so there''s no other $scope
    at the same time.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数中，我们只声明了 `$scope` 对象：Angular 的注入系统负责其余部分。在下一行代码中，我们可以使用那个对象，并确保其存在。更进一步，Angular
    通过单例模式提供服务和此类对象，因此同一时间不会有其他的 `$scope`。
- en: 'Of course, the output is as expected, and every time we reload the page, the
    current time is updated:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输出是预期的，并且每次我们重新加载页面时，当前时间都会更新：
- en: '![](img/bee9dac8-f393-4913-ae28-2b7d0891382c.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bee9dac8-f393-4913-ae28-2b7d0891382c.png)'
- en: This philosophy is extended to any AngularJS object or service and even to those
    services that the user might want to create.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理念扩展到任何 AngularJS 对象或服务，甚至扩展到用户可能想要创建的服务。
- en: In Angular (modern versions), the architecture is similar, only that it uses
    TypeScript and the preferred way for DI is the constructor-injection model we
    saw in other demos, given that TypeScript is a totally object-oriented language.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular（现代版本）中，架构类似，只是它使用 TypeScript，并且首选的依赖注入方式是我们在其他演示中看到的构造函数注入模型，因为 TypeScript
    是一种完全面向对象的编程语言。
- en: In [Chapter 10](48b807a5-dcd8-479d-b71b-670d93f20cc8.xhtml), *Dependency Injection
    in Other JavaScipt Frameworks*, we'll cover Dependency Injection in JavaScript
    (ES6, or ES 2015, to be precise), TypeScript and Angular 2, so you can have a
    wider sight of today's implementations of DI in modern web frameworks.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章](48b807a5-dcd8-479d-b71b-670d93f20cc8.xhtml)《其他 JavaScript 框架中的依赖注入》中，我们将介绍
    JavaScript（ES6，或 ES 2015，更确切地说）和 TypeScript 以及 Angular 2 中的依赖注入，这样您可以对现代 Web 框架中依赖注入的当前实现有更广泛的了解。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have focused on the principles and advantages of Dependency
    Injection, and how to implement it in C# starting from a very simple application
    and modifying it to achieve decoupling of classes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于依赖注入的原则和优势，以及如何从一个非常简单的应用程序开始，通过修改它来实现类之间的解耦。
- en: 'Once we saw the foundations of DI, we''ve covered briefly three programming
    aspects that influence the way these techniques are applied: Object Composition,
    Object Lifetime, and Interception, as a first approach that we''ll cover in more
    detail in further chapters.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了DI的基础，我们就简要地涵盖了三个影响这些技术应用的编程方面：对象组合、对象生命周期和拦截，这是我们将在后续章节中更详细地探讨的第一个方法。
- en: And, finally, we've seen how some popular IoC containers implement these concepts,
    together with a brief introduction to its use in other frameworks, like AngularJS.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了一些流行的IoC容器如何实现这些概念，以及对其在其他框架（如AngularJS）中应用的简要介绍。
- en: In [Chapter 3](087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml), *Introducing Dependency
    Injection in .NET Core 2.0*, we will begin the study of the most interesting features
    about Dependency Injection included in .NET Core.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml)，《.NET Core 2.0中的依赖注入介绍》中，我们将开始研究.NET
    Core中包含的关于依赖注入的最有趣的功能。
