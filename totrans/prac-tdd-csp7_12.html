<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Legacy Problem</h1>
                
            
            
                
<p class="calibre2">This chapter is all about legacy code. If you have never had to deal with legacy code, count yourself lucky and know that it is coming. Some of you may be permanently stuck in maintenance development. Your life is legacy code. Whatever the situation, this chapter is all about dealing with legacy code. We want to either prevent legacy code from happening, or fight it back to the depths from which it came. </p>
<p class="calibre2">In this chapter, we discuss:</p>
<ul class="calibre7">
<li class="calibre8">What makes code legacy</li>
<li class="calibre8">The issues that legacy code can create</li>
<li class="calibre8">How legacy code can inhibit testing</li>
<li class="calibre8">What we can do to deal with and fight back against the legacy problem</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What is legacy code?</h1>
                
            
            
                
<p class="calibre2">Most of you have probably had to work on a dreaded legacy project. Working on that project is no fun; the code is a mess, and you want to find whoever wrote it and find out what they were thinking when they wrote it.</p>
<p class="calibre2">At some point in your career, you have been or will be that person to someone else. We all write code that we will not be proud of later. But why does the code get so bad? When does a project become legacy? Lastly, what can be done to prevent this?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Why does code go bad?</h1>
                
            
            
                
<p class="calibre2">In short, code goes bad because we are afraid to change it. Why would the code not changing cause it to be bad? You would hope that, when the code was written, it was the best code that developer was capable of producing at the time. So, that code should have been good, right? This is a complicated answer, but assume, for the moment, that the code was something to be proud of when it was originally written. That still begs the question, how did it go bad?</p>
<p class="calibre2">The answer is staring you in the face. The only reason you are seeing this code is because it needs to change. Chances are, you are not the first person that has needed to make a change in this code. So, this is not the code that was written by a developer doing his or her best to write good code. This code was written by many developers. Still, each of those developers should have been doing their best to write good code. So, again, how did this code go bad?</p>
<p class="calibre2">This is where the fear comes in, because we are afraid to change the code. When we have to change it, we generally try to change the code as little as possible to get the requested update working. After all, we don't want to force ourselves or QA to do a full regression test because we refactored the whole thing, do we? So, we modify the code; we change the way it is expected to work. But we can't change the structure, and we can't modify the decisions of the developer who originally wrote the code.</p>
<p class="calibre2">Over time, making these small changes and being afraid to modify the structure and architectural decisions of the original developer causes severe code rot. Soon, the code will have massive conditional statements and methods that no longer fit on the page. The class containing the code will grow to tens of methods and the file will be thousands of lines long.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">When does a project become legacy?</h1>
                
            
            
                
<p class="calibre2">This is a question that is answered by many people in many different ways. Generally, an application has become legacy when no one wants to work on it anymore.</p>
<p class="calibre2">In the beginning, applications are built with a small and defined purpose. Over time, the scope and breadth of a system may grow beyond its original intent. When any change to the application causes the developer to work against what the application was designed for, it will cause friction.</p>
<p class="calibre2">As mentioned previously, the application design is not simply changed because of the fear a developer might have that the application will break. So, more and more cruft is added to the system. Okay, so how long does it take for this to happen? When do we stop hacking new modifications into the existing application and just rewrite it?</p>
<p class="calibre2">Honestly, the cruft starts getting added by the original developer as he or she is writing the application for the first time. When you start to work on a new application, or even just a new feature in an existing application, you start with a preliminary design in mind. Everyone does this. Some developers whiteboard the design or make complete <strong class="calibre1">UML</strong> (<strong class="calibre1">Unified Modeling Language</strong>) diagrams. Other developers just have an idea in their head to guide decisions. Either way, you have a design you want when you sit down to develop an application.</p>
<p class="calibre2">How long is it before you discover an issue with your design and have to start modifying it? You might get one line of code in before you have to change your design, or you might get 75% of the way through before you discover an issue. This is largely determined by the complexity of the problem you are solving and how detailed your planning was. Regardless of the thoroughness of your planning, you will find an issue and have to start changing your design before the first QA review.</p>
<p class="calibre2">The second you make that change, you are adding cruft, so almost all of the time, you are working in a system that was not designed for the code that is being forced into it. In other words, you will probably be writing legacy code the next time you are at work, even if you are working on a new application.</p>
<p>Cruft, in software, is any code that is unnecessary or needlessly complex.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What can be done to prevent legacy decay?</h1>
                
            
            
                
<p class="calibre2">There must be something that can be done to prevent this decay, right? The answer is probably predictable, given the topic of this book. But let me answer with a quote from Michael Feathers on the definition of legacy code:</p>
<p>To me, legacy code is simply code without tests. </p>
<p>- Michael Feathers, Working Effectively with Legacy Code</p>
<p class="calibre2">As we discussed in earlier chapters, tests allow you to refactor. The ability to change the structure of the code is precisely what can prevent the rot and decay that is legacy code.</p>
<p class="calibre2">While tests can allow you to prevent legacy code from forming, be aware that they themselves do not prevent the legacy problem. It takes the dedication of every person on the team understanding that building cruft into a system is a negative behavior and must be avoided. If you feel yourself working against the design of the system, then it is your responsibility to refactor the application into a design that works for today's needs and is flexible enough for tomorrow's needs.</p>
<p class="calibre2">Making a system flexible is not as hard as you might think. Following the SOLID principles (discussed in <a target="_blank" href="part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 3</a>,  <em class="calibre12">Setting up a JavaScript Environment</em>) will help to produce a maintainable and flexible system. Even with a flexible system, it takes discipline and determination to maintain a standard of recognizing and fixing friction in the application.</p>
<p class="calibre2">The process of finding that friction could be considered <strong class="calibre1">PDD</strong> (<strong class="calibre1">Pain Driven Development</strong>). This concept means to do the simplest thing to solve your existing problem and actively recognize any friction that arises during future modifications to the application.</p>
<p class="calibre2">PDD can be applied to any system, including the application, your team, and your personal life. Following this strategy, you will become obsessed with removing friction in all things, and can get a little carried away. So, it is important to keep in mind that you might be the only one looking for this friction, and the rest of the world might be ignorant to the pain they are causing themselves. Also, keep in mind that people do not, generally, enjoy having their ignorance pointed out.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Typical issues resulting from legacy code</h1>
                
            
            
                
<p class="calibre2">There is a reason we fear working on legacy code. But, what is it that we fear when working on legacy code? It's not the code itself; the code cannot harm us. Instead, what we fear is hearing that we have introduced a bug. The most dreaded word that a developer can hear. A bug means that we have failed and that we will have to work on the legacy code again.</p>
<p class="calibre2">Exploring the types of issues we might run into while working on legacy code, we find several. Firstly, because we don't know the code, a change to one part might cause unintended side effects in a different part of the application. Another issue is the code could be over-optimized or written by someone who was trying to be clever when they wrote it. Lastly, tight coupling can make updating the code difficult.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Unintended side effects</h1>
                
            
            
                
<p class="calibre2">With all the changes that push an application towards the legacy realm, often the methods or functions in the application will be used in unexpected places, far away from the code that you are changing.</p>
<p class="calibre2">There are two primary violations of the SOLID principles that have led to this issue, and the same two can help you to avoid it going forward. The first is the <strong class="calibre1">OCP</strong> (<strong class="calibre1">Open Closed Principle</strong>), and the second is the <strong class="calibre1">LSP</strong> (<strong class="calibre1">Liskov Substitution Principle</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Open Closed Principle and legacy code</h1>
                
            
            
                
<p class="calibre2">As discussed previously, the Open Closed Principle states that code should be open for extension yet closed for modification. This principle is designed to prevent the issues with legacy code.</p>
<p class="calibre2">If the modification that has been requested of you is one that will change the behavior of a specific piece of the application, then try to instead clone the method in question and modify the clone. Then the part of the application that needs the change can call the clone instead. This will prevent the change from affecting any parts of the application except the parts you are intending to affect.</p>
<p class="calibre2">Until we know for sure that the code we just avoided is not being used elsewhere in the application, we can't delete it. Eventually, once we are sure that the old code is truly orphaned and not used, we want to clean up and delete the unused method to maintain a code base with just a little less cruft.</p>
<p class="calibre2">On the other hand, if the change is for a bug, then the fix is a little more complicated. You must first determine whether the bug should be fixed everywhere that this code might be used, or whether the bug is relative only to a specific portion of the application. When in doubt, fall back to cloning the method and only affecting intentional parts of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Liskov Substitution Principle and legacy code</h1>
                
            
            
                
<p class="calibre2">How do you determine whether change should affect the entire application or just a slice? One way is to employ the LSP. Simply put, LSP says that a class should do what it sounds like it does. Any behavior change that would change that should be a different dependency.</p>
<p class="calibre2">That is, any change that changes behavior should probably be a new method or a new class with the appropriate method in it. This will prevent accidental side effects in the rest of the application and keep your code cleaner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Over-optimization</h1>
                
            
            
                
<p class="calibre2">It has been said that premature optimization is a bad thing. What is optimization, though? Generally, to optimize is to reduce the number of steps from point A to point B. In a computer program, that means to reduce the number of cycles required to compute a result.</p>
<p class="calibre2">An unfortunate side effect of optimizing code is that the code usually becomes much more difficult to read and comprehend. Optimizations tend to obfuscate the code in such a way that the only person who can understand it is the person who wrote it, and after some time, they may not be able to understand it either.</p>
<p class="calibre2">It is a fact that hard to understand code is code that is hard to change. This is the reason why optimizations that happen before they are needed are a bad thing.</p>
<p class="calibre2">So, when is an optimization needed? An optimization is needed when it is clear that the current implementation will not be able to meet the demands on the system within a reasonable timeframe in the future.</p>
<p class="calibre2">What makes a timeframe reasonable depends on the complexity of the needed optimization and the speed of the business. When a business is growing quickly, demand will follow along the same curve.</p>
<p class="calibre2">A slower moving company may require several months of planning and preparation before assigning work to a developer. In this situation, it is reasonable to plan for optimizations several months before they are needed. It is important to monitor the performance of an application so that these needs can be predicted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Overly clever code</h1>
                
            
            
                
<p class="calibre2">Most developers start writing code because they enjoy it. It is not common to find a developer that came into the field simply because they heard they could make lots of money. Working for a company writing the same boring code all the time can cause developers to want to have some fun once in a while.</p>
<p class="calibre2">When developers get bored, they come up with interesting and often overly complicated solutions that are simply not required. Sometimes, developers will come up with the cleverest solution they can figure out to solve a problem.</p>
<p class="calibre2">The problem with clever solutions is that to fix a problem, you have to be more skilled than the person who fixed it. So, if you write the cleverest code you can write, then you are no longer qualified to debug the code, and you bring your own, and everyone else's, progress to a halt.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tight coupling to third-party software</h1>
                
            
            
                
<p class="calibre2">Everyone uses some third-party plugin or library. In the software community, it is inevitable that you will have to depend on someone else's code. What you don't know when you use that code is the quality, stability, and ability to meet your future needs.</p>
<p class="calibre2">With that in mind, it is a bad idea to rely directly on the classes and interfaces presented to you by that third-party. Instead, use a hexagonal architecture, also known as ports and adapters. For anyone doing C#, this includes abstracting the .NET framework.</p>
<p class="calibre2">Any code that you and your team did not write should be abstracted to protect your code from the potential external changes. This includes code written at your company but by a different team. If it is outside your control, put it behind an abstraction. The preferred abstraction is one or more interfaces that provide the desired functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Issues that prevent adding tests </h1>
                
            
            
                
<p class="calibre2">Deadlines are tight. The scope is ever changing. We just don't have time to write tests. It's more important to get functionality out the door. We've all been there. Whatever the case may be, sometimes you will find yourself working on a project that was not written with testing in mind.</p>
<div><p class="calibre36">There never seems to be enough time to do it right, but there's always time to do it over.</p>
</div>
<p class="calibre2">So, what are the issues you might face that would prevent you from adding tests to a legacy application?</p>
<p class="calibre2">When a system wasn't written with testing in mind, it can be quite difficult to go back and add tests at a later date. Classes with concrete dependencies and tight coupling make software applications difficult to test. Things such as large classes and functions, Law of Demeter violations, global state, and static methods can also make for a system that can be very difficult to test.</p>
<p class="calibre2">Much like building a house by starting with a shaky foundation, untestable code begets untestable code. Unless pieces of the system can be decoupled from the rest of the application, the untestable trend will likely continue, and often does.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Direct dependence on framework and third-party code </h1>
                
            
            
                
<p class="calibre2">As was covered in a previous chapter, dependency on framework and third-party code makes for a tightly coupled system. Any time that the <em class="calibre12">new</em> operator in C#, for example, is invoked, then a direct dependency is made to that particular class. We want to minimize those dependencies as much as possible.</p>
<p class="calibre2">Remember that even framework dependencies should be avoided, or, at the very least, abstracted as much as possible. Think back to the <kbd class="calibre11">DateTime</kbd> example, where we were able to supply our own <kbd class="calibre11">DateTime</kbd> value for testing purposes in the sample application.</p>
<p class="calibre2">Any <kbd class="calibre11">using</kbd> or <kbd class="calibre11">import</kbd> statement at the top of a class or file should be carefully considered and avoided if at all possible. Instead, ensure that your code is dependent on an <em class="calibre12">interface</em> whose definition is directly under your control. That way, you can minimize the coupling and isolate the functionality within your own classes and methods. This will help you write cleaner, more testable code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Law of Demeter</h1>
                
            
            
                
<p class="calibre2">The Law of Demeter, in its simplest form, states that, <em class="calibre12">Each unit should have only limited knowledge about other units: only units "closely" related to the current unit</em>. Further, <em class="calibre12">Each unit should only talk to its friends; don't talk to strangers</em>. Simply put, <em class="calibre12">Only talk to your immediate friends</em>.</p>
<p class="calibre2">When a class or function has knowledge of the inner workings of something outside its immediate control, then there is some tight coupling happening there. In order to test a method that has one or more Law of Demeter violations, the amount of setup involved is often fairly substantial. In order to test a method of one class that violates the Law of Demeter, you must set up the other class or method, or provide a reasonable fake implementation in order to test effectively.</p>
<p class="calibre2">Remember, keep your test methods small and nimble so that they run quickly and are easy to understand. If you follow this rule, your production code will likely also be similarly simple and easy to follow. This will pay off in the long run, as it will be easier to maintain in the future.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Work in the constructor</h1>
                
            
            
                
<p class="calibre2">When a new instance of a class is created that has logic in the constructor, it is often very difficult to test that class. If, for some reason, you need to set up a test scenario that requires different values or behavior than that which is set up in the constructor, it will be quite difficult to proceed. It would be best to minimize the work done in the constructor and extract helper methods or some other scenario more easily tested and better implemented elsewhere.</p>
<p class="calibre2">Keep in mind that particular patterns may prove to be better alternatives to setting up a specific class or function. You should familiarize yourself with common software patterns and how to best implement them. This will help you grow an application by working to solve similar problems that have been resolved by others before you. By utilizing known software patterns, you can more easily communicate your intent with the code within the system.</p>
<p class="calibre2">The builder pattern, for example, might be employed to construct an object with the proper values set that would otherwise be added to the constructor.</p>
<p class="calibre2">Take the following example of the <kbd class="calibre11">Car</kbd> class:</p>
<div><pre class="calibre19">public Car(string make, string model, int doors)<br class="title-page-name"/>{<br class="title-page-name"/>  Make = make;<br class="title-page-name"/>  Model = model;<br class="title-page-name"/>  Doors = doors;<br class="title-page-name"/>}</pre></div>
<p class="calibre2">You could easily write a builder class to construct a specific type of car, such as a <kbd class="calibre11">ToyotaCamryBuilder</kbd> or <kbd class="calibre11">FordMustangBuilder</kbd>. Creating a new instance of either a Toyota Camry or a Ford Mustang would be quite easy, simple, and clean. Not to mention, it would be quite easy to test.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Global state</h1>
                
            
            
                
<p class="calibre2">Global state is prone to the side effects from parts of the application far away. These side effects will change the results of the code you run. Functional programming has caught on in recent years, as one of the tenants is to reduce side effects, as they can cause unpredictable and undesirable behavior in a system. Instead, you should strive to break down your code into what are known as pure functions. Pure functions take an input and produce an output. For any given input, the output will always be the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Static methods</h1>
                
            
            
                
<p class="calibre2">Static methods are not in and of themselves bad, but they do hint at a misplaced responsibility code smell. Static anything tells you that you have put the code in the wrong place. It doesn't share anything in common with the rest of the code in the scope and should probably be removed and put somewhere with its friends.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Large classes and functions </h1>
                
            
            
                
<p class="calibre2">Does class size really matter? What's the problem with having a large method or function? Large classes and functions often scream complexity. Remember the SOLID principles and what each letter in the acronym represents. A large class or method is likely violating one or more of the principles.</p>
<p class="calibre2">We want our classes and functions to be small and have only one reason to change (<em class="calibre12">Single Responsibility Principle</em>). A large class is likely hiding logic that can and should be broken into two or more separate and distinct classes. A large method or function likewise often hides two or more methods. Look for ways to keep your methods simple and keep an eye out for possible logical boundaries with which to break out smaller helpers, classes, and utilities.</p>
<p class="calibre2">Classes and functions should be divided and grouped logically. The purpose of a system should be easily understood by the names and groupings of the files associated with the application. The structure of the system should be simple and make sense to those in charge of enhancing and maintaining the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Dealing with legacy problems</h1>
                
            
            
                
<p class="calibre2">We have been discussing all the issues with legacy code. Now it is time to tackle solving those issues. The first thing we must do is bring sanity to the targeted legacy code, and then we can begin testing and eventually fix the code and bring it back from death.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Safe refactoring</h1>
                
            
            
                
<p class="calibre2">The term refactoring is often used incorrectly. When refactoring, you are merely changing the structure of the code. If the logic and/or signature of the code in question changes, then this does not qualify as refactoring. This is a change; most likely a breaking change.</p>
<p>If I'm changing the structure of the code (refactoring), then I don't ever change its behavior at the same time. If I'm changing the interface by which some logic is invoked, I never change the logic itself at the same time.</p>
<p>– Kent Beck</p>
<p class="calibre2">A safe refactoring is one that is guaranteed to not accidentally break the code. Other changes that aren't intended to actually change the behavior of the code but could do it accidentally are considered unsafe refactoring. These usually involve changes to the private areas of the code that aren't directly exposed to consumers of your application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Converting values to variables</h1>
                
            
            
                
<p class="calibre2">One of the first and easiest things that can be done is to extract any hard-coded values to be represented by variables. Having a variable allows for a quicker and more consistent update. It also helps to convey intent.</p>
<p class="calibre2">When creating the variables, make sure the name is descriptive enough for the scope of the variable. Variables with a short scope can have a short name. On the other hand, variables with a long scope must have a longer, more descriptive name. The further a variable is from its usages, the more descriptive it needs to be so that the context it represents isn't lost.</p>
<p class="calibre2">Check the scope of your variables and make sure they do not have a larger scope than is necessary. Also, check for variables that should have a larger scope but are instead passed between private methods instead of being class members.</p>
<p class="calibre2">It is not recommended at this time to update the private and protected methods that depend on variables that could be moved to a class scope. Instead, make note of them and move them around after tests have been added.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Extracting a method</h1>
                
            
            
                
<p class="calibre2">Working with legacy code often involves working with very large methods. A large method is any method that is longer than twenty lines. Preferably, methods are kept as small as possible, even down to just a few lines.</p>
<p class="calibre2">A large method can mean that the code is violating the Single Responsibility Principle. What needs to be done is to find the seams in the method. Seams can be found by commenting the different sections of the method. Once you have commented the sections, you have identified the seams.</p>
<p>Seam<br class="calibre44"/>
In code, this is the location where two pieces of business logic meet. Normally, you might refer to the location where the private method is called by a public method as a seam in the public method. The code has been stitched together at that location. In this case, there are no private methods, so we are identifying where we want the seams to be. </p>
<p class="calibre2">Each one of those seams is probably a lower order method that can be extracted. In most editors and IDEs, highlight the code you want and use the extract method refactoring provided through either a right-click, context, menu, or via the menu bar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Extracting a class</h1>
                
            
            
                
<p class="calibre2">Just like methods, sometimes a large method should really be a class. While extracting methods, if you extract three or more methods, then you have probably found a class that needs to be extracted.</p>
<p class="calibre2">Extracting a class is similar to extracting a method and is likely supported by your editor or IDE. Group and highlight the code you want to extract, then use the extract class menu option.</p>
<p class="calibre2">If your editor does not support extracting a class, all is not lost. Instead, highlight and cut all the methods you extracted that should be in the class. Create a new class file and paste those methods into the new class. Lastly, replace the calls to those methods in the original method with the instantiation and calling of the new class and methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Abstracting third-party libraries and framework code</h1>
                
            
            
                
<p class="calibre2">Now that we have variables, methods, and classes abstracted, it is time to abstract third-party libraries, framework code, and those classes we just created.</p>
<p class="calibre2">Firstly, let's start with framework details. Things like <kbd class="calibre11">DateTime</kbd>, <kbd class="calibre11">Random</kbd>, and <kbd class="calibre11">Console</kbd> are best hidden behind classes that you design to fit the needs of your application. There are several reasons for this; most importantly, putting these in their own classes will allow for testing. Without abstracting these to a separate class, it is almost impossible to test with things like <kbd class="calibre11">DateTime</kbd> that change values on their own.</p>
<p class="calibre2">Next up are the third-party libraries. Anywhere the code is calling to create a new class from a third-party, you need to abstract that to a new class specifically for the purpose of utilizing that third-party library. For the moment, replace the call that instantiates the third-party library with a call that instantiates your class.</p>
<p class="calibre2">Lastly, we can now deal with the calls to <kbd class="calibre11">new</kbd> that are left in the code. Everywhere that the code is calling <kbd class="calibre11">new</kbd> needs to be replaced with dependency injection. This will allow for testing and make the code cleaner and more flexible in the future.</p>
<p class="calibre2">To create the dependency injection without modifying the signature of the class, we will be using a pattern called poor man's dependency injection, also known as property injection. Below is an example of property injection in C#. The same process can be done in JavaScript with almost no modifications:</p>
<pre class="calibre19">public class Example<br class="title-page-name"/>{<br class="title-page-name"/>  private Injected _value;<br class="title-page-name"/>  public Injected Value<br class="title-page-name"/>  {<br class="title-page-name"/>    get =&gt; _value = _value ?? new Injected();<br class="title-page-name"/>    set =&gt; _value = value;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Using this pattern, it is possible to allow the class to create its dependency lazily, when asked for it. It is also possible to set the dependencies value for tests or other purposes. Although not shown in this quick example of the pattern, it is better to have the property and backing variable be of an interface type. This will make the injection of some other value easier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Early tests</h1>
                
            
            
                
<p class="calibre2">If an application of any significant size and complexity isn't properly segmented, it can be quite a daunting task to know how and where to begin writing tests. With a little practice in testing legacy systems it will become easier.</p>
<p class="calibre2">The <em class="calibre12">when</em> to write tests within a legacy system can easily be answered with, "When it makes sense to." It would be difficult to sell the idea to any business owner that time (and money) should be spent going back to write tests to cover the existing functionality of a legacy system. It makes much more sense to add tests as enhancements are added to the application or when defects are being addressed. As you're working in the code and have immediate context surrounding the functionality that you wish to test, that is the optimal time to begin to test parts of a legacy application.</p>
<p class="calibre2">So, how do you begin to write tests against a legacy system? Isolate small functions that can be easily tested. Extract methods and smaller classes as needed. Ensure that functionality is not being modified, but that code is simply being reorganized in order to facilitate testability.</p>
<p class="calibre2">It may be necessary to change a private method to be protected so that it may be tested.  Changing the scope of the method does make it more available and can reduce the effective abstraction, but if the change is required to aid in testing, the trade-off is almost always worth it. You might also consider that private methods made public might better belong to a different utility or helper class, and so can remain public. It depends on the method in question, but there are certainly options available to help you make a legacy system more testable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Gold standard tests</h1>
                
            
            
                
<p class="calibre2">Gold standard tests, or characterization tests, are those tests that simply define the expected functionality of a method. If you were to add tests to a legacy system, you would likely begin by writing gold standard tests to define the "happy path" through the system. You might run the application to determine what values a given method returns based on a given input, and then write a test to duplicate the results.</p>
<p>Gold standard tests are used because they provide a shortcut. Normally, to test legacy code, you would have to abstract third-party libraries and set up dependency injections of some sort. You may also have to refactor the code significantly just to get to the point where you can test anything. By using a gold standard test, most of this work can, temporarily, be bypassed. The only abstractions needed are screen output, date/time, and random. Just about everything else can be used as is.</p>
<p class="calibre2">This would provide a baseline for a suite of tests and help ensure that expected functionality does not change with future refactoring or modifications. Gold standard tests do not validate correctness; they merely confirm that the system does what the system did.</p>
<p class="calibre2">As a basis, gold standard tests provide a certain level of comfort to guard against any unwanted behavior changes. These likely will not be enough to provide adequate code coverage and should have additional tests added to cover edge cases and alternate paths through the system.</p>
<p class="calibre2">As the test suite grows and the coverage becomes more meaningful and complete, it may prove wise to remove the original gold standard tests. Again, you want your test suite to be able to execute quickly so that it is run always and often. Removing tests that may be superfluous will help minimize the feedback cycles when running your tests. In other words, you will know if you have broken something faster and will be more likely to run the tests if the tests complete faster. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Testing all potential outcomes </h1>
                
            
            
                
<p class="calibre2">It's not necessarily important to test for all possible values for an individual method. As in the example of gold standard tests, you certainly don't want to run the application with all possible values in order to write tests for each of the possibilities. It is far more important to test for every path of execution.</p>
<p class="calibre2">If a method is small enough and its potential outcomes limited in scope, it should be quite trivial to write a handful of tests to cover all potential scenarios. Take the following method as an example:</p>
<pre class="calibre19">public int GetPercent(int current, int maximum)<br class="title-page-name"/>{<br class="title-page-name"/>  if (maximum == 0)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new DivideByZeroException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  return (int) ((double) current / maximum * 100);<br class="title-page-name"/>}</pre>
<p class="calibre2">What are the potential paths through this method? What tests might you write to ensure adequate coverage?</p>
<p class="calibre2">First, you might consider writing a test in the case that the <em class="calibre12">maximum</em> input parameter is equal to <kbd class="calibre11">0</kbd>. This should cover the <kbd class="calibre11">DivideByZeroException</kbd> in this scenario.</p>
<p class="calibre2">Next, you might write a test where the <em class="calibre12">current</em> parameter is <kbd class="calibre11">0</kbd>, ensuring that the result of this method is always zero, assuming <em class="calibre12">maximum</em> is non-zero.  </p>
<p class="calibre2">Finally, you would want to write one or more tests to validate that the algorithm above is indeed calculating the percentage correctly, based on inputs.</p>
<p class="calibre2">At this point, it may be tempting to add tests for things like negative values or to check the rounding that C# is doing, but remember that we are working with legacy code and, as far as the business is concerned, this code is working as is. You don't have a record of the business requirements that spawned this code, so it would be unnecessary, and possibly irresponsible, to test more than what this code is telling you. So, if you believe the code is flawed in that it doesn't cover certain business criteria, or that it could produce incorrect values, discuss these things with your business and make a determination together. Any change to the code would have to be through either a bug or new work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Moving forward </h1>
                
            
            
                
<p class="calibre2">Once the legacy system has been sufficiently refactored and a comprehensive suite of tests has been added, you may begin to think of the application as non-legacy, current, or a present-day system. It should now be trivial to add new features and squash any newly discovered defects. From this point forward, any new feature requested should be easily added with the confidence that other parts of the system will not be negatively affected.</p>
<p class="calibre2">The legacy application is no longer legacy. With a comprehensive suite of tests, you are now safe to proceed in Test-Driven Development fashion and write tests as every new feature is added. Remember to keep your tests as clean and well-refactored as any part of the production system.</p>
<p class="calibre2">Taking the <kbd class="calibre11">GetPercent</kbd> example above, how might you modify this in order to return two decimal places? Why, by writing new tests, of course! Start by creating a test to return two decimal places based on the input value.</p>
<p class="calibre2">Your test might look something like this:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsTwoDecimalPlaces()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = GetPercent(1, 3);<br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(33.33, result);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, modify the existing method to return only two decimal places. We'll leave this as an exercise for the reader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fixing bugs </h1>
                
            
            
                
<p class="calibre2">Fixing bugs in a legacy system is a dangerous endeavor. Remember that any existing behavior may be accounted for in other parts of your system, or by external consumers of your application. By fixing a bug, you may be breaking functionality, albeit wrong, that someone else is depending on. So, a change to the execution results of code should be considered carefully before being done.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Free to do unsafe refactoring </h1>
                
            
            
                
<p class="calibre2">Refactoring is, by definition, modifying the structure of the code without modifying its behavior. Safe refactoring includes variable injection, method extraction, and so on. Unsafe refactoring would affect the architecture of the code, the way the code interacts with the rest of the system, and more. By having a fully tested section of code, you can now modify the architecture and be assured that this section still does what it is supposed to do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we discussed how we define legacy code and the issues that legacy code can create. Legacy code can inhibit testing, but now you should know how to fight back against the legacy problem.</p>
<p class="calibre2">In <a target="_blank" href="part0418.html#CEKB40-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 13</a>, <em class="calibre12">Unraveling a Mess</em>, we'll explore a rather extreme example of the types of things you might encounter in a legacy system. We'll explore safe refactoring and how to best unravel a mess into well structured, testable code.</p>


            

            
        
    </body></html>