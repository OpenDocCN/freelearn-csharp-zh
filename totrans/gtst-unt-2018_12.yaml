- en: Adding Audio and Visual Effects to Our Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 11](7098e2ac-1871-4cb2-98ba-36f3acdb0515.xhtml), *Scripting Victory
    and Defeat*, we designed and scripted our game's victory and defeat conditions.
    We updated our game's scripts to manage the Cucumber Man's health, including updating
    the HUD's health bar. We implemented our victory and end-of-game logic through
    scripting. We also implemented the lives remaining and enabled dynamic on-screen
    indicators of those lives. Lastly, we scripted the random respawning of our player
    character.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will plan and implement audio and visual effects to help
    enhance overall gameplay. Specifically, we will add audio to key events in our
    combat system and add several special effects using Unity's Particle System to
    enhance the game's visual appeal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Unity's audio system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning our game's audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing our game's audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Unity's lights and shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Unity's special effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding visual effects to our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering Unity's audio system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has an impressive array of audio capabilities. It supports 3D spatial
    sound, which provides a surround-sound effect. This gives our audio source a point
    and dimension. There are also extensive mixing and mastering capabilities in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the basics of audio in Unity and take a look
    at the Audio Mixer.
  prefs: []
  type: TYPE_NORMAL
- en: Unity audio basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity supports several audio effects, including the Duck Volume Audio Effect,
    which allows us to manipulate an audio signal's volume.
  prefs: []
  type: TYPE_NORMAL
- en: The term `duck` refers to making the audio signal quieter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a variety of audio formats in Unity. You can see the four formats
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Interchange File Format** (**AIFF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MP3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ogg Vorbis** (**OGG**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WAV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have audio assets that are in a file format different from these four,
    you can probably use a free audio conversion tool to change the file format.
  prefs: []
  type: TYPE_NORMAL
- en: When we import an audio file into a Unity game, the file becomes an audio clip.
    Audio clips can also be created from within Unity by using your computer's microphone.
    You can even create audio clips via scripts during your game.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, audio sources are attached to objects. These audio sources emit, or
    play, sound and audio listener components do receive the sound emitted by audio
    sources. You can think of audio listeners as the player's ears inside the game
    world, hearing what's near them. Usually, one audio listener component is attached
    to the main camera so that the sounds it picks up on align well with what is displayed
    in the game view. Listeners are also attached to objects. Let's look at an example
    to see how a GameObject, an audio source, and listeners are related.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we are creating a zoo simulation and are working on the bovine section.
    There is a holding area for cows. Cows are generally quiet, but might be noisy
    eaters. The cow would be our GameObject and it would emit a *chewing* audio clip.
    The audio clip's RAW file (that is, `chewing.aiff`) would be identified as an
    audio source component attached to the cow GameObject. Now, let's say there is
    a farmer character. We can attach a listener to the farmer, which is also an object.
    That listener is a script that performs certain actions if it hears the sound
    from the cow. Perhaps, if the listener picks up the *chewing* sound, they will
    know that more hay is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the relationships between the various components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6475a6ed-0b1d-4cea-a6e9-e146cece8d05.png)'
  prefs: []
  type: TYPE_IMG
- en: You will learn how to use these components later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Audio Mixer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity's Audio Mixer gives you the ability to mix and master audio sources and
    effects. To access the Audio Mixer, you select Window from the pull-down menu,
    and then select Audio Mixer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first open the Audio Mixer window, you will see that there are no
    mixers in your project. As you can see in the following screenshot, there is a
    + icon on the far-right side of that window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1731d2b-d6fe-4bd3-a0bb-a2006bedef64.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking that icon enables you to create a mixer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a mixer in your project, the Audio Mixer window reveals four
    sections on the left. As shown in the following screenshot, these are Mixers,
    Snapshots, Groups, and Views. All the mixers in your project will be listed here.
    The Snapshots are a collection of parameters that you can use in your mixer. An
    Audio Mixer Group can be used to modify audio source sounds prior to them reaching
    the listeners. The final section is Views. A View is just a saved state of the
    mixer groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8906b466-1d78-4f4f-a0ff-8f5aede6ad93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To the right of the Audio Mixer window, you see a single mixer in our project.
    When you click the Add button, you will see a popup, shown here, that reveals
    several options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84d98ad-13cf-4029-af9f-df0ea96abfa2.png)'
  prefs: []
  type: TYPE_IMG
- en: We will not use these options in our game, but they are worth exploring if you
    intend to implement advanced audio effects in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Planning our game's audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning a game's audio is an important part of game design. Just because we
    can do something with regards to audio, does not mean we should. Too much audio
    can be as off-putting as not enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The audio selected for the Cucumber Man game is intended to provide sufficient
    demonstration of how to import, configure, and script a game for various audio
    effects. To that end, the following audio will be implemented in our Cucumber
    Man game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Animations that require sounds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber Man
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jump
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Die
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Respawn
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber Beetles
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Standing Run
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Die
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Events that require sounds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player Defeat
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Player Victory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will perform the implementation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our game's audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the audio requirements listed in the previous
    section. We will import, configure, and script our game to complete the implementation. Before
    we get started, you should open your Unity game project. Alternatively, you can
    download the Starting-Chapter-12 Unity project available from the publisher's
    companion site.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement our game''s audio in three steps, each handled in subsequent
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing audio assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Cucumber Beetle audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Cucumber Man audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing audio assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to import the audio assets into our game project. Here are
    the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the game project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, right-click Assets and select Create | Folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new folder `Audio`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Audio` folder and select Import Package | Custom Package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `cucumber_man_audio.unitypackage` file available from the publisher''s
    site for this book. You should see the following screenshot pop up in your Unity
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57ea928c-cf96-45c3-81f5-9748565bd9cb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Import Unity Package dialog window, ensure all audio files are selected
    and click the Import button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, select the first audio file. Then, in the Inspector panel,
    use the interface to play the audio clip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 7 for each of the nine audio clips. This will familiarize you with
    each sound and ensure they can play on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our audio assets in our game project, let''s review how each
    of them will be used. The following table maps each audio file to the appropriate
    in-game animation or event:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **In-Game animation/Event** | **Related GameObject** | **Audio asset** |'
  prefs: []
  type: TYPE_TB
- en: '| Jump animation | Cucumber Man | `jump.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Throw animation | Cucumber Man | `throw.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Die animation | Cucumber Man | `cm_die.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Respawn event | Cucumber Man | `respawn.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Eat animation | Cucumber Beetle | `eating.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Standing Run animation | Cucumber Beetle | `attack.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Die on Ground animation | Cucumber Beetle | `beetle_die.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Die Standing animation | Cucumber Beetle | `beetle_die.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Player Defeat event | Cucumber Man | `game_over.wav` |'
  prefs: []
  type: TYPE_TB
- en: '| Player Victory event | Cucumber Man | `victory.wav` |'
  prefs: []
  type: TYPE_TB
- en: Implementing the Cucumber Beetle audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will configure the Cucumber Beetle prefab so that it supports
    audio when the Cucumber Beetles eat, when they run while standing, and when they
    die. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the beetle prefab in the Project panel's `Assets` | `Prefabs` folder.
    If you have more than one prefab, be sure to use the one that is used in your
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll to the bottom and click the Add Component button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Audio | Audio Source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play On Awake box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, we would assign an `AudioClip` to our Audio Source component. Since
    our Cucumber Beetles will have more than one audio clip, we will not assign one
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to edit the `BeetleNPC` script. Open that script file and
    make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following statement to the `Start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `OnTriggerEnter()` method as shown here. You will see two `audioSource.PlayOneShot()`
    statements, one each for the `eating` and `attack` audio clips:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `DestroySelfOnGround()` method, shown as follows. Here you can see
    that we added the `audioSource.PlayOneShot(die)` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `DestroySelfStanding()` method as shown in the following code block.
    Here, you can see we added the `audioSource.PlayOneShot(die)` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the scripting task is complete, we need to assign the designated audio
    clips to the variables we created:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Beetle NPC (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `eating` audio clip from the Project panel's `Assets` | `Audio` folder
    to the appropriate spot in the Beetle NPC (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat step 11 for the `attack` and `beetle_die` audio clips. Your Beetle NPC
    (Script) component should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dec5e8a0-a8ea-4e36-b977-9ec8c7241f8c.png)'
  prefs: []
  type: TYPE_IMG
- en: All that's left is for you to test this new functionality by playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Cucumber Man audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will configure the Cucumber Man prefab so that it supports
    audio when the Cucumber Beetles eat, when they run while standing, and when they
    die. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Cucumber Man in the Hierarchy panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll to the bottom and click the Add Component button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Audio | Audio Source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play On Awake box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, we would assign an `AudioClip` to our Audio Source component. Since
    our Cucumber Man will have more than one audio clip, we will not assign one here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to edit the `BeetleNPC` script. Open that script file and
    make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Start()` method, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `Update()` method, as shown here, so that it includes the three `audioSource.PlayOneShot()`
    statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `ReSpawnCucumberMan()` method as shown here. You can see that we added
    the `audioSource.PlayOneShot()` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our script changes for the `CucumberManManager` script file are complete,
    we need to assign the designated audio clips to the variables we created. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Cucumber Man Manager (Script)
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `cm_die` audio clip from the Project panel's `Assets` | `Audio` folder
    to the appropriate spot in the Cucumber Man Manager (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat step 10 for the `respawn` and `game_over` audio clips. Your Cucumber
    Man Manager (Script) component should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0bcf2c8-12ed-4cd1-8075-33ccdc560616.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have taking care of the dying, respawning, and game over audio clips.
    Next, we will handle the jumping and throwing audio clips:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PlayerController` script for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following statement to the `Start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following statement to the beginning of the `Jump()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following statement to the beginning of the `Throw()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our script changes for the `PlayerController` script file are complete,
    we need to assign the designated audio clips to the variables we created. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Player Controller (Script)
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `jump` audio clip from the Project panel's `Assets` | `Audio` folder
    to the appropriate spot in the Player Controller (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `throw` audio clip from the Project pane''s `Assets` | `Audio` folder
    to the appropriate spot in the Player Controller (Script) component. Your Player
    Controller (Script) component should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a6fc6ef-92ae-487c-a58b-3b3efd8b6b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last audio clip for us to implement is the victory clip. We will start
    by editing the `VictoryManager` script. Open that script file and make the following
    modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a  `Start()` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `Update()` method, shown as follows. You will notice that we only
    added an audio clip playback for the victory condition, as we''ve already taken
    care of the defeat condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our script changes for the `VictoryManager` script file are completed,
    we need to assign the victory audio clip to the variable we created. Here are
    the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select `HUD_Canvas` | `EndOfGame` | Victory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Victory Manager (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `victory` audio clip from the Project panel''s `Assets` | `Audio`
    folder to the appropriate spot in the Victory Manager (Script) component. Your Victory
    Manager (Script) component should look like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9212a714-f234-4959-9246-ca31f91e0744.png)'
  prefs: []
  type: TYPE_IMG
- en: You are now ready to test this new functionality by playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent time to save both your scene and your project.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Unity's lights and shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lighting in games is important as it is what allows GameObjects to be seen.
    If we did not have lights in our game, the game screen would be completely black.
    In Unity, it is easy to take lighting for granted because, when we create a new
    scene, there is a default Main Camera and a Directional Light.
  prefs: []
  type: TYPE_NORMAL
- en: Shadows in game worlds are another component that can be taken for granted because
    Unity's default settings regarding shadows is often sufficient for games.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at light sources and shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Adding light sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Unity, lights are GameObjects and are available in several different types.
    Here are the most common types of light sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Directional light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spot light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these lights.
  prefs: []
  type: TYPE_NORMAL
- en: Directional light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Directional light is like the sun. As you can see from the following Inspector
    panel, there are several settings that can be adjusted for Directional lights
    beyond the Transform''s Position, Rotation, and Scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aa1f7d5-0c20-4063-9842-d069f0f69bac.png)'
  prefs: []
  type: TYPE_IMG
- en: The following table provides information about key settings for Directional
    lights.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| Color | You can select a color for the light to emit. For realistic outdoor
    scenes, you would probably use a light yellow color. |'
  prefs: []
  type: TYPE_TB
- en: '| Mode | You can select from Realtime, Baked, or Mixed lighting modes. When
    Realtime is selected, the direct light is computed each frame during the game.
    This provides a realistic game experience and is the default mode. |'
  prefs: []
  type: TYPE_TB
- en: '| Intensity | Adjust this to control brightness.  |'
  prefs: []
  type: TYPE_TB
- en: '| Shadow Type | There are three options here: Soft Shadows, Hard Shadows, and
    No Shadows. Soft Shadows cast soft edges and avoid the sharp-edged shadows that
    are cast using Hard Shadows. As you would expect, Soft Shadows is more processor-intensive
    than Hard Shadows. |'
  prefs: []
  type: TYPE_TB
- en: '| Realtime Shadows | This area provides additional control over your shadows.
    |'
  prefs: []
  type: TYPE_TB
- en: Point light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Point lights are like light bulbs without lampshades. In fact, they are the
    ideal type of light to use to simulate a small, local source of light such as
    a table lamp, wall sconce, or chandelier. As you can see in the following screenshot
    of the Inspector panel, you can modify the Range, Color, and Intensity. You can
    also select from Realtime, Baked, or Mixed render modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7db0af5b-9b96-4196-aaa8-3b6d5b737ce7.png)'
  prefs: []
  type: TYPE_IMG
- en: Spot light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Spot light is like a flashlight and provides cone-shaped illumination. This
    type of light is ideal for simulating flashlights, automobile headlights, plane
    lights, search lights, and Spot lights. As you can see in the following Inspector
    panel screenshot, there is a Spot Angle property. Spot lights also have properties in
    common with other types of lights.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42ea7d07-aef9-4c88-aefa-fd81b77ea634.png)'
  prefs: []
  type: TYPE_IMG
- en: Area light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Area (baked only) light is something that is used when you bake images into
    textures. This type of light is great for simulating light coming out of a building,
    such as from a window. Area lights are also good for LED stadium lighting. The
    properties Width and Height, shown in the following screenshot, are not present
    in Directional, Point, and Spot lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fd6f05f-5c13-49ff-92ad-8ea9b8277178.png)'
  prefs: []
  type: TYPE_IMG
- en: Shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity affords us great control over shadows in our game scenes. We can control
    which objects cast shadows, which objects can receive shadows, and various properties
    of the shadows. Shadows in Unity closely replicate the way shadows exist in the
    real world. As discussed earlier in this chapter, there are soft shadows and hard
    shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Soft shadows result in greater realism, but at the cost of additional computations
    and processing. Hard shadows provide less realistic, but often acceptable, shadows
    during a game and are less processor intensive. Hard shadows are easy to identify
    in a game because the shadows cast will have sharp, blocky shadow edges.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Unity's special effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity has a great capabilities for special effects in three categories: Particle
    System, Trail Renderer, and Line Renderer. These are available via the GameObject
    | Effects top menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an Effects component to a GameObject is accomplished by using the Add
    Component | Effects option in the Inspector panel. As you can see in the following
    screenshot, the Particle System, Trail Renderer, and Line Renderer options are
    available via this method. There are also additional options, such as Lens Flare
    and Halo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c26c352-2b90-41c1-a868-731cbb611090.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we will discuss the Particle System and Trail Renderer effects.
  prefs: []
  type: TYPE_NORMAL
- en: Particle System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle Systems use a vast number of tiny 2D images or meshes in a scene to
    simulate effects such as liquids, smoke, flames, pixie dust, fireworks, and clouds.
    The basic concept is that one simple 2D image or mesh can be used in large quantities
    to create a robust and dense visual effect. These 2D images or meshes are the
    particle, and they collectively form the Particle System.
  prefs: []
  type: TYPE_NORMAL
- en: Each particle in a Particle System is rendered from a specific point and has
    a limited lifespan. How long this lifespan lasts depends on your implementation,
    but it typically only lasts a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following Inspector panel screenshot, there are several
    parameters that allow us to customize the behavior of Particle Systems. We will
    add a Particle System to our game later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37e9b8a-74bb-4d55-99bb-9d4ac63fec60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we add a Particle System to our scene, Unity presents us with an interface,
    the Particle Effect panel, in the lower-right corner of the Scene view. This interface
    allows us to play, pause, and stop the Particle simulation, as well as adding
    additional parameter settings while observing the changes to the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/265fc7f7-165c-4482-855c-1a6fab6d88f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Unity 2018, in beta at the time of this book's publication, has support for
    GPU instancing of Particle System mesh rendering, support for Orbital Velocity,
    and enables particle emitter shapes, which permits texture reading for masking
    and color tinting.
  prefs: []
  type: TYPE_NORMAL
- en: Trail Renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Trail Renderer is a visual effect that creates a trail behind a GameObject
    as it moves. Classic examples of this are a jet''s afterburner, a car''s exhaust,
    and the Tasmanian Devil''s visual swoosh (dust cloud). The following Inspector
    panel screenshot illustrates the parameters that can be manipulated to customize
    a Trail Renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0f6f962-5560-478e-914d-a572ebe494f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The primary Trail Renderer settings are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Cast Shadows | There are four options here: On, Off, Two-Sided, and Shadows
    Only. The default setting is On. |'
  prefs: []
  type: TYPE_TB
- en: '| Receive Shadows | This is an on/off toggle. |'
  prefs: []
  type: TYPE_TB
- en: '| Materials | You can select a particle shader for the material and adjust
    the size. |'
  prefs: []
  type: TYPE_TB
- en: '| Time | This setting defines the length of the trail. |'
  prefs: []
  type: TYPE_TB
- en: '| Autodestruct | You can select this option to have the trail GameObject destroyed
    once it has been idle for the number of seconds set in the Time setting. |'
  prefs: []
  type: TYPE_TB
- en: Adding visual effects to our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game already has a Directional light and, as discussed earlier in this chapter,
    it acts like the sun—shining light from high above our terrain. The shadows from
    our Cucumber Man, Cucumber Beetles, cherries, cherry trees, and cucumber patches
    can be seen on the grass. We do not need to make any changes to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The visual effects changes we will make in this section are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Point light to our cherry trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a special effect using the Particle System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Point light to our cherry trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the Cucumber Man can walk up to and under the cherry trees in our
    sandbox area. Those trees are very dense and, because the only source of light
    comes from our directional light, it is too dark for the Cucumber Man to see the
    cherries he is picking from the tree. This is just simulated for the sake of adding
    a point light. So, we will use the following steps to add a point light to our
    cherry trees in the sandbox area of our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: In Scene view, navigate to a cherry tree and zoom in so that you can see the
    base of the tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the top menu, select GameObject | Light | Point Light
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relocate the Point Light so that it is at the center of the tree trunk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, select a Color such as a light red
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, change the Range to `11`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, increase the Intensity to `30`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reposition the point light so that it looks similar to the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01c70dce-f4e4-4ac1-a27d-094ac6884f9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat steps 1 through 7 for each cherry tree in your sandbox area. Test your
    game in game mode to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Add a special effect using the Particle System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will add a particle system to our spawn pads so that a
    special effect is attached to them. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Scene view, navigate to a spawn pad and zoom in so you can see the pad clearly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the top menu, select GameObject | Effects | Particle System.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relocate the Particle System so that it is at the center and base of the spawn
    pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy panel, drag the Particle System so that it is subordinate to
    a spawn pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, click the settings cog in the Transform component and
    select Reset. This resets the position of the Particle System to the Transform
    of the spawn pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, select a Color that contrasts with the red of the spawn
    pad and the green of the terrain and cherry tree, such as blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, change the Max Particles to `10,000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, increase the Shape | Shape to Edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, increase the Shape | Radius to 1.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When completed, your Particle System should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8df633b0-a375-41dd-bab2-486c31106a41.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat steps 1 through 9 for each spawn pad in your sandbox area.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we planned and implemented audio and visual effects to enhance
    the overall gameplay. Specifically, we added audio to key events in our combat
    system and added lighting and particle special effects. We started with an overview
    of Unity's Audio System, then planned and implemented our game's audio. We then
    shifted to an introduction to lights and shadows in Unity and covered selected
    special effects. We concluded by adding a Point light to our cherry trees and
    a special effect to our spawn pads.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](e8407796-3bbd-4f54-bbcc-e1bd89284de5.xhtml), *Optimizing Our
    Game for Deployment*, you will learn how to diagnose performance problems and
    how to optimize scripts and graphic rendering. You will also learn how to deploy
    your game to multiple platforms.
  prefs: []
  type: TYPE_NORMAL
