- en: Chapter 6. Working with Mono
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用Mono
- en: Unity supports two main scripting languages, namely, C# and JavaScript. Developers
    should select one of these two from the outset and apply it consistently throughout
    their project; this writes all scripts in the selected language. Failure to do
    so (by mixing script files in different languages) typically causes unnecessary
    headache and confusion. However, once you've settled on a language, such as C#,
    it usually won't offer everything you need it to do to create games. C#, on its
    own, can neither load and parse XML files to support save-game data, nor can it
    create window objects and GUI widgets to perform advanced search and query behaviors
    on complex data sets and collections. To achieve these additional behaviors and
    lots more, we must turn to external libraries. Some libraries can be purchased
    directly from the Unity's Asset Store, and these are typically used for a specific
    and dedicated purpose. However, Unity ships with the Mono Framework, which is
    a free, cross-platform, and open source implementation of the Microsoft .NET Framework
    (a programming library), and it offers most classes available in this library.
    The .NET Framework features classes to handle strings, file input-output, search
    and sort data, keep track of dynamic lists, parse XML, and more. This means that
    through Mono an extensive toolkit is open to you to effectively and efficiently
    manage data in your application. This chapter explores some of the many ways in
    which Mono can be deployed in a Unity application by considering lists, stacks,
    **Language Integrated Query** (**Linq**), regular expressions, enumerators, and
    so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持两种主要的脚本语言，即C#和JavaScript。开发者从一开始就应该选择这两种语言中的一种，并在整个项目中一致使用；这样所有脚本都使用所选语言编写。如果不这样做（通过混合不同语言的脚本文件），通常会导致不必要的头痛和困惑。然而，一旦你确定了一种语言，比如C#，它通常不会提供你创建游戏所需的所有功能。C#本身不能加载和解析XML文件以支持保存游戏数据，也不能创建窗口对象和GUI小部件以在复杂的数据集和集合上执行高级搜索和查询行为。为了实现这些附加行为和更多功能，我们必须转向外部库。一些库可以直接从Unity的Asset
    Store购买，这些库通常用于特定的和专门的目的。然而，Unity附带Mono框架，这是一个免费、跨平台和开源的Microsoft .NET Framework（编程库）实现，并提供该库中的大多数类。.NET
    Framework具有处理字符串、文件输入输出、搜索和排序数据、跟踪动态列表、解析XML等功能。这意味着通过Mono，你可以获得一个广泛的工具集，以有效地和高效地管理应用程序中的数据。本章通过考虑列表、栈、**语言集成查询**（**Linq**）、正则表达式、枚举器等方式，探讨了Mono在Unity应用程序中部署的许多方法。
- en: 'The following screenshot shows the Mono Framework interface:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Mono框架界面：
- en: '![Working with Mono](img/0655OT_06_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![使用Mono](img/0655OT_06_01.jpg)'
- en: The Mono Framework ships with the Unity engine
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Mono框架随Unity引擎一起提供
- en: Lists and collections
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和集合
- en: 'Perhaps, the most common task when programming games is to store lists of data.
    The nature of this data varies tremendously: high scores, player stats, enemy
    stats, inventory items, weapons, power-ups, level lists, and more. Wherever possible,
    choose static arrays to hold data due to their speed and efficiency. Static arrays
    were considered in detail in [Chapter 1](ch01.html "Chapter 1. Unity C# Refresher"),
    *Unity C# Refresher*. In short, static arrays are created ahead of time, and their
    maximum capacity is fixed from the outset. Items can be added and removed from
    them at runtime, but their total size can never change. If their maximum capacity
    is not utilized, then space would be wasted. Static arrays, as their name implies,
    are an excellent choice for storing lists of data that remain constant, such as
    all levels in the game, all weapons that can possibly be collected, all power-ups
    that can possibly be collected, and so on.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏编程中，最常见的一项任务可能是存储数据列表。这种数据的特点千差万别：高分、玩家统计数据、敌人统计数据、库存物品、武器、升级、关卡列表等等。尽可能选择静态数组来存储数据，因为它们速度快、效率高。静态数组在[第1章](ch01.html
    "第1章。Unity C# 快速回顾")中进行了详细讨论，*Unity C# 快速回顾*。简而言之，静态数组是在事先创建的，它们的最大容量从一开始就是固定的。可以在运行时向它们添加和删除项目，但它们的总大小永远不会改变。如果它们的最大容量没有得到利用，那么空间就会被浪费。正如其名称所暗示的，静态数组是存储保持恒定的数据列表（如游戏中的所有关卡、可能收集的所有武器、可能收集的所有升级等等）的绝佳选择。
- en: However, you'll often need dynamic arrays, which can grow and shrink in capacity
    to exactly accommodate the data you need as it changes, such as when enemies are
    spawned and destroyed, inventory items come and go, weapons are collected and
    discarded, and so on. The Mono Framework offers many classes to maintain lists
    of data. The three main classes are `List`, `Stack`, and `Dictionary`. Each of
    these is useful for a specific purpose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The List class
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need an unordered, sequential list of items of any single data type,
    that is, a list that grows and shrinks to match the size of the stored data, then
    the `List` class is ideal. `List` is especially good to add and remove items and
    sequentially iterating through all stored items. In addition, the `List` objects
    are editable from the Unity Object Inspector. The following code sample 6-1 uses
    a sample C# file `Using_List.cs`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on using `List` can be found in the book's companion files (code
    bundle) at `Chapter06\Collections`. You can also see the `List` class reference
    documentation in the MSDN at [http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the comments for code sample 6-1:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 03**: To use the `List` class, you must include the `System.Collections.Generic`
    namespace.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 06**: If your list data type is declared as a `System.Serializable`
    class, then the list would be shown in the Object Inspector.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 20**: You can declare and initialize a new list instance in just one
    statement inside the class members'' declaration.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 27**: New objects are immediately added to the end of the list using
    the `Add` method.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 30**: Items can be removed using several methods. `RemoveRange` lets
    you delete several consecutive items from the list. Other removal methods include
    `Remove`, `RemoveAll`, and `RemoveAt`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 33**: You can cycle through all items in a list using a `foreach` loop.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 27-33**: Generally, don''t add or remove items to or from a list while
    looping through it.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `List` class in the Object Inspector:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![The List class](img/0655OT_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Viewing the List class in the Object Inspector
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The `List` class supports several methods to remove items either individually
    or collectively, and these are intended to be used outside list iterations (loops).
    However, there are times when it''s convenient, or seems simplest, to remove items
    while iterating through a loop, such as when you need to remove each item after
    processing it. A classic case is when you need to delete all reference type objects
    in the scene, such as enemies, while also removing their entry in the array to
    avoid null references. Item removal in a loop, however, can cause problems, because
    it''s easy for an iterator to lose track of where it is and where it should go
    within the array as the total item count changes during the loop. To loop and
    remove in one process, you should traverse the array backwards from the end to
    the start, as opposed to forwards, as shown in the following code sample 6-2:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Dictionary class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` class is, perhaps, one of the most useful classes in the Mono Framework
    for in-memory data storage. However, let's not forget the `Dictionary` class (similar
    to the `std::map` class in C++). This class is especially useful when you need
    more than just a simple list of items. If you need to search for and get instant
    access to specific elements based on a key value, then the `Dictionary` class
    is essential. For each item in the list, you must save a corresponding key or
    ID that uniquely identifies the item from all others. The `Dictionary` class then
    allows you to get instant access to this item, based solely on its key. This makes
    the `Dictionary` class useful as a true dictionary for word games, for example,
    if you need to look up the meaning or score-value of specific words in a large
    dictionary or database of words. The word itself would be the key, and the word
    definition would be the value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Now, of course, you can replicate this kind of behavior using multiple `List`
    objects instead of the `Dictionary` class. However, the `Dictionary` class is
    extremely fast in terms of performance, almost lightning fast. You can store vast
    quantities of data inside the dictionary at very little performance cost. This
    makes them highly valuable for a quick data lookup from key values, as shown in
    the following code sample 6-3;
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the comments for code sample 6-3:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 03**: As with the `List` class, you must include the `System.Collections.Generic`
    namespace'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 08**: Here, the dictionary is declared and created in one line; unlike
    the `List` class, `Dictionary` does not appear in the Unity Object Inspector'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 13-23**: The `Dictionary` class is populated using the `Add` method'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 27**: Elements in the `Dictionary` class are accessed much like arrays,
    except by specifying each element using its key data instead of an array index'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on using `Dictionary` can be found in [Chapter 4](ch04.html "Chapter 4. Event-driven
    Programming"), *Event-driven Programming*, when considering event-driven programming
    with an `EventManager`.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Stack class
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're making a card game where players should pick the top card from a deck,
    if you need an undo history, if you're coding customized path finding, or if you're
    creating a complex spell-casting system or even a Tower of a Hanoi puzzle game
    ([http://en.wikipedia.org/wiki/Tower_of_Hanoi](http://en.wikipedia.org/wiki/Tower_of_Hanoi)),
    the chances are high that you'll need a stack somewhere along the line. A stack
    is a special kind of list based on the **Last in, first out** (**LIFO**) model.
    The concept is about stacking. You can push items into the list, and these stack
    up one atop the other in a vertical tower, with the most recently pushed item
    always at the top. Then, you can pop items from the top of the stack (remove them
    from the array) one by one. The order in which you pop items is always the inverse
    of the order in which they were pushed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why `Stack` is especially useful for the undo or rewind functionality.
    Refer to the following code sample 6-4 for an example on how to use `Stack`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: IEnumerable and IEnumerator
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''re working with collections of data, whether `List`, `Dictionary`,
    `Stack`, or others, you''ll typically want to iterate (or traverse) all items
    in the list or at least some items, based on a specific criteria. In some cases,
    you''ll want to loop through all items in sequence or some items. Most often,
    you''ll want to traverse the items forwards in sequence, but as we''ve seen, there
    are times when reverse traversing is also suitable. You can loop through items
    using a standard for loop. However, this raises some annoyances that the interfaces
    of `IEnumerable` and `IEnumerator` can help us solve. Let''s see what the annoyances
    are. Consider the `for` loop in the following code sample 6-5:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are three main annoyances while using a `for` loop. Let's start with the
    first two. The first is that the syntax is not especially inviting for a loop
    that just cycles from left to right, from beginning to end, and we must always
    use an integer iterator variable (`i`) to access each array element as the loop
    proceeds. The second is that the iterator itself is not truly "bounds safe". It
    can, in fact, be incremented or decremented either above or below the array limits
    and cause an out-of-bounds error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'These issues can, to some extent, be fixed using the neater `foreach` loop,
    which is bounds safe and uses a simpler syntax, as shown in following code sample
    6-6:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `foreach` loop is simpler and is to be preferred for readability, but there's
    more going on here than first meets the eye. The `foreach` loop works only for
    classes that implement the `IEnumerable` interface. Objects that implement `IEnumerable`
    must return a valid instance to an `IEnumerator` interface. So, for an object
    to work in a `foreach` loop, it must depend on two other interfaces. The question
    that then arises is why is there all this internal complexity for simple looping
    or traversal behavior. The answer is, not only do the `IEnumerable` and `IEnumerator`
    solve the first two problems of simpler syntax and bounds-safe iteration by way
    of the `foreach` loop, but they also solve a third problem. Specifically, they
    allow us to loop through or iterate groups of objects that are not even truly
    array types; that is, they let us iterate through many different types of objects,
    whether or not they're in an array, as though they were in an array. This can
    be very powerful. Let's see this in action in a practical example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through enemies with IEnumerator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take, for example, an RPG game that features a medieval world inhabited by many
    different and evil wizard characters (coded in class `Wizard`). For the sake of
    example, these wizards will spawn into the level at random places and random intervals,
    potentially causing untold trouble for the gamer, casting spells, and performing
    evil deeds. The result of such random spawning is that, by default, we cannot
    know in advance how many wizards there will be in the scene at any one time, nor
    can we know where they've been spawned, because it's random. However, there are
    still legitimate reasons why we'd need to find all the wizards; perhaps, all the
    wizards must be disabled, hidden, paused, or killed, or, perhaps, we need a head
    count to prevent overspawning. So, regardless of the wizard spawning and its randomness,
    there are still good justifications for being able to access all the wizards in
    the level on demand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen already, in [Chapter 2](ch02.html "Chapter 2. Debugging"), *Debugging*,
    one way in which we can retrieve a traversable list of all wizards, as shown in
    the following code sample 6-7:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The problem with the `FindObjectsOfType` function is that it's slow and performance
    prohibitive when used frequently. Even the Unity documentation at [http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html](http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html)
    recommends against its repeated use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A sample Unity project using the `IEnumerator` and `IEnumerable` interfaces
    can be found in the book's companion files (code bundle) at `Chapter06\Enumerators`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, we can achieve similar behavior using `IEnumerable` and `IEnumerator`,
    and this avoids significant performance penalties. Using these two interfaces,
    we''ll be able to efficiently iterate through all the wizards in the scene, using
    a `foreach` loop, as though they were in an array, as shown in the following code
    sample 6-8:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are the comments for code sample 6-8:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 07 and 39**: Two classes are created here: the first is `WizardEnumerator`,
    which implements `IEnumerator`, and the second is `Wizard`, which implements `IEnumerable`.
    The `WizardEnumerator` class is instantiated simply to iterate over a collection
    of wizards that keeps track of the current wizard in the iteration process. To
    loop through or iterate over all wizards in the scene, it relies on member variables
    for the `Wizard` class, as we''ll see in the upcoming sections.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 13, 23, and 29**: The `WizardEnumerator` class implements the methods
    and properties of `IEnumerator`, specifically, `MoveNext` (which iterates over
    to the next wizard in the cycle), `Reset` (which resets the iterator back to the
    first wizard), and `Current` (which returns the active wizard in the cycle).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 39**: The `Wizard` class encapsulates a wizard character in the scene
    and inherits from two classes: `MonoBehaviour` and `IEnumerable`. This means that
    all the features of both classes come together in this derived class. It internally
    maintains several variables that allow the enumerator to loop through all the
    wizard instances in the scene at any time. First, `Wizard` holds the `FirstCreated`
    and `LastCreated` static members (which are global to all the wizard instances).
    These variables are set when objects are created (see the `Awake` function in
    line 58). `FirstCreated` always refers to the instance of a wizard that was created
    first, and `LastCreated` always to the most recently created instance.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 48 and 52**: The `Wizard` class also maintains the instance variables,
    `NextWizard` and `PrevWizard`. This implements a doubly-linked list; that is,
    each instance of the wizard points to the previously and subsequently created
    instance, which allows a chain-like connection between all wizards. The first
    wizard will have `PrevWizard` or `null`, and the last wizard will have `NextWizard`
    or `null`. These variables make it possible for the iterator to cycle through
    all wizard instances even when none of them are in an array.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 86**: The `GetEnumerator` method returns an instance to an `Enumerator`
    object. This is required by the `IEnumerable` interface and allows a `foreach`
    loop across all wizards.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Together, the `Wizard` and `WizardEnumerator` classes offer fast, direct, and
    efficient `Wizard` object cycling, even though no array of wizards need to truly
    exist. To see this in practice, in a scene of wizards, the following code sample
    6-9 can enumerate all wizards:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also enumerate through all wizards outside a `foreach` loop by accessing
    the `Enumerator` object directly, as shown in the following code sample 6-10:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过直接访问`Enumerator`对象来遍历`foreach`循环外的所有向导，如下面的代码示例6-10所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Strings and regular expressions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和正则表达式
- en: Working with text data is critical and for many reasons. If you need to display
    subtitles, show in-game text, and implement localization functionality (supporting
    multiple languages), then you would be working with text, specifically with Text
    Assets. In Unity, Text Assets refer to any text files included in the Unity project,
    and each asset is treated as one long string even when multiple lines are involved
    (each line is separated by a `\n` escape character). Once your code is presented
    with a string like this, however, there're typically many ways in which you'll
    want to process it. Let's see some common but important string operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与文本数据一起工作至关重要，并且有多个原因。如果您需要显示字幕、显示游戏中的文本以及实现本地化功能（支持多种语言），那么您将处理文本，特别是文本资产。在Unity中，文本资产指的是Unity项目中包含的任何文本文件，即使涉及多行（每行由`\n`转义字符分隔），每个资产也被视为一个长字符串。然而，一旦代码接收到这样的字符串，通常会有许多您想要处理它的方法。让我们看看一些常见但重要的字符串操作。
- en: Null, empty strings, and white space
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空字符串、空字符串和空白
- en: When processing strings, you can't always guarantee validity; sometimes, strings
    are badly formed and don't make sense. For this reason, you'll frequently need
    to validate them before processing. A common way to validate them initially is
    to see whether a string is null, and then (if not null) check the string's length,
    because if the length is `0`, then the string is empty and, therefore, invalid,
    even though it's not `null`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，您不能总是保证其有效性；有时，字符串格式不良且没有意义。因此，在处理之前，您通常会需要验证它们。验证字符串的常见方法首先检查字符串是否为空，然后（如果非空）检查字符串的长度，因为如果长度为`0`，则字符串为空，因此无效，即使它不是`null`。
- en: 'Again, you''ll probably also want to eliminate the possibility that a string
    consists entirely of spaces, because a string that is not `null` and features
    only white space characters will not, in fact, be of `0` length, even though it
    usually means there''s nothing to process. You can validate a string for each
    of these states individually, but the string class in .NET offers a compound or
    all-in-one convenience check for you, specifically the method `IsNullOrWhiteSpace`.
    However, this method was introduced in .NET 4.5, and Mono does not support this
    version. This means a manual implementation is required for equivalent behavior,
    as shown in the following code sample 6-11:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可能还希望消除字符串完全由空格组成的可能性，因为一个既不是`null`又只包含空白字符的字符串实际上长度不是`0`，尽管这通常意味着没有要处理的内容。您可以单独验证字符串的这些状态，但.NET中的字符串类为您提供了复合或一站式便利检查，具体是`IsNullOrWhiteSpace`方法。然而，此方法是在.NET
    4.5中引入的，Mono不支持此版本。这意味着需要手动实现等效行为，如下面的代码示例6-11所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: String comparison
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串比较
- en: 'You''ll frequently need to compare two separate strings, typically, for equality
    to determine whether two strings are identical. You can do this using the `==`
    operator such as `string1 == string2`, but for best performance, use the `theString.Equals`
    method. This method has several versions, all of varying computational expense.
    In general, you should prefer any version that contains an argument of type `StringComparison`.
    When the comparison type is explicitly stated, the operation will perform best,
    as shown in the following code sample 6-12:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会需要比较两个独立的字符串，通常是为了比较它们是否相等，以确定两个字符串是否相同。您可以使用`==`运算符，例如`string1 == string2`，但为了最佳性能，请使用`theString.Equals`方法。此方法有几个版本，计算成本各不相同。通常，您应该选择包含`StringComparison`类型参数的任何版本。当比较类型明确指定时，操作将表现得最好，如下面的代码示例6-12所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `String.Compare` method can be found online in MSDN
    at [http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`String.Compare`方法的更多信息可以在MSDN上找到，网址为[http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx)。
- en: 'Another method to quickly and regularly compare the same two strings for equality
    is to use string hashes, that is, to convert each string into a unique integer
    and then to compare the integers instead, as shown in the following code sample
    6-13:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `String.GetHashCode` function from the Mono library to
    retrieve a string's hash code. For more information, visit [http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, you don''t want to compare for equality. Your intention
    might be to determine which string takes more priority alphabetically, that is,
    whether one string would appear before the other if they were both listed alphabetically
    in a dictionary. You can achieve this using the `String.Compare` function. However,
    again, be sure to use a version that features a `StringComparison` type in the
    arguments, as shown in the following code sample 6-14\. With this version, `-1`
    would be returned if `Str1` comes before `Str2`, `1` would be returned if `Str2`
    comes before `Str1`, and `0` would be returned if the two strings are equal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `String.Compare` returns `0` to indicate that two strings are equal,
    never use this function for equality testing. For equality testing, use `String.Equals`
    or hashes, as both perform much faster than `String.Compare`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re creating GUI elements, such as high-score HUDs, player names, cash
    counters, or resources indicators, you''ll not only need to show literal text
    but also numerical values inside the strings, for example, by combing the word
    `Score:` with a string representation of the actual score, which will change over
    time depending on player performance. One way to achieve this is the `String.Format`
    method, as shown in the following code sample 6-15:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: String looping
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve seen `IEnumerable` and `IEnumerator`. Thankfully, these interfaces
    apply to strings and can be used to loop or cycle through every letter in a string.
    This can be achieved using either the `IEnumerator` interface itself or via a
    `foreach` loop. Let''s see both ways, as shown in the following code sample 6-16
    and 6-17:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating strings
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make your code read better, work in a cleaner way, and generally, be more
    consistent with .NET and the way it''s intended to be used. It''s a good practice
    to avoid initializing string variables as: `string MyString = "";`. Instead, try
    the following code for string declaration and assignment using `String.empty`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Searching strings
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re dealing with multiple lines of text read from a file, such as a
    Text Asset, you might need to find the first occurrence of a smaller string inside
    the larger one, for example, finding a smaller and separate word within the larger
    string. You can achieve this using the `String.IndexOf` method. If a match is
    found, the function would return a positive integer that indicates the position
    in the larger string of the first character of the found word as a measured offset
    from the first letter. If no match is found, the function returns `-1`, as shown
    in the following code sample 6-18:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理从文件中读取的多行文本，例如 Text Asset，你可能需要找到较大字符串中较小字符串的第一个出现，例如，在较大字符串中找到一个较小且独立的单词。你可以使用
    `String.IndexOf` 方法来实现这一点。如果找到匹配项，函数将返回一个正整数，表示找到的单词的第一个字符在较大字符串中的位置，作为从第一个字母测量的偏移量。如果没有找到匹配项，函数返回
    `-1`，如下面的代码示例 6-18 所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Regular expressions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'Occasionally, you might need to perform more complex searches on very large
    strings, such as finding all words in a string beginning with a specific letter,
    all words starting with `a` and ending in `t`, and so on. In these cases, you
    would want the results available in an array if there are any. You can achieve
    this effectively using regular expressions (`Regex`). Regular expressions let
    you define a string value using a conventional and specialized syntax, specifying
    a search pattern. For example, the string `[dw]ay` means "find all words that
    end with `ay` and that also begin with either `d` or `w`. Thus, find all occurrences
    of either day or way". The regular expression can then be applied to a larger
    string to perform a search using the `Regex` class. The .NET framework provides
    access to regular expression searches through the `RegularExpressions` namespace,
    as shown in the following code sample 6-19:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要在非常大的字符串上执行更复杂的搜索，例如找到以特定字母开头的所有单词，所有以 `a` 开头并以 `t` 结尾的单词等。在这些情况下，如果你找到了任何结果，你希望结果可用在数组中。你可以有效地使用正则表达式（`Regex`）来实现这一点。正则表达式允许你使用传统和专门的语法定义一个字符串值，指定搜索模式。例如，字符串
    `[dw]ay` 表示“找到所有以 `ay` 结尾且以 `d` 或 `w` 开头的单词。因此，找到 `day` 或 `way` 的所有出现”。然后可以将正则表达式应用于较大的字符串，使用
    `Regex` 类执行搜索。.NET 框架通过 `RegularExpressions` 命名空间提供对正则表达式搜索的访问，如下面的代码示例 6-19 所示：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are the comments for code sample 6-19:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-19 的注释：
- en: '**Line 05**: The `RegularExpressions` namespace must be included in all source
    files using regular expression searches.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 05 行**：使用正则表达式搜索的所有源文件都必须包含 `RegularExpressions` 命名空间。'
- en: '**Lines 09 and 13**: The string `Search` defines the regular expression itself.
    The string `txt` defines the larger string to be searched by the regular expression.
    The string `Search` searches for all occurrences of the words, `day` and `way`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 09 行和第 13 行**：字符串 `Search` 定义了正则表达式本身。字符串 `txt` 定义了要由正则表达式搜索的较大字符串。字符串
    `Search` 搜索所有出现单词 `day` 和 `way`。'
- en: '**Line 19**: The method `Regex.Match` is called to apply a regular expression
    search on the string `txt`. The results are stored in the local variable `m`.
    This variable can be iterated to scan for all results.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 19 行**：调用 `Regex.Match` 方法对字符串 `txt` 应用正则表达式搜索。结果存储在局部变量 `m` 中。这个变量可以被迭代以扫描所有结果。'
- en: '**Line 25**: The results in `m` will include three matches (not two) based
    on the string `txt`. These will include *day* as found in to*day* as well as *day*
    and *way* by themselves.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 25 行**：在 `m` 中的结果将包括基于字符串 `txt` 的三个匹配项（而不是两个）。这些匹配项将包括在 `to*day*` 中找到的
    `day`，以及单独的 `day` 和 `way`。'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on regular expressions can be found online at [http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多有关正则表达式的信息可以在网上找到，链接为 [http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)。
- en: Infinite arguments
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限参数
- en: 'Though not technically a part of .NET or Mono, our exploration of both these
    libraries has touched several times on functions that accept seemingly an endless
    chain of arguments, such as the `String.Format` function. With `String.Format`,
    it''s possible to plug in as many object arguments as you need for inclusion into
    a formatted string. In this section, I want to take a small (and very quick) diversion
    to show that you can code your own functions that accept and process limitless
    arguments; they''re simple to create. Refer to the following code sample 6-20
    for a function that can sum a potentially limitless array of integers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following are the comments for code sample 6-20:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 01**: To accept a potentially infinite number of arguments, use the
    `params` keyword and declare the argument as an array type'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 05**: The `params` argument can be accessed like a regular array'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language Integrated Query
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, games work with lots of data. They work with not just strings but
    also with objects, databases, tables, documents, and plenty more, too many to
    list here. However, despite the extensiveness and variety of data, there's always
    a common need to filter it, viewing smaller subsets of it as is relevant to our
    needs at the time. For example, given a complete array (or enumerated list) of
    all wizard objects in the scene, we might want to restrict the results even further,
    viewing only wizards whose health is less than 50 percent and whose defense points
    are less than 5\. The purpose is, perhaps, to initiate a mass flee behavior on
    the wizards to find a nearby potion and restore their health before resuming an
    attack on the player. Let's now consider the implementation of this scenario and
    how a technology, Linq, can help us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete Linq sample project can be found in the book's companion files (code
    bundle) at `Chapter06\Linq\`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a very basic and sample definition of a wizard enemy class can be given,
    as shown in the following code sample 6-21\. This class includes both the `Health`
    and `Defense` member variables that are critical to our behavior logic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, given a collection of all enemy objects in the scene, we could filter the
    data into a smaller array according to our criteria with the code, as shown in
    the following code sample 6-22.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'This code effectively loops through all members, runs them through a conditional
    `if` statement, and then, finally adds the enemy to a results array if it passes
    the condition. The condition, in this case, is whether an enemy''s health is less
    than 50 percent and their defense is less than 5:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code works insofar as it restricts a larger data set into a smaller one
    on the basis of a specific criterion. However, Linq lets us achieve the same results
    with less code and often greater performance. Linq is a high-level and specialized
    language to run queries on data sets, including arrays and objects, as well as
    on databases and XML documents. The queries are translated automatically by Linq,
    under the hood, into an appropriate language for the data set used (for example,
    SQL for databases). The aim is to extract the results we need into a regular array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample 6-23 demonstrates an alternative approach to the
    preceding code sample 6-22 using Linq:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following are the comments for code sample 6-23:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 03-04**: To use Linq, you must include the `System.Collections.Linq`
    namespace, and to use `List` objects, you must include the `System.Collections.Generic`
    namespace.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 12-14**: The main body of Linq code occurs here. It consists of three
    main parts. First, we indicated the items to pick from the source data, specifically,
    enemy objects from the data set `Enemies`. Second, we defined the criteria to
    search for, specifically where `EnemyChar.Health <= 50 && EnemyChar.Defense <
    5`. Then, when the criterion is met, we selected that object to add to the results;
    we selected `EnemyChar`. Finally, we converted the results to an array with the
    `ToArray` function.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on Linq can be found online in MSDN at [http://msdn.microsoft.com/en-gb/library/bb397926.aspx](http://msdn.microsoft.com/en-gb/library/bb397926.aspx).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Linq and regular expressions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linq, of course, need not work in isolation. It can, for example, be combined
    with regular expressions to extract specific string patterns from a larger string
    that converts the matched results into a traversable array. This can be especially
    useful in processing comma-separated value files (CSV files), for example, where
    data is formatted inside a text file, each entry being separated by a comma character.
    Both Linq and regular expressions can be used to read each value into a unique
    array element very quickly and easily. For example, consider an RTS game where
    human names must be generated for new units. The names themselves are stored in
    a CSV format and are divided into two groups: male and female. On generating a
    character, it can be either male or female, and an appropriate name must be assigned
    to them from the CSV data, as shown in the following code sample 6-24:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following are the comments for code sample 6-24:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 04**: The member variable `Search` defines a regular expression search
    pattern. The `Search` variable, in this case, is for all words prefixed with `female:`.
    More than this, however, the prefix itself should not be included in the resultant
    strings.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 07**: The member variable `CSVData` defines a complete CSV string with
    both male and female names that are structured in the expected format. This string
    essentially represents the database or data source.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 10-11**: Here, Linq is used in conjunction with a regular expression
    search to retrieve all female names from the CSV, minus the prefixes. This list
    is then converted into a string array `FemaleNames`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Strings and the @ symbol**'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice from line 04 of the code sample 6-24 that the regular expression string
    is prefixed with the symbol `@`. This is a C# convention that allows you to write
    a string literal in a source file; this string literal can contain escape sequences
    (such as `\`) without breaking or invalidating the string itself.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with Text Data Assets
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout all examples so far, we've considered text directly stored in string
    objects, but you can also work with text files in Unity. Specifically, you can
    load in text from external sources. Here, I will demonstrate how.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Text Assets – static loading
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first method is to drag-and-drop a text file into a Unity project that
    imports the text asset. The file is imported as a **TextAssets** type, as shown
    here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Assets – static loading](img/0655OT_06_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Importing text files into Unity as TextAssets
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the file and its text data from any script file by exposing
    a `TextAsset` public member, as shown in the following code sample 6-25:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code means you just need to drag-and-drop the `TextAsset` file onto the
    **Text Data** slot in the Object Inspector, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Assets – static loading](img/0655OT_06_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Accessing text file assets from script
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Text Assets – loading from the local files
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another method to load in text data is externally from the project, that is,
    from files on the local hard drive. Text Data loaded in this way is read into
    the project dynamically from script, not necessarily at scene startup, but whenever
    you execute the necessary code. This means that for longer text files that involve
    heavy processing, lag becomes a serious consideration. In general, therefore,
    it is best to prefer statically loaded Text Assets to dynamic forms. For any dynamic
    assets, I recommend that you load and process them at scene startup to avoid in-game
    lagging, as shown in the following code sample 6-26:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The code sample 6-26 loads a complete text file into one string object. You
    might, however, prefer to process a text file line by line instead, especially
    if the file is a configuration file where values are specified in separate lines.
    For this, see the following code sample 6-27:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Text Assets – loading from the INI files
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among the many text file types, you can load a common format is the INI file.
    It''s, perhaps, not as common with Unity games, because many developers use the
    `PlayerPreferences` class instead to store application settings. Even so, the
    INI files offer the advantage of storing application configuration data in only
    one place and in the same format across many different platforms. For this reason,
    there are strong reasons to use INI files. Refer to the code sample 6-28 for an
    example INI that uses a key-value pairing format:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An ideal data structure to load INI files is the dictionary that mirrors a key-value
    pair structure. For this reason, it'd be great to load an INI file into a dictionary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'However, neither Unity nor Mono offers native support for this, which means
    we have to code the functionality ourselves, as shown in the following code sample
    6-29:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A dictionary returned from this function will match the structure of the INI
    file. Therefore, values can be accessed in the form string `Value = MyDictionary["Key"];`.
    You can also enumerate through all key and value members of a dictionary inside
    a `foreach`, as shown in the following code sample 6-30:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Text Assets – loading from the CSV files
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw how to process a CSV file that features character
    names, both male and female. Let''s now see some source code to load CSV from
    a file on disk into an array of strings, with each string separated by a comma,
    as shown in the following code sample 6-31:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Text Assets – loading from the Web
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re making multiplayer games and need to access player or game data
    across the Web, if you need to verify passwords with hashes online, or if you
    need to access a web page to process its elements, then you will need the `WWW`
    class to retrieve text data online, as shown in the following code sample 6-32:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `WWW` class can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/WWW.html](http://docs.unity3d.com/ScriptReference/WWW.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter considered a wide range of applications for the Mono Framework
    in practical contexts. It took a three-part structure. First, we explored common
    data structures used in C#, including `List`, `Dictionary`, and `Stack`. From
    there, we moved on to investigate their common usages in storing and searching
    data and in organizing and processing strings. We also explored regular expressions
    for searching strings for patterns of data and the Linq language for filtering
    not only strings but all the collection-type objects available in Mono. Then,
    finally, we examined various methods to import text data, both internally to the
    project and from local files, as well as text data streamed across the Web. The
    next chapter moves into the world of artificial intelligence; it considers path-finding,
    finite state machines, line of sight, decision making, ray casting, and more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
