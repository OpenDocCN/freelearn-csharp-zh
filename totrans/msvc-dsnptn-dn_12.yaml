- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Securing Microservices with Bearer Tokens
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用载体令牌保护微服务
- en: Security is one of the most important and tedious aspects of any application.
    We need to ensure that our application is built using secure code and always pursue
    the most effective ways to reduce intrusions and loopholes in our systems. Despite
    this, however, security also comes at the cost of usability, and we should always
    seek to find a balance between the two.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是任何应用最重要的且最繁琐的方面之一。我们需要确保我们的应用是用安全代码构建的，并且始终追求最有效的方法来减少系统中的入侵和漏洞。尽管如此，然而，安全性也以可用性为代价，我们应该始终寻求在这两者之间找到平衡。
- en: Basic application security begins with a login system. We should be able to
    allow a user to register themselves in a system and store some identifying information
    accordingly. When the user returns and wishes to access certain parts of the application,
    we will query the database and verify the identity of the user through their identifying
    information and decide to grant or restrict access accordingly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基本应用安全始于登录系统。我们应该能够允许用户在系统中注册自己并相应地存储一些标识信息。当用户返回并希望访问应用的部分内容时，我们将查询数据库并通过他们的标识信息验证用户的身份，然后决定相应地授予或限制访问。
- en: In modern applications, we find it increasingly difficult to maintain a data
    store as an authority on all our users, while accounting for all the possible
    channels through which they may access our application. We have been exploring
    using microservices architecture, which takes our security considerations to a
    new level, where we now have multiple parts of an application that we need to
    secure for different users who are accessing from several devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代应用中，我们发现维护一个作为我们所有用户权威的数据存储变得越来越困难，同时还要考虑到他们可能通过的所有可能的渠道访问我们的应用。我们一直在探索使用微服务架构，这使我们的安全考虑达到了新的水平，我们现在需要为从多个设备访问的不同用户保护应用的不同部分。
- en: In this chapter, we will explore the major considerations to be made in securing
    our microservices application and the best configurations and technologies to
    use.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在保护我们的微服务应用时需要考虑的主要因素，以及最佳配置和技术。
- en: 'After reading this chapter, we will have done the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，我们将完成以下内容：
- en: Understand bearer token security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解载体令牌的安全性
- en: Learn how to implement bearer token security in an ASP.NET Core API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在ASP.NET Core API中实现载体令牌安全性
- en: Learn how to use an identity provider to secure our microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用身份提供者来保护我们的微服务
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code references used in this chapter can be found in the project repository
    that is hosted on GitHub here: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码示例可以在GitHub上托管的项目存储库中找到：[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12)。
- en: Bearer tokens for securing communications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于保护通信的载体令牌
- en: Bearer tokens are a fairly recent solution to a number of security, authentication,
    and authorization challenges that we have faced when developing modern applications.
    We have gone from working with standard desktop and web applications to catering
    to various internet-capable devices that have similar security needs. Before we
    start exploring what these modern security needs are, let us review some of the
    challenges that we have faced with web applications over the years.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 载体令牌是针对我们在开发现代应用时面临的一系列安全、身份验证和授权挑战的相对较新的解决方案。我们已经从处理标准桌面和Web应用转变为满足具有类似安全需求的多种互联网设备。在我们开始探索这些现代安全需求之前，让我们回顾一下我们在过去几年中面临的Web应用的一些挑战。
- en: 'When securing web applications, we face several challenges:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在保护Web应用时，我们面临着几个挑战：
- en: We need a way to collect user information.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个方法来收集用户信息。
- en: We need a way to store user information.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个存储用户信息的方法。
- en: We need a way to validate user information. This is called *authentication*.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个验证用户信息的方法。这被称为*身份验证*。
- en: We need a way to track the user’s authenticated state in between requests.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个方法来跟踪用户在请求之间的认证状态。
- en: We need a way to track what the user is allowed to do in our system. This is
    called *authorization*.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个方法来跟踪用户在我们系统中被允许做什么。这被称为*授权*。
- en: We need to cater to various channels or device types through which a user might
    access the web application.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要满足用户可能通过各种渠道或设备类型访问Web应用程序的需求。
- en: In a typical web application, most of these factors can be implemented through
    form authentication, where we ask for uniquely identifying information and check
    our database for a match.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的Web应用程序中，大多数这些因素可以通过表单认证来实现，我们要求提供唯一标识信息，并在数据库中查找匹配项。
- en: 'When a match is found, we instantiate a temporary storage mechanism that will
    identify the user as authenticated in our system. This temporary storage construct
    can come in the form of the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到匹配项时，我们实例化一个临时存储机制，该机制将识别用户在我们的系统中已认证。这个临时存储结构可以以下列形式出现：
- en: '**Sessions**: A way to store information in a variable that can be used across
    a website. Unlike typical variables that lose their value with each request, a
    session retains its value for a certain period until it either expires or is destroyed.
    Session variables are typically stored on the server, and one or many session
    variables are created each time a user authenticates successfully. Session variables
    can store information such as a username, role, and so on. With too many users
    logging in simultaneously, using session variables can lead to memory issues on
    a less powerful server.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：一种在网站中存储信息的方法，可以在多个请求之间使用该变量。与每个请求都会丢失其值的典型变量不同，会话保留其值一段时间，直到它过期或被销毁。会话变量通常存储在服务器上，每次用户成功认证时都会创建一个或多个会话变量。会话变量可以存储诸如用户名、角色等信息。当有太多用户同时登录时，使用会话变量可能导致在较弱的服务器上出现内存问题。'
- en: '**Cookies**: An alternative to sessions, where a small file is created and
    stored on the user’s device. It serves a similar purpose for storing information
    between requests, as well as tracking a user’s authenticated state. Each time
    a request is sent from the user’s device, this cookie is sent, and the server
    web application uses this information to be informed of whether actions can be
    taken and if so, which ones. Cookies are sometimes preferred to sessions given
    that they reduce the load on the server and place more responsibility on the user’s
    device.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookies**：会话的替代方案，其中在用户的设备上创建并存储一个小文件。它用于在请求之间存储信息，以及跟踪用户的认证状态。每次从用户的设备发送请求时，都会发送这个cookie，服务器Web应用程序使用这些信息来了解是否可以采取行动，以及如果可以，哪些行动。由于cookies可以减少服务器的负载并将更多责任放在用户的设备上，因此有时它们比会话更受欢迎。'
- en: Both options work fantastically when we are sure that we will be dealing with
    a web application that maintains a *state*. A state means that we retain user
    information in between requests and remember who is logged in and their basic
    information for the period that they are using the website – but what happens
    when you need to authenticate against APIs? An API, by nature, does not maintain
    a state. It does not attempt to retain the knowledge of the users accessing it
    since APIs are designed for sporadic access from any channel at any point. For
    this reason, we implement bearer tokens.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确信将要处理的是一个维护*状态*的Web应用程序时，这两种选项都表现得非常出色。状态意味着我们在请求之间保留用户信息，并记住谁登录以及他们在使用网站期间的基本信息——但是当你需要针对API进行认证时会发生什么？API本质上不维护状态。它不会尝试保留访问它的用户的认知，因为API是为任何渠道在任何时间点的偶然访问而设计的。因此，我们实现了载体令牌。
- en: A bearer token is an encoded string that contains information about a user who
    is attempting to communicate with our API. It helps us facilitate stateless communication
    and facilitate general user authentication and authorization scenarios.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 载体令牌是一个包含尝试与我们API通信的用户信息的编码字符串。它帮助我们实现无状态通信，并促进一般的用户认证和授权场景。
- en: Understanding bearer tokens
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解载体令牌
- en: A *bearer token* or **JSON Web Token** (**JWT**) is a construct that is widely
    used in *authentication* and *authorization* scenarios for *stateless* APIs. Bearer
    tokens are based on an open industry standard of authentication that has made
    it easy for us to share authenticated user information between a server and a
    client. When an API is accessed, a temporary state is created for the duration
    of the request-response cycle. This means that when the request is received, we
    can determine the originating source of the request and can decode additional
    header information as needed. Once a response is returned, we no longer have a
    record of the request, where it came from, or who made it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*承载令牌*或**JSON Web Token**（JWT）是一种在*认证*和*授权*场景中广泛使用的*无状态*API的构造。承载令牌基于一个开放的行业标准认证，这使得我们能够在服务器和客户端之间轻松共享认证用户信息。当访问API时，会在请求-响应周期内创建一个临时状态。这意味着当收到请求时，我们可以确定请求的来源，并根据需要解码额外的头部信息。一旦返回响应，我们就不再有请求的记录，也不知道它来自哪里，或者是由谁发起的。'
- en: 'Bearer tokens are issued after a successful authentication request. We receive
    a request to our authentication API endpoint and use the information to check
    our databases, as previously described. Once a user is verified, we compile several
    data points, such as the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 承载令牌在成功认证请求后发放。我们收到对认证API端点的请求，并使用之前描述的信息来检查我们的数据库。一旦用户得到验证，我们就收集几个数据点，如下所示：
- en: '**Subject**: Usually a unique identifier for the user, such as the user ID
    from the originating database.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：通常是指用户的唯一标识符，例如来自原始数据库的用户ID。'
- en: '**Issuer**: Usually a name that is associated with the service that has generated
    the token for issuance.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者**：通常是与生成令牌以供发放的服务相关联的名称。'
- en: '**Audience**: Usually a name that is associated with the client application
    that will be consuming the token.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受众**：通常是与将消费令牌的客户端应用程序相关联的名称。'
- en: '**Username**: The user’s unique system name, usually used for login.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：用户的唯一系统名称，通常用于登录。'
- en: '**Email address**: The user’s email address.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件地址**：用户的电子邮件地址。'
- en: '**Role**: The user’s system role that determines what they are authorized to
    do.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：用户的系统角色，它决定了他们被授权执行的操作。'
- en: '**Claims**: Various bits of information about the user that can be used to
    aid in authorization or information display in the client application. This can
    include the user’s name, gender, and even the path to their profile picture.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：关于用户的各个信息片段，可用于在客户端应用程序中辅助授权或信息显示。这可以包括用户的名字、性别，甚至他们个人资料的路径。'
- en: '**Expiry Date**: Tokens should always have a moderate expiry date relative
    to their generation. When this expires, the user will need to reauthenticate,
    so we don’t want it to only be valid for a short period, but it should also not
    last forever.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期日期**：令牌应该始终有一个相对于其生成的适度过期日期。当它过期时，用户将需要重新认证，所以我们不希望它只有效很短的时间，但也不要永远有效。'
- en: 'Ultimately, a login flow between a client application and an API is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，客户端应用程序与API之间的登录流程如下：
- en: A user will use a client application to log in
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将使用客户端应用程序进行登录
- en: The client application forwards the information collected from the login form
    to the login API endpoint for verification
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序将登录表单收集到的信息转发到登录API端点进行验证
- en: The API returns an encoded string, or token, that contains the most relevant
    bits of information about the user
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API返回一个包含有关用户最相关信息片段的编码字符串或令牌
- en: The client application stores this encoded string and uses it for subsequent
    API communications
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序存储这个编码字符串，并用于后续的API通信
- en: Based on this kind of flow, the client application will use information from
    the token to display information about the user on the UI, such as the username
    or other information that may have been included such as the first name and last
    name. While there are recommended bits of information that you should include
    in a token, there is no set standard on what should be included. We do, however,
    avoid including sensitive information, such as a password.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种流程，客户端应用程序将使用令牌中的信息在用户界面（UI）上显示有关用户的信息，例如用户名或其他可能包含的信息，如名字和姓氏。虽然有一些推荐的信息片段应该包含在令牌中，但没有固定的标准规定应该包含什么。然而，我们确实避免包含敏感信息，例如密码。
- en: 'Bearer tokens are encoded but not encrypted. This means that they are self-contained
    blocks of information that contain all the information that we have mentioned
    earlier but are not human-readable at first sight. The encoding compresses the
    strings, usually as a *base64* representation, and this is the format used for
    transportation between the client and the server, as well as for storage. Token
    strings are not meant to be secure since it is easy to decode the string and see
    the information therein, and once again, that is why we do not include sensitive
    and incriminating data in the token. This token string comprises three sections.
    Each section is separated by a full stop (*.*) and the general format is *aaaa.bbbb.cccc*.
    Each section represents the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: The *a* section of the token, which contains information about
    the type of token and the signing algorithm that was used for the encoding, such
    as HMAC SHA-256 and RSA.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: The *b* section of the token string, which contains user information
    in the form of claims. We will discuss claims in a bit more detail later in this
    chapter.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: The *c* section of the token, which contains a string representation
    of the encoded header, the encoded payload, and the secret key that was used for
    the encoding. This signature is used to verify that the token has not been tampered
    with since its generation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most development frameworks include tools and libraries that can decrypt bearer
    tokens during the runtime of the application. Since bearer tokens are based on
    an open standard, support for decoding tokens is widely available. This allows
    us to write generic and consistent code to handle tokens being issued by an API.
    Each API implementation can include different tokens relative to the exact needs
    of the application, but there are certain standards that we can always count on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: During development, however, we might want to test a token to see the contents
    that we can expect to be present in a more human-readable form. For this reason,
    we turn to third-party tools that decode and show us the contents of a token and
    allow us to reference different bits of information as needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as **jwt.io** provide us with the ability to simply paste in a token
    and view the information in a more human-readable format. As stated, there are
    three sections in each token string and we can view each of the sections in plaintext
    using this website or a similar tool. The payload section of the token, when decoded,
    will yield the information displayed in *Figure 12.1*. It shows a sample bearer
    token and its contents on [www.jwt.io](http://www.jwt.io).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – We see the encoded string and the plaintext translation of
    its contents to the right](img/Figure_12.1_B19100.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – We see the encoded string and the plaintext translation of its
    contents to the right
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'All the information that is placed into a bearer token represents a key-value
    pair. Each key-value pair represents a unit of information about the user or the
    token itself, and the keys are really short names for the previously mentioned
    claims that are usually present in a token:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 放入携带令牌中的所有信息都代表一个键值对。每个键值对代表关于用户或令牌本身的信息单元，而键实际上是之前提到的通常存在于令牌中的声明的简短名称：
- en: '**iss**: Represents the **issuer** value.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iss**：代表**发行者**值。'
- en: '**sub**: Represents the **subject** value.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sub**：代表**主题**值。'
- en: '**aud**: Represents the **audience** value.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aud**：代表**受众**值。'
- en: '**nonce**: Represents a unique value that should always change with each token
    to prevent replay attacks. This value is always new, and this ensures that no
    two tokens that are issued to the same user are the same. This can sometimes be
    called a **jti** claim.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nonce**：代表一个唯一值，该值应始终与每个令牌一起变化，以防止重放攻击。此值始终是新的，这确保了不会向同一用户发行的任何两个令牌是相同的。有时这个值也可以称为**jti**声明。'
- en: '**exp**: Represents the expiration date of the token. The value is in the form
    of a UNIX epoch, which is a numerical representation of a moment in time.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exp**：代表令牌的过期日期。值以UNIX纪元的形式表示，这是一个时间的数值表示。'
- en: '**iat**: Represents the date and time of issuance.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iat**：代表发行日期和时间。'
- en: Now that we have explored why we need bearer tokens and how they are used, let
    us review how we can implement token security in our ASP.NET Core API application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了为什么我们需要携带令牌以及它们是如何被使用的，让我们回顾一下我们如何在ASP.NET Core API应用程序中实现令牌安全。
- en: Implementing bearer token security
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现携带令牌安全
- en: ASP.NET Core offers native authentication and authorization support through
    its `Identity Core` library. This library has direct integration with Entity Framework
    and allows us to create standard user management tables in the target database.
    We can also further specify the authentication methods that we prefer and define
    policies that define authorization rules throughout that application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core通过其`Identity Core`库提供原生的身份验证和授权支持。这个库与Entity Framework直接集成，允许我们在目标数据库中创建标准的用户管理表。我们还可以进一步指定我们偏好的身份验证方法，并定义定义整个应用程序中授权规则的政策。
- en: 'This robust library has built-in support for the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的库内置了对以下功能的支持：
- en: '**User registration**: The user manager library has functions that make user
    creation and management easy. It has functions that cover most of the common user
    management operations.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户注册**：用户管理器库具有使用户创建和管理变得简单的功能。它包含覆盖大多数常见用户管理操作的功能。'
- en: '**Login, session, and cookie management**: The sign-in manager library has
    functions that can manage user authentication and session management scenarios.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录、会话和cookie管理**：登录管理器库具有管理用户身份验证和会话管理场景的功能。'
- en: '**Two-factor authentication**: Identity Core allows us to implement multi-factor
    authentication natively with email or SMS. This can be easily extended.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双因素身份验证**：Identity Core允许我们通过电子邮件或短信原生前置多因素身份验证。这可以轻松扩展。'
- en: '`Identity Core` makes it easy to integrate this feature into your application.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Identity Core`使得将此功能集成到您的应用程序中变得简单。'
- en: Securing an API using bearer tokens ensures that each API call is required to
    have a valid token in the header section of the request. An HTTP header allows
    for additional information to be provided with an HTTP request or response.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用携带令牌保护API确保每个API调用都需要在请求的头部部分包含一个有效的令牌。HTTP头部允许在HTTP请求或响应中提供额外的信息。
- en: In our case of securing an API, we enforce that each request must have an authorization
    header that contains the bearer token. Our API will assess the incoming request
    headers, retrieve the token, and validate it against the predefined configurations.
    If the token doesn’t meet the standards or is expired, an `HTTP 401 Unauthorized`
    response will be returned. If the token meets the requirements, then the request
    will be fulfilled. This built-in mechanism makes it easy and maintainable to support
    wide-scale and robust authentication and authorization rules in our application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们保护API的案例中，我们强制要求每个请求都必须包含一个包含携带令牌的授权头部。我们的API将评估传入的请求头部，检索令牌，并对其与预定义配置进行验证。如果令牌不符合标准或已过期，将返回`HTTP
    401 未授权`响应。如果令牌符合要求，则请求将被满足。这种内置机制使得在应用程序中支持广泛的、健壮的身份验证和授权规则变得简单且易于维护。
- en: Now that we have an idea of the `Identity Core` library and how it is natively
    supported in ASP.NET Core applications, we can explore the necessary package and
    configurations needed to secure an API using bearer tokens.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`Identity Core`库以及它在ASP.NET Core应用程序中的原生支持，我们可以探索使用bearer tokens保护API所需的必要包和配置。
- en: Securing API with bearer tokens
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bearer tokens保护API
- en: 'We can begin by installing the following packages using the NuGet package manager:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用NuGet包管理器安装以下包：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first package supports direct integration between Entity Framework and `Identity
    Core`. The second package contains extended methods that allow us to implement
    token generation and validation rules in our API configuration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包支持Entity Framework和`Identity Core`之间的直接集成。第二个包包含扩展方法，允许我们在API配置中实现token生成和验证规则。
- en: 'Next, we need to define constant values that will inform the token generation
    and validation activities in the API. We can place these constants in `appsettings.json`
    and they will look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义常量值，这些值将告知API中的token生成和验证活动。我们可以将这些常量放在`appsettings.json`中，它们将如下所示：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have already discussed what the issuer and audience values help to enforce.
    We can also state a value for the proposed lifetime of the token that is generated.
    This value should always be relative to the API’s capabilities and operations,
    as well as your risk tolerance. The longer a token remains valid, the longer we
    provide a potential attacker with a window into our system. At the same time,
    if the period is too short, then the client will need to reauthenticate too often.
    We should always seek to strike a balance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了发行者和受众值如何帮助强制执行。我们还可以为生成的token提出一个建议的有效期。这个值应该始终相对于API的功能和操作以及您的风险承受能力来考虑。token的有效期越长，我们提供给潜在攻击者的系统窗口就越大。同时，如果期限太短，那么客户端将需要频繁地重新认证。我们应该始终寻求寻求平衡。
- en: Our key value here is demonstrative in its value, but we use this signing key
    as an encryption key when generating the token. The key should always be kept
    secret, so we may use application secrets or a more secure key store to store
    this value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的关键值具有示范性的价值，但我们使用这个签名密钥作为生成token的加密密钥。密钥应该始终保密，因此我们可以使用应用程序密钥或更安全的密钥存储来存储这个值。
- en: 'Now that we have the application constants, we can proceed to specify the global
    authentication settings in our `Program.cs` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序常量，我们可以继续在`Program.cs`文件中指定全局身份验证设置：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are adding configurations to the application that will declare to the
    API application that it should enforce a particular type of authentication scheme.
    Given that Identity Core has support for several authentication schemes, we need
    to specify the ones that we intend to enforce and by extension, the type of challenge
    scheme that we require. The challenge scheme refers to the authentication requirements
    that the application will need. Here, we specify `JwtBearerDefaults.AuthenticationScheme`
    for both the challenge and authentication schemes. This `JwtBearerDefaults` class
    contains generally available and used JWT constants. In this case, `AuthenticationScheme`
    will render the value bearer, which is a keyword.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在向应用程序添加配置，这将向API应用程序声明它应该强制执行特定的身份验证方案。鉴于Identity Core支持多种身份验证方案，我们需要指定我们打算强制执行的方案以及扩展到所需的挑战方案类型。挑战方案指的是应用程序将需要的身份验证要求。在这里，我们指定`JwtBearerDefaults.AuthenticationScheme`作为挑战和身份验证方案。这个`JwtBearerDefaults`类包含通常可用和使用的JWT常量。在这种情况下，`AuthenticationScheme`将渲染值为bearer，这是一个关键字。
- en: After we are done defining the authentication scheme, we go on to set configurations
    that will enforce certain rules that will govern how a bearer token is validated.
    By using `true` for `ValidateIssuer`, `ValidateAdience`, and `ValidateLifetime`,
    we are enforcing that the matching values in an incoming token must match the
    values that we set in the `appsettings.json` configuration constants. You can
    be flexible with the validation rules based on how strictly you want to check
    the bearer token contents against your system. The fewer validations in place,
    the higher the chances of someone using fake tokens to gain access to the system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成定义身份验证方案后，我们继续设置将强制执行某些规则的配置，这些规则将决定如何验证令牌。通过将 `ValidateIssuer`、`ValidateAudience`
    和 `ValidateLifetime` 设置为 `true`，我们强制要求传入令牌中的匹配值必须与我们设置在 `appsettings.json` 配置常量中的值相匹配。您可以根据您想要如何严格检查令牌内容与系统之间的匹配程度来灵活设置验证规则。验证规则越少，有人使用伪造令牌获取系统访问权限的可能性就越高。
- en: 'We will also need to ensure that our API knows that we intend to support authorization,
    so we need to add this line as well:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保我们的 API 知道我们打算支持授权，因此我们还需要添加以下行：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we also need to include our middleware with the following two lines,
    in this order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要按照以下顺序包含我们的中间件：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have taken care of the preliminary configurations, we need to include
    our default identity user tables in our database. We first change the inheritance
    of our database context from `DbContext` to `IdentityDbContext`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了初步配置，我们需要将我们的默认身份用户表包含到数据库中。我们首先将数据库上下文的继承从 `DbContext` 改为 `IdentityDbContext`：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will also add code to generate a sample user in the database context. When
    we perform the next migration, then this user will be added to the table and we
    can use it to test authentication:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加代码在数据库上下文中生成一个示例用户。当我们执行下一个迁移时，此用户将被添加到表中，我们可以用它来测试身份验证：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After these changes, the next migration that we perform will generate user tables
    that will be created when the `update-database` command is executed. These new
    tables will, by default, be prefixed with `AspNet`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，我们执行的下一个迁移将生成在执行 `update-database` 命令时创建的用户表。默认情况下，这些新表将以前缀 `AspNet`
    开头。
- en: 'We also need to register the `Identity Core` services in our application and
    connect it to the database context as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的应用程序中注册 `Identity Core` 服务并将其连接到数据库上下文，如下所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we register our identity-related services in our applications, specify
    that we are using the default user type called `IdentityUser`, the default role
    type called `IdentityRole`, and the data store associated with `AppointmentsDbContext`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在应用程序中注册与身份相关的服务，指定我们正在使用默认的用户类型 `IdentityUser`、默认的角色类型 `IdentityRole`
    以及与 `AppointmentsDbContext` 关联的数据存储。
- en: Now that we have specified what is required for the integration of `Identity
    Core` and JWT authentication, we can look to implement a login endpoint that will
    verify the user’s credentials and generate a token with the minimum identifying
    information accordingly. We will investigate this in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了 `Identity Core` 和 JWT 身份验证集成所需的配置，我们可以着手实现一个登录端点，该端点将验证用户的凭据并根据需要生成包含最少识别信息的令牌。我们将在下一节中探讨这个问题。
- en: Generating and issuing bearer tokens
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成和颁发令牌
- en: 'ASP.NET Core has support for generating, issuing, and validating bearer tokens.
    To do this, we need to implement logic in our authentication flow that will generate
    a token with the authenticated user’s information, and then return it to the requesting
    client in the body of the response. Let us first define a `Id` value and the token
    and wrap them both in their own `AuthResponseDto`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 支持生成、颁发和验证令牌。为此，我们需要在我们的身份验证流程中实现逻辑，以生成包含已认证用户信息的令牌，并将其作为响应体返回给请求客户端。让我们首先定义一个
    `Id` 值和令牌，并将它们都包装在它们自己的 `AuthResponseDto` 中：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will also have a DTO that will accept login information. We can call this
    `LoginDto`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个 DTO 接受登录信息。我们可以称这个 DTO 为 `LoginDto`：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our DTO will enforce validation rules on the data being submitted. Here, our
    users can authenticate using their email address and a password, and invalid attempts
    that violate the validation rules will be rejected with a `400BadRequest` HTTP
    code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DTO 将对提交的数据执行验证规则。在这里，我们的用户可以使用他们的电子邮件地址和密码进行身份验证，任何违反验证规则的无效尝试都将使用 `400BadRequest`
    HTTP 状态码被拒绝。
- en: 'Our authentication controller will implement a login action that will accept
    this DTO as a parameter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We inject an `IAuthmanager` service into the controller, where we have abstracted
    the bulk of the user validation and token generation logic. This service contract
    is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the implementation of `AuthManager`, we use the `UserManager` service, which
    is provided by `Identity Core`, to verify the username and password combination
    that is submitted. Upon verification, we will generate and return an `AuthResponseDto`
    object containing the token and user’s ID. Our implementations will look like
    the following code block:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We inject both `UserManager` and `IConfiguration` into our `AuthManager`. In
    our login method, we attempt to retrieve the user based on the email address that
    was provided in `LoginDto`. If we then attempt to validate that the correct password
    was provided. If there is no user, or the password was incorrect, we return a
    null value, which the login action will use to indicate that no user was found
    and will return a `401 Unauthorized` HTTP response.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can validate the user, then we generate a token and then return our `AuthResponseDto`
    object with the token and the user’s `Id` value. The method to generate the token
    is also in `AuthManager` and it looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this method, we start by retrieving our security key from `appsettings.json`
    through the `IConfiguration` service. We then encode and encrypt this key. We
    also compile the standard claims that should generally be included in a token,
    and we can include other claim values, whether from the user’s claims in the database
    or custom claims that we deem necessary.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'We finally compile all the claims and other key values such as these:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`SigningCredentials` with the value of the encrypted key'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Issuer* and *Audience* as defined in `appsettings.json`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The jti claim, which is a unique identifier, or *nonce* for the token.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expiration date and time of the token, relative to the time limit from the
    configuration
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is a string full of encoded characters that is returned to our `Login`
    method, and this is then returned to the controller with `AuthResponseDto`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for our `AuthManager` to be useable in our controller, we need to
    register the interface and implementation in our `Program.cs` file using this
    line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With these configurations in place, we can protect our controllers and actions
    with a simple `[Authorize]` attribute. This attribute will be placed directly
    above the implementation of our class or the action method. Our API will automatically
    assess each incoming request for an authorization header value and automatically
    reject requests that have no token or violate the rules that were stipulated in
    `TokenValidationParameters`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we use a tool such as **Swagger UI** or **Postman**, to test our
    login endpoint using the test user that we seeded, we will receive a token response
    that looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Implementing token authentication in an API is easy enough, but we are not only
    accounting for one API in our application. We have several APIs that need to be
    secured and preferably, one token should be accepted across all the services.
    If we continue down this path, we may end up making these configurations per service
    and then needing extra code to have all the other services acknowledge a token
    that might be issued by any other service.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在API中实现令牌认证相对简单，但我们不仅在我们的应用程序中考虑一个API。我们有多个API需要被保护，并且最好，一个令牌应该被所有服务接受。如果我们继续沿着这条路走下去，我们可能会为每个服务进行这些配置，然后需要额外的代码来让所有其他服务认可可能由任何其他服务发行的令牌。
- en: We need a more global solution and more suitably, a central authority of security
    and token generation and management for all the services in our microservices
    application. This is where we begin to explore separating the token management
    responsibilities from each API and placing them in one that implements **IdentityServer**,
    which is **OpenID Connect** and the **OAuth 2.0** framework for ASP.NET Core.
    We will investigate implementing **IdentityServer** in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个更全局的解决方案，更合适的是，为我们的微服务应用中的所有服务提供一个安全和令牌生成及管理的中央权威机构。这就是我们开始探索将令牌管理责任从每个API中分离出来，并将它们放在一个实现**IdentityServer**的API中的地方，它是ASP.NET
    Core的**OpenID Connect**和**OAuth 2.0**框架。我们将在下一节中研究实现**IdentityServer**。
- en: Using IdentityServer4 to secure microservices
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IdentityServer4来保护微服务
- en: A key feature in any modern application or suite of applications is the concept
    of **single-sign-on** (**SSO**). This feature allows us to provide our credentials
    once and retain an authenticated user state across several applications within
    the suite. This is a feature that can be observed in Google or Microsoft Online
    products, to name a few.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现代应用程序或应用程序套件的关键特性之一是**单点登录**（**SSO**）的概念。此功能使我们能够一次性提供我们的凭据，并在套件中的多个应用程序之间保持已验证的用户状态。这是可以在谷歌或微软在线产品中观察到的功能，仅举几个例子。
- en: This concept will come in handy when securing a microservices application. As
    we can see, it is not feasible to implement token-issuing logic in many APIs across
    an application and then attempt to coordinate access to all the APIs when it was
    granted to one. We also run the risk of requiring a user to reauthenticate each
    time they attempt to access a feature that requires another API to complete, and
    this will not make for a good user experience.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当保护微服务应用程序时，这个概念将非常有用。正如我们所看到的，在应用程序的许多API中实现令牌发行逻辑，然后尝试协调对已授予一个API的所有API的访问，这是不可行的。我们还面临要求用户每次尝试访问需要另一个API来完成的功能时都需要重新认证的风险，这不会是一个好的用户体验。
- en: With these considerations in mind, we need to use a central authority that can
    allow us to implement more global token issuing and validation rules given all
    the security considerations of our services. In ASP.NET Core, the best candidate
    for such services is **IdentityServer**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，我们需要使用一个中央权威机构，它可以允许我们根据我们服务的所有安全考虑实施更全局的令牌发行和验证规则。在ASP.NET Core中，此类服务的最佳候选者是**IdentityServer**。
- en: '`Identity Core` and allows developers to support **OpenID Connect** and **OAuth2.0**
    standards in their web application security implementation. It is compliant with
    industry standards and contains out-of-the-box support for token-based authentication,
    SSO, and API access control in your applications. While it is a commercial product,
    a community edition is available for use by small organizations or personal projects.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Identity Core`并允许开发者在他们的Web应用程序安全实现中支持**OpenID Connect**和**OAuth2.0**标准。它符合行业标准，并包含针对基于令牌的认证、SSO和应用程序中的API访问控制的即插即用支持。虽然它是一个商业产品，但社区版可供小型组织或个人项目使用。'
- en: 'The recommended implementation style of **IdentityServer** would have us do
    the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**IdentityServer**推荐的实现方式如下：'
- en: Create a new microservice for authentication
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为认证创建一个新的微服务
- en: Create a new database just for our authentication-related tables (optional)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的认证相关表创建一个新的数据库（可选）
- en: Configure scopes to be included in the token information
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置要包含在令牌信息中的作用域
- en: Configure our services to know which scopes are allowed to access them
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置我们的服务以了解哪些作用域允许访问它们
- en: '*Figure 12.2* shows the IdentityServer authentication flow:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.2*显示了IdentityServer认证流程：'
- en: "![Figure 12.2 – This depicts how IdentityServer sits between a client and service\
    \ and handles the flow of authentication and token exchange\uFEFF](img/Figure_12.2_B19100.jpg)"
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 这描述了 IdentityServer 如何位于客户端和服务之间，并处理身份验证和令牌交换](img/Figure_12.2_B19100.jpg)'
- en: Figure 12.2 – This depicts how IdentityServer sits between a client and service
    and handles the flow of authentication and token exchange
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 这描述了 IdentityServer 如何位于客户端和服务之间，并处理身份验证和令牌交换的流程
- en: Now, let us explore creating a new service and configuring it to be our central
    authority for authentication and authorization in our microservices application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索创建一个新的服务并将其配置为我们的微服务应用程序中身份验证和授权的中心权威。
- en: Configuring IdentityServer
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 IdentityServer
- en: 'Duende offers us some quick-start ASP.NET Core project templates that are easy
    to create in our solution. These quick-start templates bootstrap the minimum requirements
    needed to bootstrap IdentityServer functionality in an ASP.NET Core project. The
    general steps involved in setting up an IdentityServer service are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Duende 为我们提供了一些快速入门的 ASP.NET Core 项目模板，这些模板在我们的解决方案中易于创建。这些快速入门模板启动了在 ASP.NET
    Core 项目中启动 IdentityServer 功能所需的最小要求。设置 IdentityServer 服务的常规步骤如下：
- en: Add Duende IdentityServer support to a standard ASP.ENT Core project
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Duende IdentityServer 支持添加到标准 ASP.ENT Core 项目
- en: Add data storage support, preferably using Entity Framework configurations
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数据存储支持，最好使用 Entity Framework 配置
- en: Add support for ASP.NET `Identity Core`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对 ASP.NET `Identity Core` 的支持
- en: Configure token issuing for client applications
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为客户端应用程序配置令牌发行
- en: Secure client applications with IdentityServer
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IdentityServer 保护客户端应用程序
- en: 'To get started, we need to use the .NET CLI and run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要使用 .NET CLI 并运行以下命令：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That command will now give us access to new project templates prefixed with
    `Duende.IdentityServer`. *Figure 12.3* depicts what we can expect to see in Visual
    Studio once these templates are installed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令现在将为我们提供访问以 `Duende.IdentityServer` 为前缀的新项目模板。*图 12.3* 展示了在 Visual Studio
    中安装这些模板后我们可以期待看到的内容。
- en: '*Figure 12.3* shows the Duende IdentityServer project templates:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.3* 展示了 Duende IdentityServer 项目模板：'
- en: '![Figure 12.3 – We get a variety of project templates that help us to speed
    up the IdentityServer implementation process](img/Figure_12.3_B19100.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 我们得到了各种项目模板，这些模板有助于我们加快 IdentityServer 的实现过程](img/Figure_12.3_B19100.jpg)'
- en: Figure 12.3 – We get a variety of project templates that help us to speed up
    the IdentityServer implementation process
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 我们得到了各种项目模板，这些模板有助于我们加快 IdentityServer 的实现过程
- en: 'Using our healthcare microservices application, let us start by adding a new
    `HealthCare.Auth`. Now, we have a preconfigured IdentityServer project with several
    moving parts. We need to understand what the major components are and have an
    appreciation of how we can manipulate them for our needs. Let us conduct a high-level
    review of the file and folder structure that we get out of the box:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的医疗微服务应用程序，让我们首先添加一个新的 `HealthCare.Auth`。现在，我们有一个预配置的包含多个组件的 IdentityServer
    项目。我们需要了解主要组件是什么，并欣赏我们如何根据我们的需求操纵它们。让我们对开箱即得的文件和文件夹结构进行高级审查：
- en: '`Wwwroot`: A standard folder that is shipped with ASP.NET Core web application
    templates. It stores static assets such as JavaScript and CSS files that are used
    in the website.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wwwroot`: 这是与 ASP.NET Core 网络应用程序模板一起提供的标准文件夹。它存储用于网站中的静态资产，如 JavaScript 和
    CSS 文件。'
- en: '`Migrations`: Stores preset migrations that will be used to populate the data
    store with supporting tables. This is handy, as it removes the need for us to
    create the databases.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Migrations`: 存储预设迁移，这些迁移将用于用支持表填充数据存储。这很方便，因为它消除了我们创建数据库的需要。'
- en: '`Pages`: Stores default Razor pages that are used to support the UI requirements
    of user authentication operations. Out of the box, we get login, register, grant,
    and user data management pages.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages`: 存储用于支持用户身份验证操作 UI 要求的默认 Razor 页面。开箱即得，我们得到登录、注册、授权和用户数据管理页面。'
- en: '`appsettings.json`: The standard file that contains logging and database connection
    configurations. We can change this connection string to reflect our requirements
    better.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json`: 这是包含日志和数据库连接配置的标准文件。我们可以更改这个连接字符串以更好地反映我们的需求。'
- en: '`buildschema.bat`: Contains Entity Framework commands using .NET command-line
    commands (`dotnet ef`) that will run migration scripts that have been included
    in the `Migrations` folder. We will use these commands to create our databases.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildschema.bat`: 包含使用.NET命令行命令（`dotnet ef`）的Entity Framework命令，这些命令将运行包含在`Migrations`文件夹中的迁移脚本。我们将使用这些命令来创建我们的数据库。'
- en: '`Config.cs`: This static class serves as a configuration authority. It is used
    to outline `IdentityResources`, `Scopes`, and `Clients`:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Config.cs`: 这个静态类作为配置权威机构。它用于概述`IdentityResources`、`Scopes`和`Clients`：'
- en: '`IdentityResources`: Map to scopes that grant access to identity-related information.
    The `OpenId` method supports the expected *subject* (or *sub*-claim) value and
    the `Profile` method supports additional claim information such as `given_name`
    and `family_name`. We can also extend the default offerings and include additional
    details such as the user’s *roles*.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IdentityResources`：映射到授予访问身份相关信息的范围。`OpenId`方法支持预期的*主题*（或*sub*-声明）值，而`Profile`方法支持额外的声明信息，如`given_name`和`family_name`。我们还可以扩展默认提供的内容，并包括用户*角色*等额外细节。'
- en: '`Scopes`: Can be used to outline permissions that can be included in the token
    when it is issued.'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scopes`：可以在发放令牌时包含权限。'
- en: '`Clients`: Third-party clients that we expect to use IdentityServer as a token-issuing
    authority.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clients`：我们期望使用IdentityServer作为令牌发行权威机构的第三方客户端。'
- en: '`HostingExtension.cs`: Contains service and middleware registration extension
    methods. These methods are then called in the `Program.cs` file during startup.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostingExtension.cs`: 包含服务和中间件注册扩展方法。这些方法随后在启动时的`Program.cs`文件中被调用。'
- en: '`Program.cs`: Primary program execution file in an ASP.NET Core application.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.cs`：ASP.NET Core应用程序中的主要程序执行文件。'
- en: '`SeedData.cs`: Contains default methods that will ensure that data migrations
    and seeding operations are carried out at application startup.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SeedData.cs`: 包含默认方法，确保在应用程序启动时执行数据迁移和种子操作。'
- en: 'IdentityServer uses two database contexts, a configuration store context and
    an operational store context. As a result, two database contexts are created in
    the `HostingExtension.cs` file. The `IdentityServer` libraries are registered
    using the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: IdentityServer使用两个数据库上下文，一个配置存储上下文和一个操作存储上下文。因此，在`HostingExtension.cs`文件中创建了两个数据库上下文。使用以下代码注册`IdentityServer`库：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are adding `TestUsers` to the configuration and then adding `ConfigurationStoreDbContext`
    and `OperationalStoreDbContext`. Other settings also govern how alerts and tokens
    are handled. The defaults are generally solid, but you may modify them based on
    your specific needs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`TestUsers`添加到配置中，然后添加`ConfigurationStoreDbContext`和`OperationalStoreDbContext`。其他设置还规定了如何处理警报和令牌。默认设置通常很稳健，但您可以根据具体需求进行修改。
- en: 'The default connection string and Entity Framework Core libraries give us support
    for an SQLite database. This can be changed to whatever the desired data store
    may be, but we will continue with SQLite for the purpose of this exercise. Let
    us proceed to generate the database and the tables, and we need the following
    commands:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认连接字符串和Entity Framework Core库为我们支持SQLite数据库。这可以更改为任何期望的数据存储，但我们将继续使用SQLite来完成这个练习。让我们继续生成数据库和表，我们需要以下命令：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With these two commands, we will see our database scaffolded with all the supporting
    tables. At this point, they are all empty and we may want to populate them with
    some default values based on our application. Let us start by configuring the
    `IdentityResources` that we intend to support in our tokens. We can modify the
    `IdentityResources` method as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个命令，我们将看到我们的数据库已经与所有支持表一起构建。在这个阶段，它们都是空的，我们可能希望根据我们的应用程序填充一些默认值。让我们首先配置我们打算在令牌中支持的`IdentityResources`。我们可以按如下方式修改`IdentityResources`方法：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have added the list of roles to the resources list. Based on the claims that
    are being accounted for, we need to ensure that our users will contain all their
    expected data, as well as the list of claims that they are expected to have. Bear
    in mind that claims are the information that a client application will have via
    the token since it is the only way a client can track which user is online and
    what they can do.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将角色列表添加到资源列表中。根据正在处理的声明，我们需要确保我们的用户将包含所有预期的数据，以及他们预期拥有的声明列表。请记住，声明是客户端应用程序将通过令牌拥有的信息，因为这是客户端跟踪哪个用户在线以及他们可以做什么的唯一方式。
- en: 'Now, we can refine the list of scopes that are supported by modifying the `ApiScopes`
    method as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过修改`ApiScopes`方法来细化支持的作用域列表：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we are supporting two types of authentication scopes. These scopes will
    be used to support authentication for two different scenarios: client and user.
    Client authentication represents an unsupervised attempt to gain access to a resource,
    usually by another program or API. Client authentication means that a user will
    authenticate using credentials.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们支持两种类型的身份验证作用域。这些作用域将被用于支持两种不同场景的身份验证：客户端和用户。客户端身份验证代表一种未经监督的尝试获取资源，通常是通过另一个程序或API。客户端身份验证意味着用户将使用凭证进行身份验证。
- en: 'This brings us to the next configuration, which is for the clients. The term
    client is used a bit loosely since any entity that attempts to gain authorization
    from IdentityServer is seen as a client. The word client can also refer to a program
    that is attempting to gain authorization, such as a daemon or background service.
    Another scenario is when a user attempts to carry out an operation that requires
    them to authenticate against IdentityServer. We add support for our clients as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了下一个配置，它是针对客户端的。术语客户端使用得比较宽松，因为任何试图从IdentityServer获取授权的实体都被视为客户端。客户端一词也可以指试图获取授权的程序，例如守护进程或后台服务。另一种情况是当用户试图执行需要他们通过IdentityServer进行身份验证的操作时。我们如下添加对客户端的支持：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we have defined the `ClientId` and `ClientSecret` values for our clients.
    By defining several clients, we can support the applications that we expect to
    support at a more granular level, and we can define specific `AllowedScopes` and
    `AllowedGrantTypes` values. In this example, we have defined a client for an API,
    which can represent a microservice in our application that might need to authenticate
    with the authentication service. This type of authentication generally occurs
    without user interaction. We also define a web client, which could be a user-facing
    application. This presents the unique challenge where we configure sign-in and
    sign-out URLs to redirect our users during the authentication or logout flow.
    We also go on to state which scopes will be accessible via the generated token.
    We have added the `roles` value to the list of `AllowedScopes` since we want that
    information to be included when a user authenticates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为我们的客户端定义了`ClientId`和`ClientSecret`值。通过定义多个客户端，我们可以在更细粒度的层面上支持我们期望支持的应用程序，并且我们可以定义特定的`AllowedScopes`和`AllowedGrantTypes`值。在这个例子中，我们为API定义了一个客户端，它可以代表我们的应用程序中可能需要与身份验证服务进行身份验证的微服务。这种类型的身份验证通常在没有用户交互的情况下发生。我们还定义了一个Web客户端，它可能是一个面向用户的应用程序。这提出了一个独特的挑战，即我们在配置登录和注销URL时，将用户在身份验证或注销流程期间重定向。我们还说明了哪些作用域可以通过生成的令牌访问。由于我们希望在用户身份验证时包含该信息，因此我们将`roles`值添加到`AllowedScopes`列表中。
- en: 'Now that we have our configuration values outlined, let us add a command-line
    argument for seeding to the `launchSettings.json` file in the `Properties` folder.
    The file’s contents will now look as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了配置值，让我们向`Properties`文件夹中的`launchSettings.json`文件添加一个用于初始化的命令行参数。该文件的现在内容如下：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we run this application after making this adjustment, the `if (args.Contains("/seed"))`
    statement will evaluate to `true` in `Program.cs` and this will trigger the database
    seeding activity as outlined in the `SeedData.cs` file. After the first run, you
    may remove the `"commandLineArgs": "/seed"` section from the `launchSettings.json`
    file. Running it again will launch a browser application with a page similar to
    what is depicted in *Figure 12.4*. This is the home landing page and shows that
    our IdentityServer is up and running.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在做出此调整后运行此应用程序，`if (args.Contains("/seed"))`语句将在`Program.cs`中评估为`true`，这将触发`SeedData.cs`文件中概述的数据库初始化活动。第一次运行后，您可以从`launchSettings.json`文件中删除`"commandLineArgs":
    "/seed"`部分。再次运行它将启动一个带有类似*图12.4*所示页面的浏览器应用程序。这是主页着陆页，显示我们的IdentityServer正在运行。'
- en: '*Figure 12.4* shows the Duende IdentityServer landing page:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.4*显示了Duende IdentityServer的着陆页：'
- en: '![Figure 12.4 – This landing page shows us that our IdentityServer application
    is in a running state](img/Figure_12.4_B19100.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 此着陆页显示我们的IdentityServer应用程序正在运行状态](img/Figure_12.4_B19100.jpg)'
- en: Figure 12.4 – This landing page shows us that our IdentityServer application
    is in a running state
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 此着陆页显示我们的IdentityServer应用程序正在运行状态
- en: You can find the `TestUsers.cs` file in the `Pages` folder. We will use `alice`
    as both the username and password for a quick test. You may proceed to use the
    credentials that have been provided in your instance of that file. We can then
    proceed to test a login operation using one of the test users that was added to
    the context by default, and we will be required to authenticate when attempting
    to access most of these links.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Pages`文件夹中找到`TestUsers.cs`文件。我们将使用`alice`作为用户名和密码进行快速测试。您可以使用该文件实例中提供的凭据继续操作。然后，我们可以使用默认添加到上下文中的一个测试用户来测试登录操作，并且当我们尝试访问大多数这些链接时，我们将需要验证身份。
- en: 'The most important link to discuss is the one that leads to the discovery document.
    Most OAuth2.0 and OpenID Connect service providers have a concept of a discovery
    document, which outlines the built-in routes in the API, supported claims and
    token types, and other key bits of information that make it easier for us to know
    and access these intricate bits of information from IdentityServer. Some of the
    key information available is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的最重要链接是通往发现文档的链接。大多数OAuth2.0和OpenID Connect服务提供商都有一个发现文档的概念，它概述了API中的内置路由、支持的声明和令牌类型以及其他有助于我们了解和访问这些复杂信息的要点信息。以下是一些关键信息：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have a clear outline of the various endpoints that are now available to us
    for the different commonly access operations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对可用于不同常见操作的各个端点有一个清晰的概述。
- en: Next, we can test our `HealthCare.Auth` application and validate that we can
    retrieve a valid token. Let us attempt to retrieve a token using our machine client
    credentials. We will use an API testing tool called *Postman* to send the request.
    *Figure 12.5* shows the user interface in Postman and the information that needs
    to be added accordingly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试我们的`HealthCare.Auth`应用程序，并验证我们能否检索到一个有效的令牌。让我们尝试使用我们的机器客户端凭据来检索令牌。我们将使用一个名为*Postman*的API测试工具发送请求。*图12.5*显示了Postman的用户界面以及相应需要添加的信息。
- en: '![Figure 12.5 – Here, we add the client ID, client secret, and token URL values
    in Postman in order to retrieve a bearer token](img/Figure_12.5_B19100.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 在这里，我们在Postman中添加客户端ID、客户端密钥和令牌URL值以检索一个承载令牌](img/Figure_12.5_B19100.jpg)'
- en: Figure 12.5 – Here, we add the client ID, client secret, and token URL values
    in Postman in order to retrieve a bearer token
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 在这里，我们在Postman中添加客户端ID、客户端密钥和令牌URL值以检索一个承载令牌
- en: Once we have added the required values, we proceed to click on the **Get New
    Access Token** button. This will send a request to our IdentityServer, which will
    validate the request and return a token if the information is found in the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了所需的值，我们就点击**获取新的访问令牌**按钮。这将向我们的IdentityServer发送请求，如果数据库中存在相关信息，它将验证请求并返回一个令牌。
- en: Our token response automatically includes some additional information such as
    the type of token, the expiry timestamp, and the scope that is included. Our token
    is generated with several data points by default. Since IdentityServer follows
    the *OAuth* and *OpenID Connect* standards, we can be sure that we do not need
    to include basic claims such as **sub**, **exp**, **jti**, and **iss**, to name
    a few.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的令牌响应自动包含一些附加信息，例如令牌类型、过期时间戳和包含的作用域。我们的令牌默认包含几个数据点。由于IdentityServer遵循*OAuth*和*OpenID
    Connect*标准，我们可以确信我们不需要包含基本声明，例如**sub**、**exp**、**jti**和**iss**等。
- en: The values that get included are the scope and client ID. These are determined
    by the configurations that we have per client and the information that is presented
    by the authenticating user. In this example, we are accommodating APIs that only
    authenticated users should be able to access.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的值是作用域和客户端ID。这些值由每个客户端的配置和认证用户提供的信息确定。在这个例子中，我们允许只有经过认证的用户才能访问的API。
- en: '*Figure 12.6* shows the payload of the token:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.6*显示了令牌的有效负载：'
- en: '![Figure 12.6 – Our token automatically contains some claims that we would
    have entered manually if it was generated without IdentityServer](img/Figure_12.6_B19100.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 如果没有使用IdentityServer生成，我们的令牌将自动包含一些我们手动输入的声明](img/Figure_12.6_B19100.jpg)'
- en: Figure 12.6 – Our token automatically contains some claims that we would have
    entered manually if it was generated without IdentityServer
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 如果没有使用IdentityServer生成，我们的令牌将自动包含一些我们手动输入的声明
- en: Let us save our bearer token value that was returned, as we will use it in our
    next section. Now let us review the changes that are necessary to protect an API
    using IdentityServer.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存返回的携带令牌值，因为我们将在下一节中使用它。现在让我们回顾一下使用 IdentityServer 保护 API 所必需的更改。
- en: Securing an API using IdentityServer
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IdentityServer 保护 API
- en: 'We now have the peculiar challenge of implementing the best possible security
    solution across our microservices application. We have several services that need
    to be secured and based on the architecture pattern you have implemented, you
    might also have a gateway that is routing traffic:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在面临着一个特别的挑战，即在微服务应用程序中实施最佳的安全解决方案。我们有几个需要保护的服务，并且根据你实现的架构模式，你可能还有一个路由流量的网关：
- en: '**Securing each service**: Securing each service seems simple enough, but we
    must bear in mind that each service has different requirements and might need
    to be seen as a different client for each request. This can lead to a maintenance
    nightmare when trying to maintain all the scopes and clients, relative to each
    service. We then need to navigate how services will communicate as well since
    a token will be needed for service-to-service calls. One service’s claims and
    scopes might not be sufficient for this communication. This might lead to a user
    having to authenticate several times when accessing different features that rely
    on different services.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护每个服务**：保护每个服务看起来足够简单，但我们必须记住，每个服务都有不同的需求，可能需要被视为每个请求的不同客户端。当尝试维护与每个服务相关的所有范围和客户端时，这可能会导致维护噩梦。我们还需要考虑服务之间的通信方式，因为服务到服务的调用需要令牌。一个服务的声明和范围可能不足以支持这种通信。这可能会导致用户在访问依赖于不同服务的不同功能时需要多次进行身份验证。'
- en: '**Secured API gateway**: Securing our API gateway makes the most sense. If
    we implement a gateway that all apps will communicate with, we allow the gateway
    to orchestrate the authentication flow for the client and then manage the token
    to be shared between service calls. This support can be implemented in a custom-written
    API gateway and is supported by most if not all third-party gateway service providers.
    This is especially useful when combined with the *Backend For Frontend* pattern.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的 API 网关**：保护我们的 API 网关最有意义。如果我们实现一个所有应用程序都将与之通信的网关，我们允许网关为客户和客户端之间的身份验证流程进行编排，并管理在服务调用之间共享的令牌。这种支持可以在自定义编写的
    API 网关中实现，并且大多数（如果不是所有）第三方网关服务提供商都支持。当与 *Backend For Frontend* 模式结合使用时，这特别有用。'
- en: 'We have already seen how we can add JWT bearer protection to our API using
    functionality from the `Identity Core` library. We can leverage some of these
    configurations and override the native functionality with support for IdentityServer.
    Let us explore how we can secure our `Patients` API using IdentityServer. We start
    by adding the `Microsoft.AspNetCore.Authentication.JwtBearer` library using the
    NuGet package manager:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `Identity Core` 库的功能将 JWT 携带保护添加到我们的 API 中。我们可以利用一些这些配置，并用对 IdentityServer
    的支持覆盖原生功能。让我们探索如何使用 IdentityServer 保护我们的 `Patients` API。我们首先通过 NuGet 包管理器添加 `Microsoft.AspNetCore.Authentication.JwtBearer`
    库：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then modify the `Program.cs` file and add the following configuration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们修改 `Program.cs` 文件并添加以下配置：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will also need to register the authentication middleware in our application
    with the following line. We should ensure that we place this registration above
    the authorization middleware:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的应用程序中注册身份验证中间件，以下是一行代码。我们应该确保将此注册放在授权中间件之上：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This configuration will dictate to our service that we are now to refer them
    to the URL in the *Authority* option, for authentication instructions. We can
    now protect our API by implementing a global authorization policy. This will ensure
    that no endpoint can be accessed without a valid bearer token that has been issued
    by our IdentityServer:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将指示我们的服务现在要将它们指向 *Authority* 选项中的 URL，以获取身份验证说明。我们现在可以通过实现全局授权策略来保护我们的 API。这将确保没有端点可以访问，除非有一个由我们的
    IdentityServer 签发的有效携带令牌：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We modify the controller’s middleware as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按如下方式修改控制器的中间件：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, any attempt to interact with our `Patients` API endpoint will return a
    `401Unauthorized` HTTP response. The API is now expecting us to provide the bearer
    token in the authorization header value. In *Figure 12.7*, we see how we can make
    authorized API calls to our `Patients` API endpoints using the bearer token that
    was retrieved in the previous section from our machine client credentials authentication.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12.7* shows the authorized API request:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Our bearer token is included in the request to our protected
    service and we can comfortably access endpoints](img/Figure_12.7_B19100.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Our bearer token is included in the request to our protected service
    and we can comfortably access endpoints
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to configure our API to force authentication and rely on the *HealthCare.Auth*
    service accordingly. If we reuse our appointments API, we can make a few modifications
    to the `Program.cs` file and introduce reliance on our authentication service.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by modifying the `builder.Services.AddAuthenctication()` registration
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have secured our API directly, we can explore how we can manage
    this new security requirement in our API gateway. Recall that we have implemented
    aggregation methods and we will expect client applications to access the endpoints
    through the gateway.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Ocelot API gateway with IdentityServer
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, when we access an API endpoint that is protected via IdentityServer, we
    need to retrofit our gateway service to support authentication and forwarding
    of the credentials to the target API. We start by adding the `Microsoft.AspNetCore.Authentication.JwtBearer`
    library using the NuGet package manager:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then modify the `ocelot.json` file with an `AuthenticationOptions` section.
    Now, our `GET` method for the `Patients` API is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we modify our `Program.cs` file and register our authentication service
    to use JWT bearer authentication, similar to what we did on the service itself:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we have secured our gateway using IdentityServer. This, once again, might
    be a better security solution for our suite of microservices that will be accessed
    through the gateway, and it can help us to centralize access to our services.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored API security at length, let us summarize the concepts
    that we have explored.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: With this simple change, we no longer need to concern our appointments API with
    the inclusion of authentication tables in its database, or complex JWT bearer
    compilation logic. We simply point the service to our `Authority`, which is the
    authentication service, and include the `Audience` value so that it can identify
    itself to the authentication service.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration, a user will need to provide a token such as the one
    we retrieved to make any calls to our API. Any other token or lack thereof will
    be met with a *401 Unauthorized* HTTP response.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IdentityServer is not the most difficult task, but it can become
    complex when attempting to account for several scenarios, configurations, and
    clients. Several considerations can be made along the way, and we will discuss
    them next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 配置IdentityServer并不是最困难的任务，但在尝试处理多个场景、配置和客户端时，它可能会变得复杂。在过程中可以做出一些考虑，我们将在下一节中讨论它们。
- en: Additional API security considerations
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的API安全考虑
- en: We have configured an authentication service to secure our microservices application.
    Several scenarios can govern how each service is protected by this central authority
    and they all have their pros and cons.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了一个身份验证服务来保护我们的微服务应用程序。有几个场景可以决定每个服务如何被这个中央权威保护，它们各有优缺点。
- en: What we also need to consider is that we want the entire responsibility of hosting
    and maintaining our own *OAuth* service. There are third-party services such as
    **Auth0**, **Azure Active Directory**, and **Okta**, to name a few. They all provide
    a hosted service that will abstract our need to stage and maintain our services,
    and we can simply subscribe to their services and secure our application with
    a few configurations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑的是，我们希望承担托管和维护我们自己的*OAuth*服务的全部责任。有一些第三方服务，例如**Auth0**、**Azure Active
    Directory**和**Okta**（仅举几例）。它们都提供托管服务，这将抽象化我们部署和维护服务的需求，我们可以简单地订阅它们的服务，并通过一些配置来保护我们的应用程序。
- en: This option takes advantage of **Software-as-a-Service** (**SaaS**) offerings
    that greatly reduce our infrastructure needs and increase the reliability, stability,
    and future-proofing of our application’s security.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择利用了**软件即服务**（**SaaS**）提供的服务，这些服务大大减少了我们的基础设施需求，并增加了我们应用程序安全性的可靠性、稳定性和未来保障。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reviewed the current industry standard for API security.
    Using bearer tokens, we can support authorized API access attempts without maintaining
    state or sessions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了当前行业标准的API安全。使用载体令牌，我们可以支持授权的API访问尝试，而无需维护状态或会话。
- en: In a service-oriented architecture, a client app can come in several forms,
    whether a web application, a mobile application, or even a smart television. We
    cannot account for the type of device in use and our API does not keep track of
    the applications connecting to it. For this reason, when a user logs in and is
    verified against our user information data stores, we select the most important
    bit of information and compile them into a token.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向服务的架构中，客户端应用程序可以有多种形式，无论是Web应用程序、移动应用程序，甚至是智能电视。我们无法确定正在使用的设备类型，我们的API也不会跟踪连接到它的应用程序。因此，当用户登录并验证我们的用户信息数据存储时，我们会选择最重要的信息片段并将它们编译成一个令牌。
- en: This token is called a bearer token and is an encoded string that should contain
    enough information about a user that our API can determine the user with whom
    the token is associated and their privileges in our system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令牌被称为载体令牌，是一个编码的字符串，应该包含足够关于用户的信息，以便我们的API能够确定与令牌关联的用户以及他们在我们系统中的权限。
- en: Ultimately, attempting to secure each API using this method can lead to a lot
    of disconnection and complexity, so we introduce a centralized authentication
    management platform such as IdentityServer. This central authority will secure
    all the APIs using common configurations, and issue tokens based on those global
    configurations. Now, we can use these tokens once and access several services
    without needing to re-authenticate.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，尝试使用这种方法为每个API提供安全保护可能会导致很多脱节和复杂性，因此我们引入了一个集中的身份验证管理平台，例如IdentityServer。这个中央权威将使用通用配置来保护所有API，并基于这些全局配置颁发令牌。现在，我们可以使用这些令牌一次，访问多个服务，而无需重新进行身份验证。
- en: Security should never be neglected in any application and when it is well implemented,
    we can strike a balance between security and usability in our application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，安全都不应该被忽视，并且当它得到良好实施时，我们可以在我们的应用程序中在安全性和可用性之间取得平衡。
- en: Now that we have explored security for our microservices application, we will
    review how we can leverage *containers* to deploy our microservices application
    in the next chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了我们的微服务应用程序的安全性，我们将在下一章中回顾如何利用*容器*来部署我们的微服务应用程序。
