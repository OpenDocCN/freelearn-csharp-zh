<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-184"><a id="_idTextAnchor205"/>5. Concurrency: Multithreading Parallel and Async Code</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">C# and .NET provide a highly effective way to run concurrent code, making it easy to perform complex and often time-consuming actions. In this chapter, you will explore the various patterns that are available, from creating tasks using the <code>Task</code> factory methods to continuations to link tasks together, before moving on to the <code>async</code>/<code>await</code> keywords, which vastly simplify such code. By the end of this chapter, you will see how C# can be used to execute code that runs concurrently and often produces results far quicker than a single-threaded application.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor206"/>Introduction</h1>
<p>Concurrency is a generalized term that describes the ability of software to do more than one thing at the same time. By harnessing the power of concurrency, you can provide a more responsive user interface by offloading CPU-intensive activities from the main UI thread. On the server side, taking advantage of modern processing power through multi-processor and multi-core architectures, scalability can be achieved by processing operations in parallel.</p>
<p>Multithreading is a form of concurrency whereby multiple threads are used to perform operations. This is typically achieved by creating many <code>Thread</code> instances and coordinating operations between them. It is regarded as a legacy implementation, having largely been replaced by parallel and async programming; you may well find it used in older projects.</p>
<p>Parallel programming is a class of multithreading where similar operations are run independently of each other. Typically, the same operation is repeated using multiple loops, where the parameters or target of the operation themselves vary by iteration. .NET provides libraries that shield developers from the low-level complexities of thread creation. The phrase <strong class="bold">embarrassingly parallel</strong> is often used to describe an activity that requires little extra effort to be broken down into a set of tasks that can be run in parallel, often where there are few interactions between sub-tasks. One such example of parallel programming could be counting the number of words found in each text file within a folder. The job of opening a file and scanning through the words can be split into parallel tasks. Each task executes the same lines of code but is given a different text file to process.</p>
<p>Asynchronous programming is a more recent form of concurrency where an operation, once started, will complete at some point in the future, and the calling code is able to continue with other operations. This completion is often known as a <code>Task&lt;&gt;</code> equivalent. In C# and .NET, async programming has become the preferred means to achieve concurrent operations.</p>
<p>A common application of asynchronous programming is where multiple slow-running or expensive dependencies need to be initialized and marshaled prior to calling a final step that should be called only when all or some of the dependencies are ready to be used. For example, a mobile hiking application may need to wait for a reliable GPS satellite signal, a planned navigation route, and a heart-rate monitoring service to be ready before the user can start hiking safely. Each of these distinct steps would be initialized using a dedicated task.</p>
<p>Another very common use case for asynchronous programming occurs in UI applications where, for example, saving a customer's order to a database could take 5-10 seconds to complete. This may involve validating the order, opening a connection to a remote server or database, packaging and sending the order in a format that can be transmitted over the wire, and then finally waiting for confirmation that the customer's order has been successfully stored in a database. In a single-threaded application, this would take much longer, and this delay would soon be noticed by the user. The application would become unresponsive until the operation was completed. In this scenario, the user may rightly think the application has crashed and may try to close it. That is not an ideal user experience.</p>
<p>Such issues can be mitigated by using async code that performs any of the slow operations using a dedicated task for each. These tasks may choose to provide feedback as they progress, which the UI's main thread can use to notify the user. Overall, the operation should complete sooner, thus freeing the user to continue interacting with the app. In modern applications, users have come to expect this method of operation. In fact, many UI guidelines suggest that if an operation may take more than a few seconds to complete, then it should be performed using async code.</p>
<p>Note that when code is executing, whether it's synchronous or asynchronous code, it is run within the context of a <code>Thread</code> instance. In the case of asynchronous code, this <code>Thread</code> instance is chosen by the .NET scheduler from a pool of available threads.</p>
<p>The <code>Thread</code> class has various properties but one of the most useful is <code>ManagedThreadId</code>, which will be used extensively throughout this chapter. This integer value serves to uniquely identify a thread within your process. By examining <code>Thread.ManagedThreadId</code>, you can determine that multiple thread instances are being used. This can be done by accessing the <code>Thread</code> instance from within your code using the static <code>Thread.CurrentThread</code> method.</p>
<p>For example, if you started five long-running tasks and examined the <code>Thread.ManagedThreadId</code> for each, you would observe five unique IDs, possibly numbered as two, three, four, five, and six. In most cases, the thread with ID number one is the process's main thread, created when the process first starts.</p>
<p>Keeping track of thread IDs can be quite useful, especially when you have time-consuming operations to perform. As you have seen, using concurrent programming, multiple operations can be executed at the same time, rather than using a traditional single-threaded approach, where one operation must complete before a subsequent operation can start.</p>
<p>In the physical world, consider the case of building a train tunnel through a mountain. Starting at one side of a mountain and tunneling through to the other side could be made considerably faster if two teams started on opposite sides of the mountain, both tunneling toward each other. The two teams could be left to work independently; any issues experienced by a team on one side should not have an adverse effect on the other side's team. Once both sides have completed their tunneling, there should be one single tunnel, and the construction could then continue with the next task, such as laying the train line.</p>
<p>The next section will look at using the C# <code>Task</code> class, which allows you to execute blocks of code at the same time and independently of each other. Consider again the example of the UI app, where the customer's order needs to be saved to a database. For this, you would have two options:</p>
<p>Option 1 is to create a C# <code>Task</code> that performs each step one after another:</p>
<ul>
<li>Validate the order.</li>
<li>Connect to the server.</li>
<li>Send the request.</li>
<li>Wait for a response.</li>
</ul>
<p>Option 2 is to create a C# <code>Task</code> for each of the steps, executing each in parallel where possible.</p>
<p>Both options achieve the same end result, freeing the UI's main thread to respond to user interactions. Option one may well be slower to finish, but the upside is that this would require simpler code. However, Option two would be the preferred choice as you are offloading multiple steps, so it should complete sooner. Although, this could involve additional complexity as you may need to coordinate each of the individual tasks as they are complete.</p>
<p>In the upcoming sections, you will first get a look at how Option one could be approached, that is, using a single <code>Task</code> to run blocks of code, before moving on to the complexity of Option two where multiple tasks are used and coordinated.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor207"/>Running Asynchronous Code Using Tasks</h1>
<p>The <code>Task</code> class is used to execute blocks of code asynchronously. Its usage has been somewhat superseded by the newer <code>async</code> and <code>await</code> keywords, but this section will cover the basics of creating tasks as they tend to be pervasive in larger or mature C# applications and form the backbone of the <code>async</code>/<code>await</code> keywords.</p>
<p>In C#, there are three ways to schedule asynchronous code to run using the <code>Task</code> class and its generic equivalent <code>Task&lt;T&gt;</code>.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor208"/>Creating a New Task</h2>
<p>You'll start off with the simplest form, one that performs an operation but does not return a result back to the caller. You can declare a <code>Task</code> instance by calling any of the <code>Task</code> constructors and passing in an <code>Action</code> based delegate. This delegate contains the actual code to be executed at some point in the future. Many of the constructor overloads allow cancellation tokens and <code>Task</code> runs.</p>
<p>Some of the commonly used constructors are as follows:</p>
<ul>
<li><code>public Task(Action action)</code>: The <code>Action</code> delegate represents the body of code to be run.</li>
<li><code>public Task(Action action, CancellationToken cancellationToken)</code>: The <code>CancellationToken</code> parameter can be used as a way to interrupt the code that is running. Typically, this is used where the caller has been provided with a means to request that an operation be stopped, such as adding a <code>Cancel</code> button that a user can press.</li>
<li><code>public Task(Action action, TaskCreationOptions creationOptions)</code>: <code>TaskCreationOptions</code> offers a way to control how the <code>Task</code> is run, allowing you to provide hints to the scheduler that a certain <code>Task</code> might take extra time to complete. This can help when running related tasks together.</li>
</ul>
<p>The following are the most often used <code>Task</code> properties:</p>
<ul>
<li><code>public bool IsCompleted { get; }</code>: Returns <code>true</code> if the <code>Task</code> completed (completion does not indicate success).</li>
<li><code>public bool IsCompletedSuccessfully { get; }</code>: Returns <code>true</code> if the <code>Task</code> completed successfully.</li>
<li><code>public bool IsCanceled { get; }</code>: Returns <code>true</code> if the <code>Task</code> was canceled prior to completion.</li>
<li><code>public bool IsFaulted { get; }</code>: Returns <code>true</code> if the <code>Task</code> has thrown an unhandled exception prior to completion.</li>
<li><code>public TaskStatus Status { get; }</code>: Returns an indicator of the task's current status, such as <code>Canceled</code>, <code>Running</code>, or <code>WaitingToRun</code>.</li>
<li><code>public AggregateException Exception { get; }</code>: Returns the exception, if any, that caused the <code>Task</code> to end prematurely.</li>
</ul>
<p>Note that the code within the <code>Action</code> delegate is not executed until sometime after the <code>Start()</code> method is called. This may well be some milliseconds after and is determined by the .NET scheduler.</p>
<p>Start here by creating a new VS Code console app, adding a utility class named <code>Logger</code>, which you will use in the exercises and examples going forward. It will be used to log a message to the console along with the current time and current thread's <code>ManagedThreadId</code>.</p>
<p>The steps for this are as follows:</p>
<ol>
<li>Change to your source folder.</li>
<li>Create a new console app project called <code>Chapter05</code> by running the following command:<pre>source&gt;dotnet new console -o Chapter05</pre></li>
<li>Rename the <code>Class1.cs</code> file to <code>Logger.cs</code> and remove all the template code.</li>
<li>Be sure to include the <code>System</code> and <code>System.Threading</code> namespaces. <code>System.Threading</code> contains the <code>Threading</code> based classes:<pre>using System;
using System.Threading;
namespace Chapter05
{</pre></li>
<li>Mark the <code>Logger</code> class as static so that it can be used without having to create an instance to use:<pre>    public static class Logger
    {</pre><p class="callout-heading">Note</p><p class="callout">If you use the <code>Chapter05</code> namespace, then the <code>Logger</code> class will be accessible to code in examples and activities, provided they also use the <code>Chapter05</code> namespace. If you prefer to create a folder for each example and exercise, then you should copy the file <code>Logger.cs</code> into each folder that you create.</p></li>
<li>Now declare a <code>static</code> method called <code>Log</code> that is passed a <code>string message</code> parameter:<pre>        public static void Log(string message)
        {
            Console.WriteLine($"{DateTime.Now:T} [{Thread.CurrentThread.ManagedThreadId:00}] {message}");
        }
    }
}</pre></li>
</ol>
<p>When invoked, this will log a message to the console window using the <code>WriteLine</code> method. In the preceding snippet, the string interpolation feature in C# is used to define a string using the <code>$</code> symbol; here, <code>:T</code> will format the current time (<code>DateTime.Now</code>) into a time-formatted string and <code>:00</code> is used to include <code>Thread.ManagedThreadId</code> with a leading 0.</p>
<p>Thus, you have created the static Logger class that will be used throughout the rest of this chapter.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/cg6c5">https://packt.link/cg6c5</a>.</p>
<p>In the next example, you will use the <code>Logger</code> class to log details when a thread is about to start and finish.</p>
<ol>
<li value="7">Start by adding a new class file called <code>TaskExamples.cs</code>:<pre>using System;
using System.Threading;
using System.Threading.Tasks;
namespace Chapter05.Examples
{
    class TaskExamples
    {</pre></li>
<li>The <code>Main</code> entry point will log that <code>taskA</code> is being created:<pre>        public static void Main()
        {
            Logger.Log("Creating taskA");</pre></li>
<li>Next, add the following code:<pre>            var taskA = new Task(() =&gt;
            {
                Logger.Log("Inside taskA");
                Thread.Sleep(TimeSpan.FromSeconds(5D));
                Logger.Log("Leaving taskA");
            });</pre></li>
</ol>
<p>Here, the simplest <code>Task</code> constructor is passed an <code>Action</code> lambda statement, which is the actual target code that you want to execute. The target code writes the message <code>Inside taskA</code> to the console. It pauses for five seconds using <code>Thread.Sleep</code> to block the current thread, thus simulating a long-running activity, before finally writing <code>Leaving taskA</code> to the console.</p>
<ol>
<li value="10">Now that you have created <code>taskA</code>, confirm that it will only invoke its target code when the <code>Start()</code> method is called. You will do this by logging a message immediately before and after the method is called:<pre>            Logger.Log($"Starting taskA. Status={taskA.Status}");
            taskA.Start();
            Logger.Log($"Started taskA. Status={taskA.Status}");
            Console.ReadLine();
        }
    }
} </pre></li>
<li>Copy the contents of <code>Logger.cs</code> file to same folder as the <code>TaskExamples.cs</code> example.</li>
<li>Next run the console app to produce the following output:<pre><a id="_idTextAnchor209"/>10:47:34 [01] Creating taskA
10:47:34 [01] Starting taskA. Status=Created
10:47:34 [01] Started taskA. Status=WaitingToRun
10:47:34 [03] Inside taskA
10:47:39 [03] Leaving taskA</pre></li>
</ol>
<p>Note that the task's status is <code>WaitingToRun</code> even after you've called <code>Start</code>. This is because you are asking the .NET scheduler to schedule the code to run—that is, to add it to its queue of pending actions. Depending on how busy your application is with other tasks, it may not run immediately after you've called <code>Start</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/DHxt3">https://packt.link/DHxt3</a>.</p>
<p>In earlier versions of C#, this was the main way to create and start <code>Task</code> objects directly. It is no longer recommended and is only included here as you may find it used in older code. Its usage has been replaced by the <code>Task.Run</code> or <code>Task.Factory.StartNew</code> static factory methods, which offer a simpler interface for the most common usage scenarios.</p>
<h3 id="_idParaDest-188"><a id="_idTextAnchor210"/>Using Task.Factory.StartNew</h3>
<p>The static method <code>Task.Factory.StartNew</code> contains various overloads that make it easier to create and configure a <code>Task</code>. Notice how the method is named <code>StartNew</code>. It creates a <code>Task</code> and automatically starts the method for you. The .NET team recognized that there is little value in creating a <code>Task</code> that is not immediately started after it is first created. Typically, you would want the <code>Task</code> to start performing its operation right away.</p>
<p>The first parameter is the familiar <code>Action</code> delegate to be executed, followed by optional cancelation tokens, creation options, and a <code>TaskScheduler</code> instance.</p>
<p>The following are some of the common overloads:</p>
<ul>
<li><code>Task.Factory.StartNew(Action action)</code>: The <code>Action</code> delegate contains the code to execute, as you have seen previously.</li>
<li><code>Task.Factory.StartNew(Action action, CancellationToken cancellationToken)</code>: Here, <code>CancellationToken</code> coordinates the cancellation of the task.</li>
<li><code>Task.Factory.StartNew(Action&lt;object&gt; action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)</code>: The <code>TaskScheduler</code> parameter allows you to specify a type of low-level scheduler responsible for queuing tasks. This option is rarely used.</li>
</ul>
<p>Consider the following code, which uses the first and simplest overload:</p>
<pre>var taskB = Task.Factory.StartNew((() =&gt;
{
  Logger.Log("Inside taskB");
  Thread.Sleep(TimeSpan.FromSeconds(3D));
  Logger.Log("Leaving taskB");
}));
Logger.Log($"Started taskB. Status={taskB.Status}");
Console.ReadLine();</pre>
<p>Running this code produces the following output:</p>
<pre>21:37:42 [01] Started taskB. Status=WaitingToRun
21:37:42 [03] Inside taskB
21:37:45 [03] Leaving taskB</pre>
<p>From the output, you can see that this code achieves the same result as creating a <code>Task</code> but is more concise. The main point to consider is that <code>Task.Factory.StartNew</code> was added to C# to make it easier to create tasks that are started for you. It was preferable to use <code>StartNew</code> rather than creating tasks directly.</p>
<p class="callout-heading">Note</p>
<p class="callout">The term <strong class="bold">Factory</strong> is often used in software development to represent methods that help create objects.</p>
<p><code>Task.Factory.StartNew</code> provides a highly configurable way to start tasks, but in reality, many of the overloads are rarely used and need a lot of extra parameters to be passed to them. As such, <code>Task.Factory.StartNew</code> itself has also become somewhat obsolete in favor of the newer <code>Task.Run</code> static method. Still, the <code>Task.Factory.StartNew</code> is briefly covered as you may see it used in legacy C# applications.</p>
<h3 id="_idParaDest-189"><a id="_idTextAnchor211"/>Using Task.Run</h3>
<p>The alternative and preferred <code>static</code> factory method, <code>Task.Run</code>, has various overloads and was added later to .NET to simplify and shortcut the most common task scenarios. It is preferable for newer code to use <code>Task.Run</code> to create started tasks, as far fewer parameters are needed to achieve common threading operations.</p>
<p>Some of the common overloads are as follows:</p>
<ul>
<li><code>public static Task Run(Action action)</code>: Contains the <code>Action</code> delegate code to execute.</li>
<li><code>public static Task Run(Action action, CancellationToken cancellationToken)</code>: Additionally contains a cancelation token used to coordinate the cancellation of a task.</li>
</ul>
<p>For example, consider the following code:</p>
<pre>var taskC = Task.Run(() =&gt;
{
  Logger.Log("Inside taskC");
  Thread.Sleep(TimeSpan.FromSeconds(1D));
  Logger.Log("Leaving taskC");
  });
Logger.Log($"Started taskC. Status={taskC.Status}");
Console.ReadLine();</pre>
<p>Running this code will produce the following output:</p>
<pre>21:40:27 [03] Inside taskC
21:40:27 [01] Started taskC. Status=WaitingToRun
21:40:28 [03] Leaving taskC</pre>
<p>As you can see, the output is pretty similar to the outputs of the previous two code snippets. Each wait for a shorter time than its predecessor before the associated <code>Action</code> delegate completes.</p>
<p>The main difference is that creating a <code>Task</code> instance directly is an obsolete practice but will allow you to add an extra logging call before you explicitly call the <code>Start</code> method. That is the only benefit in creating a <code>Task</code> directly, which is not a particularly compelling reason to do so.</p>
<p>Running all three examples together produces this:</p>
<pre>21:45:52 [01] Creating taskA
21:45:52 [01] Starting taskA. Status=Created
21:45:52 [01] Started taskA. Status=WaitingToRun
21:45:52 [01] Started taskB. Status=WaitingToRun
21:45:52 [01] Started taskC. Status=WaitingToRun
21:45:52 [04] Inside taskB
21:45:52 [03] Inside taskA
21:45:52 [05] Inside taskC
21:45:53 [05] Leaving taskC
21:45:55 [04] Leaving taskB
21:45:57 [03] Leaving taskA</pre>
<p>You can see various <code>ManagedThreadIds</code> being logged and that <code>taskC</code> completes before <code>taskB</code>, which completes before <code>taskA</code>, due to the decreasing number of seconds specified in the <code>Thread.Sleep</code> calls in each case.</p>
<p>It is preferable to favor either of the two static methods, but which should you use when scheduling a new task? <code>Task.Run</code> should be used for the <code>Task.Run</code> defers down to <code>Task.Factory.StartNew</code>.</p>
<p><code>Task.Factory.StartNew</code> should be used where you have more advanced requirements, such as defining where tasks are queued, by using any of the overloads that accept a <code>TaskScheduler</code> instance, but in practice, this is seldom the requirement.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on <code>Task.Run</code> and <code>Task.Factory.StartNew</code> at <a href="https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/">https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/</a> and <a href="https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml">https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml</a>.</p>
<p>So far, you have seen how small tasks can be started, each with a small delay before completion. Such delays can simulate the effect caused by code accessing slow network connections or running complex calculations. In the following exercise, you'll extend your <code>Task.Run</code> knowledge by starting multiple tasks that run increasingly longer numeric calculations.</p>
<p>This serves as an example to show how potentially complex tasks can be started and allowed to run to completion in isolation from one another. Note that in a traditional synchronous implementation, the throughput of such calculations would be severely restricted, owing to the need to wait for one operation to complete before the next one can commence. It is now time to practice what you have learned through an exercise.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor212"/>Exercise 5.01: Using Tasks to Perform Multiple Slow-Running Calculations</h2>
<p>In this exercise, you will create a recursive function, Fibonacci, which calls itself twice to calculate a cumulative value. This is an example of potentially slow-running code rather than using <code>Thread.Sleep</code> to simulate a slow call. You will create a console app that repeatedly prompts for a number to be entered. The larger this number, the longer each task will take to calculate and output its result. The following steps will help you complete this exercise:</p>
<ol>
<li value="1">In the <code>Chapter05</code> folder, add a new folder called <code>Exercises</code>. Inside that folder, add a new folder called <code>Exercise01</code>. You should have the folder structure as <code>Chapter05\Exercises\Exercise01</code>.</li>
<li>Create a new file called <code>Program.cs</code>.</li>
<li>Add the recursive <code>Fibonacci</code> function as follows. You can save a little processing time by returning <code>1</code> if the requested iteration is less than or equal to <code>2</code>:<pre>using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
namespace Chapter05.Exercises.Exercise01
{
  class Program
  {
        private static long Fibonacci(int n)
        {
            if (n &lt;= 2L)
                return 1L;
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }</pre></li>
<li>Add the <code>static Main</code> entry point to the console app and use a <code>do</code>-loop to prompt for a number to be entered.</li>
<li>Use <code>int.TryParse</code> to convert the string into an integer if the user enters a string:<pre>        public static void Main()
        {
            string input;
            do
            {
                Console.WriteLine("Enter number:");
                input = Console.ReadLine();
                if (!string.IsNullOrEmpty(input) &amp;&amp;                     int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var number))</pre></li>
<li>Define a lambda statement that captures the current time using <code>DateTime.Now</code>, calls the slow-running <code>Fibonacci</code> function, and logs the time taken to run:<pre>                 {
                    Task.Run(() =&gt;
                    {
                        var now = DateTime.Now;
                        var fib = Fibonacci(number);
                        var duration = DateTime.Now.Subtract(now);
                        Logger.Log($"Fibonacci {number:N0} = {fib:N0} (elapsed time: {duration.TotalSeconds:N0} secs)");
                    });
                } </pre></li>
</ol>
<p>The lambda is passed to <code>Task.Run</code> and will be started by <code>Task.Run</code> shortly, freeing the <code>do-while</code> loop to prompt for another number.</p>
<ol>
<li value="7">The program shall exit the loop when an empty value is entered:<pre>             } while (input != string.Empty);
        }
    }
}</pre></li>
<li>For running the console app, start by entering the numbers <code>1</code> and then <code>2</code>. As these are very quick calculations, they both return in under one second.<pre>Enter number:1
Enter number:2
11:25:11 [04] Fibonacci 1 = 1 (elapsed time: 0 secs)
Enter number:45
11:25:12 [04] Fibonacci 2 = 1 (elapsed time: 0 secs)
Enter number:44
Enter number:43
Enter number:42
Enter number:41
Enter number:40
Enter number:10
11:25:35 [08] Fibonacci 41 = 165,580,141 (elapsed time: 4 secs)
11:25:35 [09] Fibonacci 40 = 102,334,155 (elapsed time: 2 secs)
11:25:36 [07] Fibonacci 42 = 267,914,296 (elapsed time: 6 secs)
Enter number: 39
11:25:36 [09] Fibonacci 10 = 55 (elapsed time: 0 secs)
11:25:37 [05] Fibonacci 43 = 433,494,437 (elapsed time: 9 secs)
11:25:38 [06] Fibonacci 44 = 701,408,733 (elapsed time: 16 secs)
Enter number:38
11:25:44 [06] Fibonacci 38 = 39,088,169 (elapsed time: 1 secs)
11:25:44 [05] Fibonacci 39 = 63,245,986 (elapsed time: 2 secs)
11:25:48 [04] Fibonacci 45 = 1,134,903,170 (elapsed time: 27 secs)</pre></li>
</ol>
<p>Notice how the <code>ThreadId</code> is <code>[04]</code> for both <code>1</code> and <code>2</code>. This shows that the same thread was used by <code>Task.Run</code> for both iterations. By the time <code>2</code> was entered, the previous calculation had already been completed. So .NET decided to reuse thread <code>04</code> again. The same occurs for the value <code>45</code>, which took <code>27</code> seconds to complete even though it was the third requested.</p>
<p>You can see that entering values above <code>40</code> causes the elapsed time to increase quite dramatically (for each increase by one, the time taken almost doubles). Starting with higher numbers and descending downward, you can see that the calculations for <code>41</code>, <code>40</code>, and <code>42</code> were all completed before <code>44</code> and <code>43</code>, even though they were started at similar times. In a few instances, the same thread appears twice. Again, this is .NET re-using idle threads to run the task's action.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/YLYd4">https://packt.link/YLYd4</a>.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor213"/>Coordinating Tasks</h2>
<p>In the previous <em class="italic">Exercise 5.01</em>, you saw how multiple tasks can be started and left to run to completion without any interaction between the individual tasks. One such scenario is a process that needs to search a folder looking for image files, adding a copyright watermark to each image file found. The process can use multiple tasks, each working on a distinct file. There would be no need to coordinate each task and its resulting image.</p>
<p>Conversely, it is quite common to start various long-running tasks and only continue when some or all of the tasks have completed; maybe you have a collection of complex calculations that need to be started and can only perform a final calculation once the others have completed.</p>
<p>In the <em class="italic">Introduction</em> section, it was mentioned that a hiking application needed a GPS satellite signal, navigation route, and a heart rate monitor before it could be used safely. Each of these dependencies can be created using a <code>Task</code> and only when all of them have signaled that they are ready to be used should the application then allow the user to start with their route.</p>
<p>Over the next sections, you will cover various ways offered by C# to coordinate tasks. For example, you may have a requirement to start many independent tasks running, each running a complex calculation, and need to calculate a final value once all the previous tasks have completed. You may either like to start downloading data from multiple websites but want to cancel the downloads that are taking too long to complete. The next section will cover this scenario.</p>
<h3 id="_idParaDest-192"><a id="_idTextAnchor214"/>Waiting for Tasks to Complete</h3>
<p><code>Task.Wait</code> can be used to wait for an individual task to complete. If you are working with multiple tasks, then the static <code>Task.WaitAll</code> method will wait for all tasks to complete. The <code>WaitAll</code> overloads allow cancellation and timeout options to be passed in, with most returning a Boolean value to indicate success or failure, as you can see in the following list:</p>
<ul>
<li><code>public static bool WaitAll(Task[] tasks, TimeSpan timeout)</code>: This is passed an array of <code>Task</code> items to wait for. It returns <code>true</code> if <code>TimeSpan</code> allows specific units such as hours, minutes, and seconds to be expressed).</li>
<li><code>public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)</code>: This is passed an array of <code>Task</code> items to wait for, and a cancellation token that can be used to coordinate the cancellation of the tasks.</li>
<li><code>public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)</code>: This is passed an array of <code>Task</code> items to wait for and a cancellation token that can be used to coordinate the cancellation of the tasks. <code>millisecondsTimeout</code> specifies the number of milliseconds to wait for all tasks to complete by.</li>
<li><code>public static void WaitAll(params Task[] tasks)</code>: This allows an array of <code>Task</code> items to wait for.</li>
</ul>
<p>If you need to wait for any task to complete from a list of tasks, then you can use <code>Task.WaitAny</code>. All of the <code>WaitAny</code> overloads return either the index number of the first completed task or <code>-1</code> if a timeout occurred (the maximum amount of time to wait for).</p>
<p>For example, if you pass an array of five Task items and the last Task in that array completes, then you will be returned the value four (array indexes always start counting at zero).</p>
<ul>
<li><code>public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)</code>: This is passed an array of <code>Task</code> items to wait for, the number of milliseconds to wait for any <code>Task</code> to complete by, and a cancellation token that can be used to coordinate the cancellation of the tasks.</li>
<li><code>public static int WaitAny(params Task[] tasks)</code>: This is passed an array of <code>Task</code> items to wait for any <code>Task</code> to be completed.</li>
<li><code>public static int WaitAny(Task[] tasks, int millisecondsTimeout)</code>: Here, you pass the number of milliseconds to wait for any tasks to complete.</li>
<li><code>public static int WaitAny(Task[] tasks, CancellationToken cancellationToken) CancellationToken</code>: This is passed a cancellation token that can be used to coordinate the cancellation of the tasks.</li>
<li><code>public static int WaitAny(Task[] tasks, TimeSpan timeout)</code>: This is passed the maximum time period to wait for.</li>
</ul>
<p>Calling <code>Wait</code>, <code>WaitAll</code>, or <code>WaitAny</code> will block the current thread, which can negate the benefits of using a task in the first place. For this reason, it is preferable to call these from within an awaitable task, such as via <code>Task.Run</code> as the following example shows.</p>
<p>The code creates <code>outerTask</code> with a lambda statement, which itself then creates two inner tasks, <code>inner1</code>, and <code>inner2</code>. <code>WaitAny</code> is used to get the index of the <code>inner2</code> will complete first as it pauses for a shorter time, so the resulting index value will be <code>1</code>:</p>
<pre>TaskWaitAnyExample.cs
1    var outerTask = Task.Run( () =&gt;
2    {
3        Logger.Log("Inside outerTask");
4        var inner1 = Task.Run(() =&gt;
5        {
6            Logger.Log("Inside inner1");
7            Thread.Sleep(TimeSpan.FromSeconds(3D));
8        });
9        var inner2 = Task.Run(() =&gt;
10        {
11            Logger.Log("Inside inner2");
12            Thread.Sleep(TimeSpan.FromSeconds(2D));
13        });
14
15        Logger.Log("Calling WaitAny on outerTask");
You can find the complete code here: <a href="http://packt.link/CicWk">http://packt.link/CicWk</a>.</pre>
<p>When the code runs, it produces the following output:</p>
<pre>15:47:43 [04] Inside outerTask
15:47:43 [01] Press ENTER
15:47:44 [04] Calling WaitAny on outerTask
15:47:44 [05] Inside inner1
15:47:44 [06] Inside inner2
15:47:46 [04] Waitany index=1</pre>
<p>The application remains responsive because you called <code>WaitAny</code> from inside a <code>Task</code>. You have not blocked the application's main thread. As you can see, thread ID <code>01</code> has logged this message: <code>15:47:43 [01] Press ENTER</code>.</p>
<p>This type of pattern can be used in cases where you need to fire and forget a task. For example, you may want to log an informational message to a database or a log file, but it is not essential that the flow of the program is altered if either task fails to complete.</p>
<p>A common progression from fire-and-forget tasks is those cases where you need to wait for several tasks to complete within a certain time limit. The next exercise will cover this scenario.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor215"/>Exercise 5.02: Waiting for Multiple Tasks to Complete Within a Time Period</h2>
<p>In this exercise, you will start three long-running tasks and decide your next course of action if they all completed within a certain randomly selected time span.</p>
<p>Here, you will see the generic <code>Task&lt;T&gt;</code> class being used. The <code>Task&lt;T&gt;</code> class includes a <code>Value</code> property that can be used to access the result of <code>Task</code> (in this exercise, it is a string-based generic, so <code>Value</code> will be a string type). You won't use the <code>Value</code> property here as the purpose of this exercise is to show that void and generic tasks can be waited for together. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Add the main entry point to the console app:<pre>using System;
using System.Threading;
using System.Threading.Tasks;
namespace Chapter05.Exercises.Exercise02
{
    class Program
    {
        public static void Main()
        {
            Logger.Log("Starting");</pre></li>
<li>Declare a variable named <code>taskA</code>, passing <code>Task.Run</code> a lambda that pauses the current thread for <code>5</code> seconds:<pre>            var taskA = Task.Run( () =&gt;
            {
                Logger.Log("Inside TaskA");
                Thread.Sleep(TimeSpan.FromSeconds(5));
                Logger.Log("Leaving TaskA");
                return "All done A";
            });</pre></li>
<li>Create two more tasks using the method group syntax:<pre>            var taskB = Task.Run(TaskBActivity);
            var taskC = Task.Run(TaskCActivity);</pre></li>
</ol>
<p>As you may recall, this shorter syntax can be used if the compiler can determine the type of argument required for a zero- or single-parameter method.</p>
<ol>
<li value="4">Now pick a random maximum timeout in seconds. This means that either of the two tasks may <strong class="bold">not</strong> complete before the timeout period has elapsed:<pre>            var timeout = TimeSpan.FromSeconds(new Random().Next(1, 10));
            Logger.Log($"Waiting max {timeout.TotalSeconds} seconds...");</pre></li>
</ol>
<p>Note that each of the tasks will still run to completion as you have not added a mechanism to stop executing the code inside the body of the <code>Task.Run</code> <code>Action</code> lambda.</p>
<ol>
<li value="5">Call <code>WaitAll</code>, passing in the three tasks and the <code>timeout</code> period:<pre>            var allDone = Task.WaitAll(new[] {taskA, taskB, taskC}, timeout);
            Logger.Log($"AllDone={allDone}: TaskA={taskA.Status}, TaskB={taskB.Status}, TaskC={taskC.Status}");
            Console.WriteLine("Press ENTER to quit");
            Console.ReadLine();
        }</pre></li>
</ol>
<p>This will return <code>true</code> if all tasks complete in time. You will then log the status of all tasks and wait for <code>Enter</code> to be pressed to exit the application.</p>
<ol>
<li value="6">Finish off by adding two slow-running <code>Action</code> methods:<pre>        private static string TaskBActivity()
        {
            Logger.Log($"Inside {nameof(TaskBActivity)}");
            Thread.Sleep(TimeSpan.FromSeconds(2));
            Logger.Log($"Leaving {nameof(TaskBActivity)}");
            return "";
        }
        private static void TaskCActivity()
        {
            Logger.Log($"Inside {nameof(TaskCActivity)}");
            Thread.Sleep(TimeSpan.FromSeconds(1));
            Logger.Log($"Leaving {nameof(TaskCActivity)}");
        }
    }
}</pre></li>
</ol>
<p>Each will log a message when starting and leaving a task, after a few seconds. The useful <code>nameof</code> statement is used to include the name of the method for extra logging information. Often, it is useful to examine log files to see the name of a method that has been accessed rather than hardcoding its name as a literal string.</p>
<ol>
<li value="7">Upon running the code, you will see the following output:<pre>14:46:28 [01] Starting
14:46:28 [04] Inside TaskBActivity
14:46:28 [05] Inside TaskCActivity
14:46:28 [06] Inside TaskA
14:46:28 [01] Waiting max 7 seconds...
14:46:29 [05] Leaving TaskCActivity
14:46:30 [04] Leaving TaskBActivity
14:46:33 [06] Leaving TaskA
14:46:33 [01] AllDone=True: TaskA=RanToCompletion, TaskB=RanToCompletion, TaskC=RanToCompletion
Press ENTER to quit</pre></li>
</ol>
<p>While running the code, a seven-second timeout was randomly picked by the runtime. This allowed all tasks to complete in time, so <code>true</code> was returned by <code>WaitAll</code> and all tasks had a <code>RanToCompletion</code> status at that point. Notice that the thread ID, in square brackets, is different for all three tasks.</p>
<ol>
<li value="8">Run the code again:<pre>14:48:20 [01] Starting
14:48:20 [01] Waiting max 2 seconds...
14:48:20 [05] Inside TaskCActivity
14:48:20 [06] Inside TaskA
14:48:20 [04] Inside TaskBActivity
14:48:21 [05] Leaving TaskCActivity
14:48:22 [04] Leaving TaskBActivity
14:48:22 [01] AllDone=False: TaskA=Running, TaskB=Running, TaskC=RanToCompletion
Press ENTER to quit
14:48:25 [06] Leaving TaskA</pre></li>
</ol>
<p>This time the runtime picked a two-second maximum wait time, so the <code>WaitAll</code> call times out with <code>false</code> being returned.</p>
<p>You may have noticed from the output that <code>Inside TaskBActivity</code> can sometimes appear before <code>Inside TaskCActivity</code>. This demonstrates the .NET scheduler's queuing mechanism. When you call <code>Task.Run</code>, you are asking the scheduler to add this to its queue. There may only be a matter of milliseconds between the time that you call <code>Task.Run</code> and when it invokes your lambda, but this can depend on how many other tasks you have recently added to the queue; a greater number of pending tasks could increase that time period.</p>
<p>Interestingly, the output shows <code>Leaving TaskBActivity</code>, but the <code>taskB</code> status was still <code>Running</code> just after <code>WaitAll</code> finished waiting. This indicates that there can sometimes be a very slight delay when a timed-out task's status is changed.</p>
<p>Some three seconds after the <code>Enter</code> key is pressed, <code>Leaving TaskA</code> is logged. This shows that the <code>Action</code> within any timed-out tasks will continue to run, and .NET will not stop it for you.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/5lH0o">https://packt.link/5lH0o</a>.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor216"/>Continuation Tasks</h2>
<p>So far, you have created tasks that are independent of one another, but what if you need to continue a task with the results of the previous task? Rather than blocking the current thread, by calling <code>Wait</code> or accessing the <code>Result</code> property, this can be achieved using the <code>Task</code> <code>ContinueWith</code> methods.</p>
<p>These methods return a new task, referred to as a <strong class="bold">continuation</strong> task, or more simply, a continuation, which can consume the previous task's or the antecedent's results.</p>
<p>As with standard tasks, they do not block the caller thread. There are several <code>ContinueWith</code> overloads available, many allowing extensive customization. A few of the more commonly used overloads are as follows:</p>
<ul>
<li><code>public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction)</code>: This defines a generic <code>Action&lt;T&gt;</code> based <code>Task</code> to run when the previous task completes.</li>
<li><code>public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, CancellationToken cancellationToken)</code>: This has a task to run and a cancellation token that can be used to coordinate the cancellation of the task.</li>
<li><code>public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, TaskScheduler scheduler)</code>: This also has a task to run and a low-level <code>TaskScheduler</code> that be used to queue the task.</li>
<li><code>public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, TaskContinuationOptions continuationOptions)</code>: A task to run, with the behavior for the task specified with <code>TaskContinuationOptions</code>. For example, specifying <code>NotOnCanceled</code> indicates that you do <strong class="bold">not</strong> want the continuation to be called if the previous task is canceled.</li>
</ul>
<p>Continuations have an initial <code>WaitingForActivation</code> status. The .NET Framework will execute this task once the antecedent task or tasks have completed. It is important to note that you do not need to start a continuation and attempting to do so will result in an exception.</p>
<p>The following example simulates calling a long-running function, <code>GetStockPrice</code> (this may be some sort of web service or database call that takes a few seconds to return):</p>
<pre>ContinuationExamples.cs
1    class ContinuationExamples
2    {
3        public static void Main()
4        {
5            Logger.Log("Start...");
<strong class="bold">6</strong>            <strong class="bold">Task.Run(<a id="_idTextAnchor217"/>GetStockPrice)</strong>
<strong class="bold">7</strong>                <strong class="bold">.ContinueWith(prev =&gt;</strong>
<strong class="bold">8</strong>                <strong class="bold">{</strong>
<strong class="bold">9</strong>                    <strong class="bold">Logger.Log($"GetPrice returned {prev.Result:N2}, status={prev.Status}");</strong>
<strong class="bold">10</strong>                <strong class="bold">});</strong>
11
12           Console.ReadLine();
13        }
14
You can find the complete code here: <a href="http://packt.link/rpNcx">http://packt.link/rpNcx</a>.</pre>
<p>The call to <code>GetStockPrice</code> returns a <code>double</code>, which results in the generic <code>Task&lt;double&gt;</code> being passed to as a continuation (see the highlighted part). The <code>prev</code> parameter is a generic <code>Action</code> of type <code>Task&lt;double&gt;</code>, allowing you to access the antecedent task and its <code>Result</code> to retrieve the value returned from <code>GetStockPrice</code>.</p>
<p>If you hover your mouse over the <code>ContinueWith</code> method, you will see the IntelliSense description for it as follows:</p>
<div><div><img alt="Figure 5.1: ContinueWith method signature " height="521" src="img/B16835_05_01.jpg" width="1235"/>
</div>
</div>
<p class="figure-caption">Figure 5.1: ContinueWith method signature</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>ContinueWith</code> method has various options that can be used to fine-tune behavior, and you can get more details about them from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions</a>.</p>
<p>Running the example produces an output similar to the following:</p>
<pre>09:30:45 [01] Start...
09:30:45 [03] Inside GetStockPrice
09:30:50 [04] GetPrice returned 76.44, status=RanToCompletion</pre>
<p>In the output, thread <code>[01]</code> represents the console's main thread. The task that called <code>GetStockPrice</code> was executed by thread ID <code>[03]</code>, yet the continuation was executed using a different thread, thread (<code>[04]</code>).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/rpNcx">https://packt.link/rpNcx</a>.</p>
<p>The continuation running on a different thread may not be a problem, but it certainly will be an issue if you are working on UWP, WPF, or WinForms UI apps where it's essential that UI elements are updated using the main UI thread (unless you are using binding semantics).</p>
<p>It is worth noting that the <code>TaskContinuationOptions.OnlyOnRanToCompletion</code> option can be used to ensure the continuation only runs if the antecedent task has run to completion first. For example, you may create a <code>Task</code> that fetches customers' orders from a database and then use a continuation task to calculate the average order value. If the previous task fails or is canceled by the user, then there is no point in wasting processing power to calculate the average if the user no longer cares about the result.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>ContinueWith</code> method has various options that can be used to fine-tune behavior, and you can see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions</a> for more details.</p>
<p>If you access the <code>Task&lt;T&gt; Result</code> property on a <code>AggregateException</code> being thrown. This will be covered in more detail later.</p>
<h3 id="_idParaDest-195"><a id="_idTextAnchor218"/>Using Task.WhenAll and Task.WhenAny with Multiple Tasks</h3>
<p>You have seen how a single task can be used to create a continuation task, but what if you have multiple tasks and need to continue with a final operation when any or all of the previous tasks have completed?</p>
<p>Earlier, the <code>Task.WaitAny</code> and <code>Task.WaitAll</code> methods were used to wait for tasks to complete, but these block the current thread. This is where <code>Task.WhenAny</code> and <code>Task.WhenAll</code> can be used. They return a new <code>Task</code> whose <code>Action</code> delegate is called <strong class="bold">when</strong> any, or all, of the preceding tasks have completed.</p>
<p>There are four <code>WhenAll</code> overloads, two that return a <code>Task</code> and two that return a generic <code>Task&lt;T&gt;</code> allowing the task's result to be accessed:</p>
<ol>
<li value="1"><code>public static Task WhenAll(IEnumerable&lt;Task&gt; tasks)</code>: This continues when the collection of tasks completes.</li>
<li><code>public static Task WhenAll(params Task[] tasks)</code>: This continues when the array of tasks completes.</li>
<li><code>public static Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt;(params Task&lt;TResult&gt;[] tasks)</code>: This continues when the array of generic <code>Task&lt;T&gt;</code> items complete.</li>
<li><code>public static Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt;(IEnumerable&lt;Task&lt;TResult&gt;&gt; tasks)</code>: This continues when the collection of generic <code>Task&lt;T&gt;</code> items complete.</li>
</ol>
<p><code>WhenAny</code> has a similar set of overloads but returns the <code>Task</code> or <code>Task&lt;T&gt;</code> that is the <code>WhenAll</code> and <code>WhenAny</code> in practice.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor219"/>Exercise 5.03: Waiting for All Tasks to Complete</h2>
<p>Say you have been asked by a car dealer to create a console application that calculates the average sales value for cars sold across different regions. A dealership is a busy place, but they know it may take a while to fetch and calculate the average. For this reason, they want to enter a maximum number of seconds that they are prepared to wait for the average calculation. Any longer and they will leave the app and ignore the result.</p>
<p>The dealership has 10 regional sales hubs. To calculate the average, you need to first invoke a method called <code>FetchSales</code>, which returns a list of <code>CarSale</code> items for each of these regions.</p>
<p>Each call to <code>FetchSales</code> could be to a potentially slow-running service (you will implement random pauses to simulate such a delay) so you need to use a <code>Task</code> for each as you can't know for sure how long each call will take to complete. You also do not want slow-running tasks to affect other tasks, but to calculate a valid average, it's important to have <strong class="bold">all</strong> results returned before continuing.</p>
<p>Create a <code>SalesLoader</code> class that implements <code>IEnumerable&lt;CarSale&gt; FetchSales()</code> to return the car sales details. Then, a <code>SalesAggregator</code> class should be passed a list of <code>SalesLoader</code> (in this exercise, there will be 10 loader instances, one for each region). The aggregator will wait for all loaders to finish using <code>Task.WhenAll</code> before continuing with a task that calculates the average across all regions.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">First, create a <code>CarSale</code> record. The constructor accepts two values, the name of the car and its sale price (<code>name</code> and <code>salePrice</code>):<pre>using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
namespace Chapter05.Exercises.Exercise03
{
    public record CarSale
    {
        public CarSale(string name, double salePrice)
            =&gt; (Name, SalePrice) = (name, salePrice);
        public string Name { get; }
        public double SalePrice { get; }
    }</pre></li>
<li>Now create an interface, <code>ISalesLoader</code>, that represents the sales data loading service:<pre>    public interface ISalesLoader
    {
        public IEnumerable&lt;CarSale&gt; FetchSales();
    }</pre></li>
</ol>
<p>It has just one call, <code>FetchSales</code>, returning an enumerable of type <code>CarSale</code>. For now, it's not important to know how the loader works; just that it returns a list of car sales when called. Using an interface here allows using various types of loader as needed.</p>
<ol>
<li value="3">User the aggregator class to call an <code>ISalesLoader</code> implementation:<pre>    public static class SalesAggregator
    {
       public static Task&lt;double&gt; Average(IEnumerable&lt;ISalesLoader&gt; loaders)
       {</pre></li>
</ol>
<p>It is declared as <code>static</code> as there is no state between calls. Define an <code>Average</code> function that is passed an enumerable of <code>ISalesLoader</code> items and returns a generic <code>Task&lt;Double&gt;</code> for the final average calculation.</p>
<ol>
<li value="4">For each of the loader parameters, use a LINQ projection to pass a <code>loader.FetchSales</code> method to <code>Task.Run</code>:<pre>         var loaderTasks = loaders.Select(ldr =&gt; Task.Run(ldr.FetchSales));
         return Task
                .WhenAll(loaderTasks)
                .ContinueWith(tasks =&gt;</pre></li>
</ol>
<p>Each of these will return a <code>Task&lt;IEnumerable&lt;CarSale&gt;&gt;</code> instance. <code>WhenAll</code> is used to create a single task that continues when <code>ContinueWith</code> call.</p>
<ol>
<li value="5">Use the LINQ <code>SelectMany</code> to grab all of the <code>CarSale</code> items from every loader call result, before calling the Linq <code>Average</code> on the <code>SalePrice</code> field of each <code>CarSale</code> item:<pre>                {
                    var average = tasks.Result
                        .SelectMany(t =&gt; t)
                        .Average(car =&gt; car.SalePrice);
                    return average;
                });
        }
    }
}</pre></li>
<li>Implement the <code>ISalesLoader</code> interface from a class called <code>SalesLoader</code>:<pre>    public class SalesLoader : ISalesLoader
    {
        private readonly Random _random;
        private readonly string _name;
        public SalesLoader(int id, Random rand)
        {
            _name = $"Loader#{id}";
            _random = rand;
        }</pre></li>
</ol>
<p>The constructor will be passed an <code>int</code> variable used for logging and a <code>Random</code> instance to help create a random number of <code>CarSale</code> items.</p>
<ol>
<li value="7">Your <code>ISalesLoader</code> implementation requires a <code>FetchSales</code> function. Include a random delay of between <code>1</code> and <code>3</code> seconds to simulate a less reliable service:<pre>        public IEnumerable&lt;CarSale&gt; FetchSales()
        {
            var delay = _random.Next(1, 3);
            Logger.Log($"FetchSales {_name} sleeping for {delay} seconds ...");
            Thread.Sleep(TimeSpan.FromSeconds(delay));</pre></li>
</ol>
<p>You are trying to test that your application behaves with various time delays. Hence, the random class use.</p>
<ol>
<li value="8">Use <code>Enumerable.Range</code> and <code>random.Next</code> to pick a random number from one to five:<pre>            var sales = Enumerable
                .Range(1, _random.Next(1, 5))
                .Select(n =&gt; GetRandomCar())
                .ToList();
            foreach (var car in sales)
                Logger.Log($"FetchSales {_name} found: {car.Name} @ {car.SalePrice:N0}");
            return sales;
        }</pre></li>
</ol>
<p>This is the total number of <code>CarSale</code> items to return using your <code>GetRandomCar</code> function.</p>
<ol>
<li value="9">Use the <code>GetRandomCar</code> to generate a <code>CarSale</code> item with a random manufacturer's name from a hardcoded list.</li>
<li>Use the <code>carNames.length</code> property to pick a random index number between zero and four for the car's name:<pre>        private readonly string[] _carNames = { "Ford", "BMW", "Fiat", "Mercedes", "Porsche" };
        private CarSale GetRandomCar()
        {
            var nameIndex = _random.Next(_carNames.Length);
            return new CarSale(
                _carNames[nameIndex], _random.NextDouble() * 1000);
        }
    }</pre></li>
<li>Now, create your console app to test this out:<pre>    public class Program
    {
        public static void Main()
        {
            var random = new Random();
            const int MaxSalesHubs = 10;
            string input;
            do
            {
                Console.WriteLine("Max wait time (in seconds):");
                input = Console.ReadLine();
                if (string.IsNullOrEmpty(input))
                    continue;</pre></li>
</ol>
<p>Your app will repeatedly ask for a maximum time that the user is prepared to wait while data is downloaded. Once all the data has been downloaded, the app will use this to calculate an average price. Pressing <code>Enter</code> alone will result in the program loop ending. <code>MaxSalesHubs</code> is the maximum number of sales hubs to request data for.</p>
<ol>
<li value="12">Convert the entered value into an <code>int</code> type, then use <code>Enumerable.Range</code> again to create a random number of new <code>SalesLoader</code> instances (you have up to 10 different sales hubs):<pre>                if (int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var maxDelay))
                {
                       var loaders = Enumerable.Range(1,                                           random.Next(1, MaxSalesHubs))
                        .Select(n =&gt; new SalesLoader(n, random))
                        .ToList();</pre></li>
<li>Pass loaders to the static <code>SalesAggregator.Average</code> method to receive a <code>Task&lt;Double&gt;</code>.</li>
<li>Call <code>Wait</code>, passing in the maximum wait time:<pre>                    var averageTask = SalesAggregator.Average(loaders);
                    var hasCompleted = averageTask.Wait(                              TimeSpan.FromSeconds(maxDelay));
                    var average = averageTask.Result;</pre></li>
</ol>
<p>If the <code>Wait</code> call does return in time, then you will see a <code>true</code> value for has completed.</p>
<ol>
<li value="15">Finish off by checking <code>hasCompleted</code> and log a message accordingly:<pre>                    if (hasCompleted)
                    {
                        Logger.Log($"Average={average:N0}");
                    }
                    else
                    {
                        Logger.Log("Timeout!");
                    }
                }
            } while (input != string.Empty);
        }
    }
}</pre></li>
<li>When running the console app and entering a short maximum wait of <code>1</code> second, you see three loader instances randomly created:<pre>Max wait time (in seconds):1
10:52:49 [04] FetchSales Loader#1 sleeping for 1 seconds ...
10:52:49 [06] FetchSales Loader#3 sleeping for 1 seconds ...
10:52:49 [05] FetchSales Loader#2 sleeping for 1 seconds ...
10:52:50 [04] FetchSales Loader#1 found: Mercedes @ 362
10:52:50 [04] FetchSales Loader#1 found: Ford @ 993
10:52:50 [06] FetchSales Loader#3 found: Fiat @ 645
10:52:50 [05] FetchSales Loader#2 found: Mercedes @ 922
10:52:50 [06] FetchSales Loader#3 found: Ford @ 9
10:52:50 [05] FetchSales Loader#2 found: Porsche @ 859
10:52:50 [05] FetchSales Loader#2 found: Mercedes @ 612
10:52:50 [01] Timeout!</pre></li>
</ol>
<p>Each loader sleeps for <code>1</code> second (you can see various thread IDs are logged) before returning a random list of <code>CarSale</code> records. You soon reach the maximum timeout value, hence the message <code>Timeout!</code> with no average value displayed.</p>
<ol>
<li value="17">Enter a larger timeout period of <code>10</code> seconds:<pre>Max wait time (in seconds):10
20:08:41 [05] FetchSales Loader#1 sleeping for 2 seconds ...
20:08:41 [12] FetchSales Loader#4 sleeping for 1 seconds ...
20:08:41 [08] FetchSales Loader#2 sleeping for 1 seconds ...
20:08:41 [11] FetchSales Loader#3 sleeping for 1 seconds ...
20:08:41 [15] FetchSales Loader#5 sleeping for 2 seconds ...
20:08:41 [13] FetchSales Loader#6 sleeping for 2 seconds ...
20:08:41 [14] FetchSales Loader#7 sleeping for 1 seconds ...
20:08:42 [08] FetchSales Loader#2 found: Porsche @ 735
20:08:42 [08] FetchSales Loader#2 found: Fiat @ 930
20:08:42 [11] FetchSales Loader#3 found: Porsche @ 735
20:08:42 [12] FetchSales Loader#4 found: Porsche @ 735
20:08:42 [08] FetchSales Loader#2 found: Porsche @ 777
20:08:42 [11] FetchSales Loader#3 found: Ford @ 500
20:08:42 [12] FetchSales Loader#4 found: Ford @ 500
20:08:42 [12] FetchSales Loader#4 found: Porsche @ 710
20:08:42 [14] FetchSales Loader#7 found: Ford @ 144
20:08:43 [05] FetchSales Loader#1 found: Fiat @ 649
20:08:43 [15] FetchSales Loader#5 found: Ford @ 779
20:08:43 [13] FetchSales Loader#6 found: Porsche @ 763
20:08:43 [15] FetchSales Loader#5 found: Fiat @ 137
20:08:43 [13] FetchSales Loader#6 found: BMW @ 415
20:08:43 [15] FetchSales Loader#5 found: Fiat @ 853
20:08:43 [15] FetchSales Loader#5 found: Porsche @ 857
20:08:43 [01] Average=639</pre></li>
</ol>
<p>Entering a value of <code>10</code> seconds allow <code>7</code> random loaders to complete in time and to finally create the average value of <code>639</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/kbToQ">https://packt.link/kbToQ</a>.</p>
<p>So far, this chapter has considered the various ways that individual tasks can be created and how static <code>Task</code> methods are used to create tasks that are started for us. You saw how <code>Task.Factory.StartNew</code> is used to create configured tasks, albeit with a longer set of configuration parameters. The <code>Task.Run</code> methods, which were more recently added to C#, are preferable by using their more concise signatures for most regular scenarios.</p>
<p>Using continuations, single and multiple tasks can be left to run in isolation, only continuing with a final task when all or any of the preceding tasks have run to completion.</p>
<p>Now it is time to look at the <code>async</code> and <code>wait</code> keywords to run asynchronous code. These keywords are a relatively new addition to the C# language. The <code>Task.Factory.StartNew</code> and <code>Task.Run</code> methods can be found in older C# applications, but hopefully, you will see that <code>async</code>/<code>await</code> provides a much clearer syntax.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor220"/>Asynchronous Programming</h1>
<p>So far, you have created tasks and used the static <code>Task</code> factory methods to run and coordinate such tasks. In earlier versions of C#, these were the only ways to create tasks.</p>
<p>The C# language now provides the <code>async</code> and <code>await</code> keywords to <code>async</code>/<code>await</code> style results in less code and the code that is created is generally easier to grasp and therefore easier to maintain.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may often find that legacy concurrent-enabled applications were originally created using <code>Task.Factory.StartNew</code> methods are subsequently updated to use the equivalent <code>Task.Run</code> methods or are updated directly to the <code>async</code>/<code>await</code> style.</p>
<p>The <code>async</code> keyword indicates that the method will return to the caller before it has had a chance to complete its operations, therefore the caller should wait for it to complete at some point in time.</p>
<p>Adding the <code>async</code> keyword to a method instructs the compiler that it may need to generate additional code to create a state machine. In essence, a state machine extracts the logic from your original method into a series of delegates and local variables that allows code to continue onto the next statement following an <code>await</code> expression. The compiler generates delegates that can jump back to the same location in the method once they have completed. </p>
<p class="callout-heading">Note</p>
<p class="callout">You don't normally see this extra complied code, but if you are interested in learning more about state machines in C#, visit <a href="https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c">https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c</a>.</p>
<p>Adding the <code>async</code> keyword does not mean that <code>async</code> method is executed, it starts off running synchronously until it comes to a section of code with the <code>await</code> keyword. At this point, the awaitable block of code (in the following example, the <code>BuildGreetings</code> call is awaitable due to the preceding <code>async</code> keyword) is checked to see if it has already been completed. If so, it continues executing synchronously. If not, the asynchronous method is paused and returns an incomplete <code>Task</code> to the caller. This will be complete once the <code>async</code> code has been completed.</p>
<p>In the following console app, the entry point, <code>static Main</code>, has been marked as <code>async</code> and the <code>Task</code> return type added. You cannot mark a <code>Main</code> entry point, which returns either <code>int</code> or <code>void</code>, as <code>async</code> because the runtime must be able to return a <code>Task</code> result to the calling environment when the console app closes:</p>
<pre>AsyncExamples.cs
1    using System;
2    using System.Threading;
3    using System.Threading.Tasks;
4    
5    namespace Chapter05.Examples
6    {
7        public class AsyncExamples
8        {
9            public static async Task Main()
10            {
11                Logger.Log("Starting");
12                await BuildGreetings();
13
14                Logger.Log("Press Enter");
15                Console.ReadLine();
You can find the complete code here: <a href="http://packt.link/CsCek">http://packt.link/CsCek</a>.</pre>
<p>Running the example produces an output like this:</p>
<pre>18:20:31 [01] Starting
18:20:31 [01] Morning
18:20:41 [04] Morning...Afternoon
18:20:42 [04] Morning...Afternoon...Evening
18:20:42 [04] Press Enter</pre>
<p>As soon as <code>Main</code> runs, it logs <code>Starting</code>. Notice how the <code>ThreadId</code> is <code>[01]</code>. As you saw earlier, the console app's main thread is numbered as <code>1</code> (because the <code>Logger.Log</code> method uses the <code>00</code> format string, which adds a leading <code>0</code> to numbers in the range zero to nine).</p>
<p>Then the asynchronous method <code>BuildGreetings</code> is called. It sets the string <code>message</code> variable to <code>"Morning"</code> and logs the message. The <code>ThreadId</code> is still <code>[01]</code>; this is currently running synchronously.</p>
<p>So far, you have been using <code>Thread.Sleep</code> to block the calling thread in order or simulate long-running operations, but <code>async</code>/<code>await</code> makes it easier to simulate slow actions using the static <code>Task.Delay</code> method and awaiting that call. <code>Task.Delay</code> returns a task so it can also be used in continuation tasks.</p>
<p>Using <code>Task.Delay</code>, you will make two distinct awaitable calls (one that waits for 10 seconds and the second for two seconds), before continuing and appending to your local <code>message</code> string. The two <code>Task.Delay</code> calls could have been any method in your code that returns a <code>Task</code>.</p>
<p>The great thing here is that each awaited section gets its correct state in the order that it was declared in the code, irrespective of waiting 10 (or two) seconds prior. The thread IDs have all changed from <code>[01]</code> to <code>[04]</code>. This tells you that a different thread is running these statements. Even the very last <code>Press Enter</code> message has a different thread to the original thread.</p>
<p><code>Async/await</code> makes it easier to run a series of task-based codes using the familiar <code>WhenAll</code>, <code>WhenAny</code>, and <code>ContinueWith</code> methods interchangeably.</p>
<p>The following example shows how multiple <code>async</code>/<code>await</code> calls can be applied at various stages in a program using a mixture of various awaitable calls. This simulates an application that makes a call to a database (<code>FetchPendingAccounts</code>) to fetch a list of user accounts. Each user in the pending accounts list is given a unique ID (using a task for each user).</p>
<p>Based on the user's region, an account is then created in the <code>Task.WhenAll</code> call signals that everything has been completed.</p>
<pre>using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
namespace Chapter05.Examples
{</pre>
<p>Use an <code>enum</code> to define a <code>RegionName</code>:</p>
<pre>    public enum RegionName { North, East, South, West };</pre>
<p>A <code>User</code> record constructor is passed a <code>userName</code> and the user's <code>region</code>:</p>
<pre>    public record User
    {
        public User(string userName, RegionName region)
            =&gt; (UserName, Region) = (userName, region);
        public string UserName { get; }
        public RegionName Region { get; }
        public string ID { get; set; }
    }</pre>
<p><code>AccountGenerator</code> is the main controlling class. It contains an <code>async</code> <code>CreateAccounts</code> method that can be awaited by a console app (this is implemented at the end of the example):</p>
<pre>    public class AccountGenerator
    {
        public async Task CreateAccounts()
        {</pre>
<p>Using the <code>await</code> keyword, you define an awaitable call to <code>FetchPendingAccounts</code>:</p>
<pre>            var users = await FetchPendingAccounts();</pre>
<p>For each one of the users returned by <code>FetchPendingAccounts</code>, you make an awaitable call to <code>GenerateId</code>. This shows that a loop can contain multiple awaitable calls. The runtime will set the user ID for the correct user instance:</p>
<pre>            foreach (var user in users)
            {
                var id = await GenerateId();
                user.ID = id;
            }</pre>
<p>Using a Linq <code>Select</code> function, you create a list of tasks. For each user, a Northern or Other account is created based on the user's region (each one of the calls is a <code>Task</code> per user):</p>
<pre>            var accountCreationTasks = users.Select(
                user =&gt; user.Region == RegionName.North
                    ? Task.Run(() =&gt; CreateNorthernAccount(user))
                    : Task.Run(() =&gt; CreateOtherAccount(user)))
                .ToList();</pre>
<p>The list of account creation tasks is awaited using the <code>static</code> <code>WhenAll</code> call. Once this completes, <code>UpdatePendindAccounts</code> will be called passing in the updated user list. This shows that you can pass lists of tasks between <code>async</code> statements:</p>
<pre>            Logger.Log($"Creating {accountCreationTasks.Count} accounts");
            await Task.WhenAll(accountCreationTasks);
            var updatedAccountTask = UpdatePendingAccounts(users);
            await updatedAccountTask;
            Logger.Log($"Updated {updatedAccountTask.Result} pending accounts");
        }</pre>
<p>The <code>FetchPendingAccounts</code> method returns a <code>Task</code> containing a list of users (here you simulate a delay of <code>3</code> seconds using <code>Task.Delay</code>):</p>
<pre>        private async Task&lt;List&lt;User&gt;&gt; FetchPendingAccounts()
        {
            Logger.Log("Fetching pending accounts...");
            await Task.Delay(TimeSpan.FromSeconds(3D));
            var users = new List&lt;User&gt;
            {
                new User("AnnH", RegionName.North),
                new User("EmmaJ", RegionName.North),
                new User("SophieA", RegionName.South),
                new User("LucyG", RegionName.West),
            };
            Logger.Log($"Found {users.Count} pending accounts");
            return users;
        }</pre>
<p><code>GenerateId</code> uses <code>Task.FromResult</code> to generate a globally unique ID using the <code>Guid</code> class. <code>Task.FromResult</code> is used when you want to return a result but do not need to create a running task as you would with <code>Task.Run</code>:</p>
<pre>        private static Task&lt;string&gt; GenerateId()
        {
            return Task.FromResult(Guid.NewGuid().ToString());
        }</pre>
<p>The two <code>bool</code> task methods create either a northern account or other account. Here, you return <code>true</code> to indicate that each account creation call was successful, regardless:</p>
<pre>        private static async Task&lt;bool&gt; CreateNorthernAccount(User user)
        {
            await Task.Delay(TimeSpan.FromSeconds(2D));
            Logger.Log($"Created northern account for {user.UserName}");
            return true;
        }
        private static async Task&lt;bool&gt; CreateOtherAccount(User user)
        {
            await Task.Delay(TimeSpan.FromSeconds(1D));
            Logger.Log($"Created other account for {user.UserName}");
            return true;
        }</pre>
<p>Next, <code>UpdatePendingAccounts</code> is passed a list of users. For each user, you create a task that simulates a slow-running call to update each user and returning a count of the number of users subsequently updated:</p>
<pre>        private static async Task&lt;int&gt; UpdatePendingAccounts(IEnumerable&lt;User&gt; users)
        {
            var updateAccountTasks = users.Select(usr =&gt; Task.Run(
                async () =&gt;
                {
                    await Task.Delay(TimeSpan.FromSeconds(2D));
                    return true;
                }))
                .ToList();
            await Task.WhenAll(updateAccountTasks);
            return updateAccountTasks.Count(t =&gt; t.Result);
        }
    }</pre>
<p>Finally, the console app creates an <code>AccountGenerator</code> instance and waits for <code>CreateAccounts</code> to finish before writing an <code>All done</code> message:</p>
<pre>    public static class AsyncUsersExampleProgram
    {
        public static async Task Main()
        {
            Logger.Log("Starting");
            await new AccountGenerator().CreateAccounts();
            Logger.Log("All done");
            Console.ReadLine();
        }
    }
   
}</pre>
<p>Running the console app produces this output:</p>
<pre>20:12:38 [01] Starting
20:12:38 [01] Fetching pending accounts...
20:12:41 [04] Found 4 pending accounts
20:12:41 [04] Creating 4 accounts
20:12:42 [04] Created other account for SophieA
20:12:42 [07] Created other account for LucyG
20:12:43 [04] Created northern account for EmmaJ
20:12:43 [05] Created northern account for AnnH
20:12:45 [05] Updated 4 pending accounts
20:12:45 [05] All done</pre>
<p>Here, you can see that thread <code>[01]</code> writes the <code>Starting</code> message. This is the application's main thread. Note, too, that the main thread also writes <code>Fetching pending accounts...</code> from the <code>FetchPendingAccounts</code> method. This is still running synchronously as the awaitable block (<code>Task.Delay</code>) has not yet been reached.</p>
<p>Threads <code>[4]</code>, <code>[5]</code>, and <code>[7]</code> create each of the four user accounts. You used <code>Task.Run</code> to call the <code>CreateNorthernAccount</code> or <code>CreateOtherAccount</code> methods. Thread <code>[5]</code> runs the last statement in <code>CreateAccounts: Updated 4 pending accounts</code>. The thread numbers might differ in your system because .NET uses an internal pool of threads which vary based on how busy each thread is.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ZIK8k">https://packt.link/ZIK8k</a>.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor221"/>Async Lambda Expressions</h2>
<p><em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, looked at lambda expressions and how they can be used to create succinct code. You can also use the <code>async</code> keyword with lambda expressions to create code for an event handler that contains various <code>async</code> code.</p>
<p>The following example uses the <code>WebClient</code> class to show two different ways to download data from a website (this will be covered in great detail in <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em> and <em class="italic">Chapter 9</em>, <em class="italic">Creating API Services</em>).</p>
<pre>using System;
using System.Net;
using System.Net.Http
using System.Threading.Tasks;
namespace Chapter05.Examples
{
    public class AsyncLambdaExamples
    {
        public static async Task Main()
        {
            const string Url = "https://www.packtpub.com/";
            using var client = new WebClient();</pre>
<p>Here, you add your own event handler to the <code>WebClient</code> class <code>DownloadDataCompleted</code> event using a lambda statement that is prefixed with the <code>async</code> keyword. The compiler will allow you to add awaitable calls inside the body of the lambda.</p>
<p>This event will be fired after <code>DownloadData</code> is called and the data requested has been downloaded for us. The code uses an awaitable block <code>Task.Delay</code> to simulate some extra processing on a different thread:</p>
<pre>            client.DownloadDataCompleted += async (sender, args) =&gt;
            {
                Logger.Log("Inside DownloadDataCompleted...looking busy");
                await Task.Delay(500);
                Logger.Log("Inside DownloadDataCompleted..all done now");
            };</pre>
<p>You invoke the <code>DownloadData</code> method, passing in your URL and then logging the length of the web data received. This particular call itself will block the main thread until data is downloaded. <code>WebClient</code> offers a task-based asynchronous version of the <code>DownloadData</code> method called <code>DownloadDataTaskAsync</code>. So it's recommended to use the more modern <code>DownloadDataTaskAsync</code> method as follows:</p>
<pre>            Logger.Log($"DownloadData: {Url}");
            var data = client.DownloadData(Url);
            Logger.Log($"DownloadData: Length={data.Length:N0}");</pre>
<p>Once again, you request the same URL but can simply use an <code>await</code> statement, which will be run once the data download has been completed. As you can see, this requires less code and has a cleaner syntax:</p>
<pre>            Logger.Log($"DownloadDataTaskAsync: {Url}");
            var downloadTask = client.DownloadDataTaskAsync(Url);
            var downloadBytes =  await downloadTask;
            Logger.Log($"DownloadDataTaskAsync: Length={downloadBytes.Length:N0}");
            Console.ReadLine();
        }
    }
}</pre>
<p>Running the code produces this output:</p>
<pre>19:22:44 [01] DownloadData: https://www.packtpub.com/
19:22:45 [01] DownloadData: Length=278,047
19:22:45 [01] DownloadDataTaskAsync: https://www.packtpub.com/
19:22:45 [06] Inside DownloadDataCompleted...looking busy
19:22:45 [06] DownloadDataTaskAsync: Length=278,046
19:22:46 [04] Inside DownloadDataCompleted..all done now</pre>
<p class="callout-heading">Note</p>
<p class="callout">When running the program, you may see the following warning: <code>"Warning SYSLIB0014: 'WebClient.WebClient()' is obsolete: 'WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.'"</code>. Here, Visual Studio has suggested that the <code>HttpClient</code> class be used, as <code>WebClient</code> has been marked as obsolete.</p>
<p><code>DownloadData</code> is logged by thread <code>[01]</code>, the main thread, which is blocked for around one second until the download completes. The size of the downloaded file is then logged using the <code>downloadBytes.Length</code> property.</p>
<p>The <code>DownloadDataTaskAsync</code> request is handled by thread <code>06</code>. Finally, the delayed code inside the <code>DownloadDataCompleted</code> event handler completes via thread <code>04</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/IJEaU">https://packt.link/IJEaU</a>.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor222"/>Canceling Tasks</h2>
<p>Task cancelation is a two-step approach:</p>
<ul>
<li>You need to add a way to request a cancelation.</li>
<li>Any cancelable code needs to support this.</li>
</ul>
<p>You cannot provide cancelation without both mechanisms in place.</p>
<p>Typically, you will start a long-running task that supports cancelation and provide the user with the ability to cancel the operation by pressing a button on a UI. There are many real-world examples where such cancellation is needed, such as image processing where multiple images need to be altered allowing a user to cancel the remainder of the task if they run out of time. Another common scenario is sending multiple data requests to different web servers and allowing slow-running or pending requests to be canceled as soon as the first response is received.</p>
<p>In C#, <code>CancellationTokenSource</code> acts as a top-level object to initiate a cancelation request with its <code>Token</code> property, <code>CancellationToken</code>, being passed to concurrent/slow running code that can periodically check and act upon this cancellation status. Ideally, you would not want low-level methods to arbitrarily cancel high-level operations, hence the separation between the source and the token.</p>
<p>There are various <code>C<a id="_idTextAnchor223"/><a id="_idTextAnchor224"/>ancellationTokenSource</code> constructors, including one that will initiate a cancel request after a specified time has elapsed. Here are a few of the <code>CancellationTokenSource</code> methods, offering various ways to initiate a cancellation request:</p>
<ul>
<li><code>public bool IsCancellationRequested { get; }</code>: This returns <code>true</code> if a cancellation has been requested for this token source (a caller has called the <code>Cancel</code> method). This can be inspected at intervals in the target code.</li>
<li><code>public CancellationToken Token { get; }</code>: The <code>CancellationToken</code> that is linked to this source object is often passed to <code>Task.Run</code> overloads, allowing .NET to check the status of pending tasks or for your own code to check while running.</li>
<li><code>public void Cancel()</code>: Initiates a request for cancellation.</li>
<li><code>public void Cancel(bool throwOnFirstException)</code>: Initiates a request for cancellation and determines whether further operations are to be processed should an exception occur.</li>
<li><code>public void CancelAfter(int millisecondsDelay)</code>: Schedules a cancel request after a specified number of milliseconds.</li>
</ul>
<p><code>CancellationTokenSource</code> has a <code>Token</code> property. <code>CancellationToken</code> contains various methods and properties that can be used for code to detect a cancellation request:</p>
<ul>
<li><code>public bool IsCancellationRequested { get; }</code>: This returns <code>true</code> if a cancellation has been requested for this token.</li>
<li><code>public CancellationTokenRegistration Register(Action callback)</code>: Allows code to register a delegate that will be executed by the system if this token is canceled.</li>
<li><code>public void ThrowIfCancellationRequested()</code>: Calling this method will result in <code>OperationCanceledException</code> being thrown if a cancellation has been requested. This is typically used to break out of loops.</li>
</ul>
<p>Throughout the previous examples, you may have spotted that <code>CancellationToken</code> can be passed to many of the static <code>Task</code> methods. For example, <code>Task.Run</code>, <code>Task.Factory.StartNew</code>, and <code>Task.ContinueWith</code> all contain overrides that accept <code>CancellationToken</code>.</p>
<p>.NET will not try to interrupt or stop any of your code once it is running, no matter how many times you call <code>Cancel</code> on a <code>CancellationToken</code>. Essentially, you pass these tokens into target code, but it is up to that code to periodically check the cancellation status whenever it can, such as within a loop, and then decide how it should act upon it. This makes logical sense; how would .NET know at what point it was safe to interrupt a method, maybe one that has hundreds of lines of code?</p>
<p>Passing <code>CancellationToken</code> to <code>Task.Run</code> only provides a hint to the queue scheduler that it may not need to start a task's action, but once started, .NET will not stop that running code for you. The running code itself must subsequently observe the cancelation status.</p>
<p>This is analogous to a pedestrian waiting to cross a road at a set of traffic lights. Motor vehicles can be thought of as tasks that have been started elsewhere. When the pedestrian arrives at the crossing and they press a button (calling <code>Cancel</code> on <code>CancellationTokenSource</code>), the traffic lights should eventually change to red so that the moving vehicles are requested to stop. It is up to each individual driver to observe that the red light has changed (<code>IsCancellationRequested</code>) and then decide to stop their vehicle. The traffic light does not forcibly stop each vehicle (.NET runtime). If a driver notices that the vehicle behind is too close and stopping soon may result in a collision, they may decide to not stop immediately. A driver that is not observing the traffic light status at all may fail to stop.</p>
<p>The next sections will continue with exercises that show <code>async</code>/<code>await</code> in action, some of the commonly used options for canceling tasks, in which you will need to control whether pending tasks should be allowed to run to completion or interrupted, and when you should aim to catch exceptions.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor225"/>Exercise 5.04: Canceling Long-Running Tasks</h2>
<p>You will create this exercise in two parts:</p>
<ul>
<li>One that uses a <code>Task</code> that returns a double-based result.</li>
<li>Second that provides a fine-grained level of control by inspecting the <code>Token.IsCancellationRequested</code> property.</li>
</ul>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Create a class called <code>SlowRunningService</code>. As the name suggests, the methods inside the service have been designed to be slow to complete:<pre>using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
namespace Chapter05.Exercises.Exercise04
{
    public class SlowRunningService
    {</pre></li>
<li>Add the first slow-running operation, <code>Fetch</code>, which is passed a delay time (implemented with a simple <code>Thread.Sleep</code> call), and the cancellation token, which you pass to <code>Task.Run</code>:<pre>        public Task&lt;double&gt; Fetch(TimeSpan delay, CancellationToken token)
        {
            return Task.Run(() =&gt;
                {
                    var now = DateTime.Now;
                    Logger.Log("Fetch: Sleeping");
                    Thread.Sleep(delay);
                    Logger.Log("Fetch: Awake");
                    return DateTime.Now.Subtract(now).TotalSeconds;
                },
                token);
        }</pre></li>
</ol>
<p>When <code>Fetch</code> is called, the token may get canceled before the sleeping thread awakes.</p>
<ol>
<li value="3">To test whether <code>Fetch</code> will just stop running or return a number, add a console app to test this. Here, use a default delay (<code>DelayTime</code>) of <code>3</code> seconds:<pre>    public class Program
    {
        private static readonly TimeSpan DelayTime=TimeSpan.FromSeconds(3);</pre></li>
<li>Add a helper function to prompt for a maximum number of seconds that you are prepared to wait. If a valid number is entered, convert the value entered into a <code>TimeSpan</code>:<pre>        private static TimeSpan? ReadConsoleMaxTime(string message)
        {
            Console.Write($"{message} Max Waiting Time (seconds):");
            var input = Console.ReadLine();
            if (int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var intResult))
            {
                return TimeSpan.FromSeconds(intResult);
            }
            return null;
        }</pre></li>
<li>Add a standard <code>Main</code> entry point for the console app. This is marked async and returns a <code>Task</code>:<pre>public static async Task Main()
        {</pre></li>
<li>Create an instance of the service. You will use the same instance in a loop, shortly:<pre>            var service = new SlowRunningService();</pre></li>
<li>Now add a <code>do</code>-loop that repeatedly asks for a maximum delay time:<pre>          Console.WriteLine($"ETA: {DelayTime.TotalSeconds:N} seconds");  
          
          TimeSpan? maxWaitingTime;
            while (true)
            {
                maxWaitingTime = ReadConsoleMaxTime("Fetch");
                if (maxWaitingTime == null)
                    break;</pre></li>
</ol>
<p>This allows you to try various values to see how that affects the cancel token and the results you receive back. In the case of a <code>null</code> value, you will <code>break</code> out of the <code>do</code>-loop.</p>
<ol>
<li value="8">Create <code>CancellationTokenSource</code>, passing in the maximum waiting time:<pre>                using var tokenSource = new CancellationTokenSource( maxWaitingTime.Value);
                var token = tokenSource.Token;</pre></li>
</ol>
<p>This will trigger a cancellation without having to call the <code>Cancel</code> method yourself.</p>
<ol>
<li value="9">Using the <code>CancellationToken.Register</code> method, pass an <code>Action</code> delegate to be invoked when the token gets signaled for cancellation. Here, simply log a message when that occurs:<pre>                token.Register(() =&gt; Logger.Log($"Fetch: Cancelled token={token.GetHashCode()}"));</pre></li>
<li>Now for the main activity, call the service's <code>Fetch</code> method, passing in the default <code>DelayTime</code> and the token:<pre>                var resultTask = service.Fetch(DelayTime, token);</pre></li>
<li>Before you await <code>resultTask</code>, add a <code>try-catch</code> block to catch any <code>TaskCanceledException</code>:<pre>                try
                {
                    await resultTask;
                    if (resultTask.IsCompletedSuccessfully)
                        Logger.Log($"Fetch: Result={resultTask.Result:N0}");
                    else
                        Logger.Log($"Fetch: Status={resultTask.Status}");
                }
                catch (TaskCanceledException ex)
                {
                    Logger.Log($"Fetch: TaskCanceledException {ex.Message}");
                }
            }
        }
    }
}</pre></li>
</ol>
<p>W<a id="_idTextAnchor226"/>hen using cancelable tasks, there is a possibility that they will throw <code>TaskCanceledException</code>. In this case, that is okay as you do expect that to happen. Notice that you only access the <code>resultTask.Result</code> if the task is marked as <code>IsCompletedSuccessfully</code>. If you attempt to access the <code>Result</code> property of a faulted task, then <code>AggregateException</code> instance is thrown. In some older projects, you may see non-async/await code that catches <code>AggregateException</code>.</p>
<ol>
<li value="12">Run the app and enter a waiting time greater than the ETA of three seconds, <code>5</code> in this case:<pre>ETA: 3.00 seconds
Fetch Max Waiting Time (seconds):5
16:48:11 [04] Fetch: Sleeping
16:48:14 [04] Fetch: Awake
16:48:14 [04] Fetch: Result=3</pre></li>
</ol>
<p>As expected, the token was not canceled prior to completion, so you see <code>Result=3</code> (the elapsed time in seconds).</p>
<ol>
<li value="13">Try this again. For the cancellation to be triggered and detected, enter <code>2</code> for the number of seconds:<pre>Fetch Max Waiting Time (seconds):2
16:49:51 [04] Fetch: Sleeping
16:49:53 [08] Fetch: Cancelled token=28589617
16:49:54 [04] Fetch: Awake
16:49:54 [04] Fetch: Result=3 </pre></li>
</ol>
<p>Notice that the <code>Cancelled token</code> message is logged <code>Fetch</code> awakes, but you still end up receiving a result of <code>3</code> seconds with no <code>TaskCanceledException</code> message. This emphasizes the point that passing a cancellation token to <code>Start.Run</code> does not stop the task's action from starting, and more importantly, it did not interrupt it either.</p>
<ol>
<li value="14">Finally, use <code>0</code> as the maximum waiting time, which will effectively trigger the cancellation immediately:<pre>Fetch Max Waiting Time (seconds):
0
16:53:32 [04] Fetch: Cancelled token=48717705
16:53:32 [04] Fetch: TaskCanceledException A task was canceled. </pre></li>
</ol>
<p>You will see the canceled token message and <code>TaskCanceledException</code> being caught, but there are no <code>Sleeping</code> or <code>Awake</code> messages logged at all. This shows that the <code>Action</code> passed to <code>Task.Run</code> was not actually started by the runtime. When you pass a <code>CancelationToken</code> to <code>Start.Run</code>, the task's <code>Action</code> gets queued but <code>TaskScheduler</code> will not run the action if it notices that the token has been canceled prior to starting; it just throws <code>TaskCanceledException</code>.</p>
<p>Now for an alternative slow-running method, one that allows you to support cancellable actions via a loop that polls for a change in the cancellation status.</p>
<ol>
<li value="15">In the <code>SlowRunningService</code> class, add a <code>FetchLoop</code> function:<pre>        public Task&lt;double?&gt; FetchLoop(TimeSpan delay, CancellationToken token)
        {
            return Task.Run(() =&gt;
            {
                const int TimeSlice = 500;
                var iterations = (int)(delay.TotalMilliseconds / TimeSlice);
                Logger.Log($"FetchLoop: Iterations={iterations} token={token.GetHashCode()}");
                var now = DateTime.Now;</pre></li>
</ol>
<p>This produces a result similar to the earlier <code>Fetch</code> function but its purpose is to show how a function can be broken into a repeating loop that offers the ability to examine <code>CancellationToken</code> as each loop iteration runs.</p>
<ol>
<li value="16">Define the body of a <code>for...next</code> loop, which checks, for each iteration, if the <code>IsCancellationRequested</code> property is <code>true</code> and simply returns a nullable double if it detects that a cancellation has been requested:<pre>                for (var i = 0; i &lt; iterations; i++)
                {
                    if (token.IsCancellationRequested)
                    {
                        Logger.Log($"FetchLoop: Iteration {i + 1} detected cancellation token={token.GetHashCode()}");
                        return (double?)null;
                    }
                    Logger.Log($"FetchLoop: Iteration {i + 1} Sleeping");
                    Thread.Sleep(TimeSlice);
                    Logger.Log($"FetchLoop: Iteration {i + 1} Awake");
                }
                Logger.Log("FetchLoop: done");
                return DateTime.Now.Subtract(now).TotalSeconds;
            }, token);
        }</pre></li>
</ol>
<p>This is a rather firm way to exit a loop, but as far as this code is concerned, nothing else needs to be done.</p>
<p class="callout-heading">Note</p>
<p class="callout">You could have also used a <code>continue</code> statement and cleaned up before returning. Another option is to call <code>token.ThrowIfCancellationRequested()</code> rather than checking <code>token.IsCancellationRequested</code>, which will force you to exit the <code>for</code> loop.</p>
<ol>
<li value="17">In the <code>Main</code> console app, add a similar <code>while</code> loop that calls the <code>FetchLoop</code> method this time. The code is similar to the previous looping code:<pre>        while (true)
            {
                maxWaitingTime = ReadConsoleMaxTime("FetchLoop");
                if (maxWaitingTime == null)
                    break;
                using var tokenSource = new CancellationTokenSource(maxWaitingTime.Value);
                var token = tokenSource.Token;
                token.Register(() =&gt; Logger.Log($"FetchLoop: Cancelled token={token.GetHashCode()}"));</pre></li>
<li>Now call the <code>FetchLoop</code> and await the result:<pre>                var resultTask = service.FetchLoop(DelayTime, token);
                try
                {
                    await resultTask;
                    if (resultTask.IsCompletedSuccessfully)
                        Logger.Log($"FetchLoop: Result={resultTask.Result:N0}");
                    else
                        Logger.Log($"FetchLoop: Status={resultTask.Status}");
                }
                catch (TaskCanceledException ex)
                {
                    Logger.Log($"FetchLoop: TaskCanceledException {ex.Message}");
                }
            } </pre></li>
<li>Running the console app and using a <code>5</code>-second maximum allows all the iterations to run through with none detecting a cancellation request. The result is <code>3</code> as expected:<pre>FetchLoop Max Waiting Time (seconds):5
17:33:38 [04] FetchLoop: Iterations=6 token=6044116
17:33:38 [04] FetchLoop: Iteration 1 Sleeping
17:33:38 [04] FetchLoop: Iteration 1 Awake
17:33:38 [04] FetchLoop: Iteration 2 Sleeping
17:33:39 [04] FetchLoop: Iteration 2 Awake
17:33:39 [04] FetchLoop: Iteration 3 Sleeping
17:33:39 [04] FetchLoop: Iteration 3 Awake
17:33:39 [04] FetchLoop: Iteration 4 Sleeping
17:33:40 [04] FetchLoop: Iteration 4 Awake
17:33:40 [04] FetchLoop: Iteration 5 Sleeping
17:33:40 [04] FetchLoop: Iteration 5 Awake
17:33:40 [04] FetchLoop: Iteration 6 Sleeping
17:33:41 [04] FetchLoop: Iteration 6 Awake
17:33:41 [04] FetchLoop: done
17:33:41 [04] FetchLoop: Result=3</pre></li>
<li>Use <code>2</code> as the maximum. This time the token is auto-triggered during iteration <code>4</code> and spotted by iteration <code>5</code>, so you are returned a null result:<pre>FetchLoop Max Waiting Time (seconds):
2
17:48:47 [04] FetchLoop: Iterations=6 token=59817589
17:48:47 [04] FetchLoop: Iteration 1 Sleeping
17:48:48 [04] FetchLoop: Iteration 1 Awake
17:48:48 [04] FetchLoop: Iteration 2 Sleeping
17:48:48 [04] FetchLoop: Iteration 2 Awake
17:48:48 [04] FetchLoop: Iteration 3 Sleeping
17:48:49 [04] FetchLoop: Iteration 3 Awake
17:48:49 [04] FetchLoop: Iteration 4 Sleeping
17:48:49 [06] FetchLoop: Cancelled token=59817589
17:48:49 [04] FetchLoop: Iteration 4 Awake
17:48:49 [04] FetchLoop: Iteration 5 detected cancellation token=59817589
17:48:49 [04] FetchLoop: Result=</pre></li>
<li>By using <code>0</code>, you see the same output as the earlier <code>Fetch</code> example:<pre>FetchLoop Max Waiting Time (seconds):
0
17:53:29 [04] FetchLoop: Cancelled token=48209832
17:53:29 [08] FetchLoop: TaskCanceledException A task was canceled.</pre></li>
</ol>
<p>The action doesn't get a chance to run. You can see a <code>Cancelled token</code> message and <code>TaskCanceledException</code> being logged.</p>
<p>By running this exercise, you have seen how long-running tasks can be automatically marked for cancellation by the .NET runtime if they do not complete within a specified time. By using a <code>for</code> loop, a task was broken down into small iterative steps, which provided a frequent opportunity to detect if a cancellation was requested.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/xa1Yf">https://packt.link/xa1Yf</a>.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor227"/>Exception Handling in Async/Await Code</h2>
<p>You have seen that canceling a task can result in <code>TaskCanceledException</code> being thrown. Exception handling for asynchronous code can be implemented in the same way you would for standard synchronous code, but there are a few things you need to be aware of.</p>
<p>When code in an <code>async</code> method causes an exception to be thrown, the task's status is set to <strong class="bold">Faulted</strong>. However, an exception will not be rethrown until the awaited expression gets rescheduled. What this mean is that if you do not await a call, then it's possible for exceptions to be thrown and to go completely unobserved in code.</p>
<p>Unless you absolutely cannot help it, you should not create <code>async void</code> methods. Doing so makes it difficult for the caller to await your code. This means they cannot catch any exceptions raised, which by default, will terminate a program. If the caller is not given a <code>Task</code> reference to await, then there is no way for them to tell if the called method ran to completion or not.</p>
<p>The general exception to this guideline is in the case of fire-and-forget methods as mentioned at the start of the chapter. A method that asynchronously logs the usage of the application may not be of such critical importance, so you may not care if such calls are successful or not.</p>
<p>It is possible to detect and handle unobserved task exceptions. If you attach an event delegate to the static <code>TaskScheduler.UnobservedTaskException</code> event, you can receive a notification that a task exception has gone unobserved. You can attach a delegate to this event as follows:</p>
<pre>TaskScheduler.UnobservedTaskException += (sender, args) =&gt;
{
  Logger.Log($"Caught UnobservedTaskException\n{args.Exception}");
};</pre>
<p>The runtime considers a task exception to be <strong class="bold">unobserved</strong> once the task object is finalized.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/OkH7r">https://packt.link/OkH7r</a>.</p>
<p>Continuing with some more exception handling examples, see how you can catch a specific type of exception as you would with synchronous code.</p>
<p>In the following example, the <code>CustomerOperations</code> class provides the <code>AverageDiscount</code> function, which returns <code>Task&lt;int&gt;</code>. However, there is a chance that it may throw <code>DivideByZeroException</code>, so you will need to catch that; otherwise, the program will crash.</p>
<pre>using System;
using System.Threading.Tasks;
namespace Chapter05.Examples
{
    class ErrorExamplesProgram
    {
        public static async Task Main()
        {
            try
            {</pre>
<p>Create a <code>CustomerOperations</code> instance and wait for the <code>AverageDiscount</code> method to return a value:</p>
<pre>                var operations = new CustomerOperations();
                var discount = await operations.AverageDiscount();
                Logger.Log($"Discount: {discount}");
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("Caught a divide by zero");
            }
            Console.ReadLine();
        }
        class CustomerOperations
        {
            public async Task&lt;int&gt; AverageDiscount()
            {
                Logger.Log("Loading orders...");
                await Task.Delay(TimeSpan.FromSeconds(1));</pre>
<p>Choose a random value for <code>ordercount</code> between <code>0</code> and <code>2</code>. An attempt to divide by zero will result in an exception being thrown by the .NET runtime:</p>
<pre>                var orderCount = new Random().Next(0, 2);
                var orderValue = 1200;
                return orderValue / orderCount;
            }
        }
    }
}</pre>
<p>The results show that when <code>orderCount</code> was zero, you did catch <code>DivideByZeroException</code> as expected:</p>
<pre>15:47:21 [01] Loading orders...
Caught a divide by zero</pre>
<p>Running a second time, there was no error caught:</p>
<pre>17:55:54 [01] Loading orders...
17:55:55 [04] Discount: 1200</pre>
<p>On your system you may find that the program needs to be run multiple times before the <code>DivideByZeroException</code> is raised. This is due to the use of a random instance to assign a value to <code>orderCount</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/18kOK">https://packt.link/18kOK</a>.</p>
<p>So far, you have created single tasks that may throw exceptions. The following exercise will look at a more complex variant.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor228"/>Exercise 5.05: Handling Async Exceptions</h2>
<p>Imagine you have a <code>CustomerOperations</code> class that can be used to fetch a list of customers via a <code>Task</code>. For each customer, you need to run an extra <code>async</code> task, which goes off to a service to calculate the total value of that customer's orders.</p>
<p>Once you have your customer list, the customers need to be sorted in descending order of sales, but due to some security restrictions, you are not allowed to read a customer's <code>TotalOrders</code> property if their region name is <code>West</code>. In this exercise you will create a copy of the <code>RegionName</code> enum that was used in the earlier example.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Start by adding the <code>Customer</code> class:<pre>1    using System;
2    using System.Collections.Generic;
3    using System.Linq;
4    using System.Threading.Tasks;
5
6    namespace Chapter05.Exercises.Exercise05
7    {
8        public enum RegionName { North, East, South, West };
9
10        public class Customer
11        {
12            private readonly RegionName _protectedRegion;
13
14            public Customer(string name, RegionName region, RegionName protectedRegion)
15            {</pre></li>
</ol>
<p>The constructor is passed the customer <code>name</code> and their <code>region</code>, along with a second region that identifies the <code>protectedRegion</code> name. If the customer's <code>region</code> is the same as this <code>protectedRegion</code>, then throw an access violation exception on any attempt to read the <code>TotalOrders</code> property.</p>
<ol>
<li value="2">Then add a <code>CustomerOperations</code> class:<pre>public class CustomerOperations
{
   public const RegionName ProtectedRegion = RegionName.West;</pre></li>
</ol>
<p>This knows how to load a customer's name and populate their total order value. The requirement here is that customers from the <code>West</code> region need to have a restriction hardcoded, so add a constant called <code>ProtectedRegion</code> that has <code>RegionName.West</code> as a value.</p>
<ol>
<li value="3">Add a <code>FetchTopCustomers</code> function:<pre>        public async Task&lt;IEnumerable&lt;Customer&gt;&gt; FetchTopCustomers()
        {
            await Task.Delay(TimeSpan.FromSeconds(2));
            Logger.Log("Loading customers...");
            var customers = new List&lt;Customer&gt;
            {
            new Customer("Rick Deckard", RegionName.North, ProtectedRegion),
            new Customer("Taffey Lewis", RegionName.North, ProtectedRegion),
            new Customer("Rachael", RegionName.North, ProtectedRegion),
            new Customer("Roy Batty", RegionName.West, ProtectedRegion),
            new Customer("Eldon Tyrell", RegionName.East, ProtectedRegion)
            };</pre></li>
</ol>
<p>This returns a <code>Task</code> enumeration of <code>Customer</code> and is marked as <code>async</code> as you will make further <code>async</code> calls to populate each customer's order details inside the function. Await using <code>Task.Delay</code> to simulate a slow-running operation. Here, a sample list of customers is hardcoded. Create each <code>Customer</code> instance, passing their name, actual region, and the protected region constant, <code>ProtectedRegion</code>.</p>
<ol>
<li value="4">Add an <code>await</code> call to <code>FetchOrders</code> (which will be declared shortly):<pre>            await FetchOrders(customers);</pre></li>
<li>Now, iterate through the list of customers, but be sure to wrap each call to <code>TotalOrders</code> with a <code>try-catch</code> block that explicitly checks for the access violation exception that will be thrown if you attempt to view a protected customer:<pre>            var filteredCustomers = new List&lt;Customer&gt;();
            foreach (var customer in customers)
            {
                try
                {
                    if (customer.TotalOrders &gt; 0)
                        filteredCustomers.Add(customer);
                }
                catch (AccessViolationException e)
                {
                    Logger.Log($"Error {e.Message}");
                }
            }</pre></li>
<li>Now that the <code>filteredCustomers</code> list has been populated with a filtered list of customers, use the Linq <code>OrderByDescending</code> extension method to return the items sorted by each customer's <code>TotalOrders</code> value:<pre>            return filteredCustomers.OrderByDescending(c =&gt; c.TotalOrders);
        } </pre></li>
<li>Finish off <code>CustomerOperations</code> with the <code>FetchOrders</code> implementation.</li>
<li>For each customer in the list, use an <code>async</code> lambda that pauses for <code>500</code> milliseconds before assigning a random value to <code>TotalOrders</code>:<pre>        private async Task FetchOrders(IEnumerable&lt;Customer&gt; customers)
        {
            var rand = new Random();
            Logger.Log("Loading orders...");
            var orderUpdateTasks = customers.Select(
              cust =&gt; Task.Run(async () =&gt;
              {
                    await Task.Delay(500);
                    cust.TotalOrders = rand.Next(1, 100);
               }))
              .ToList();</pre></li>
</ol>
<p>The delay could represent another slow-running service.</p>
<ol>
<li value="9">Wait for <code>orderUpdateTasks</code> to complete using <code>Task.WhenAll</code>:<pre>            await Task.WhenAll(orderUpdateTasks);
        }
    }</pre></li>
<li>Now create a console app to run the operation:<pre>    public class Program
    {
        public static async Task Main()
        {
            var ops = new CustomerOperations();
            var resultTask = ops.FetchTopCustomers();
            var customers = await resultTask;
            foreach (var customer in customers)
            {
                Logger.Log($"{customer.Name} ({customer.Region}): {customer.TotalOrders:N0}");
            }
            Console.ReadLine();
        }
    }
}</pre></li>
<li>On running the console, there are no errors as <code>Roy Batty</code> from the <code>West</code> region was skipped safely:<pre>20:00:15 [05] Loading customers...
20:00:16 [05] Loading orders...
20:00:16 [04] Error Cannot access orders for Roy Batty
20:00:16 [04] Rachael (North): 56
20:00:16 [04] Taffey Lewis (North): 19
20:00:16 [04] Rick Deckard (North): 10
20:00:16 [04] Eldon Tyrell (East): 6</pre></li>
</ol>
<p>In this exercise, you saw how exceptions can be handled gracefully with asynchronous code. You placed a <code>try-catch</code> block at the required location, rather than over-complicating and adding too many unnecessary levels of nested <code>try-catch</code> blocks. When the code was run, an exception was caught that did not crash the application.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/4ozac">https://packt.link/4ozac</a>.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor229"/>The AggregateException Class</h2>
<p>At the beginning of the chapter, you saw that the <code>Task</code> class has an <code>Exception</code> property of type <code>AggregateException</code>. This class contains details about one or more errors that occur during an asynchronous call.</p>
<p><code>AggregateException</code> has various properties, but the main ones are as follows:</p>
<ul>
<li><code>public ReadOnlyCollection&lt;Exception&gt; InnerExceptions { get; }</code>: A collection of exceptions that caused the current exception. A single asynchronous call can result in multiple exceptions being raised and collected here.</li>
<li><code>public AggregateException Flatten()</code>: Flattens all of the <code>AggregateException</code> instances in the <code>InnerExeceptions</code> property into a single new instance. This saves you from having to iterate over <code>AggregateException</code> nested with the exceptions list.</li>
<li><code>public void Handle(Func&lt;Exception, bool&gt; predicate)</code>: Invokes the specified Func handler on every exception in this aggregate exception. This allows the handler to return <code>true</code> or <code>false</code> to indicate whether each exception was handled. Any remaining unhandled exceptions will be thrown for the caller to catch as required.</li>
</ul>
<p>When something goes wrong and this exception is caught by a caller, <code>InnerExceptions</code> contains a list of the exceptions that caused the current exception. These can be from multiple tasks, so each individual exception is added to the resulting task's <code>InnerExceptions</code> collection.</p>
<p>You may often find <code>async</code> code with a <code>try-catch</code> block that catches <code>AggregateException</code> and logs each of <code>InnerExceptions</code> details. In this example, <code>BadTask</code> returns an <code>int</code> based task, but it can be the cause of an exception when run. Perform the following steps to complete this example:</p>
<pre>using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
namespace Chapter05.Examples
{
    class WhenAllErrorExamples
    {+</pre>
<p>It sleeps for <code>1,000</code> milliseconds before throwing the <code>InvalidOperationException</code> in case the number passed in is an even number (using the % operator to see if the number can be divided by <code>2</code> with no remainder):</p>
<pre>        private static async Task&lt;int&gt; BadTask(string info, int n)
        {
            await Task.Delay(1000);
            Logger.Log($"{info} number {n} awake");
            if (n % 2 == 0)
            {
                Logger.Log($"About to throw one {info} number {n}"…");
                throw new InvalidOperationException"($"Oh dear from {info} number "n}");
            }
            return n;
        }</pre>
<p>Add a helper function, <code>CreateBadTasks</code>, that creates a collection of five bad tasks. When started, each of the tasks will eventually throw an exception of type <code>InvalidOperationException</code>:</p>
<pre>        private static IEnumerable&lt;Task&lt;int&gt;&gt; CreateBadTasks(string info)
        {
            return Enumerable.Range(0, 5)
                .Select(i =&gt; BadTask(info, i))
                .ToList();
        }</pre>
<p>Now, create the console app's <code>Main</code> entry point. You pass the results of <code>CreateBadTasks</code> to <code>WhenAll</code>, passing in the string <code>[WhenAll]</code> to make it easier to see what is happening in the output:</p>
<pre>        public static async Task Main()
        {
            var whenAllCompletedTask = Task.WhenAll(CreateBadTasks("[WhenAll]"));</pre>
<p>Before you attempt to await the <code>whenAllCompletedTask</code> task, you need to wrap it in <code>try-catch</code>, which catches the base <code>Exception</code> type (or a more specific one if you are expecting that).</p>
<p>You cannot catch <code>AggregateException</code> here as it's the first exception inside the <code>Task</code> that you receive, but you can still use the <code>Exception</code> property of <code>whenAllCompletedTask</code> to get at the <code>AggregateException</code> itself:</p>
<pre>            try
            {
                await whenAllCompletedTask;
            }
            catch (Exception ex)
            {</pre>
<p>You've caught an exception, so log its type (this will be <code>InvalidOperationException</code> instance that you threw) and the message:</p>
<pre>                Console.WriteLine($"WhenAll Caught {ex.GetType().Name}, Message={ex.Message}");</pre>
<p>Now you can examine <code>whenAllCompletedTask</code>, iterating though this task's <code>AggregateException</code> to see its <code>InnerExceptions</code> list:</p>
<pre>                Console.WriteLine($"WhenAll Task.Status={whenAllCompletedTask.Status}");
               foreach (var ie in whenAllCompletedTask.Exception.InnerExceptions)
               {
                   Console.WriteLine($"WhenAll Caught Inner Exception: {ie.Message}");
               }
            }
            Console.ReadLine();
        }      
    }
}</pre>
<p>Running the code, you'll see five tasks that sleep, and eventually, numbers <code>0</code>, <code>2</code>, and <code>4</code> each throw <code>InvalidOperationException</code>, which you will catch:</p>
<pre>17:30:36 [05] [WhenAll] number 3 awake
17:30:36 [09] [WhenAll] number 1 awake
17:30:36 [07] [WhenAll] number 0 awake
17:30:36 [06] [WhenAll] number 2 awake
17:30:36 [04] [WhenAll] number 4 awake
17:30:36 [06] About to throw one [WhenAll] number 2...
17:30:36 [04] About to throw one [WhenAll] number 4...
17:30:36 [07] About to throw one [WhenAll] number 0...
WhenAll Caught InvalidOperationException, Message=Oh dear from [WhenAll] number 0
WhenAll Task.Status=Faulted
WhenAll Caught Inner Exception: Oh dear from [WhenAll] number 0
WhenAll Caught Inner Exception: Oh dear from [WhenAll] number 2
WhenAll Caught Inner Exception: Oh dear from [WhenAll] number 4</pre>
<p>Notice how <code>number 0</code> appears to be the only error that was caught (<code>(Message=Oh</code> dear from <code>[WhenAll] number 0</code>). However, by logging each entry in the <code>InnerExceptions</code> list, you see all <code>number 0</code> appearing once again.</p>
<p>You can try the same code, but this time use <code>WhenAny</code>. Remember that <code>WhenAny</code> will complete when the first task in the list completes, so notice the complete lack of <strong class="bold">error handling</strong> in this case:</p>
<pre>            var whenAnyCompletedTask = Task.WhenAny(CreateBadTasks("[WhenAny]"));
            var result = await whenAnyCompletedTask;
            Logger.Log($"WhenAny result: {result.Result}");</pre>
<p>Unless you wait for all tasks to complete, you may miss an exception raised by a task when using <code>WhenAny</code>. Running this code results in not a single error being caught and the app does <code>3</code> as that completed first:</p>
<pre>18:08:46 [08] [WhenAny] number 2 awake
18:08:46 [10] [WhenAny] number 0 awake
18:08:46 [10] About to throw one [WhenAny] number 0...
18:08:46 [07] [WhenAny] number 3 awake
18:08:46 [09] [WhenAny] number 1 awake
18:08:46 [07] WhenAny result: 3
18:08:46 [08] About to throw one [WhenAny] number 2...
18:08:46 [06] [WhenAny] number 4 awake
18:08:46 [06] About to throw one [WhenAny] number 4...</pre>
<p>You will finish this look at <code>async</code>/<code>await</code> code by looking at some of the newer options in C# around handling streams of <code>async</code> results. This provides a way to efficiently iterate through the items of a collection without the calling code having to wait for the entire collection to be populated and returned before it can start processing the items in the list.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/SuCXK">https://packt.link/SuCXK</a>.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor230"/>IAsyncEnumerable Streams</h2>
<p>If your application targets .NET 5, .NET6, .NET Core 3.0, .NET Standard 2.1, or any of the later versions, then you can use <code>IAsyncEnumerable</code> streams to create awaitable code that combines the <code>yield</code> keyword into an enumerator to iterate asynchronously through a collection of objects.</p>
<p class="callout-heading">Note</p>
<p class="callout">Microsoft's documentation provides this definition of the <code>yield</code> keyword: When a <code>yield</code> return statement is reached in the iterator method, expression is returned, and the current location in code is retained. Execution is restarted from that location the next time that the iterator function is called.</p>
<p>Using the <code>yield</code> statement, you can create methods that return an enumeration of items to the caller. Additionally, the caller does not need to wait for the <strong class="bold">entire list</strong> of items to be returned before they can start traversing each item in the list. Instead, the caller can access each item as soon as it becomes available.</p>
<p>In this example, you will create a console app that replicates an insurance quoting system. You will make five requests for an insurance quote, once again using <code>Task.Delay</code> to simulate a 1-second delay in receiving each delay.</p>
<p>For the list-based approach, you can only log each quote once all five results have been received back to the <code>Main</code> method. Using <code>IAsyncEnumerable</code> and the <code>yield</code> keyword, the same one second exists between quotes being received, but as soon as each quote is received, the <code>yield</code> statement allows the calling <code>Main</code> method to receive and process the value quoted. This is ideal if you want to start processing items right away or potentially do not want the overhead of having thousands of items in a list for longer than is needed to process them individually:</p>
<pre>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
namespace Chapter05.Examples
{
    class AsyncEnumerableExamplesProgram
    {
        public static async Task Main()
        {</pre>
<p>Start by <code>GetInsuranceQuotesAsTask</code> to return a list of strings and iterate through each, logging the details of each quote. This code will wait for all quotes to be received before logging each item:</p>
<pre>            Logger.Log("Fetching Task quotes...");
            var taskQuotes = await GetInsuranceQuotesAsTask();
            foreach(var quote in taskQuotes)
            {
                Logger.Log($"Received Task: {quote}");
            }</pre>
<p>Now for the <code>async</code> stream version. If you compare the following code to the preceeding code block, you'll see that there are fewer lines of code needed to iterate through the items returned. This code does not wait for all quote items to be received but instead writes out each quote as soon as it is received from <code>GetInsuranceQuotesAsync</code>:</p>
<pre>            Logger.Log("Fetching Stream quotes...");
            await foreach (var quote in GetInsuranceQuotesAsync())
            {
                Logger.Log($"Received Stream: {quote}");
            }
            Logger.Log("All done...");
            Console.ReadLine();
        }</pre>
<p>The <code>GetInsuranceQuotesAsTask</code> method returns a <code>Task</code> of strings. Between each of the five quotes, you wait for one second to simulate a delay, before adding the result to the list and finally returning the entire list back to the caller:</p>
<pre>        private static async Task&lt;IEnumerable&lt;string&gt;&gt; GetInsuranceQuotesAsTask()
        {
            var rand = new Random();
            var quotes = new List&lt;string&gt;();
            for (var i = 0; i &lt; 5; i++)
            {
                await Task.Delay(1000);
                quotes.Add($"Provider{i}'s quote is {rand.Next(5, 10)}");
            }
            return quotes;
        } </pre>
<p>The <code>GetInsuranceQuotesAsync</code> method contains the same delay between each quote, but rather than populating a list to return back to the caller, the <code>yield</code> statement is used to allow the <code>Main</code> method to process each quote item immediately:</p>
<pre>        private static async IAsyncEnumerable&lt;string&gt; GetInsuranceQuotesAsync()
        {
            var rand = new Random();
            for (var i = 0; i &lt; 5; i++)
            {
                await Task.Delay(1000);
                yield return $"Provider{i}'s quote is {rand.Next(5, 10)}";
            }
        }
    }
}</pre>
<p>Running the console app produces the following output:</p>
<pre>09:17:57 [01] Fetching Task quotes...
09:18:02 [04] Received Task: Provider0's quote is 7
09:18:02 [04] Received Task: Provider1's quote is 9
09:18:02 [04] Received Task: Provider2's quote is 9
09:18:02 [04] Received Task: Provider3's quote is 8
09:18:02 [04] Received Task: Provider4's quote is 8
09:18:02 [04] Fetching Stream quotes...
09:18:03 [04] Received Stream: Provider0's quote is 7
09:18:04 [04] Received Stream: Provider1's quote is 8
09:18:05 [05] Received Stream: Provider2's quote is 9
09:18:06 [05] Received Stream: Provider3's quote is 8
09:18:07 [04] Received Stream: Provider4's quote is 7
09:18:07 [04] All done...</pre>
<p>Thread <code>[04]</code> logged all five task-based quote details five seconds after the app started. Here, it waited for all quotes to be returned before logging each quote. However, notice that each of the stream-based quotes was logged as soon as it was yielded by threads <code>4</code> and <code>5</code> with 1 second between them.</p>
<p>The overall time taken for both calls is the same (5 seconds in total), but <code>yield</code> is preferrable when you want to start processing each result as soon as it is ready. This is often useful in UI apps where you can provide early results to the user.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/KarKW">https://packt.link/KarKW</a>.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor231"/>Parallel Programming</h2>
<p>So far, this chapter has covered async programming using the <code>Task</code> class and <code>async</code>/<code>await</code> keywords. You have seen how tasks and <code>async</code> blocks of code can be defined and the flow of a program can be finely controlled as these structures complete.</p>
<p>The Parallel Framework (PFX) offers further ways to utilize multicore processors to efficiently run concurrent operations. The phrase TPL (Task Parallel Library) is generally used to refer to the <code>Parallel</code> class in C#.</p>
<p>Using the Parallel Framework, you do not need to worry about the complexity of creating and reusing threads or coordinating multiple tasks. The framework manages this for you, even adjusting the number of threads that are used, in order to maximize throughput.</p>
<p>For parallel programming to be effective, the order in which each task executes must be irrelevant and all tasks should be independent of each other, as you cannot be certain when one task completes and the next one begins. Coordinating negates any benefits. Parallel programming can be broken down into two distinct concepts:</p>
<ul>
<li>Data parallelism</li>
<li>Task parallelism</li>
</ul>
<h3 id="_idParaDest-206"><a id="_idTextAnchor232"/>Data Parallelism</h3>
<p>Data parallelism is used when you have multiple data values, and the same operation is to be applied concurrently to each of those values. In this scenario, processing each of the values is partitioned across different threads.</p>
<p>A typical example might be calculating the prime numbers from one to 1,000,000. For each number in the range, the same function needs to be applied to determine whether the value is a prime. Rather than iterating through each number one at a time, an asynchronous approach would be to split numbers across multiple threads.</p>
<h3 id="_idParaDest-207"><a id="_idTextAnchor233"/>Task Parallelism</h3>
<p>Conversely, task parallelism is used where a collection of threads all performs a different action, such as calling different functions or sections of code, concurrently. One such example is a program that analyzes the words found in a book, by downloading the book's text and defining separate tasks to do the following:</p>
<ul>
<li>Count the number of words.</li>
<li>Find the longest word.</li>
<li>Calculate the average word length.</li>
<li>Count the number of noise words (the, and, of, for example).</li>
</ul>
<p>Each of these tasks can be run concurrently and they do not depend on each other.</p>
<p>For the <code>Parallel</code> class, the Parallel Framework provides various layers that offer parallelism, including Parallel Language Integrated Query (PLINQ). PLINQ is a collection of extension methods that add the power of parallel programming to the LINQ syntax. The PLINQ won't be covered here in detail, but the <code>Parallel</code> class will be covered in more detail.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you're interested in learning more about PLINQ, you can refer to the online documentation at <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq</a>.</p>
<h3 id="_idParaDest-208"><a id="_idTextAnchor234"/>The Parallel Class</h3>
<p>The <code>Parallel</code> class contains just three <code>static</code> methods but there are numerous overloads providing options to control and influence how actions are performed. Each of the methods <code>Parallel</code> class is often called from within an awaitable block such as <code>Task.Run</code>.</p>
<p>It is worth remembering that the runtime may run the required operations in parallel only if it thinks that is warranted. In the case of individual steps completing sooner than others, the runtime may decide that the overhead of running the remaining operations in parallel is not justified.</p>
<p>Some of the commonly used <code>Parallel</code> method overloads are as follows:</p>
<ul>
<li><code>public static ParallelLoopResult For(int from, int to, Action&lt;int&gt; body)</code>: This data parallelism call executes a loop by invoking the body <code>Action</code> delegate, passing in an <code>int</code> value across the from and to numeric range. It returns <code>ParallelLoopResult</code>, which contains details of the loop once completed.</li>
<li><code>public static ParallelLoopResult For(int from, int to, ParallelOptions options, Action&lt;int, ParallelLoopState&gt; body)</code>: A data parallelism call that executes a loop across the numeric range. <code>ParallelOptions</code> allows loop options to be configured and <code>ParallelLoopState</code> is used to monitor or manipulate the state of the loop as it runs. It returns <code>ParallelLoopResult</code>.</li>
<li><code>public static ParallelLoopResult ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source, Action&lt;TSource, ParallelLoopState&gt; body)</code>: A data parallelism call that invokes the <code>Action</code> body on each item in the <code>IEnumerable</code> source. It returns <code>ParallelLoopResult</code>.</li>
<li><code>public static ParallelLoopResult ForEach&lt;TSource&gt;(Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body)</code>: An advanced data parallelism call that invokes the <code>Action</code> body and allows you to specify <code>Partitioner</code> to provide partitioning strategies optimized for specific data structures to improve performance. It returns <code>ParallelLoopResult</code>.</li>
<li><code>public static void Invoke(params Action[] actions)</code>: A task parallelism call that executes each of the actions passed.</li>
<li><code>public static void Invoke(ParallelOptions parallelOptions, params Action[] actions)</code>: A task parallelism call that executes each of the actions and allows <code>ParallelOptions</code> to be specified to configure method calls.</li>
</ul>
<p>The <code>ParallelOptions</code> class can be used to configure how the <code>Parallel</code> methods operate:</p>
<ul>
<li><code>public CancellationToken CancellationToken { get; set; }</code>: The familiar cancelation token that can be used to detect within loops if cancellation has been requested by a caller.</li>
<li><code>public int MaxDegreeOfParallelism { get; set; }</code>: An advanced setting that determines the maximum number of concurrent tasks that can be enabled at a time.</li>
<li><code>public TaskScheduler? TaskScheduler { get; set; }</code>: An advanced setting that allows a certain type of task queue scheduler to be set.</li>
</ul>
<p><code>ParallelLoopState</code> can be passed into the body of an <code>Action</code> for that action to then determine or monitor flow through the loop. The most commonly used properties are as follows:</p>
<ul>
<li><code>public bool IsExceptional { get; }</code>: Returns <code>true</code> if an iteration has thrown an unhandled exception.</li>
<li><code>public bool IsStopped { get; }</code>: Returns <code>true</code> if an iteration has stopped the loop by calling the <code>Stop</code> method.</li>
<li><code>public void Break()</code>: The <code>Action</code> loop can call this to indicate execution should cease beyond the current iteration.</li>
<li><code>public void Stop()</code>: Requests that the loop should cease execution at the current iteration.</li>
<li><code>ParallelLoopResult</code>, as returned by the <code>For</code> and <code>ForEach</code> methods, contains a completion status for the <code>Parallel</code> loop.</li>
<li><code>public bool IsCompleted { get; }</code>: Indicates that the loop ran to completion and did not receive a request to end before completion.</li>
<li><code>public long? LowestBreakIteration { get; }</code>: If <code>Break</code> is called <code>while</code> the loop runs. This returns the index of the lowest iteration the loop arrived at.</li>
</ul>
<p>Using the <code>Parallel</code> class does not automatically mean that a particular bulk operation will complete any faster. There is an overhead in scheduling tasks, so care should be taken when running tasks that are too short or too long. Sadly, there is no simple metric that determines an optimal figure here. It is often a case of profiling to see if operations do indeed complete faster using the <code>Parallel</code> class.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on data and task parallelism at <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism</a>.</p>
<h3 id="_idParaDest-209"><a id="_idTextAnchor235"/>Parallel.For and Parallel.ForEach</h3>
<p>These two methods offer data parallelism. The same operation is applied to a collection of data objects or numbers. To benefit from these, each operation should be CPU-bound, that is it should require CPU cycles to execute rather than being IO-bound (accessing a file, for example).</p>
<p>With these two methods, you define an <code>Action</code> to be applied, which is passed an object instance or number to work with. In the case of <code>Parallel.ForEach</code>, the <code>Action</code> is passed an object reference parameter. A numeric parameter is passed to <code>Parallel.For</code>.</p>
<p>As you saw in <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, the <code>Action</code> delegate code can be as simple or complex as you need:</p>
<pre>using System;
using System.Threading.Tasks;
using System.Globalization;
using System.Threading;
namespace Chapter05.Examples
{
    class ParallelForExamples
    {
        public static async Task Main()
        {</pre>
<p>In this example, calling <code>Parallel.For</code>, you pass an inclusive <code>int</code> value to start from (<code>99</code>) and an exclusive end value (<code>105</code>). The third argument is a lambda statement, <code>Action</code>, that you want invoked over each iteration. This overload uses <code>Action&lt;int&gt;</code>, passing an integer via the <code>i</code> argument:</p>
<pre>            var loopResult = Parallel.For(99, 105, i =&gt;
            {
                Logger.Log($"Sleep iteration {i}");
                Thread.Sleep(i * 10);
                Logger.Log($"Awake iteration {i}");
            });</pre>
<p>Examine the <code>ParallelLoopResult</code> <code>IsCompleted</code> property:</p>
<pre>            Console.WriteLine($"Completed: {loopResult.IsCompleted}");
            Console.ReadLine();
        }
    }
}</pre>
<p>Running the code, you'll see that it stops at <code>104</code>. Each iteration is executed by a set of different threads and the order appears somewhat random with certain iterations awaking before others. You have used a relatively short delay (using <code>Thread.Sleep</code>) so the parallel task scheduler may take a few additional milliseconds to activate each iteration. This is the reason why the orders in which iterations are executed should be independent of each other:</p>
<pre>18:39:37 [10] Sleep iteration 104
18:39:37 [03] Sleep iteration 100
18:39:37 [06] Sleep iteration 102
18:39:37 [04] Sleep iteration 101
18:39:37 [01] Sleep iteration 99
18:39:37 [07] Sleep iteration 103
18:39:38 [03] Awake iteration 100
18:39:38 [01] Awake iteration 99
18:39:38 [06] Awake iteration 102
18:39:38 [04] Awake iteration 101
18:39:38 [07] Awake iteration 103
18:39:38 [10] Awake iteration 104
Completed: True</pre>
<p>Using the <code>ParallelLoopState</code> override, you can control the iterations from with the <code>Action</code> code. In the following example, the code checks to see if it is at iteration number <code>15</code>:</p>
<pre>            var loopResult1 = Parallel.For(10, 20,               (i, loopState) =&gt;
              {
                Logger.Log($"Inside iteration {i}");
                if (i == 15)
                {
                    Logger.Log($"At {i}…break when you're ready");</pre>
<p>Calling <code>Break</code> on <code>loopState</code> communicates that the <code>Parallel</code> loop should cease further iterations as soon as it can:</p>
<pre>                    loopState.Break();
                }
              });
            Console.WriteLine($"Completed: {loopResult1.IsCompleted}, LowestBreakIteration={loopResult1.L<a id="_idTextAnchor236"/>owestBreakIteration}");
            Console.ReadLine();</pre>
<p>From the results, you can see you got to item <code>17</code> before things actually stopped, despite asking to break at iteration <code>15</code>, as can be seen from the following snippet:</p>
<pre>19:04:48 [03] Inside iteration 11
19:04:48 [03] Inside iteration 13
19:04:48 [03] Inside iteration 15
19:04:48 [03] At 15...break when you're ready
19:04:48 [01] Inside iteration 10
19:04:48 [05] Inside iteration 14
19:04:48 [07] Inside iteration 17
19:04:48 [06] Inside iteration 16
19:04:48 [04] Inside iteration 12
Completed: False, LowestBreakIteration=15</pre>
<p>The code used <code>ParallelLoopState.Break</code>; this indicates the loop <code>17</code> despite requesting a stop at iteration <code>15</code>. This generally occurs when the runtime has already started a subsequent iteration and then detects a <code>Break</code> request just after. These are requests to stop; the runtime may run extra iterations before it can stop.</p>
<p>Alternatively, the <code>ParallelLoopState.Stop</code> method can be used for a more abrupt stop. An alternative <code>Parallel.For</code> overload allows state to be passed into each loop and return a single aggregate value.</p>
<p>To better learn about these overloads, you will calculate the value of <code>pi</code> in the next example. This is an ideal task for <code>Parallel.For</code> as it means repeatedly calculating a value, which is aggregated before being passed to the next iteration. The higher the number of iterations, the more accurate the final number.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on the formula at <a href="https://www.mathscareers.org.uk/article/calculating-pi/">https://www.mathscareers.org.uk/article/calculating-pi/</a>.</p>
<p>You use a loop to prompt the user to enter the number of series (the number of decimal places to be shown) as a multiple of a million (to save typing many zeroes):</p>
<pre>            double series;
            do
            {
                Console.Write("Pi Series (in millions):");
                var input = Console.ReadLine();</pre>
<p>Try to parse the input:</p>
<pre>                if (!double.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out series))
                {
                    break;
                }</pre>
<p>Multiply the entered value by one million and pass it to the awaitable <code>CalcPi</code> function (which will be defined shortly):</p>
<pre>                var actualSeries = series * 1000000;
                Console.WriteLine($"Calculating PI {actualSeries:N0}");
                var pi = await CalcPi((int)(actualSeries));</pre>
<p>You eventually receive the value of <code>pi</code>, so use the string interpolation feature to write <code>pi</code> to <code>18</code> decimal places using the <code>:N18</code> numeric format style:</p>
<pre>                Console.WriteLine($"PI={pi:N18}");
            }</pre>
<p>Repeat the loop until <code>0</code> is entered:</p>
<pre>            while (series != 0D);
            Console.ReadLine();</pre>
<p>Now for the <code>CalcPi</code> function. You know that the <code>Parallel</code> methods all block the calling thread, so you need to use <code>Task.Run</code> which will eventually return the final calculated value.</p>
<p>The concept of thread synchronization will be covered briefly. There is a danger when using multiple threads and shared variables that one thread may read a value from memory and attempt to write a new value at the same time a different thread is trying to do the same operation, with its own value and what it thinks is the correct current value, when it may have read an already out-of-date shared value.</p>
<p>To prevent such issues, a mutual-exclusion lock can be used so that a given thread can execute its statements while it holds a lock and then releases that lock when finished. All other threads are blocked from acquiring the lock and are forced to wait until the lock is released.</p>
<p>This can be achieved using the <code>lock</code> statement. All of the complexities are handled by the runtime when the <code>lock</code> statement is used to achieve thread synchronization. The <code>lock</code> statement has the following form:</p>
<pre>lock (obj){ //your thread safe code here }.</pre>
<p>Conceptually, you can think of the <code>lock</code> statement as a narrow gate that has enough room to allow just one person to pass through at a time. No matter how long a person takes to pass through the gate and what they do while they are there, everyone else must wait to get through the gate until the person with the key has left (releasing the lock).</p>
<p>Returning to the <code>CalcPi</code> function:</p>
<pre>        private static Task&lt;double&gt; CalcPi(int steps)
        {
            return Task.Run(() =&gt;
            {
                const int StartIndex = 0;
                var sum = 0.0D;
                var step = 1.0D / (double)steps;</pre>
<p>The <code>gate</code> variable is of type <code>object</code> and used with the <code>lock</code> statement inside the lambda to protect the <code>sum</code> variable from unsafe access:</p>
<pre>                var gate = new object();</pre>
<p>This is where things get a little more complex, as you use the <code>Parallel.For</code> overload, which additionally allows you to pass in extra parameters and delegates:</p>
<ul>
<li><code>fromInclusive</code>: The start index (<code>0</code> in this case).</li>
<li><code>toExclusive</code>: The end index (steps).</li>
<li><code>localInit</code>: A <code>Func</code> delegate that returns the <strong class="bold">initial state</strong> of data local to each iteration.</li>
<li><code>body</code>: The actual <code>Func</code> delegate that calculates a value of Pi.</li>
<li><code>localFinal</code>: A <code>Func</code> delegate that performs the final action on the local state of each iteration.</li>
</ul>
<pre>                Parallel.For(
                    StartIndex, 
                    steps,
                    () =&gt; 0.0D,                 // localInit 
                    (i, state, localFinal) =&gt;   // body
                    {
                        var x = (i + 0.5D) * step;
                        return localFinal + 4.0D / (1.0D + x * x);
                    },
                    localFinal =&gt;               //localFinally
                    { </pre>
<p>Here, you now use the <code>lock</code> statement to ensure that only one thread at a time can increment the value of <code>sum</code> with its own correct value:</p>
<pre>                        lock (gate)
                            sum += localFinal; 
                    });
                return step * sum;
            });
        }</pre>
<p>By using the <code>lock(obj)</code> statement, you have provided a minimum level of thread safety, and running the program produces the following output:</p>
<pre>Pi Series (in millions):1
Calculating PI 1,000,000
PI=3.141592653589890000
Pi Series (in millions):20
Calculating PI 20,000,000
PI=3.141592653589810000
Pi Series (in millions):30
Calculating PI 30,000,000
PI=3.141592653589750000</pre>
<p><code>Parallel.ForEach</code> follows similar semantics; rather than a range of numbers being passed to the <code>Action</code> delegate, you pass a collection of objects to work with.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/1yZu2">https://packt.link/1yZu2</a>.</p>
<p>The following example shows <code>Parallel.ForEach</code> using <code>ParallelOptions</code> along with a cancelation token. In this example, you have a console app that creates 10 customers. Each customer has a list containing the value of all orders placed. You want to simulate a slow-running service that fetches a customer's order on demand. Whenever any code accesses the <code>Customer.Orders</code> property, the list is populated only once though. Here, you will use another <code>lock</code> statement per customer instance to ensure the list is safely populated.</p>
<p>An <code>Aggregator</code> class will iterate through the list of customers and calculate the total and average order costs using a <code>Parallel.ForEach</code> call. Allow the user to enter a maximum time period that they are prepared to wait for all of the aggregations to complete and then show the top five customers.</p>
<p>Start by creating a <code>Customer</code> class whose constructor is passed a <code>name</code> argument:</p>
<pre>using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
namespace Chapter05.Examples
{
    public class Customer
    {
        public Customer(string name)
        {
            Name = name;
            Logger.Log($"Created {Name}");
        }
        public string Name { get; }</pre>
<p>You want to populate the <code>Orders</code> list on demand and once only per customer, so use another <code>lock</code> example that ensures the list of orders is safely populated once. You simply use the <code>Orders</code> <code>get</code> accessor to check for a null reference on the <code>_orders</code> variable, before creating a random number of order values using the <code>Enumerable.Range</code> LINQ method to generate a range of numbers.</p>
<p>Note, you also simulate a slow request by adding <code>Thread.Sleep</code> to block the thread that is accessing this customer's orders for the first time (as you're using the <code>Parallel</code> class, this will be a background thread rather than the main thread):</p>
<pre>ParallelForEachExample.cs
1            private readonly object _orderGate = new object();
2            private IList&lt;double&gt; _orders;
3            public IList&lt;double&gt; Orders
4            {
5                get
6                {
7                    lock (_orderGate)
8                    {
9                        if (_orders != null)
10                            return _orders;
11
12                        var random = new Random();
13                        var orderCount = random.Next(1000, 10000);
14
You can find the complete code here: <a href="https://packt.link/Nmx3X">https://packt.link/Nmx3X</a>.</pre>
<p>The <code>Total</code> and <code>Average</code> properties that will be calculated by your <code>Aggregator</code> class are as follows:</p>
<pre>        public double? Total { get; set; }
        public double? Average { get; set; }
    }</pre>
<p>Looking at the <code>Aggregator</code> class, note that its <code>Aggregate</code> method is passed a list of customers to work with and <code>CancellationToken</code>, which will automatically raise a cancellation request based on the console user's preferred timespan. The method returns a bool-based <code>Task</code>. The result will indicate whether the operation was canceled partway through processing the customers:</p>
<pre>    public static class Aggregator
    {
        public static Task&lt;bool&gt; Aggregate(IEnumerable&lt;Customer&gt; customers, CancellationToken token)
        {
            var wasCancelled = false;</pre>
<p>The main <code>Parallel.ForEach</code> method is configured by creating a <code>ParallelOptions</code> class, passing in the cancellation token. When invoked by the <code>Parallel</code> class, the <code>Action</code> delegate is passed a <code>Customer</code> instance (<code>customer =&gt;</code>) that simply sums the order values and calculates the average which is assigned to the customer's properties.</p>
<p>Notice how the <code>Parallel.ForEach</code> call is wrapped in a <code>try-catch</code> block that catches any exceptions of type <code>OperationCanceledException</code>. If the maximum time period is exceeded, then the runtime will throw an exception to stop processing. You must catch this; otherwise, the application will crash with an unhandled exception error:</p>
<pre>ParallelForEachExample.cs
1                return Task.Run(() =&gt;
2                {
3                    var options = new ParallelOptions { CancellationToken = token };
4    
5                    try
6                    {
7                        Parallel.ForEach(customers, options,
8                            customer =&gt;
9                            {
10                                customer.Total = customer.Orders.Sum();
11                                customer.Average = customer.Total / 12                                                   customer.Orders.Count;
13                                Logger.Log($"Processed {customer.Name}");
14                            });
15                    }
You can find the complete code here: <a href="https://packt.link/FfVNA">https://packt.link/FfVNA</a>.</pre>
<p>The main console app prompts for a maximum waiting time, <code>maxWait</code>:</p>
<pre>    class ParallelForEachExampleProgram
    {
        public static async Task Main()
        {
            Console.Write("Max waiting time (seconds):");
            var input = Console.ReadLine();
            var maxWait = TimeSpan.FromSeconds(int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var inputSeconds)
                ? inputSeconds
                : 5);</pre>
<p>Create <code>100</code> customers that can be passed to the aggregator:</p>
<pre>            var customers = Enumerable.Range(1, 10)
                .Select(n =&gt; new Customer($"Customer#{n}"))
                .ToList();</pre>
<p>Create <code>CancellationTokenSource</code> instance, passing in the maximum wait time. As you saw earlier, any code that uses this token will be interrupted with a cancellation exception should the time limit be exceeded:</p>
<pre>            var tokenSource = new CancellationTokenSource(maxWait);
            var aggregated = await Task.Run(() =&gt; Aggregator.Aggregate(customers,                                   tokenSource.Token));            </pre>
<p>Once the task completes, you simply take the top five customers ordered by total. The <code>PadRight</code> method is used to align the customer's name in the output:</p>
<pre>            var topCustomers = customers
                .OrderByDescending(c =&gt; c.Total)
                .Take(5);
            Console.WriteLine($"Cancelled: {aggregated }");
            Console.WriteLine("Customer      \tTotal         \tAverage  \tOrders");
           
            foreach (var c in topCustomers)
            {
                Console.WriteLine($"{c.Name.PadRight(10)}\t{c.Total:N0}\t{c.Average:N0}\t\t{c.Orders.Count:N0}");
            }
            Console.ReadLine();
        }
    }
}</pre>
<p>Running the console app with a short time of <code>1</code> second produces this output:</p>
<pre>Max waiting time (seconds):1
21:35:56 [01] Created Customer#1
21:35:56 [01] Created Customer#2
21:35:56 [01] Created Customer#3
21:35:56 [01] Created Customer#4
21:35:56 [01] Created Customer#5
21:35:56 [01] Created Customer#6
21:35:56 [01] Created Customer#7
21:35:56 [01] Created Customer#8
21:35:56 [01] Created Customer#9
21:35:56 [01] Created Customer#10
21:35:59 [07] Processed Customer#5
21:35:59 [04] Processed Customer#3
21:35:59 [10] Processed Customer#7
21:35:59 [06] Processed Customer#2
21:35:59 [05] Processed Customer#1
21:35:59 [11] Processed Customer#8
21:35:59 [08] Processed Customer#6
21:35:59 [09] Processed Customer#4
21:35:59 [05] Caught The operation was canceled.
Cancelled: True
Customer        Total           Average         Orders
Customer#1      23,097,348      2,395           9,645
Customer#4      19,029,182      2,179           8,733
Customer#8      15,322,674      1,958           7,827
Customer#6      9,763,247       1,568           6,226
Customer#2      6,189,978       1,250           4,952</pre>
<p>The operation of creating <code>10</code> customers ran using Thread <code>01</code> as this was intentionally synchronous.</p>
<p class="callout-heading">Note</p>
<p class="callout">Visual Studio may show the following warning the first time you run the program: <code>Non-nullable field '_orders' must contain a non-null value when exiting constructor. Consider declaring the field as nullable.</code> This is a suggestion to check the code for the possibility of a null reference.</p>
<p><code>Aggregator</code> then starts processing each of the customers. Notice how different threads are used and processing does not start with the first customer either. This is the task scheduler deciding which task is next in the queue. You only managed to process eight of the customers before the token raised the cancelation exception.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/1LDxI">https://packt.link/1LDxI</a>.</p>
<p>You have looked at some of the features available in the <code>Parallel</code> class. You can see that it provides a simple yet effective way to run code across multiple tasks or pieces of data.</p>
<p>The phrase <code>Parallel</code> class is an example of this and can be a great utility.</p>
<p>The next section will bring these concurrency concepts into an activity that uses multiple tasks to generate a sequence of images. As each of the images can take a few seconds to create, you will need to offer the user a way to cancel any remaining tasks if the user so chooses.</p>
<h2 id="_idParaDest-210">A<a id="_idTextAnchor237"/>ctivity 5.01: Creating Images from a Fibonacci Sequence</h2>
<p>In <em class="italic">Exercise 5.01</em>, you looked at a recursive function to create a value called a Fibonacci number. These numbers can be joined into what is known as a Fibonacci sequence and used to create interesting spiral-shaped images.</p>
<p>For this activity, you need to create a console application that allows various inputs to be passed to a sequence calculator. Once the user has entered their parameters, the app will start the time-consuming task of creating 1,000 images.</p>
<p>Each image in the sequence may take a few seconds to compute and create so you will need to provide a way to cancel the operation midway using <code>TaskCancellationSource</code>. If the user cancels the task, they should still be able to access the images that were created prior to the cancellation request. Essentially, you are allowing the user to try different parameters to see how this affects output images.</p>
<div><div><img alt="Figure 5.2: Fibonacci sequence image files " height="651" src="img/B16835_05_02.jpg" width="1612"/>
</div>
</div>
<p class="figure-caption">Figure 5.2: Fibonacci sequence image files</p>
<p>This is an ideal example for the <code>Parallel</code> class or <code>async</code>/<code>await</code> tasks if you prefer. The following inputs will be needed from the user:</p>
<ul>
<li>Input the value for <code>phi</code> (values between <code>1.0</code> and <code>6.0</code> provide ideal images).</li>
<li>Input the number of images to create (the suggestion is <code>1,000</code> per cycle).</li>
<li>Input the optional number of points per image (a default of <code>3,000</code> is recommended).</li>
<li>Input the optional image size (defaults to <code>800</code> pixels).</li>
<li>Input the optional point size (defaults to <code>5</code>).</li>
<li>Next input the optional file format (defaults to <code>.png</code> format).</li>
<li>The console app should use a loop that prompts for the preceding parameters and allows the user to enter new criteria while images are created for previous criteria.</li>
<li>If the user presses <code>Enter</code> whilst a previous set of images is still being created, then that task should be canceled.</li>
<li>Pressing <code>x</code> should close the application.</li>
</ul>
<p>As this activity is aimed at testing your asynchronous skills, rather than math or image processing, you have the following classes to help with calculations and image creation:</p>
<ul>
<li>The <code>Fibonacci</code> class defined here calculates <code>X</code> and <code>Y</code> coordinates for successive sequence items. For each image loop, return a list of <code>Fibonacci</code> classes.</li>
<li>Create the first element by calling <code>CreateSeed</code>. The remainder of the list should use <code>CreateNext</code>, passing in the previous item:<pre>FibonacciSequence.cs
1    public class Fibonacci
2    {
3        public static Fibonacci CreateSeed()
4        {
5            return new Fibonacci(1, 0D, 1D);
6        }
7    
8        public static Fibonacci CreateNext(Fibonacci previous, double angle)
9        {
10            return new Fibonacci(previous, angle);
11        }
12    
13        private Fibonacci(int index, double theta, double x)
14        {
15            Index = index;</pre></li>
</ul>
<pre>You can find the complete code here: <a href="http://packt.link/I7C6A">http://packt.link/I7C6A</a>.</pre>
<ul>
<li>Create a list of Fibonacci items using the following <code>FibonacciSequence</code>.<code>Calculate</code> method. This will be passed the number of points to be drawn and the value of <code>phi</code> (both as specified by the user):<pre>FibonacciSequence.cs
1    public static class FibonacciSequence
2    {
3        public static IList&lt;Fibonacci&gt; Calculate(int indices, double phi)
4        {
5            var angle = phi.GoldenAngle();
6    
7            var items = new List&lt;Fibonacci&gt;(indices)
8            {
9                Fibonacci.CreateSeed()
10            };
11            
12            for (var i = 1; i &lt; indices; i++)
13            {
14                var previous = items.ElementAt(i - 1);
15                var next = Fibonacci.CreateNext(previous, angle);</pre></li>
</ul>
<pre>You can find the complete code here: <a href="https://packt.link/gYK4N">https://packt.link/gYK4N</a>.</pre>
<ul>
<li>Export the generated data to <code>.png</code> format image files using the <code>dotnet add package</code> command to add a reference to the <code>System.Drawing.Common</code> namespace. Within your project's source folder, run this command:<pre>source\Chapter05&gt;dotnet add package System.Drawing.Common</pre></li>
<li>This image creation class <code>ImageGenerator</code> can be used to create each of the final image files:<pre>ImageGenerator.cs
1    using System.Collections.Generic;
2    using System.Drawing;
3    using System.Drawing.Drawing2D;
4    using System.Drawing.Imaging;
5    using System.IO;
6    
7    namespace Chapter05.Activities.Activity01
8    {
9        public static class ImageGenerator
10        {
11            public static void ExportSequence(IList&lt;Fibonacci&gt; sequence, 
12                string path, ImageFormat format, 13                int width, int height, double pointSize)
14            {
15                double minX = 0; </pre></li>
</ul>
<pre>You can find the complete code here: <a href="http://packt.link/a8Bu7">http://packt.link/a8Bu7</a>.</pre>
<p>To complete this activity, perform the following steps:</p>
<ol>
<li value="1">Create a new console app project.</li>
<li>The generated images should be saved in a folder within the system's <code>Temp</code> folder, so use <code>Path.GetTempPath()</code> to get the <code>Temp</code> path and create a subfolder called <code>Fibonacci</code> using <code>Directory.CreateDirectory</code>.</li>
<li>Declare a <code>do</code>-loop that repeats the following <em class="italic">Step 4</em> to <em class="italic">Step 7</em>.</li>
<li>Prompt the user to enter a value for <code>phi</code> (this typically ranges from <code>1.0</code> to <code>6.00</code>). You will need to read the user's input as a string and use <code>double.TryParse</code> to attempt to convert their input into a valid double variable.</li>
<li>Next, prompt the user to enter a value for the number of image files to create (<code>1,000</code> is an acceptable example value). Store the parsed input in an <code>int</code> variable called <code>imageCount</code>.</li>
<li>If either of the entered values is empty, this will indicate that the user pressed the <code>Enter</code> key alone, so break out of the <code>do</code>-loop. Ideally, <code>CancellationTokenSource</code> can also be defined and used to cancel any pending calculations.</li>
<li>The value of <code>phi</code> and <code>imageCount</code> should be passed to a new method called <code>GenerateImageSequences</code>, which returns a <code>Task</code>.</li>
<li>The <code>GenerateImageSequences</code> method needs to use a loop that iterates for each of the image counts requested. Each iteration should increment <code>phi</code>, and a constant value (a suggestion is <code>0.015</code>) before awaiting a <code>Task.Run</code> method that calls <code>FibonacciSequence.Calculate</code>, passing in <code>phi</code> and a constant for the number of points (<code>3,000</code> provides an acceptable example value). This will return a list of Fibonacci items.</li>
<li><code>GenerateImageSequences</code> should then pass the generated Fibonacci list to the image creator <code>ImageGenerator.ExportSequence</code>, awaiting using a <code>Task.Run</code> call. An image size of <code>800</code> and a point size of <code>5</code> are recommended constants for the call to <code>ExportSequence</code>.</li>
<li>Running the console app should produce the following console output:<pre>Using temp folder: C:Temp\Fibonacci\
Phi (eg 1.0 to 6.0) (x=quit, enter=cancel):1
Image Count (eg 1000):1000
Creating 1000 images...
20:36:19 [04] Saved Fibonacci_3000_1.015.png
20:36:19 [06] Saved Fibonacci_3000_1.030.png
20:36:20 [06] Saved Fibonacci_3000_1.090.png</pre></li>
</ol>
<p>You will find that various image files have been generated in the Fibonacci folder in the system's <code>Temp</code> folder:</p>
<div><div></div>
</div>
<div><div><img alt="Figure 5.3: Windows 10 Explorer image folder contents (a subset of images produced) " height="758" src="img/B16835_05_03.jpg" width="1442"/>
</div>
</div>
<p class="figure-caption">Figure 5.3: Windows 10 Explorer image folder contents (a subset of images produced)</p>
<p>By completing this activity, you have seen how multiple long-running operations can be started and then coordinated to produce a single result, with each step running in isolation, allowing other operations to continue as necessary.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor238"/>Summary</h1>
<p>In this chapter, you considered some of the power and flexibility that concurrency provides. You started by passing target actions to tasks that you created and then looked at the static <code>Task</code> factory helper methods. By using continuation tasks, you saw that single tasks and collections of tasks can be coordinated to perform aggregate actions.</p>
<p>Next, you studied the <code>async</code>/<code>await</code> keywords that can help you write simpler and more concise code that is, hopefully, easier to maintain.</p>
<p>This chapter looked at how C# provides, with relative ease, concurrency patterns that make it possible to leverage the power of multicore processors. This is great for offloading time-consuming calculations, but it does come at a price. You saw how the <code>lock</code> statement can be used to safely prevent multiple threads from reading or writing to a value simultaneously.</p>
<p>In the next chapter, you will look at how Entity Framework and SQL Server can be used to interact with relational data in C# applications. This chapter is about working with databases. If you are unfamiliar with database structure or would like a refresher on the basics of PostgreSQL, please refer to the bonus chapter available in the GitHub repository for this book.</p>
</div>
<div><div></div>
</div>
</div>
</body></html>