- en: What Next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have discovered the MVVM architectural pattern and explored
    the process of developing a WPF application, while taking advantage of the pattern's
    **Separation of Concerns** and adhering to its principles. We investigated a number
    of different ways of communicating between the various application layers and
    structuring our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, we considered a variety of ways of debugging our WPF applications
    and tracking down our coding problems. In particular, we revealed some tips and
    tricks to help us to identify the causes of our data binding errors. In addition,
    we also learned how viewing trace information can help us to detect problems,
    even after our applications have been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to investigate the benefit of utilizing an application framework
    and began designing and developing our own. We structured it in a way that did
    not tie our framework to any particular feature or technology and experimented
    with a variety of ways to encapsulate our required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We devoted a whole chapter to the essential art of data binding and took a detailed
    look at the creation of Dependency Properties and Attached Properties. We looked
    at setting Dependency Property metadata and were introduced to the crucial Dependency
    Property Setting Precedence List. We then covered both standard and hierarchical
    data templates and studied some interesting data binding examples.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating the rich inheritance hierarchy of the built-in WPF controls enabled
    us to see how their functionality is built up from each successive base class
    in the hierarchy. This, in turn, enabled us to see that some controls are better
    to use in some situations than others. We also found out how to customize the
    built-in controls and considered how best to make our own controls.
  prefs: []
  type: TYPE_NORMAL
- en: While the animation possibilities in a WPF application are practically endless,
    we investigated the more usable options, primarily focusing on the syntax used
    in XAML. We then added animation functionality directly into our application framework,
    where it could be used with little effort on the part of developers.
  prefs: []
  type: TYPE_NORMAL
- en: After turning our attention to the look of our applications, we investigated
    a number of techniques, such as borderless windows and adding shadows and glowing
    effects to more advanced methods to make our application stand out from the crowd.
    We also incorporated animations into our everyday controls, in order to bring
    about a sense of exclusivity to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We thoroughly investigated the data validation options that the .NET Framework
    offers us, primarily concentrating on the two available validation interfaces,
    and exploring a number of different ways of implementing them. We probed advanced
    techniques, such as multilevel validation and using data annotation attributes,
    and then added a complete validation system into our application framework.
  prefs: []
  type: TYPE_NORMAL
- en: We further extended our application framework with an asynchronous data operation
    system that was combined with a complete user feedback component, including an
    animated feedback display mechanism. We continued by investigating how we can
    provide in-application help and user preferences and implement work-heavy functions
    to save users time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored a number of options that we can use to increase the performance
    of our WPF applications, from declaring our resources more efficiently to using
    lighter weight controls and more efficient methods of rendering drawings, images,
    and text. We saw more performant methods of data binding and discovered the importance
    of detaching event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we investigated the last task in any professional application's development,
    its deployment. We looked at a number of alternative methods but primarily focused
    on the most popular ClickOnce technology. We investigated how ClickOnce deployments
    are done and how we can safely store and access data in isolated storage. We ended
    with a number of ways to access the various application versions available to
    us in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we've covered a plethora of information that, together, will enable
    us to create efficient, visually appealing, highly usable, and highly productive
    applications in WPF. What's more, we've now got our own application framework
    that we can reuse for each new application that we create. *So, what's next?*
  prefs: []
  type: TYPE_NORMAL
- en: Turning your attention to future projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could apply the concepts and ideas from this book to other areas and continue
    to experiment and explore their effect in these new areas. For example, we've
    learned about `Adorner` objects, so you could use that new-found knowledge to
    implement some visual feedback for the common drag and drop functionality in the
    main window's adorner layer.
  prefs: []
  type: TYPE_NORMAL
- en: You could then further extend this idea, using what you've discovered about
    Attached Properties, and completely encapsulate this drag and drop functionality,
    enabling the developers that utilize your application framework to make use of
    this feature in a property-based manner.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could create a `DragDropProperties` class that declared Attached
    Properties, such as `IsDragSource`, `IsDragTarget`, `DragEffects`, `DragDropType`,
    and `DropCommand`, and it could be extended by your relevant Attached Property
    classes, such as a `ListBoxProperties` class.
  prefs: []
  type: TYPE_NORMAL
- en: You could then declare a `BaseDragDropManager` class to be used in the `DragDropProperties`
    class, that stitches everything together, by attaching and removing the appropriate
    event handlers, starting the drag and drop procedure, updating the cursor via
    the drag and drop effects as it moves across the screen, and executing the `ICommand`
    object assigned to the `DropCommand` Property.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to a further area that could be extended. Not only can we handle
    UI events in Attached Properties, but we can also combine them to perform more
    complex functionality. For example, let's say that we have an Attached Property
    of type `string`, named `Label`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this property is set, it could apply a particular `ControlTemplate` element
    from resources to the current `TextBox` object''s `Template` property. This template
    could display the text from this property in a secondary text element and therefore
    act as an internal label. When the `TextBox` object has a value, the label text
    element could be hidden via an `IValueConverter` implementation that extends our
    `BaseVisibilityConverter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we could then declare another Attached Property,
    named `LabelColor`, of type `Brush`, which specifies the color to be used by the
    `Label` Attached Property when it is set. Note that if the `LabelColor` property
    is not set, then it will either use its default value if it is set, or the value
    specified in the `FallbackValue` property.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our application framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another area that you can continue to work on is customizing our application
    framework further and adapting it to your individual requirements. With this in
    mind, you could continue to build up a complete collection of customized controls
    with a particular look and feel in an external resource file to use in all of
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many other examples provided throughout this book that could
    be easily extended. For example, you could update our `DependencyManager` class
    to enable multiple concrete classes to be registered for each interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a `Dictionary<Type, Type>` object to store our registrations,
    you could define new custom objects. You could declare a `ConcreteImplementation`
    struct that has a `Type` property and an `object` array to hold any constructor
    input parameters that may be required for its initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then declare a `DependencyRegistration` class that you could use
    to pair the interface type with the collection of concrete implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our `DependencyManager` class, you could change the type of the `registeredDependencies`
    field to a collection of this new `DependencyRegistration` type. The current `Register`
    and `Resolve` methods could then also be updated to use this new collection type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could include other common functionality that is contained
    within popular Dependency Injection and Inversion of Control containers, such
    as the automatic registering of concrete classes to interfaces at the assembly
    level. For this, you could use some basic reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method first accesses the assembly that contains the generic type parameter
    and then gets a collection of the interfaces in that assembly. It then iterates
    through the interface collection and finds a collection of classes that implements
    each interface, instantiating a `ConcreteImplementation` element with each. Each
    match is added into the `registeredDependencies` collection with its relating
    interface type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, you could pass any interface type from our `Models`, `Managers`,
    and `ViewModels` projects to automatically register all of the interfaces and
    concrete classes found inside their assemblies. There is a clear benefit to doing
    this in larger applications, as it will mean that you don''t have to manually
    register each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you could declare another method that registers all types found
    in the assembly of the type specified by the generic type parameter `T`, where
    matches of implemented interfaces are found. This could be used during testing,
    so that you could just pass any type from the mock projects during testing, again
    saving time and effort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As with all serious development projects, there is a need to test the code that
    makes up the code base. Doing so obviously helps to reduce the number of bugs
    in the application, but also alerts us when existing functionality has been broken,
    while adding new code. They also provide a safety net for refactoring, allowing
    us to continually improve our designs, while ensuring that existing functionality
    is not broken.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, one area that you could improve in the application would be to implement
    a full test suite. This book has explained a number of ways for us to swap out
    code during testing and this pattern can be easily extended. If a manager class
    uses some sort of resource that cannot be used during testing, then you can create
    an interface for it, add a mock class, and use the `DependencyManager` class to
    instantiate the relevant concrete implementation during runtime and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Another area from the book that could be extended relates to our `AnimatedStackPanel`
    class. You could extract the reusable properties and animation code from this
    class to an `AnimatedPanel` base class so that it could service several different
    types of animated panels.
  prefs: []
  type: TYPE_NORMAL
- en: As suggested in [Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml), *Mastering
    Practical Animations*, you could then further extend the base class by exposing
    additional animation properties so that users of your panel could have more control
    over the animations that it provides. For example, you could add alignment, direction,
    duration, and/or animation type properties to enable users of your framework to
    use a wide variety of animation options.
  prefs: []
  type: TYPE_NORMAL
- en: These properties could be divided between the entry and exit animations, to
    enable independent control over them. By providing a wide variety of these additional
    properties in a base class, you can vastly simplify the process of adding new
    animated panels.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could add a new `AnimatedWrapPanel`, or perhaps an `AnimatedColumnPanel`,
    by simply extending the base class, and only have to implement the two `MeasureOverride`
    and `ArrangeOverride` methods in the new panel.
  prefs: []
  type: TYPE_NORMAL
- en: Logging errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a number of places in the code examples in this book, you may have seen `Log
    error` comments. In general, it is not only good practice to log errors, but it
    can also help you to track down bugs and improve the overall user experience of
    the users of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest place to log errors to would be an `Errors` database and the minimum
    useful information fields that you''d want to store would include details of the
    current user, the time the error occurred, the exception message, the stack trace,
    and the assembly or area that it occurred in. This latter field can be found in
    the `Module` property of the exception''s `TargetSite` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the custom `FlattenInnerExceptions` method that also outputs
    the messages from any inner exceptions that the thrown exception may contain.
    One alternative to building your own `FlattenInnerExceptions` method would be
    to simply save the `ToString` output of the exception, which will also contain
    details of any inner exceptions that it may contain, although it will also contain
    stack trace and other information as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using online resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a final note, if you are not already familiar with the **Microsoft Docs**
    website, you really should acquaint yourself with it. It is maintained for the
    Microsoft developer community and includes everything from detailed APIs for their
    various languages, tutorial walkthroughs, and code examples, through to downloads
    of their software.
  prefs: []
  type: TYPE_NORMAL
- en: It can be found at [https://docs.microsoft.com](https://docs.microsoft.com) and
    should be the first place you look when questions arise over the members of the
    various classes in .NET. Should you not find your required information in their
    APIs, then you can ask questions in their forums and quickly receive answers from
    both the community and from Microsoft employees.
  prefs: []
  type: TYPE_NORMAL
- en: Another great developer resource is the **Stack Overflow** question and answer
    site for development professionals, where I still answer questions when I can
    find the time. It can be found online at [http://stackoverflow.com/](http://stackoverflow.com/)
    and with answers often provided by the community within seconds, it really is
    hard to beat and is one of the best development forums around.
  prefs: []
  type: TYPE_NORMAL
- en: For further tutorials, check out the WPF Tutorial.net website at [https://www.wpftutorial.net/](https://www.wpftutorial.net/),
    where you can find a wealth of tutorials, from basic to complex. And for interesting
    and novel downloadable custom controls and additional tutorials, try visiting
    the WPF section of the Code Project website at [https://www.codeproject.com/kb/wpf/](https://www.codeproject.com/kb/wpf/).
  prefs: []
  type: TYPE_NORMAL
- en: All that remains now is for me to wish you well with your future application
    development and your blossoming development careers.
  prefs: []
  type: TYPE_NORMAL
