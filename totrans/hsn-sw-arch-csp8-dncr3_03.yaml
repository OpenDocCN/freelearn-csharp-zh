- en: Functional and Nonfunctional Requirements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性需求和非功能性需求
- en: Once you have gathered the system requirements, it is time to think about the
    impact they have on the architectural design. Scalability, performance, multithreading,
    interoperability, and other subjects need to be analyzed so that we can meet user
    needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您收集了系统需求，就需要考虑它们对架构设计的影响。可伸缩性、性能、多线程、互操作性以及其他主题都需要进行分析，以便我们能够满足用户需求。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is scalability and how does it interact with Azure and .NET Core?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是可伸缩性以及它与Azure和.NET Core如何交互？
- en: Good tips for writing better code when it comes to performance improvement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能改进方面，以下是一些编写更好代码的好建议
- en: Creating a safe and useful multithreading software
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个安全且有用的多线程软件
- en: Software usability, that is, how to design effective user interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件可用性，即如何设计有效的用户界面
- en: .NET Core and interoperability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core和互操作性
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The samples provided in this chapter will require Visual Studio 2019 Community
    Edition or Visual Studio Code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的示例将需要Visual Studio 2019 Community Edition或Visual Studio Code。
- en: You can find the sample code for this chapter here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的示例代码：[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02)。
- en: How does scalability interact with Azure and .NET Core?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可伸缩性如何与Azure和.NET Core交互？
- en: A short search on scalability returns a definition such as *the ability of a
    system to keep working well when there's an increase in demand*. Once developers
    read this, many of them incorrectly conclude *that scalability only means add
    more hardware to keep things working without stopping the app*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对可伸缩性进行简短搜索会返回如下定义：*系统在需求增加时仍能良好工作的能力*。一旦开发者阅读了这一点，许多人会错误地得出结论，*可伸缩性仅仅意味着添加更多硬件以保持事物运行而不停止应用程序*。
- en: Scalability relies on technologies involving hardware solutions. However, as
    a software architect, you have to be aware that good software will keep scalability
    in a sustainable model, which means that a well-architected software can save
    a lot of money. Hence, it is not just a matter of hardware but also a matter of
    overall software design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性依赖于涉及硬件解决方案的技术。然而，作为一名软件架构师，您必须意识到，优秀的软件将保持可伸缩性在一个可持续的模式中，这意味着一个良好架构的软件可以节省很多钱。因此，这不仅仅是硬件的问题，也是整体软件设计的问题。
- en: In [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the
    Importance of Software Architecture*, while discussing software performance, we
    proposed some good tips to overcome bad performance issues. The same tips will
    help you with scalability too. The fewer resources we spend on each process, the
    more users the application can handle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)“理解软件架构的重要性”中，当我们讨论软件性能时，我们提出了一些克服不良性能问题的好建议。同样的建议也会帮助您处理可伸缩性。我们投入每个过程中的资源越少，应用程序可以处理的用户就越多。
- en: It is worth knowing that Azure and .NET Core web apps can be configured to handle
    scalability too. Let's check this out in the following subsections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Azure和.NET Core Web应用可以被配置为处理可伸缩性。让我们在以下小节中查看。
- en: Creating a scalable web app in Azure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure中创建可伸缩的Web应用
- en: 'It is pretty simple to create a web app in Azure, ready for scaling. The reason
    why you have to do so is to be able to maintain different amounts of users during
    different seasons. The more users you have, the more hardware you will need. The
    following steps will show you how to create a scalable web application in Azure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中创建一个可伸缩的Web应用非常简单，为扩展做好准备。您之所以必须这样做，是为了能够在不同季节维护不同数量的用户。用户越多，您需要的硬件就越多。以下步骤将向您展示如何在Azure中创建一个可伸缩的Web应用程序：
- en: 'As soon as you log in to your Azure account, you will be able to create a new
    resource (web app, database, virtual machine, and so on), as you can see in the
    following screenshot:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您登录到您的Azure账户，您就可以创建新的资源（Web应用、数据库、虚拟机等），如下面的截图所示：
- en: '![](img/6e9d04d4-4cde-4373-b4c3-e37a870c504b.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e9d04d4-4cde-4373-b4c3-e37a870c504b.png)'
- en: 'After that, you can select Web App. This tutorial will take you to the following
    screen:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以选择Web应用。本教程将带您进入以下屏幕：
- en: '![](img/6c7100ab-983a-439c-8de1-31190c059b43.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c7100ab-983a-439c-8de1-31190c059b43.png)'
- en: 'The required details are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的详细信息如下：
- en: 'App name: As you can see, this is the URL that your web app will assume after
    its creation. The name is checked to ensure it is available.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用名称：如您所见，这是您的网络应用创建后所假设的URL。该名称经过检查以确保其可用性。
- en: 'Subscription: This is the account that will be charged for all application
    costs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅：这是将收取所有应用费用的账户。
- en: 'Resource Group: This is the collection of resources you can define to organize
    policies and permissions. You may specify a new resource group name or add the
    web app to a group specified during the definition of other resources.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组：这是您可以定义以组织策略和权限的资源集合。您可以指定新的资源组名称或将网络应用添加到在定义其他资源时指定的组中。
- en: 'OS: This is the operating system that will host the web app. Both Windows and
    Linux may be used for ASP.NET Core projects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：这是将托管网络应用的操作系统的名称。对于ASP.NET Core项目，可以使用Windows和Linux。
- en: 'Publish: This parameter indicates whether the web app will be delivered directly
    or whether it is going to use Docker technology to publish content. Docker will
    be discussed in more detail in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application.*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布：此参数指示网络应用是直接交付还是将使用Docker技术发布内容。Docker将在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，*将微服务架构应用于您的企业应用*中更详细地讨论。
- en: 'App Service Plan/Location: This is where you define the hardware plan that''s
    used to handle the web app and the location of the servers. This choice defines
    application scalability, performance, and costs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务计划/位置：这是您定义用于处理网络应用和服务器位置的硬件计划的地方。此选择定义了应用程序的可扩展性、性能和成本。
- en: 'Application Insights: This is a useful Azure toolset for monitoring and troubleshooting
    web apps.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用洞察：这是用于监控和故障排除网络应用的Azure实用工具集。
- en: 'Applications may be scaled in two conceptually different ways:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用可以从两种概念上不同的方式扩展：
- en: Vertically (Scale up)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纵向（扩展）
- en: Horizontally (Scale out)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横向（扩展）
- en: 'Both of them are available in the web app settings, as you can see in the following
    screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都可在网络应用设置中找到，如下截图所示：
- en: '![](img/0626f955-69b8-4ade-9e81-3683d9ed56d7.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0626f955-69b8-4ade-9e81-3683d9ed56d7.png)'
- en: Let's checkout the two types of scaling.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两种扩展类型。
- en: Vertical scaling (Scale up)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直扩展（扩展）
- en: Scale up means changing the type of hardware that will sustain your application.
    In Azure, you have the opportunity of starting with free-shared hardware and moving
    to an isolated machine in a few clicks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展意味着更改将支持您的应用程序的硬件类型。在Azure中，您有机会从免费共享硬件开始，并在几个点击中切换到隔离的机器。
- en: 'By selecting this option, you have the opportunity to select more powerful
    hardware (machines with more CPUs, storage, and RAM). The following screenshot
    shows the user interface for scaling up a web app:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项，您有机会选择更强大的硬件（具有更多CPU、存储和RAM的机器）。以下截图显示了扩展网络应用的用户界面：
- en: '![](img/1ccf3faa-5d47-4f59-97a7-25e7b14cc979.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1ccf3faa-5d47-4f59-97a7-25e7b14cc979.png)'
- en: Horizontal scaling (Scale out)
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横向扩展（扩展）
- en: 'Scaling out means splitting all requests among more servers with the same capacity
    instead of using more powerful machines. The load on all the servers is automatically
    balanced by the Azure infrastructure. This solution is advised when the overall
    load may change considerably in the future since horizontal scaling can be automatically
    adapted to the current load. The following screenshot shows an automatic Scale
    out strategy defined by two simple rules, which is triggered by CPU usage:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展意味着将所有请求分配给具有相同容量的更多服务器，而不是使用更强大的机器。所有服务器的负载将由Azure基础设施自动平衡。以下截图显示了一个由两个简单规则定义的自动扩展策略，该策略由CPU使用情况触发：
- en: '![](img/084e5d5c-ef10-4dfd-8ddc-3bcb321f683d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/084e5d5c-ef10-4dfd-8ddc-3bcb321f683d.png)'
- en: A complete description of all the available auto scale rules is beyond the purpose
    of this book. However, they are quite self-explanatory and the *Further reading*
    section contains links to the full documentation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有可用自动扩展规则的完整描述超出了本书的范围。然而，它们相当直观，*进一步阅读*部分包含指向完整文档的链接。
- en: The Scale out feature is only available in paid service plans.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展功能仅在付费服务计划中可用。
- en: Creating a scalable web app with .NET Core
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET Core创建可扩展的网络应用
- en: Among all the available frameworks for implementing web apps, ASP.NET Core ensures
    good performance, together with low production and maintenance costs. ASP.NET
    Core performance is comparable with the performance of Node.js, but production
    and maintenance costs are lower because of the usage of C# (which is a strongly typed
    and advanced pure object language) instead of JavaScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用于实现 Web 应用的框架中，ASP.NET Core 确保了良好的性能，同时生产和维护成本较低。ASP.NET Core 的性能与 Node.js
    的性能相当，但由于使用了 C#（这是一种强类型和高级纯对象语言）而不是 JavaScript，因此生产和维护成本较低。
- en: The steps that follow will guide you through the creation of an ASP.NET Core-based web
    app. All the steps are quite simple, but some details require particular attention.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您通过创建基于 ASP.NET Core 的 Web 应用。所有步骤都非常简单，但一些细节需要特别注意。
- en: First of all, during the web app's creation, you can choose between .NET Core
    Framework and .NET Framework. Pay attention, because only .NET Core can run on
    both Windows and cheaper Linux servers, while classic .NET runs only on Windows
    servers. On the other hand, with classic .NET, you will have access to a larger
    code base of legacy libraries that include both Microsoft and third-party packages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在创建 Web 应用时，您可以在 .NET Core 框架和 .NET 框架之间进行选择。请注意，只有 .NET Core 可以在 Windows
    和更便宜的 Linux 服务器上运行，而经典 .NET 只能在 Windows 服务器上运行。另一方面，使用经典 .NET，您将能够访问更大的代码库，包括
    Microsoft 和第三方包的遗留库。
- en: 'Nowadays, Microsoft recommends classic .NET, just in case the features you
    need are not available in .NET Core, or even when you deploy your web app in an
    environment that does not support .NET Core. In any other case, you should prefer
    .NET Core Framework because it allows you to do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Microsoft 推荐使用经典 .NET，以防所需的特性在 .NET Core 中不可用，或者当您在不支持 .NET Core 的环境中部署 Web
    应用时。在其他任何情况下，您都应该优先选择 .NET Core 框架，因为它允许您做以下事情：
- en: Run your web app in Windows, Linux, or Docker containers
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows、Linux 或 Docker 容器中运行您的 Web 应用
- en: Design your solution with microservices
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微服务设计您的解决方案
- en: Have high performance and scalable systems
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有高性能和可扩展的系统
- en: Containers and microservices will be covered in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*. There,
    you'll get a better understanding of the advantages of these technologies. For
    now, it is enough to say that .NET Core and microservices were designed for performance
    and scalability, which is why you should prefer .NET Core in all of your new projects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和微服务将在第 5 章[应用微服务架构到您的企业应用](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中介绍。在那里，您将更好地了解这些技术的优势。目前，只需说
    .NET Core 和微服务是为了性能和可扩展性而设计的，这就是为什么您应该在所有新项目中优先选择 .NET Core。
- en: 'The following steps will show you how to create an ASP.NET Core web app in
    Visual Studio 2019 with .NET Core 3.0:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何在 Visual Studio 2019 中使用 .NET Core 3.0 创建 ASP.NET Core Web 应用：
- en: 'Once you select ASP.NET Core Web Application, you will be directed to a screen
    where you will be asked to set up the Project name, Location, and Solution name:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您选择了 ASP.NET Core Web 应用，您将被引导到一个屏幕，您将需要设置项目名称、位置和解决方案名称：
- en: '![](img/5b160782-ca4c-48e7-a573-3e0e35990dc8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b160782-ca4c-48e7-a573-3e0e35990dc8.png)'
- en: After that, you will be able to select the .NET Core version to use. At the
    time of writing, .NET Core 3.0 was still in its Preview 1 version.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您将能够选择要使用的 .NET Core 版本。在撰写本文时，.NET Core 3.0 仍处于 Preview 1 版本。
- en: Now that we are done with adding the basic details, you can connect your web
    app project to your Azure account and have it published.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了基本详情，您可以将您的 Web 应用项目连接到您的 Azure 账户，并发布它。
- en: 'In the Solution Explorer, you have the option to Publish... if you right-click anywhere
    in there:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，如果您在任意位置右键单击，您将有一个“发布...”的选项：
- en: '![](img/5c431af5-0c1b-421d-b84d-e1e86330d050.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c431af5-0c1b-421d-b84d-e1e86330d050.png)'
- en: 'After you select the Publish... menu item, you will be able to connect your
    Azure account and then select the web app you wish to deploy:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择“发布...”菜单项后，您将能够连接到您的 Azure 账户，然后选择您希望部署的 Web 应用：
- en: '![](img/41b66c52-c29c-46a2-807a-70b29620b0c2.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41b66c52-c29c-46a2-807a-70b29620b0c2.png)'
- en: 'There is full integration between Visual Studio and Azure. This gives you the
    opportunity to view all the resources you created in the Azure Portal in your
    development environment:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 与 Azure 完全集成。这使您有机会在开发环境中查看在 Azure Portal 中创建的所有资源：
- en: '![](img/f0e01e35-c1eb-4516-92dd-cc68034c3637.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0e01e35-c1eb-4516-92dd-cc68034c3637.png)'
- en: 'Once you''ve decided on your publish settings, that is, your publish profile,
    the web app is automatically published when you click OK:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您确定了发布设置，即您的发布配置文件，当您点击“确定”时，Web应用将自动发布。
- en: '![](img/443b5d84-b2dd-466e-8e6c-65758d394f94.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/443b5d84-b2dd-466e-8e6c-65758d394f94.png)'
- en: 'For publishing .NET Core Preview versions, you have to add an extension in
    the web app setup panel in Azure portal, as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发布.NET Core预览版本，您必须在Azure门户的Web应用设置面板中添加一个扩展，如图所示：
- en: '![](img/b5f79141-0422-4dee-9836-1fb169a2ad0c.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5f79141-0422-4dee-9836-1fb169a2ad0c.png)'
- en: For more information on deploying ASP.NET Core 3.0 to Azure App Service, please
    take a look at this link: [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将ASP.NET Core 3.0部署到Azure App Service的更多信息，请参阅此链接：[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service)。
- en: Here, we described the simplest ways to deploy a web app. [Chapter 17](b444cf5c-311d-4f74-80b0-0e86c0c13307.xhtml),
    *Deploying Your Application with Azure DevOps,* will introduce you to the Azure
    DevOps **Continuous Integration/Continuous Delivery** (**CI/CD**) pipeline. This
    pipeline is a further Azure toolset that automates all the required steps to get
    the application in production, that is, build, testing, deployment in staging,
    and deployment in production.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们描述了部署Web应用的最简单方法。[第17章](b444cf5c-311d-4f74-80b0-0e86c0c13307.xhtml)，*使用Azure
    DevOps部署您的应用程序*，将向您介绍Azure DevOps **持续集成/持续交付**（**CI/CD**）管道。这个管道是Azure工具集的进一步扩展，它自动化了将应用程序部署到生产环境所需的所有步骤，即构建、测试、预部署和部署到生产。
- en: Performance issues that need to be considered when programming in C#
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在用C#编程时需要考虑的性能问题
- en: Nowadays, C# is one of the most used programming languages all over the world,
    so good tips about C# programming are fundamental for the design of good architectures
    that satisfy the most common non-functional requirements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，C#是全球最广泛使用的编程语言之一，因此关于C#编程的好建议对于设计满足最常见非功能性要求的好架构是基本的。
- en: The following sections mention a few simple but efficacious tips—the associated
    code samples are available in the GitHub repository of this book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节提到了一些简单但有效的技巧——相关的代码示例可在本书的GitHub仓库中找到。
- en: String concatenation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串连接
- en: This is a classic one! A naive concatenation of strings with the `+` string
    operator may cause serious performance issues since each time two strings are
    concatenated, their contents are copied into a new string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典案例！使用`+`字符串运算符进行字符串的简单连接可能会导致严重的性能问题，因为每次连接两个字符串时，它们的内容都会被复制到一个新的字符串中。
- en: So, if we concatenate, say, 10 strings that have an average length of 100, the
    first operation has a cost of 200, the second one has a cost of *200+100=300*,
    the third one has a cost of 300+100= 400, and so on. It is not difficult to convince
    yourself that the overall cost grows like *m*n2*, where *n* is the number of strings
    and *m* is their average length. *n2* isn't too big for small *n* (say, *n* <
    10), but it becomes quite big when *n* reaches the magnitude of 100-1,000, and
    actually unacceptable for magnitudes of 10,000-100,000.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们连接，比如说，平均长度为100的10个字符串，第一次操作的成本为200，第二次操作的成本为*200+100=300*，第三次操作的成本为300+100=400，以此类推。不难说服自己，总成本的增长类似于*m*n²*，其中*n*是字符串的数量，*m*是它们的平均长度。对于小的*n*（比如说，*n*
    < 10），*n²*并不太大，但当*n*达到100-1,000的数量级时，它就变得相当大了，实际上对于10,000-100,000的数量级是不可接受的。
- en: 'Let''s take a look at this with some test code, which compares naive concatenation
    with the same operation that''s performed with the help of the `StringBuilder`
    class (the code is available in this book''s GitHub repository):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些测试代码来看看这个问题，这些代码比较了简单的字符串连接与使用`StringBuilder`类执行相同操作的情况（代码可在本书的GitHub仓库中找到）：
- en: '![](img/1711e2df-6610-4cc5-a45c-8592b91d0e20.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1711e2df-6610-4cc5-a45c-8592b91d0e20.png)'
- en: If you create a `StringBuilder` class with something like `var sb =new System.Text.StringBuilder()`,
    and then you add each string to it with `sb.Append(currString)`, the strings are
    not copied; instead, their pointers are queued in a list. They are copied in the
    final string just once, when you call `sb.ToString()` to get the final result.
    Accordingly, the cost of `StringBuilder`-based concatenation grows simply as *m*n*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个`StringBuilder`类，例如`var sb = new System.Text.StringBuilder()`，然后使用`sb.Append(currString)`将每个字符串添加到其中，字符串不会被复制；相反，它们的指针被排队到一个列表中。它们只在调用`sb.ToString()`以获取最终结果时复制一次。因此，基于`StringBuilder`的连接成本简单地增长为*m*n*。
- en: Of course, you will probably never find a piece of software with a function
    like the preceding one that concatenates 100,000 strings. However, you need to
    recognize pieces of code similar to these ones where the concatenation of some
    20-100 strings, say, in a web server that handles several requests simultaneously,
    might cause bottlenecks that damage your non-functional requirements for performance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能永远不会找到一个像前面那样的函数，它将10万个字符串连接起来。然而，你需要认识到类似的代码片段，其中一些20-100个字符串的连接，比如在一个同时处理多个请求的Web服务器中，可能会造成瓶颈，损害你的性能非功能需求。
- en: Exceptions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Always remember—exceptions take too much time to be handled! So, the usage of
    `try-catch` needs to be concise and essential; otherwise, you will create big
    performance issues.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住——异常处理需要太多时间！因此，`try-catch`的使用需要简洁且必要；否则，你将创建大的性能问题。
- en: 'The following two samples compare the usage of `try-catch` and `Int32.TryParse`
    to check whether a string can be converted into an integer, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例比较了使用`try-catch`和`Int32.TryParse`来检查字符串是否可以转换为整数的方法，如下所示：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second function doesn''t look dangerous, but it is thousands of times slower
    than the first one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数看起来并不危险，但它比第一个慢数千倍：
- en: '![](img/422c9151-f741-489e-b71c-7b6a97295143.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/422c9151-f741-489e-b71c-7b6a97295143.png)'
- en: To sum this up, exceptions must be used to deal with exceptional cases that
    break the normal flow of control, for instance, situations when operations must
    be aborted for some unexpected reasons, and control must be returned several levels
    up in the call stack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，异常必须用于处理打破正常控制流程的异常情况，例如，当操作由于某些意外原因必须被中止时，并且必须将控制返回到调用堆栈的几个级别。
- en: Multithreading environments for better results – do's and don'ts
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程环境以获得更好的结果——应该做什么和不应该做什么
- en: If you want to take advantage of all of the hardware that the system you're
    building provides, you have to use multithreading. This way, when a thread is
    waiting for an operation to complete, it can leave the CPU and other resources
    to other threads instead of wasting CPU time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想充分利用你正在构建的系统提供的所有硬件，你必须使用多线程。这样，当一个线程正在等待一个操作完成时，它可以离开CPU和其他资源，让其他线程使用，而不是浪费CPU时间。
- en: 'On the other hand, no matter how hard Microsoft is working to help with this,
    parallel code is not as simple as eating a piece of cake: it is error-prone and
    difficult to test and debug. The most important thing to remember as a software
    architect when you start considering using threads: *does your system require
    them?* Non-functional and some functional requirements will definitely answer
    this question for you.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无论微软如何努力帮助解决这个问题，并行代码并不像吃蛋糕那么简单：它容易出错，难以测试和调试。当你开始考虑使用线程时，作为软件架构师，最重要的要记住的是：*你的系统需要它们吗？*
    非功能性和一些功能性需求肯定会为你回答这个问题。
- en: 'As soon as you are sure that you need a multithreading system, you should decide
    on which technology is more adequate. There are a few options here, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定你需要一个多线程系统，你应该决定哪种技术更合适。这里有几个选项，如下所示：
- en: '**Creating an instance of a System.Threading.Thread**: This is a classic way
    of creating threads in C#. The entirety of the thread life cycle will be in your
    hands. This is good when you are sure about what you are going to do, but you
    need to worry about every single detail of the implementation. The resulting code
    is hard to conceive and debug/test/maintain. So, to keep development costs acceptable,
    this approach should be confined to a few fundamental performance critique modules.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建一个`System.Threading.Thread`的实例**：这是在C#中创建线程的经典方式。线程的生命周期将完全由你控制。当你确定你要做什么时，这是好的，但你需要担心实现中的每一个细节。生成的代码难以构思、调试/测试/维护。因此，为了保持开发成本可接受，这种方法应该仅限于几个基本性能批判性模块。'
- en: '**Programming using System.Threading.Tasks.Parallel and System.Threading.Tasks.Task
    classes**: In the .NET Framework 4.0 versions, you can use parallel classes to
    enable threads in a simpler way. This is good because you don''t need to worry
    about the life cycle of the threads you create, but it will give you less control
    about what is happening in each thread.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 System.Threading.Tasks.Parallel 和 System.Threading.Tasks.Task 类进行编程**：在
    .NET Framework 4.0 版本中，你可以使用并行类以更简单的方式启用线程。这很好，因为你不需要担心你创建的线程的生命周期，但它会给你更少的控制权来了解每个线程中发生的事情。'
- en: '**Develop using asynchronous programming**: This is for sure the easiest way
    to develop multithreading applications since you don''t need to care about thread
    coordination and deadlocks are not possible. When an asynchronous method calls
    another asynchronous method, it goes in sleeping mode to avoid wasting resources
    until the called task returns. This way, asynchronous code mimics the behavior
    of classical synchronous code while keeping most of the performance advantages
    of general parallel programming.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用异步编程进行开发**：这无疑是开发多线程应用程序最容易的方式，因为你不需要关心线程协调，死锁也不可能发生。当一个异步方法调用另一个异步方法时，它会进入休眠模式，以避免在调用任务返回之前浪费资源。这样，异步代码模仿了经典同步代码的行为，同时保持了通用并行编程的大部分性能优势。'
- en: The overall behavior is deterministic and doesn't depend on the time taken by
    each task to complete, so non-reproducible bugs are not possible and the resulting
    code is easy to test/debug/maintain. Defining a method as an asynchronous task
    or not is the only choice left to the programmer; everything else is automatically
    handled by the runtime. The only thing you should be concern about is which methods
    should have asynchronous behavior.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总体行为是确定性的，并且不依赖于每个任务完成所需的时间，因此不可能出现不可重现的bug，生成的代码易于测试/调试/维护。将一个方法定义为异步任务或不是，这是程序员唯一的选择；其他所有事情都由运行时自动处理。你唯一需要关心的是哪些方法应该具有异步行为。
- en: Later on in this book, we will provide some simple examples of asynchronous
    programming. For more information about asynchronous programming and its related
    patterns, please check *Task-Based Asynchronous Patterns* in the Microsoft documentation
    ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续部分，我们将提供一些异步编程的简单示例。有关异步编程及其相关模式的信息，请参阅微软文档中的 *基于任务的异步模式* ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap))。
- en: 'No matter the option you choose, there are some do''s and don''ts that, as
    a software architect, you have to pay attention to. These are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种选项，作为软件架构师，你都必须注意一些“应该做”和“不应该做”的事情。以下是一些注意事项：
- en: '**Do use concurrent collections** (`System.Collections.Concurrent`): As soon
    as you start a multithreading application, you have to use these collections.
    The reason for this is that your program will probably manage the same list, dictionary,
    and so on from different threads. The use of concurrent collections is the only
    option for developing thread-safe programs.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用并发集合** (`System.Collections.Concurrent`)：一旦开始一个多线程应用程序，就必须使用这些集合。原因是你的程序可能会从不同的线程管理相同的列表、字典等。使用并发集合是开发线程安全程序的唯一选择。'
- en: '**Do worry about static variables**: It is not possible to say that static
    variables are prohibited in multithreading development, but you should pay attention
    to them. Again, multiple threads taking care of the same variable can cause a
    lot of trouble. If you decorate a static variable with the `[ThreadStatic]` attribute,
    each thread will see a different copy of that variable, hence solving the problem
    of several threads competing on the same value. However, `ThreadStatic` variables
    can''t be used for extra-thread communications since values written by a thread
    can''t be read by other threads.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注静态变量**：不能说在多线程开发中禁止使用静态变量，但你应该注意它们。再次强调，多个线程处理相同的变量可能会引起很多麻烦。如果你用 `[ThreadStatic]`
    属性装饰静态变量，每个线程都会看到该变量的不同副本，从而解决了多个线程竞争同一值的问题。然而，`ThreadStatic` 变量不能用于跨线程通信，因为一个线程写入的值不能被其他线程读取。'
- en: '**Do test system performance after multithreading implementations**: Threads
    give you the ability to take full advantage of your hardware, but in some cases,
    badly written threads can waste CPU time just doing nothing! Similar situations
    may result in almost 100% CPU usage and unacceptable system slowdowns. In some
    cases, the problem can be mitigated or solved by adding a simple `Thread.Sleep(1)` call
    in the main loop of some threads to prevent them from wasting too much CPU time,
    but you need to test this.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在多线程实现后测试系统性能**：线程使你能够充分利用你的硬件，但在某些情况下，编写不良的线程可能会浪费CPU时间而什么也不做！类似的情况可能会导致几乎100%的CPU使用率和不可接受的系统减速。在某些情况下，通过在某个线程的主循环中添加简单的`Thread.Sleep(1)`调用可以减轻或解决问题，但你需要测试这一点。'
- en: '**Do not consider multithreading easy**: Multithreading is not as simple as
    it seems in some syntax implementations. While writing a multithreading application,
    you should consider things such as the synchronization of the user interface,
    threading termination, and coordination. In many cases, programs just stop working
    well due to a bad implementation of multithreading.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要认为多线程很简单**：在某些语法实现中，多线程并不像看起来那么简单。在编写多线程应用程序时，你应该考虑诸如用户界面的同步、线程终止和协调等问题。在许多情况下，程序只是因为多线程实现不当而停止正常工作。'
- en: '**Do not forget to plan the number of threads your system should have**: This
    is really important for 32-bit programs. There is a limitation regarding how many
    threads you can have in 32-bit environments. You should consider this when you
    are designing your system.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记计划你的系统应该拥有的线程数量**：这对于32位程序来说非常重要。在32位环境中，你可以拥有的线程数量有一个限制。在设计你的系统时，你应该考虑这一点。'
- en: '**Do not forget to end your threads**: If you do not have the correct termination
    procedure for each thread, you will probably have trouble with memory and handles
    leaks.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记结束你的线程**：如果你没有为每个线程提供正确的终止程序，你可能会遇到内存和处理句柄泄漏的问题。'
- en: Usability – why inserting data takes too much time
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性 - 为什么插入数据需要花费太多时间
- en: Scalability, performance tips, and multithreading are the main tools we can
    use to tune machine performance. However, the effectiveness of the system you
    design depends on the overall performance of the whole processing pipeline, which
    includes both humans and machines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性、性能技巧和多线程是我们可以用来调整机器性能的主要工具。然而，你设计的系统的有效性取决于整个处理管道的整体性能，这包括人类和机器。
- en: 'As a software architect, you can''t improve the performance of humans, but
    you can improve the performance of man-machine interaction by designing an effective
    **user interface** (**UI**), that is, user interfaces that ensure a fast interaction
    with humans, which, in turn, means the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你无法提高人类的表现，但你可以通过设计一个有效的**用户界面**（**UI**），即确保与人类快速交互的用户界面来提高人机交互的性能，这反过来意味着以下内容：
- en: The UI must be easy to learn to reduce the time that's needed for learning and
    time waste before the target users learn to operate quickly. This constraint is
    fundamental if UI changes are frequent, and for public websites that need to attract
    the greatest possible number of users.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI必须易于学习，以减少学习时间和目标用户学会快速操作之前的时间浪费。如果UI更改频繁，以及需要吸引尽可能多用户的公共网站，这个限制是基本的。
- en: The UI must not cause any kind of slowdown in data insertion; data insertion
    speed must be limited just by the user's ability to type, not by system delays
    or by additional gestures that could be avoided.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI不得在数据插入时造成任何类型的减速；数据插入速度必须仅限于用户的打字能力，而不是由系统延迟或可以避免的额外手势。
- en: 'The following are a few simple tips when it comes to designing *easy to learn*
    user interfaces:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计*易于学习*的用户界面时，以下是一些简单的技巧：
- en: Each input screen must state its purpose clearly.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个输入屏幕必须清楚地说明其目的。
- en: Use the language of the user, not the language of developers.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户的语言，而不是开发者的语言。
- en: Avoid complications. Design the UI with the average case in mind; more complicated
    cases can be handled with extra inputs that appear only when needed. Split complex
    screens into more input steps.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂化。设计UI时考虑平均情况；更复杂的情况可以通过仅在需要时出现的额外输入来处理。将复杂的屏幕拆分为更多输入步骤。
- en: Use past inputs to understand user intentions and to put users on the right
    paths with messages and automatic UI changes; for instance, cascading drop-down
    menus.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过去的输入来理解用户意图，并通过消息和自动UI更改将用户引导到正确的路径；例如，级联下拉菜单。
- en: Error messages are not bad notes the system gives to the user, but they must
    explain how to insert correct input.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误消息不是系统给用户的坏笔记，但它们必须解释如何插入正确的输入。
- en: 'Fast user interfaces result from efficacious solutions to the following three
    requirements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 快速用户界面源于对以下三个要求的有效解决方案：
- en: Input fields must be placed in the order they are usually filled, and it should
    be possible to move to the next input with the *Tab* or *Enter* key. Moreover,
    fields that often remain empty should be placed at the bottom of the form. Simply
    put, the usage of the mouse while filling a form should be minimized. This way,
    the number of user gestures is kept to a minimum. In a web application, once the
    optimal placement of input fields has been decided, it is enough to use the `tabindex`
    attribute to define the right way users move from one input field to the next
    with the *Tab* key.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段必须按照通常填充的顺序放置，并且应该可以使用 *Tab* 或 *Enter* 键移动到下一个输入。此外，经常保持空白的字段应放置在表单底部。简单来说，填写表单时使用鼠标的操作应尽可能减少。这样，用户手势的数量保持在最低。在Web应用程序中，一旦决定了输入字段的最佳放置，就足够使用
    `tabindex` 属性来定义用户使用 *Tab* 键从输入字段移动到下一个输入字段的正确方式。
- en: System reactions to user inputs must be as fast as possible. In particular,
    error (or information) messages must appear as soon as the user leaves the input
    field. The simplest way to achieve this is to move most of the help and input
    validation logic to the client side so that system reactions don't need to pass
    through both communication lines and servers.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统对用户输入的反应必须尽可能快。特别是，错误（或信息）消息必须在用户离开输入字段时立即出现。实现这一点的最简单方法是将大部分帮助和输入验证逻辑移动到客户端，这样系统反应就不需要通过通信线路和服务器进行。
- en: Efficacious selection logic. Selecting an existing item should be as easy as
    possible; for example, selecting one of some thousands of products in an offer
    must be possible with a few gestures and with no need to remember the exact product
    name or its barcode. The next subsection analyzes techniques we can use to increase complexity to
    achieve fast selection.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的选择逻辑。选择现有项目应该尽可能简单；例如，在优惠中从数千种产品中选择一个，应该可以通过几个手势完成，而且无需记住确切的产品名称或其条形码。下一小节将分析我们可以使用的提高复杂度以实现快速选择的技术。
- en: Designing fast selection logic
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计快速选择逻辑
- en: 'When all the possible choices are in the order of magnitude of 1-50, the usual
    drop-down menu is enough. For instance, check the currency selection drop-down
    menu:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有可能的选择的数量级在1-50之间时，通常的下拉菜单就足够了。例如，检查货币选择下拉菜单：
- en: '![](img/64bf7d21-bbca-4f59-9a69-8c7777836a5e.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64bf7d21-bbca-4f59-9a69-8c7777836a5e.png)'
- en: 'When the order of magnitude is higher but less than a few thousand, an autocomplete
    that shows the names of all the items that start with the characters typed by
    the user is usually a good choice:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当数量级较高但不到几千时，显示所有以用户输入的字符开头的项目名称的自动完成通常是一个好选择：
- en: '![](img/f74ec7cc-96e3-42e5-aa6d-4b48572c322d.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f74ec7cc-96e3-42e5-aa6d-4b48572c322d.png)'
- en: A similar solution can be implemented with a low computational cost since all
    the main databases can efficiently select strings that start with a given substring.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类似解决方案可以以低计算成本实现，因为所有主要数据库都可以有效地选择以给定子串开头的字符串。
- en: When names are quite complex, when searching for the characters that were typed
    in by the user, they should be extended inside each item string. This operation
    can't be performed efficiently with usual databases and requires ad hoc data structures.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当名称相当复杂时，在搜索用户输入的字符时，它们应在每个项目字符串内部扩展。这种操作不能使用常规数据库有效地执行，需要专门的数据结构。
- en: Finally, when we are searching inside descriptions composed of several words,
    more complex search patterns are needed. This is the case, for instance, of product
    descriptions. If the chosen database supports full-text search, the system can
    search for the occurrence of several words that have been typed by the user inside
    all the descriptions efficiently.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们搜索由多个单词组成的描述时，需要更复杂的搜索模式。例如，产品描述就是这样。如果所选数据库支持全文搜索，系统可以有效地搜索用户在所有描述中输入的多个单词的出现。
- en: However, when descriptions are made up of names instead of common words, it
    might be difficult for the user to remember a few exact names contained in the
    target description. This happens, for instance, with multi-country company names.
    In these cases, we need algorithms that find the best match for the character
    that was typed by the user. Substrings of the string that was typed by the user
    must be searched in different places of each description. In general, similar
    algorithms can't be implemented efficiently with databases based on indexes but
    require all the descriptions to be loaded in memory and ranked somehow against
    the string that was typed by the user.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当描述由名称而不是常见单词组成时，用户可能很难记住目标描述中包含的几个确切名称。这种情况在多国公司名称中很常见。在这些情况下，我们需要找到用户输入的字符最佳匹配的算法。必须在每个描述的不同位置搜索用户输入的字符串的子串。一般来说，无法有效地使用基于索引的数据库实现类似算法，但需要将所有描述加载到内存中，并以某种方式与用户输入的字符串进行排名。
- en: The most famous algorithm in this class is probably the **Levenshtein** algorithm,
    which is used by most spell checkers to find a word that best fits the mistyped
    one by the user. This algorithm minimizes the Levenshtein distance between the
    description and the string typed by the user, that is, the minimum number of character
    removals and additions needed to transform one string into another.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这类算法中最著名的算法可能是**Levenshtein**算法，该算法被大多数拼写检查器用于找到与用户输入的错误拼写最匹配的单词。此算法最小化描述与用户输入的字符串之间的Levenshtein距离，即从一个字符串转换到另一个字符串所需的字符删除和添加的最小数量。
- en: 'The Levenshtein algorithm works great but has a very high computational cost.
    Now, we give a faster algorithm that works well for searching character occurrences
    in descriptions. Characters typed by the user don''t need to occur consecutively
    in the description but must occur in the same order. Some characters may miss.
    Each description is given a penalty that depends on the missing characters and
    on how the occurrences of the characters typed by the user are far from the others.
    More specifically, the algorithm ranks each description with two numbers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein算法效果很好，但计算成本非常高。现在，我们给出一个更快的算法，该算法在搜索描述中的字符发生时效果良好。用户输入的字符不需要在描述中连续出现，但必须按相同的顺序出现。某些字符可能缺失。每个描述都根据缺失的字符以及用户输入的字符发生的相对位置给予一个惩罚。更具体地说，算法使用两个数字对每个描述进行排名：
- en: 'The number of characters typed by the user that occurs in the description:
    The more characters contained in the description, the higher its rank.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的字符在描述中出现的次数：描述中包含的字符越多，其排名越高。
- en: Each description is given a penalty equal to the total distance among the occurrences
    of the characters typed by the user in the description.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个描述都根据用户在描述中输入的字符发生之间的总距离给予一个惩罚。
- en: 'The following screenshot shows how the word **Ireland** is ranked against the
    string **ilad**, which was typed by the user:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了单词**爱尔兰**与用户输入的字符串**ilad**的排名情况：
- en: '![](img/cfd55e6c-1607-4a2d-8c4a-1a5677b8cc12.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfd55e6c-1607-4a2d-8c4a-1a5677b8cc12.png)'
- en: The number of occurrences is four, while the total distance among characters
    occurrences is three.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 发生次数为四个，而字符发生之间的总距离为三个。
- en: 'Once all the descriptions have been rated they are sorted according to the
    number of occurrences. Descriptions with the same number of occurrences are sorted
    according to the lowest penalties. The following is an autocomplete that implements
    the preceding algorithm:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有描述都被评分，它们将根据发生次数进行排序。发生次数相同的描述将根据最低的惩罚进行排序。以下是一个实现上述算法的自动完成示例：
- en: '![](img/9c02622a-1350-4551-be69-4ea2b4e8eb5f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c02622a-1350-4551-be69-4ea2b4e8eb5f.png)'
- en: 'The C# code that ranks each description against the string typed by the user
    is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对用户输入的字符串进行排名的C#代码：
- en: '[PRE1]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The item to rank is inserted in a `Rater` instance. Then, its string description
    is extracted by a `keyAccessor` function. After that, the code computes both character
    occurrences and occurrences in the total distance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要排名的项目被插入到`Rater`实例中。然后，通过`keyAccessor`函数提取其字符串描述。之后，代码计算字符发生和总距离中的发生次数。
- en: The full class code, along with a test console project, is available in this
    book's GitHub repository.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的类代码，以及一个测试控制台项目，都可以在本书的GitHub仓库中找到。
- en: Selecting from a huge amount of items
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从大量项目中选择
- en: Here, huge doesn't refer to the amount of space needed to store the data, but
    to the difficulty the user has in remembering the features of each item. When
    an item must be selected from among more than 10,000-100,000 items, there is no
    hope to find it by searching for character occurrences inside a description. Here,
    the user must be driven toward the right item through a hierarchy of categories.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“巨大”并不是指存储数据所需的空间量，而是指用户记住每个项目功能的困难程度。当必须从 10,000-100,000 个项目中选择一个时，通过在描述中搜索字符出现来找到它的希望就消失了。在这里，用户必须通过一系列类别来引导到正确的项目。
- en: In this case, several user gestures are needed to perform a single selection.
    In other word, each selection requires interaction with several input fields.
    Once it's decided that the selection can't be done with a single input field,
    the simplest option is cascading drop-down menus, that is, a chain of drop-down
    menus whose selection list depends on the values that were selected in the previous
    drop-down menus.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，执行单个选择需要多个用户手势。换句话说，每个选择都需要与多个输入字段进行交互。一旦确定选择不能通过单个输入字段完成，最简单的选项就是级联下拉菜单，即一系列下拉菜单，其选择列表取决于之前下拉菜单中选择的值。
- en: 'For example, if the user needs to select a town located anywhere in the world,
    we may use the first drop-down menu to select the country, and once the country
    has been chosen, we may use this choice to populate a second one with all the
    towns in the selected country. A simple example is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户需要选择世界上任何地方的城镇，我们可能使用第一个下拉菜单来选择国家，一旦选择了国家，我们可能使用这个选择来填充第二个下拉菜单，其中包含所选国家中的所有城镇。一个简单的例子如下：
- en: '![](img/887f872b-d932-4737-965f-606bd1ad47a6.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/887f872b-d932-4737-965f-606bd1ad47a6.png)'
- en: Clearly, each drop-down menu can be replaced by an autocomplete when required
    due to having a high number of options.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当需要时，每个下拉菜单都可以用自动完成来替换，因为选项数量很多。
- en: 'If making the right selection can be done by intersecting several different
    hierarchies, cascading drop-down menus become inefficient too, and we need a filter
    form, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过交叉多个不同的层次结构来做出正确的选择变得不高效，那么级联下拉菜单也会变得低效，我们需要一个过滤器表单，如下所示：
- en: '![](img/47389640-dfa6-4283-9d0e-af7bf68564c5.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47389640-dfa6-4283-9d0e-af7bf68564c5.png)'
- en: Now, let's understand interoperability with .NET Core.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解 .NET Core 的互操作性。
- en: The fantastic world of interoperability with .NET Core
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 与 .NET Core 的互操作性奇妙世界
- en: .NET Core brought Windows developers the ability to deliver their software into
    various platforms. And you, as a software architect, need to pay particular attention
    to this. Linux and macOS are no longer a problem for C# lovers—it's much better
    than that—they are really good opportunities to deliver to new customers. Therefore,
    we need to ensure performance and multi-platform support, two common non-functional
    requirements in several systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 为 Windows 开发者带来了将他们的软件部署到各种平台的能力。作为软件架构师，您需要特别注意这一点。对于 C# 爱好者来说，Linux
    和 macOS 已不再是问题——这比那更好——它们确实是向新客户交付的真正好机会。因此，我们需要确保性能和多平台支持，这是几个系统中的两个常见非功能性需求。
- en: Both console applications and web apps designed with .NET Core in Windows are
    almost completely compatible with Linux and macOS, too. This means you do not
    have to build the app again to run it on these platforms. Also, very platform-specific
    behaviors now have multi-platform support, as shown, for instance, by the `System.IO.Ports.SerialPort`class,
    which, starting from .NET Core 3.0, is on Linux.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中使用 .NET Core 设计的控制台应用程序和 Web 应用程序几乎也与 Linux 和 macOS 完全兼容。这意味着您不需要在这些平台上重新构建应用程序即可运行它。此外，现在许多特定于平台的行为都支持多平台，例如，从
    .NET Core 3.0 开始的 `System.IO.Ports.SerialPort` 类，它在 Linux 上运行。
- en: Microsoft offers scripts to help you install .NET Core on Linux and macOS. You
    can find them at [https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script).
    Once you have the SDK installed, you just need to call **dotnet** the same way
    you do in Windows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了脚本帮助您在 Linux 和 macOS 上安装 .NET Core。您可以在 [https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script)
    找到它们。一旦安装了 SDK，您只需像在 Windows 上一样调用 **dotnet** 即可。
- en: However, you must be aware of some features that are not fully compatible with
    Linux and macOS systems. For instance, no equivalent to the Windows Registry exists
    in these OSes and you have to develop an alternative yourself. If needed, an encrypted
    JSON config file can be a good option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您必须意识到一些与 Linux 和 macOS 系统不完全兼容的功能。例如，在这些操作系统中没有与 Windows 注册表等效的东西，您必须自己开发替代方案。如果需要，加密的
    JSON 配置文件是一个不错的选择。
- en: Another important point is that Linux is case-sensitive, while Windows is not.
    Please, remember this when you work with files. Another important thing is that
    the Linux path separator is different from the Windows separator. You can use
    the `Path.PathSeparator` property and all the other `Path` class methods to ensure
    your code is actually multi-platform.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要点是，Linux 区分大小写，而 Windows 不区分。当您处理文件时，请记住这一点。另一个重要的事情是，Linux 的路径分隔符与 Windows
    的分隔符不同。您可以使用 `Path.PathSeparator` 属性以及所有其他 `Path` 类方法来确保您的代码实际上是跨平台的。
- en: 'Besides, you can also adapt your code to the underlying OS by using the runtime
    checks provided by .NET Core, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以通过使用 .NET Core 提供的运行时检查来将您的代码适配到底层操作系统，如下所示：
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating a service in Linux
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 中创建服务
- en: 'The following script can be used to encapsulate a command-line .NET Core app
    in Linux. The idea is that this service works like a Windows Service. This can
    be really useful, considering that most Linux installations are command-line only
    and run without a user logged in:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本可以用于在 Linux 中封装命令行 .NET Core 应用程序。这个想法是，这个服务就像一个 Windows 服务一样工作。考虑到大多数 Linux
    安装仅提供命令行界面，并且在没有用户登录的情况下运行，这可能会非常有用：
- en: 'The first step is to create file that will run the command-line app. The name
    of the app is `app.dll` and it is installed in `appfolder`. The application will
    be checked every 5,000 milliseconds. This service was created on a CentOS 7 system.
    Using a Linux Terminal, you can type this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个将运行命令行应用程序的文件。应用程序的名称是 `app.dll`，它安装在 `appfolder` 中。该应用程序将被每 5,000 毫秒检查一次。此服务是在
    CentOS 7 系统上创建的。使用 Linux 终端，您可以输入以下内容：
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the file has been created, you have to copy the service file to a system
    location. After that, you have to reload `systemd` and enable the service so that
    it will restart on reboots:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件创建完成，您必须将服务文件复制到系统位置。之后，您需要重新加载 `systemd` 并启用服务，以便在重启时自动启动：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Done! Now, you can start, stop, and check the service using the following commands.
    The whole input that you need to provide in your command-line app is as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成！现在，您可以使用以下命令启动、停止和检查服务。您在命令行应用程序中需要提供的整个输入如下：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we've learned about a few concepts, let's learn how to implement them
    in our use case.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些概念，让我们学习如何在我们的用例中实现它们。
- en: Book use case – understanding the main types of .NET Core projects
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍用例 - 理解 .NET Core 项目的类型
- en: 'The development of this book''s use case will be based on various kinds of
    .NET Core Visual Studio projects. This section describes all of them. Let''s select
    New project in the Visual Studio file menu. In the window that opens, all the
    .NET Core projects will be located under the .NET Core, .NET Standard, and Cloud
    items in the left-hand menu:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本书用例的开发将基于各种类型的 .NET Core Visual Studio 项目。本节描述了所有这些项目。让我们在 Visual Studio 文件菜单中选择“新建项目”。在打开的窗口中，所有
    .NET Core 项目都将位于左侧菜单的 .NET Core、.NET Standard 和 Cloud 项下：
- en: '![](img/9897fec5-b7cd-41e5-8835-9db5c86f617c.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9897fec5-b7cd-41e5-8835-9db5c86f617c.png)'
- en: 'Most of them are available under .NET Core:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都在 .NET Core 下可用：
- en: '![](img/91892c07-c0c3-4ce9-a574-b58b6fe2ca2e.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91892c07-c0c3-4ce9-a574-b58b6fe2ca2e.png)'
- en: 'Here, we have a console project, a class library project, and various types
    of test projects, each based on a different test framework: xUnit, nUnit, and
    MSTest. Choosing among the various testing frameworks is just a matter of preference
    since all of them offer comparable features. Adding tests to each piece of software
    that composes a solution is a common practice and allows software to be modified
    frequently without jeopardizing its reliability.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个控制台项目、一个类库项目以及各种类型的测试项目，每个项目都基于不同的测试框架：xUnit、nUnit 和 MSTest。选择各种测试框架只是个人偏好的问题，因为它们都提供了类似的功能。将测试添加到构成解决方案的每个软件组件中是一种常见做法，允许软件频繁修改而不会危及其可靠性。
- en: Testing will be discussed in detail in [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml),
    *Testing Your Code with Unit Test Cases and TDD*, and [Chapter 20](e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml),
    *Automation for Software Testing*. Finally, we have the ASP.NET Core application
    we already described in the *Creating a scalable web app with .NET Core* subsection.
    There, we defined an ASP.NET MVC application, but Visual Studio also contains
    project templates for projects based on RESTful APIs and the most important single-page
    application frameworks such as Angular, React, Vue.js, and the new Blazor framework
    based on WebAssembler. Some of them are available with the standard Visual Studio
    installation; others require the installation of a SPA package.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将在[第15章](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml)，*使用单元测试用例和TDD测试您的代码*和[第20章](e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml)，*软件测试自动化*中详细讨论。最后，我们已经有了一个在*使用.NET
    Core创建可扩展的Web应用程序*子节中描述的ASP.NET Core应用程序。在那里，我们定义了一个ASP.NET MVC应用程序，但Visual Studio还包含基于RESTful
    API和最重要的单页应用程序框架（如Angular、React、Vue.js以及基于WebAssembly的新Blazor框架）的项目模板。其中一些在标准的Visual
    Studio安装中可用；其他则需要安装SPA包。
- en: For each project type, we can choose the .NET Core version we would like to
    use. Under the .NET Standard menu item, we have only a class library project.
    .NET Standard class libraries are based on .NET standards instead of a specific
    .NET Core version so they are compatible with several .NET Core versions. For
    instance, libraries based on 2.0 standards are compatible with all .NET Core versions
    greater than or equal to 2.0, and with all .NET Framework versions greater than
    4.6.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种项目类型，我们可以选择我们想要使用的.NET Core版本。在.NET Standard菜单项下，我们只有一个类库项目。.NET Standard类库基于.NET标准而不是特定的.NET
    Core版本，因此它们与多个.NET Core版本兼容。例如，基于2.0标准的库与所有大于或等于2.0的.NET Core版本以及所有大于4.6的.NET
    Framework版本兼容。
- en: This compatibility advantage comes at the price of having less available features.
    However, features that are not a part of a standard can be added as references
    to additional library packages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种兼容性优势是以牺牲更少可用功能为代价的。然而，不属于标准的特性可以作为对附加库包的引用添加。
- en: 'Finally, under the cloud menu, we have several more project types, but the
    only new project related to .NET Core is the Service Fabric Application:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在云菜单下，我们还有更多项目类型，但与.NET Core相关的新项目只有Service Fabric应用程序：
- en: '![](img/72a033eb-6bf1-4da9-b7fd-3544d1f43541.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72a033eb-6bf1-4da9-b7fd-3544d1f43541.png)'
- en: This allows us to define microservices. Microservice-based architectures allow
    an application to be split into several independent microservices. Several instances
    of the same microservice can be created and distributed across several machines
    to fine-tune the performance of each application part. Microservices will be described
    in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice
    Architecture to Your Enterprise Application*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够定义微服务。基于微服务的架构允许将应用程序拆分为几个独立的微服务。可以创建多个相同的微服务实例，并将它们分布到多台机器上以微调每个应用程序部分的表现。微服务将在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，*将微服务架构应用于您的企业应用程序*中描述。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional requirements that describe system behavior must be completed with
    non-functional requirements that constrain system performance, scalability, interoperability,
    and usability. Performance requirements come from response-time and system load
    requirements. As a software architect, you should ensure you have the required
    performance with the minimum cost building efficient algorithms and taking full
    advantage of the available hardware resources with multithreading.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 描述系统行为的职能需求必须与非职能需求相结合，这些非职能需求限制了系统的性能、可伸缩性、互操作性和可用性。性能需求来自响应时间和系统负载需求。作为软件架构师，您应该确保以最低的成本构建高效的算法，充分利用可用的硬件资源，并通过多线程实现所需的性能。
- en: Scalability is the capability of a system to be adapted to an increasing load.
    Systems can be scaled vertically by providing more powerful hardware, or horizontally
    by replicating and load balancing the same hardware. The cloud, in general, and
    Azure, in particular, can help us implement strategies dynamically, with no need
    to stop your application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性是指系统适应增加负载的能力。系统可以通过提供更强大的硬件进行垂直扩展，或者通过复制和负载均衡相同的硬件进行水平扩展。通常来说，云（尤其是Azure）可以帮助我们动态地实施策略，而无需停止您的应用程序。
- en: Tools such as .NET Core that run on several platforms can ensure interoperability,
    that is, the capability of your software to run on different target machines and
    with different operating systems (Windows, Linux, macOS, Android, and so on).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个平台上运行的工具，如 .NET Core，可以确保互操作性，即你的软件能够在不同的目标机器和不同的操作系统（Windows、Linux、macOS、Android
    等）上运行。
- en: Usability is ensured by taking care of the input field's order, the effectiveness
    of the item selection logic, and how easy your system is to learn.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注输入字段的顺序、项目选择逻辑的有效性以及系统学习的便捷性来确保可用性。
- en: In the next chapter, you will learn how Azure DevOps tools can help us when
    it comes to collecting, defining, and documenting our requirements.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习 Azure DevOps 工具如何帮助我们收集、定义和记录我们的需求。
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which are the two conceptual ways to scale a system?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统扩展的两种概念方式是什么？
- en: Can you deploy your web app automatically from Visual Studio to Azure?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否从 Visual Studio 自动部署你的 Web 应用到 Azure？
- en: What is multithreading useful for?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程有什么用途？
- en: What are the main advantages of the asynchronous pattern over other multithreading
    techniques?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步模式相较于其他多线程技术的主要优势是什么？
- en: Why is the order of input fields so important?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么输入字段的顺序如此重要？
- en: Why is the .NET Core `Path` class so important for interoperability?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 .NET Core 的 `Path` 类对于互操作性如此重要？
- en: What is the advantage of a .NET standard class library over a .NET Core class
    library?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 标准类库相较于 .NET Core 类库有什么优势？
- en: List the various types of .NET Core Visual Studio projects.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出各种 .NET Core Visual Studio 项目的类型。
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and links you may consider reading to gather more
    information about this chapter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能考虑阅读的书籍和链接，以获取更多关于本章的信息：
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
- en: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
