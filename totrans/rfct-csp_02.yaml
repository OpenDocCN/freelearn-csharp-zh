- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to learn refactoring is to look at an example. In this chapter,
    we’ll explore a sample refactoring scenario using C# and Visual Studio and see
    firsthand how refactoring can transform the maintainability of code without altering
    its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a baggage price calculator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring in other editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we’ll cover refactorings around introducing locals, constants,
    and parameters, extracting methods, and removing unreachable/unused code, as well
    as touching upon the importance of testing in any refactoring endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow along with this chapter, you can clone this book’s code
    from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp).
  prefs: []
  type: TYPE_NORMAL
- en: The starting code for this chapter can be found in the `Chapter02/Ch2BeginningCode`
    folder after cloning the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a baggage price calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by examining a baggage price calculator used by the staff of Cloudy
    Skies Airline during baggage checks to determine the amount an individual customer
    must pay.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for baggage pricing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All carry-on baggage costs $30 per bag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first checked bag a passenger checks costs $40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each subsequent checked bag costs $50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the travel occurs during the holidays, a 10% surcharge is applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code lives in a C# `BaggageCalculator` class that we’ll review in a few
    blocks of code, starting with the class definition, field, and full property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'BaggageCalculator.cs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple class with an older style of property definition setting `holidayFeePercent`
    to a `decimal` value (identified by the `M` suffix) of `0.1` or 10%.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class also has a `CalculatePrice` method that returns a `decimal` value
    indicating the total cost of baggage fees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That logic has some complexity to it, but it matches up with the business rules
    described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the class ends with a `CalculatePriceFlat` method that was introduced
    in an earlier version of the application and is no longer used (which we’ll discuss
    later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While this code isn’t the worst in the world by any stretch, this is a class
    that is slowly growing in complexity and becoming harder to understand and maintain
    as new rules are added to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this class is supported by a series of passing unit tests and is
    generally agreed to calculate the correct amount by all users.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of the chapter, we’ll apply a series of targeted refactorings
    to improve this code to prevent it from being an issue in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Converting properties to auto properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class starts with the declaration of the `HolidayFeePercent` property as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code is fine and has no issues whatsoever. However, C# is a language that
    continues to evolve and developers generally prefer to write and maintain fewer
    lines of code when given the choice.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, Microsoft gave us the ability to write *automatically implemented
    properties* (commonly called **auto properties**) that automatically generate
    their own field with a getter and setter when the code is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: While we could delete the property and its field and redeclare it, there’s a
    possibility that we could make a spelling or capitalization mistake when doing
    so. Instead, let’s take a look at how Visual Studio can do this for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio, if you move your typing cursor onto a property name, either
    by using the arrow keys or by clicking on the name of the property, you’ll see
    a light bulb appear in the margin as shown in *Figure 2**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The light bulb Quick Actions icon](img/B21324_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The light bulb Quick Actions icon
  prefs: []
  type: TYPE_NORMAL
- en: If you click on this light bulb (or press *Ctrl* + *.* by default), the **Quick
    Actions** menu will appear and list several refactorings.
  prefs: []
  type: TYPE_NORMAL
- en: The refactoring choices are context-sensitive, so only those that Visual Studio
    believes are relevant to the code you have currently selected will appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the first option, **Use auto property**, is the refactoring action
    we want. See *Figure 2**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Previewing the Use auto property refactoring](img/B21324_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Previewing the Use auto property refactoring
  prefs: []
  type: TYPE_NORMAL
- en: When this option is selected, the pane on the right will display a preview of
    the change this will make to your code. Here it lists the lines it will remove
    in red and the line it adds in green.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking **Use auto property** or pressing *Enter* on the keyboard will accept
    the suggestion and replace your code with the auto property version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Admittedly this is a simple refactoring, but there are a couple of things I
    want to stress about the refactoring process:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio took care of making the change and did so in an automated way
    that was free of potential typos or other mistakes a human might make.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you didn’t know that you could move a full property to an auto property,
    this **Quick Action** helped you discover that. These **Quick Actions** can actually
    *teach* you a lot about the C# programming language as it continues to evolve
    and change every year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the mechanics of refactoring in Visual Studio out of the way, let’s explore
    some additional refactorings.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing locals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems the `CalculatePrice` method has is that there are a few
    expressions, such as `carryOn * 30M` and `bags * 40M`, that appear multiple times
    throughout the method.
  prefs: []
  type: TYPE_NORMAL
- en: These are small issues but can lead to maintainability problems. If the nature
    of the expressions changed, we would need to modify multiple places within our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In general, one of the reasons you may want to refactor code is if you find
    yourself modifying multiple places to make a single change on a regular basis.
    For example, if the pricing structure changed we should modify multiple lines
    of code to support the new pricing model. Each one of those lines we should modify
    is a place we might fail to make a change. Missing changes like this typically
    introduce bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we didn’t miss any code that needed to be modified, most developers
    would prefer to have to make a change in one place instead of multiple.
  prefs: []
  type: TYPE_NORMAL
- en: The **Introduce local** refactoring can help with this by introducing a local
    variable containing the result of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this refactoring, select the expression that is repeated as shown in
    *Figure 2**.3*, noting that Visual Studio helpfully highlights any places it is
    repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Selecting a repeated expression in Visual Studio](img/B21324_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Selecting a repeated expression in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Next, use the **Quick Action** button by pressing *Ctrl* + *.* or clicking on
    the screwdriver icon.
  prefs: []
  type: TYPE_NORMAL
- en: A note on the Quick Actions icon
  prefs: []
  type: TYPE_NORMAL
- en: The **Quick Action** button sometimes appears as a light bulb and sometimes
    appears as a screwdriver, depending on your code analysis rules and the exact
    issues a line is facing. They are effectively the same option, but the light bulb
    tells you a suggested refactoring is present while a screwdriver indicates a less
    critical refactoring option to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Once the context menu is open, expand the right arrow next to **Introduce local**
    by using the arrow keys to navigate the menu. This will let you view more detailed
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Drilling into the specialized forms of the Introduce local refactoring](img/B21324_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Drilling into the specialized forms of the Introduce local refactoring
  prefs: []
  type: TYPE_NORMAL
- en: Here it gives you the ability to introduce a local variable just for the expression
    you selected or to do so **for all occurrences** of this expression. I generally
    recommend using the **for all occurrences**option, but it will depend on the context
    of what you’re trying to improve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select the **Introduce local** option, Visual Studio will prompt you
    for a name for your variable (see *Figure 2**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Naming your new local variable](img/B21324_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Naming your new local variable
  prefs: []
  type: TYPE_NORMAL
- en: Type in the name you would like and then press *Enter* to make the box disappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I called the variable `fee` and it replaced it in both lines as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While this is certainly cleaner for the carry-on baggage fee logic, there’s
    still a `bags * 40M` expression repeated in the checked baggage logic and a `total
    * HolidayFeePercent` expression that is also repeated.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the **Introduce local** refactoring to make complex lines more understandable
    by pulling some logic out of dense lines into their own smaller lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the **Introduce local** refactoring throughout this method results
    in a longer method, but one that’s easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a programming instructor, I saw many students under the mistaken assumption
    that the shortest way to implement something was always the best.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the best code tends to be the code that’s easier to maintain over time,
    less likely to break, and easier to think about as you go about development tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Less code is often easier to think about, but when code gets too concise or
    too complex it can be hard to maintain. Find a happy medium between brevity and
    readability, keeping in mind that many times, programmers skim code looking for
    a specific section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` value that will never change during the program’s runtime.
  prefs: []
  type: TYPE_NORMAL
- en: However, **Introduce constant** is often used for a different purpose than **Introduce
    local**. While **Introduce local** tends to be used to reduce repetition or simplify
    complex lines of code, **Introduce constant** is often used to eliminate **magic
    numbers** or **magic strings** from code.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a magic number is a number that exists in your code without
    any explanation of what that number means or why it is there. This is bad because
    the person maintaining your code later doesn’t understand why that number was
    chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CalculatePrice` method has three magic numbers: `30M`, `40M`, and `50M`,
    representing the various baggage fee amounts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing a constant for these is the same as introducing a local. Just highlight
    the number and open the **Quick Actions** menu, then select **Introduce constant**
    and then **Introduce constant for all occurrences** in the sub-menu as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Introducing a constant for all occurrences of the 40M decimal
    literal](img/B21324_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Introducing a constant for all occurrences of the 40M decimal literal
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this to the various magic numbers in our application and choosing appropriate
    names results in the following new constants at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Introducing these constants has the added benefit of putting our price rules
    in a centralized place, making them more discoverable by new developers joining
    the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also makes our code a lot easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Programmers spend disproportionally more time *reading* code rather than *writing*
    code. Optimizing your code for maintainability is a key habit that will help your
    application resist technical debt as time goes by.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One refactoring technique I wish I saw more people use is the **Introduce**
    **parameter** refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring takes an expression or variable in a method and removes it
    from the method entirely, instead adding its value as a new parameter to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, right now the `CalculatePrice` method has logic inside of it for
    determining which travel dates should be considered for holiday travel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is logic that could become more complex as more holidays are added and
    holidays from different countries are considered. As the code is written now,
    the additional complexity would need to go into this `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, introducing a parameter for `isHoliday` gives the callers of this method
    the responsibility of telling whether the method is holiday travel or not. This
    ultimately allows us to leave this method to focus on pricing the customer’s baggage
    and to be aware of holidays but it is not responsible for determining what is
    and what isn’t a holiday.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing a parameter can be done by selecting the variable or expression
    you wish to move to a parameter and then triggering the **Quick** **Actions**
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Introducing a parameter using the Quick Actions menu](img/B21324_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Introducing a parameter using the Quick Actions menu
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple options to choose from when introducing a parameter. Choosing
    **and update call sites directly** is usually a good option – provided you review
    the code it generates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we introduce the parameter and name it appropriately, the holiday fee
    logic becomes much easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Introducing a parameter also changed the method signature line to add a Boolean
    `isHoliday` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As a result of this refactoring, any code that called the `CalculatePrice` method
    now calculates and passes a value for `isHoliday` to the method.
  prefs: []
  type: TYPE_NORMAL
- en: I find that **Introduce parameter** is particularly helpful for letting a method
    focus on just a few key pieces of logic.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be very helpful in places where you have very similar methods of
    doing similar things but only differing by a few key details. It can sometimes
    be possible to merge many different methods into a single method that takes in
    a few details as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code might perform logging for different actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Fee.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These two methods both take in a numeric fee and write the charge name and charged
    fee to the console. In fact, the only way they differ is the charge name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code could be consolidated into a single method by introducing a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Never underestimate the value of making a method more generalized by having
    outside code provide additional details.
  prefs: []
  type: TYPE_NORMAL
- en: With the charge logic largely improved, let’s move on to the final method in
    the code that has several warnings associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unreachable and unused code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you opened the beginning code from this chapter in Visual Studio, you would
    likely notice that `CalculatePriceFlat` and a few variables inside it appear in
    gray with a number of wavy underscore suggestions as shown in *Figure 2**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The CalculatePriceFlat method with gray text for many lines
    of code](img/B21324_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The CalculatePriceFlat method with gray text for many lines of
    code
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio can sometimes detect when variables, parameters, and even methods
    are not being used. If it does so, Visual Studio usually renders these identifiers
    in more muted tones and often includes suggestions to investigate or remove these
    items.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, nothing is ever calling the `CalculatePriceFlat` method, and nothing
    is referencing the `numBags` parameter. The `total` variable is declared and given
    a value but is never read from after that, and the final `return` line is unreachable
    given the return line above it.
  prefs: []
  type: TYPE_NORMAL
- en: Each one of these issues can be addressed with a *remove unused member*, *remove
    unused variable*, or *remove unreachable* *code* refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these refactorings do what you’d expect: they remove the offending code.'
  prefs: []
  type: TYPE_NORMAL
- en: Since nothing is calling the method at all, the entire method can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unused parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s another piece of code from earlier that can be removed as well: the
    `CalculatePrice` method has a `travelTime` parameter that is no longer being used
    after we introduced the `isHoliday` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no *remove unused parameter* in Visual Studio at the time of writing,
    but you can remove it safely using some of the method-level refactorings we’ll
    discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this refactoring, select the `travelTime` parameter and then select
    **Change signature...** as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Changing the signature of a method](img/B21324_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Changing the signature of a method
  prefs: []
  type: TYPE_NORMAL
- en: Clicking **Change signature…** will show the **Change** **Signature** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `travelTime` parameter and click **Remove**. The parameter will
    appear crossed out in the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The Change Signature dialog with travelTime removed](img/B21324_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – The Change Signature dialog with travelTime removed
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** and the dialog will close and the parameter will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that was referencing your method will also have their signatures updated
    to not pass anything for the `travelTime` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding pitfalls when removing code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One cautionary note on removing code: be particularly careful about removing
    `public` members from code. Sometimes Visual Studio is not aware of all the places
    using code. This is particularly true for serialization/deserialization logic,
    properties that exist for data binding, and members that are accessed using reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if your code is being deployed as a **NuGet package** or otherwise
    being shared in other projects, it is possible that code outside of your solution
    may depend on a method or parameter, and your change could cause their code to
    no longer compile.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder on testing
  prefs: []
  type: TYPE_NORMAL
- en: It is *your* responsibility to test any refactorings you make and ensure they
    do not bring about unintended changes in program behavior.
  prefs: []
  type: TYPE_NORMAL
- en: That may sound scary, but don’t let these edge cases stop you from removing
    dead code.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve known a number of developers hesitant to remove code in case they need
    it later. Instead, these developers will either keep the code there untouched
    or comment the entire block of code out.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with commenting out dead code is that it increases the amount of
    distracting and unhelpful comments in a file. This reduces the amount of importance
    developers place on the comments that are present and also increases the amount
    of scrolling the developers must do.
  prefs: []
  type: TYPE_NORMAL
- en: Delete dead code. Your code should be in source control anyway, so if you really
    need to find the code later, you can look at the history to recover it – assuming,
    of course, you checked the code into source control to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our code is now looking fairly clean, but the `CalculatePrice` method has a
    lot of logic in it for the checked baggage price calculation.
  prefs: []
  type: TYPE_NORMAL
- en: This logic is complex enough for us to extract a method just for this logic
    and call that method from our existing code.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, select the lines of code that represent the method you want to extract.
    Be mindful of the various `{}` instances that you select, as your selection must
    make sense as a related block of code to Visual Studio. See the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Extracting a method from a block of code](img/B21324_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Extracting a method from a block of code
  prefs: []
  type: TYPE_NORMAL
- en: Once your block of code is selected, open the **Quick Actions** menu, choose
    **Extract Method**, and then name the method in the prompt before pressing *Enter*
    to confirm your name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Naming the extracted method](img/B21324_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Naming the extracted method
  prefs: []
  type: TYPE_NORMAL
- en: 'This will result in a new method being added to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that Visual Studio will make the method `private` by default and will mark
    the method as `static` if it does not access instance members on the class.
  prefs: []
  type: TYPE_NORMAL
- en: I generally prefer `private` methods, but your preferences on `static` may vary
    depending on what method you’re working with and whether it makes sense for the
    method to ultimately be `static`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extract method refactoring also removes the code from the original method
    and replaces it with a call to the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This results in a much more concise and readable **CalculatePrice method** and
    makes it easier to think about everything the method is doing. This reduced complexity
    greatly improves the long-term quality of the method by helping developers fully
    understand the method and avoids costly mistakes that can occur when maintaining
    complex blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we’ve performed a number of refactoring operations supported
    by Visual Studio. These have been fairly safe given the quality of the tools we’ve
    used, but there are some things the built-in tools just won’t do.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio is powerful, but it can’t think about code like a human can (despite
    the exciting new AI features we’ll talk about in [*Chapter 11*](B21324_11.xhtml#_idTextAnchor236),
    *AI-Assisted Refactoring with GitHub* *Copilot Chat*).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes there will be opportunities to improve the code that no built-in refactoring
    can perform for you. At those points, you’ll have to make the changes manually.
  prefs: []
  type: TYPE_NORMAL
- en: The `ApplyCheckedBagFee` method we extracted earlier is a good method, but a
    few things could be improved.
  prefs: []
  type: TYPE_NORMAL
- en: First, the method takes in a total, increases it by a fee, and then returns
    that new total. It’d be easier for others to understand the method if the method
    returned the fee instead of the adjusted total.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the method is performing the same `Console.WriteLine` operation twice.
    Additionally, all other `WriteLine` statements in the class are in the `CalculatePrice`
    method, making the user interface slightly hard to fully trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the method so that it returns only the fee, doesn’t require the
    `total` parameter, and doesn’t log anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll need to update the code that calls this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result is stored in a `bagFee` variable, `total` is no longer
    passed to `ApplyCheckedBagFee`, and `Console.WriteLine` now appears here in this
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `ApplyCheckedBagFee` name might not apply anymore since the
    method no longer actually applies the fee, but rather calculates it. In this case,
    applying the *rename method* refactoring would help the final code have a more
    appropriate name.
  prefs: []
  type: TYPE_NORMAL
- en: Testing refactored code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned earlier, it is *your responsibility* to ensure that your refactoring
    efforts have not altered how the system fundamentally behaves.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, this means that `BaggageCalculator` should still calculate the
    same prices it did before for any valid set of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: One of the many tools we have at our disposal for determining whether code still
    meets our needs is running **unit tests**.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk more about unit tests in [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133),
    *Unit Testing*, but for now, know that unit tests are code that verifies that
    other code is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '`BaggageCalculator` has five tests that can be run by clicking on the **Test**
    menu and then choosing **Run** **All Tests**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Test Explorer** window should show all tests as passing with green check
    marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Five passing tests in Test Explorer](img/B21324_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Five passing tests in Test Explorer
  prefs: []
  type: TYPE_NORMAL
- en: If a test is now failing and didn’t fail before, this is a good thing, since
    it means the test found an issue you caused in the code’s behavior. Investigate
    the failing test and then resolve the issue before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore testing in much more detail in *Part 2* of this book, but as it
    stands, it appears that our refactorings have been successful.
  prefs: []
  type: TYPE_NORMAL
- en: Final code
  prefs: []
  type: TYPE_NORMAL
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    repository, inside the `Chapter02/Ch2FinalCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The code we produced in this chapter is simple, readable, and maintainable.
    Certainly, there are things that could still be improved, but the code is less
    likely to cause issues as it grows in complexity in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring in other editors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we end the chapter, let’s talk about refactoring in editors other than
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book primarily focuses on refactoring in Visual Studio because that’s
    the current primary development environment for .NET developers. However, there
    are a few other editors and extensions that are frequently used for .NET development
    and offer refactoring support:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual** **Studio Code**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JetBrains Rider**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JetBrains ReSharper** (Visual Studio Extension)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools will not be featured in examples throughout the remainder of the
    book since Visual Studio is the primary editing experience. However, most of what
    I’ll show you in the remainder of the book is also possible using these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring in Visual Studio Code with the C# Dev Kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**) is rapidly becoming a highly capable editing
    environment for .NET projects with its C# extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Where VS Code really comes into its own is with the newer **C# Dev Kit**, which
    gives an editing experience almost identical to Visual Studio, including the solution
    explorer. The C# Dev Kit integrates with the other C# extensions to provide code
    suggestions and refactoring **Quick Actions** with the same style of light bulb
    icons you see in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Refactoring with the C# Dev Kit in VS Code](img/B21324_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Refactoring with the C# Dev Kit in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: VS Code won’t give you the full set of refactoring options Visual Studio currently
    does, but it is cross-platform and will work on Mac and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing note
  prefs: []
  type: TYPE_NORMAL
- en: VS Code is free, but the C# Dev Kit extension requires a paid Visual Studio
    license key.
  prefs: []
  type: TYPE_NORMAL
- en: I expect we’ll see VS Code featured much more prominently in .NET development
    with the improvements from the C# Dev Kit and VS Code’s cross-platform capabilities,
    along with its ability to run in-browser to some extent through **GitHub Codespaces**.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring in JetBrains Rider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JetBrains Rider is a separate editor developed on the same set of editing software
    used by the popular **IntelliJ** Java editor.
  prefs: []
  type: TYPE_NORMAL
- en: Rider works with most .NET projects and has a fantastic set of refactoring capabilities
    built in. These capabilities will often be similar to those mentioned in this
    book, but the exact naming and user experience will be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Refactoring in JetBrains Rider](img/B21324_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Refactoring in JetBrains Rider
  prefs: []
  type: TYPE_NORMAL
- en: Like VS Code, one major advantage Rider has over Visual Studio is that it is
    fully cross-platform and can run on macOS or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring in Visual Studio with ReSharper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you love working with Visual Studio but want the same rich set of refactorings
    that Rider offers, JetBrains also offers a Visual Studio extension called **ReSharper**.
  prefs: []
  type: TYPE_NORMAL
- en: ReSharper replaces many Visual Studio features with enhanced versions, including
    Visual Studio’s code analysis and refactoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Refactoring with ReSharper in Visual Studio](img/B21324_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Refactoring with ReSharper in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, Visual Studio tends to have most of the refactoring capabilities ReSharper
    and Rider offer, but the capabilities of ReSharper and Rider can sometimes be
    a bit more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we explored refactoring by taking a class with a bit
    of complexity and applied targeted refactorings to make it easier to read, maintain,
    and expand.
  prefs: []
  type: TYPE_NORMAL
- en: We went from a modestly complex class to a relatively simple one by following
    a set of repeatable actions that transformed the code from one form to another
    without changing its overall behavior or result.
  prefs: []
  type: TYPE_NORMAL
- en: Although Visual Studio supports very capable refactoring tools, it is up to
    you as an experienced developer to know when you might want to apply each individual
    refactoring, based on the current level of complexity of your code and the code
    smells you’re observing.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next three chapters, we’ll explore the built-in refactorings in more
    depth by exploring refactorings related to methods, classes, and individual lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are some ways of triggering Quick Actions for a block of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does Visual Studio ever indicate that refactorings are possible or recommended?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you know what a Quick Action will do before performing it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are Visual Studio Quick Actions the only way to refactor code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about refactoring in Visual Studio and other
    environments at these URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Quick Actions* *Overview*: [https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions](https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JetBrains Rider vs Visual Studio (with and without* *ReSharper)*: [https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/](https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Announcing C# Dev Kit for Visual Studio* *Code*: [https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/](https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
