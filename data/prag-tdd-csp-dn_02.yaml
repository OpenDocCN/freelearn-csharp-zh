- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding Dependency Injection by Example
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例理解依赖注入
- en: '**Dependency injection** (**DI**) is a software design pattern that exists
    in every modern architecture. However, you may wonder how this pattern found its
    way into the second chapter of a **test-driven development** (**TDD**)-focused
    book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种存在于每个现代架构中的软件设计模式。然而，你可能想知道这种模式是如何进入一本以**测试驱动开发**（**TDD**）为重点的书的第二章的。'
- en: DI is a pattern that has several benefits that we are going to discover throughout
    the book, though the core benefit is that *DI opens an application for unit testing*.
    We cannot exercise unit testing without a solid understanding of this pattern,
    and if we cannot unit test, by virtue, we cannot practice TDD. Considering this,
    DI understanding forms the foundation of *Section 1*, *Getting Started and Basics*,
    and *Part 2*, *Building an Application with TDD*, which explains the early introduction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: DI是一种具有几个我们在整本书中将要发现的优点的设计模式，但其核心优点是**DI为单元测试打开了应用程序**。没有对这个模式有坚实的理解，我们就无法进行单元测试，而如果不能进行单元测试，那么根据定义，我们就无法实践TDD。考虑到这一点，DI的理解构成了*第1节*，“开始和基础知识”以及*第2部分*，“使用TDD构建应用程序”的基础，这解释了早期引入的原因。
- en: We will build an application and then modify it to support DI while learning
    the concepts, but the ideas in this chapter will be repeated and exercised throughout
    this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，然后在学习概念的同时修改它以支持DI，但本章中的思想将在整本书中重复和练习。
- en: 'In this chapter, you will be exploring these topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探索以下主题：
- en: The **weather forecaster application** (**WFA**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天气预报应用程序**（**WFA**）'
- en: Understanding dependency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖
- en: Introducing DI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍DI
- en: Using DI containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DI容器
- en: By the end of this chapter, the application will be unit test-ready by having
    the necessary DI changes implemented. You will have a fair understanding of dependency
    and will have gained confidence in refactoring code to support DI. You will have
    also covered half the way to write your first proper unit test.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，应用程序将通过实施必要的DI更改而准备好进行单元测试。您将对依赖关系有一个公平的理解，并将对重构代码以支持DI充满信心。您也将完成了编写第一个正确单元测试的一半。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch02](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch02)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch02](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch02)'
- en: There, you will find four directories. Each one will be a snapshot of our progress.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您将找到四个目录。每个目录都将是我们进展的快照。
- en: The WFA
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WFA
- en: Throughout this chapter, we will be using an **ASP.NET Web API** application
    in our learning process. We will be refactoring all the code in this application
    to enable DI. Then, in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066), *Getting
    Started with Unit Testing*, we will apply unit tests on the refactored application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将使用一个**ASP.NET Web API**应用程序作为我们的学习过程。我们将重构该应用程序中的所有代码以启用DI。然后，在[*第3章*](B18370_03.xhtml#_idTextAnchor066)，“开始单元测试”，我们将对重构后的应用程序应用单元测试。
- en: When a new ASP.NET Web API application is created, it comes with a sample random
    weather forecaster. The application in this chapter will build on top of the original
    weather sample and will add a real weather forecasting capability to the existing
    random one. We will creatively call our application the WFA.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的ASP.NET Web API应用程序时，它自带一个示例随机天气预报器。本章中的应用程序将基于原始的天气示例，并添加一个真实的天气预报功能到现有的随机功能中。我们将我们的应用程序称为WFA。
- en: The first step is going to be creating a WFA application and making sure it
    is running.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是创建一个WFA应用程序并确保它正在运行。
- en: Creating a sample weather forecaster
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个示例天气预报
- en: 'To create a sample application, navigate your console to the directory where
    you want to create this application and execute the following commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个示例应用程序，请将您的控制台导航到您想要创建此应用程序的目录，并执行以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code will create a `UqsWeather` and will add an ASP.NET Web API
    project to it. This will produce a similar output to this console window:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建一个`UqsWeather`并将一个ASP.NET Web API项目添加到其中。这将产生与这个控制台窗口类似的输出：
- en: '![Figure 2.1 – The output of creating a weather application via the command-line
    interface (CLI) ](img/Figure_2.1_B18370.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 通过命令行界面 (CLI) 创建天气应用程序的输出](img/Figure_2.1_B18370.jpg)'
- en: Figure 2.1 – The output of creating a weather application via the command-line
    interface (CLI)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 通过命令行界面 (CLI) 创建天气应用程序的输出
- en: 'To check what we have created, go to the directory and open the solution using
    VS, and you will see the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们创建的内容，请转到目录并使用 VS 打开解决方案，你将看到以下内容：
- en: '![Figure 2.2 – Newly created project opened in VS ](img/Figure_2.2_B18370.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 在 VS 中打开的新创建的项目](img/Figure_2.2_B18370.jpg)'
- en: Figure 2.2 – Newly created project opened in VS
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 在 VS 中打开的新创建的项目
- en: 'What is interesting here is the sample files that were generated automatically:
    `WeatherForecast Controller.cs` and `WeatherForecast.cs`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是自动生成的示例文件：`WeatherForecast Controller.cs` 和 `WeatherForecast.cs`。
- en: 'This is the default template; we haven’t done any modification yet. It would
    make sense to check whether, so far, the application is loading properly. You
    can run the application and it will launch your default browser with the Swagger
    UI interface. We can see the only available `GET` `WeatherForecast`, as illustrated
    in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认模板；我们还没有进行任何修改。检查到目前为止应用程序是否正确加载是有意义的。你可以运行应用程序，它将启动你的默认浏览器并显示 Swagger UI
    界面。我们可以看到唯一的可用 `GET` `WeatherForecast`，如下面的截图所示：
- en: '![Figure 2.3 – Swagger UI showing the available GET API ](img/Figure_2.3_B18370.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – Swagger UI 显示可用的 GET API](img/Figure_2.3_B18370.jpg)'
- en: Figure 2.3 – Swagger UI showing the available GET API
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Swagger UI 显示可用的 GET API
- en: 'To manually call this API and check whether it is generating output, from the
    Swagger UI page, expand the down arrow on the right of **/WeatherForecast**. Hit
    **Try it out**. Then, hit **Execute**. You will get a response like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动调用此 API 并检查它是否生成输出，从 Swagger UI 页面，展开 **/WeatherForecast** 右侧的下箭头。点击 **Try
    it out**。然后，点击 **Execute**。你将得到如下所示的响应：
- en: '![Figure 2.4 – Swagger API call response ](img/Figure_2.4_B18370.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Swagger API 调用响应](img/Figure_2.4_B18370.jpg)'
- en: Figure 2.4 – Swagger API call response
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Swagger API 调用响应
- en: You can find this sample under the GitHub chapter directory, in a directory
    called `01-UqsWeather`. Now, it’s time to make the application a bit realistic
    by adding a real forecasting feature.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 章节目录下的 `01-UqsWeather` 目录中找到这个示例。现在，是时候通过添加真实预报功能使应用程序更加真实了。
- en: Adding a real weather forecaster
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加真实天气预报
- en: The template app has a sample random weather generator. I decided to give the
    app a spin by adding a real weather forecast as well. For this, I am going to
    use a weather service called *OpenWeather*. *OpenWeather* provides a free RESTful
    API weather service (where **REST** stands for **REpresentational State Transfer**)
    and will act as a more realistic example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模板应用程序包含一个示例随机天气生成器。我决定给这个应用程序添加一些真实天气预报的功能。为此，我将使用一个名为 *OpenWeather* 的天气服务。*OpenWeather*
    提供了一个免费的 RESTful API 天气服务（其中 **REST** 代表 **REpresentational State Transfer**），并将作为一个更真实的示例。
- en: I have also created a public NuGet package to serve the chapter and act as a
    client for the *OpenWeather* RESTful APIs. So, rather than dealing with the REST
    API calls, you call a C# method, and it does the RESTful API calls in the background.
    In the following sections, we will obtain an API key and write the `GetReal` API.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我还创建了一个公共 NuGet 包，用于提供本章内容，并作为 *OpenWeather* RESTful API 的客户端。因此，你不需要处理 REST
    API 调用，而是调用一个 C# 方法，它会在后台执行 RESTful API 调用。在接下来的章节中，我们将获取一个 API 密钥并编写 `GetReal`
    API。
- en: Getting an API key
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 API 密钥
- en: 'To be able to run the application from the companion source code or to create
    one yourself, you need an API key. You can sign up at [https://openweathermap.org](https://openweathermap.org)
    and then obtain an API key. After signing up, you can generate a key by going
    to **My API keys** and hitting **Generate**, similar to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够从配套源代码运行应用程序或自己创建一个，你需要一个 API 密钥。你可以在 [https://openweathermap.org](https://openweathermap.org)
    上注册并获取一个 API 密钥。注册后，你可以通过访问 **My API keys** 并点击 **Generate** 来生成密钥，类似于以下示例：
- en: '![Figure 2.5 – Generating an API key ](img/Figure_2.5_B18370.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 生成 API 密钥](img/Figure_2.5_B18370.jpg)'
- en: Figure 2.5 – Generating an API key
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 生成 API 密钥
- en: 'Once you have obtained the key, save it in your `appsettings.json` file, like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了密钥，将其保存在你的 `appsettings.json` 文件中，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The API key is done. Let’s get a client library to access the API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥已生成。让我们获取一个客户端库来访问 API。
- en: Getting the client NuGet package
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取客户端 NuGet 包
- en: There are many OpenWeather API client libraries; however, I chose to create
    one to specifically fit the requirements of this chapter. The code of the package
    and how it is tested are discussed in [*Appendix 2*](B18370_15.xhtml#_idTextAnchor326),
    *Advanced Mocking Scenarios*. If you are curious and would like to check the source
    code, you can visit its GitHub repository at [https://github.com/AdamTibi/OpenWeatherClient](https://github.com/AdamTibi/OpenWeatherClient).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多OpenWeather API客户端库；然而，我选择创建一个专门符合本章要求的库。包的代码及其测试方法在[*附录2*](B18370_15.xhtml#_idTextAnchor326)中讨论，*高级模拟场景*。如果你好奇并想查看源代码，你可以访问其GitHub仓库[https://github.com/AdamTibi/OpenWeatherClient](https://github.com/AdamTibi/OpenWeatherClient)。
- en: 'You can install the NuGet package via the VS `AdamTibi.OpenWeather` or via
    the .NET CLI, by going to the project directory and writing this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过VS中的`AdamTibi.OpenWeather`或通过.NET CLI安装NuGet包，方法是进入项目目录并编写以下内容：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The configuration is done, so now, we can modify the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 配置已完成，因此现在我们可以修改代码。
- en: Mapping feeling to temperature
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将感觉映射到温度
- en: 'Here is a simple method that will map the temperature in °C to a single word
    describing it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的方法，将°C的温度映射到一个描述它的单个单词：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output for `0` or less is `Freezing`, between `0` and `5` it is `Bracing`,
    then it is going to change every `5` degrees. `45` degrees onward, it is `Scorching`.
    Don’t take my word for the output—we will unit test it. Imagine if we didn’t!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`0`或更低的输出是`Freezing`，在`0`到`5`之间是`Bracing`，然后每`5`度就会改变一次。从`45`度开始，就是`Scorching`。不要只相信我的输出——我们将进行单元测试。想象一下如果我们没有这样做会怎样！
- en: Random weather API
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机天气API
- en: 'I kept the random weather API, but I made it use the preceding `MapFeelToTemp`
    string, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我保留了随机天气API，但我让它使用前面的`MapFeelToTemp`字符串，如下所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a trivial API generating a random temperature and then making a summary
    out of the generated temperature. We are generating `FORECAST_DAYS = 5` days,
    starting from the next day.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成随机温度并对其做出总结的简单API。我们正在生成`FORECAST_DAYS = 5`天的预测，从第二天开始。
- en: 'Running this project and hitting the Swagger UI output will give us this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此项目并点击Swagger UI输出将给我们以下结果：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see how random the output is, as the next day is hot but the day after
    is freezing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到输出是多么随机，因为第二天很热，但第三天就非常冷。
- en: Real weather API
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实天气API
- en: 'The real weather API should make more sense. This is the newly added API:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 真实天气API应该更有意义。这是新添加的API：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method creates a `HttpClient` class for the sake of passing it to the *OpenWeather*
    `Client` class. It then fetches the API key and creates an *OpenWeather* `Client`
    class. To limit our scope, this will only forecast for Greenwich, London.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个`HttpClient`类，以便将其传递给*OpenWeather*的`Client`类。然后它获取API密钥并创建一个*OpenWeather*的`Client`类。为了限制我们的范围，这将只为格林威治，伦敦进行预测。
- en: Important Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The previous code is not clean and will be cleaned shortly in this chapter.
    If you really want to know the reason right now, it is instantiating (newing)
    the `HttpClient` and the `Client` classes in the controller, and this is not a
    good practice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码不够整洁，将在本章中稍后进行清理。如果你现在真的想了解原因，那就是在控制器中实例化（新建）`HttpClient`和`Client`类，这不是一个好的做法。
- en: 'We are calling a RESTful API of *OpenWeather* called **OneCall**. This API
    returns today’s weather and forecasts 6 consecutive days; this is good as we only
    need the next 5 consecutive days. The Swagger UI output of this one is shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在调用名为*OpenWeather*的RESTful API的**OneCall**。此API返回今天的天气并预测接下来的6天；这对于我们只需要接下来的5天来说很好。此API的Swagger
    UI输出如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The best way to explain concepts is by example, so consider this test problem
    that will give you a firsthand experience of what DI is.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过例子解释概念是最好的方法，所以考虑这个测试问题，它将给你一个亲身体验DI（依赖注入）的机会。
- en: C to F conversion API
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C到F转换API
- en: 'To have all the world come together and to keep everybody happy, we will add
    another method to convert °C to °F. We will have an API on our controller called
    `ConvertCToF`, and it looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让全世界团结起来并让每个人都开心，我们将添加另一个方法将°C转换为°F。我们将在控制器上有一个名为`ConvertCToF`的API，它看起来像这样：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This API converts a temperature from °C to °F and logs every time this API
    is requested, for statistical purposes. You can invoke this API from Swagger UI
    as before, or invoke it from the browser like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此API将温度从°C转换为°F，并记录每次请求此API的情况，用于统计目的。你可以像以前一样从Swagger UI调用此API，或者从浏览器中这样调用它：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '![Figure 2.6 – Results of executing the ConvertCToF API from the browser ](img/Figure_2.6_B18370.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 从浏览器执行ConvertCToF API的结果](img/Figure_2.6_B18370.jpg)'
- en: Figure 2.6 – Results of executing the ConvertCToF API from the browser
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 从浏览器执行ConvertCToF API的结果
- en: 'This is a **Unified Modeling Language** (**UML**) diagram showing what we have
    so far:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**统一建模语言**（**UML**）图，显示了到目前为止我们所拥有的内容：
- en: '![Figure 2.7 – UML diagram showing the WFA application ](img/Figure_2.7_B18370.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 显示WFA应用的UML图](img/Figure_2.7_B18370.jpg)'
- en: Figure 2.7 – UML diagram showing the WFA application
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 显示WFA应用的UML图
- en: You can see all the changes in `WeatherForecastController.cs`; it is always
    in the `Ch02` source code in GitHub under a directory called `02-UqsWeather`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`WeatherForecastController.cs`中看到所有更改；它始终位于GitHub上的`Ch02`源代码中，在名为`02-UqsWeather`的目录下。
- en: The application is ready for critique, and I can tell you from now that the
    code you’ve just seen is not unit-testable. We can perform other categories of
    testing, but not unit testing, although it will be unit-testable by the end of
    this chapter. I invite you to open the project in VS and follow along, as we will
    implement exciting and important concepts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已准备好接受批评，现在我可以告诉你，你刚刚看到的代码是不可进行单元测试的。我们可以执行其他测试类别，但不能进行单元测试，尽管到本章结束时它将是可进行单元测试的。我邀请你打开项目在VS中跟随，因为我们将实现令人兴奋且重要的概念。
- en: Now that the project is ready, we need to set some basics right, and the first
    in the list is understanding dependency.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已准备好，我们需要做一些基本设置，列表中的第一项是理解依赖项。
- en: Understanding dependency
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖项
- en: If your code does something useful, chances are your code depends on other code
    or another component, which in turn depends on another component. A clear understanding
    of the **dependency** terminology should give you a better grasp of unit testing
    and will definitely aid in having clearer conversations with your colleagues.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码做了些有用的事情，那么你的代码很可能依赖于其他代码或另一个组件，而这个组件反过来又依赖于另一个组件。对**依赖项**术语的清晰理解应该会帮助你更好地掌握单元测试，并肯定有助于与同事进行更清晰的交流。
- en: The plan in this section is to familiarize you with the concept of dependency,
    which should make understanding the DI pattern easier. Understanding dependency
    and DI are prerequisites for writing any serious unit testing. Next, we will explore
    what dependencies are, though when it comes to unit testing, we don’t care for
    all dependencies, so we will define what a relevant dependency is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的计划是使你熟悉依赖项的概念，这应该会使理解DI模式更容易。理解依赖项和DI是编写任何严肃单元测试的先决条件。接下来，我们将探讨依赖项是什么，尽管在单元测试方面，我们并不关心所有依赖项，因此我们将定义相关依赖项是什么。
- en: Before we dive into dependencies, let’s first define abstraction types and concrete
    types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入依赖项之前，让我们首先定义抽象类型和具体类型。
- en: Abstractions and concrete types
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类型和具体类型
- en: To have you and me on the same channel, I will define the terminology to be
    used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们处于同一频道，我将定义将要使用的术语。
- en: 'A concrete class is a class that can be instantiated; it could be something
    like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具体类是可以实例化的类；它可能像这样：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`FileStream` is a concrete type that can be instantiated and used directly
    in the code.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`是一个具体类型，可以在代码中直接实例化和使用。'
- en: An abstraction type can be an abstract class or an interface. Examples of abstract
    classes are `Stream`, `ControllerBase`, and `HttpContext`. Examples of interfaces
    are `IEnumerable`, `IDisposable`, and `ILogger`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型可以是抽象类或接口。抽象类的例子有`Stream`、`ControllerBase`和`HttpContext`。接口的例子有`IEnumerable`、`IDisposable`和`ILogger`。
- en: I will be overusing these terms in the book, so it’s worth defining them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在书中过度使用这些术语，所以值得定义它们。
- en: What is a dependency?
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是依赖项？
- en: 'First, what it isn’t: it is not equivalent to the same term used in UML.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它不是什么：它不等于在UML中使用的相同术语。
- en: 'In this book’s context and when speaking with other developers within unit
    testing boundaries, it can be defined in this way: if class A *uses* a type of
    B where B is an abstraction type or a concrete class, then A has a dependency
    on B.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的上下文中，以及与其他开发者在单元测试边界内交谈时，可以这样定义：如果类A *使用* 类型B，其中B是抽象类型或具体类，那么A依赖于B。
- en: 'The term *uses* can be narrowed down to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *使用* 可以缩小到以下内容：
- en: 'B is passed to the constructor of A. Example from WFA: the logger is passed
    to the controller’s constructor, which makes `ILogger<WeatherForecastController>`
    a dependency, as illustrated here:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B被传递给A的构造函数。WFA中的例子：记录器被传递给控制器的构造函数，这使得`ILogger<WeatherForecastController>`成为一个依赖关系，如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'B is passed to a method in A, as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B被传递给A中的方法，如下所示：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'B has a static method that is called from a method in A. Example from WFA:
    `DateTime.Now` is called from `GetRandom`, which makes `DateTime` a dependency,
    as illustrated here:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B有一个静态方法，该方法从A的方法中调用。WFA中的例子：`DateTime.Now`在`GetRandom`中被调用，这使得`DateTime`成为一个依赖关系，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'B is instantiated anywhere inside A, whether instantiated in a method, in a
    field, or in a property. In the following example, `HttpClient` is instantiated
    in the code:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B在任何A内部的地方被实例化，无论是在方法中、字段中还是在属性中。在以下示例中，`HttpClient`在代码中被实例化：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Based on this definition, we have all of the following as dependencies on `WeatherForecast
    Controller`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，以下所有内容都是`WeatherForecast Controller`的依赖关系：
- en: '`Random`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Random`'
- en: '`DateTime`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`'
- en: '`Client`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`'
- en: '`HttpClient`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`'
- en: '`ILogger<WeatherForecastController>`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILogger<WeatherForecastController>`'
- en: '`IConfiguration`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConfiguration`'
- en: '`WeatherForecast`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeatherForecast`'
- en: '**Data transfer objects** (**DTOs**) are not considered dependencies, although
    they look like concrete classes, but they act as a vehicle to carry data from
    one place to another. We will show an example of a DTO in the *The WeatherForecast
    class dependency* section.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据传输对象**（**DTOs**）不被视为依赖关系，尽管它们看起来像具体的类，但它们充当从一地到另一地传输数据的载体。我们将在*WeatherForecast类依赖关系*部分展示一个DTO的例子。'
- en: Note that `record`, `record struct`, and `struct` usually follow the same concept
    as a DTO.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`record`、`record struct`和`struct`通常遵循与DTO相同的概念。
- en: We will have more analysis of dependencies across *Part 1*, *Getting Started
    and Basics*, and *Part 2*, *Building an Application with TDD*. For an experienced
    TDD practitioner, spotting dependencies is second nature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对跨越第一部分*入门和基础*和第二部分*使用TDD构建应用程序*的依赖关系进行更多分析。对于有经验的TDD实践者来说，发现依赖关系是第二本能。
- en: Dependency relevance
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖关系相关性
- en: Dependencies lead our class to interact with components external to our code.
    A dependency is relevant for DI in the context of unit testing if it has a method
    or a property that might cause a side effect when triggered or when it leads to
    other behavior that is not very relevant to the class being tested.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系使我们的类与代码外部的组件进行交互。在单元测试的上下文中，如果依赖关系有一个在触发时或导致其他与被测试类不太相关的行为时可能引起副作用的方法或属性，则该依赖关系与DI相关。
- en: This is an overloaded definition, and it is not meant to be all clear at this
    point. Examples will be provided from here until the end of *Part 2* to show when
    a dependency is relevant.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个过载的定义，并不打算在这个阶段完全清晰。从现在开始直到第二部分的结束，我们将提供一些例子来展示何时依赖关系是相关的。
- en: We care for pinpointing a dependency if we want to change its behavior when
    testing it. If `_logger.LogInformation` is writing to the disk, we want sometimes
    to change this behavior, especially when testing. As always, clarifying with examples
    is best, so in this section, we will demonstrate multiple examples and explain
    why they are relevant.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在测试时改变其行为，我们会关注定位依赖关系。如果`_logger.LogInformation`正在写入磁盘，我们有时会改变这种行为，尤其是在测试时。像往常一样，用例子来说明是最好的，因此在本节中，我们将展示多个示例并解释为什么它们是相关的。
- en: The logging dependency
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录依赖关系
- en: 'Consider this `_logger` field:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个`_logger`字段：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'During the application lifespan, the `_logger` field might be triggered to
    write logs. Depending on the configuration of the logger, it might write logs
    in memory, in the console while debugging, in a log file on the disk, in the database,
    or on a cloud service such as `_logger` field when we log in the `ConvertCToF`
    method, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的生命周期中，`_logger`字段可能会被触发以写入日志。根据记录器的配置，它可能会在内存中、调试时的控制台、磁盘上的日志文件、数据库或云服务（例如在`ConvertCToF`方法中记录`_logger`字段时）中写入日志，如下所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*It is relevant* because we have a side effect that will extend to other components
    in the system, and when unit testing at a later stage, we want to eliminate this
    side effect.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*它是相关的*，因为我们有一个副作用会扩展到系统中的其他组件，并且在稍后的单元测试阶段，我们希望消除这个副作用。'
- en: The configuration dependency
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置依赖关系
- en: 'There is another field in the class, the `_config` field, as illustrated here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类中还有一个字段，即`_config`字段，如下所示：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `_config` field is needed to get the API key from the configuration. It
    is passed through the constructor of the controller class, similar to the `_logger`
    field.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`_config` 字段是必需的，用于从配置中获取 API 密钥。它通过控制器类的构造函数传递，类似于 `_logger` 字段。'
- en: 'During runtime `_config` can load configuration based on configuration; pun
    not intended. Your configuration can be in the cloud, in `appsettings`, or in
    a custom format. We can see this dependency in use here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时 `_config` 可以根据配置加载配置；这不是字面意义上的双关语。您的配置可以位于云端、`appsettings` 或自定义格式中。我们可以在以下示例中看到这个依赖项的使用：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*It is relevant* as we need to go through the configuration to read the API
    key. Accessing configuration is also causing a side effect.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是相关的*，因为我们需要通过配置来读取 API 密钥。访问配置也会产生副作用。'
- en: The HTTP dependency
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 依赖
- en: 'Digging through the code, you find that we have instantiated `HttpClient` and
    used it in the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中深入挖掘，你会发现我们实例化了 `HttpClient` 并在代码中使用它：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is obvious that we have a dependency on `GetReal` API, is invoked, it issues
    an HTTP call.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们依赖于 `GetReal` API，它被调用，它发出 HTTP 请求。
- en: Unlike the logging and configuration dependencies, where the dependency is built
    against an abstraction (`IConfiguration` and `ILogging<>`), `httpClient` is instantiated
    in the code—this makes what is called a **hard** or a **concrete dependency**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与日志和配置依赖项不同，其中依赖项是对抽象（`IConfiguration` 和 `ILogging<>`）的构建，`httpClient` 在代码中被实例化——这被称为**硬**或**具体依赖**。
- en: We do care about the distinction between instantiating a dependency in code
    or passing it from outside, through the constructor. It’ll be clear why later
    on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实关心在代码中实例化依赖项或从外部通过构造函数传递依赖项之间的区别。稍后我们会清楚为什么。
- en: '*It is relevant* as we don’t want to depend on the network while we are testing.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是相关的*，因为我们不希望在测试时依赖网络。'
- en: The OpenWeather client dependency
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenWeather 客户端依赖
- en: 'The OpenWeather client is a dependency on a dependency. It is a dependency
    itself and it is relying on the HTTP dependency, represented by `httpClient`,
    as well. You can see this in the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeather 客户端是一个依赖项的依赖项。它本身也是一个依赖项，并且它依赖于由 `httpClient` 表示的 HTTP 依赖项。您可以在以下代码片段中看到这一点：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, this is another example of a concrete dependency as it is being instantiated
    inline.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这也是另一个具体的依赖项的例子，因为它是在行内实例化的。
- en: '*It is relevant* as we don’t want to depend on HTTP (or the network) while
    we are testing.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是相关的*，因为我们不希望在测试时依赖 HTTP（或网络）。'
- en: The time dependency
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间依赖
- en: 'Consider this line in the code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码行：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What is important here is the `Now` property. `Now` has code that will call
    the `Now` property is static, as we can see here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是 `Now` 属性。`Now` 有代码会调用 `Now` 属性是静态的，正如我们在这里可以看到的：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The fact that this is static will make it slightly more difficult to deal with
    regarding DI, as we will see soon.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是静态的，它将使 DI（依赖注入）的处理稍微困难一些，正如我们很快就会看到的。
- en: '*It is relevant* as we want a predictable time during testing. Taking the current
    time will not lead to consistent results, as time is changing.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是相关的*，因为我们希望在测试时有一个可预测的时间。获取当前时间不会导致一致的结果，因为时间是在变化的。'
- en: The randomness dependency
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机性依赖
- en: 'This is an example of depending on an algorithm to generate randomness:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个依赖于算法生成随机性的例子：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Next` method is a static method as well and it is calling the time in the
    background to generate a seed; also, it is depending on a *randomization algorithm*.
    We want to control the outcome so that we can test it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Next` 方法也是一个静态方法，它在后台调用时间来生成种子；它还依赖于一个*随机化算法*。我们希望控制结果，以便我们可以对其进行测试。'
- en: '*It is relevant* as we want predictable output.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是相关的*，因为我们希望输出是可预测的。'
- en: The WeatherForecast class dependency
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 天气预报类依赖
- en: 'We are instantiating this class as a DTO, as we want to transfer the data from
    our method to the client. This data structure will be serialized into **JavaScript
    Object Notation** (**JSON**). The code is illustrated here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个类实例化为 DTO，因为我们想将数据从我们的方法传输到客户端。这个数据结构将被序列化为**JavaScript 对象表示法**（**JSON**）。代码如下所示：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*It is not relevant* as this object does not cause a side effect and it just
    carries data.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*这不相关*，因为这个对象不会产生副作用，它只是携带数据。'
- en: 'If the code depends on abstractions and the objects are not instantiated in
    the class (the controller in the previous example), then this is generally good.
    If the code depends on concrete classes that are instantiated in the class, then
    we are not following best practices as we are violating one good **object-oriented
    programming** (**OOP**) practice: *depend on abstraction, not concrete*. This
    will be our next topic.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码依赖于抽象并且对象没有在类中实例化（如前例中的控制器），那么这通常是好的。如果代码依赖于在类中实例化的具体类，那么我们就不是遵循最佳实践，因为我们违反了一个好的**面向对象编程**（**OOP**）实践：*依赖抽象，而非具体*。这将是我们的下一个主题。
- en: Depend on abstraction, not concrete
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖抽象，而非具体
- en: 'The title is popular advice in OOP best practices. This advice applies to two
    cases: the method signatures and the code inside the methods. We will explore
    both cases in this section.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题是面向对象编程最佳实践中的流行建议。这个建议适用于两种情况：方法签名和方法内部的代码。我们将在本节中探讨这两种情况。
- en: Abstracted parameters in the method signature
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法签名中的抽象参数
- en: When designing a method, including a class constructor, the advice is to check
    whether you can accept an abstracted type rather than a concrete type. As always,
    let’s explain this with examples.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计方法，包括类构造函数时，建议检查你是否可以接受一个抽象类型而不是一个具体类型。像往常一样，让我们用例子来解释这一点。
- en: 'For an example of an abstract class, take the well-known `Stream` class from
    .NET, as illustrated in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个抽象类的例子来说明，我们可以从.NET中著名的`Stream`类，如下代码片段所示：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `Stream` object represents a sequence of bytes, but the class doesn’t care
    about the physical source of the bytes—let it be from a file or from memory or
    others. This is the wisdom behind making it an abstract class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`对象代表一系列字节，但该类不关心字节物理来源——无论是来自文件还是来自内存或其他。这就是将其作为抽象类的原因。'
- en: 'We have `FileStream`, which inherits `Stream` as an example of a concrete class,
    as illustrated here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以`FileStream`为例，它继承自`Stream`，作为一个具体类的示例，如下所示：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`FileStream` understands the specifications of reading a stream of bytes from
    a disk file.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`理解从磁盘文件读取字节流的要求。'
- en: 'We have also `MemoryStream`, which inherits `Stream` as another example of
    a concrete class, as illustrated here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`MemoryStream`，它继承自`Stream`，作为另一个具体类的示例，如下所示：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is a UML diagram to summarize the relationship:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个UML图来总结这些关系：
- en: '![Figure 2.8 – Stream and its children ](img/Figure_2.8_B18370.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 流及其子类](img/Figure_2.8_B18370.jpg)'
- en: Figure 2.8 – Stream and its children
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 流及其子类
- en: 'Having `Stream` as an abstract class opened the way for `System.Text.Json.JsonSerializer`
    class, which accepts a parameter of the type `Stream`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Stream`作为抽象类打开了`System.Text.Json.JsonSerializer`类接受类型为`Stream`的参数的道路：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method converts the provided value to `Stream` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将提供的值转换为`Stream`类。
- en: 'Because this method doesn’t care for the way the `Stream` class is dealing
    with the underlying physical persistence, it is accepting the `Stream` parent
    abstract class as a parameter. If there is no abstraction, then you will have
    **multiple** overloads of the same method. Each one of them accepts a different
    stream type, like this (these overloads don’t exist; they are hypothetical):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个方法不关心`Stream`类如何处理底层的物理持久性，所以它接受`Stream`父抽象类作为参数。如果没有抽象，那么你将会有**多个**相同方法的过载。每个过载都接受不同的流类型，如下所示（这些过载不存在；它们是假设的）：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is an example of the benefits of accepting an abstraction type as a method
    argument. Here is another example. Consider this code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受抽象类型作为方法参数的好处示例。这里还有另一个例子。考虑以下代码：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method takes an array and returns the sum of its elements. At first glance,
    the method’s signature looks fine, but if you think about it, this method forces
    the caller to convert any collection to an array before calling the method, which
    is an unnecessary conversion and a waste of performance as this method doesn’t
    depend on the specific features of an array. It is just doing a `foreach` construct,
    which means it is accessing the array elements sequentially. Does it really need
    to accept an array?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个数组并返回其元素的总和。乍一看，方法的签名看起来不错，但如果你仔细想想，这个方法强制调用者在使用方法之前将任何集合转换为数组，这是一个不必要的转换，并且由于此方法不依赖于数组的特定功能，所以是一种性能浪费。它只是在执行一个`foreach`结构，这意味着它按顺序访问数组元素。它真的需要接受一个数组吗？
- en: 'Converting the signature parameter to `IEnumerable<int>`, which is an abstraction,
    would allow this method to accept a considerable number of concrete classes, as
    illustrated here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将签名参数转换为`IEnumerable<int>`这种抽象类型，将允许此方法接受相当数量的具体类，如下所示：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You initially were only able to call this method with an `int[]` array; now,
    it can be passed to any object of a class that implements `IEnumerable<int>`,
    and there are plenty of them. Here are a few:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你最初只能用`int[]`数组调用此方法；现在，它可以传递给实现`IEnumerable<int>`的任何对象，而且有很多。以下是一些例子：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Going back to the WFA application, our controller constructor is already doing
    something right as it depends on abstractions, as illustrated in the following
    code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到WFA应用程序，我们的控制器构造函数已经做得很好，因为它依赖于抽象，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Always think of the common denominator abstraction type that satisfies the requirement
    to have your method as open as possible.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总是考虑满足尽可能使你的方法开放的公共分母抽象类型。
- en: Direct instantiation of a dependency
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接实例化依赖项
- en: We have just discussed using abstractions, when possible, in our method signature.
    This reduces coupling and increases the usability of the method. This section
    will extend the advice to the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了在可能的情况下在我们的方法签名中使用抽象，这减少了耦合并增加了方法的可用性。本节将此建议扩展到代码中。
- en: 'If we are instantiating classes directly in the code, we depend on concrete
    objects. If we depend on concrete objects, then we cannot change their behavior
    at runtime. Let’s take an example from our WFA application where we are instantiating
    the `Client` class in our method, as per this line of code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代码中直接实例化类，我们就依赖于具体对象。如果我们依赖于具体对象，那么我们无法在运行时改变它们的行为。让我们以我们的WFA应用程序为例，我们在方法中实例化`Client`类，就像以下代码行所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, whenever we use the `openWeatherClient` object, such as calling the `OneCallAsync`
    method, we will be firing an HTTP request over the network to a RESTful API on
    the *OpenWeather* end. This is good for the production code, but not good for
    testing the code; when we are testing, we want to eliminate this behavior.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次我们使用`openWeatherClient`对象，例如调用`OneCallAsync`方法时，我们都会在网络上向*OpenWeather*端的RESTful
    API发送HTTP请求。这对于生产代码来说是好的，但不适合测试代码；当我们测试时，我们希望消除这种行为。
- en: Isolation
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离
- en: In this case, we can avoid the HTTP call and work around this using an *isolation
    framework* during testing. However, this is only kept as a last resort. We will
    explain what isolation frameworks are in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以避免HTTP调用，并在测试期间使用*隔离框架*来解决这个问题。然而，这只是一个最后的手段。我们将在[*第3章*](B18370_03.xhtml#_idTextAnchor066)，“开始单元测试”中解释隔离框架是什么。
- en: 'When testing the code, we don’t want it to fire an HTTP request for many reasons,
    including the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码时，我们不希望它出于许多原因触发HTTP请求，包括以下原因：
- en: We have a limited number of calls that we can make per time—a quota.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们每段时间可以进行的调用次数有限——有一个配额。
- en: Our testing environment is behind a firewall that bans outbound traffic.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的测试环境位于防火墙后面，该防火墙禁止出站流量。
- en: The REST service on the other end of the network is temporarily down, so we
    will get a false-negative result that our test has failed.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络另一端的REST服务暂时关闭，因此我们将得到一个假阴性结果，即我们的测试失败了。
- en: Calling a service over the internet is slow, compared to dealing with CPU and
    memory.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过互联网调用服务比处理CPU和内存要慢。
- en: Can you see where we’re going? The code works, but it is not testable in isolation
    of the HTTP calls.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出我们的方向吗？代码是可行的，但它不能在独立于HTTP调用的环境中进行测试。
- en: Important Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some test categories should fire HTTP and reach the other end, such as integration
    tests. In the previous context, I meant tests that validate the business logic
    and do not test for connectivity—one of them is a unit test.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试类别应该触发HTTP请求并到达另一端，例如集成测试。在先前的上下文中，我指的是验证业务逻辑而不测试连接性的测试——其中之一是单元测试。
- en: Instantiating concrete classes would not work if we were to unit test a piece
    of functionality. What we want to do during unit testing is to check if a *false
    attempt* to fire a call is made but not actually executed, and that would be enough.
    So far, the takeaway is that creating concrete classes in code is not compatible
    with DI and, accordingly, not compatible with unit testing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要对某个功能进行单元测试，实例化具体类将不起作用。我们在单元测试期间想要做的是检查是否进行了 *虚假尝试* 来触发调用，但实际上并没有执行，这就足够了。到目前为止，我们得到的结论是，在代码中创建具体类与
    DI 不兼容，因此也与单元测试不兼容。
- en: The main solution to avoid instantiating classes in the business logic is DI,
    which is what we will see shortly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在业务逻辑中实例化类的根本解决方案是依赖注入（DI），我们很快就会看到。
- en: Best practices recap
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践回顾
- en: 'Our discussion in the *Depend on abstraction, not concrete* section boils down
    to these two examples of *do* and *do not*. Let’s start with the bad or the do-not-do
    example, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“依赖抽象，而非具体”部分的讨论归结为以下两个 *应该做* 和 *不应该做* 的例子。让我们从不好的或 *不应该做* 的例子开始，如下所示：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s the equivalent good class example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个等效的好类示例：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here are the good practices:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些好的实践：
- en: Having abstractions as parameters encourages decoupling and opens the method
    to accept more types.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将抽象作为参数鼓励解耦，并使方法能够接受更多类型。
- en: Depending on abstractions allows changing an object’s behavior without changing
    the code in the class.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖抽象允许在不更改类中的代码的情况下更改对象的行为。
- en: 'One question you would ask is this: *If I did not instantiate the objects that
    were passed to the constructor or the method at runtime, then who did? Surely
    somewhere along the line, some process has instantiated my dependencies and passed
    them to my class.* The answer to this question can be found in the next section.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问一个问题：*如果我在运行时没有实例化传递给构造函数或方法的对象，那么是谁实例化的呢？肯定在某个环节，某个进程已经实例化了我的依赖并将它们传递给我的类。*
    这个问题的答案可以在下一节找到。
- en: Introducing DI
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍依赖注入
- en: When I first learned how to do DI in code, I had a euphoria as if I had discovered
    a secret in software engineering; it is like *code magic*. We have been exploring
    dependencies in the previous sections and now, we are about to discover injecting
    these dependencies into our classes. The next step is explaining what DI is and
    using practical samples from the WFA application to make sure you are experimenting
    with a variety of scenarios. The best way to introduce DI is with a familiar example.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次学习如何在代码中实现依赖注入时，我感到一种狂喜，就像我发现了软件工程中的秘密一样；它就像 *代码魔法*。在前面的章节中，我们已经探讨了依赖关系，现在，我们即将发现将这些依赖注入到我们的类中。下一步是解释什么是
    DI，并使用 WFA 应用程序的实际示例来确保你在各种场景中进行实验。介绍 DI 的最好方式是通过一个熟悉的例子。
- en: First example of DI
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入的第一个例子
- en: 'DI is all over any modern .NET code. In fact, we have one example right here
    in the ASP.NET template code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）在现代 .NET 代码中无处不在。实际上，我们就在 ASP.NET 模板代码中找到了一个例子：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `logger` object, which is a dependency, is injected into the controller
    when a new instance of the controller is created. There is nowhere in the controller
    that we are instantiating the `logger` class. It has been injected into the controller’s
    constructor.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建控制器的新实例时，将依赖项 `logger` 对象注入到控制器中。在控制器中没有任何地方是实例化 `logger` 类的。它已经被注入到控制器的构造函数中。
- en: 'What does injection in this context mean? It means the ASP.NET framework found
    an incoming request that needs this controller to be instantiated. The framework
    realized that to create a new instance of `WeatherForecastController`, it needs
    to create an instance of a concrete class that implements `ILogger<WeatherForecastController>`,
    to do something similar to this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，“注入”意味着 ASP.NET 框架发现了一个需要实例化这个控制器的传入请求。框架意识到要创建 `WeatherForecastController`
    的新实例，它需要创建一个实现了 `ILogger<WeatherForecastController>` 的具体类的实例，以执行类似以下操作：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The constructor of the controller required an instance of a concrete class that
    implements `ILogger<WeatherForecastController>`, and the framework resolved that
    `Logger<>` implements `ILogger<>` and can be used as a parameter for the construction
    of the controller.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的构造函数需要一个实现了 `ILogger<WeatherForecastController>` 的具体类的实例，并且框架解析出 `Logger<>`
    实现了 `ILogger<>`，因此它可以作为控制器构造的参数使用。
- en: How did it resolve this? We will learn about this in the DI containers; what
    is important now is that it knew what to do in order to instantiate the controller
    class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何解决的？我们将在DI容器中学习这一点；现在重要的是，它知道如何实例化控制器类。
- en: 'Now is the time to give every subject in our play a DI-related name, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给我们的剧本中的每一个主题起一个与DI相关的名字，如下所示：
- en: '**DI container**: The software library that is managing the injection'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DI容器**：管理注入的软件库'
- en: '`ILogger<>` descendant object)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILogger<>`派生对象）'
- en: '**Client**: The class requesting the service (the controller, in the previous
    example)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：请求服务的类（在上一个例子中的控制器）'
- en: '**Activation**: The process of instantiating the client'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活**：实例化客户端的过程'
- en: '**Resolution**: The DI container finding the right service required to activate
    the client'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：DI容器找到激活客户端所需的服务'
- en: Testing an API
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个API
- en: Let’s dig deeper into DI with an example. Consider this test problem that will
    give you firsthand experience of what DI is. Take the `ConvertCToF` method we
    created earlier in our WFA application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子更深入地了解DI。考虑这个测试问题，它将给你亲身体验DI是什么的第一手经验。考虑我们在WFA应用程序中之前创建的`ConvertCToF`方法。
- en: 'We want to do some tests for this method in order to validate whether the temperature
    conversion is done accurately. We have been given a few examples of °C and the
    equivalent °F for our tests, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对这个方法进行一些测试，以验证温度转换是否准确完成。我们得到了一些°C和相应的°F的例子，如下所示：
- en: -1.0 C = 30.20 F
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: -1.0 C = 30.20 F
- en: 1.2 C = 34.16 F
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.2 C = 34.16 F
- en: To satisfy the tests, we want to use an old-school console application that
    will throw an exception if the conversion doesn’t match the examples.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足测试，我们想使用一个老式的控制台应用程序，如果转换不匹配示例，它将抛出异常。
- en: 'You can add the console application via the VS GUI or you can execute the following
    lines from the solution directory:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过VS GUI添加控制台应用程序，或者你可以从解决方案目录执行以下行：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This adds a new console application called `Uqs.Weather.TestRunner` to the
    existing solution, and references the existing ASP.NET Web API application. In
    VS, add this code to the `Program.cs` file of the console application:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在现有解决方案中添加一个新的控制台应用程序`Uqs.Weather.TestRunner`，并引用现有的ASP.NET Web API应用程序。在VS中，将以下代码添加到控制台应用程序的`Program.cs`文件中：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The code in the current format doesn’t run as it fails at the `var logger` line.
    We’ll fix that in a moment, but let’s analyze the code first. The code instantiates
    a controller, in the way we instantiate any class in .NET; then, it calls the
    `ConvertCToF` method and tries different values. If all values pass, then it will
    print **Test Passed**; otherwise, it will throw an exception.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当前格式的代码无法运行，因为它在`var logger`行失败。我们稍后会修复这个问题，但首先让我们分析一下代码。代码以我们实例化任何.NET中的类的方式实例化了一个控制器，然后调用`ConvertCToF`方法并尝试不同的值。如果所有值都通过，它将打印**测试通过**；否则，它将抛出一个异常。
- en: To instantiate a `Logger<>` object, we need to pass to its constructor an object
    of `ILoggerFactory` type. If you pass `null`, it will fail at runtime. Besides,
    the bad news is that an instance of a concrete implementation of `ILoggerFactory`
    is not meant to be instantiated manually unless you are integrating a logging
    framework or handling a special case, and testing is not a special case! In brief,
    we cannot easily do this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个`Logger<>`对象，我们需要将其构造函数传递一个`ILoggerFactory`类型的对象。如果你传递`null`，它将在运行时失败。此外，`ILoggerFactory`的具体实现实例不应该手动实例化，除非你正在集成日志记录框架或处理特殊情况，而测试不是特殊情况！简而言之，我们无法轻易做到这一点。
- en: 'What if we try to pass to the controller’s constructor two null values, and
    ignore creating a `Logger<>` object, like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试向控制器的构造函数传递两个null值，并且忽略创建一个`Logger<>`对象，就像这样：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The problem is that if you pass a `null` value, your `_logger` object in the
    controller will be null and your code will fail at this line with the infamous
    `NullReferenceException` exception, as illustrated here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果你传递一个`null`值，控制器中的`_logger`对象将是null，你的代码将在这一行失败，并出现著名的`NullReferenceException`异常，如下所示：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What we really want is just to instantiate the controller. We are not testing
    the logger; we want to pass to the constructor anything that will create an object
    from our controller, but the logger is standing in our way. It turns out that
    Microsoft has a class called `NullLogger<>` that does just that—getting out of
    the way! The documentation from Microsoft states “*Minimalistic logger that does
    nothing*”.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是只是实例化控制器。我们不是在测试记录器；我们希望传递给构造函数任何可以创建控制器对象的东西，但记录器挡在了我们的路上。结果发现，Microsoft有一个名为`NullLogger<>`的类，它正是这样做的——让路！Microsoft的文档中这样描述：“*最小化记录器，什么都不做*”。
- en: 'With the enlightenment of this class, the first few lines of the code will
    look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的启发下，代码的前几行将看起来像这样：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We are getting a reference to `NullLogger<>` through the `Instance` field. When
    we call `_logger.LogInformation`, nothing will happen, which fits what we’re looking
    for. If we run this console application now, we will get a **Test Passed** message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`Instance`字段获取到`NullLogger<>`的引用。当我们调用`_logger.LogInformation`时，不会发生任何事，这符合我们的需求。如果我们现在运行这个控制台应用程序，我们将得到一个**测试通过**的消息。
- en: Important Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Testing methods via a console application is not the best practice for testing.
    Also, throwing exceptions and writing messages are not ideal for reporting failed
    and passed tests. The right way will be covered in the next chapter.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制台应用程序进行测试并不是最佳实践。同样，抛出异常和写入消息也不是报告通过和失败的测试的理想方式。正确的方法将在下一章中介绍。
- en: 'The constructor of the controller accepts an `ILogger<>` object, which gave
    us the flexibility of passing a `NullLogger<>` object as the latter implements
    `ILogger<>`, as illustrated here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的构造函数接受一个`ILogger<>`对象，这给了我们传递一个`NullLogger<>`对象作为后者的灵活性，因为它实现了`ILogger<>`接口，如下所示：
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And the UML diagram of the logging classes looks like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 日志类的UML图看起来如下：
- en: '![Figure 2.9 – UML of Logger<>, NullLogger<>, and ILogger<> ](img/Figure_2.9_B18370.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – Logger<>, NullLogger<>, 和 ILogger<> 的UML图](img/Figure_2.9_B18370.jpg)'
- en: Figure 2.9 – UML of Logger<>, NullLogger<>, and ILogger<>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – Logger<>, NullLogger<>, 和 ILogger<> 的UML图
- en: 'At this point, it is worth analyzing what we’ve done so far. Here’s what we’ve
    achieved:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，分析我们所做的是值得的。这是我们取得的成绩：
- en: At runtime (when the APIs are launched), `Logger<>` was injected into the controller
    and it should be writing logs as expected.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行时（当API启动时），`Logger<>`被注入到控制器中，并应该按预期写入日志。
- en: At test time, we are not interested in the activities of logging; we are testing
    another scenario, so we’ve passed `NullLogger<>`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试时，我们对日志活动不感兴趣；我们正在测试另一个场景，所以我们传递了`NullLogger<>`。
- en: We were allowed to inject into `ILogger<>` different types as `ILogger<>` is
    an interface, which is an abstraction. We would have failed to do this if our
    constructor expects a `Logger<>` type (the concrete type with no `I`).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们被允许向`ILogger<>`注入不同的类型，因为`ILogger<>`是一个接口，它是一个抽象。如果我们的构造函数期望一个`Logger<>`类型（没有`I`的具体类型），我们就无法做到这一点。
- en: 'In the first scenario, it was the **DI container** that injected the object
    at runtime. In the second scenario, this was us manually injecting a different
    logger for testing purposes. The annotated code in the following screenshot shows
    a summary of this section:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，是**DI容器**在运行时注入了对象。在第二种情况下，这是我们手动注入一个不同的记录器进行测试。以下截图中的注释代码展示了本节内容的总结：
- en: '![Figure 2.10 – Annotated code showing DI at test time and at runtime ](img/Figure_2.10_B18370.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 显示测试时间和运行时DI的注释代码](img/Figure_2.10_B18370.jpg)'
- en: Figure 2.10 – Annotated code showing DI at test time and at runtime
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 显示测试时间和运行时DI的注释代码
- en: The conclusion here is that if our parameters use abstract types such as interfaces,
    `ILogger<>`-type interfaces, or abstract classes, we can open our classes for
    more reusability where DI can be utilized.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，如果我们的参数使用抽象类型，如接口、`ILogger<>`类型接口或抽象类，我们可以使我们的类更具可重用性，从而可以利用DI。
- en: The `LogInformation` method is changing behavior based on the injected object,
    so it is acting as a seam. This drives us naturally to our next section about
    seams.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogInformation`方法根据注入的对象改变行为，因此它充当了一个接口。这自然地引导我们进入下一节关于接口的内容。'
- en: What are seams?
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是接口？
- en: 'As an English term, a *seam* is where two pieces of fabric are stitched together.
    The term in a DI context resembles areas in the code where we can *change* the
    behavior without changing the code explicitly. We can point to the example from
    our previous convert method, shown here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为英语中的一个术语，*接口*是两块布料缝合在一起的地方。在 DI 上下文中，这个术语类似于代码中我们可以*改变*行为而不显式更改代码的区域。我们可以指向我们之前转换方法中的例子，如下所示：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Take the `LogInformation` method. We want this method to write into some production
    instrument, but when we’re testing, we want it to do nothing (if our test scenario
    is not about logging). We want to test other functionality, but `_logger.LogInformation`
    is standing in our way, trying to write somewhere, so we want to change its behavior.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以`LogInformation`方法为例。我们希望这个方法能够写入某个生产工具，但在测试时，我们希望它什么都不做（如果我们的测试场景不是关于日志记录）。我们想要测试其他功能，但`_logger.LogInformation`挡在了我们的路上，试图写入某个地方，因此我们希望改变它的行为。
- en: '`LogInformation` is a seam, as the behavior can change here. From the previous
    section, if we inject into the class a `Logger<>` object, then `LogInformation`
    will behave in one way, and if we inject `NullLogger<>`, it will behave in another
    way.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogInformation`是一个接口，因为行为可以在这里改变。从上一节中，如果我们向类注入一个`Logger<>`对象，那么`LogInformation`将按一种方式表现，如果我们注入`NullLogger<>`，它将按另一种方式表现。'
- en: Inversion of control
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制反转
- en: You will often hear the term **inversion of control** (**IoC**) used to mean
    DI. You may also hear IoC container, as well, to mean a DI container. From a pragmatic
    point of view, you don’t need to worry about the differences in the meaning of
    these terms. Practitioners have different definitions of IoC and how it relates
    to DI. Just search for one term versus the other and you’ll find forums full of
    contradicting definitions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到**控制反转**（IoC）这个术语用来表示 DI。你也可能会听到 IoC 容器，这也意味着 DI 容器。从实用主义的角度来看，你不需要担心这些术语在意义上的差异。实践者对
    IoC 和它与 DI 的关系有不同的定义。只需搜索其中一个术语与另一个术语，你会在论坛上找到充满矛盾的定义。
- en: 'Here are the common points that practitioners agree on:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实践者普遍认同的要点：
- en: IoC is reversing the flow of events from the software to the **user interface**
    (**UI**) or the other way around.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoC 是将事件流从软件到用户界面（UI）或相反方向反转。
- en: DI is a form of IoC.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI 是 IoC 的一种形式。
- en: '*DI* is the most popular term and the most modern one. The term *IoC* is from
    a different era, is more generic, and has a less practical use, so I recommend
    using the term *DI*.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*DI* 是最流行且最现代的术语。术语 *IoC* 来自不同的时代，更通用，并且实用性较低，所以我建议使用术语 *DI*。'
- en: After all these examples, best practices, and definitions, I kept the best to
    last, which is the practical section of this chapter. This is how you can take
    all the previous literature and write useful code with it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些例子、最佳实践和定义之后，我把最好的留到了最后，这就是本章的实践部分。这是你可以如何利用所有前面的文献来编写有用代码的方法。
- en: Using DI containers
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DI 容器
- en: 'A **DI container** is a library that injects a service into the client. A DI
    container provides extra functionality other than injecting dependencies, such
    as the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI 容器**是一个库，它将服务注入客户端。DI 容器提供了除了注入依赖项之外的其他功能，例如以下内容：'
- en: Registering the classes that need to be injected (registering the services)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册需要注入的类（注册服务）
- en: Implementing how the services need to be instantiated
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务需要如何实例化
- en: Instantiating what has already been registered
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化已经注册的内容
- en: Managing the created service lifetime
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理创建的服务生命周期
- en: Let’s clarify a DI container role with an example from the previous code. We
    have the `logger` service being injected, but who is responsible for this?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个来自上一段代码的例子来明确 DI 容器的角色。我们有`logger`服务被注入，但谁负责这个？
- en: 'There is a DI container called `Microsoft.Extensions.DependencyInjection` that
    will inject `_logger`. This happened in the first line of `Program.cs`, as illustrated
    here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Microsoft.Extensions.DependencyInjection`的 DI 容器，它将注入`_logger`。这发生在`Program.cs`的第一行，如图所示：
- en: '[PRE46]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This previous method call registers a default logger. Unfortunately, while we
    can see the code in the .NET source code, it is not obvious in our `Program.cs`
    source code. In fact, the previous line registers plenty of other services.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个方法调用注册了一个默认的日志记录器。不幸的是，虽然我们可以在 .NET 源代码中看到代码，但在我们的 `Program.cs` 源代码中并不明显。事实上，上一行注册了许多其他服务。
- en: 'By adding a single line for experimentation, directly following the previous
    line in `Program.cs`, we can see how many registered services are created:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Program.cs`的上一行之后添加一行用于实验，我们可以看到创建了多少注册的服务：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will give us 82 services. A few of these services are for logging-related
    activities. So, if you want to see what they are, you can have this line directly
    after the previous line:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们82个服务。其中一些服务与日志相关活动有关。所以，如果你想查看它们，你可以在上一行之后直接添加这一行：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can see here that we are filtering on any service that has the word `Log`
    as part of its name. If you have a breakpoint after this line and go to VS `logServices`,
    you can see a glimpse of all the registered log-related services, as illustrated
    in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里我们正在筛选任何名称中包含`Log`字样的服务。如果你在这行代码后设置断点并转到VS的`logServices`，你可以看到所有注册的日志相关服务的快照，如下面的截图所示：
- en: '![Figure 2.11 – Immediate window showing the registered logging-related services
    ](img/Figure_2.11_B18370.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 显示已注册日志相关服务的即时窗口](img/Figure_2.11_B18370.jpg)'
- en: Figure 2.11 – Immediate window showing the registered logging-related services
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 显示已注册日志相关服务的即时窗口
- en: The screenshot shows that we have 10 registered logging-related services. The
    one being injected for us at runtime is the second one (index number 1).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示我们有10个注册的日志相关服务。在运行时为我们注入的是第二个（索引号1）。
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might get a different list of pre-registered services than this, depending
    on your ASP.NET version.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的ASP.NET版本，你可能会得到一个不同的预注册服务列表。
- en: We will change our implementation in the controller to move everything to be
    dependency-injected and experiment with various scenarios of writing DI-ready
    code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改控制器中的实现，将所有内容移动到依赖注入，并尝试编写DI-ready代码的各种场景。
- en: Container role
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器角色
- en: 'The container activities are being executed in the background by the DI container.
    A container is involved in booting up classes in your application, as illustrated
    in the following screenshot:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 容器活动是由DI容器在后台执行的。容器参与启动你的应用程序中的类，如下面的截图所示：
- en: '![Figure 2.12 – Container in action (pseudo code) ](img/Figure_2.12_B18370.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 容器在行动（伪代码）](img/Figure_2.12_B18370.jpg)'
- en: Figure 2.12 – Container in action (pseudo code)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 容器在行动（伪代码）
- en: The code of the **DI Container** box is a pseudo code. It is trying to summarize
    how the DI *resolves* the *service* required by the *client* from a list of already
    *registered* services. Then, the DI *activates* the client and passes it to the
    service. This is all happening at runtime.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI容器**框的代码是伪代码。它试图总结DI如何从已注册的服务列表中*解析*客户端所需的*服务*。然后，DI激活客户端并将其传递给服务。所有这些都是在运行时发生的。'
- en: The registration is an activity we will explore in many examples later on. In
    this scenario, there was an instruction that stated whenever an `ILogger<>` object
    is requested by the client, substitute it with a concrete class of the `Logger<>`
    type.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注册是我们将在许多示例中探索的活动。在这个场景中，有一个指令说明每当客户端请求一个`ILogger<>`对象时，就用`Logger<>`类型的具体类来替换它。
- en: It is important to note that while the client is requesting an interface, the
    DI has been instructed earlier on how to construct a concrete class for this abstraction;
    the DI container knew earlier that to construct an `Ilogger<>` object, it needs
    to initialize a `Logger<>` object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，虽然客户端正在请求一个接口，但DI之前已经指示了如何为这个抽象构造一个具体的类；DI容器之前就知道要构造一个`Ilogger<>`对象，它需要初始化一个`Logger<>`对象。
- en: Third-party containers
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方容器
- en: We have been working so far with a *built-in* DI container that is automatically
    wired with new ASP.NET projects, and that is the `Microsoft.Extensions.DependencyInjection`
    Microsoft DI container, but this is not the only DI container available for .NET
    6—there are other third-party options.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用一个*内置*的DI容器，它与新的ASP.NET项目自动连接，这就是`Microsoft.Extensions.DependencyInjection`
    Microsoft DI容器，但这并不是.NET 6可用的唯一DI容器——还有其他第三方选项。
- en: Microsoft has developed a DI container in recent years. Third-party containers
    gradually diminished in popularity in favor of the one shipped with .NET. Also,
    some frameworks did not make the leap with the introduction of .NET 5\. Who’s
    left strong today, with .NET 6, are **Autofac** and **StructureMap**. There are
    other containers supporting .NET 6, but they are not as popular.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微软开发了一个DI容器。第三方容器逐渐失去了人气，转而使用.NET自带的一个。此外，一些框架在.NET 5的引入时并未跃进。如今，随着.NET
    6的推出，剩下的强大容器是**Autofac**和**StructureMap**。还有其他支持.NET 6的容器，但它们并不那么受欢迎。
- en: If you are experienced in unit testing and you want more features that are not
    supported in `Microsoft.Extensions.DependencyInjection`, then have a look at other
    frameworks such as Autofac. But for non-monolithic, mid-size projects, I would
    recommend sticking with the Microsoft one as it is fairly supported and there
    are plenty of third-party plugin components. You can always swap to another framework
    at a later stage. My advice is not to spend valuable time choosing a DI container.
    Start with the Microsoft one until your requirements exceed it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉单元测试并且想要更多在`Microsoft.Extensions.DependencyInjection`中不支持的功能，那么可以看看其他框架，如Autofac。但对于非单体、中等规模的项目，我建议坚持使用微软的，因为它得到了很好的支持，并且有大量的第三方插件组件。你总是可以在以后阶段切换到另一个框架。我的建议是不要浪费宝贵的时间选择DI容器。从微软的版本开始，直到你的需求超过它。
- en: Service lifetime
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务生命周期
- en: When a service is registered to be passed to the client, the DI container has
    to decide about the lifetime of the service. The lifetime is the time interval
    from when the service is created until when it is released for garbage collection
    or disposed of.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个服务注册为传递给客户端时，DI容器必须决定服务的生命周期。生命周期是从服务创建到释放以进行垃圾回收或销毁的时间间隔。
- en: 'The Microsoft DI container has three major lifetimes that you can specify when
    registering a service: **transient**, **singleton**, and **scoped lifetime scopes**.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 微软DI容器在注册服务时可以指定三个主要生命周期：**临时**、**单例**和**作用域生命周期作用域**。
- en: Note that if the service implements the `IDisposable` interface, the `Dispose`
    method is invoked when the service is released. When a service is released, if
    it has dependencies, they are also released and disposed of. Next, we will explore
    the three major lifetimes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果服务实现了`IDisposable`接口，当服务释放时将调用`Dispose`方法。当服务释放时，如果它有依赖项，它们也会被释放和销毁。接下来，我们将探讨三个主要生命周期。
- en: Transient lifetime
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时生命周期
- en: Transient services are created every time they are injected or requested. The
    container simply creates a new instance for every request.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 临时服务每次注入或请求时都会创建。容器为每个请求简单地创建一个新的实例。
- en: This is good in terms of not having to worry about thread safety or service
    state modification (by another requesting object). But creating an object for
    every request has adverse performance implications, especially when the service
    is in high demand, and activating it may not be cheap.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这在不需要担心线程安全或服务状态修改（由另一个请求对象引起）方面是好的。但是，为每个请求创建一个对象会有不良的性能影响，尤其是在服务需求高的时候，激活它可能并不便宜。
- en: You will see an example of a transient service in the *Refactoring for DI* section
    later on.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在稍后的*重构DI*部分看到一个临时服务的例子。
- en: Singleton lifetime
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例生命周期
- en: Singleton services are created once on the first client request and released
    when the application terminates. The same activated service will be passed to
    all requesters.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 单例服务在第一个客户端请求时创建一次，并在应用程序终止时释放。相同的激活服务将被传递给所有请求者。
- en: This is the most efficient lifetime as the object is created once, but this
    is the most dangerous one as a singleton service should allow concurrent access,
    which means it needs to be thread-safe.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最有效率的生命周期，因为对象只创建一次，但这也是最危险的，因为单例服务应该允许并发访问，这意味着它需要是线程安全的。
- en: You will see an example of a singleton service in the *Refactoring for DI* section
    later on.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在稍后的*重构DI*部分看到一个单例服务的例子。
- en: Scoped lifetime
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域生命周期
- en: Scoped services are created once per HTTP request. They stay alive from the
    beginning of the HTTP request until the end of the HTTP response and they will
    be shared between clients.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域服务在每个HTTP请求中创建一次。它们从HTTP请求的开始活到HTTP响应的结束，并且它们将在客户端之间共享。
- en: This is good if you want one service to be used by several clients and the service
    applies to a single request only.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个服务被几个客户端使用，并且服务只适用于单个请求，这是好的。
- en: This lifetime is the least popular compared to the transient and the singleton
    lifetimes. Performance-wise, it sits in the middle between the transient and the
    singleton lifetimes. There is only one thread executing each client request at
    a given time, and because each request gets a separate DI scope, you don’t have
    to worry about thread safety.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 与瞬态和单例生命周期相比，这种生命周期最不受欢迎。在性能方面，它位于瞬态和单例生命周期之间。在给定时间内，只有一个线程执行每个客户端请求，并且因为每个请求都得到一个单独的DI范围，所以你不必担心线程安全。
- en: One popular example of using scoped services is using **Entity Framework’s**
    (**EF’s**) DB context object as scoped, which allows the request to share the
    same data and to cache data when required between clients.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围服务的流行例子是使用**Entity Framework的**（**EF的**）DB上下文对象作为范围，这允许请求共享相同的数据，并在需要时在客户端之间缓存数据。
- en: Here is another example. Suppose you have a logging service that will allow
    the client to log, but it will only flush from memory to the destination media
    (say, saving to the database) when the HTTP request is over. Ignoring other conditions,
    this could be a candidate for a scoped lifetime.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子。假设你有一个允许客户端记录日志的服务，但它只会在HTTP请求结束后将数据从内存刷新到目标媒体（例如，保存到数据库）。忽略其他条件，这可能是范围生命周期的候选者。
- en: We will have an example of a scoped lifetime in [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226),
    *Building an Appointment Booking App with Entity Framework and Relational DB*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B18370_09.xhtml#_idTextAnchor226)中看到一个范围生命周期的示例，*使用Entity Framework和关系型数据库构建预约预订应用*。
- en: Choosing a lifetime
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择生命周期
- en: If your concern is performance, then think of a singleton. Then, the next step
    is checking whether the service is thread-safe, either by reading its documentation
    or doing other types of investigation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的关注点是性能，那么考虑单例。然后，下一步是检查服务是否线程安全，无论是通过阅读其文档还是进行其他类型的调查。
- en: Then, fall down to scoped if relevant, and then fall down to transient. The
    safest option is always transient—if in doubt, then choose transient!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果相关，就降到范围级别，然后降到瞬态。始终选择瞬态是最安全的选项——如果有疑问，那么就选择瞬态！
- en: Important Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Any class that gets injected into the singleton will become a singleton, regardless
    of the lifetime of the injected object.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被注入到单例中的类都将成为单例，无论注入对象的生命周期如何。
- en: Container workflow
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器工作流程
- en: 'Before we see some examples of service registration and lifetime, it’s a good
    time to generalize our understanding of DI containers and look at a workflow diagram
    of the DI activation process:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看服务注册和生命周期的示例之前，这是一个很好的时机来概括我们对DI容器的理解，并查看DI激活过程的流程图：
- en: '![Figure 2.13 – The workflow of a DI container ](img/Figure_2.13_B18370.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – DI容器的流程](img/Figure_2.13_B18370.jpg)'
- en: Figure 2.13 – The workflow of a DI container
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – DI容器的流程
- en: In this diagram, it is clear that the DI container has two major concerns when
    activating a class, which are registration and lifetime.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，很明显，当激活一个类时，DI容器有两个主要关注点，即注册和生命周期。
- en: Refactoring for DI
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为DI重构
- en: If you have done your DI right, then you are halfway with respect to implementing
    your unit tests. When writing a unit test, you will be thinking about how everything
    should be DI-ready.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地做了DI，那么在实现单元测试方面你已经完成了一半。在编写单元测试时，你会考虑如何使一切准备好DI。
- en: 'There are certain factors that will determine how your services should be injected,
    as outlined here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些因素将决定你的服务应该如何注入，具体如下所述：
- en: Does my seam belong to an abstracted method? In another way, does the method
    in question exist in an abstraction? This is the case with the `ILogger.LogInformation`
    method that we saw earlier, but we will cover this scenario again in more detail
    in the *Injecting the OpenWeather client* section.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的接口是否属于一个抽象方法？换句话说，问题中的方法是否存在于一个抽象中？这是我们在前面看到的`ILogger.LogInformation`方法的情况，但我们将在这个*注入OpenWeather客户端*部分更详细地介绍这个场景。
- en: Is my seam a static method? This will be covered in the *Injecting DateTime*
    and *Injecting the random generator* sections.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的接口是否是一个静态方法？这将在*注入DateTime*和*注入随机生成器*部分中介绍。
- en: Injecting the OpenWeather client
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入OpenWeather客户端
- en: 'One offending line is the `Client` class instantiation in `WeatherForecastController.cs`,
    as illustrated here:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有问题的行是`WeatherForecastController.cs`中的`Client`类实例化，如图所示：
- en: '[PRE49]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The sole purpose of accessing `_config` was to get the API key for `Client`
    and the sole purpose of instantiating `HttpClient` was to pass it to the constructor
    of  `Client`. So, if we were to inject `openWeatherClient`, then the first two
    lines would not be needed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`_config`的唯一目的是获取`Client`的API密钥，实例化`HttpClient`的唯一目的是将其传递给`Client`的构造函数。因此，如果我们注入`openWeatherClient`，则前两行将不再需要。
- en: 'Which method or property are we using from the to-be-injected class? The answer,
    by looking through the code, is `OneCallAsync` only. Then, what is the highest
    type (a class, an abstract class, or an interface) in the hierarchy of `Client`
    that has this member? To do this, hold the *Ctrl* button and click on the class
    name in VS, and you will find that `Client` implements `IClient`, as illustrated
    here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从待注入的类中使用哪种方法或属性？通过查看代码，答案是`OneCallAsync`。那么，在`Client`的层次结构中，具有此成员的最高类型（一个类、一个抽象类或一个接口）是什么？要做到这一点，请按住*Ctrl*按钮并点击VS中的类名，你将发现`Client`实现了`IClient`，如图所示：
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, hold *Ctrl* and click `IClient`, and you will find the following interface:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按住*Ctrl*并点击`IClient`，你将找到以下接口：
- en: '[PRE51]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Clearly, my implementation can depend on `IClient` rather than `Client`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我的实现可以依赖于`IClient`而不是`Client`。
- en: 'In the controller constructor, add `IClient` and add `_client` as a field,
    as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器构造函数中，添加`IClient`并添加`_client`作为字段，如下所示：
- en: '[PRE52]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The last step is doing the following modifications to these two lines:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是对这两行进行以下修改：
- en: '[PRE53]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Remove the first line as we are no longer instantiating `Client`, and modify
    your second line to use `_client` instead of the previous `openWeatherClient`.
    This will result in this code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 删除第一行，因为我们不再实例化`Client`，并将你的第二行修改为使用`_client`而不是之前的`openWeatherClient`。这将导致以下代码：
- en: '[PRE54]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have done all our modifications to the controller. What is left is registering
    with the DI container how to inject an object that matches `IClient` for our controller
    constructor. Let’s run the project in its current state and we will get the following
    error:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对控制器进行了所有修改。剩下的是在DI容器中注册如何为控制器构造函数注入匹配`IClient`的对象。让我们以当前状态运行项目，我们将得到以下错误：
- en: '[PRE55]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The DI container tried to look for a concrete class that implements `IClient`
    so that it can create it and pass it to the constructor of `WeatherForecastController`.
    We know that there is a concrete class called `Client` that implements `IClient`,
    but we have not told the DI container about it yet.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器试图寻找一个实现`IClient`的具体类，以便它可以创建它并将其传递给`WeatherForecastController`的构造函数。我们知道有一个名为`Client`的具体类实现了`IClient`，但我们还没有告诉DI容器。
- en: 'In order for the DI container to register a service, it requires two bits of
    information, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使DI容器注册一个服务，它需要两个信息位，如下所示：
- en: How to create the required service?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建所需的服务？
- en: What is the lifetime of the created service?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建的服务生命周期是什么？
- en: The answer to *point 1* is we need to create an instance of `Client` whenever
    `IClient` is requested.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*第1点*的答案是，每当请求`IClient`时，我们需要创建一个`Client`实例。'
- en: '*Point 2* is the trickier one. `Client` is a third-party class that is documented
    online. The first action is looking through the documentation to see whether it
    has a recommended lifetime and in this case, the documentation of `Client` specifies
    `Singleton` as the recommended one. In other cases where this is not documented,
    we have to figure it out in other ways. We will have more examples later on.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*第2点*比较复杂。`Client`是一个在线有文档的第三方类。第一步是查看文档以查看它是否有推荐的寿命，在这种情况下，`Client`的文档指定`Singleton`为推荐的。在其他没有文档的情况下，我们必须以其他方式找出它。我们稍后会提供更多示例。'
- en: 'To register our dependency, in the `Program.cs` file, look for the comment
    provided by the `Add services to the container` template and add your code underneath
    it, as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册我们的依赖项，在`Program.cs`文件中，查找由`Add services to the container`模板提供的注释，并在其下方添加你的代码，如下所示：
- en: '[PRE56]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we are constructing `Client` in the same way we did it before. Once `Client`
    is first requested, only one instance will be created per application, and the
    same instance will be provided for all clients upon request.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以与之前相同的方式构造`Client`。一旦`Client`首次请求，每个应用程序将只创建一个实例，并且所有客户端在请求时将提供相同的实例。
- en: Now, as we have finished with the DI of all dependencies required by the `GetReal`
    method, let’s tackle the `Now` dependency in the `GetRandom` method.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了`GetReal`方法所需的所有依赖项的DI，让我们解决`GetRandom`方法中的`Now`依赖项。
- en: Injecting DateTime
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入DateTime
- en: 'We are using `DateTime` in our `GetRandom` method and it is tricky to inject.
    Let’s look at `DateTime` class usage in the code. We are using the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`GetRandom`方法中，我们使用`DateTime`，并且注入它有些棘手。让我们看看代码中`DateTime`类的使用情况。我们使用以下内容：
- en: '`AddDays` method'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddDays`方法'
- en: '`Now` property, which returns a `DateTime` object'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Now`属性，它返回一个`DateTime`对象'
- en: 'All this is clear in one line of code, shown here:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在一行代码中清晰地展示出来，如下所示：
- en: '[PRE57]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `AddDays` method is a method that relies on an arithmetic calculation of
    days, which can be verified by looking at the `DateTime` source code on GitHub,
    at [https://github.com/microsoft/referencesource/blob/master/mscorlib/system/datetime.cs](https://github.com/microsoft/referencesource/blob/master/mscorlib/system/datetime.cs).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDays`方法是一个依赖于天数算术计算的方法，可以通过查看GitHub上的`DateTime`源代码来验证，在[https://github.com/microsoft/referencesource/blob/master/mscorlib/system/datetime.cs](https://github.com/microsoft/referencesource/blob/master/mscorlib/system/datetime.cs)。'
- en: We don’t have to worry about injecting it as it is not reaching an external
    dependency; it is just executing some C# code, or we might want to inject it to
    control how the `AddDays` method is being calculated. In our case here, injecting
    `AddDays` is not required.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心注入它，因为它没有达到外部依赖；它只是执行一些C#代码，或者我们可能想要注入它来控制`AddDays`方法是如何计算的。在我们的例子中，注入`AddDays`不是必需的。
- en: The second point is the `Now` property. If we were to write a unit test that
    involves testing the value of `Now`, then we’d want to freeze it to a constant
    value to be able to test. At this stage, the picture of freezing it may not be
    clear, but it will be clearer when we unit test `GetRandom` in the next chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是`Now`属性。如果我们编写一个涉及测试`Now`值的单元测试，我们希望将其冻结到一个常量值以便测试。在这个阶段，冻结它的画面可能还不清楚，但在下一章单元测试`GetRandom`时会更清晰。
- en: 'We need to provide an injected `Now` property, but `Now` is a **static property**,
    as we can see here:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个注入的`Now`属性，但`Now`是一个**静态属性**，正如我们在这里看到的：
- en: '[PRE58]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Static properties (and methods) do not adhere to the same polymorphism principles
    that instance properties adhere to. So, we need to figure out another way to inject
    `Now` than what we used before.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性（和方法）不遵循与实例属性相同的多态原则。因此，我们需要找出一种不同于之前的方法来注入`Now`。
- en: 'The next code is preparing `Now` in a way suitable to work polymorphically.
    Create an interface like this one to act as an abstraction:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了如何以适合多态工作的方式准备`Now`。创建一个如下所示的接口作为抽象：
- en: '[PRE59]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will have our code depending on this abstraction type. Also, we will have
    to provide an implementation for a concrete `NowWrapper` class, so our code simply
    looks like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使我们的代码依赖于这个抽象类型。此外，我们还需要提供一个具体`NowWrapper`类的实现，所以我们的代码看起来就像这样：
- en: '[PRE60]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: I have added two files under a directory called `Wrappers` in the project. I
    have added `INowWrapper.cs` and `NowWrapper.cs` under it.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我在项目中的一个名为`Wrappers`的目录下添加了两个文件。我在其中添加了`INowWrapper.cs`和`NowWrapper.cs`。
- en: Wrapper and Provider
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Wrapper和Provider
- en: Some developers like to have a `Wrapper` suffix for this category of types,
    and others like to use a `Provider` suffix such as `NowProvider`. I don’t like
    to use the name `Provider` as it is already a design pattern and it might be misleading.
    My advice is to pick one convention and stay consistent.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者喜欢为这类类型添加`Wrapper`后缀，而其他人则喜欢使用`Provider`后缀，例如`NowProvider`。我不喜欢使用`Provider`这个名字，因为它已经是一个设计模式，可能会造成误导。我的建议是选择一种约定并保持一致性。
- en: 'As usual, we have two points to consider when registering a non-concrete type
    for injection, as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们为注入注册一个非具体类型时，我们需要考虑两个要点，如下所示：
- en: How to create the required service?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建所需的服务？
- en: What is the lifetime of the created service?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建的服务生命周期是什么？
- en: The first point is easy—we just instantiate the `NowWrapper` class. The second
    point depends on the `DateTime.Now` original property. Since I know that this
    is a web environment where multiple requests may be hitting my static property
    simultaneously, the first thing I would be checking is the popular .NET thread-safety
    topic. In other words, if this property is accessed simultaneously by multiple
    threads, would that lead to undetermined behavior?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点很容易——我们只需实例化`NowWrapper`类。第二点取决于`DateTime.Now`原始属性。由于我知道这是一个可能同时有多个请求击中我的静态属性的Web环境，我会首先检查流行的.NET线程安全主题。换句话说，如果这个属性被多个线程同时访问，会不会导致不确定的行为？
- en: Static members of `DateTime`, including the `Now` property, are written with
    thread safety in mind, so calling `Now` simultaneously should not lead to an undetermined
    behavior.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`的静态成员，包括`Now`属性，都是考虑到线程安全性而编写的，因此同时调用`Now`不应导致不确定的行为。'
- en: 'Given this is the case, then I can have my DI as a singleton. Let’s register
    `INowWrapper` for injection. As with the previous example, add `INowWrapper` to
    the controller constructor, like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我可以将我的DI作为单例。让我们注册`INowWrapper`以进行注入。与之前的例子一样，将`INowWrapper`添加到控制器构造函数中，如下所示：
- en: '[PRE61]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Replace `DateTime.Now` with `_nowWrapper.Now`, as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DateTime.Now`替换为`_nowWrapper.Now`，如下所示：
- en: '[PRE62]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And lastly, register your dependency in the `Program.cs` file, using the following
    code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Program.cs`文件中注册您的依赖项，使用以下代码：
- en: '[PRE63]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This means that when the first `INowWrapper` instance is requested, the DI container
    will instantiate it and keep it for the lifetime of the application.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当第一次请求`INowWrapper`实例时，DI容器将实例化它，并保留其整个应用程序的生命周期。
- en: Injecting the random generator
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入随机生成器
- en: 'The random number generator is unpredictable by design; otherwise, it wouldn’t
    be random! There is a problem in unit testing it if it is not DI-injected, because
    the unit tests should be testing against a fixed (determined) value. Let’s look
    at the offending line here:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成器的设计就是不可预测的；否则，它就不会是随机的！如果它没有DI注入，那么在单元测试中就会有问题，因为单元测试应该针对一个固定的（确定的）值进行测试。让我们看看这里的问题行：
- en: '[PRE64]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Shared` is a static method, so we have the same issue that we had in the previous
    task with `Now`. First, we need to determine thread safety. There is no definite
    mention in the `Next` documentation if it is thread-safe; on the contrary, claims
    online mention that it is not thread-safe. So, the safest option here is to assume
    that it is not thread-safe. Here, we can wrap the entire class or the particular
    method. I will choose to wrap the entire class in case we need it later to use
    another method from the `Random` class. Let’s write our interface, as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shared`是一个静态方法，所以我们有与之前任务中`Now`相同的问题。首先，我们需要确定线程安全性。在`Next`文档中没有明确提到它是否是线程安全的；相反，网上的一些说法称它不是线程安全的。因此，这里最安全的选项是假设它不是线程安全的。在这里，我们可以包装整个类或特定方法。我将选择包装整个类，以防我们以后需要使用`Random`类中的另一个方法。让我们编写我们的接口，如下所示：'
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And here, we have the concrete class implementing it:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有具体实现它的类：
- en: '[PRE66]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add this as usual to the controller constructor and replace the code in `GetRandom`
    with this:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例将其添加到控制器构造函数中，并用此代码替换`GetRandom`中的代码：
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: I did change the behavior slightly in the class; initially, it was creating
    a new `Random` instance every time we call `Next`, but now it is creating one
    `_randomWrapper` per requesting class.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我在类中稍微改变了行为；最初，每次我们调用`Next`时都会创建一个新的`Random`实例，但现在它为每个请求的类创建一个`_randomWrapper`。
- en: 'As our `Next` class implementation depends on the thread-unsafe `_random.Next`,
    then our class is not thread-safe as well. So, when injecting it, we cannot inject
    it as a singleton; we have to inject it as a transient, so our `Program.cs` code
    looks like this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`Next`类实现依赖于线程不安全的`_random.Next`，因此我们的类也不是线程安全的。因此，在注入时，我们不能将其作为单例注入；我们必须将其作为瞬态注入，因此我们的`Program.cs`代码如下所示：
- en: '[PRE68]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This might have worked as a `AddScoped` registration method, but the documentation
    is insufficient for me to decide, and transient is always the safest.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能作为一个`AddScoped`注册方法有效，但文档不足，我无法做出决定，而瞬态总是最安全的。
- en: You can now run the application, and from the Swagger UI, execute both APIs
    to make sure that everything is working as expected.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序，并通过Swagger UI执行两个API，以确保一切按预期工作。
- en: The DI changes that we have done are all in the `Ch02` source code in GitHub
    under a directory called `03-UqsWeather`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的DI更改都在GitHub上的`Ch02`源代码中，位于名为`03-UqsWeather`的目录下。
- en: Lifelike DI scenario
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逼真的DI场景
- en: The most common scenario for using DI is with unit testing, though I have seen
    it being used elsewhere to change the behavior of a certain component at runtime.
    Take the case where you want to change a functionality of a system based on a
    configuration, and another case where you want to change a system behavior per
    hosting environment. Consider the next example of **load-testing** our WFA application.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入（DI）最常见的情况是与单元测试结合使用，尽管我也见过它在其他地方被用来在运行时改变某个组件的行为。考虑以下两种情况：一种是基于配置更改系统功能，另一种是针对不同的托管环境更改系统行为。让我们考虑下一个例子，即**负载测试**我们的WFA应用程序。
- en: Using DI as a load-testing example
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用DI作为负载测试示例
- en: 'A common **non-functional requirement** (**NFR**) for critical systems is load
    testing. Load testing is an artificial simulation of calls to a system to measure
    how it handles high volumes of concurrent calls. For our WFA, load testing would
    look like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键系统，一个常见的**非功能性需求**（**NFR**）是负载测试。负载测试是对系统进行人工调用模拟以测量其处理高并发调用量的能力。对于我们的WFA，负载测试看起来会是这样：
- en: '![Figure 2.14 – WFA under load testing ](img/Figure_2.14_B18370.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 负载测试下的WFA](img/Figure_2.14_B18370.jpg)'
- en: Figure 2.14 – WFA under load testing
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 负载测试下的WFA
- en: A load-testing framework would start the test by issuing a pre-agreed number
    of calls to the APIs and measuring response times and failures. In turn, the APIs
    will exert loads on their dependencies.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试框架将通过向API发出预定的调用数量来启动测试，并测量响应时间和失败次数。反过来，API将对它们的依赖项施加负载。
- en: 'The complete WFA might have multiple dependencies, but what we are interested
    in specifically, in this example, is the *OpenWeather* API that we are calling
    in the background. If we are to load-test the WFA application, we will, by design,
    issue a heavy number of calls to *OpenWeather* and this *should not* be the case,
    for many reasons. Here are a few:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的WFA可能有多重依赖项，但在这个例子中，我们特别感兴趣的是我们在后台调用的*OpenWeather* API。如果我们要对WFA应用程序进行负载测试，我们将设计性地向*OpenWeather*发出大量的调用，这*不应该*是情况，有很多原因。以下是一些：
- en: Consuming the number of allocated calls quota
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗分配的调用配额数量
- en: Contractual agreement against load-testing their system through yours
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过你的系统对他们的系统进行负载测试的合同协议
- en: Being banned for an exorbitant number of calls in a short period
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在短时间内因调用过多而被禁止
- en: Ethical reasons, as this might affect their overall service quality
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伦理原因，因为这可能会影响他们的整体服务质量
- en: Unless your system requires specifically to load-test with the third party connected
    and you have an agreement with the third party to do so, I wouldn’t do it.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的系统需要与第三方连接进行负载测试，并且你已经与第三方达成协议这样做，否则我不会这样做。
- en: What can we do to work around this and conduct our load test without calling
    *OpenWeather*?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做些什么来绕过这个问题，并在不调用*OpenWeather*的情况下进行负载测试？
- en: A solution could be to add a configuration key to the WFA. When this key is
    `true`, we want every call in all our application to *OpenWeather* to return a
    stubbed response (canned response). More about dummy, mock, stub, and fake will
    be discussed in the next chapter. For now, we will refer to this type of response
    as a stubbed response.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在WFA中添加一个配置键。当这个键为`true`时，我们希望所有应用程序中对*OpenWeather*的调用都返回一个存根响应（预定义响应）。关于模拟、存根、存根和伪造的更多内容将在下一章讨论。现在，我们将这种类型的响应称为存根响应。
- en: Enabling an OpenWeather stubbed response
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用OpenWeather存根响应
- en: 'Let’s enable a stub response representing OpenWeather. Where do we start? I
    would directly look for the *seam* that is causing the call to OpenWeather. It
    is in our `WeatherForecastController` class, as illustrated here:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启用一个代表OpenWeather的存根响应。我们从哪里开始？我会直接寻找导致调用OpenWeather的*缝隙*。正如这里所示，它在我们的`WeatherForecastController`类中：
- en: '[PRE69]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'What we need to do is to keep the previous code the same but make this method
    change behavior by not going over the network and instead return some saved value
    when under a load test. Here is the plan to achieve this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是保持之前的代码不变，但通过不通过网络而是返回一些保存的值来改变这个方法的行为，当处于负载测试之下。以下是实现这一目标的计划：
- en: Add a configuration to denote load testing.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个配置来表示负载测试。
- en: Add a stubbed response class.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个存根响应类。
- en: Register a condition to swap responses based on the configuration.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个基于配置的响应交换条件。
- en: Adding configuration
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'We want the configuration to be off by default unless we explicitly set it
    *on*. In your `appsettings.json` file, add the following code:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望默认情况下配置是关闭的，除非我们明确将其设置为*开启*。在你的`appsettings.json`文件中，添加以下代码：
- en: '[PRE70]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And in our `appsettings.Development.json` file, add the same configuration,
    but set it to `true`. This should result in `true` when you load the application
    locally.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`appsettings.Development.json`文件中，添加相同的配置，但将其设置为`true`。当你本地加载应用程序时，这应该会显示为`true`。
- en: Adding the stub class
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加存根类
- en: '`OneCallAsync` is a method on the `IClient` interface. If you look at the code,
    we are passing the `client` object, which becomes `_client`, as an argument to
    the constructor. Here is where we can do some magic—we need to pass to the constructor
    our stubbed implementation of `IClient`, then figure out a way to pass it through
    the constructor.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneCallAsync` 是 `IClient` 接口上的一个方法。如果您查看代码，我们会将 `client` 对象，即 `_client`，作为参数传递给构造函数。在这里我们可以做一些魔法——我们需要将我们的
    `IClient` 模拟实现传递给构造函数，然后找出一种方法通过构造函数传递它。'
- en: 'Add a class called `ClientStub` to the root of your project to hold the implementation
    of our stubbed `IClient` interface, as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目根目录下添加一个名为 `ClientStub` 的类，以保存我们模拟的 `IClient` 接口实现，如下所示：
- en: '[PRE71]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`IClient` is defined in the NuGet package for the *OpenWeather* client. It
    has one method to implement `OneCallAsync`. I looked for the used properties and
    generated a 7-day fake forecast. Note that you might need to make a full stub
    in other scenarios.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`IClient` 定义在 *OpenWeather* 客户端的 NuGet 包中。它有一个实现 `OneCallAsync` 的方法。我查找了使用的属性并生成了一个
    7 天的虚假预报。请注意，您可能需要在其他场景中制作一个完整的模拟。'
- en: 'Now, both `Client` and `ClientStub` implement `IClient`, as per this diagram:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Client` 和 `ClientStub` 都实现了 `IClient`，正如这个图所示：
- en: '![Figure 2.15 – IClient, Client, and ClientStub relationship ](img/Figure_2.15_B18370.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – IClient、Client 和 ClientStub 的关系](img/Figure_2.15_B18370.jpg)'
- en: Figure 2.15 – IClient, Client, and ClientStub relationship
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – IClient、Client 和 ClientStub 的关系
- en: 'Now comes the step that developers forget to do often: registering the service.
    Remember that every time you forget to register a service, you are not alone.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是开发者经常忘记做的步骤：注册服务。请记住，每次您忘记注册服务时，您并不孤单。
- en: Updating IClient registration
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新 IClient 注册
- en: 'We are going to use our DI container to decide when to inject an instance of
    `Client` and when to inject an instance of `ClientStub`. In `Program.cs`, modify
    the initial register of `IClient` so that it looks like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的 DI 容器来决定何时注入 `Client` 的实例，何时注入 `ClientStub` 的实例。在 `Program.cs` 中，修改
    `IClient` 的初始注册，使其看起来像这样：
- en: '[PRE72]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Whenever an instance of `IClient` is requested, the DI container will decide
    what to inject, `ClientStub` or `Client`, based on the configuration.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 每当请求 `IClient` 的实例时，DI 容器将根据配置决定注入 `ClientStub` 或 `Client`。
- en: We now have the stubbing implementation completed and ready to run. Have a look
    at the output of the `GetReal` method when you run the project. You will notice
    you are getting the stubbed version if you’ve enabled load testing.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模拟实现并准备运行。当您运行项目时，查看 `GetReal` 方法的输出。如果您已启用负载测试，您将注意到您得到的是模拟版本。
- en: Points to note
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'We have seen, dare I say it, a beautiful way of swapping implementation. While
    this example is small and contained, the implementation will shine more in larger
    projects. Consider these points:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了，我敢说这是一种美丽的方式来交换实现。虽然这个例子很小且有限，但在更大的项目中，实现方式将更加出色。考虑以下这些要点：
- en: '**Separation of concerns** where the code to load different versions is taken
    away from the controller class to the registration section.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**，将加载不同版本代码的任务从控制器类移至注册部分。'
- en: The developer will not need to worry about or remember to do additional implementation
    when passing `IClient` to new controllers.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将 `IClient` 传递给新的控制器时，开发者无需担心或记住执行额外的实现。
- en: Similar to this scenario, you can use DI whenever a swap of implementation is
    required under certain conditions.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与此场景类似，在满足某些条件下需要交换实现时，你可以使用依赖注入（DI）。
- en: This scenario is located in the `Ch02` source code in GitHub under a directory
    called `04-UqsWeather`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景位于 GitHub 上 `Ch02` 源代码的 `04-UqsWeather` 目录中。
- en: Method injection
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法注入
- en: 'You have seen across the chapter that we have been injecting parameters through
    the constructor. There is another less popular form of injection, called **method
    injection**. This is an example from the WFA controller:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到我们一直在通过构造函数注入参数。还有一种不太流行的注入形式，称为 **方法注入**。这是一个来自 WFA 控制器的例子：
- en: '[PRE73]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice the `FromServices` attribute. This instructs the DI container to inject
    a dependency into a method in the same way it is injected into a constructor.
    Obviously, this is not needed in a constructor.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `FromServices` 属性。这指示 DI 容器以与构造函数中相同的方式将依赖项注入到方法中。显然，在构造函数中不需要这样做。
- en: You would use method injection when you have multiple methods in a class. One
    of them uses a special service. The benefit here is a cleaner class constructor
    and a bit of performance saving because the class—for example, the controller—might
    be instantiated, but the injection service would have a chance of not being used.
    So, there is a performance waste in injecting it but not using it.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类中有多个方法时，你会使用方法注入。其中一个使用特殊的服务。这里的优点是更干净的类构造函数，以及一点性能提升，因为类——例如，控制器——可能会被实例化，但注入服务可能不会被使用。所以，注入但不使用它会有性能浪费。
- en: In this example case, the logger was only used in the `ConvertCToF` method,
    so it can be moved from the constructor to the method. It needs to be injected
    only when `ConvertCToF`, not the controller, is instantiated to serve any other
    method.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例案例中，日志记录器仅在 `ConvertCToF` 方法中使用，因此它可以从构造函数移动到方法。它只需要在 `ConvertCToF` 而不是控制器被实例化时注入，以服务于任何其他方法。
- en: Best practices recommend classes with a single responsibility. This leads to
    related methods with related services, so you won’t find method injection as a
    popular pattern, but method injection is there if you need it.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践推荐具有单一职责的类。这导致相关的方法与相关的服务相关联，所以你不会找到方法注入作为一个流行的模式，但如果需要，方法注入是存在的。
- en: Property injection
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性注入
- en: '**Property injection** is injecting a service into a property on a class. This
    is not supported by Microsoft containers, but it is supported by third-party containers.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性注入**是将服务注入到类上的属性。微软容器不支持这种做法，但第三方容器支持。'
- en: I have seen this used with legacy systems where a DI container is gradually
    being introduced and code changes are at a minimum. However, I have never seen
    or used this in a greenfield application.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过这种方法在遗留系统中使用，其中 DI 容器正在逐步引入，代码更改最小。然而，我从未在绿色场应用中见过或使用过这种方法。
- en: I trust that it was not added to the Microsoft container, as it is not popular
    and not encouraged.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信它没有被添加到微软容器中，因为它不受欢迎，也不被鼓励。
- en: Service locator
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务定位器
- en: 'Every container comes with or integrates with a **service locator**. A service
    locator finds and activates a registered service. So, the DI container registers
    a service and the service locator resolves what is already registered. Here is
    a typical pattern of using a service locator:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都自带或集成了一个 **服务定位器**。服务定位器查找并激活已注册的服务。所以，DI 容器注册一个服务，服务定位器解析已注册的内容。这里是一个使用服务定位器的典型模式：
- en: '[PRE74]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`IServiceProvider` is an abstraction that supports service location. It can
    be injected into a class like any other service. Notice when we called the `GetService`
    method that it got us whatever is registered with `IMyClass`.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceProvider` 是一个支持服务定位的抽象。它可以像任何其他服务一样注入到类中。注意当我们调用 `GetService` 方法时，它给我们
    whatever 是注册了 `IMyClass` 的。'
- en: 'Obviously, you could have done the same thing by injecting `IMyClass` into
    the constructor, and it is even better to do so. You can see this being done here:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以通过将 `IMyClass` 注入构造函数来完成同样的事情，这样做甚至更好。你可以在这里看到它是如何被完成的：
- en: '[PRE75]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: But there are situations where you will want to avoid injection and prefer to
    use a service locator. This is more often used in legacy applications where DI
    is not fully implemented.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 但有些情况下，你会想要避免注入，而更愿意使用服务定位器。这通常在 DI 没有完全实现的遗留应用程序中使用。
- en: Using a service locator in code will complicate your unit tests, so it is better
    avoided, and some practitioners would consider using it as an anti-pattern.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用服务定位器会复杂化你的单元测试，所以最好避免使用，一些从业者甚至会将其视为反模式。
- en: Summary
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This is a long chapter, I admit, but my defense is that it has plenty of examples
    to cover many real-life DI scenarios. Also, DI automatically encourages good software
    engineering practices, so we had to include the relevant practices. If you were
    to develop TDD-style, you would spend around 10% of your coding time doing DI-related
    tasks, and I hope this chapter did the right job and added to your knowledge.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认这是一个很长的章节，但我的辩护是它有大量的例子来涵盖许多现实生活中的 DI 场景。此外，DI 自动鼓励良好的软件工程实践，所以我们不得不包括相关的实践。如果你要开发
    TDD 风格，你大约会花费 10% 的编码时间来做 DI 相关的任务，我希望这一章节做得正确，并增加了你的知识。
- en: DI is mainly used with unit tests, so without it, DI may feel less interesting.
    The next chapter, *Getting Started with Unit Testing*, will use the WFA application
    that we refactored here, and hopefully, you will appreciate further this design
    pattern.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: DI 主要与单元测试一起使用，所以没有它，DI 可能感觉不那么有趣。下一章，*单元测试入门*，将使用我们在这里重构的 WFA 应用程序，希望你能进一步欣赏这种设计模式。
- en: Further reading
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下链接：
- en: '*IoC*: [https://martinfowler.com/bliki/InversionOfControl.xhtml](https://martinfowler.com/bliki/InversionOfControl.xhtml)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制反转（IoC）*: [https://martinfowler.com/bliki/InversionOfControl.xhtml](https://martinfowler.com/bliki/InversionOfControl.xhtml)'
- en: '*DI in ASP.NET Core*: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ASP.NET Core 中的依赖注入（DI）*: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
