<html><head></head><body>
<div id="_idContainer071">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.2.1">Security and Identity in ASP.NET Core</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B18971_07.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we discussed some more advanced topics of EF Core, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">DbContext</span></strong><span class="koboSpan" id="kobo.7.1"> pooling, performance optimization, and concurrency control. </span><span class="koboSpan" id="kobo.7.2">At this point, you should have the skills to create a web API application that accesses the database using EF Core. </span><span class="koboSpan" id="kobo.7.3">However, the application is not secure. </span><span class="koboSpan" id="kobo.7.4">Without any authentication, anyone who knows the URL can access the API, potentially exposing sensitive data to the public. </span><span class="koboSpan" id="kobo.7.5">To ensure the security of the web API application, we must take </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">additional steps.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Security is a broad topic, and it is a crucial aspect of any application. </span><span class="koboSpan" id="kobo.9.2">In this chapter, we will explore some of the security features that ASP.NET Core provides, including authentication, authorization, and some best practices for securing your web API application. </span><span class="koboSpan" id="kobo.9.3">We will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Getting started with authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and authorization</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Delving deeper </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">into authorization</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Managing users </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and roles</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">New Identity API endpoints in ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Core 8</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Understanding OAuth 2.0 and </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">OpenID Connect</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Other </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">security topics</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">After reading this chapter, you will have a basic understanding of the security features in ASP.NET Core. </span><span class="koboSpan" id="kobo.23.2">You will also know how to implement authentication and various authorization types in your web API applications, such as role-based authorization, claim-based authorization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">policy-based authorization.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">The code examples in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</span></a><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">You can use VS Code or VS 2022 to open </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the solutions.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.30.1">Getting started with authentication and authorization</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Authentication</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.32.1"> and authorization are </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.33.1">two important aspects of security. </span><span class="koboSpan" id="kobo.33.2">Although these two terms are often used together, they are distinct concepts. </span><span class="koboSpan" id="kobo.33.3">Before we dive into the code, it is important to gain an understanding of the differences between authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">and authorization.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">We have already built some web API applications. </span><span class="koboSpan" id="kobo.35.2">However, these APIs will be publicly available to anyone who knows the URL. </span><span class="koboSpan" id="kobo.35.3">For some resources, we want to restrict access to only authenticated users. </span><span class="koboSpan" id="kobo.35.4">For example, we have a resource that contains some sensitive information that should not be available to everyone. </span><span class="koboSpan" id="kobo.35.5">In this case, the application should be able to identify the user who is making the request. </span><span class="koboSpan" id="kobo.35.6">If the user is anonymous, the application should not allow the user to access the resource. </span><span class="koboSpan" id="kobo.35.7">This is where authentication comes </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">into play.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">For some scenarios, we also want to restrict access to some specific users. </span><span class="koboSpan" id="kobo.37.2">For example, we want to allow authenticated users to read the resource, but only admin users to update or delete the resource. </span><span class="koboSpan" id="kobo.37.3">In this case, the application should be able to check whether the user has the required permissions to execute the operation. </span><span class="koboSpan" id="kobo.37.4">This is where authorization </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Long story short, authentication is used to know who the user is, while authorization is used to know what the user can do. </span><span class="koboSpan" id="kobo.39.2">Together, these processes are used to ensure that the user is who they claim to be and that they have the required permissions to access </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the resource.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">ASP.NET Core provides the Identity framework, which has a rich set of features for authentication and authorization. </span><span class="koboSpan" id="kobo.41.2">In this chapter, we will explore how to use the Identity framework to implement authentication and authorization in ASP.NET Core. </span><span class="koboSpan" id="kobo.41.3">We will also introduce some third-party </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">authentication providers</span><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Think about a scenario where we want to build a web API application that allows users to register and log in. </span><span class="koboSpan" id="kobo.44.2">For a specific endpoint, we only want to allow authenticated users to access the resource. </span><span class="koboSpan" id="kobo.44.3">In this section, we will explore how to implement this scenario. </span><span class="koboSpan" id="kobo.44.4">From this example, you will learn how to</span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.45.1"> implement a basic authentication and authorization</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.46.1"> system in ASP.NET Core; this will help you prepare for the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">We will use the following resources in </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">this example:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">POST /account/register</span></strong><span class="koboSpan" id="kobo.51.1">: This resource will be used to register a new user. </span><span class="koboSpan" id="kobo.51.2">The user should send the username and password in the request body. </span><span class="koboSpan" id="kobo.51.3">After validating the username and password, the application will create a new user in the database and return a JWT token to the user. </span><span class="koboSpan" id="kobo.51.4">This JWT token will be used to authenticate the user in </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">subsequent requests.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">POST /account/login</span></strong><span class="koboSpan" id="kobo.54.1">: This resource will be used to log into an existing user. </span><span class="koboSpan" id="kobo.54.2">After the user sends the username and password, the application will validate the credentials and return a JWT token to the user if the credentials are valid. </span><span class="koboSpan" id="kobo.54.3">The JWT token will be used to authenticate the user in </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">subsequent requests.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">GET /WeatherForecast</span></strong><span class="koboSpan" id="kobo.57.1">: This resource will be used to get the weather forecast. </span><span class="koboSpan" id="kobo.57.2">It only allows authenticated users to access the resource. </span><span class="koboSpan" id="kobo.57.3">The user should send the JWT token in the Authorization header to authenticate </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the user.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.59.1">There should be more endpoints to manage users, such as updating the user profile, deleting the user, resetting the password, and more. </span><span class="koboSpan" id="kobo.59.2">However, we are not building a complete application in this chapter. </span><span class="koboSpan" id="kobo.59.3">To keep things simple, we will only focus on the minimal features required to demonstrate the authentication and authorization features in </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">ASP.NET Core.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.61.1">What is JWT?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.62.1">JWT stands for </span><em class="italic"><span class="koboSpan" id="kobo.63.1">JSON Web Token</span></em><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">It is an industry standard for representing claims securely between two parties. </span><span class="koboSpan" id="kobo.64.3">The RFC for JWT is RFC 7519: </span><a href="https://www.rfc-editor.org/rfc/rfc7519"><span class="koboSpan" id="kobo.65.1">https://www.rfc-editor.org/rfc/rfc7519</span></a><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">A JWT token consists of three parts: header, payload, and signature. </span><span class="koboSpan" id="kobo.66.3">So, typically, a JWT token looks like </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">xxxxx.yyyyy.zzzzz</span></strong><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">The header contains the algorithm used to sign the token, the payload contains the claims, and the signature is used to verify the integrity of the token. </span><span class="koboSpan" id="kobo.68.3">For more information about JWT, </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">see </span></span><a href="https://jwt.io/introduction"><span class="No-Break"><span class="koboSpan" id="kobo.70.1">https://jwt.io/introduct</span><span id="_idTextAnchor312"/><span class="koboSpan" id="kobo.71.1">ion</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.72.1">.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.73.1">Creating a sample project with authentication and authorization</span></h2>
<p><span class="koboSpan" id="kobo.74.1">To begin, we</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.75.1"> must prepare the project and add any necessary NuGet packages. </span><span class="koboSpan" id="kobo.75.2">Additionally, we need to configure </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.76.1">the database context to enable us </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.77.1">to store user information in the database. </span><span class="koboSpan" id="kobo.77.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.79.1">Create a new ASP.NET Core web API project by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.81.1">dotnet new webapi -n AuthenticationDemo -controllers</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.82.1">This command will create a new ASP.NET Core web API project named </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">AuthenticationDemo</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">Open the project in VS Code. </span><span class="koboSpan" id="kobo.84.3">You can find the start project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">samples/chapter8/AuthenticationDemo/BasicAuthenticationDemo/start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1"> f</span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.88.1">older.</span></span></p></li> <li><span class="koboSpan" id="kobo.89.1">Now, it’s time to add the required NuGet packages. </span><span class="koboSpan" id="kobo.89.2">We will use ASP.NET Core Identity to implement the authentication. </span><span class="koboSpan" id="kobo.89.3">ASP.NET Core Identity is a membership system that provides authentication and authorization features. </span><span class="koboSpan" id="kobo.89.4">It is a part of the ASP.NET Core framework. </span><span class="koboSpan" id="kobo.89.5">We need to install the following </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">NuGet packages:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">Microsoft.AspNetCore.Identity.EntityFrameworkCore</span></strong><span class="koboSpan" id="kobo.92.1">: This package is used for the EF Core implementation of ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">Core Identity.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Microsoft.EntityFrameworkCore.SqlServer</span></strong><span class="koboSpan" id="kobo.95.1">: This package is used to connect to </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">SQL Server.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Microsoft.EntityFrameworkCore.Tools</span></strong><span class="koboSpan" id="kobo.98.1">: This package is used to enable the necessary EF </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">Core tools.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">Microsoft.AspNetCore.Authentication.JwtBearer</span></strong><span class="koboSpan" id="kobo.101.1">: This package is used to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">JWT authentication.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.103.1">The ASP.NET Core Identity package already comes with the default project template, so we do not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">insta</span><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.105.1">ll it.</span></span></p></li>
<li><span class="koboSpan" id="kobo.106.1">Next, we </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.107.1">will add</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.108.1"> the database context. </span><span class="koboSpan" id="kobo.108.2">We will use EF Core to access the database. </span><span class="koboSpan" id="kobo.108.3">But first, we need an entity model to represent the user. </span><span class="koboSpan" id="kobo.108.4">Create a new folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Authentication</span></strong><span class="koboSpan" id="kobo.110.1"> and add a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">AppUser</span></strong><span class="koboSpan" id="kobo.112.1"> to it. </span><span class="koboSpan" id="kobo.112.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">AppUser</span></strong><span class="koboSpan" id="kobo.114.1"> class </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.115.1">inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">IdentityUser</span></strong><span class="koboSpan" id="kobo.117.1"> class, which is provided by ASP.NET Core Identity, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.119.1">
public class AppUser : IdentityUser{}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.120.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">IdentityUser</span></strong><span class="koboSpan" id="kobo.122.1"> class already contains the properties that we need to represent a user for most of the scenarios, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">UserName</span></strong><span class="koboSpan" id="kobo.124.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">Email</span></strong><span class="koboSpan" id="kobo.126.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">PasswordHash</span></strong><span class="koboSpan" id="kobo.128.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">PhoneNumber</span></strong><span class="koboSpan" id="kobo.130.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">and others.</span></span></p></li> <li><span class="koboSpan" id="kobo.132.1">Next, we need to create a database context to access the database. </span><span class="koboSpan" id="kobo.132.2">Add a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.134.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">Authentication</span></strong><span class="koboSpan" id="kobo.136.1"> folder. </span><span class="koboSpan" id="kobo.136.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.138.1"> class inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">IdentityDbContext</span></strong><span class="koboSpan" id="kobo.140.1"> class, which is provided by ASP.NET Core Identity, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.142.1">
public class AppDbContext(DbContextOptions&lt;AppDbContext&gt; options, IConfiguration configuration) : IdentityDbContext&lt;AppUser&gt;(options){    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)    {        base.OnConfiguring(optionsBuilder);        optionsBuilder.UseSqlServer(_configuration.GetConnectionString("DefaultConnection"));    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.143.1">To</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.144.1"> provide the database connection</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.145.1"> string, we need to add the following configuration to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1"> file:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.148.1">"ConnectionStrings": {    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=AuthenticationDemo;Trusted_Connection=True;MultipleActiveResultSets=true"}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.149.1">As we</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.150.1"> can see, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.152.1"> is purely for ASP.NET Core Identity. </span><span class="koboSpan" id="kobo.152.2">If you have other entities in your application, you can create a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">DbContext</span></strong><span class="koboSpan" id="kobo.154.1"> for them if you want to. </span><span class="koboSpan" id="kobo.154.2">You can use the same connection string for </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">both</span><a id="_idTextAnchor316"/> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">DbContexts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.158.1">Next, we will need to create a few models for registering and logging in users because, when we register a user, we need to send the username, password, and email address. </span><span class="koboSpan" id="kobo.158.2">When we log a user in, we need to send the username and password. </span><span class="koboSpan" id="kobo.158.3">It would be good if we had separate models for these </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">different scenarios.</span></span></li>
<li><span class="koboSpan" id="kobo.160.1">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">AddOrUpdateAppUserModel</span></strong><span class="koboSpan" id="kobo.162.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">Authentication</span></strong><span class="koboSpan" id="kobo.164.1"> folder. </span><span class="koboSpan" id="kobo.164.2">This class will be used to represent the user when we register a new user. </span><span class="koboSpan" id="kobo.164.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">AddOrUpdateAppUserModel</span></strong><span class="koboSpan" id="kobo.166.1"> class should contain </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.167.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">following properties:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.169.1">
public class AddOrUpdateAppUserModel{    [Required(ErrorMessage = "User name is required")]    public string UserName { get; set; } = string.Empty;    [EmailAddress]    [Required(ErrorMessage = "Email is required")]    public string Email { get; set; } = string.Empty;    [Required(ErrorMessage = "Password is required")]    public string Password { get; set; } = string.Empty;}</span></pre></li> <li><span class="koboSpan" id="kobo.170.1">Similarly, create </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.171.1">a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">LoginModel</span></strong><span class="koboSpan" id="kobo.173.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Authentication</span></strong><span class="koboSpan" id="kobo.175.1"> folder, as </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.176.1">shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.178.1">
public class LoginModel{    [Required(ErrorMessage = "User name is required")]    public string UserName { get; set; } = string.Empty;    [Required(ErrorMessage = "Password is required")]    public string Password { get; set; } = string.Empty;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.179.1">We </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.180.1">can add more properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">AppUser</span></strong><span class="koboSpan" id="kobo.182.1"> class if we need to. </span><span class="koboSpan" id="kobo.182.2">For example, you can add </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">FirstName</span></strong><span class="koboSpan" id="kobo.184.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">LastName</span></strong><span class="koboSpan" id="kobo.186.1">, and also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">ProfilePicture</span></strong><span class="koboSpan" id="kobo.188.1"> property to store the user’s profile picture, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">following code:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.190.1">public class AppUser : IdentityUser{    public string FirstName { get; set; }    public string LastName { get; set; }    public string ProfilePicture { get; set; }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.191.1">If you </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.192.1">add additional properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">AppUser</span></strong><span class="koboSpan" id="kobo.194.1"> class, you need to add the corresponding properties for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">AddOrUpdateAppU</span><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.196.1">serModel</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.197.1">as well.</span></span></p></li> <li><span class="koboSpan" id="kobo.198.1">Next, we</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.199.1"> need to configure the authentication service. </span><span class="koboSpan" id="kobo.199.2">First, let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.201.1"> file to provide the configurations for </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">JWT tokens:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
"JwtConfig": {    "ValidAudiences": "http://localhost:5056",    "ValidIssuer": "http://localhost:5056",    "Secret": "c1708c6d-7c94-466e-aca3-e09dcd1c2042"  }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.204.1">Update the configurations as per your requirements. </span><span class="koboSpan" id="kobo.204.2">Because we use the same web API to issue and validate the JWT token, we use the same URL for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ValidAudiences</span></strong><span class="koboSpan" id="kobo.206.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">ValidIssuer</span></strong><span class="koboSpan" id="kobo.208.1"> properties. </span><span class="koboSpan" id="kobo.208.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">Secret</span></strong><span class="koboSpan" id="kobo.210.1"> property is used to sign the JWT token. </span><span class="koboSpan" id="kobo.210.2">You can use any string as the secret. </span><span class="koboSpan" id="kobo.210.3">In this case, we can use a </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.211.1">GUID value. </span><span class="koboSpan" id="kobo.211.2">Also, please note that this is for demo purposes only. </span><span class="koboSpan" id="kobo.211.3">In a real-world application, you should store the secret in a secure location, such as Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">Key Vault.</span></span></p></li> <li><span class="koboSpan" id="kobo.213.1">Update </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.214.1">the </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.215.1">code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">Program.cs</span></strong><span class="koboSpan" id="kobo.217.1"> file, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.219.1">
// Omitted for brevitybuilder.Services.AddControllers();builder.Services.AddDbContext&lt;AppDbContext&gt;();builder.Services.AddIdentityCore&lt;AppUser&gt;()    .AddEntityFrameworkStores&lt;AppDbContext&gt;()    .AddDefaultTokenProviders();builder.Services.AddAuthentication(options =&gt;{    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;}).AddJwtBearer(options =&gt;{    var secret = builder.Configuration["JwtConfig:Secret"];    var issuer = builder.Configuration["JwtConfig:ValidIssuer"];    var audience = builder.Configuration["JwtConfig:ValidAudiences"];    if (secret is null || issuer is null || audience is null)    {        throw new ApplicationException("Jwt is not set in the configuration");    }    options.SaveToken = true;    options.RequireHttpsMetadata = false;    options.TokenValidationParameters = new TokenValidationParameters()    {        ValidateIssuer = true,        ValidateAudience = true,        ValidAudience = audience,        ValidIssuer = issuer,        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret))    };});// Omitted for brevityapp.UseHttpsRedirection();app.UseAuthentication();app.UseAuthorization();// Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.220.1">In the</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.221.1"> preceding code, we configured the authentication service to use JWT tokens. </span><span class="koboSpan" id="kobo.221.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">AddIdentityCore()</span></strong><span class="koboSpan" id="kobo.223.1"> method adds and configures the identity system for the specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">User</span></strong><span class="koboSpan" id="kobo.225.1"> type. </span><span class="koboSpan" id="kobo.225.2">We also added </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">AppUser</span></strong><span class="koboSpan" id="kobo.229.1"> to the service collection and specified that we want to use EF Core to store the user data. </span><span class="koboSpan" id="kobo.229.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">AddDefaultTokenProviders()</span></strong><span class="koboSpan" id="kobo.231.1"> method adds the default token providers for the application, which are used to generate tokens. </span><span class="koboSpan" id="kobo.231.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Services.AddAuthentication()</span></strong><span class="koboSpan" id="kobo.233.1"> method configures the authentication service to use JWT tokens. </span><span class="koboSpan" id="kobo.233.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">AddJwtBearer()</span></strong><span class="koboSpan" id="kobo.235.1"> method configures the JWT bearer </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.236.1">authentication handler, including the token validation parameters. </span><span class="koboSpan" id="kobo.236.2">We use some configurations from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.238.1"> file to configure the token </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">validation parameters.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.240.1">Finally, we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">UseAuthentication()</span></strong><span class="koboSpan" id="kobo.242.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">UseAuthorization()</span></strong><span class="koboSpan" id="kobo.244.1"> methods to enable authentication and authorizat</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.245.1">ion in </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the application.</span></span></p></li> <li><span class="koboSpan" id="kobo.247.1">Now, it’s </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.248.1">time to create and update the database. </span><span class="koboSpan" id="kobo.248.2">We have already created the database context and the user entity. </span><span class="koboSpan" id="kobo.248.3">So, now, we need to create the database. </span><span class="koboSpan" id="kobo.248.4">To do that, just run the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.250.1">dotnet ef migrations add InitialDb</span></strong><strong class="bold"><span class="koboSpan" id="kobo.251.1">dotnet ef database update</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.252.1">If the commands are executed successfully, you should see the database created with the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">following tables:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.254.1"><img alt="Figure 8.1 – The database tables created by ASP.NET Core Identity" src="image/B18971_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">Figure 8.1 – The database tables created by ASP.NET Core Identity</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.256.1">Another </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.257.1">way to</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.258.1"> check whether the database </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.259.1">has been created is to add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
using (var serviceScope = app.Services.CreateScope()){    var services = serviceScope.ServiceProvider;    // Ensure the database is created.    var dbContext = services.GetRequiredService&lt;AppDbContext&gt;();    dbContext.Database.EnsureCreated();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.263.1">You can use either of the methods to check whether the database is created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">development environment.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.265.1">The data for the users will be stored in these tables, which is convenient when using the default tables provide</span><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.266.1">d by ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">Core Identity.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.268.1">Next, let’s </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.269.1">apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Authorize</span></strong><span class="koboSpan" id="kobo.271.1"> attribute </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.272.1">to enable authentication and authorization </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">WeatherForecastController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.276.1">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.278.1"> by adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">[Authorize]</span></strong><span class="koboSpan" id="kobo.280.1"> attribute, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
[Authorize][ApiController][Route("[controller]")]public class WeatherForecastController : ControllerBase{    // ...}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.283.1">This </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.284.1">attribute will ensure that the user is authenticated before accessing the controller. </span><span class="koboSpan" id="kobo.284.2">If the user is not authenticated, the controller will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.286.1"> response. </span><span class="koboSpan" id="kobo.286.2">Test this by running the application and calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">/WeatherForecast</span></strong><span class="koboSpan" id="kobo.288.1"> endpoint. </span><span class="koboSpan" id="kobo.288.2">You should see a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">401</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1"> response:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.291.1"><img alt="Figure 8.2 – When the user is not authenticated, the controller returns a 401 response" src="image/B18971_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.292.1">Figure 8.2 – When the user is not authenticated, the controller returns a 401 response</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.293.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Authorize</span></strong><span class="koboSpan" id="kobo.295.1"> attribute can be applied to the controller or the action method. </span><span class="koboSpan" id="kobo.295.2">If the attribute is applied to the controller, all the action methods in the controller will be protected. </span><span class="koboSpan" id="kobo.295.3">If the attribute is applied to the action method, only that action method will </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">be protected.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.297.1">You can</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.298.1"> also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">AllowAnonymous</span></strong><span class="koboSpan" id="kobo.300.1"> attribute to allow anonymous access to the controller or action method. </span><span class="koboSpan" id="kobo.300.2">Note </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.301.1">that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">AllowAnonymous</span></strong><span class="koboSpan" id="kobo.303.1"> attribute overrides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">Authorize</span></strong><span class="koboSpan" id="kobo.305.1"> attribute. </span><span class="koboSpan" id="kobo.305.2">So, if you apply both attributes to the controller or action method, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">AllowAnonymous</span></strong><span class="koboSpan" id="kobo.307.1"> attribute will take precedence, which means that the controller or action method will be accessible to all </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the users.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.309.1">Next, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">AccountController</span></strong><span class="koboSpan" id="kobo.311.1"> to handle the authentication requests. </span><span class="koboSpan" id="kobo.311.2">For </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.312.1">example, we need to provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">/account/register</span></strong><span class="koboSpan" id="kobo.314.1"> endpoint. </span><span class="koboSpan" id="kobo.314.2">When the user sends the username and password, the application will create a record of the user in the database and generate a </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">JWT token.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.316.1">To generate a JWT token, we need to provide the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">following information:</span></span></p><ul><li><strong class="bold"><span class="koboSpan" id="kobo.318.1">The issuer of the token</span></strong><span class="koboSpan" id="kobo.319.1">: This is the server that issues </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">the token.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.321.1">The audience of the token</span></strong><span class="koboSpan" id="kobo.322.1">: This is the server that consumes the token. </span><span class="koboSpan" id="kobo.322.2">It can be the same as the issuer or include </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">multiple servers.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.324.1">The secret key to sign the token</span></strong><span class="koboSpan" id="kobo.325.1">: This is used to validate </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">the token.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.327.1">We already defined these values in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.329.1"> file as described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">previous steps.</span></span></p></li>
<li><span class="koboSpan" id="kobo.331.1">Next, create a new controller named </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">AccountController</span></strong><span class="koboSpan" id="kobo.333.1"> to handle the authentication requests. </span><span class="koboSpan" id="kobo.333.2">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">AccountController</span></strong><span class="koboSpan" id="kobo.335.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Controllers</span></strong><span class="koboSpan" id="kobo.337.1"> folder. </span><span class="koboSpan" id="kobo.337.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">AccountController</span></strong><span class="koboSpan" id="kobo.339.1"> class should inherit from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ControllerBase</span></strong><span class="koboSpan" id="kobo.341.1"> class, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
[ApiController][Route("[controller]")]public class AccountController(UserManager&lt;AppUser&gt; userManager, IConfiguration configuration) : ControllerBase{}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.344.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">UserManager</span></strong><span class="koboSpan" id="kobo.346.1"> class to manage the users. </span><span class="koboSpan" id="kobo.346.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">UserManager</span></strong><span class="koboSpan" id="kobo.348.1"> class is provided by ASP.NET Core Identity. </span><span class="koboSpan" id="kobo.348.2">We also need to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">IConfiguration</span></strong><span class="koboSpan" id="kobo.350.1"> interface to get the configuration values from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> file.</span></span></p></li> <li><span class="koboSpan" id="kobo.353.1">Create a </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.354.1">new method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Register()</span></strong><span class="koboSpan" id="kobo.356.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">AccountController</span></strong><span class="koboSpan" id="kobo.358.1"> class. </span><span class="koboSpan" id="kobo.358.2">This </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.359.1">method will be used to register a </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.360.1">new user. </span><span class="koboSpan" id="kobo.360.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">Register()</span></strong><span class="koboSpan" id="kobo.362.1"> method should accept an </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">AddOrUpdateAppUserModel</span></strong><span class="koboSpan" id="kobo.364.1"> object as a parameter, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
[HttpPost("register")]public async Task&lt;IActionResult&gt; Register([FromBody] AddOrUpdateAppUserModel model){    // Check if the model is valid    if (ModelState.IsValid)    {        var existedUser = await userManager.FindByNameAsync(model.UserName);        if (existedUser != null)        {            ModelState.AddModelError("", "User name is already taken");            return BadRequest(ModelState);        }        // Create a new user object        var user = new AppUser()        {            UserName = model.UserName,            Email = model.Email,            SecurityStamp = Guid.NewGuid().ToString()        };        // Try to save the user        var result = await userManager.CreateAsync(user, model.Password);        // If the user is successfully created, return Ok        if (result.Succeeded)        {            var token = GenerateToken(model.UserName);            return Ok(new { token });        }        // If there are any errors, add them to the ModelState object        // and return the error to the client        foreach (var error in result.Errors)        {            ModelState.AddModelError("", error.Description);        }    }    // If we got this far, something failed, redisplay form    return BadRequest(ModelState);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.367.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">UserManager</span></strong><span class="koboSpan" id="kobo.369.1"> class provides a set of methods to manage the users, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">FindByNameAsync</span></strong><span class="koboSpan" id="kobo.371.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">FindByNameAsync()</span></strong><span class="koboSpan" id="kobo.373.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">CreateAsync()</span></strong><span class="koboSpan" id="kobo.375.1">, and others. </span><span class="koboSpan" id="kobo.375.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">GenerateToken()</span></strong><span class="koboSpan" id="kobo.377.1"> method </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.378.1">is a </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.379.1">private method that generates</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.380.1"> a JWT token for the user, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">following code:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.382.1">private string? </span><span class="koboSpan" id="kobo.382.2">GenerateToken(string userName){    var secret = _configuration["JwtConfig:Secret"];    var issuer = _configuration["JwtConfig:ValidIssuer"];    var audience = _configuration["JwtConfig:ValidAudiences"];    if (secret is null || issuer is null || audience is null)    {        throw new ApplicationException("Jwt is not set in the configuration");    }    var signingKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret));    var tokenHandler = new JwtSecurityTokenHandler();    var tokenDescriptor = new SecurityTokenDescriptor    {        Subject = new ClaimsIdentity(new[]        {            new Claim(ClaimTypes.Name, userName)        }),        Expires = DateTime.UtcNow.AddDays(1),        Issuer = issuer,        Audience = audience,        SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)    };    var securityToken = tokenHandler.CreateToken(tokenDescriptor);    var token = tokenHandler.WriteToken(securityToken);    return token;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.383.1">In the</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.384.1"> preceding </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.385.1">code, we are using</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.386.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">JwtSecurityTokenHandler</span></strong><span class="koboSpan" id="kobo.388.1"> class to generate the JWT token. </span><span class="koboSpan" id="kobo.388.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">JwtSecurityTokenHandler</span></strong><span class="koboSpan" id="kobo.390.1"> class is provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">System.IdentityModel.Tokens.Jwt</span></strong><span class="koboSpan" id="kobo.392.1"> NuGet package. </span><span class="koboSpan" id="kobo.392.2">First, we get the configuration values from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.394.1"> file. </span><span class="koboSpan" id="kobo.394.2">Then, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">SymmetricSecurityKey</span></strong><span class="koboSpan" id="kobo.396.1"> object using the secret key. </span><span class="koboSpan" id="kobo.396.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">SymmetricSecurityKey</span></strong><span class="koboSpan" id="kobo.398.1"> object is used to sign </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the token.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.400.1">Next, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">SecurityTokenDescriptor</span></strong><span class="koboSpan" id="kobo.402.1"> object, which contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">following properties:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Subject</span></strong><span class="koboSpan" id="kobo.405.1">: The subject of the token. </span><span class="koboSpan" id="kobo.405.2">The subject can be any value, such as the username, email address, and </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">so on.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Expires</span></strong><span class="koboSpan" id="kobo.408.1">: The expiration date of </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the token.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Issuer</span></strong><span class="koboSpan" id="kobo.411.1">: The issuer of </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">the token.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Audience</span></strong><span class="koboSpan" id="kobo.414.1">: The audience of </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the token.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">SigningCredentials</span></strong><span class="koboSpan" id="kobo.417.1">: The credentials to sign the token. </span><span class="koboSpan" id="kobo.417.2">Note that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">HmacSha256Signature</span></strong><span class="koboSpan" id="kobo.419.1"> algorithm to sign the token. </span><span class="koboSpan" id="kobo.419.2">It is a 256-bit HMAC cryptographic algorithm for digital signatures. </span><span class="koboSpan" id="kobo.419.3">If you encounter an error such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">IDX10603: The algorithm: 'HS256' requires the SecurityKey.KeySize to be greater than '128' bits.</span></strong><span class="koboSpan" id="kobo.421.1">, please check the secret key in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.423.1"> file. </span><span class="koboSpan" id="kobo.423.2">The secret key should be at least 16 characters long (16 * 8 = </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">128).</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.425.1">Finally, we </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.426.1">used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">JwtSecurityTokenHandler</span></strong><span class="koboSpan" id="kobo.428.1"> class to create and write the token to a </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">string value.</span></span></p></li> <li><span class="koboSpan" id="kobo.430.1">Now, we </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.431.1">can</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.432.1"> test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Register()</span></strong><span class="koboSpan" id="kobo.434.1"> method. </span><span class="koboSpan" id="kobo.434.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">dotnet run</span></strong><span class="koboSpan" id="kobo.436.1"> to run the application. </span><span class="koboSpan" id="kobo.436.2">You can use the Swagger UI or any other tools to test the API. </span><span class="koboSpan" id="kobo.436.3">Send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">POST</span></strong><span class="koboSpan" id="kobo.438.1"> request with the following JSON data to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">http://localhost:5056/account/register</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1"> endpoint:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.441.1">
{  "userName": "admin",  "email": "admin@example.com",  "password": "Passw0rd!"}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.442.1">You will see the response similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the following:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.444.1"><img alt="Figure 8.3 – Registering a new user" src="image/B18971_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.445.1">Figure 8.3 – Registering a new user</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.446.1">As we</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.447.1"> can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Register()</span></strong><span class="koboSpan" id="kobo.449.1"> method returns a JWT token. </span><span class="koboSpan" id="kobo.449.2">The token is valid for 1 day. </span><span class="koboSpan" id="kobo.449.3">We </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.450.1">can use this token to authenticate </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.451.1">the user in the future. </span><span class="koboSpan" id="kobo.451.2">If you check the database, you will see that a new user has been created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">AspNetUsers</span></strong><span class="koboSpan" id="kobo.453.1"> table, and the password is hashed, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.455.1"><img alt="Figure 8.4 – The new user has been created in the database" src="image/B18971_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.456.1">Figure 8.4 – The new user has been created in the database</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.457.1">Copy the token value and send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">GET</span></strong><span class="koboSpan" id="kobo.459.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">/WeatherForecast</span></strong><span class="koboSpan" id="kobo.461.1"> endpoint. </span><span class="koboSpan" id="kobo.461.2">You need to attach the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Bearer</span></strong><span class="koboSpan" id="kobo.463.1"> token to the request header, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.465.1"><img alt="Figure 8.5 – Sending a request with the Bearer token" src="image/B18971_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.466.1">Figure 8.5 – Sending a request with the Bearer token</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.467.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.468.1">When you attach the bearer token to the request, please note that there is a prefix of </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Bearer</span></strong><span class="koboSpan" id="kobo.470.1"> before the token value. </span><span class="koboSpan" id="kobo.470.2">So, the actual format </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">should be</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">Authorization: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Bearer &lt;token&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">OK, it works! </span><span class="koboSpan" id="kobo.475.2">Your API </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.476.1">is</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.477.1"> now secured. </span><span class="koboSpan" id="kobo.477.2">The next step is </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.478.1">to create a login method to authenticate the user. </span><span class="koboSpan" id="kobo.478.2">It is quite straightforward. </span><span class="koboSpan" id="kobo.478.3">Create a new method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Login</span></strong><span class="koboSpan" id="kobo.480.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">AccountController</span></strong><span class="koboSpan" id="kobo.482.1"> class. </span><span class="koboSpan" id="kobo.482.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">Login()</span></strong><span class="koboSpan" id="kobo.484.1"> method should accept an </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">AddOrUpdateAppUserModel</span></strong><span class="koboSpan" id="kobo.486.1"> object as a parameter, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
[HttpPost("login")]public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel model)
{
    // Get the secret in the configuration
    // Check if the model is valid
    if (ModelState.IsValid)
    {
        var user = await _userManager.FindByNameAsync(model.UserName);
        if (user != null)
        {
            if (await _userManager.CheckPasswordAsync(user, model.Password))
            {
                var token = GenerateToken(model.UserName);
                return Ok(new { token });
            }
        }
        // If the user is not found, display an error message
        ModelState.AddModelError("", "Invalid username or password");
    }
    return BadRequest(ModelState);
}</span></pre>
<p><span class="koboSpan" id="kobo.489.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">UserManager</span></strong><span class="koboSpan" id="kobo.491.1"> class to find the user by the username. </span><span class="koboSpan" id="kobo.491.2">If the user is found, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">CheckPasswordAsync()</span></strong><span class="koboSpan" id="kobo.493.1"> method to check</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.494.1"> the password. </span><span class="koboSpan" id="kobo.494.2">If the password is correct, we generate a new token and return it to the client. </span><span class="koboSpan" id="kobo.494.3">If the user is not found or the password is incorrect, we return an error message to </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">So far, we </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.497.1">have created a </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.498.1">web API project with basic authentication and authorization. </span><span class="koboSpan" id="kobo.498.2">We also created a controller to handle account-related operations. </span><span class="koboSpan" id="kobo.498.3">Note that in this example, we have not implemented any specific authorization rules. </span><span class="koboSpan" id="kobo.498.4">All authenticated users can access the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">WeatherForecast</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1"> endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Ne</span><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.502.1">xt, we will discuss the details of the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">JWT token.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.504.1">Understanding the JWT token structure</span></h2>
<p><span class="koboSpan" id="kobo.505.1">A JWT token is a </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.506.1">string value. </span><span class="koboSpan" id="kobo.506.2">It is composed of three parts, separated by a </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">dot (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">.</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">):</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.510.1">Header</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.511.1">Payload</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.512.1">Signature</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.513.1">The header and payload are encoded using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Base64Url</span></strong><span class="koboSpan" id="kobo.515.1"> algorithm. </span><span class="koboSpan" id="kobo.515.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">jwt.io</span></strong><span class="koboSpan" id="kobo.517.1"> to decode the token. </span><span class="koboSpan" id="kobo.517.2">Copy the token in the response body and paste it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Encoded</span></strong><span class="koboSpan" id="kobo.519.1"> field on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">jwt.io</span></strong><span class="koboSpan" id="kobo.521.1"> website. </span><span class="koboSpan" id="kobo.521.2">You will see the decoded token, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.523.1"><img alt="Figure 8.6 – Decoding the JWT token" src="image/B18971_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.524.1">Figure 8.6 – Decoding the JWT token</span></p>
<p><span class="koboSpan" id="kobo.525.1">The header contains the</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.526.1"> algorithm used to sign the token. </span><span class="koboSpan" id="kobo.526.2">In our case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">HmacSha256Signature</span></strong><span class="koboSpan" id="kobo.528.1"> algorithm. </span><span class="koboSpan" id="kobo.528.2">So, the decoded header is </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
{  "alg": "HS256",
  "typ": "JWT"
}</span></pre>
<p><span class="koboSpan" id="kobo.531.1">The payload contains the claims of the token and some other additional data. </span><span class="koboSpan" id="kobo.531.2">In our case, the decoded payload is </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
{  "unique_name": "admin",
  "nbf": 1679779000,
  "exp": 1679865400,
  "iat": 1679779000,
  "iss": "http://localhost:5056",
  "aud": "http://localhost:5056"
}</span></pre>
<p><span class="koboSpan" id="kobo.534.1">There are some </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.535.1">recommended (but not mandatory) registered claim names defined </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">in RFC7519:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">sub</span></strong><span class="koboSpan" id="kobo.538.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">sub</span></strong><span class="koboSpan" id="kobo.540.1"> (subject) claim identifies the principal that is the subject of </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">the token</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">nbf</span></strong><span class="koboSpan" id="kobo.543.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">nbf</span></strong><span class="koboSpan" id="kobo.545.1"> (not before) claim identifies the time before which the token </span><em class="italic"><span class="koboSpan" id="kobo.546.1">must not</span></em><span class="koboSpan" id="kobo.547.1"> be accepted </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">for processing</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">exp</span></strong><span class="koboSpan" id="kobo.550.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">exp</span></strong><span class="koboSpan" id="kobo.552.1"> (expiration time) claim identifies the expiration time on or after which the token </span><em class="italic"><span class="koboSpan" id="kobo.553.1">must not</span></em><span class="koboSpan" id="kobo.554.1"> be accepted </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">for processing</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">iat</span></strong><span class="koboSpan" id="kobo.557.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">iat</span></strong><span class="koboSpan" id="kobo.559.1"> (issued at) claim identifies the time at which the token </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">was issued</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">iss</span></strong><span class="koboSpan" id="kobo.562.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">iss</span></strong><span class="koboSpan" id="kobo.564.1"> (issuer) claim identifies the principal that issued </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">the token</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">aud</span></strong><span class="koboSpan" id="kobo.567.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">aud</span></strong><span class="koboSpan" id="kobo.569.1"> (audience) claim identifies the recipients that the token is </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">intended for</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.571.1">Note that in our case, we use the same value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">iss</span></strong><span class="koboSpan" id="kobo.573.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">aud</span></strong><span class="koboSpan" id="kobo.575.1"> claims because we use the same web API to issue and validate the token. </span><span class="koboSpan" id="kobo.575.2">In a real-world application, normally, there is a separate authentication server to issue the token so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">iss</span></strong><span class="koboSpan" id="kobo.577.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">aud</span></strong><span class="koboSpan" id="kobo.579.1"> claims have </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">different values.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">The signature is used to verify the token to make sure the token does not tamper. </span><span class="koboSpan" id="kobo.581.2">There are various algorithms to generate the signature. </span><span class="koboSpan" id="kobo.581.3">In our case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">HmacSha256Signature</span></strong><span class="koboSpan" id="kobo.583.1"> algorithm, so the signature is generated using the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">following formula:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">HMACSHA256(base64UrlEncode(header) + "." </span><span class="koboSpan" id="kobo.585.2">+ </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">base64UrlEncode(payload), secret)</span></strong></span></p>
<p><span class="koboSpan" id="kobo.587.1">Therefore, the </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.588.1">token typically looks like </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">xxxxx.yyyyy.zzzzz</span></strong><span class="koboSpan" id="kobo.590.1">, which can be easily passed in the HTTP request he</span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.591.1">ader, or stored in the local storage of </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">the browser.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.593.1">Consuming the API</span></h2>
<p><span class="koboSpan" id="kobo.594.1">At this</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.595.1"> point, we have a secured API. </span><span class="koboSpan" id="kobo.595.2">You can find a sample client application named </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">AuthenticationDemoClient</span></strong><span class="koboSpan" id="kobo.597.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">samples\chapter8\AuthenticationDemo\BasicAuthenticationDemo\end</span></strong><span class="koboSpan" id="kobo.599.1"> folder. </span><span class="koboSpan" id="kobo.599.2">The client application is a simple console application. </span><span class="koboSpan" id="kobo.599.3">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">HttpClient</span></strong><span class="koboSpan" id="kobo.601.1"> class to send HTTP requests to the API. </span><span class="koboSpan" id="kobo.601.2">The main code is </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">like this:</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.603.1">Login:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
var httpClient = new HttpClient();// Create a post request with the user name and password
var request = new HttpRequestMessage(HttpMethod.Post, "http://localhost:5056/authentication/login");
request.Content = new StringContent(JsonSerializer.Serialize(new LoginModel()
{
    UserName = userName,
    Password = password
}), Encoding.UTF8, "application/json");
var response = await httpClient.SendAsync(request);
var token = string.Empty;
if (response.IsSuccessStatusCode)
{
    var content = await response.Content.ReadAsStringAsync();
    var jwtToken = JsonSerializer.Deserialize&lt;JwtToken&gt;(content);
    Console.WriteLine(jwtToken.token);
    token = jwtToken.token;
}</span></pre>
<p><span class="koboSpan" id="kobo.605.1">Get </span><a id="_idIndexMarker753"/><span class="No-Break"><span class="koboSpan" id="kobo.606.1">weather forecast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
request = new HttpRequestMessage(HttpMethod.Get, "http://localhost:5056/WeatherForecast");// Add the token to the request header
request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
response = await httpClient.SendAsync(request);
if (response.IsSuccessStatusCode)
{
    var content = await response.Content.ReadAsStringAsync();
    var weatherForecasts = JsonSerializer.Deserialize&lt;IEnumerable&lt;WeatherForecast&gt;&gt;(content);
    foreach (var weatherForecast in weatherForecasts)
    {
        Console.WriteLine("Date: {0:d}", weatherForecast.Date);
        Console.WriteLine($"Temperature (C): {weatherForecast.TemperatureC}");
        Console.WriteLine($"Temperature (F): {weatherForecast.TemperatureF}");
        Console.WriteLine($"Summary: {weatherForecast.Summary}");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.608.1">First, the client application sends a request to the login API to get the token. </span><span class="koboSpan" id="kobo.608.2">Then, it attaches the </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.609.1">token to the request header and sends the request to the weather forecast AP</span><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.610.1">I. </span><span class="koboSpan" id="kobo.610.2">If the token is valid, the API will return </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the data.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.612.1">Configuring the Swagger UI to support authorization</span></h2>
<p><span class="koboSpan" id="kobo.613.1">You</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.614.1"> probably prefer to use the Swagger UI to test the APIs. </span><span class="koboSpan" id="kobo.614.2">The default configuration of the Swagger UI does not support </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.615.1">authorization. </span><span class="koboSpan" id="kobo.615.2">We need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">AddSwaggerGen()</span></strong><span class="koboSpan" id="kobo.617.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">Program</span></strong><span class="koboSpan" id="kobo.619.1"> class to support authorization. </span><span class="koboSpan" id="kobo.619.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Program</span></strong><span class="koboSpan" id="kobo.621.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
builder.Services.AddSwaggerGen(c =&gt;{
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. </span><span class="koboSpan" id="kobo.623.2">Example: \"Authorization: Bearer {token}\"",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] { }
        }
    });
});</span></pre>
<p><span class="koboSpan" id="kobo.624.1">The</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.625.1"> preceding code adds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">Bearer</span></strong><span class="koboSpan" id="kobo.627.1"> security definition to the Swagger UI. </span><span class="koboSpan" id="kobo.627.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">AddSecurityRequirement</span></strong><span class="koboSpan" id="kobo.629.1"> method adds</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.630.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Authorization</span></strong><span class="koboSpan" id="kobo.632.1"> header to the Swagger UI. </span><span class="koboSpan" id="kobo.632.2">Now, when you run the application, you will see the </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">Authorize</span></strong><span class="koboSpan" id="kobo.634.1"> button in the Swagger UI. </span><span class="koboSpan" id="kobo.634.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">Authorize</span></strong><span class="koboSpan" id="kobo.636.1"> button; you will see a pop-up window that allows you to enter the token, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.638.1"><img alt="Figure 8.7 – Entering the token in the Swagger UI" src="image/B18971_08_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.639.1">Figure 8.7 – Entering the token in the Swagger UI</span></p>
<p><span class="koboSpan" id="kobo.640.1">Enter the token</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.641.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">Value</span></strong><span class="koboSpan" id="kobo.643.1"> field. </span><span class="koboSpan" id="kobo.643.2">Then, click the </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">Authorize</span></strong><span class="koboSpan" id="kobo.645.1"> button. </span><span class="koboSpan" id="kobo.645.2">Now, you can test the APIs</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.646.1"> using the Swagger </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">UI directly:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.648.1">Caution</span></p>
<p class="callout"><span class="koboSpan" id="kobo.649.1">You need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">Bearer</span></strong><span class="koboSpan" id="kobo.651.1"> prefix to the token with </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">a space.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.653.1"><img alt="Figure 8.8 – The Swagger UI is authorized" src="image/B18971_08_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.654.1">Figure 8.8 – The Swagger UI is authorized</span></p>
<p><span class="koboSpan" id="kobo.655.1">You can find more information about the configuration for the Swagger UI </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">here: </span></span><a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore"><span class="No-Break"><span class="koboSpan" id="kobo.657.1">https://github.com/domaindrivendev/Swashbuckle.AspNetCore</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.658.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">In this section, we discussed the implementation of a web API project that supports authentication and authorization, including the creation of a controller to handle the login request. </span><span class="koboSpan" id="kobo.659.2">Additionally, we explored how to generate a JWT token and validate it, as well as how to use a console application to access the project resource and how to configure the Swagger UI to test the APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">with authorization.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">In the next section, we will learn more about authorization in ASP.NET Core. </span><span class="koboSpan" id="kobo.661.2">We will explore a couple of authorization types, including role-based authorization,</span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.662.1"> claim-based authorization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">policy-based authorization.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.664.1">Delving deeper into authorization</span></h1>
<p><span class="koboSpan" id="kobo.665.1">Authorization is </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.666.1">the process of determining whether a user is allowed to perform a specific action. </span><span class="koboSpan" id="kobo.666.2">In the previous section, we implemented a web API project that enables simple authentication and authorization. </span><span class="koboSpan" id="kobo.666.3">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Authorize</span></strong><span class="koboSpan" id="kobo.668.1"> attribute, only authenticated users can access the API. </span><span class="koboSpan" id="kobo.668.2">However, in many scenarios, we need to implement granular authorization. </span><span class="koboSpan" id="kobo.668.3">For example, some resources are only accessible to the administrator, while some resources are accessible to normal users. </span><span class="koboSpan" id="kobo.668.4">In this section, we will explore how to implement granular authorization in ASP.NET Core, including role-based authorization</span><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.669.1">, claim-based authorization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">policy-based authorization.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.671.1">Role-based authorization</span></h2>
<p><span class="koboSpan" id="kobo.672.1">You can </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.673.1">find the starter app and the completed app in this book’s GitHub repository at </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">chapter8/AuthorizationDemo/RoleBasedAuthorizationDemo</span></strong><span class="koboSpan" id="kobo.675.1">. </span><span class="koboSpan" id="kobo.675.2">The starter </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.676.1">app is similar to the application we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">previous section:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.678.1">We’ll start with the starter app. </span><span class="koboSpan" id="kobo.678.2">Don’t forget to create the database and run the migrations using the </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.680.1">dotnet ef database update</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.681.1">A role is a set of permissions that are assigned to a user. </span><span class="koboSpan" id="kobo.681.2">For example, the administrator role has permission to access all resources, while the normal user role has limited permissions. </span><span class="koboSpan" id="kobo.681.3">A user can be assigned to multiple roles. </span><span class="koboSpan" id="kobo.681.4">A role can be assigned to </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">multiple users.</span></span></p></li> <li><span class="koboSpan" id="kobo.683.1">Next, let’s define a few roles in the project. </span><span class="koboSpan" id="kobo.683.2">Create a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">AppRoles</span></strong><span class="koboSpan" id="kobo.685.1"> that is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
public static class AppRoles{    public const string Administrator = "Administrator";    public const string User = "User";    public const string VipUser = "VipUser";}</span></pre></li> <li><span class="koboSpan" id="kobo.688.1">In </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.689.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Program</span></strong><span class="koboSpan" id="kobo.691.1"> class, we need to explicitly call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">AddRoles()</span></strong><span class="koboSpan" id="kobo.693.1"> method after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">AddIdentityCore()</span></strong><span class="koboSpan" id="kobo.695.1"> method. </span><span class="koboSpan" id="kobo.695.2">The updated code is </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
// Use the `AddRoles()` methodbuilder.Services.AddIdentityCore&lt;AppUser&gt;()    .AddRoles&lt;IdentityRole&gt;()    .AddEntityFrameworkStores&lt;AppDbContext&gt;()    .AddDefaultTokenProviders();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.698.1">If you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">AddIdentity()</span></strong><span class="koboSpan" id="kobo.700.1"> method, you do not need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">AddRoles()</span></strong><span class="koboSpan" id="kobo.702.1"> method. </span><span class="koboSpan" id="kobo.702.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">AddIdentity()</span></strong><span class="koboSpan" id="kobo.704.1"> method will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">AddRoles()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.706.1">method internally.</span></span></p></li> <li><span class="koboSpan" id="kobo.707.1">We</span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.708.1"> also need to check whether the roles exist in the database. </span><span class="koboSpan" id="kobo.708.2">If not, we will create the roles. </span><span class="koboSpan" id="kobo.708.3">Add the code, </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.710.1">
using (var serviceScope = app.Services.CreateScope()){    var services = serviceScope.ServiceProvider;    var roleManager = app.Services.GetRequiredService&lt;RoleManager&lt;IdentityRole&gt;&gt;();    if (!await roleManager.RoleExistsAsync(AppRoles.User))    {        await roleManager.CreateAsync(new IdentityRole(AppRoles.User));    }    if (!await roleManager.RoleExistsAsync(AppRoles.VipUser))    {        await roleManager.CreateAsync(new IdentityRole(AppRoles.VipUser));    }    if (!await roleManager.RoleExistsAsync(AppRoles.Administrator))    {        await roleManager.CreateAsync(new IdentityRole(AppRoles.Administrator));    }}</span></pre></li> <li><span class="koboSpan" id="kobo.711.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">dotnet run</span></strong><span class="koboSpan" id="kobo.713.1"> to run </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.714.1">the application. </span><span class="koboSpan" id="kobo.714.2">You</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.715.1"> will see that the roles are created in </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">the database:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.717.1"><img alt="Figure 8.9 – Roles in the database" src="image/B18971_08_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.718.1">Figure 8.9 – Roles in the database</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.719.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">AccountController</span></strong><span class="koboSpan" id="kobo.721.1"> class, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">Register()</span></strong><span class="koboSpan" id="kobo.723.1"> method that is used to register a new user. </span><span class="koboSpan" id="kobo.723.2">Let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">Register()</span></strong><span class="koboSpan" id="kobo.725.1"> method to assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">User</span></strong><span class="koboSpan" id="kobo.727.1"> role to the new user. </span><span class="koboSpan" id="kobo.727.2">The updated code is </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
// Omitted for brevity// Try to save the uservar userResult = await userManager.CreateAsync(user, model.Password);// Add the user to the "User" rolevar roleResult = await userManager.AddToRoleAsync(user, AppRoles.User);// If the user is successfully created, return Okif (userResult.Succeeded &amp;&amp; roleResult.Succeeded){    var token = GenerateToken(model.UserName);    return Ok(new { token });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.730.1">Similarly, we</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.731.1"> can create a new action to register an administrator or a VIP user. </span><span class="koboSpan" id="kobo.731.2">You can check the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">completed app.</span></span></p></li> <li><span class="koboSpan" id="kobo.733.1">You can</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.734.1"> register a new administrator using any HTTP client you like. </span><span class="koboSpan" id="kobo.734.2">After the users are created, you can view the users and their roles in the database, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.735.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.736.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.738.1"><img alt="Figure 8.10 – Users and their roles in the database" src="image/B18971_08_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.739.1">Figure 8.10 – Users and their roles in the database</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.740.1">The data of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">AspNetUserRoles</span></strong><span class="koboSpan" id="kobo.742.1"> table is used to store the relationship between users and roles. </span><span class="koboSpan" id="kobo.742.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">UserId</span></strong><span class="koboSpan" id="kobo.744.1"> column is the primary key of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">AspNetUsers</span></strong><span class="koboSpan" id="kobo.746.1"> table, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">RoleId</span></strong><span class="koboSpan" id="kobo.748.1"> column is the primary key of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">AspNetRoles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1"> table.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.751.1">Next, we </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.752.1">need to update the method that is used to generate the JWT token. </span><span class="koboSpan" id="kobo.752.2">When we generate the token, we need to </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.753.1">include the roles of the user in the token. </span><span class="koboSpan" id="kobo.753.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">GetRolesAsync()</span></strong><span class="koboSpan" id="kobo.755.1"> method to get the roles and then add them to the claims. </span><span class="koboSpan" id="kobo.755.2">The updated code is </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.757.1">
var userRoles = await userManager.GetRolesAsync(user);var claims = new List&lt;Claim&gt;{    new(ClaimTypes.Name, userName)};claims.AddRange(userRoles.Select(role =&gt; new Claim(ClaimTypes.Role, role)));var tokenDescriptor = new SecurityTokenDescriptor{    Subject = new ClaimsIdentity(claims),    Expires = DateTime.UtcNow.AddDays(1),    Issuer = issuer,    Audience = audience,    SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)};</span></pre></li> <li><span class="koboSpan" id="kobo.758.1">Try to run the application and register a new user or log in with an existing user. </span><span class="koboSpan" id="kobo.758.2">Copy the </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.759.1">token in the response and paste it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">jwt.io</span></strong><span class="koboSpan" id="kobo.761.1"> website to decode the payload. </span><span class="koboSpan" id="kobo.761.2">You will see that the roles are included in the token, as </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.763.1">
{  "unique_name": "admin",  "role": "Administrator",  "nbf": 1679815694,  "exp": 1679902094,  "iat": 1679815694,  "iss": "http://localhost:5056",  "aud": "http://localhost:5056"}</span></pre></li> <li><span class="koboSpan" id="kobo.764.1">Now, let’s</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.765.1"> update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.767.1"> class to implement role-based authorization. </span><span class="koboSpan" id="kobo.767.2">Add a new action for administrators, </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.769.1">
[HttpGet("admin", Name = "GetAdminWeatherForecast")][Authorize(Roles = AppRoles.Administrator)]public IEnumerable&lt;WeatherForecast&gt; GetAdmin(){    return Enumerable.Range(1, 20).Select(index =&gt; new WeatherForecast    {        Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),        TemperatureC = Random.Shared.Next(-20, 55),        Summary = Summaries[Random.Shared.Next(Summaries.Length)]    })    .ToArray();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.770.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">Authorize</span></strong><span class="koboSpan" id="kobo.772.1"> attribute is used to specify the role that is allowed to access the API. </span><span class="koboSpan" id="kobo.772.2">In the preceding code, only authenticated users with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">Administrator</span></strong><span class="koboSpan" id="kobo.774.1"> role can access </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">the API.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.776.1">Now, you can test the API. </span><span class="koboSpan" id="kobo.776.2">If you use the token of a normal user to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">/WeatherForecast/admin</span></strong><span class="koboSpan" id="kobo.778.1"> endpoint, you will get a 403 </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">Forbidden response.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.780.1">Generally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">administrator</span></strong><span class="koboSpan" id="kobo.782.1"> role should have permission to access all resources. </span><span class="koboSpan" id="kobo.782.2">But in our </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.783.1">current application, the administrator user cannot access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">/WeatherForecast</span></strong><span class="koboSpan" id="kobo.785.1"> endpoint. </span><span class="koboSpan" id="kobo.785.2">There are multiple ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">fix this.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">The first way</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.788.1"> is that when we register a new administrator, we can assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">Administrator</span></strong><span class="koboSpan" id="kobo.790.1"> role to the user and also assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">User</span></strong><span class="koboSpan" id="kobo.792.1"> role (or any other roles) to the user. </span><span class="koboSpan" id="kobo.792.2">This way, the administrator user can access </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">all resources.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">We can also update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">Authorize</span></strong><span class="koboSpan" id="kobo.796.1"> attribute to allow multiple roles, </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
[HttpGet(Name = "GetWeatherForecast")][Authorize(Roles = $"{AppRoles.User},{AppRoles.VipUser},{AppRoles.Administrator}")]
public IEnumerable&lt;WeatherForecast&gt; Get()
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.799.1">The preceding code means that the user must have at least one of the specified roles to access </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">Note that if you</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.802.1"> apply multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">Authorize</span></strong><span class="koboSpan" id="kobo.804.1"> attributes with specified roles to an action, the user must have all the roles to access the API. </span><span class="koboSpan" id="kobo.804.2">For example, consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
[HttpGet("vip", Name = "GetVipWeatherForecast")][Authorize(Roles = AppRoles.User)]
[Authorize(Roles = AppRoles.VipUser)]
public IEnumerable&lt;WeatherForecast&gt; GetVip()
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.807.1">The </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.808.1">preceding code states that the user must have both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">User</span></strong><span class="koboSpan" id="kobo.810.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">VipUser</span></strong><span class="koboSpan" id="kobo.812.1"> roles to access the API. </span><span class="koboSpan" id="kobo.812.2">If the user has only one of the roles, the user will get a 403 </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">Forbidden response.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">Besides this, we can also define a policy to specify the roles that are allowed to access the API. </span><span class="koboSpan" id="kobo.814.2">For example, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Program</span></strong><span class="koboSpan" id="kobo.816.1"> class, we can add the </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.818.1">
builder.Services.AddAuthorization(options =&gt;{
    options.AddPolicy("RequireAdministratorRole", policy =&gt; policy.RequireRole(AppRoles.Administrator));
    options.AddPolicy("RequireVipUserRole", policy =&gt; policy.RequireRole(AppRoles.VipUser));
    options.AddPolicy("RequireUserRole", policy =&gt; policy.RequireRole(AppRoles.User));
    options.AddPolicy("RequireUserRoleOrVipUserRole", policy =&gt; policy.RequireRole(AppRoles.User, AppRoles.VipUser));
});</span></pre>
<p><span class="koboSpan" id="kobo.819.1">Then, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Authorize</span></strong><span class="koboSpan" id="kobo.821.1"> attribute to use the policy </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
[HttpGet("admin-with-policy", Name = "GetAdminWeatherForecastWithPolicy")][Authorize(Policy = "RequireAdministratorRole")]
public IEnumerable&lt;WeatherForecast&gt; GetAdminWithPolicy()
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.824.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">policy.RequireRole()</span></strong><span class="koboSpan" id="kobo.826.1"> method has multiple roles in parameters, the user must</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.827.1"> have at least one of the roles to access the API. </span><span class="koboSpan" id="kobo.827.2">You</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.828.1"> can check the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">completed app.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">With that, we’ve implemented role-based authorization in ASP.NET Core. </span><span class="koboSpan" id="kobo.830.2">In</span><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.831.1"> the next section, we will learn how to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">claim-based authorization.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.833.1">Claim-based authorization</span></h2>
<p><span class="koboSpan" id="kobo.834.1">When</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.835.1"> a user is authenticated, the user will </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.836.1">have a set of claims that are used to store the information about the user. </span><span class="koboSpan" id="kobo.836.2">For example, the user can have a claim that specifies the user’s role. </span><span class="koboSpan" id="kobo.836.3">So, technically, roles are also claims, but they are special claims that are used to store the roles of the user. </span><span class="koboSpan" id="kobo.836.4">We can store other information in the claims, such as the user’s name, email address, date of birth, driving license number, and more. </span><span class="koboSpan" id="kobo.836.5">Once we’ve done this, the authorization system can check the claims to determine whether the user is allowed to access the resource. </span><span class="koboSpan" id="kobo.836.6">Claim-based authorization provides more granular access control than role-based authorization, but it can be more complex to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">and manage.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">You can find the starter app and the completed app in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">chapter8/AuthorizationDemo/ClaimBasedAuthorizationDemo</span></strong><span class="koboSpan" id="kobo.840.1"> folder in this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">GitHub repository:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.842.1">We’ll start with the starter app. </span><span class="koboSpan" id="kobo.842.2">Don’t forget to create the database and run the migrations using the </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.844.1">dotnet ef database update</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.845.1">A claim is a key-value pair. </span><span class="koboSpan" id="kobo.845.2">Note that the claim type and value are case-sensitive. </span><span class="koboSpan" id="kobo.845.3">You can store the claims in the database or the code. </span><span class="koboSpan" id="kobo.845.4">When the user logs in, the claims can be retrieved from the database and added to the token. </span><span class="koboSpan" id="kobo.845.5">In this demo, we will hard-code the claims in the code </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">for simplicity.</span></span></p></li> <li><span class="koboSpan" id="kobo.847.1">ASP.NET Core </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.848.1">provides a built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">ClaimTypes</span></strong><span class="koboSpan" id="kobo.850.1"> class that contains the common claim types, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">NameIdentifier</span></strong><span class="koboSpan" id="kobo.852.1">,  </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">DateOfBirth</span></strong><span class="koboSpan" id="kobo.854.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">Email</span></strong><span class="koboSpan" id="kobo.856.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">Gender</span></strong><span class="koboSpan" id="kobo.858.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">GivenName</span></strong><span class="koboSpan" id="kobo.860.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">Name</span></strong><span class="koboSpan" id="kobo.862.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">PostalCode</span></strong><span class="koboSpan" id="kobo.864.1">, and others, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">Role</span></strong><span class="koboSpan" id="kobo.866.1">. </span><span class="koboSpan" id="kobo.866.2">This is why we said that roles are also claims. </span><span class="koboSpan" id="kobo.866.3">You</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.867.1"> can also define your own claim types. </span><span class="koboSpan" id="kobo.867.2">For example, we can define the following claim types in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">AppClaimTypes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.869.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.870.1">
public static class AppClaimTypes{    public const string DrivingLicenseNumber = "DrivingLicenseNumber";    public const string AccessNumber = "AccessNumber";}</span></pre></li> <li><span class="koboSpan" id="kobo.871.1">Also, create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">AppAuthorizationPolicies</span></strong><span class="koboSpan" id="kobo.873.1"> class to define the </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">authorization policies:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.875.1">
public static class AppAuthorizationPolicies{    public const string RequireDrivingLicenseNumber = "RequireDrivingLicenseNumber";    public const string RequireAccessNumber = "RequireAccessNumber";}</span></pre></li> <li><span class="koboSpan" id="kobo.876.1">Then, we can add the claims to the token when the user logs in. </span><span class="koboSpan" id="kobo.876.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">GenerateToken</span></strong><span class="koboSpan" id="kobo.878.1"> method</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.879.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">AccountController</span></strong><span class="koboSpan" id="kobo.881.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">as </span></span><span class="No-Break"><a id="_idIndexMarker785"/></span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
// Omitted for brevityvar tokenDescriptor = new SecurityTokenDescriptor{    Subject = new ClaimsIdentity(new[]    {        new Claim(ClaimTypes.Name, userName),        // Suppose the user's information is stored in the database so that we can retrieve it from the database        new Claim(ClaimTypes.Country, "New Zealand"),        // Add our custom claims        new Claim(AppClaimTypes.AccessNumber, "12345678"),        new Claim(AppClaimTypes.DrivingLicenseNumber, "123456789")    }),    Expires = DateTime.UtcNow.AddDays(1),    Issuer = issuer,    Audience = audience,    SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)};// Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.885.1">We can</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.886.1"> add any claims to the token. </span><span class="koboSpan" id="kobo.886.2">In the preceding code, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Country</span></strong><span class="koboSpan" id="kobo.888.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">AccessNumber</span></strong><span class="koboSpan" id="kobo.890.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">DrivingLicenseNumber</span></strong><span class="koboSpan" id="kobo.892.1"> claims to </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">the token.</span></span></p></li> <li><span class="koboSpan" id="kobo.894.1">Imagine that</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.895.1"> we have a requirement that only users who have their driving licenses can access the resource. </span><span class="koboSpan" id="kobo.895.2">We can implement this by adding the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.897.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.898.1">
builder.Services.AddAuthorization(options =&gt;{    options.AddPolicy(AppAuthorizationPolicies.RequireDrivingLicense, policy =&gt; policy.RequireClaim(AppClaimTypes.DrivingLicenseNumber));    options.AddPolicy(AppAuthorizationPolicies.RequireAccessNumber, policy =&gt; policy.RequireClaim(AppClaimTypes.AccessNumber));});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.899.1">So, the</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.900.1"> difference between role-based authorization and claim-based authorization is that claim-based authorization uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">policy.RequireClaim()</span></strong><span class="koboSpan" id="kobo.902.1"> to check the claims, while role-based authorization uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">policy.RequireRole()</span></strong><span class="koboSpan" id="kobo.904.1"> to check </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">the roles.</span></span></p></li> <li><span class="koboSpan" id="kobo.906.1">At this point, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">Authorize</span></strong><span class="koboSpan" id="kobo.908.1"> attribute so that it uses the policy, </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.910.1">
[Authorize(Policy = AppAuthorizationPolicies.RequireDrivingLicense)][HttpGet("driving-license")]public IActionResult GetDrivingLicense(){    var drivingLicenseNumber = User.Claims.FirstOrDefault(c =&gt; c.Type == AppClaimTypes.DrivingLicenseNumber)?.Value;    return Ok(new { drivingLicenseNumber });}</span></pre></li> <li><span class="koboSpan" id="kobo.911.1">Run the</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.912.1"> application and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">/WeatherForecast/driving-license</span></strong><span class="koboSpan" id="kobo.914.1"> endpoint. </span><span class="koboSpan" id="kobo.914.2">You will get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">401</span></strong><span class="koboSpan" id="kobo.916.1"> Unauthorized response because the user does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">DrivingLicenseNumber</span></strong><span class="koboSpan" id="kobo.918.1"> claim. </span><span class="koboSpan" id="kobo.918.2">Register a user or log in to get the token. </span><span class="koboSpan" id="kobo.918.3">Then, add the token to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">Authorization</span></strong><span class="koboSpan" id="kobo.920.1"> header and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">/WeatherForecast/driving-license</span></strong><span class="koboSpan" id="kobo.922.1"> endpoint again. </span><span class="koboSpan" id="kobo.922.2">You will get a 200 OK response with </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">drivingLicenseNumber</span></strong><span class="koboSpan" id="kobo.924.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">response body.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.926.1">The token </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.927.1">now contains the claims, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">JSON response:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.929.1">
{  "unique_name": "user",  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/country": "New Zealand",  "AccessNumber": "12345678",  "DrivingLicenseNumber": "123456789",  "nbf": 1679824749,  "exp": 1679911149,  "iat": 1679824749,  "iss": "http://localhost:5056",  "aud": "http://localhost:5056"}</span></pre></li> <li><span class="koboSpan" id="kobo.930.1">This is the simplest way to implement claim-based authorization. </span><span class="koboSpan" id="kobo.930.2">The current approach only checks whether the token contains the claim; it does not check the value of the claim. </span><span class="koboSpan" id="kobo.930.3">We can check the values as well. </span><span class="koboSpan" id="kobo.930.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">RequireClaim()</span></strong><span class="koboSpan" id="kobo.932.1"> method also has an overload that accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">allowedValues</span></strong><span class="koboSpan" id="kobo.934.1"> as a parameter. </span><span class="koboSpan" id="kobo.934.2">For example, we have a resource that can only be accessed by</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.935.1"> users based in New Zealand. </span><span class="koboSpan" id="kobo.935.2">We can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">Program</span></strong><span class="koboSpan" id="kobo.937.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.939.1">
builder.Services.AddAuthorization(options =&gt;{    // Omitted for brevity    options.AddPolicy(AppAuthorizationPolicies.RequireCountry, policy =&gt; policy.RequireClaim(ClaimTypes.Country, "New Zealand"));});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.940.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">allowedValues</span></strong><span class="koboSpan" id="kobo.942.1"> parameter is an array of strings. </span><span class="koboSpan" id="kobo.942.2">So, we can pass multiple </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.943.1">values to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">allowedValues</span></strong><span class="koboSpan" id="kobo.945.1"> parameter. </span><span class="koboSpan" id="kobo.945.2">For example, we can allow users from New Zealand and Australia to access </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">the resource:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.947.1">options.AddPolicy(AppAuthorizationPolicies.RequireCountry, policy =&gt; policy.RequireClaim(ClaimTypes.Country, "New Zealand", "Australia"));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.948.1">The action in the controller looks </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">like this:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.950.1">[Authorize(Policy = AppAuthorizationPolicies.RequireCountry)][HttpGet("country")]public IActionResult GetCountry(){    var country = User.Claims.FirstOrDefault(c =&gt; c.Type == ClaimTypes.Country)?.Value;    return Ok(new { country });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.951.1">You can test the API by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">/WeatherForecast/country</span></strong><span class="koboSpan" id="kobo.953.1"> endpoint. </span><span class="koboSpan" id="kobo.953.2">Now, only users who have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">Country</span></strong><span class="koboSpan" id="kobo.955.1"> claim with the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">New Zealand</span></strong><span class="koboSpan" id="kobo.957.1"> can access </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">the resource.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.959.1">Similar to roles, we</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.960.1"> can apply multiple policies to a resource. </span><span class="koboSpan" id="kobo.960.2">For example, we can require the user to have both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">DrivingLicense</span></strong><span class="koboSpan" id="kobo.962.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">AccessNumber</span></strong><span class="koboSpan" id="kobo.964.1"> claims to access the resource. </span><span class="koboSpan" id="kobo.964.2">Just like roles, you can add </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.965.1">two policies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">Authorize</span></strong><span class="koboSpan" id="kobo.967.1"> attribute, which means that the user must have both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">DrivingLicense</span></strong><span class="koboSpan" id="kobo.969.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">AccessNumber</span></strong><span class="koboSpan" id="kobo.971.1"> claims to access the resource. </span><span class="koboSpan" id="kobo.971.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
[Authorize(Policy = AppAuthorizationPolicies.RequireDrivingLicense)][Authorize(Policy = AppAuthorizationPolicies.RequireAccessNumber)]
[HttpGet("driving-license-and-access-number")]
public IActionResult GetDrivingLicenseAndAccessNumber()
{
    var drivingLicenseNumber = User.Claims.FirstOrDefault(c =&gt; c.Type == AppClaimTypes.DrivingLicenseNumber)?.Value;
    var accessNumber = User.Claims.FirstOrDefault(c =&gt; c.Type == AppClaimTypes.AccessNumber)?.Value;
    return Ok(new { drivingLicenseNumber, accessNumber });
}</span></pre>
<p><span class="koboSpan" id="kobo.974.1">Another way is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">RequireAssertion()</span></strong><span class="koboSpan" id="kobo.976.1"> method, which allows us to execute a custom logic to check the claims. </span><span class="koboSpan" id="kobo.976.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">Program</span></strong><span class="koboSpan" id="kobo.978.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.980.1">
builder.Services.AddAuthorization(options =&gt;{
    // Omitted for brevity
    options.AddPolicy(AppAuthorizationPolicies.RequireDrivingLicenseAndAccessNumber, policy =&gt; policy.RequireAssertion(context =&gt;
    {
        var hasDrivingLicenseNumber = context.User.HasClaim(c =&gt; c.Type == AppClaimTypes.DrivingLicenseNumber);
        var hasAccessNumber = context.User.HasClaim(c =&gt; c.Type == AppClaimTypes.AccessNumber);
        return hasDrivingLicenseNumber &amp;&amp; hasAccessNumber;
    }));
});</span></pre>
<p><span class="koboSpan" id="kobo.981.1">In the </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.982.1">preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">context</span></strong><span class="koboSpan" id="kobo.984.1"> parameter contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">User</span></strong><span class="koboSpan" id="kobo.986.1"> property that contains the claims. </span><span class="koboSpan" id="kobo.986.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">HasClaim()</span></strong><span class="koboSpan" id="kobo.988.1"> method to check whether the user has the claim. </span><span class="koboSpan" id="kobo.988.2">Then, we can return </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">true</span></strong><span class="koboSpan" id="kobo.990.1"> if the </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.991.1">user has both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">DrivingLicenseNumber</span></strong><span class="koboSpan" id="kobo.993.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">AccessNumber</span></strong><span class="koboSpan" id="kobo.995.1"> claims; otherwise, we return </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">false</span></strong><span class="koboSpan" id="kobo.997.1">. </span><span class="koboSpan" id="kobo.997.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">context.User.Claims</span></strong><span class="koboSpan" id="kobo.999.1"> property to get the claims and check the values per </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">your requirement.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">The action in the controller looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1003.1">
[Authorize(Policy = AppAuthorizationPolicies.RequireDrivingLicenseAndAccessNumber)][HttpGet("driving-license-and-access-number")]
public IActionResult GetDrivingLicenseAndAccessNumber()
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1004.1">In this section, we learned how to implement claim-based authorization in ASP.NET Core. </span><span class="koboSpan" id="kobo.1004.2">We also learned how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">RequireAssertion()</span></strong><span class="koboSpan" id="kobo.1006.1"> method to check the claims. </span><span class="koboSpan" id="kobo.1006.2">If we need a more complex authorization logic, we can us</span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.1007.1">e policy-based authorization. </span><span class="koboSpan" id="kobo.1007.2">But first, let’s learn how authorization works in </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">ASP.NET Core.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.1009.1">Understanding the authorization process</span></h2>
<p><span class="koboSpan" id="kobo.1010.1">In the </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.1011.1">previous section, we learned how to implement role-based authorization and claim-based authorization. </span><span class="koboSpan" id="kobo.1011.2">Let’s delve deeper into the details. </span><span class="koboSpan" id="kobo.1011.3">You may have noticed that when we use role-based authorization or claim-based authorization, we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">AddPolicy()</span></strong><span class="koboSpan" id="kobo.1013.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">AddAuthorization</span></strong><span class="koboSpan" id="kobo.1015.1"> method. </span><span class="koboSpan" id="kobo.1015.2">The signature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">AddPolicy()</span></strong><span class="koboSpan" id="kobo.1017.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
public void AddPolicy(string name, Action&lt;AuthorizationPolicyBuilder&gt; configurePolicy){
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1020.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">AddPolicy()</span></strong><span class="koboSpan" id="kobo.1022.1"> method accepts </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">two parameters:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1024.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">name</span></strong><span class="koboSpan" id="kobo.1026.1"> parameter, which is the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">the policy</span></span></li>
<li><span class="koboSpan" id="kobo.1028.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">configurePolicy</span></strong><span class="koboSpan" id="kobo.1030.1"> parameter, which is a delegate that accepts an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">AuthorizationPolicyBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1"> parameter</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1033.1">You can press </span><em class="italic"><span class="koboSpan" id="kobo.1034.1">F12</span></em><span class="koboSpan" id="kobo.1035.1"> to check the source code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">AuthorizationPolicyBuilder</span></strong><span class="koboSpan" id="kobo.1037.1"> class. </span><span class="koboSpan" id="kobo.1037.2">You will find that it has some methods to configure the policy, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">RequireRole()</span></strong><span class="koboSpan" id="kobo.1039.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">RequireClaim()</span></strong><span class="koboSpan" id="kobo.1041.1">, and others. </span><span class="koboSpan" id="kobo.1041.2">The source code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">RequireRole</span></strong><span class="koboSpan" id="kobo.1043.1"> method looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
public AuthorizationPolicyBuilder RequireRole(IEnumerable&lt;string&gt; roles){
    ArgumentNullThrowHelper.ThrowIfNull(roles);
    Requirements.Add(new RolesAuthorizationRequirement(roles));
    return this;
}</span></pre>
<p><span class="koboSpan" id="kobo.1046.1">The source code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">RequireClaim()</span></strong><span class="koboSpan" id="kobo.1048.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
public AuthorizationPolicyBuilder RequireClaim(string claimType){
    ArgumentNullThrowHelper.ThrowIfNull(claimType);
    Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues: null));
    return this;
}</span></pre>
<p><span class="koboSpan" id="kobo.1051.1">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">RequireRole()</span></strong><span class="koboSpan" id="kobo.1053.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">RequireClaim()</span></strong><span class="koboSpan" id="kobo.1055.1"> methods call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">Requirements.Add()</span></strong><span class="koboSpan" id="kobo.1057.1"> method under the hood. </span><span class="koboSpan" id="kobo.1057.2">So, what is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">Requirements</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1"> object?</span></span></p>
<p><span class="koboSpan" id="kobo.1060.1">We are getting</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.1061.1"> closer to the core of authorization in ASP.NET Core. </span><span class="koboSpan" id="kobo.1061.2">The definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">Requirements</span></strong><span class="koboSpan" id="kobo.1063.1"> object is </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
public IList&lt;IAuthorizationRequirement&gt; Requirements { get; set; } = new List&lt;IAuthorizationRequirement&gt;();</span></pre> <p><span class="koboSpan" id="kobo.1066.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">Requirements</span></strong><span class="koboSpan" id="kobo.1068.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">AuthorizationPolicyBuilder</span></strong><span class="koboSpan" id="kobo.1070.1"> class is a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1072.1"> objects. </span><span class="koboSpan" id="kobo.1072.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1074.1"> interface is just a marker service, and it does not have any methods. </span><span class="koboSpan" id="kobo.1074.2">Let’s press </span><em class="italic"><span class="koboSpan" id="kobo.1075.1">F12</span></em><span class="koboSpan" id="kobo.1076.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">RolesAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1078.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">ClaimsAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1080.1"> class. </span><span class="koboSpan" id="kobo.1080.2">We will see their </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">source code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1082.1">
// RolesAuthorizationRequirementpublic class RolesAuthorizationRequirement : AuthorizationHandler&lt;RolesAuthorizationRequirement&gt;, IAuthorizationRequirement
{
    // Omitted for brevity
}
// ClaimsAuthorizationRequirement
public class ClaimsAuthorizationRequirement : AuthorizationHandler&lt;ClaimsAuthorizationRequirement&gt;, IAuthorizationRequirement
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1083.1">As we can </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.1084.1">see, both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">RolesAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1086.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">ClaimsAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1088.1"> classes implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1090.1"> interface. </span><span class="koboSpan" id="kobo.1090.2">They also implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">AuthorizationHandler&lt;TRequirement&gt;</span></strong><span class="koboSpan" id="kobo.1092.1"> class, which is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1094.1">
public abstract class AuthorizationHandler&lt;TRequirement&gt; : IAuthorizationHandler        where TRequirement : IAuthorizationRequirement
{
    /// &lt;summary&gt;
    /// Makes a decision if authorization is allowed.
</span><span class="koboSpan" id="kobo.1094.2">    /// &lt;/summary&gt;
    /// &lt;param name="context"&gt;The authorization context.&lt;/param&gt;
    public virtual async Task HandleAsync(AuthorizationHandlerContext context)
    {
        foreach (var req in context.Requirements.OfType&lt;TRequirement&gt;())
        {
            await HandleRequirementAsync(context, req).ConfigureAwait(false);
        }
    }
    /// &lt;summary&gt;
    /// Makes a decision if authorization is allowed based on a specific requirement.
</span><span class="koboSpan" id="kobo.1094.3">    /// &lt;/summary&gt;
    /// &lt;param name="context"&gt;The authorization context.&lt;/param&gt;
    /// &lt;param name="requirement"&gt;The requirement to evaluate.&lt;/param&gt;
    protected abstract Task HandleRequirementAsync(AuthorizationHandlerContext context, TRequirement requirement);
}</span></pre>
<p><span class="koboSpan" id="kobo.1095.1">So, each </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.1096.1">implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">AuthorizationHandler&lt;TRequirement&gt;</span></strong><span class="koboSpan" id="kobo.1098.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">HandleRequirementAsync()</span></strong><span class="koboSpan" id="kobo.1100.1"> method to check the requirements. </span><span class="koboSpan" id="kobo.1100.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">RolesAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1102.1"> class consists of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1104.1">
public RolesAuthorizationRequirement(IEnumerable&lt;string&gt; allowedRoles){
    ArgumentNullThrowHelper.ThrowIfNull(allowedRoles);
    if (!allowedRoles.Any())
    {
        throw new InvalidOperationException(Resources.Exception_RoleRequirementEmpty);
    }
    AllowedRoles = allowedRoles;
}
/// &lt;summary&gt;
/// Gets the collection of allowed roles.
</span><span class="koboSpan" id="kobo.1104.2">/// &lt;/summary&gt;
public IEnumerable&lt;string&gt; AllowedRoles { get; }
/// &lt;summary&gt;
/// Makes a decision if authorization is allowed based on a specific requirement.
</span><span class="koboSpan" id="kobo.1104.3">/// &lt;/summary&gt;
/// &lt;param name="context"&gt;The authorization context.&lt;/param&gt;
/// &lt;param name="requirement"&gt;The requirement to evaluate.&lt;/param&gt;
protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, RolesAuthorizationRequirement requirement)
{
    if (context.User != null)
    {
        var found = false;
        foreach (var role in requirement.AllowedRoles)
        {
            if (context.User.IsInRole(role))
            {
                found = true;
                break;
            }
        }
        if (found)
        {
            context.Succeed(requirement);
        }
    }
    return Task.CompletedTask;
}</span></pre>
<p><span class="koboSpan" id="kobo.1105.1">When a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">RolesAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1107.1"> instance is instantiated, it accepts a collection </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.1108.1">of roles from the constructor. </span><span class="koboSpan" id="kobo.1108.2">Then, it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">HandleRequirementAsync()</span></strong><span class="koboSpan" id="kobo.1110.1"> method to check whether the user is in the role. </span><span class="koboSpan" id="kobo.1110.2">If the user is in the role, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">context.Succeed()</span></strong><span class="koboSpan" id="kobo.1112.1"> method to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">Succeeded</span></strong><span class="koboSpan" id="kobo.1114.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">true</span></strong><span class="koboSpan" id="kobo.1116.1">. </span><span class="koboSpan" id="kobo.1116.2">Otherwise, it sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">Succeeded</span></strong><span class="koboSpan" id="kobo.1118.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1122.1">If you check the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">ClaimsAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1124.1"> class, you will find it is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">RolesAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1126.1"> class. </span><span class="koboSpan" id="kobo.1126.2">It accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">claimType</span></strong><span class="koboSpan" id="kobo.1128.1"> and a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">allowValues</span></strong><span class="koboSpan" id="kobo.1130.1"> and checks whether the user has the claim, and whether the claim value is in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">allowValues</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1"> set.</span></span></p>
<p><span class="koboSpan" id="kobo.1133.1">The next question is – who is responsible for calling </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">these methods?</span></span></p>
<p><span class="koboSpan" id="kobo.1135.1">Let’s go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">Program</span></strong><span class="koboSpan" id="kobo.1137.1"> class to understand the middleware pipeline. </span><span class="koboSpan" id="kobo.1137.2">We have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">app.UseAuthorization()</span></strong><span class="koboSpan" id="kobo.1139.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">Program</span></strong><span class="koboSpan" id="kobo.1141.1"> file, which is used to add the authorization middleware. </span><span class="koboSpan" id="kobo.1141.2">Press </span><em class="italic"><span class="koboSpan" id="kobo.1142.1">F12</span></em><span class="koboSpan" id="kobo.1143.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">UseAuthorization</span></strong><span class="koboSpan" id="kobo.1145.1"> method. </span><span class="koboSpan" id="kobo.1145.2">We’ll be able to view its </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">source code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1147.1">
public static IApplicationBuilder UseAuthorization(this IApplicationBuilder app){
    // Omitted for brevity
    return app.UseMiddleware&lt;AuthorizationMiddleware&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.1148.1">Continue</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.1149.1"> to press </span><em class="italic"><span class="koboSpan" id="kobo.1150.1">F12</span></em><span class="koboSpan" id="kobo.1151.1"> to check the source code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">AuthorizationMiddleware</span></strong><span class="koboSpan" id="kobo.1153.1">. </span><span class="koboSpan" id="kobo.1153.2">You will see the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">Invoke()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1156.1">
// Omitted for brevityvar authorizeData = endpoint?.Metadata.GetOrderedMetadata&lt;IAuthorizeData&gt;() ?? </span><span class="koboSpan" id="kobo.1156.2">Array.Empty&lt;IAuthorizeData&gt;();
var policies = endpoint?.Metadata.GetOrderedMetadata&lt;AuthorizationPolicy&gt;() ?? </span><span class="koboSpan" id="kobo.1156.3">Array.Empty&lt;AuthorizationPolicy&gt;();
// Omitted for brevity
var policyEvaluator = context.RequestServices.GetRequiredService&lt;IPolicyEvaluator&gt;();
var authenticateResult = await policyEvaluator.AuthenticateAsync(policy, context);
// Omitted for brevity
var authorizeResult = await policyEvaluator.AuthorizeAsync(policy, authenticateResult!, context, resource);
// Omitted for brevity</span></pre>
<p><span class="koboSpan" id="kobo.1157.1">Now, we are closer. </span><span class="koboSpan" id="kobo.1157.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">AuthorizationMiddleware</span></strong><span class="koboSpan" id="kobo.1159.1"> class gets the policies from the endpoint metadata and then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">IPolicyEvaluator.AuthenticateAsync()</span></strong><span class="koboSpan" id="kobo.1161.1"> method to check whether the user is authenticated, after which it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">IPolicyEvaluator.AuthorizeAsync()</span></strong><span class="koboSpan" id="kobo.1163.1"> method to check whether the user is authorized. </span><span class="koboSpan" id="kobo.1163.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">IPolicyEvaluator</span></strong><span class="koboSpan" id="kobo.1165.1"> interface is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1167.1">
public interface IPolicyEvaluator{
    Task&lt;AuthenticateResult&gt; AuthenticateAsync(AuthorizationPolicy policy, HttpContext context);
    Task&lt;PolicyAuthorizationResult&gt; AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context, object? </span><span class="koboSpan" id="kobo.1167.2">resource);
}</span></pre>
<p><span class="koboSpan" id="kobo.1168.1">The default</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.1169.1"> implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">IPolicyEvaluator</span></strong><span class="koboSpan" id="kobo.1171.1"> has been injected into the DI container by the ASP.NET Core framework. </span><span class="koboSpan" id="kobo.1171.2">You can find the source code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">PolicyEvaluator</span></strong><span class="koboSpan" id="kobo.1173.1"> class here: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">https://source.dot.net/#Microsoft.AspNetCore.Authorization.Policy/PolicyEvaluator.cs</span></strong><span class="koboSpan" id="kobo.1175.1">. </span><span class="koboSpan" id="kobo.1175.2">You will see it has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">IAuthorizationService</span></strong><span class="koboSpan" id="kobo.1177.1"> object injected into it, which is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1179.1">
public interface IAuthorizationService{
    Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object? </span><span class="koboSpan" id="kobo.1179.2">resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements);
    Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object? </span><span class="koboSpan" id="kobo.1179.3">resource, string policyName);
}</span></pre>
<p><span class="koboSpan" id="kobo.1180.1">With that, we’ve found the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1182.1"> class we </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">described earlier!</span></span></p>
<p><span class="koboSpan" id="kobo.1184.1">You can find the source code of the default implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">IAuthorizationService</span></strong><span class="koboSpan" id="kobo.1186.1"> here: </span><a href="https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs"><span class="koboSpan" id="kobo.1187.1">https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs</span></a><span class="koboSpan" id="kobo.1188.1">. </span><span class="koboSpan" id="kobo.1188.2">It is</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.1189.1"> also injected into the DI container by the framework. </span><span class="koboSpan" id="kobo.1189.2">The core code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1191.1">
public virtual async Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object? </span><span class="koboSpan" id="kobo.1191.2">resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements){
    ArgumentNullThrowHelper.ThrowIfNull(requirements);
    var authContext = _contextFactory.CreateContext(requirements, user, resource);
    var handlers = await _handlers.GetHandlersAsync(authContext).ConfigureAwait(false);
    foreach (var handler in handlers)
    {
        await handler.HandleAsync(authContext).ConfigureAwait(false);
        if (!_options.InvokeHandlersAfterFailure &amp;&amp; authContext.HasFailed)
        {
            break;
        }
    }
    var result = _evaluator.Evaluate(authContext);
    if (result.Succeeded)
    {
        _logger.UserAuthorizationSucceeded();
    }
    else
    {
        _logger.UserAuthorizationFailed(result.Failure);
    }
    return result;
}</span></pre>
<p><span class="koboSpan" id="kobo.1192.1">So, we end up </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.1193.1">with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">call stack:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1195.1">Define the authorization policy (requirement) in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1"> class.</span></span></li>
<li><span class="koboSpan" id="kobo.1198.1">Apply the authorization policy to </span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1">the endpoint.</span></span></li>
<li><span class="koboSpan" id="kobo.1200.1">Apply the authorization middleware to </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">the pipeline.</span></span></li>
<li><span class="koboSpan" id="kobo.1202.1">The request comes in with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">Authorization</span></strong><span class="koboSpan" id="kobo.1204.1"> header, which can be retrieved from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">HttpContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1"> object.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">AuthorizationMiddleware</span></strong><span class="koboSpan" id="kobo.1208.1"> calls the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">IPolicyEvaluator.AuthorizeAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1"> method.</span></span></li>
<li><span class="koboSpan" id="kobo.1211.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">IPolicyEvaluator.AuthorizeAsync()</span></strong><span class="koboSpan" id="kobo.1213.1"> method calls the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">IAuthorizationService.AuthorizeAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1"> method.</span></span></li>
<li><span class="koboSpan" id="kobo.1216.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">IAuthorizationService.AuthorizeAsync()</span></strong><span class="koboSpan" id="kobo.1218.1"> method calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">IAuthorizationHandler.HandleAsync()</span></strong><span class="koboSpan" id="kobo.1220.1"> method to check whether the user </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">is authorized.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1222.1">Once we understand the call stack, we can easily implement an authorization policy by im</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.1223.1">plementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1225.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">IAuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1227.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">IAuthorizationService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1"> interfaces.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.1230.1">Policy-based authorization</span></h2>
<p><span class="koboSpan" id="kobo.1231.1">In the</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.1232.1"> previous section, we explained that both role-based authorization and claim-based authorization are implemented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1234.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">IAuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1236.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">IAuthorizationService</span></strong><span class="koboSpan" id="kobo.1238.1"> interfaces under the hood. </span><span class="koboSpan" id="kobo.1238.2">If we have more complex authorization logic, we can use policy-based authorization directly, which allows us to define custom </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.1239.1">authorization policies to execute complex </span><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">authorization logic.</span></span></p>
<p><span class="koboSpan" id="kobo.1241.1">For example, we have a scenario where we need to support the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">authorization logic:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1243.1">The special premium content can be accessed by the user who has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">Premium</span></strong><span class="koboSpan" id="kobo.1245.1"> subscription and is also based in </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">New Zealand</span></span></li>
<li><span class="koboSpan" id="kobo.1247.1">Users who have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">Premium</span></strong><span class="koboSpan" id="kobo.1249.1"> subscription, but are not based in New Zealand, cannot access the special </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">premium content</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1251.1">There may be other complex authorization logic in the real world. </span><span class="koboSpan" id="kobo.1251.2">Let’s implement the aforementioned authorization logic using policy-based authorization. </span><span class="koboSpan" id="kobo.1251.3">You can find the sample code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">samples/chapter8/AuthorizationDemo/PolicyBasedAuthorization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1"> folder:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1255.1">First, add two classes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">Authentication</span></strong><span class="koboSpan" id="kobo.1257.1"> folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1259.1">
public static class AppClaimTypes{    public const string Subscription = "Subscription";}public static class AppAuthorizationPolicies{    public const string SpecialPremiumContent = "SpecialPremiumContent";}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1260.1">These</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.1261.1"> classes define the claim types and authorization policies we need. </span><span class="koboSpan" id="kobo.1261.2">You can also</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.1262.1"> use strings directly in the code, but it is recommended to use constants to </span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1">avoid typos.</span></span></p></li> <li><span class="koboSpan" id="kobo.1264.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">AccountController</span></strong><span class="koboSpan" id="kobo.1266.1"> class, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">GenerateToken()</span></strong><span class="koboSpan" id="kobo.1268.1"> method with a new claim, </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1270.1">
private string? </span><span class="koboSpan" id="kobo.1270.2">GenerateToken(string userName, string country){    // Omitted for brevity    var tokenDescriptor = new SecurityTokenDescriptor    {        Subject = new ClaimsIdentity(new[]        {            new Claim(ClaimTypes.Name, userName),            new Claim(AppClaimTypes.Subscription, "Premium"),            new Claim(ClaimTypes.Country, country)        }),        Expires = DateTime.UtcNow.AddDays(1),        Issuer = issuer,        Audience = audience,        SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)    };    // Omitted for brevity}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1271.1">We </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.1272.1">added a new claim, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">AppClaimTypes.Subscription</span></strong><span class="koboSpan" id="kobo.1274.1">, with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">Premium</span></strong><span class="koboSpan" id="kobo.1276.1"> to the token. </span><span class="koboSpan" id="kobo.1276.2">This claim </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.1277.1">represents the user’s subscription type. </span><span class="koboSpan" id="kobo.1277.2">We also added a new claim, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">ClaimTypes.Country</span></strong><span class="koboSpan" id="kobo.1279.1">, to the token. </span><span class="koboSpan" id="kobo.1279.2">This claim represents the user’s country. </span><span class="koboSpan" id="kobo.1279.3">In the real world, you can get the user’s subscription type and country from the database. </span><span class="koboSpan" id="kobo.1279.4">Let’s assume we have the subscription type and country information in the token </span><span class="No-Break"><span class="koboSpan" id="kobo.1280.1">for simplicity.</span></span></p></li> <li><span class="koboSpan" id="kobo.1281.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">Login()</span></strong><span class="koboSpan" id="kobo.1283.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">AccountController</span></strong><span class="koboSpan" id="kobo.1285.1"> class to add the country to the claims and create another method for New Zealand users, </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1287.1">
[HttpPost("login-new-zealand")]public async Task&lt;IActionResult&gt; LoginNewZealand([FromBody] LoginModel model){    if (ModelState.IsValid)    {        var user = await userManager.FindByNameAsync(model.UserName);        if (user != null)        {            if (await userManager.CheckPasswordAsync(user, model.Password))            {                var token = GenerateToken(model.UserName, "New Zealand");                return Ok(new { token });            }        }        // If the user is not found, display an error message        ModelState.AddModelError("", "Invalid username or password");    }    return BadRequest(ModelState);}[HttpPost("login")]public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel model){    if (ModelState.IsValid)    {        var user = await userManager.FindByNameAsync(model.UserName);        if (user != null)        {            if (await userManager.CheckPasswordAsync(user, model.Password))            {                var token = GenerateToken(model.UserName, "Australia");                return Ok(new { token });            }        }        // If the user is not found, display an error message        ModelState.AddModelError("", "Invalid username or password");    }    return BadRequest(ModelState);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1288.1">Again, this</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.1289.1"> is a simplified implementation </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.1290.1">for demonstration purposes. </span><span class="koboSpan" id="kobo.1290.2">In the real world, generally, there is only one login endpoint, and the country information is retrieved from the database or other sources, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">IP addresses.</span></span></p></li> <li><span class="koboSpan" id="kobo.1292.1">Next, we need to implement the authorization policy. </span><span class="koboSpan" id="kobo.1292.2">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">SpecialPremiumContentRequirement</span></strong><span class="koboSpan" id="kobo.1294.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">Authorization</span></strong><span class="koboSpan" id="kobo.1296.1"> folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1298.1">
public class SpecialPremiumContentRequirement : IAuthorizationRequirement{    public string Country { get; }    public SpecialPremiumContentRequirement(string country)    {        Country = country;    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1299.1">This class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">IAuthorizationRequirement</span></strong><span class="koboSpan" id="kobo.1301.1"> interface. </span><span class="koboSpan" id="kobo.1301.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">Country</span></strong><span class="koboSpan" id="kobo.1303.1"> property</span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.1304.1"> represents the country where the premium content can be accessed. </span><span class="koboSpan" id="kobo.1304.2">We can use this property to check whether the user is authorized to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">premium content.</span></span></p></li> <li><span class="koboSpan" id="kobo.1306.1">Next, we </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.1307.1">need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">AuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1309.1"> interface. </span><span class="koboSpan" id="kobo.1309.2">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">SpecialPremiumContentAuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1311.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">Authorization</span></strong><span class="koboSpan" id="kobo.1313.1"> folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1315.1">
public class SpecialPremiumContentAuthorizationHandler : AuthorizationHandler&lt;SpecialPremiumContentRequirement&gt;{    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, SpecialPremiumContentRequirement requirement)    {        var hasPremiumSubscriptionClaim = context.User.HasClaim(c =&gt; c.Type == "Subscription" &amp;&amp; c.Value == "Premium");        if (!hasPremiumSubscriptionClaim)        {            return Task.CompletedTask;        }        var countryClaim = context.User.FindFirst(c =&gt; c.Type == ClaimTypes.Country);        if (countryClaim == null || string.IsNullOrWhiteSpace(countryClaim.ToString()))        {            return Task.CompletedTask;        }        if (countryClaim.Value == requirement.Country)        {            context.Succeed(requirement);        }        return Task.CompletedTask;    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1316.1">This </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.1317.1">handler is used to check whether the requirement is satisfied. </span><span class="koboSpan" id="kobo.1317.2">If the user has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">Premium</span></strong><span class="koboSpan" id="kobo.1319.1"> subscription and is based </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.1320.1">in the country where the premium content can be accessed, the requirement is satisfied. </span><span class="koboSpan" id="kobo.1320.2">Otherwise, the requirement is </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">not satisfied.</span></span></p></li> <li><span class="koboSpan" id="kobo.1322.1">Next, we need to register the authorization policy and the authorization handler. </span><span class="koboSpan" id="kobo.1322.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">Program</span></strong><span class="koboSpan" id="kobo.1324.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1326.1">
builder.Services.AddAuthorization(options =&gt;{    options.AddPolicy(AppAuthorizationPolicies.SpecialPremiumContent, policy =&gt;    {        policy.Requirements.Add(new SpecialPremiumContentRequirement("New Zealand"));    });});builder.Services.AddSingleton&lt;IAuthorizationHandler, SpecialPremiumContentAuthorizationHandler&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1327.1">In the </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.1328.1">preceding code, we registered the authorization policy, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">AppAuthorizationPolicies.SpecialPremiumContent</span></strong><span class="koboSpan" id="kobo.1330.1">, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">SpecialPremiumContentRequirement</span></strong><span class="koboSpan" id="kobo.1332.1"> requirement. </span><span class="koboSpan" id="kobo.1332.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">SpecialPremiumContentRequirement</span></strong><span class="koboSpan" id="kobo.1334.1"> requirement is satisfied if the user has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">Premium</span></strong><span class="koboSpan" id="kobo.1336.1"> subscription and is based in New Zealand. </span><span class="koboSpan" id="kobo.1336.2">We also registered the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">SpecialPremiumContentAuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1338.1"> handler as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">singleton service.</span></span></p></li> <li><span class="koboSpan" id="kobo.1340.1">Finally, we</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.1341.1"> need to apply the authorization policy to the controller. </span><span class="koboSpan" id="kobo.1341.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.1343.1"> class and add a new action, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1344.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1345.1">
[Authorize(Policy = AppAuthorizationPolicies.SpecialPremiumContent)][HttpGet("special-premium", Name = "GetPremiumWeatherForecast")]public IEnumerable&lt;WeatherForecast&gt; GetPremium(){    // Omitted for brevity}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1346.1">This action can only be accessed by users who have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">Premium</span></strong><span class="koboSpan" id="kobo.1348.1"> subscription and are based in New Zealand. </span><span class="koboSpan" id="kobo.1348.2">If the user does not have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">Premium</span></strong><span class="koboSpan" id="kobo.1350.1"> subscription or is not based in New Zealand, the authorization policy will not be satisfied, and the user will not be able to access </span><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">the action.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1352.1">You can </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.1353.1">test the application as we did in the previous section. </span><span class="koboSpan" id="kobo.1353.2">The application has two login endpoints – one for New Zealand users and one for</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.1354.1"> Australian users. </span><span class="koboSpan" id="kobo.1354.2">If you log in as a New Zealand user, you can access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">WeatherForecast/special-premium</span></strong><span class="koboSpan" id="kobo.1356.1"> endpoint. </span><span class="koboSpan" id="kobo.1356.2">Otherwise, you will get a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">403</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1"> response.</span></span></p>
<p><span class="koboSpan" id="kobo.1359.1">There are some points to note for </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">policy-based authorization:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1361.1">You can use one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">AuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1363.1"> instance to handle multiple requirements. </span><span class="koboSpan" id="kobo.1363.2">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">HandleAsync()</span></strong><span class="koboSpan" id="kobo.1365.1"> method, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">AuthorizationHandlerContext.PendingRequirements</span></strong><span class="koboSpan" id="kobo.1367.1"> to get all the pending requirements and then check them one </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">by one.</span></span></li>
<li><span class="koboSpan" id="kobo.1369.1">If you have multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">AuthorizationHandler</span></strong><span class="koboSpan" id="kobo.1371.1"> instances, they will be invoked in any order, which means you cannot expect the order of </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">the handlers.</span></span></li>
<li><span class="koboSpan" id="kobo.1373.1">You need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">context.Succeed(requirement)</span></strong><span class="koboSpan" id="kobo.1375.1"> to mark the requirement </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">as satisfied.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1377.1">What if the requirement is not satisfied? </span><span class="koboSpan" id="kobo.1377.2">There are </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">two options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1379.1">Generally, you do not need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">context.Fail()</span></strong><span class="koboSpan" id="kobo.1381.1"> to mark the failed requirement because there may be other handlers to handle the same requirement, which may </span><span class="No-Break"><span class="koboSpan" id="kobo.1382.1">be satisfied.</span></span></li>
<li><span class="koboSpan" id="kobo.1383.1">If you want to make sure the requirement fails and indicate that the whole authorization process fails, you can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">context.Fail()</span></strong><span class="koboSpan" id="kobo.1385.1"> explicitly, and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">InvokeHandlersAfterFailure</span></strong><span class="koboSpan" id="kobo.1387.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">false</span></strong><span class="koboSpan" id="kobo.1389.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">AddAuthorization()</span></strong><span class="koboSpan" id="kobo.1391.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1393.1">
builder.Services.AddAuthorization(options =&gt;  {      options.AddPolicy(AppAuthorizationPolicies.PremiumContent, policy =&gt;      {          policy.Requirements.Add(new PremiumContentRequirement("New Zealand"));      });      options.InvokeHandlersAfterFailure = false;  });</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.1394.1">In this </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.1395.1">section, we</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.1396.1"> explored the three types of authorization available in ASP.NET Core: role-based, claim-based, and policy-based. </span><span class="koboSpan" id="kobo.1396.2">We examined the source code to gain a deeper understanding of how authorization works. </span><span class="koboSpan" id="kobo.1396.3">With this knowledge, you should now b</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.1397.1">e able to confidently use the authorization features of ASP.NET Core. </span><span class="koboSpan" id="kobo.1397.2">Next, we will learn how to manage users </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">and roles.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.1399.1">Managing users and roles</span></h1>
<p><span class="koboSpan" id="kobo.1400.1">In the</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.1401.1"> previous sections, we implemented the authentication and authorization features. </span><span class="koboSpan" id="kobo.1401.2">Generally, the application should also provide a way to manage users and roles. </span><span class="koboSpan" id="kobo.1401.3">ASP.NET Core Identity provides a set of APIs to manage users and roles. </span><span class="koboSpan" id="kobo.1401.4">In this section, we will introduce how to use </span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1">these APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.1403.1">Previously, we </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.1404.1">learned that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">IdentityDbContext</span></strong><span class="koboSpan" id="kobo.1406.1"> class is used to store the user and role information. </span><span class="koboSpan" id="kobo.1406.2">So, we do not need to create a new database context class. </span><span class="koboSpan" id="kobo.1406.3">Similarly, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">UserManager</span></strong><span class="koboSpan" id="kobo.1408.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">RoleManager</span></strong><span class="koboSpan" id="kobo.1410.1"> to manage users and roles without having to write </span><span class="No-Break"><span class="koboSpan" id="kobo.1411.1">any code.</span></span></p>
<p><span class="koboSpan" id="kobo.1412.1">Here are some common operations for managing users by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">UserManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1"> class:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-6">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1415.1">Method</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1416.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">CreateAsync(TUser user, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">string password)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1419.1">Creates a user with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">given password.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">UpdateUserAsync(TUser user)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1422.1">Updates </span><span class="No-Break"><span class="koboSpan" id="kobo.1423.1">a user.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">FindByNameAsync(string userName)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1425.1">Finds a user </span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">by name.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">FindByIdAsync(string userId)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1428.1">Finds a user </span><span class="No-Break"><span class="koboSpan" id="kobo.1429.1">by ID.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">FindByEmailAsync(string email)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1431.1">Finds a user </span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">by email.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">DeleteAsync(TUser user)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1434.1">Deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">a user.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">AddToRoleAsync(TUser user, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">string role)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1438.1">Adds the user to </span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">a role.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">GetRolesAsync(TUser user)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1441.1">Gets a list of roles for </span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">the user.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">IsInRoleAsync(TUser user, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">string role)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1445.1">Checks whether the user has </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">a role.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">RemoveFromRoleAsync(TUser user, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">string role)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1449.1">Removes the user from </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">a role.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">CheckPasswordAsync(TUser user, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">string password)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1453.1">Checks whether the password is correct for </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">the user.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">ChangePasswordAsync(TUser user, string currentPassword, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">string newPassword)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1457.1">Changes the user’s password. </span><span class="koboSpan" id="kobo.1457.2">The user must provide the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">current password.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">GeneratePasswordResetTokenAsync(TUser user)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1460.1">Generates a token for resetting the user’s password. </span><span class="koboSpan" id="kobo.1460.2">You need to specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">options.Token.PasswordResetTokenProvider</span></strong><span class="koboSpan" id="kobo.1462.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">AddIdentityCore()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1464.1"> method.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">GenerateEmailConfirmationTokenAsync(TUser user)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1466.1">Generates a token for confirming the user’s email. </span><span class="koboSpan" id="kobo.1466.2">You need to specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">options.Tokens.EmailConfirmationTokenProvider</span></strong><span class="koboSpan" id="kobo.1468.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">AddIdentityCore()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1"> method.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">ConfirmEmailAsync(TUser user, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">string token)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1473.1">Checks whether the user has a valid email confirmation token. </span><span class="koboSpan" id="kobo.1473.2">If the token matches, this method will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">EmailConfirmed</span></strong><span class="koboSpan" id="kobo.1475.1"> property of the user </span><span class="No-Break"><span class="koboSpan" id="kobo.1476.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1478.1">.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1479.1">Table 8.1 – Common operations for managing users</span></p>
<p><span class="koboSpan" id="kobo.1480.1">Here </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.1481.1">are some </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.1482.1">common operations for managing roles by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">RoleManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1"> class:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1485.1">Method</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1486.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">CreateAsync(TRole role)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1488.1">Creates </span><span class="No-Break"><span class="koboSpan" id="kobo.1489.1">a role</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">RoleExistsAsync(string roleName)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1491.1">Checks whether the </span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">role exists</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">UpdateAsync(TRole role)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1494.1">Updates </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">a role</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">DeleteAsync(TRole role)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1497.1">Deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">a role</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">FindByNameAsync(string roleName)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1500.1">Finds a role </span><span class="No-Break"><span class="koboSpan" id="kobo.1501.1">by name</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1502.1">Table 8.2 – Common operations for managing roles</span></p>
<p><span class="koboSpan" id="kobo.1503.1">These APIs encapsulate the database operations, so we can use them to manage users and roles</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.1504.1"> easily. </span><span class="koboSpan" id="kobo.1504.2">Some </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.1505.1">of the methods return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">Task&lt;IdentityResult&gt;</span></strong><span class="koboSpan" id="kobo.1507.1"> object. </span><span class="koboSpan" id="kobo.1507.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">IdentityResult</span></strong><span class="koboSpan" id="kobo.1509.1"> object contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">Succeeded</span></strong><span class="koboSpan" id="kobo.1511.1"> property to indicate whether the operation is successful. </span><span class="koboSpan" id="kobo.1511.2">If the operation is not successful, you can get the error messages by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">Errors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1513.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.1514.1">We will not cover all the APIs in this book. </span><span class="koboSpan" id="kobo.1514.2">You can find more information in the ASP.NET Core documentation. </span><span class="koboSpan" id="kobo.1514.3">Next, we will learn about the new built-in Identity API endpoints in ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1">Core 8.0.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.1516.1">New Identity API endpoints in ASP.NET Core 8</span></h1>
<p><span class="koboSpan" id="kobo.1517.1">In the previous </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.1518.1">sections, we learned how to implement authentication and authorization using the built-in Identity APIs in ASP.NET Core. </span><span class="koboSpan" id="kobo.1518.2">We developed a couple of endpoints to register, log in, and manage users and roles. </span><span class="koboSpan" id="kobo.1518.3">ASP.NET Core 8.0 introduces a new set of features to simplify authentication for web APIs. </span><span class="koboSpan" id="kobo.1518.4">In this section, we will introduce these </span><span class="No-Break"><span class="koboSpan" id="kobo.1519.1">new endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.1520.1">Note that this new feature is only for simple authentication scenarios. </span><span class="koboSpan" id="kobo.1520.2">The token generated by the Identity API endpoints is opaque, not a JWT token, which means it is intended to be used by the same application only. </span><span class="koboSpan" id="kobo.1520.3">However, it is still a choice for a quick start. </span><span class="koboSpan" id="kobo.1520.4">In ASP.NET Core 8.0, we can use a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">MapIdentityApi()</span></strong><span class="koboSpan" id="kobo.1522.1"> method to map the Identity API endpoints without writing any implementation as we did in the previous sections. </span><span class="koboSpan" id="kobo.1522.2">Let’s learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">use it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1524.1">First, follow </span><em class="italic"><span class="koboSpan" id="kobo.1525.1">steps 1</span></em><span class="koboSpan" id="kobo.1526.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.1527.1">5</span></em><span class="koboSpan" id="kobo.1528.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.1529.1">Creating a sample project with authentication and authorization</span></em><span class="koboSpan" id="kobo.1530.1"> section to create a new web API project named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">NewIdentityApiDemo</span></strong><span class="koboSpan" id="kobo.1532.1">. </span><span class="koboSpan" id="kobo.1532.2">Note that you do not need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">Microsoft.AspNetCore.Authentication.JwtBearer</span></strong><span class="koboSpan" id="kobo.1534.1"> package because we will not use JWT tokens in this </span><span class="No-Break"><span class="koboSpan" id="kobo.1535.1">sample project.</span></span></li>
<li><span class="koboSpan" id="kobo.1536.1">Add the authorization policy service and register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">DbContext</span></strong><span class="koboSpan" id="kobo.1538.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1540.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1542.1">
builder.Services.AddAuthorization();builder.Services.AddDbContext&lt;AppDbContext&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.1543.1">Run the following commands to create the database and </span><span class="No-Break"><span class="koboSpan" id="kobo.1544.1">the migration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1545.1">
dotnet ef migrations add InitialDbdotnet ef database update</span></pre></li> <li><span class="koboSpan" id="kobo.1546.1">Register the Identity API endpoints in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1547.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1548.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1550.1">
builder.Services.AddIdentityApiEndpoints&lt;AppUser&gt;().AddEntityFrameworkStores&lt;AppDbContext&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1551.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">AddIdentityApiEndpoints()</span></strong><span class="koboSpan" id="kobo.1553.1"> method adds a set of common identity services to the application by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">AddIdentityCore&lt;TUser&gt;()</span></strong><span class="koboSpan" id="kobo.1555.1"> method under the hood. </span><span class="koboSpan" id="kobo.1555.2">It also configures authentication to support identity bearer tokens and cookies, so we do not need to explicitly call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">AddIdentityCore&lt;AppUser&gt;()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1557.1"> method.</span></span></p></li> <li><span class="koboSpan" id="kobo.1558.1">Map </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.1559.1">the Identity API endpoints in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1561.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1563.1">
app.MapGroup("/identity").MapIdentityApi&lt;AppUser&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1564.1">The preceding code maps the Identity API endpoints to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1565.1">/identity</span></strong><span class="koboSpan" id="kobo.1566.1"> path. </span><span class="koboSpan" id="kobo.1566.2">You can change it to any path you like, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">api/accounts</span></strong><span class="koboSpan" id="kobo.1568.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1569.1">/users</span></strong><span class="koboSpan" id="kobo.1570.1">, and so on. </span><span class="koboSpan" id="kobo.1570.2">Note that as we use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1571.1">AppUser</span></strong><span class="koboSpan" id="kobo.1572.1"> instead of the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1573.1">IdentityUser</span></strong><span class="koboSpan" id="kobo.1574.1">, we must specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">AppUser</span></strong><span class="koboSpan" id="kobo.1576.1"> type in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">MapIdentityApi()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1"> method.</span></span></p></li> <li><span class="koboSpan" id="kobo.1579.1">Apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">[Authorize]</span></strong><span class="koboSpan" id="kobo.1581.1"> attribute to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.1583.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1585.1">
[Authorize] [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase {     // Omitted for brevity }</span></pre></li> <li><span class="koboSpan" id="kobo.1586.1">Run the application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">dotnet run</span></strong><span class="koboSpan" id="kobo.1588.1">. </span><span class="koboSpan" id="kobo.1588.2">You will see the new Identity API endpoints in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1589.1">Swagger UI:</span></span></li>
</ol>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.1590.1"><img alt="Figure 8.11 – Identity API endpoints in the Swagger UI" src="image/B18971_08_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1591.1">Figure 8.11 – Identity API endpoints in the Swagger UI</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.1592.1">Now, you </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.1593.1">can explore the new Identity API endpoints. </span><span class="koboSpan" id="kobo.1593.2">Send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1594.1">POST</span></strong><span class="koboSpan" id="kobo.1595.1"> request with the following body to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">/identity/register</span></strong><span class="koboSpan" id="kobo.1597.1"> endpoint to register a </span><span class="No-Break"><span class="koboSpan" id="kobo.1598.1">new user:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1599.1">
{   "userName": "admin",   "email": "admin@example.com",   "password": "Passw0rd!" </span><span class="koboSpan" id="kobo.1599.2">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1600.1">You will see the request returns a 200 response. </span><span class="koboSpan" id="kobo.1600.2">Then, send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">POST</span></strong><span class="koboSpan" id="kobo.1602.1"> request with the following body to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1603.1">/identity/login</span></strong><span class="koboSpan" id="kobo.1604.1"> endpoint to </span><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">log in:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1606.1">{   "email": "admin@example.com",   "password": "Passw0rd!" </span><span class="koboSpan" id="kobo.1606.2">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1607.1">You will get a response that contains the access token and </span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1">refresh token:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1609.1">{   "tokenType": "Bearer",   "accessToken": "CfDJ8L-NUxrCjhBJqmxaYaETqK0P0...",   "expiresIn": 3600,   "refreshToken": "CfDJ8L-NUxrCjhBJqmxaYaETqK2U..." </span><span class="koboSpan" id="kobo.1609.2">}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1610.1">Then, you can </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.1611.1">use the access token to request the protected </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">/weatherforecast</span></strong><span class="koboSpan" id="kobo.1613.1"> endpoint with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">Authorization</span></strong><span class="koboSpan" id="kobo.1615.1"> header, as we introduced in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">previous sections.</span></span></p>
<p><span class="koboSpan" id="kobo.1617.1">This new feature also provides endpoints such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">refreshToken</span></strong><span class="koboSpan" id="kobo.1619.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">confirmEmail</span></strong><span class="koboSpan" id="kobo.1621.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">resetPassword</span></strong><span class="koboSpan" id="kobo.1623.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">2fa</span></strong><span class="koboSpan" id="kobo.1625.1">, and others. </span><span class="koboSpan" id="kobo.1625.2">Feel free to explore them on </span><span class="No-Break"><span class="koboSpan" id="kobo.1626.1">your</span><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.1627.1"> own.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.1628.1">Understanding OAuth 2.0 and OpenID Connect</span></h1>
<p><span class="koboSpan" id="kobo.1629.1">Previously, we learned how to implement authentication and authorization using built-in Identity APIs in ASP.NET Core. </span><span class="koboSpan" id="kobo.1629.2">However, you may encounter some terms such as OAuth 2.0 and OpenID Connect when you work on a real project. </span><span class="koboSpan" id="kobo.1629.3">It would be helpful to understand what they are and how to use them in ASP.NET Core. </span><span class="koboSpan" id="kobo.1629.4">It is worth authoring a full book on OAuth 2.0 and OpenID Connect. </span><span class="koboSpan" id="kobo.1629.5">In this section, we will introduce some basic concepts surrounding OAuth 2.0 and OpenID Connect, as well as some third-party authentication and </span><span class="No-Break"><span class="koboSpan" id="kobo.1630.1">authorization provid</span><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.1631.1">ers.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.1632.1">What is OAuth 2.0?</span></h2>
<p><span class="koboSpan" id="kobo.1633.1">Let’s start </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.1634.1">with a real example. </span><span class="koboSpan" id="kobo.1634.2">When you use LinkedIn, you may see a window that prompts you to sync your contacts from Outlook, Gmail, Yahoo, or other email services. </span><span class="koboSpan" id="kobo.1634.3">This is because LinkedIn would like to know your contacts so that it can recommend you to invite your friends to join LinkedIn or to connect with them. </span><span class="koboSpan" id="kobo.1634.4">This is a typical example where OAuth 2.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.1635.1">is used:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.1636.1"><img alt="Figure 8.12 – Syncing contacts on LinkedIn" src="image/B18971_08_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1637.1">Figure 8.12 – Syncing contacts on LinkedIn</span></p>
<p><span class="koboSpan" id="kobo.1638.1">If you fill in your email address and click the </span><strong class="bold"><span class="koboSpan" id="kobo.1639.1">Continue</span></strong><span class="koboSpan" id="kobo.1640.1"> button, you will be redirected to the email service provider’s website. </span><span class="koboSpan" id="kobo.1640.2">For example, I use Outlook, so I will see a window like this because I have </span><span class="No-Break"><span class="koboSpan" id="kobo.1641.1">multiple accounts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.1642.1"><img alt="Figure 8.13 – Prompting to log into Outlook" src="image/B18971_08_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1643.1">Figure 8.13 – Prompting to log into Outlook</span></p>
<p><span class="koboSpan" id="kobo.1644.1">Note the URL in</span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.1645.1"> the address bar. </span><span class="koboSpan" id="kobo.1645.2">It will look something </span><span class="No-Break"><span class="koboSpan" id="kobo.1646.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1647.1">
https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&amp;redirect_uri=https%3A%2F%2Fwww.linkedin.com%2Fgenie%2Ffinishauth&amp;scope=openid%20email%20People.Read&amp;response_type=code&amp;state=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</span></pre> <p><span class="koboSpan" id="kobo.1648.1">The URL contains </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.1649.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.1650.1">client ID</span></strong><span class="koboSpan" id="kobo.1651.1"> of the application, which is used to identify the application. </span><span class="koboSpan" id="kobo.1651.2">It also</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.1652.1"> contains the </span><strong class="bold"><span class="koboSpan" id="kobo.1653.1">redirect URL</span></strong><span class="koboSpan" id="kobo.1654.1"> so that the authorization server can redirect the user back to the application after the user </span><span class="No-Break"><span class="koboSpan" id="kobo.1655.1">grants permission.</span></span></p>
<p><span class="koboSpan" id="kobo.1656.1">You need to log into the email service provider’s website and authorize LinkedIn to access your contacts. </span><span class="koboSpan" id="kobo.1656.2">If </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.1657.1">you have already logged in, you will see </span><span class="No-Break"><span class="koboSpan" id="kobo.1658.1">this window:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.1659.1"><img alt="Figure 8.14 – Authorizing LinkedIn to access your contacts" src="image/B18971_08_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1660.1">Figure 8.14 – Authorizing LinkedIn to access your contacts</span></p>
<p><span class="koboSpan" id="kobo.1661.1">After you authorize LinkedIn, you will be redirected back to LinkedIn. </span><span class="koboSpan" id="kobo.1661.2">LinkedIn will get the contacts from the email service provider and show them </span><span class="No-Break"><span class="koboSpan" id="kobo.1662.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.1663.1">We do not </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.1664.1">want to allow LinkedIn to know the password of our email address. </span><span class="koboSpan" id="kobo.1664.2">In this case, OAuth 2.0 and OpenID Connect are used to authorize LinkedIn to access our contacts without knowing </span><span class="No-Break"><span class="koboSpan" id="kobo.1665.1">our password.</span></span></p>
<p><span class="koboSpan" id="kobo.1666.1">OAuth 2.0 </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.1667.1">implements a </span><strong class="bold"><span class="koboSpan" id="kobo.1668.1">delegated authorization</span></strong><span class="koboSpan" id="kobo.1669.1"> model. </span><span class="koboSpan" id="kobo.1669.2">It allows a client to access a protected resource on behalf of a user. </span><span class="koboSpan" id="kobo.1669.3">There are some</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.1670.1"> entities involved in the OAuth </span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">2.0 model:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1672.1">Resource owner</span></strong><span class="koboSpan" id="kobo.1673.1">: The user who owns the protected resource. </span><span class="koboSpan" id="kobo.1673.2">In our example, the resource owner is the user who owns the </span><span class="No-Break"><span class="koboSpan" id="kobo.1674.1">email address.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1675.1">Client</span></strong><span class="koboSpan" id="kobo.1676.1">: The client application that wants to access the protected resource. </span><span class="koboSpan" id="kobo.1676.2">In our example, the client is LinkedIn. </span><span class="koboSpan" id="kobo.1676.3">Note that this client is not the </span><span class="No-Break"><span class="koboSpan" id="kobo.1677.1">user’s browser.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1678.1">Resource server</span></strong><span class="koboSpan" id="kobo.1679.1">: The server that hosts the protected resource. </span><span class="koboSpan" id="kobo.1679.2">In our example, the resource server is the email service provider – for </span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">example, Outlook.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1681.1">Authorization server</span></strong><span class="koboSpan" id="kobo.1682.1">: The server that handles the delegated authorization. </span><span class="koboSpan" id="kobo.1682.2">In our example, the authorization server is Microsoft Identity Platform. </span><span class="koboSpan" id="kobo.1682.3">An </span><strong class="bold"><span class="koboSpan" id="kobo.1683.1">Authorization</span></strong><span class="koboSpan" id="kobo.1684.1"> server has at least </span><span class="No-Break"><span class="koboSpan" id="kobo.1685.1">two endpoints:</span></span><ul><li><span class="koboSpan" id="kobo.1686.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1687.1">authorization endpoint</span></strong><span class="koboSpan" id="kobo.1688.1"> is </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.1689.1">used to interact with the end user and obtain an </span><span class="No-Break"><span class="koboSpan" id="kobo.1690.1">authorization grant</span></span></li><li><span class="koboSpan" id="kobo.1691.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1692.1">token endpoint</span></strong><span class="koboSpan" id="kobo.1693.1"> is </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.1694.1">used with the client to exchange an authorization grant for an </span><span class="No-Break"><span class="koboSpan" id="kobo.1695.1">access token:</span></span></li></ul></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.1696.1"><img alt="Figure 8.15 – OAuth 2.0 flow" src="image/B18971_08_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1697.1">Figure 8.15 – OAuth 2.0 flow</span></p>
<p><span class="koboSpan" id="kobo.1698.1">Note that the</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.1699.1"> client (LinkedIn) must register itself as a known client to the authorization server (Microsoft) before it can access the protected resource. </span><span class="koboSpan" id="kobo.1699.2">The client must </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.1700.1">provide a </span><strong class="bold"><span class="koboSpan" id="kobo.1701.1">client ID</span></strong><span class="koboSpan" id="kobo.1702.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.1703.1">client secret</span></strong><span class="koboSpan" id="kobo.1704.1"> to the </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.1705.1">authorization server to prove its identity. </span><span class="koboSpan" id="kobo.1705.2">That is why we can see LinkedIn’s Microsoft Graph Connector in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1706.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1707.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1709.1">The common steps of</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.1710.1"> OAuth 2.0 are </span><span class="No-Break"><span class="koboSpan" id="kobo.1711.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1712.1">The client requests access to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1713.1">protected resource.</span></span></li>
<li><span class="koboSpan" id="kobo.1714.1">The client redirects the user to the authorization server, such as Microsoft, Google, and so on. </span><span class="koboSpan" id="kobo.1714.2">Specifically, it redirects to the authorization endpoint of the authorization server. </span><span class="koboSpan" id="kobo.1714.3">After the user is authenticated, the authorization server will prompt the user, asking something like “Hi, I have a </span><strong class="bold"><span class="koboSpan" id="kobo.1715.1">known</span></strong><span class="koboSpan" id="kobo.1716.1"> client named LinkedIn, which wants to access my APIs using your privileges. </span><span class="koboSpan" id="kobo.1716.2">Specifically, it wants to access your contacts so that it can send emails on your behalf. </span><span class="koboSpan" id="kobo.1716.3">Do you want to grant access to LinkedIn?” </span><span class="koboSpan" id="kobo.1716.4">This is what </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1717.1">Figure </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1718.1">8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1719.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1720.1"> shows.</span></span></li>
<li><span class="koboSpan" id="kobo.1721.1">Once the user</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.1722.1"> accepts the request, the authorization server will generate an </span><strong class="bold"><span class="koboSpan" id="kobo.1723.1">authorization code</span></strong><span class="koboSpan" id="kobo.1724.1">, which is just an opaque string that confirms the user did grant access to the client (LinkedIn). </span><span class="koboSpan" id="kobo.1724.2">The authorization server will redirect the user back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1725.1">client (LinkedIn).</span></span></li>
<li><span class="koboSpan" id="kobo.1726.1">The authorization code is sent to the client (LinkedIn) as a query </span><span class="No-Break"><span class="koboSpan" id="kobo.1727.1">string parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.1728.1">The </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.1729.1">client (LinkedIn) now has an authorization code. </span><span class="koboSpan" id="kobo.1729.2">Next, it will use the authorization code, client ID, and client secret to request an </span><strong class="bold"><span class="koboSpan" id="kobo.1730.1">access token</span></strong><span class="koboSpan" id="kobo.1731.1"> from</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.1732.1"> the token endpoint of the authorization server. </span><span class="koboSpan" id="kobo.1732.2">It may ask something like “Hi, I am LinkedIn. </span><span class="koboSpan" id="kobo.1732.3">This user has granted me access to the contacts of this email address. </span><span class="koboSpan" id="kobo.1732.4">This is my client credentials (client id and client secret). </span><span class="koboSpan" id="kobo.1732.5">I also have an authorization code. </span><span class="koboSpan" id="kobo.1732.6">Can I get access </span><span class="No-Break"><span class="koboSpan" id="kobo.1733.1">to this?”</span></span></li>
<li><span class="koboSpan" id="kobo.1734.1">The authorization server will verify the client credentials and the authorization code. </span><span class="koboSpan" id="kobo.1734.2">If all is good, it will generate an access token and send it back to the client (LinkedIn). </span><span class="koboSpan" id="kobo.1734.3">The access token is a string that can be used to access the protected resource. </span><span class="koboSpan" id="kobo.1734.4">It is usually a JWT token. </span><span class="koboSpan" id="kobo.1734.5">It may also contain the </span><strong class="bold"><span class="koboSpan" id="kobo.1735.1">scope</span></strong><span class="koboSpan" id="kobo.1736.1">, which is the permission that the</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.1737.1"> client (LinkedIn) has been granted. </span><span class="koboSpan" id="kobo.1737.2">For example, it may </span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">be </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1739.1">Contacts.Read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1740.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1741.1">The client (LinkedIn) can now use this access token to access the protected resource. </span><span class="koboSpan" id="kobo.1741.2">It may ask something like “Hi, I am LinkedIn. </span><span class="koboSpan" id="kobo.1741.3">I have an access token. </span><span class="koboSpan" id="kobo.1741.4">Can I access the contacts of this email address?” </span><span class="koboSpan" id="kobo.1741.5">The resource server checks the access token and if it is valid, it will return the protected resource to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1742.1">client (LinkedIn).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1743.1">In this way, the client can access the protected resource without knowing the user’s password. </span><span class="koboSpan" id="kobo.1743.2">Because the access token has a scope, it can only access the protected resource within the scope. </span><span class="koboSpan" id="kobo.1743.3">For example, if the scope is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1744.1">Contacts.Read</span></strong><span class="koboSpan" id="kobo.1745.1">, the client can only read the contacts, but it cannot modify the contacts. </span><span class="koboSpan" id="kobo.1745.2">This mechanism provides a good balance between secur</span><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.1746.1">ity </span><span class="No-Break"><span class="koboSpan" id="kobo.1747.1">and usability.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.1748.1">What is OpenID Connect?</span></h2>
<p><span class="koboSpan" id="kobo.1749.1">OAuth </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.1750.1">was initially designed and released in 2006 and later revised and standardized in 2012 as OAuth 2.0. </span><span class="koboSpan" id="kobo.1750.2">OAuth 2.0 solves the problem of delegated authorization. </span><span class="koboSpan" id="kobo.1750.3">However, there are some other scenarios that OAuth 2.0 cannot solve. </span><span class="koboSpan" id="kobo.1750.4">For example, your API may need to know the identity of the user who is accessing the API, but users may not want to create an account for your API. </span><span class="koboSpan" id="kobo.1750.5">They may already have an account in some other services, such as Microsoft, Google, and others. </span><span class="koboSpan" id="kobo.1750.6">In this case, it would be more convenient if the user could use their existing account to access your API. </span><span class="koboSpan" id="kobo.1750.7">However, OAuth 2.0 was not designed to implement sign-in with an existing account. </span><span class="koboSpan" id="kobo.1750.8">This is where a new specification named OpenID Connect </span><span class="No-Break"><span class="koboSpan" id="kobo.1751.1">comes in.</span></span></p>
<p><span class="koboSpan" id="kobo.1752.1">OpenID Connect </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.1753.1">is an authentication layer on top of OAuth 2.0 that was designed by the OpenID Foundation in 2014. </span><span class="koboSpan" id="kobo.1753.2">OpenID Connect is like an extension of OAuth 2.0 that adds and defines some new features to retrieve the identity of the user, including profile information such as the user’s name, email address, and so on. </span><span class="koboSpan" id="kobo.1753.3">OpenID Connect uses </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.1754.1">similar terminology and concepts as OAuth 2.0, such as </span><strong class="bold"><span class="koboSpan" id="kobo.1755.1">client</span></strong><span class="koboSpan" id="kobo.1756.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1757.1">resource owner</span></strong><span class="koboSpan" id="kobo.1758.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1759.1">authorization server</span></strong><span class="koboSpan" id="kobo.1760.1">, and others. </span><span class="koboSpan" id="kobo.1760.2">However, keep</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.1761.1"> in mind that OpenID Connect is not a replacement for OAuth 2.0. </span><span class="koboSpan" id="kobo.1761.2">Instead, it is a specification that extends OAuth 2.0 to </span><span class="No-Break"><span class="koboSpan" id="kobo.1762.1">support authentication.</span></span></p>
<p><span class="koboSpan" id="kobo.1763.1">Many popular identity providers, such as Microsoft, Google, Facebook, and others, have implemented OpenID Connect so that you can integrate your API application with their identity provider. </span><span class="koboSpan" id="kobo.1763.2">Then, users can use their existing account to sign into your API application. </span><span class="koboSpan" id="kobo.1763.3">Here is an example of how OpenID Connect works </span><span class="No-Break"><span class="koboSpan" id="kobo.1764.1">on </span></span><a href="http://Medium.com"><span class="No-Break"><span class="koboSpan" id="kobo.1765.1">Medium.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1766.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.1767.1"><img alt="Figure 8.16 – Medium.com sign-in with multiple identity providers" src="image/B18971_08_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1768.1">Figure 8.16 – Medium.com sign-in with multiple identity providers</span></p>
<p><span class="koboSpan" id="kobo.1769.1">If you </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.1770.1">click </span><strong class="bold"><span class="koboSpan" id="kobo.1771.1">Sign in with Google</span></strong><span class="koboSpan" id="kobo.1772.1">, you will be redirected to Google to sign in. </span><span class="koboSpan" id="kobo.1772.2">Then, you will be redirected back to Medium.com so that you can use your existing Google account to sign in to Medium.com. </span><span class="koboSpan" id="kobo.1772.3">This is what OpenID </span><span class="No-Break"><span class="koboSpan" id="kobo.1773.1">Connect does.</span></span></p>
<p><span class="koboSpan" id="kobo.1774.1">Similar to OAuth 2.0, OpenID Connect also generates an access token. </span><span class="koboSpan" id="kobo.1774.2">It also introduces a new token </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.1775.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.1776.1">ID token</span></strong><span class="koboSpan" id="kobo.1777.1">, which is a JWT token that contains the identity of the user. </span><span class="koboSpan" id="kobo.1777.2">The client application can inspect and validate the ID token to extract identity info</span><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.1778.1">rmation about </span><span class="No-Break"><span class="koboSpan" id="kobo.1779.1">the user.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.1780.1">Integrating with other identity providers</span></h2>
<p><span class="koboSpan" id="kobo.1781.1">Many identity providers </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.1782.1">support OpenID Connect so that you can integrate your API application with these platforms. </span><span class="koboSpan" id="kobo.1782.2">Here are some popular</span><a id="_idIndexMarker859"/> <span class="No-Break"><span class="koboSpan" id="kobo.1783.1">identity providers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1784.1">Microsoft</span></strong><span class="koboSpan" id="kobo.1785.1">: Microsoft </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.1786.1">provides </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.1787.1">Microsoft Identity Platform for authentication and authorization. </span><span class="koboSpan" id="kobo.1787.2">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1788.1">see </span></span><a href="https://learn.microsoft.com/zh-cn/azure/active-directory/develop/"><span class="No-Break"><span class="koboSpan" id="kobo.1789.1">https://learn.microsoft.com/zh-cn/azure/active-directory/develop/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1790.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1791.1">Google</span></strong><span class="koboSpan" id="kobo.1792.1">: Sign in</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.1793.1"> with Google is a service that helps </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.1794.1">you quickly and easily manage user authentication and share the user’s profile information with your application. </span><span class="koboSpan" id="kobo.1794.2">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1795.1">see </span></span><a href="https://developers.google.com/identity/gsi/web/guides/overview"><span class="No-Break"><span class="koboSpan" id="kobo.1796.1">https://developers.google.com/identity/gsi/web/guides/overview</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1797.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1798.1">Facebook</span></strong><span class="koboSpan" id="kobo.1799.1">: Facebook</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.1800.1"> Login is a convenient way for </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.1801.1">people to log into your application using their Facebook account. </span><span class="koboSpan" id="kobo.1801.2">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1802.1">see </span></span><a href="https://developers.facebook.com/products/facebook-login/"><span class="No-Break"><span class="koboSpan" id="kobo.1803.1">https://developers.facebook.com/products/facebook-login/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1804.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1805.1">Auth0</span></strong><span class="koboSpan" id="kobo.1806.1">: Auth0 is </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.1807.1">a cloud-based identity management</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.1808.1"> platform that provides authentication, authorization, and related security services for web, mobile, and legacy applications. </span><span class="koboSpan" id="kobo.1808.2">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1809.1">see </span></span><a href="https://auth0.com/docs/quickstart/backend"><span class="No-Break"><span class="koboSpan" id="kobo.1810.1">https://auth0.com/docs/quickstart/backend</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1811.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1812.1">Okta</span></strong><span class="koboSpan" id="kobo.1813.1">: Okta </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.1814.1">is also a cloud-based identity platform that </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.1815.1">allows organizations to manage and secure user authentication and authorization across multiple applications and services. </span><span class="koboSpan" id="kobo.1815.2">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1816.1">see </span></span><a href="https://www.okta.com/"><span class="No-Break"><span class="koboSpan" id="kobo.1817.1">https://www.okta.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1818.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1819.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1820.1">In March 2021, Okta acquired Auth0. </span><span class="koboSpan" id="kobo.1820.2">However, the two companies will continue to operate separately. </span><span class="koboSpan" id="kobo.1820.3">Generally, Auth0 targets smaller companies and is known for its developer-friendly features, but Okta is considered to be more focused on large enterprises and offers more advanced features such as network integration, single sign-on, </span><span class="No-Break"><span class="koboSpan" id="kobo.1821.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.1822.1">If you need to build an identity provider yourself, there are also some open-source projects that you </span><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">can use:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1824.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.1825.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1826.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.1827.1"> is </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.1828.1">one of the most flexible and standards-compliant OpenID Connect and OAuth 2.0 frameworks for ASP.NET Core. </span><span class="koboSpan" id="kobo.1828.2">It is widely used by many companies to secure their applications and APIs. </span><span class="koboSpan" id="kobo.1828.3">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1829.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.1830.1"> is open-source, but it is not free now. </span><span class="koboSpan" id="kobo.1830.2">The last free version is IdentityServer4, which was released in 2021, but it is no longer maintained. </span><span class="koboSpan" id="kobo.1830.3">Duende Software now provides a commercial version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1831.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.1832.1">. </span><span class="koboSpan" id="kobo.1832.2">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1833.1">see </span></span><a href="https://duendesoftware.com/products/identityserver"><span class="No-Break"><span class="koboSpan" id="kobo.1834.1">https://duendesoftware.com/products/identityserver</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1835.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1836.1">OpenIddict</span></strong><span class="koboSpan" id="kobo.1837.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">OpenIddict</span></strong><span class="koboSpan" id="kobo.1839.1"> is </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.1840.1">an open-source OpenID Connect stack for ASP.NET Core. </span><span class="koboSpan" id="kobo.1840.2">It provides a versatile solution to implement OpenID Connect client, server, token validation, and more. </span><span class="koboSpan" id="kobo.1840.3">However, it is not a turnkey solution. </span><span class="koboSpan" id="kobo.1840.4">You need to write some custom code to implement some business logic, such as an authorization controller, and more. </span><span class="koboSpan" id="kobo.1840.5">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1841.1">see </span></span><a href="https://github.com/openiddict/openiddict-core"><span class="No-Break"><span class="koboSpan" id="kobo.1842.1">https://github.com/openiddict/openiddict-core</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1843.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1844.1">KeyCloak</span></strong><span class="koboSpan" id="kobo.1845.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1846.1">KeyCloak</span></strong><span class="koboSpan" id="kobo.1847.1"> is an</span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.1848.1"> open-source identity and access management solution. </span><span class="koboSpan" id="kobo.1848.2">It provides features such as single sign-on, user federation, strong authentication, user management, fine-grained authorization, and more. </span><span class="koboSpan" id="kobo.1848.3">It is container-based, so it can easily be deployed in a containerized environment. </span><span class="koboSpan" id="kobo.1848.4">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.1849.1">see </span></span><a href="https://www.keycloak.org/"><span class="No-Break"><span class="koboSpan" id="kobo.1850.1">https://www.keycloak.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1851.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1852.1">We will not cover the details of how to integrate with these identity providers in this book. </span><span class="koboSpan" id="kobo.1852.2">Plea</span><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.1853.1">se refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1854.1">documentation instead.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.1855.1">Other security topics</span></h1>
<p><span class="koboSpan" id="kobo.1856.1">As we mentioned at the beginning of this chapter, security is a very broad topic. </span><span class="koboSpan" id="kobo.1856.2">In this section, we will briefly</span><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.1857.1"> introduce some other </span><span class="No-Break"><span class="koboSpan" id="kobo.1858.1">security topics.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.1859.1">Always use Hypertext Transfer Protocol Secure (HTTPS)</span></h2>
<p><span class="koboSpan" id="kobo.1860.1">HTTPS is a </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.1861.1">protocol that provides</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.1862.1"> secure communication between a client and a server. </span><span class="koboSpan" id="kobo.1862.2">It is a combination of the HTTP </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.1863.1">and </span><strong class="bold"><span class="koboSpan" id="kobo.1864.1">Secure Sockets Layer/Transport Layer Security</span></strong><span class="koboSpan" id="kobo.1865.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1866.1">SSL/TLS</span></strong><span class="koboSpan" id="kobo.1867.1">) protocols. </span><span class="koboSpan" id="kobo.1867.2">HTTPS is used to encrypt communication between the client and the server, ensuring that sensitive data transmitted over the internet is secure and cannot be intercepted by unauthorized third parties. </span><span class="koboSpan" id="kobo.1867.3">Google Chrome and other modern browsers will display a warning if you try to access a website that does not use HTTPS. </span><span class="koboSpan" id="kobo.1867.4">Therefore, it is very important to use HTTPS for all your </span><span class="No-Break"><span class="koboSpan" id="kobo.1868.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1869.1">The default ASP.NET Core web API template can use both HTTP and HTTPS. </span><span class="koboSpan" id="kobo.1869.2">It is recommended to use HTTPS only. </span><span class="koboSpan" id="kobo.1869.3">So, we need to configure the project to redirect all HTTP requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1870.1">to HTTPS.</span></span></p>
<p><span class="koboSpan" id="kobo.1871.1">To do that, we need to add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1872.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1873.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1874.1">
app.UseHttpsRedirection();</span></pre> <p><span class="koboSpan" id="kobo.1875.1">This code applies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">UseHttpsRedirection</span></strong><span class="koboSpan" id="kobo.1877.1"> middleware to redirect HTTP requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1878.1">to HTTPS.</span></span></p>
<p><span class="koboSpan" id="kobo.1879.1">When you run the application locally, ASP.NET Core will automatically generate a self-signed certificate and use it to encrypt communication. </span><span class="koboSpan" id="kobo.1879.2">However, when you deploy the application to a production environment, you need to use a certificate issued by a trusted </span><strong class="bold"><span class="koboSpan" id="kobo.1880.1">certificate authority</span></strong><span class="koboSpan" id="kobo.1881.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1882.1">CA</span></strong><span class="koboSpan" id="kobo.1883.1">), such</span><a id="_idIndexMarker876"/><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.1884.1"> as DigiCert, Comodo, GeoTrust, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1885.1">so on.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.1886.1">Using a strong password policy</span></h2>
<p><span class="koboSpan" id="kobo.1887.1">The</span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.1888.1"> default password policy we implemented in previous sections is </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.1889.1">not secure enough. </span><span class="koboSpan" id="kobo.1889.2">Users can use any password, which might be a security risk. </span><span class="koboSpan" id="kobo.1889.3">It is important to force users to use strong, unique passwords that are difficult for others to guess or crack. </span><span class="koboSpan" id="kobo.1889.4">Generally, a good password should be a combination of uppercase and lowercase letters, numbers, and special characters. </span><span class="koboSpan" id="kobo.1889.5">The length of the password should be at least 8 characters. </span><span class="koboSpan" id="kobo.1889.6">We can define a </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.1890.1">password policy to enforce </span><span class="No-Break"><span class="koboSpan" id="kobo.1891.1">these rules.</span></span></p>
<p><span class="koboSpan" id="kobo.1892.1">We can </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.1893.1">specify the password policy in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1894.1">Program</span></strong><span class="koboSpan" id="kobo.1895.1"> class. </span><span class="koboSpan" id="kobo.1895.2">Add the following code after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1896.1">AddAuthentication()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1897.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1898.1">
builder.Services.Configure&lt;IdentityOptions&gt;(options =&gt;{
    // Password settings
    options.Password.RequireDigit = true;
    options.Password.RequireLowercase = true;
    options.Password.RequireNonAlphanumeric = true;
    options.Password.RequireUppercase = true;
    options.Password.RequiredLength = 8;
    options.Password.RequiredUniqueChars = 1;
    // User settings
    options.User.AllowedUserNameCharacters =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+";
    options.User.RequireUniqueEmail = true;
});</span></pre>
<p><span class="koboSpan" id="kobo.1899.1">The preceding code is easy to understand. </span><span class="koboSpan" id="kobo.1899.2">In this example, we require the password to contain at least one uppercase letter, one lowercase letter, one number, and one special character, and the length of the password should be at least 8 characters. </span><span class="koboSpan" id="kobo.1899.3">We also require the user’s email to be unique. </span><span class="koboSpan" id="kobo.1899.4">So, if a user tries to register with an email that is already in use, the registration will fail. </span><span class="koboSpan" id="kobo.1899.5">Now, the user’s password should be hard </span><span class="No-Break"><span class="koboSpan" id="kobo.1900.1">to guess.</span></span></p>
<p><span class="koboSpan" id="kobo.1901.1">We can also enforce the password policy when the user fails to log in. </span><span class="koboSpan" id="kobo.1901.2">For example, if the user fails to log in three times, the account will be locked for 5 minutes. </span><span class="koboSpan" id="kobo.1901.3">This can help prevent brute-force attacks. </span><span class="koboSpan" id="kobo.1901.4">To </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.1902.1">enable this feature, add the following code after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1903.1">AddAuthentication()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1904.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1905.1">
builder.Services.Configure&lt;IdentityOptions&gt;(options =&gt;{
    // Omitted for brevity
    // Lockout settings
    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5);
    options.Lockout.MaxFailedAccessAttempts = 3;
    options.Lockout.AllowedForNewUsers = true;
});</span></pre>
<p><span class="koboSpan" id="kobo.1906.1">This</span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.1907.1"> change works when we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1908.1">SignInManager.CheckPasswordSignInAsync()</span></strong><span class="koboSpan" id="kobo.1909.1"> method to sign in. </span><span class="koboSpan" id="kobo.1909.2">In previous examples, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1910.1">UserManager</span></strong><span class="koboSpan" id="kobo.1911.1">. </span><span class="koboSpan" id="kobo.1911.2">So, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1912.1">Login()</span></strong><span class="koboSpan" id="kobo.1913.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1914.1">AuthenticationController</span></strong><span class="koboSpan" id="kobo.1915.1"> class. </span><span class="koboSpan" id="kobo.1915.2">First, we need to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1916.1">SignInManager</span></strong><span class="koboSpan" id="kobo.1917.1"> into the controller. </span><span class="koboSpan" id="kobo.1917.2">Then, we must update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1918.1">AuthenticationController</span></strong><span class="koboSpan" id="kobo.1919.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1920.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1921.1">
[HttpPost("login")]public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel model)
{
    // Check if the model is valid
    if (ModelState.IsValid)
    {
        var user = await _userManager.FindByNameAsync(model.UserName);
        if (user != null)
        {
            var result =
                await _signInManager.CheckPasswordSignInAsync(user, model.Password, lockoutOnFailure: true);
            if (result.Succeeded)
            {
                var token = GenerateToken(model.UserName);
                return Ok(new { token });
            }
        }
        // If the user is not found, display an error message
        ModelState.AddModelError("", "Invalid username or password");
    }
    return BadRequest(ModelState);
}</span></pre>
<p><span class="koboSpan" id="kobo.1922.1">The </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.1923.1">preceding code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1924.1">SignInManager.CheckPasswordSignInAsync()</span></strong><span class="koboSpan" id="kobo.1925.1"> method to sign in, which has a parameter named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1926.1">lockoutOnFailure</span></strong><span class="koboSpan" id="kobo.1927.1"> that specifies whether the account should be locked out </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.1928.1">when the user fails to log in. </span><span class="koboSpan" id="kobo.1928.2">The default value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1929.1">false</span></strong><span class="koboSpan" id="kobo.1930.1">, so we need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1931.1">true</span></strong><span class="koboSpan" id="kobo.1932.1"> to enable the </span><span class="No-Break"><span class="koboSpan" id="kobo.1933.1">lockout feature.</span></span></p>
<p><span class="koboSpan" id="kobo.1934.1">Note that if you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1935.1">AddIdentityCore&lt;AppUser&gt;()</span></strong><span class="koboSpan" id="kobo.1936.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1938.1">, as we mentioned in the previous section, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1939.1">SignInManager</span></strong><span class="koboSpan" id="kobo.1940.1"> is not available by default. </span><span class="koboSpan" id="kobo.1940.2">In this case, you need to explicitly add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1941.1">SignInManager</span></strong><span class="koboSpan" id="kobo.1942.1"> service to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1943.1">ConfigureServices()</span></strong><span class="koboSpan" id="kobo.1944.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.1945.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1946.1">
builder.Services.AddIdentityCore&lt;AppUser&gt;()    .AddSignInManager()
    .AddEntityFrameworkStores&lt;AppDbContext&gt;()
    .AddDefaultTokenProviders();</span></pre>
<p><span class="koboSpan" id="kobo.1947.1">Let’s test the </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.1948.1">application. </span><span class="koboSpan" id="kobo.1948.2">Run the application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1949.1">dotnet run</span></strong><span class="koboSpan" id="kobo.1950.1"> and create a new user using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">Register</span></strong><span class="koboSpan" id="kobo.1952.1"> API. </span><span class="koboSpan" id="kobo.1952.2">You will find that if the password is too simple, you will get an</span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.1953.1"> error message. </span><span class="koboSpan" id="kobo.1953.2">Here is a </span><span class="No-Break"><span class="koboSpan" id="kobo.1954.1">sample request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1955.1">
{  "userName": "user",
  "email": "user@example.com",
  "password": "123456"
}</span></pre>
<p><span class="koboSpan" id="kobo.1956.1">You will get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1957.1">400</span></strong><span class="koboSpan" id="kobo.1958.1"> response with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1959.1">error message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1960.1">
{  "": [
    "Passwords must be at least 8 characters.",
    "Passwords must have at least one non alphanumeric character.",
    "Passwords must have at least one lowercase ('a'-'z').",
    "Passwords must have at least one uppercase ('A'-'Z')."
</span><span class="koboSpan" id="kobo.1960.2">  ]
}</span></pre>
<p><span class="koboSpan" id="kobo.1961.1">If you attempt to log in with an incorrect password more than three times, you will be locked out of the system for 5 minutes. </span><span class="koboSpan" id="kobo.1961.2">During this period, you will not be able to access the system, even if you enter the correct password. </span><span class="koboSpan" id="kobo.1961.3">After those 5 min</span><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.1962.1">utes have elapsed, you will be able to log </span><span class="No-Break"><span class="koboSpan" id="kobo.1963.1">in again.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.1964.1">Implementing two-factor authentication (2FA)</span></h2>
<p><span class="koboSpan" id="kobo.1965.1">2FA is a </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.1966.1">security process that requires users to provide two different forms of authentication to verify their identity. </span><span class="koboSpan" id="kobo.1966.2">Besides the </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.1967.1">common username and password, 2FA adds an extra layer of security by requiring users to provide a second authentication factor, such as a code sent to their mobile phone or authenticator app, fingerprint, face recognition, and so on. </span><span class="koboSpan" id="kobo.1967.2">This makes it harder for hackers to gain access to user accounts. </span><span class="koboSpan" id="kobo.1967.3">Even if the hacker gets the user’s password, they still cannot get the second factor. </span><span class="koboSpan" id="kobo.1967.4">2FA is widely used in banking and financial </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.1968.1">services to protect users’ </span><span class="No-Break"><span class="koboSpan" id="kobo.1969.1">sensitive information.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1970.1">Multi-factor authentication</span></strong><span class="koboSpan" id="kobo.1971.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1972.1">MFA</span></strong><span class="koboSpan" id="kobo.1973.1">) is a</span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.1974.1"> superset </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.1975.1">of 2FA. </span><span class="koboSpan" id="kobo.1975.2">It requires users to provide more than two factors to verify their identity. </span><span class="koboSpan" id="kobo.1975.3">There are two types </span><span class="No-Break"><span class="koboSpan" id="kobo.1976.1">of MFA:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1977.1">MFA Time-based One-Time Password</span></strong><span class="koboSpan" id="kobo.1978.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1979.1">TOTP</span></strong><span class="koboSpan" id="kobo.1980.1">): MFA TOTP is a type of MFA that </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.1981.1">requires users to provide a code generated by an authenticator app (such as Google Authenticator or Microsoft Authenticator). </span><span class="koboSpan" id="kobo.1981.2">The code is valid for a short period, usually 30 seconds. </span><span class="koboSpan" id="kobo.1981.3">After the code expires, the user needs to generate a new code. </span><span class="koboSpan" id="kobo.1981.4">This type of MFA is widely used in banking and financial services. </span><span class="koboSpan" id="kobo.1981.5">If you use a bank app, you might have seen this type of MFA. </span><span class="koboSpan" id="kobo.1981.6">It requires the server and authenticator app to have an </span><span class="No-Break"><span class="koboSpan" id="kobo.1982.1">accurate time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1983.1">MFA Fast Identity Online 2</span></strong><span class="koboSpan" id="kobo.1984.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1985.1">FIDO2</span></strong><span class="koboSpan" id="kobo.1986.1">): MFA FIDO2 is a type of MFA that requires users to </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.1987.1">authenticate using a hardware key, such as a USB key or a biometric device (such as a fingerprint scanner). </span><span class="koboSpan" id="kobo.1987.2">It has become more popular in recent years. </span><span class="koboSpan" id="kobo.1987.3">However, ASP.NET Core does not support FIDO2 </span><span class="No-Break"><span class="koboSpan" id="kobo.1988.1">directly yet.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1989.1">MFA SMS</span></strong><span class="koboSpan" id="kobo.1990.1">: MFA SMS </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.1991.1">is no longer recommended because there are many security issues </span><span class="No-Break"><span class="koboSpan" id="kobo.1992.1">with SMS.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1993.1">To learn more about</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.1994.1"> MFA, please refer </span><span class="No-Break"><span class="koboSpan" id="kobo.1995.1">to </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa"><span class="No-Break"><span class="koboSpan" id="kobo.1996.1">https://learn</span><span id="_idTextAnchor355"/><span class="koboSpan" id="kobo.1997.1">.microsoft.com/en-us/aspnet/core/security/authentication/mfa</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1998.1">.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.1999.1">Implementing rate-limiting</span></h2>
<p><span class="koboSpan" id="kobo.2000.1">Rate-limiting</span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.2001.1"> is a security mechanism that limits the number of </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.2002.1">requests a </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.2003.1">client can make to a server. </span><span class="koboSpan" id="kobo.2003.2">It can prevent malicious clients from making too many requests, which can</span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.2004.1"> cause a </span><strong class="bold"><span class="koboSpan" id="kobo.2005.1">denial of service</span></strong><span class="koboSpan" id="kobo.2006.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.2007.1">DoS</span></strong><span class="koboSpan" id="kobo.2008.1">) attack. </span><span class="koboSpan" id="kobo.2008.2">ASP.NET Core provides a built-in r</span><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.2009.1">ate-limiting middleware. </span><span class="koboSpan" id="kobo.2009.2">We explained how to use it in </span><a href="B18971_04.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2010.1">Chapter 4</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.2011.1">.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.2012.1">Using model validation</span></h2>
<p><span class="koboSpan" id="kobo.2013.1">Model validation</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.2014.1"> is a security mechanism that prevents malicious</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.2015.1"> users from sending invalid data to the server. </span><span class="koboSpan" id="kobo.2015.2">We should always validate the </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.2016.1">data sent by the client. </span><span class="koboSpan" id="kobo.2016.2">In other words, the client is not trusted. </span><span class="koboSpan" id="kobo.2016.3">For example, we expect a property in the model to be an integer, but what if the client sends a string? </span><span class="koboSpan" id="kobo.2016.4">The application should be able to handle this situation and reject the request directly before executing any </span><span class="No-Break"><span class="koboSpan" id="kobo.2017.1">business logic.</span></span></p>
<p><span class="koboSpan" id="kobo.2018.1">ASP.NET Core provides a built-in model binding and model validation mechanism. </span><span class="koboSpan" id="kobo.2018.2">Model binding is used to convert the data sent by the client to the corresponding model. </span><span class="koboSpan" id="kobo.2018.3">The data sent by the client can be in different formats, such as JSON, XML, form fields, or query strings. </span><span class="koboSpan" id="kobo.2018.4">Model validation is used to check whether the data sent by the client is valid. </span><span class="koboSpan" id="kobo.2018.5">We used model validation in the previous sections. </span><span class="koboSpan" id="kobo.2018.6">For example, here is the code we used to register a </span><span class="No-Break"><span class="koboSpan" id="kobo.2019.1">new user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2020.1">
// Create an action to register a new user[HttpPost("register")]
public async Task&lt;IActionResult&gt; Register([FromBody] AddOrUpdateAppUserModel model)
{
    // Check if the model is valid
    if (ModelState.IsValid)
    {
        // Omitted for brevity
    }
    return BadRequest(ModelState);
}</span></pre>
<p><span class="koboSpan" id="kobo.2021.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2022.1">ModelState.IsValid</span></strong><span class="koboSpan" id="kobo.2023.1"> property represents whether the model is valid. </span><span class="koboSpan" id="kobo.2023.2">So, how does ASP.NET Core </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.2024.1">validate the model? </span><span class="koboSpan" id="kobo.2024.2">Look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2025.1">AddOrUpdateAppUserModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2026.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2027.1">
public class AddOrUpdateAppUserModel{
    [Required(ErrorMessage = "User name is required")]
    public string UserName { get; set; } = string.Empty;
    [EmailAddress]
    [Required(ErrorMessage = "Email is required")]
    public string Email { get; set; } = string.Empty;
    [Required(ErrorMessage = "Password is required")]
    public string Password { get; set; } = string.Empty;
}</span></pre>
<p><span class="koboSpan" id="kobo.2028.1">We use</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.2029.1"> the validation attributes to specify the validation rules. </span><span class="koboSpan" id="kobo.2029.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2030.1">Required</span></strong><span class="koboSpan" id="kobo.2031.1"> is a built-in attribute annotation that specifies that the property is required. </span><span class="koboSpan" id="kobo.2031.2">Here are some of the most commonly used ones </span><span class="No-Break"><span class="koboSpan" id="kobo.2032.1">besides </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2033.1">Required</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2034.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2035.1">CreditCard</span></strong><span class="koboSpan" id="kobo.2036.1">: This specifies that the property must be a valid credit </span><span class="No-Break"><span class="koboSpan" id="kobo.2037.1">card number</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2038.1">EmailAddress</span></strong><span class="koboSpan" id="kobo.2039.1">: This specifies that the property must be a valid </span><span class="No-Break"><span class="koboSpan" id="kobo.2040.1">email address</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2041.1">Phone</span></strong><span class="koboSpan" id="kobo.2042.1">: This specifies that the property must be a valid </span><span class="No-Break"><span class="koboSpan" id="kobo.2043.1">phone number</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2044.1">Range</span></strong><span class="koboSpan" id="kobo.2045.1">: This specifies that the property must be within a </span><span class="No-Break"><span class="koboSpan" id="kobo.2046.1">specified range</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2047.1">RegularExpression</span></strong><span class="koboSpan" id="kobo.2048.1">: This specifies that the property must match a specified </span><span class="No-Break"><span class="koboSpan" id="kobo.2049.1">regular expression</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2050.1">StringLength</span></strong><span class="koboSpan" id="kobo.2051.1">: This specifies that the property must be a string with a </span><span class="No-Break"><span class="koboSpan" id="kobo.2052.1">specified length</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2053.1">Url</span></strong><span class="koboSpan" id="kobo.2054.1">: This specifies that the property must be a </span><span class="No-Break"><span class="koboSpan" id="kobo.2055.1">valid URL</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2056.1">Compare</span></strong><span class="koboSpan" id="kobo.2057.1">: This specifies that the property must be the same as </span><span class="No-Break"><span class="koboSpan" id="kobo.2058.1">another property</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2059.1">If these</span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.2060.1"> built-in </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.2061.1">attributes cannot meet your requirements, you can also create custom attributes. </span><span class="koboSpan" id="kobo.2061.2">For example, you can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.2062.1">Adult</span></strong><span class="koboSpan" id="kobo.2063.1"> attribute to validate the age of the user based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.2064.1">user’s birthday:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2065.1">
public class AdultAttribute : ValidationAttribute{
    public string GetErrorMessage() =&gt; $"You must be at least 18 years old to register.";
    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        var birthDate = (DateTime)value;
        var age = DateTime.Now.Year - birthDate.Year;
        if (DateTime.Now.Month &lt; birthDate.Month || (DateTime.Now.Month == birthDate.Month &amp;&amp; DateTime.Now.Day &lt; birthDate.Day))
        {
            age--;
        }
        if (age &lt; 18)
        {
            return new ValidationResult(GetErrorMessage());
        }
        return ValidationResult.Success;
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.2066.1">Then, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2067.1">Adult</span></strong><span class="koboSpan" id="kobo.2068.1"> attribute in </span><span class="No-Break"><span class="koboSpan" id="kobo.2069.1">the model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2070.1">
public class AddOrUpdateAppUserModel{
    // Omitted for brevity
    [Required(ErrorMessage = "Birthday is required")]
    [Adult]
    public DateTime Birthday { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.2071.1">You can also </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.2072.1">manually validate the model in the controller. </span><span class="koboSpan" id="kobo.2072.2">For</span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.2073.1"> example, you can check whether the user’s email </span><span class="No-Break"><span class="koboSpan" id="kobo.2074.1">is unique:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2075.1">
// Create an action to register a new user[HttpPost("register")]
public async Task&lt;IActionResult&gt; Register([FromBody] AddOrUpdateAppUserModel model)
{
    // Check if the email is unique
    if (await _userManager.FindByEmailAsync(model.Email) != null)
    {
        ModelState.AddModelError("Email", "Email already exists");
        return BadRequest(ModelState);
    }
    if (ModelState.IsValid)
    {
        // Omitted for brevity
    }
    return BadRequest(ModelState);
}</span></pre>
<p><span class="koboSpan" id="kobo.2076.1">In the</span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.2077.1"> preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2078.1">AddModelError()</span></strong><span class="koboSpan" id="kobo.2079.1"> method to </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.2080.1">add a validation error to the model. </span><span class="koboSpan" id="kobo.2080.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2081.1">ModelState.IsValid</span></strong><span class="koboSpan" id="kobo.2082.1"> property will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.2083.1">false</span></strong><span class="koboSpan" id="kobo.2084.1"> if there is any validation error. </span><span class="koboSpan" id="kobo.2084.2">In </span><a href="B18971_16.xhtml#_idTextAnchor671"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2085.1">Chapter 16</span></em></span></a><span class="koboSpan" id="kobo.2086.1">, we will discuss how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2087.1">ProblemDetails </span></strong><span class="koboSpan" id="kobo.2088.1">class to return error information to the client and how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.2089.1">FluentValidation</span></strong><span class="koboSpan" id="kobo.2090.1"> to validate the model for</span><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.2091.1"> more complex scenarios. </span><span class="koboSpan" id="kobo.2091.2">You can refer to that chapter for </span><span class="No-Break"><span class="koboSpan" id="kobo.2092.1">more information.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.2093.1">Using parameterized queries</span></h2>
<p><span class="koboSpan" id="kobo.2094.1">We </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.2095.1">explained how to use EF Core to execute SQL queries in previous</span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.2096.1"> chapters. </span><span class="koboSpan" id="kobo.2096.2">Generally, if you use LINQ to query data, EF Core will generate parameterized queries for you. </span><span class="koboSpan" id="kobo.2096.3">However, you need to take care of SQL injection attacks when you use the </span><span class="No-Break"><span class="koboSpan" id="kobo.2097.1">following methods:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2098.1">FromSqlRaw()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2099.1">SqlQeuryRaw()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2100.1">ExecuteSqlRaw()</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2101.1">These methods allow you to execute raw SQL queries without sanitizing the input.</span><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.2102.1"> So, please make sure you sanitize the query statements before </span><span class="No-Break"><span class="koboSpan" id="kobo.2103.1">executing them.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.2104.1">Using data protection</span></h2>
<p><span class="koboSpan" id="kobo.2105.1">Data protection </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.2106.1">is a security mechanism that prevents malicious </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.2107.1">users from accessing sensitive data. </span><span class="koboSpan" id="kobo.2107.2">For example, if you store the user’s password in the database, you should encrypt it before storing it. </span><span class="koboSpan" id="kobo.2107.3">Another example is the user’s credit card number, which should also be encrypted before it </span><span class="No-Break"><span class="koboSpan" id="kobo.2108.1">is stored.</span></span></p>
<p><span class="koboSpan" id="kobo.2109.1">The reason for this is that if the database is compromised, the attacker can easily access the user’s sensitive data. </span><span class="koboSpan" id="kobo.2109.2">In other words, the database is not trusted, just like the client. </span><span class="koboSpan" id="kobo.2109.3">Data protection is another big topic, but it is beyond the scope of this book. </span><span class="koboSpan" id="kobo.2109.4">ASP.NET Core provides a built-in data protection mechanism. </span><span class="koboSpan" id="kobo.2109.5">If you would like to learn more about it, please refer to the official </span><span class="No-Break"><span class="koboSpan" id="kobo.2110.1">documentation: </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction"><span class="No-Break"><span class="koboSpan" id="kobo.2111.1">http</span><span id="_idTextAnchor363"/><span class="koboSpan" id="kobo.2112.1">s://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.2113.1">.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.2114.1">Keeping secrets safe</span></h2>
<p><span class="koboSpan" id="kobo.2115.1">Secrets </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.2116.1">are sensitive data that should not be exposed to the public. </span><span class="koboSpan" id="kobo.2116.2">In our applications, we may have many secrets, such as the database </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.2117.1">connection string, the API keys, the client secrets, and so on. </span><span class="koboSpan" id="kobo.2117.2">In the previous chapters, we often stored them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2118.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.2119.1"> file. </span><span class="koboSpan" id="kobo.2119.2">However, we need to emphasize that this is not a good practice. </span><span class="koboSpan" id="kobo.2119.3">These secrets should be stored in a safe place, such as Azure Key Vault, AWS Secrets Manager, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2120.1">kube-secrets</span></strong><span class="koboSpan" id="kobo.2121.1">. </span><span class="koboSpan" id="kobo.2121.2">Never upload them to the source </span><span class="No-Break"><span class="koboSpan" id="kobo.2122.1">code repository.</span></span></p>
<p><span class="koboSpan" id="kobo.2123.1">We will introduce </span><strong class="bold"><span class="koboSpan" id="kobo.2124.1">continuous integration/co</span><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.2125.1">ntinuous deployment</span></strong><span class="koboSpan" id="kobo.2126.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.2127.1">CI/CD</span></strong><span class="koboSpan" id="kobo.2128.1">) and explain how to store secrets safely in </span><a href="B18971_14.xhtml#_idTextAnchor585"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2129.1">Chapter 14</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.2130.1">.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.2131.1">Keeping the framework up to date</span></h2>
<p><span class="koboSpan" id="kobo.2132.1">The .NET</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.2133.1"> Core framework is an open-source project. </span><span class="koboSpan" id="kobo.2133.2">It is constantly being updated. </span><span class="koboSpan" id="kobo.2133.3">We should always keep the framework up to date, including the NuGet packages. </span><span class="koboSpan" id="kobo.2133.4">Note the life cycle of the .NET Core framework. </span><span class="koboSpan" id="kobo.2133.5">Use the latest version of the framework as much as possible. </span><span class="koboSpan" id="kobo.2133.6">If you are using an older version, you should consider upgrading it. </span><span class="koboSpan" id="kobo.2133.7">You can find the life cycle of the .NET Core fram</span><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.2134.1">ework </span><span class="No-Break"><span class="koboSpan" id="kobo.2135.1">here: </span></span><a href="https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core"><span class="No-Break"><span class="koboSpan" id="kobo.2136.1">https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.2137.1">.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.2138.1">Checking the Open Web Application Security Project (OWASP) Top 10</span></h2>
<p><span class="koboSpan" id="kobo.2139.1">OWASP</span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.2140.1"> is a </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.2141.1">nonprofit organization that provides information about web application security. </span><span class="koboSpan" id="kobo.2141.2">It publishes a list of the most common web application security risks, which is called the OWASP Top 10. </span><span class="koboSpan" id="kobo.2141.3">You can find the </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.2142.1">OWASP Top 10 here: </span><a href="https://owasp.org/www-project-top-ten/"><span class="koboSpan" id="kobo.2143.1">https://owasp.org/www-project-top-ten/</span></a><span class="koboSpan" id="kobo.2144.1">. </span><span class="koboSpan" id="kobo.2144.2">You should check the list regularly to make sure your application is not vulnerable to any of </span><span class="No-Break"><span class="koboSpan" id="kobo.2145.1">the risks.</span></span></p>
<p><span class="koboSpan" id="kobo.2146.1">Also, OWASP provides a free resource called </span><em class="italic"><span class="koboSpan" id="kobo.2147.1">DotNet Security Cheat Sheet</span></em><span class="koboSpan" id="kobo.2148.1">, where you can find the best practices for securing .NET Core applications. </span><span class="koboSpan" id="kobo.2148.2">You can find it </span><a id="_idTextAnchor369"/><span class="No-Break"><span class="koboSpan" id="kobo.2149.1">here: </span></span><a href="https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html"><span class="No-Break"><span class="koboSpan" id="kobo.2150.1">https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.2151.1">.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.2152.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2153.1">In this chapter, we introduced the security and identity features of ASP.NET Core. </span><span class="koboSpan" id="kobo.2153.2">We mainly learned how to use its built-in authentication and authorization mechanisms. </span><span class="koboSpan" id="kobo.2153.3">We learned how to use the Identity framework to manage users and roles, and also explained role-based authorization, claim-based authorization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.2154.1">policy-based authorization.</span></span></p>
<p><span class="koboSpan" id="kobo.2155.1">Then, we introduced OAuth 2.0 and OpenID Connect, which are the most popular authentication and authorization standards. </span><span class="koboSpan" id="kobo.2155.2">After that, we explained several security practices, such as using HTTPS, strong passwords, parameterized queries, </span><span class="No-Break"><span class="koboSpan" id="kobo.2156.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.2157.1">Again, security is a big topic, and we cannot cover all the details in one chapter. </span><span class="koboSpan" id="kobo.2157.2">Please treat security as a continuous process, and always keep your </span><span class="No-Break"><span class="koboSpan" id="kobo.2158.1">application secure.</span></span></p>
<p><span class="koboSpan" id="kobo.2159.1">In the next chapter, we will get starssseted with testing, which is an important part of any software project. </span><span class="koboSpan" id="kobo.2159.2">We will learn how to write unit tests for ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.2160.1">Core applications.</span></span></p>
</div>
</body></html>