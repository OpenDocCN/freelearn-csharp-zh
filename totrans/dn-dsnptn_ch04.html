<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>4. Targeting Multiple Databases</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;4.&#160;Targeting Multiple Databases">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04"></a>Chapter&#160;4.&#160;Targeting Multiple Databases</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will try to create a library which will help application developers target their applications against SQL Server, SQLite, MySQL, and Oracle. As a result of creating this library, we will be able to write the application code without worrying about the underlying persistence technology. Even though ADO.NET does a wonderful job of abstracting away the nitty-gritties of a <span class="strong"><strong>relational database management system</strong></span> (<span class="strong"><strong>RDBMS</strong></span>), we need more than what is available as a stock feature within ADO.NET to write a database-agnostic persistence layer.</p>
        <p>During the course of this chapter, as a reader, you will learn to leverage the abstract factory pattern, factory pattern, and the adapter pattern to be able to do the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Interfacing with various ADO.NET providers</li>
            <li class="listitem" style="list-style-type: disc">Writing persistence-store agnostic logic</li>
            <li class="listitem" style="list-style-type: disc">Writing data to an SQLite database</li>
            <li class="listitem" style="list-style-type: disc">Writing data to an SQL Server database</li>
            <li class="listitem" style="list-style-type: disc">Writing data to an ODBC data source</li>
          </ul>
        </div>
        <div class="section" title="Requirements for the library">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch04lvl1sec26"></a>Requirements for the library</h1>
              </div>
            </div>
          </div>
          <p>Before we embark on writing the library, let us scribble down a preliminary requirement statement as follows:</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note19"></a>Note</h3>
              <p>When we write business applications, our application should be able to persist to relational database engines from different database vendors.</p>
            </div>
          </div>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note191"></a>Note</h3>
              <p>We should be able to support SQL Server, SQLite, Oracle, or any database engine which supports ADO.net. Adding a new DB engine should be a breeze. Likewise, changing the database technology should be seamless for the application developer.</p>
            </div>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Solutions approach">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec27"></a>Solutions approach</h1>
            </div>
          </div>
        </div>
        <p>With the advent of ORM technologies like ADO.NET <span class="strong"><strong>Entity Framework</strong></span> (<span class="strong"><strong>EF</strong></span>) and <span class="strong"><strong>NHibernate</strong></span>, writing an application which targets multiple database offerings has become easier. The authors believe that ADO.NET EF works in tandem with the Visual Studio environment and its tools, and would be difficult to deal with in a book meant for pattern oriented software development. For people from the Java world, who are accustomed to the Hibernate library, NHibernate flattens the learning curve. Despite its dwindling usage and popularity (reasons unknown) amidst .NET professionals, the authors feel that NHibernate is a viable option to write enterprise grade applications in. In this book, for the sake of simplicity, we will be using the ADO.NET programming model to isolate the database specificities.</p>
        <p>The ADO.NET library is based on the following set of interfaces defined in the <code class="literal">System.Data</code> assembly from Microsoft:</p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td>
<p>
<span class="strong"><strong>Interface</strong></span>
</p>
</td>
                <td>
<p>
<span class="strong"><strong>Definition</strong></span>
</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">IDbConnection</code>
</p>
</td>
                <td>
<p>Interface for managing database connection specifics.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">IDbCommand</code>
</p>
</td>
                <td>
<p>Interface for issuing SQL commands and queries.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">IDbDataAdapter</code>
</p>
</td>
                <td>
<p>Interface for disconnected data access.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">IDataReader</code>
</p>
</td>
                <td>
<p>Interface for cursor-based access to the database.</p>
</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note20"></a>Note</h3>
            <p>There are other interfaces which deal with the management of transactions, stored procedures, and associated parameter handling. We will ignore them in this book for the sake of shortening our code listings. Those can be incorporated into our library without much effort.</p>
          </div>
        </div>
        <p>Each of the aforementioned Interfaces is implemented by a provider written by the respective database vendor. Microsoft encourages independent vendors to write ADO.NET providers. The SQL Server implementation (<code class="literal">System.Data.SqlClient</code>) of these interfaces are named as follows:</p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td>
<p>
<span class="strong"><strong>Class</strong></span>
</p>
</td>
                <td>
<p>
<span class="strong"><strong>Definition</strong></span>
</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SqlConnection</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDbConnection</code> interface.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SqlCommand</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDbCommand</code> interface.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SqlDataAdapter</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDbAdapter</code> interface.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SqlDataReader</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDataReader</code> interface.</p>
</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>In the case of <code class="literal">System.Data.SQLite</code>, the scheme is as follows:
</p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td>
<p>
<span class="strong"><strong>Class</strong></span>
</p>
</td>
                <td>
<p>
<span class="strong"><strong>Definition</strong></span>
</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SQLiteConnection</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDbConnection</code> interface.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SQLiteCommand</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDbCommand</code> interface.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SQLitelDataAdapter</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDbAdapter</code> interface.</p>
</td>
              </tr>
              <tr>
                <td>
<p>
<code class="literal">SQLiteDataReader</code>
</p>
</td>
                <td>
<p>Implementation of <code class="literal">IDataReader</code> interface.</p>
</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Similar provider classes are implemented by Oracle and MySQL.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note21"></a>Note</h3>
            <p>We will be using the GoF catalog's abstract factory methods to instantiate standard ADO.NET-library-specific interfaces for connection, command, data adapter, and reader. The abstract factory pattern is a creational pattern which provides an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
          </div>
        </div>
        <div class="section" title="A quick primer on ADO.net">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec22"></a>A quick primer on ADO.net</h2>
              </div>
            </div>
          </div>
          <p>Since we are using ADO.net API for accessing databases, a couple of code snippets will be of help to comprehend the following sections. There are two ways to write code using the ADO.net API. We can directly use the concrete classes to access the database content. The following code snippet shows how one can write code against SQLite using <code class="literal">SQliteConnection</code>, <code class="literal">SQliteCommand</code> and <code class="literal">SQliteDataReader</code>&#160;and so on. Similar code can be written for SQL Server, MySQL and Oracle:</p>
          <pre class="programlisting">    public static void TestAdoNetSpecificInterface() 
    { 
      string connectionString = @"Data Source=./Logstorage.db"; 
      //----- Create a Connection Object 
      //----- and open it 
      SQLiteConnection dbcon= 
        new SQLiteConnection(connectionString); 
      dbcon.Open(); 
      //----------- Create a Command Object 
      //----------- to issue SQL Query 
      SQLiteCommand dbcmd = dbcon.CreateCommand(); 
      string sql = "SELECT * from logs"; 
      dbcmd.CommandText = sql; 
 
      //----------- Create a Reader Object  
      //----------- And Iterate through it 
      SQLiteDataReader reader = dbcmd.ExecuteReader(); 
      while (reader.Read()) 
      { 
        string logentry = reader.GetString(0); 
        Console.WriteLine(logentry); 
      } 
      // clean up 
      reader.Close(); 
      reader = null; 
      dbcmd.Dispose(); 
      dbcmd = null; 
      dbcon.Close(); 
      dbcon = null; 
    } 
</pre>
          <p>The above code snippet leverages the concrete classes provided. If we want to write code in a generic manner, we can program against the interfaces like <code class="literal">IDbConnection</code>, <code class="literal">IDbCommand</code> and <code class="literal">IDbDataReader</code> etc. The following code snippet demonstrates the technique:</p>
          <pre class="programlisting">    public static void TestAdoNetWithGenericInterface() 
    { 
      string connectionString = @"Data Source=./Logstorage.db"; 
      //------ Open a connection and assign the connection object  
      //------ to the IDbconnection interface. SQliteConnection, 
      //------ OracleConnection,SQLConnection etc. implements the  
      //------ IDbConnection Interface 
      IDbConnection dbcon 
        = (IDbConnection)new SQLiteConnection(connectionString); 
      dbcon.Open(); 
      //------------ IDbCommand is the interface for  
      //------------ Command Object . Every ADO.net  
      //------------ Interface (for Oracle,SQL server etc) 
      //------------ supports it  
      IDbCommand dbcmd = dbcon.CreateCommand(); 
      string sql = "SELECT * from logs"; 
      dbcmd.CommandText = sql; 
      //------- Create a Data Reader and Assign  
      //------- it to IDataReader Interface 
      IDataReader reader = dbcmd.ExecuteReader(); 
      while (reader.Read()) 
      { 
        string logentry = reader.GetString(0); 
        Console.WriteLine(logentry); 
      } 
      // clean up 
      reader.Close(); 
      reader = null; 
      dbcmd.Dispose(); 
      dbcmd = null; 
      dbcon.Close(); 
      dbcon = null; 
    } 
</pre>
        </div>
        <div class="section" title="The abstract factory pattern and object instantiation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec23"></a>The abstract factory pattern and object instantiation</h2>
              </div>
            </div>
          </div>
          <p>In our case, the abstract factory pattern is pertinent, as we are supposed to create a set of related classes based on the ADO.NET defined interfaces. For this very purpose, we will define an abstract class with the following signature:</p>
          <pre class="programlisting">    public abstract class DbAbstractFactory 
    { 
      public abstract IDbConnection CreateConnection(string connstr); 
      public abstract IDbCommand CreateCommand(IDbConnection con,    
      string cmd); 
      public abstract IDbDataAdapter CreateDbAdapter(IDbCommand cmd); 
      public abstract IDataReader CreateDataReader(IDbCommand cmd); 
    } 
</pre>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_04_01.jpg" alt="The abstract factory pattern and object instantiation"/>
          </div>
          <p>
</p>
          <p>In the preceding interface, we have methods to create connection object, command object, data adapter object, and data reader object. These classes are related, and concrete classes are for each of the database offerings. The concrete classes make calls to the corresponding ADO.NET driver.</p>
        </div>
        <div class="section" title="The SQL server implementation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec24"></a>The SQL server implementation</h2>
              </div>
            </div>
          </div>
          <p>The SQL Server implementation of abstract factory uses the default provider given by Microsoft Corporation. We need to include the <code class="literal">System.Data.SqlClient</code> namespace in our projects to utilize the objects in the provider namespace. Though the code given warrants more robust and defensive programming practices mandated for an industrial strength implementation, it provides clarity and is a good template for such an implementation:</p>
          <pre class="programlisting">    [Serializable()] 
    public class SQLServerDbFactory : DbAbstractFactory,ISerializable 
    { 
      private string drivertype { get; set; } 
      public SQLServerDbFactory() { this.drivertype = null; } 
      //------------------ Create a Connection Object 
      //------------------ returns a reference to  
      //------------------- a IDbConnection Interface 
      public override IDbConnection CreateConnection(string connstr) 
      { 
        if (connstr == null || connstr.Length == 0) 
          return null; 
        return new SqlConnection(connstr); 
      } 
      public override IDbCommand CreateCommand(IDbConnection con,    
      string cmd) 
      { 
        if (con == null || cmd == null || cmd.Length == 0) 
        return null; 
        if (con is SqlConnection) 
        return new SqlCommand(cmd, 
        (SqlConnection)con); 
        return null; 
      } 
      public override IDbDataAdapter CreateDbAdapter(IDbCommand cmd) 
      { 
        if (cmd == null) { return null; } 
        if (cmd is SqlCommand) 
        return new 
        SqlDataAdapter((SqlCommand)cmd); 
        return null; 
      } 
      public override IDataReader CreateDataReader(IDbCommand cmd) 
      { 
        if (cmd == null) { return null; } 
        if (cmd is SqlCommand) 
          return (SqlDataReader)cmd.ExecuteReader(); 
        return null; 
      } 
      public void GetObjectData(SerializationInfo info,  
      StreamingContext ctxt) 
      { 
      } 
      protected SQLServerDbFactory(SerializationInfo info,  
      StreamingContext context) 
      { 
      } 
    } 
</pre>
        </div>
        <div class="section" title="The SQLite implementation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec25"></a>The SQLite implementation</h2>
              </div>
            </div>
          </div>
          <p>The SQLite implementation uses the ADO.NET provider maintained by the SQLite implementation team. To include that, we need to download assemblies from the <a class="ulink" href="https://system.data.sqlite.org/">https://system.data.sqlite.org</a> site. We need to also include <code class="literal">sqlite3.dll</code> available on the SQLite site.</p>
          <p>You could also use nuget to install it via the Package Manager Console as <code class="literal">PM&gt; Install-Package System.Data.SQLite</code>:</p>
          <pre class="programlisting">    [Serializable()] 
    public class SQLiteDbFactory : DbAbstractFactory,ISerializable 
    { 
      private string drivertype { get; set; } 
      public SQLiteDbFactory() { this.drivertype = null; } 
      public override IDbConnection CreateConnection(string connstr) 
      { 
        if (connstr == null || connstr.Length == 0) 
        return null; 
        return new SQLiteConnection(connstr); 
      } 
 
      public override IDbCommand CreateCommand(IDbConnection    
      con,string cmd) 
      { 
        if (con == null || cmd == null || cmd.Length == 0) 
        return null; 
        if (con is SQLiteConnection ) 
        return  new SQLiteCommand(cmd,  
        (SQLiteConnection)con); 
        return null; 
      } 
 
      public override IDbDataAdapter CreateDbAdapter(IDbCommand cmd) 
      { 
        if (cmd == null) { return null; } 
        if (cmd is SQLiteCommand) 
        return new  
        SQLiteDataAdapter((SQLiteCommand)cmd); 
        return null; 
      } 
 
      public override IDataReader CreateDataReader(IDbCommand cmd) 
      { 
        if (cmd == null) { return null; } 
        if (cmd is SQLiteCommand) 
        return (SQLiteDataReader)cmd.ExecuteReader(); 
        return null; 
      } 
 
      public void GetObjectData(SerializationInfo info,  
      StreamingContext ctxt) 
      { 
      } 
 
      protected SQLiteDbFactory(SerializationInfo info,  
      StreamingContext context) 
      { 
      } 
    } 
</pre>
        </div>
        <div class="section" title="The Oracle and ODBC implementation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec26"></a>The Oracle and ODBC implementation</h2>
              </div>
            </div>
          </div>
          <p>Since Microsoft has deprecated the <code class="literal">System.Data.OracleClient</code> interface, we need to download ADO.NET providers from the Oracle Corporation site. Incorporating Oracle into the mix is similar to the way we did for SQL Server and SQLite. Since Oracle supports ODBC, we use an ODBC ADO.NET provider through the <code class="literal">System.Data.Oledb</code> namespace to interact with the other databases. The implementation is available as part of the source code downloads.</p>
          <p>The following diagram illustrates the abstract factories in action (though only one has been labeled):</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_04_02.jpg" alt="The Oracle and ODBC implementation"/>
          </div>
          <p>
</p>
        </div>
        <div class="section" title="The adapter pattern powered API">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec27"></a>The adapter pattern powered API</h2>
              </div>
            </div>
          </div>
          <p>The GOF Adapter pattern is useful for us in this context to provide a unified programming model for the consumers of the sub system.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note22"></a>Note</h3>
              <p>The Adapter pattern is a structural pattern which works as a bridge between different interfaces or different implementations of an interface. In our case, we will use the adapter pattern as a bridge between application developers and various implementations of <code class="literal">DbAstractFactory</code>.</p>
            </div>
          </div>
          <p>We need to create an <span class="strong"><strong>Application Program Interface</strong></span> (<span class="strong"><strong>API</strong></span>) for the application software developer to leverage different implementations based on a configuration entry. We will create a C# interface, which an adapter class needs to implement, to act as an API. At this point in time, we have only one instance of the adapter class. In future, we can have adapters for different scenarios:</p>
          <pre class="programlisting">    public interface IDbEngineAdapter 
    { 
      bool Open(); 
      DataSet Execute(string SQL); 
      IDataReader ExecuteQuery(string SQL); 
      bool ExecuteNonQuery(string SQL);     
      Boolean Close(); 
    } 
</pre>
        </div>
        <div class="section" title="The adapter class Implementation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec28"></a>The adapter class Implementation</h2>
              </div>
            </div>
          </div>
          <p>We will implement an adapter class which will help us to seamlessly integrate multiple database engines with our application. For implementing the adapter class, we will leverage the object factory (<code class="literal">ObjectFactory</code>) implementation from the previous chapter:</p>
          <pre class="programlisting">    public class DbEngineAdapter : IDbEngineAdapter 
    { 
      static  ObjectFactory of = new ObjectFactory("DbDrivers.xml"); 
      private IDbConnection _con = null; 
      private IDbCommand _cmd = null; 
      private DbAbastractFactory df = null; 
      private string _constr; 
      private string _driver; 
</pre>
          <p>We leverage the factory method infrastructure created in <a class="link" href="dn-dsnptn_ch03.html" title="Chapter&#160;3.&#160;A Logging Library">Chapter 3</a>, <span class="emphasis"><em>A Logging Library</em></span> to help instantiate the proper concrete implementation of <code class="literal">DbAstractFactory</code>. The <code class="literal">DbDrivers.xml</code> configuration file contains the necessary information to instantiate the concrete classes:</p>
          <pre class="programlisting">    public DbEngineAdapter(string constr, string driver) 
    { 
      _constr = constr; 
      _driver = driver; 
      //----- Instantiate the correct concrete class 
      //----- based on the driver 
      df = (DbAbastractFactory)of.Get(driver, "prototype"); 
    } 
</pre>
          <p>The constructor takes two parameters, that is, connection string and driver name. Using the driver name as the key, the appropriate implementation of ADO.NET will be instantiated:</p>
          <pre class="programlisting">    public bool Open() 
    { 
      try 
      { 
        if (_con != null || df == null || _constr == null) 
        { 
          return false; 
        } 
        //------ Create Connection Object  
        _con = df.CreateConnection(_constr); 
        if (_con == null) 
        return false; 
        _con.Open(); 
        return true; 
      } 
      catch (Exception e) 
      { 
        e.ToString(); 
        return false; 
      } 
    } 
</pre>
          <p>The <code class="literal">Open</code> method creates the connection object through the abstract factory concrete implementation. Once the connection object has been created, the ADO.NET connection is opened. The application developer should then make a call to <code class="literal">Open</code> method of the current class before calling any other method:</p>
          <pre class="programlisting">    public DataSet Execute(string SQL) 
    { 
      try 
      { 
        if (_con == null || df == null || _cmd != null)  
        {  
          return null;  
        } 
        _cmd = df.CreateCommand(_con, SQL); 
        IDbDataAdapter da = df.CreateDbAdapter(_cmd); 
        if (da == null) { return null; } 
        DataSet ds = new DataSet(); 
        da.Fill(ds); 
        return ds; 
      } 
      catch (Exception e) 
      { 
        e.ToString(); 
        return null; 
      } 
    } 
</pre>
          <p>The <code class="literal">Execute</code> method helps one to dispatch an SQL string to the selected database engine, and returns a dataset. This method is also used for disconnected access where an application wants to retrieve a small set of data to be populated in a user interface:</p>
          <pre class="programlisting">    public IDataReader ExecuteQuery(string SQL) 
    { 
      try 
      { 
        if (_con == null || df == null || _cmd != null) { return      
        null;} 
        _cmd = df.CreateCommand(_con, SQL); 
        if (_cmd == null) { return null; } 
        IDataReader rs = df.CreateDataReader(_cmd); 
        return rs; 
      } 
      catch (Exception e) 
      { 
        e.ToString(); 
        return null; 
      } 
    } 
</pre>
          <p>The <code class="literal">ExecuteQuery</code> method helps one to dispatch an SQL query to a database, and retrieve a data reader object which will help one to navigate one record at a time. This is called cursor-based access, and is suitable for queries which return a large dataset:</p>
          <pre class="programlisting">    public bool ExecuteNonQuery(string SQL) 
    { 
      try 
      { 
        if (_con == null || df == null || _cmd != null)  
        return false;  
        _cmd = df.CreateCommand(_con,SQL); 
        if (_cmd == null) { return false; } 
        _cmd.ExecuteNonQuery(); 
        return true; 
      } 
      catch (Exception e) 
      { 
        e.ToString(); 
        return false; 
      } 
    } 
</pre>
          <p>The <code class="literal">ExecuteNonQuery</code> method is meant to insert, update, or delete records from the table. It does not return any value. In other words, the method is called for mutable operations on a relational database:</p>
          <pre class="programlisting">    public Boolean Close() 
    { 
      if (_con != null) 
      { 
        _con.Close(); 
        _con = null; 
        return true; 
      } 
      return false; 
    } 
  }</pre>
          <p>The <code class="literal">Close</code> method, as indicated, closes the database connection. The adapter class can be instantiated inside the application code using the following schema. All we need is a connection string and a driver name (<code class="literal">SQLITE</code>, <code class="literal">SQLSERVER</code>, and so on) to instantiate the object. Once we have instantiated the object, we can dispatch an arbitrary query against the chosen database engine as indicated in the following code:</p>
          <pre class="programlisting">    DbEngineAdapter db =  
    new DbEngineAdapter(connstr,driver); 
    if (db.Open()) 
    { 
      bool result = db.ExecuteNonQuery(query); 
    } 
    db.Close(); 
</pre>
        </div>
        <div class="section" title="The adapter configuration">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec29"></a>The adapter configuration</h2>
              </div>
            </div>
          </div>
          <p>The drivers for the respective database engines are configured via an XML file (<code class="literal">DbDrivers.xml</code>) as follows:</p>
          <pre class="programlisting">    &lt;?xml version="1.0"?&gt; 
    &lt;entries&gt; 
      &lt;entry key ="SQLITE" value="Chapter4_Example.SQLiteDbFactory"/&gt; 
      &lt;entry key="SQLSERVER"      
      value="Chapter4_Exanple.SQLServerDbFactory"/&gt; 
      &lt;entry key="NULL" value ="Chapter4_Example.NULLDbFactory"/&gt; 
    &lt;/entries&gt; 
</pre>
          <p>When we want to target a new database, we need to create a concrete class which implements the abstract factory interface, and add an entry to this configuration file.</p>
        </div>
        <div class="section" title="The client program">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch04lvl2sec30"></a>The client program</h2>
              </div>
            </div>
          </div>
          <p>We can write a client program to test this logic. The code for inserting an entry to a database of your choice is given next. We have chosen SQLite initially for the sake of simplicity. Since SQLite is a server-less database engine, we can embed an SQLite DB as part of our project:</p>
          <pre class="programlisting">    static void TestInsert(string connstr, string driver) 
    { 
      DbEngineAdapter db =  
      new DbEngineAdapter(connstr,driver); 
      //----- a Test Log Entry 
      string test = "Log value is " + Math.PI * 1999; 
      if (db.Open()) 
      { 
        string query = "INSERT INTO logs VALUES('" + 
        test + "');"; 
        bool result = db.ExecuteNonQuery(query); 
      } 
      db.Close(); 
      return; 
    } 
</pre>
          <p>To retrieve data from a table, we can use either the disconnected recordset model or cursor model. When we are dealing with large datasets, especially for reports, using the cursor model is preferred. For scenarios where we need to edit a small set of data through some control, a disconnected set is preferred. The following code demonstrates how one can use the disconnected recordset for retrieving the data:</p>
          <pre class="programlisting">    static void TestDataSet(string connstr, string driver) 
    { 
      IDbEngineAdapter db = 
      new DbEngineAdapter(connstr,driver); 
      if (db.Open()) 
      { 
        string query = "SELECT * from logs"; 
        DataSet ds = db.Execute(query); 
        DataTable dt = ds.Tables[0]; 
        int i = 0; 
        int max = dt.Rows.Count; 
        while (i &lt; max) 
        { 
          DataRow dr = dt.Rows[i]; 
          Console.WriteLine(dr[0]); 
          i++; 
        } 
      } 
      db.Close(); 
      return; 
    } 
</pre>
          <p>The <code class="literal">DataReader</code> interface of ADO.NET is meant for cursor-based access to the database. This helps one to iterate through the data which satisfies some criteria. Reporting applications are a typical use case for cursor-based access:</p>
          <pre class="programlisting">    static void TestDataReader(string connstr, string driver) 
    { 
      IDbEngineAdapter db = 
      new DbEngineAdapter(connstr,driver); 
      string query = "select * from logs"; 
      if (db.Open()) 
      { 
        IDataReader reader = db.ExecuteQuery(query); 
        while(reader.Read()) 
        { 
          Console.WriteLine(reader.GetString(1)); 
        } 
      } 
      db.Close(); 
    } 
</pre>
          <p>The <code class="literal">Main</code> program which invokes these helper routines is given next. The initial code snippet shows how to use SQLite as a target database:</p>
          <pre class="programlisting">    static void Main(string[] args) 
    { 
      TestInsert(@"Data Source=./Logstorage.db", "SQLITE"); 
      TestDataSet(@"Data Source=./Logstorage.db", "SQLITE"); 
      TestDataReader(@"Data Source=./Logstorage.db", "SQLITE"); 
    } 
</pre>
          <p>To use the SQL Server, one needs to make changes to the connection string. Since the connection string is specific to the SQL Server installation (which a reader will have), the general scheme of invoking the program is the following:</p>
          <pre class="programlisting">    static void Main(string[] args) 
    { 
      TestInsert(@"sqlserverconnstring", "SQLSERVER"); 
      TestDataSet(@"sqlserverconnstring", "SQLSERVER"); 
      TestDataReader(@"sqlserverconnstring", "SQLSERVER"); 
    } 
</pre>
          <p>The following UML diagram illustrates the key set of patterns in action for the <span class="strong"><strong>Database Access Library</strong></span> (<span class="strong"><strong>DAL</strong></span>) API that we have built:</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_04_03-1.jpg" alt="The client program"/>
          </div>
          <p>
</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec28"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we created a reusable DAL to target different relational database offerings available for persistence. The library leverages the Microsoft ADO.NET programming model to implement database-agnostic persistence. In the process, you learned about the abstract factory pattern, adapter pattern, and revisited factory method pattern. You also understood the difference between the factory method and the abstract factory pattern. In the next chapter, we will write a document object library which will help one save data contents to different formats like PDF, SVG, and HTML. In that process, you will learn about the composite design pattern and visitor pattern.</p>
      </div>
    </div>
</body>
</html>