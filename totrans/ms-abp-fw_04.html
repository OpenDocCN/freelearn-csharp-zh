<html><head></head><body>
		<div><h1 id="_idParaDest-45"><em class="italic"><a id="_idTextAnchor044"/>Chapter 3</em>: Step-By-Step Application Development</h1>
			<p>This chapter introduces the fundamentals of ABP Framework by building an example application. The example application is used to manage products on a typical <strong class="bold">CRUD</strong> page (note that a CRUD page is used to <strong class="bold">Create</strong>, <strong class="bold">Read</strong> (view), <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> entities).</p>
			<p>The example presented in this chapter is more advanced than a simple CRUD page. It implements many aspects of application development with production quality. By the end of this chapter, you will understand the basics, and you will be ready to start development with ABP Framework.</p>
			<p>I will proceed, step by step, in the order of building a real-world project. This chapter consists of the following topics; each represents a step in this process:</p>
			<ul>
				<li>Creating the solution</li>
				<li>Defining the domain objects</li>
				<li><strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) Core and database mappings</li>
				<li>Listing the product data</li>
				<li>Creating products</li>
				<li>Editing products</li>
				<li>Deleting products<p class="callout-heading">User Interface (UI) and Database Preference</p><p class="callout">I prefer <strong class="bold">Razor Pages (MVC)</strong> as the UI framework and <strong class="bold">EF Core</strong> as the database provider. We will cover other UI frameworks and database providers in separate chapters.</p></li>
			</ul>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Technical requirements</h1>
			<p>We will be building an application, so you need to have .NET runtime, ABP CLI, and an IDE/editor installed to build ASP.NET Core projects.</p>
			<p>Please refer to <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>, to learn how to prepare your development environment, as well as create and run the solution.</p>
			<p>You can download the source code of the final application from the GitHub repository at <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Creating the solution</h1>
			<p>The first step is to <a id="_idIndexMarker094"/>create a solution for the product management application. If you've created the <em class="italic">ProductManagement</em> solution in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>, you can use it. Otherwise, create an empty folder in your computer, open a command-line terminal in this folder, and run the following <strong class="bold">ABP CLI</strong> command to create a new web application:</p>
			<pre>abp new ProductManagement -t app</pre>
			<p>Open the solution in your favorite IDE, create the database, and run the web project. If you have problems with running the solution, please refer to the previous chapter.</p>
			<p>Now we have a running solution. We can start the development by defining the domain objects of the solution.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Defining the domain objects</h1>
			<p>In this section, you <a id="_idIndexMarker095"/>will learn how to define entities with ABP Framework. The domain is simple for this application. We have <strong class="bold">Product</strong> and <strong class="bold">Category</strong> entities and a <strong class="bold">ProductStockState</strong> enum, as shown in <em class="italic">Figure 3.1</em>:</p>
			<div><div><img src="img/Figure_3.1_B17287.jpg" alt="Figure 3.1 – An example product management domain&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – An example product management domain</p>
			<p>Entities are defined in the <em class="italic">Domain Layer</em> of the <a id="_idIndexMarker096"/>solution, and the domain layer is split into two projects within the solution:</p>
			<ul>
				<li><strong class="bold">ProductManagement.Domain</strong> is used to define your entities, value objects, domain services, repository interfaces, and other core domain-related classes.</li>
				<li><strong class="bold">ProductManagement.Domain.Shared</strong> is used to define some primitive shared types. The types defined in this project are available to all other layers. Typically, we define enums and some constants here. </li>
			</ul>
			<p>So, we can start by creating the <code>Category</code> and <code>Product</code> entities and the <code>ProductStockState</code> enum. </p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Category</h2>
			<p>The <code>Category</code> entity<a id="_idIndexMarker097"/> is used to categorize the products. Create a <em class="italic">Categories</em> folder inside the <em class="italic">ProductManagement.Domain</em> project and a <code>Category</code> class inside i<a id="_idTextAnchor049"/>t:</p>
			<pre>using System;
using Volo.Abp.Domain.Entities.Auditing;
namespace ProductManagement.Categories
{
    public class Category : AuditedAggregateRoot&lt;Guid&gt;
    {
        public string Name { get; set; }
    }
}</pre>
			<p><code>Category</code> is a <a id="_idIndexMarker098"/>class is derived from <code>AuditedAggregateRoot&lt;Guid&gt;</code>. Here, <code>Guid</code> is the primary key (<code>Id</code>) type of the entity. You can use any type of primary key (such as <code>int</code>, <code>long</code>, or <code>string</code>) as long as your database management system supports it.</p>
			<p><code>AggregateRoot</code> is a special type of entity that is used to create the root entity type of an aggregate. An <a id="_idIndexMarker099"/>aggregate<a id="_idIndexMarker100"/> is a <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) concept that we will discuss in greater detail in the upcoming chapters. For now, consider that we inherit the main entities from this class.</p>
			<p>The <code>AuditedAggregateRoot</code> class adds some more properties to the <code>AggregateRoot</code> class: <code>CreationTime</code> as <code>DateTime</code>, <code>CreatorId</code> as <code>Guid</code>, <code>LastModificationTime</code> as <code>DateTime</code>, and <code>LastModifierId</code> as <code>Guid</code>. </p>
			<p>ABP automatically sets these properties. For example, when you insert an entity into the database, <code>CreationTime</code> is set to the current time, and <code>CreatorId</code> is automatically set to the <code>Id</code> property of the current user.</p>
			<p>The audit logging system and the base <code>Audited</code> classes will be covered in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p class="callout-heading">About Rich Domain Models</p>
			<p class="callout">In this chapter, I keep the entities simple, with public getters and setters. If you want to create rich domain models and apply DDD principles and other best practices, we will discuss them in upcoming chapters.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>ProductStockState</h2>
			<p><code>ProductStockState</code> is a<a id="_idIndexMarker101"/> simple enum to set and track the availability of the product in stock.</p>
			<p>Create a <em class="italic">Products</em> folder inside the <em class="italic">ProductManagement.Domain.Shared</em> project and a <code>ProductStockState</code> enum insi<a id="_idTextAnchor051"/>de it:</p>
			<pre>namespace ProductManagement.Products
{
    public enum ProductStockState : byte
    {
        PreOrder,
        InStock,
        NotAvailable,
        Stopped
    }
}</pre>
			<p>We define this <code>enum</code> in the <code>ProductManagement.Domain.Shared</code> project since we will reuse it in the <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>) and the<a id="_idIndexMarker102"/> UI layer.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Product</h2>
			<p>The <code>Product</code> class<a id="_idIndexMarker103"/> represents a real product. I intentionally added different types of properties to show their usages. Create a <em class="italic">Products</em> folder inside the <em class="italic">ProductManagement.Domain</em> project and a <code>Product</code> class in<a id="_idTextAnchor053"/>side it:</p>
			<pre>using System;
using Volo.Abp.Domain.Entities.Auditing;
using ProductManagement.Categories;
namespace ProductManagement.Products
{
    public class Product : FullAuditedAggregateRoot&lt;Guid&gt;
    {
        public Category Category { get; set; }
        public Guid CategoryId { get; set; }
        public string Name { get; set; }
        public float Price { get; set; }
        public bool IsFreeCargo { get; set; }
        public DateTime ReleaseDate { get; set; }
        public ProductStockState StockState { get; set; }
    }
}</pre>
			<p>This time, I<a id="_idIndexMarker104"/> inherited from <code>FullAuditedAggregateRoot</code>, which adds <code>IsDeleted</code> as <code>bool</code>, <code>DeletionTime</code> as <code>DateTime</code>, and <code>DeleterId</code> as <code>Guid</code> properties in addition to the <code>AuditedAggregateRoot</code> class used for the <code>Category</code> class.</p>
			<p><code>FullAuditedAggregateRoot</code> implements the <code>ISoftDelete</code> interface, which makes the <a id="_idIndexMarker105"/>entity <strong class="bold">Soft-Delete</strong>. That means it is never deleted from the database but just <em class="italic">marked as deleted</em>. ABP automatically handles all the Soft-Delete logic. You delete the entity as you normally do, but it is not actually deleted. The next time you query, deleted entities are automatically filtered, and you don't get them in the query result unless you intentionally request them. We will return to that feature in the <em class="italic">Using the data filtering system</em> section of <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p class="callout-heading">About the Navigation Properties</p>
			<p class="callout">In this example, <code>Product.Category</code> is a navigation property<a id="_idIndexMarker106"/> for the <code>Category</code> entity. If you use MongoDB or want to implement DDD truly, you should not add navigation properties to other aggregates. However, for relational databases, it works perfectly and provides flexibility to our code. We will discuss alternative approaches in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.</p>
			<p>The new files in the solution should look like <em class="italic">Figure 3.2</em>:</p>
			<div><div><img src="img/Figure_3.2_B17287.jpg" alt="Figure 3.2 – Adding domain objects to the solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Adding domain objects to the solution</p>
			<p>We've created the domain objects. In addition, we will create a few <code>const</code> values to be used later in the application.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>Constants</h2>
			<p>We need to define constant<a id="_idIndexMarker107"/> values for the properties of the entities. We will then use them in the input validation and database mapping phase.</p>
			<p>First, create a <em class="italic">Categories</em> folder inside the <em class="italic">ProductManagement.Domain.Shared</em> project and add a <code>CategoryConsts</code> class<a id="_idTextAnchor055"/> inside it:</p>
			<pre>namespace ProductManagement.Categories
{
    public static class CategoryConsts
    {
        public const int MaxNameLength = 128;
    }
}</pre>
			<p>Here, the <code>MaxNameLength</code> value will be<a id="_idIndexMarker108"/> used to implement the constraint for the <code>Name</code> property of a <code>Category</code> instance.</p>
			<p>Then, create a <code>ProductConsts</code> class inside the <em class="italic">Products</em> folder of the <em class="italic">ProductManagement.Domain.Sha<a id="_idTextAnchor056"/>red</em> project:</p>
			<pre>namespace ProductManagement.Products
{
    public static class ProductConsts
    {
        public const int MaxNameLength = 128;
    }
}</pre>
			<p>The <code>MaxNameLength</code> value will be used to implement the constraint for a <code>Product</code> instance's <code>Name</code> property.</p>
			<p>The <em class="italic">ProductManagement.Domain.Shared</em> project should look similar to <em class="italic">Figure 3.3</em>:</p>
			<div><div><img src="img/Figure_3.3_B17287.jpg" alt="Figure 3.3 – Adding constant classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Adding constant classes</p>
			<p>Now that the domain layer has been completed, we can now configure the database mappings for EF Core.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor057"/>EF Core and database mappings</h1>
			<p>We are using <strong class="bold">EF Core</strong> in this <a id="_idIndexMarker109"/>application. EF Core is an <strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) provider<a id="_idIndexMarker110"/> provided by Microsoft. ORMs provide abstractions to make you feel like you are working with objects in your application code rather than the database tables. We will cover ABP's EF Core integration in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>. However, for now, let's focus on how we can use it practically.</p>
			<p>First, we will add entities to the <code>DbContext</code> class and define the mappings between entities and database tables. Then, we will use EF Core's <strong class="bold">Code First Migration</strong> approach<a id="_idIndexMarker111"/> to build the necessary code that creates the database tables. Following this, we will look at ABP's <strong class="bold">Data Seeding</strong> system<a id="_idIndexMarker112"/> to insert <a id="_idIndexMarker113"/>some initial data into the database. Finally, we will apply the migrations and seed data to the database to prepare it for the application.</p>
			<p>First, let's start by defining the <code>DbSet</code> properties for the entities.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor058"/>Adding entities to the DbContext class</h2>
			<p>EF's <code>DbContext</code> class<a id="_idIndexMarker114"/> is the main class that is used to define mappings between entities and database tables. Additionally, it is used to access the database and perform database<a id="_idIndexMarker115"/> operations for the related entities.</p>
			<p>Open the <code>ProductManagementDbContext</code> class in the <em class="italic">ProductManagement.EntityFrameworkCore</em> project, and add the following <code>DbSet</code> properties inside it (you will need to import the namespaces of the <code>Product</code> and <a id="_idTextAnchor059"/><code>Category</code> objects):</p>
			<pre>public DbSet&lt;Product&gt; Products { get; set; }
public DbSet&lt;Category&gt; Categories { get; set; }</pre>
			<p>Adding a <code>DbSet</code> property for an entity relates the entity with the <code>DbContext</code> class. Then, we can use that <code>DbContext</code> class to perform database operations for the entity. EF Core can make most of the mapping using conventions based on the property names and types. If you want to customize the default mapping configuration or perform additional configurations, you<a id="_idIndexMarker116"/> have two <a id="_idIndexMarker117"/>options: <strong class="bold">Data Annotations</strong> (attributes) and <strong class="bold">Fluent API</strong>.</p>
			<p>In the data annotation approach, you add attributes, such as <code>[Required]</code> and <code>[StringLength]</code>, to your entity properties. It is very practical and easy to use. It also makes it easier to understand when you read the source code of your entity.</p>
			<p>One problem<a id="_idIndexMarker118"/> with the data annotation attributes is that they are<a id="_idIndexMarker119"/> limited (compared to the Fluent API) and make your domain layer dependant on the EF Core NuGet package when you need to use EF Core's custom attributes, such as <code>[Index]</code> and <code>[Owned]</code>. If that's not a problem for you, you can use the data annotation attributes and combine them with the Fluent API where they are not sufficient.</p>
			<p>In this chapter, I will prefer the Fluent API approach, which keeps the entity cleaner and places all the ORM logic inside the infrastructure layer.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor060"/>Mapping entities to the database tables</h2>
			<p>The <code>ProductManagementDbContext</code> class (in the <em class="italic">ProductManagement.EntityFrameworkCore</em> project) contains an <code>OnModelCreating</code> method to configure mappings of the entities to the database tables. When you <a id="_idIndexMarker120"/>first create your solution, this method looks <a id="_idIndexMarker121"/>like the following:</p>
			<pre>protected override void OnModelCreating(ModelBuilder builder)
{
    base.OnModelCreating(builder);
    builder.ConfigurePermissionManagement();
    builder.ConfigureSettingManagement();
    builder.ConfigureIdentity();
    ...configuration of the other modules
    /* Configure your own tables/entities here */
}</pre>
			<p>Add the<a id="_idIndexMarker122"/> following code<a id="_idIndexMarker123"/> af<a id="_idTextAnchor061"/>ter the preceding comment:</p>
			<pre>builder.Entity&lt;Category&gt;(b =&gt;
{
      b.ToTable("Categories");
      b.Property(x =&gt; x.Name)
            .HasMaxLength(CategoryConsts.MaxNameLength)
            .IsRequired();
      b.HasIndex(x =&gt; x.Name);
});
builder.Entity&lt;Product&gt;(b =&gt;
{
      b.ToTable("Products");
      b.Property(x =&gt; x.Name)
            .HasMaxLength(ProductConsts.MaxNameLength)
            .IsRequired();
      b.HasOne(x =&gt; x.Category)
           .WithMany()
           .HasForeignKey(x =&gt; x.CategoryId)
           .OnDelete(DeleteBehavior.Restrict)
           .IsRequired();
b.HasIndex(x =&gt; x.Name).IsUnique();
});</pre>
			<p>This code<a id="_idIndexMarker124"/> part defines <a id="_idIndexMarker125"/>the <code>Category</code> and <code>Product</code> mapping configurations.</p>
			<p class="callout-heading">About Namespaces</p>
			<p class="callout">You might need to add <code>using</code> statements for the namespaces of the <code>Product</code> class, the <code>Category</code> class, and any other classes used in the code. If you have trouble, you can always refer to the source code in the GitHub repository that I've shared in the <em class="italic">Technical requirements</em> section of this chapter.</p>
			<p>The <code>Category</code> entity is mapped to the <em class="italic">Categories</em> database table. We use <code>CategoryConsts.MaxNameLength</code> that was defined before to set the maximum length of the <code>Name</code> field in the database. The <code>Name</code> field is also a <em class="italic">required</em> property. Finally, we define a <em class="italic">unique</em> database index for the <code>Name</code> property because it helps search categories by the <code>Name</code> field.</p>
			<p>The <code>Product</code> mapping is similar to the <code>Category</code> mapping. Additionally, it defines a relationship between the <code>Category</code> entity and the <code>Product</code> entity; a <code>Product</code> entity belongs to a <code>Category</code> entity, while a <code>Category</code> entity can have many related <code>Product</code> entities.</p>
			<p class="callout-heading">EF Core Fluent Mapping</p>
			<p class="callout">You can refer to the EF Core documentation to learn about all the details and other options for the Fluent Mapping API.</p>
			<p>The mapping <a id="_idIndexMarker126"/>configuration is complete. It is time to create a database <a id="_idIndexMarker127"/>migration to update the database schema for the newly added entities.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor062"/>The Add-Migration command</h2>
			<p>When you create a new<a id="_idIndexMarker128"/> entity or make changes to an existing entity, you should also create or alter the related table in the database. EF Core's <strong class="bold">Code First Migration</strong> system<a id="_idIndexMarker129"/> is a perfect way to keep the database schema aligned with the application code. Typically, you generate migrations and apply them to the database. A migration is an incremental schema change for the database. When you update the database, all the migrations are applied since the last update, and the database becomes aligned with the application code.</p>
			<p>There are two ways to generate a new migration.</p>
			<h3>With Visual Studio</h3>
			<p>If you <a id="_idIndexMarker130"/>are using<a id="_idIndexMarker131"/> Visual Studio, open <strong class="bold">Package Manager Console (PMC)</strong> from the <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <strong class="bold">Package Manager Console</strong> menu:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.4_B17287.jpg" alt="Figure 3.4 – Package Manager Console&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Package Manager Console</p>
			<p>Select the <em class="italic">ProductManagement.EntityFrameworkCore</em> project as the <strong class="bold">Default project</strong> type. Ensure that the <em class="italic">ProductManagement.Web</em> project is selected as the startup project. You can right-click on the <em class="italic">ProductManagement.Web</em> project and click on the <strong class="bold">Set as Startup Project</strong> action.</p>
			<p>Now, you can type the following command into the PMC to add a new migration class:</p>
			<pre>Add-Migration "Added_Categories_And_Products"</pre>
			<p>The output of this command should be similar to <em class="italic">Figure 3.5</em>:</p>
			<div><div><img src="img/Figure_3.5_B17287.jpg" alt="Figure 3.5 – Output of the Add-Migration command&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Output of the Add-Migration command</p>
			<p>If you get an<a id="_idIndexMarker132"/> error such as <em class="italic">No DbContext was found in assembly…</em>, be sure that you've set the <strong class="bold">Default project</strong> type to<a id="_idIndexMarker133"/> the <em class="italic">ProductManagement.EntityFrameworkCore</em> project.</p>
			<p>If everything goes well, a new migration class should be added inside the <em class="italic">Migrations</em> folder of the <em class="italic">ProductManagement.EntityFrameworkCore</em> project.</p>
			<h3>In the command line</h3>
			<p>If you are not using <a id="_idIndexMarker134"/>Visual Studio, you can use the EF Core <a id="_idIndexMarker135"/>command-line tools. If you haven't installed it yet, execute the following command in a command-line terminal:</p>
			<pre>dotnet tool install --global dotnet-ef</pre>
			<p>Now, open a command-line terminal in the root directory of the <em class="italic">ProductManagement.EntityFrameworkCore</em> project, and type in the following command:</p>
			<pre>dotnet ef migrations add "Added_Categories_And_Products"</pre>
			<p>A new migration class <a id="_idIndexMarker136"/>should be added inside the <em class="italic">Migrations</em> folder of the <em class="italic">ProductManagement.EntityFrameworkCore</em> project.</p>
			<p>Before applying the newly <a id="_idIndexMarker137"/>created migration to the database, I want to mention the data seeding feature of ABP Framework.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor063"/>Seeding data</h2>
			<p>The data seeding system<a id="_idIndexMarker138"/> is used to add some initial data when you migrate the database. For example, the identity module creates an admin user in the database with all permissions granted to log in to the application. </p>
			<p>While data seeding is not essential in our scenario, I want to add some example categories and products to the database to make it easier to develop and test the application.</p>
			<p class="callout-heading">About the EF Core Data Seeding</p>
			<p class="callout">This section uses ABP's <a id="_idIndexMarker139"/>data seed system, while EF Core has its own data seeding feature. The ABP data seed system allows you to inject runtime services and implement advanced logic in your data seed code, and it is suitable for development, test, and production environments. However, for simpler development and test scenarios, you can use EF Core's data seeding system. Please check the official documentation at <a href="https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding">https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding</a>.</p>
			<p>Create a <code>ProductManagementDataSeedContributor</code> class in the <em class="italic">Data</em> folder <a id="_idTextAnchor064"/>of the <em class="italic">ProductManagement.Domain</em> project:</p>
			<pre>using ProductManagement.Categories;
using ProductManagement.Products;
using System;
using System.Threading.Tasks;
using Volo.Abp.Data;
using Volo.Abp.DependencyInjection;
using Volo.Abp.Domain.Repositories;
namespace ProductManagement.Data
{
    public class ProductManagementDataSeedContributor :
           IDataSeedContributor, ITransientDependency
    {
        private readonly IRepository&lt;Category,                           Guid&gt;_categoryRepository;
        private readonly IRepository&lt;Product,                           Guid&gt;_productRepository;
        public ProductManagementDataSeedContributor(
            IRepository&lt;Category, Guid&gt; categoryRepository,
            IRepository&lt;Product, Guid&gt; productRepository)
        {
            _categoryRepository = categoryRepository;
            _productRepository = productRepository;
        }
        public async Task SeedAsync(DataSeedContext                     context)
        {
            /***** TODO: Seed initial data here *****/
        }
    }
}</pre>
			<p>This class implements the <code>IDataSeedContributor</code> interface. ABP automatically discovers and calls its <code>SeedAsync</code> method when you want to seed the database. You can implement constructor injection and use any service in your class (such as the repositories in this example).</p>
			<p>Then, write the <a id="_idIndexMarker140"/>fo<a id="_idTextAnchor065"/>llowing code inside the <code>SeedAsync</code> method:</p>
			<pre>if (await _categoryRepository.CountAsync() &gt; 0)
{
    return;
}
var monitors = new Category { Name = "Monitors" };
var printers = new Category { Name = "Printers" };
await _categoryRepository
    .InsertManyAsync(new[] { monitors, printers });
var monitor1 = new Product
{
    Category = monitors,
    Name = "XP VH240a 23.8-Inch Full HD 1080p IPS LED               Monitor",
    Price = 163,
    ReleaseDate = new DateTime(2019, 05, 24),
    StockState = ProductStockState.InStock
};
var monitor2 = new Product
{
    Category = monitors,
    Name = "Clips 328E1CA 32-Inch Curved Monitor, 4K UHD",
    Price = 349,
    IsFreeCargo = true,
    ReleaseDate = new DateTime(2022, 02, 01),
    StockState = ProductStockState.PreOrder
};
var printer1 = new Product
{
    Category = monitors,
    Name = "Acme Monochrome Laser Printer, Compact All-In           One",
    Price = 199,
    ReleaseDate = new DateTime(2020, 11, 16),
    StockState = ProductStockState.NotAvailable
};
await _productRepository
    .InsertManyAsync(new[] { monitor1, monitor2, printer1 });</pre>
			<p>We've created two categories with three products and inserted them into the database. This class is executed whenever you run the <em class="italic">DbMigrator</em> application (please refer to the following section). Additionally, we checked <code>if (await _categoryRepository.CountAsync() &gt; 0)</code> to prevent us from inserting the same data in every run.</p>
			<p>We are now ready to migrate the database, which will update the database schema and seed the initial data.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>Migrating the database</h2>
			<p>The ABP application startup<a id="_idIndexMarker141"/> template includes a <em class="italic">DbMigrator</em> console application that is pretty useful in development and production environments. When you run it, all pending migrations are applied in the database, and the data seeder classes are executed. It supports multi-tenant, multi-database scenarios, which is not possible if you use the standard <code>Update-Database</code> command. This application can be deployed and executed in the production environment, typically, as a stage of your <strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>) pipeline. Separating <a id="_idIndexMarker142"/>the migration from the main application is a good approach, as the main application doesn't require permission to alter the database schema in such cases. Also, you can get rid of any concurrency issues you might have if you apply migrations in your main application and run multiple instances of the application.</p>
			<p>Run the <em class="italic">ProductManagement.DbMigrator</em> application to migrate the database (that is, set it as the startup project, and hit <em class="italic">Ctrl</em> + <em class="italic">F5</em>). Once the application exits, you can check the database to see that the <em class="italic">Categories</em> and <em class="italic">Products</em> tables have the initial data inserted (if you are using Visual Studio, you can use <strong class="bold">SQL Server Object Explorer</strong> to connect to <strong class="bold">LocalDB</strong> and explore the databases).</p>
			<p>The EF Core configuration is complete, and the database is ready for development. We will continue by showing the product data on the UI.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor067"/>Listing the product data</h1>
			<p>I prefer to develop the application functionality feature by feature. This section will explain how to show a list of the products in a data table on the UI.</p>
			<p>We will <a id="_idIndexMarker143"/>begin by defining a <code>ProductDto</code>, for the <code>Product</code> entity. Then, we will create an application service method that returns a list of products to the presentation layer. Additionally, we will learn how to map the <code>Product</code> entity to <code>ProductDto</code> automatically.</p>
			<p>Before creating the UI, I will show you how to write an <strong class="bold">Automated Test</strong> for the application service. In this way, we will be sure that the application service is working properly before starting the UI development.</p>
			<p>Throughout the<a id="_idIndexMarker144"/> development, we will explore some benefits of ABP Framework, such as the automatic API controller and dynamic JavaScript Proxy systems.</p>
			<p>Finally, we will create a new page, add a data table inside it, get a list of the products from the server, and show it on the UI.</p>
			<p>In the next section, we will begin by creating a <code>ProductDto</code> class.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor068"/>The ProductDto class</h2>
			<p>DTOs are used to transfer data between the application and presentation layers. It is best practice to return DTOs to the presentation (UI) layer instead of the entities. DTOs allow you to expose data in a<a id="_idIndexMarker145"/> controlled way and abstract your entities from the presentation layer. Directly exposing entities to the presentation layer might cause serialization and security problems, too. We will discuss the benefits of using DTOs in <a href="B17287_11_Epub_AM.xhtml#_idTextAnchor340"><em class="italic">Chapter 11</em></a>, <em class="italic">DDD – The Application Layer</em>.</p>
			<p>DTOs are defined in the <em class="italic">Application.Contracts</em> project to make them available within the UI layer. So, we start by creating a <code>ProductDto</code> class inside the <em class="italic">Products</em> folder of the <em class="italic">Pr<a id="_idTextAnchor069"/>oductManagement.Application.Contracts</em> project:</p>
			<pre>using System;
using Volo.Abp.Application.Dtos;
namespace ProductManagement.Products
{
    public class ProductDto : AuditedEntityDto&lt;Guid&gt;
    {
        public Guid CategoryId { get; set; }
        public string CategoryName { get; set; }
        public string Name { get; set; }
        public float Price { get; set; }
        public bool IsFreeCargo { get; set; }
        public DateTime ReleaseDate { get; set; }
        public ProductStockState StockState { get; set; }
    }
}</pre>
			<p>The <code>ProductDto</code> class is <a id="_idIndexMarker146"/>a similar class to the <code>Product</code> entity with the following differences:</p>
			<ul>
				<li>It is derived from <code>AuditedEntityDto&lt;Guid&gt;</code>, which defines the <code>Id</code>, <code>CreationTime</code>, <code>CreatorId</code>, <code>LastModificationTime</code>, and <code>LastModifierId</code> properties (we don't need to delete auditing properties, such as <code>DeletionTime</code>, since the deleted entities are not read from the database).</li>
				<li>Instead of adding a navigation property to the <code>Category</code> entity, we used a <code>string</code> <code>CategoryName</code> property, which is enough to show on the UI.</li>
			</ul>
			<p>We will use the <code>ProductDto</code> class to return a list of products from the <code>IProductAppService</code> interface.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor070"/>IProductAppService</h2>
			<p><strong class="bold">Application Services</strong> implement <a id="_idIndexMarker147"/>the use <a id="_idIndexMarker148"/>cases of an application. The UI uses them to perform business logic on user interactions. Typically, an application service method gets and returns DTOs.</p>
			<p class="callout-heading">Application Services versus API Controllers</p>
			<p class="callout">You could compare application services with API controllers in an ASP.NET Core MVC application. While they have similarities for some use cases, application services are plain classes that better fit into DDD. They don't depend on a particular UI technology. In addition, ABP can automatically expose your application services as HTTP APIs, as we will discover in the <em class="italic">Auto API Controllers and the Swagger UI</em> section of this chapter.</p>
			<p>We define interfaces for application services in the <em class="italic">Application.Contracts</em> project of the solution. Create an <code>IProductAppService</code> interface inside the <em class="italic">Products</em> folder of the<a id="_idTextAnchor071"/> <em class="italic">ProductManagement.Application.Contracts</em> project:</p>
			<pre>using System.Threading.Tasks;
using Volo.Abp.Application.Dtos;
using Volo.Abp.Application.Services;
namespace ProductManagement.Products
{
    public interface IProductAppService :                           IApplicationService
    {
        Task&lt;PagedResultDto&lt;ProductDto&gt;&gt;
            GetListAsync(PagedAndSortedResultRequestDto                     input);
    }
}</pre>
			<p>You can see some <a id="_idIndexMarker149"/>predefined ABP types in the preceding code block:</p>
			<ul>
				<li><code>IProductAppService</code> is derived from the <code>IApplicationService</code> interface. In this way, ABP can recognize the application services.</li>
				<li>The <code>GetListAsync</code> method gets <code>PagedAndSortedResultRequestDto</code>, which is a standard DTO class of ABP Framework that defines the <code>MaxResultCount</code> (int), <code>SkipCount</code> (int), and <code>Sorting</code> (string) properties.</li>
				<li>The <code>GetListAsync</code> method returns <code>PagedResultDto&lt;ProductDto&gt;</code>, which contains a <code>TotalCount</code> (long) property and an <code>Items</code> collection of <code>ProductDto</code> objects. That is a convenient way of returning paged results with ABP Framework.</li>
			</ul>
			<p>You could use your own DTOs instead of these predefined DTO types. However, they are pretty helpful when you want to standardize some common patterns and use the same naming everywhere.</p>
			<p class="callout-heading">Asynchronous Methods</p>
			<p class="callout">It is a best practice to define all the application service methods as asynchronous. If you define synchronous application service methods, in some cases, certain ABP features (such as Unit of Work) might not work as expected.</p>
			<p>Now, we can implement the <code>IProductAppService</code> interface to perform the use case.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor072"/>ProductAppService</h2>
			<p>Create a <code>ProductAppService</code> class<a id="_idIndexMarker150"/> inside the <em class="italic">Products</em> f<a id="_idTextAnchor073"/>older of the <em class="italic">ProductManagement.Application</em> project:</p>
			<pre>using System;
u<a id="_idTextAnchor074"/>sing System.Collections.Generic;
using System.Linq;
using System.Linq.Dynamic.Core;
using System.Threading.Tasks;
using Volo.Abp.Application.Dtos;
using Volo.Abp.Domain.Repositories;
namespace ProductManagement.Products
{
    public class ProductAppService :
        ProductManagementAppService, IProductAppService
    {
        private readonly IRepository&lt;Product, Guid&gt;                     _productRepository;
        public ProductAppService(
            IRepository&lt;Product, Guid&gt; productRepository)
        {
            _productRepository = productRepository;
        }
        public async Task&lt;PagedResultDto&lt;ProductDto&gt;&gt;                   GetListAsync(
            PagedAndSortedResultRequestDto input)
        {
            /* TODO: Implementation */
        }
    }
}</pre>
			<p>The <code>ProductAppService</code> class is<a id="_idIndexMarker151"/> derived from <code>ProductManagementAppService</code>, which was defined in the startup template, and can be used as the base class for your application services. It implements the <code>IProductAppService</code> interface that was previously defined. It injects the <code>IRepository&lt;Product, Guid&gt;</code> service. This is called <a id="_idIndexMarker152"/>a <strong class="bold">Default Repository</strong>. A repository is a collection-like interface that allows you to perform operations on the database. ABP automatically provides default repository implementations for all aggregate root entities.</p>
			<p>We can implement the <code>GetLi<a id="_idTextAnchor075"/>stAsync</code> method, as shown in the following code block:</p>
			<pre>public async Task&lt;PagedResultDto&lt;ProductDto&gt;&gt; GetListAsync(
    PagedAndSortedResultRequestDto input)
{
    var queryable = await _productRepository
        .WithDetailsAsync(x =&gt; x.Category);
    queryable = queryable
        .Skip(input.SkipCount)
        .Take(input.MaxResultCount)
        .OrderBy(input.Sorting ?? nameof(Product.Name));
    var products = await                                             AsyncExecuter.ToListAsync(queryable);
    var count = await _productRepository.GetCountAsync();
    return new PagedResultDto&lt;ProductDto&gt;(
        count,
        ObjectMapper.Map&lt;List&lt;Product&gt;, List&lt;ProductDto&gt;&gt;                (products)
    );
}</pre>
			<p>Here, <code>_productRepository.WithDetailsAsync</code> returns an <code>IQueryable&lt;Product&gt;</code> object <a id="_idIndexMarker153"/>by including the categories (the <code>WithDetailsAsync</code> method is similar to EF Core's <code>Include</code> extension method, which loads the related data into the query). We can use the standard <code>Skip</code>, <code>Take</code>, and <code>OrderBy</code> on the queryable object.</p>
			<p>The <code>AsyncExecuter</code> service (which is pre-injected in the base class) is used to execute the <code>IQueryable</code> object to perform a database query asynchronously. This makes it possible to use the async LINQ extension methods without depending on the EF Core package in the application layer.</p>
			<p>Finally, we are using the <code>ObjectMapper</code> service (pre-injected in the base class) to map a list of <code>Product</code> (entity) objects to a <code>ProductDto</code> (DTO) object list. In the next section, we will explain how the object mapping is configured.</p>
			<p class="callout-heading">Repositories and Async Query Execution</p>
			<p class="callout">We will explore <code>IRepository</code> and <code>AsyncExecuter</code> in greater detail in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor076"/>Object to object mapping</h2>
			<p><code>ObjectMapper</code> (the <code>IObjectMapper</code> service) automates type conversions and uses the <strong class="bold">AutoMapper</strong> library<a id="_idIndexMarker155"/> by default. It requires you to define the mapping before <a id="_idIndexMarker156"/>using it. The startup template contains a profile class that you can create the mappings inside.</p>
			<p>Open the <code>ProductManagementApplicationAutoMapperProfile</code> class in the <em class="italic">ProductManage<a id="_idTextAnchor077"/>ment.Application</em> project, and change it to the following:</p>
			<pre>using AutoMapper;
using ProductManagement.Products;
namespace ProductManagement
{
    public class ProductManagementApplicationAutoMapperProfile
        : Profile
    {
        public ProductManagementApplicationAutoMapperProfile()
        {
            CreateMap&lt;Product, ProductDto&gt;();
        }
    }
}</pre>
			<p>Here, <code>CreateMap</code> defines the mapping. Then, you can automatically convert <code>Product</code> objects into <code>ProductDto</code> objects where you need them.</p>
			<p>One of the <a id="_idIndexMarker157"/>interesting AutoMapper features is <code>Product</code> class has a <code>Category</code> property, and the <code>Category</code> class has a <code>Name</code> property. So, if you want to access the category name of a product, you should use the <code>Product.Category.Name</code> expression. However, <code>ProductDto</code> has a direct <code>CategoryName</code> property that can be accessed using the <code>ProductDto.CategoryName</code> expression. AutoMapper automatically maps these expressions by flattening <code>Category.Name</code> into <code>CategoryName</code>.</p>
			<p>The application layer is complete. Before starting the UI, I want to show you how to write automated tests for the application layer.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor078"/>Testing the ProductAppService class</h2>
			<p>The startup template comes with the test infrastructure properly configured using the <strong class="bold">xUnit</strong>, <strong class="bold">Shouldly</strong>, and <strong class="bold">NSubstitute</strong> libraries. It uses the <em class="italic">SQLite in-memory</em> database to mock the database. A separate database is created for each test. It is seeded and destroyed at the end of the<a id="_idIndexMarker159"/> test. In this way, tests do not affect each other, and your real database remains untouched.</p>
			<p><a href="B17287_17_Epub_AM.xhtml#_idTextAnchor476"><em class="italic">Chapter 17</em></a>, <em class="italic">Building Automated Tests</em>, will explore all the details of testing. However, here, I want to show you how you can easily write some automated test code for the <code>GetListAsync</code> method of the <code>ProductAppService</code> class. It is good to write the test code for the application services before using them on the UI.</p>
			<p>Create a <em class="italic">Products</em> folder in the <em class="italic">ProductManagement.Application.Tests</em> pr<a id="_idTextAnchor079"/>oject, and create a <code>ProductAppService_Tests</code> class inside it:</p>
			<pre>using Shouldly;
using System.Threading.Tasks;
using Volo.Abp.Application.Dtos;
using Xunit;
namespace ProductManagement.Products
{
    public class ProductAppService_Tests
        : ProductManagementApplicationTestBase
    {
        private readonly IProductAppService                             _productAppService;
        public ProductAppService_Tests()
        {
            _productAppService =
                GetRequiredService&lt;IProductAppService&gt;();
        }
        /* TODO: Test methods */
    }
}</pre>
			<p>This class<a id="_idIndexMarker160"/> inherits from the <code>ProductManagementApplicationTestBase</code> class (which is included in your solution) that integrates ABP Framework and other infrastructure libraries and makes it possible to write our tests. Instead of constructor injection (which is not possible in tests), we use the <code>GetRequiredService</code> method to resolve dependencies in the test code.</p>
			<p>Now, we can write the first test method. Add t<a id="_idTextAnchor080"/>he following method inside the <code>ProductAppService_Tests</code> class:</p>
			<pre>[Fact]
public async Task Should_Get_Product_List()
{
    //Act
    var output = await _productAppService.GetListAsync(
        new PagedAndSortedResultRequestDto()
    );
    //Assert
    output.TotalCount.ShouldBe(3);
    output.Items.ShouldContain(
        x =&gt; x.Name.Contains("Acme Monochrome Laser                     Printer")
    );
}</pre>
			<p>This method <a id="_idIndexMarker161"/>calls the <code>GetListAsync</code> method and checks whether the result is correct. If you open the <strong class="bold">Test Explorer</strong> window (under the <strong class="bold">View</strong> | <strong class="bold">Test Explorer</strong> menu in Visual Studio), you can see the test method that we've added. <strong class="bold">Test Explorer</strong> is used for showing and running the tests in the solution:</p>
			<div><div><img src="img/Figure_3.6_B17287.jpg" alt="Figure 3.6 – The Test Explorer window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The Test Explorer window</p>
			<p>Run the test to <a id="_idIndexMarker162"/>check whether it is working as expected. If the <code>GetListAsync</code> method works properly, you will see a green icon on the left-hand side of the test method name, as shown in <em class="italic">Figure 3.6</em>. Unit and integration tests will be covered in <a href="B17287_17_Epub_AM.xhtml#_idTextAnchor476"><em class="italic">Chapter 17</em></a>, <em class="italic">Building Automated Tests</em>.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor081"/>Auto API Controllers and the Swagger UI</h2>
			<p><strong class="bold">Swagger</strong> is a popular <a id="_idIndexMarker163"/>tool in which to explore and test HTTP APIs. It comes preinstalled with the startup template.</p>
			<p>Run the <em class="italic">ProductManagement.Web</em> project to start the web application (set it as the startup project if not done so already, and hit <em class="italic">Ctrl</em> + <em class="italic">F5</em>). Once the application starts, enter the <code>/swagger</code> URL, as shown in <em class="italic">Figure 3.7</em>:</p>
			<div><div><img src="img/Figure_3.7_B17287.jpg" alt="Figure 3.7 – The Swagger UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The Swagger UI</p>
			<p>You will see a lot of API <a id="_idIndexMarker164"/>endpoints coming from the modules installed in the application. If you scroll down, you will see a <strong class="bold">Product</strong> endpoint, too. You can test it to get the list of products:</p>
			<div><div><img src="img/Figure_3.8_B17287.jpg" alt="Figure 3.8 – The Product endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – The Product endpoint</p>
			<p>We haven't created a <em class="italic">ProductController</em> endpoint yet. So, how is this endpoint available here? This is known as<a id="_idIndexMarker165"/> the <strong class="bold">Auto API Controller</strong> feature of ABP Framework. It automatically exposes your application services as HTTP APIs based on naming conventions and configurations. Typically, we don't write the controllers manually.</p>
			<p>The Auto API Controller feature will be covered in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>, in detail.</p>
			<p>So, we have the HTTP API to get the list of products. The next step is to consume this API from the client code.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor082"/>Dynamic JavaScript proxies</h2>
			<p>Typically, you call the<a id="_idIndexMarker166"/> HTTP API endpoints from your JavaScript code. ABP dynamically creates client-side proxies for all HTTP APIs. Then, you can use these dynamic JavaScript functions to consume your APIs from the client application.</p>
			<p>Run the <em class="italic">ProductManagement.Web</em> project again, and open the <strong class="bold">Developer Console</strong> of the browser while you are on the application's landing page. The developer console is available in any modern browser and is typically opened using the <em class="italic">F12</em> shortcut key (on Windows). It is used to explore, trace, and debug the application by developers.</p>
			<p>Open the <strong class="bold">Console</strong> tab, and type in the following JavaScript code:</p>
			<pre>productManagement.products.product.getList({}).then(function(result) {
    console.log(result);
});</pre>
			<p>Once you execute this code, a request is made to the server, and the returning result is logged in the <strong class="bold">Console</strong> tab, as shown in <em class="italic">Figure 3.9</em>:</p>
			<div><div><img src="img/Figure_3.9_B17287.jpg" alt="Figure 3.9 – Using the dynamic JavaScript proxies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Using the dynamic JavaScript proxies</p>
			<p>We can see<a id="_idIndexMarker167"/> that the product list is logged in the <strong class="bold">Console</strong> tab. That means we can easily consume server-side APIs from JavaScript code without having to deal with the low-level details.</p>
			<p>If you are wondering where that <code>getList</code> JavaScript is defined, you can check the <code>/Abp/ServiceProxyScript</code> endpoint in your application to see the JavaScript proxy functions dynamically created by ABP Framework.</p>
			<p>In the next section, we will create a <strong class="bold">Razor Page</strong> to show the table of products on the UI.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor083"/>Creating a products page</h2>
			<p>Razor Pages is the recommended<a id="_idIndexMarker168"/> way of creating a UI in the ASP.NET Core MVC framework.</p>
			<p>First, create a <em class="italic">Products</em> folder under the <em class="italic">Pages</em> folder of the <em class="italic">ProductManagement.Web</em> project. Then, add a new, empty razor page by right-clicking on the <em class="italic">Products</em> folder and then selecting <code>Index.cshtml</code>. <em class="italic">Figure 3.10</em> shows the location of the page that we've added:</p>
			<div><div><img src="img/Figure_3.10_B17287.jpg" alt="Figure 3.10 – Creating a Razor Page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Creating a Razor Page</p>
			<p>Edit<a id="_idTextAnchor084"/> the <code>Index.cshtml</code> content, as shown in the following code block:</p>
			<pre>@page
@using ProductManagement.Web.Pages.Products
@model IndexModel
&lt;h1&gt;Products Page&lt;/h1&gt;</pre>
			<p>Here, I've just<a id="_idIndexMarker169"/> placed an <code>h1</code> element as the page header. When we create a page, typically, we want to add an item to the main menu to open this page.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor085"/>Adding a new menu item</h2>
			<p>ABP provides a dynamic<a id="_idIndexMarker170"/> and modular menu system. Every module can add items to the main menu.</p>
			<p>Open the <code>ProductManagementMenuContributor</code> class in the <em class="italic">Menus</em> folder of the <em class="italic">ProductManagement.Web</em> project, and add t<a id="_idTextAnchor086"/>he following code at the end of the <code>ConfigureMainMenuAsync</code> method:</p>
			<pre>context.Menu.AddItem(
    new ApplicationMenuItem(
        "ProductManagement",
        l["Menu:ProductManagement"],
        icon: "fas fa-shopping-cart"
            ).AddItem(
        new ApplicationMenuItem(
            "ProductManagement.Products",
            l["Menu:Products"],
            url: "/Products"
        )
    )
);</pre>
			<p>This code adds a <em class="italic">Product Management</em> main menu item with the <em class="italic">Products</em> menu item inside it. It uses localization keys (with the <code>l["…"]</code> syntax) that we should define. Open the <code>en.json</code> file in the <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared</em> proje<a id="_idTextAnchor087"/>ct, and add the following entries to the end of the <code>texts</code> section:</p>
			<pre>"Menu:ProductManagement": "Product Management",
"Menu:Products": "Products"</pre>
			<p>Localization keys are arbitrary, which means you can use any string value as the localization key. I prefer to use the <code>Menu:</code> prefix for the localization keys of menu items, such as <code>Menu:Products</code>, in this example. We will return to the topic of localization in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p>Now, you can rerun the application and open the <em class="italic">Products</em> page using the new <em class="italic">Product Management</em> menu <a id="_idIndexMarker171"/>item, as shown in <em class="italic">Figure 3.11</em>:</p>
			<div><div><img src="img/Figure_3.11_B17287.jpg" alt="Figure 3.11 – The Products page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The Products page</p>
			<p>So, we've created a page and can open the page using the menu element. We are ready to create a data table to show the list of products.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor088"/>Creating the products data table</h2>
			<p>We will create a<a id="_idIndexMarker172"/> data table to show the list of products with paging and sorting. The ABP startup template comes with the <strong class="bold">Datatables.net</strong> JavaScript library preinstalled and configured. It is a flexible and feature-rich library to show tabular data.</p>
			<p>Open the <code>Index.cshtml</code> page (in th<a id="_idTextAnchor089"/>e <em class="italic">Pages/Products</em> folder), and change its contents to the following:</p>
			<pre>@page
@using ProductManagement.Web.Pages.Products
@using Microsoft.Extensions.Localization
@using ProductManagement.Localization
@model IndexModel
@inject IStringLocalizer&lt;ProductManagementResource&gt; L
@section scripts
{
    &lt;abp-script src="img/Index.cshtml.js" /&gt;
}
&lt;abp-card&gt;
    &lt;abp-card-header&gt;
        &lt;h2&gt;@L["Menu:Products"]&lt;/h2&gt;
    &lt;/abp-card-header&gt;
    &lt;abp-card-body&gt;
        &lt;abp-table id="ProductsTable" striped-rows="true" /&gt;
    &lt;/abp-card-body&gt;
&lt;/abp-card&gt;</pre>
			<p>Here, <code>abp-script</code> is an ABP tag helper for adding script files to the page with automatic bundling, minification, and versioning support. <code>abp-card</code> is another tag helper to render a <a id="_idIndexMarker173"/>card component in a type-safe and easy way (it renders a Bootstrap card).</p>
			<p>We could use the standard HTML tags. However, ABP tag helpers dramatically simplify UI creation in MVC/Razor Page applications. Additionally, they prevent errors with the help of IntelliSense and compile-time type checking. We will investigate tag helpers in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>Create a new JavaScript file, named <code>Index.cshtml.js</code> (you might prefer a different naming style, such as <code>index.js</code>; that's fine, as long as you use the same file name in the <code>abp-scri<a id="_idTextAnchor090"/>pt</code> tag), under the <em class="italic">Pages/Products</em> folder with the following content:</p>
			<pre>$(function () {
    var l = abp.localization.getResource('ProductManagement');
    var dataTable = $('#ProductsTable').DataTable(
        abp.libs.datatables.normalizeConfiguration({
            serverSide: true,
            paging: true,
            order: [[0, "asc"]],
            searching: false,
            scrollX: true,
            ajax: abp.libs.datatables.createAjax(
                productManagement.products.product.getList),
            columnDefs: [
                /* TODO: Column definitions */
            ]
        })
    );
});</pre>
			<p>ABP allows you to <a id="_idIndexMarker174"/>reuse the localization texts in your JavaScript code. In this way, you can define them on the server side and use them on both sides. <code>abp.localization.getResource</code> returns a function to localize the values.</p>
			<p>ABP simplifies the data table's library configuration and provides built-in integrations:</p>
			<ul>
				<li><code>abp.libs.datatables.normalizeConfiguration</code> is a helper function defined by ABP Framework. It simplifies the data table's configuration by providing conventional default values for missing options.</li>
				<li><code>abp.libs.datatables.createAjax</code> is another helper function that adapts ABP's dynamic JavaScript client proxies to the data table's parameter format.</li>
				<li><code>productManagement.products.product.getList</code> is the dynamic JavaScript proxy function introduced earli<a id="_idTextAnchor091"/>er.</li>
			</ul>
			<p>Define the columns <a id="_idIndexMarker175"/>of the data table inside the <code>columnDefs</code> array:</p>
			<pre>{
    title: l('Name'),
    data: "name"
},
{
    title: l('CategoryName'),
    data: "categoryName",
    orderable: false
},
{
    title: l('Price'),
    data: "price"
},
{
    title: l('StockState'),
    data: "stockState",
    render: function (data) {
        return l('Enum:StockState:' + data);
    }
},
{
    title: l('CreationTime'),
    data: "creationTime",
    dataFormat: 'date'
}</pre>
			<p>Typically, a column definition has a <code>title</code> field (display name) and a <code>data</code> field. The data field matches the property names in the <code>ProductDto</code> class, formatted as <strong class="bold">camelCase</strong> (a naming style in which the first letter of each word is capitalized, except for the first word; it is <a id="_idIndexMarker176"/>commonly used in the JavaScript language).</p>
			<p>The <code>render</code> option can be <a id="_idIndexMarker177"/>used to finely control how to show the column data. We are providing a function to customize the rendering of the stock state column.</p>
			<p>On this page, we've used some localization keys. We should define them in the localization resource. Open the <code>en.json</code> file in the <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared<a id="_idTextAnchor092"/></em> project, and add the following entries at the end of the <code>texts</code> section:</p>
			<pre>"Name": "Name",
"CategoryName": "Category name",
"Price": "Price",
"StockState": "Stock state",
"Enum:StockState:0": "Pre-order",
"Enum:StockState:1": "In stock",
"Enum:StockState:2": "Not available",
"Enum:StockState:3": "Stopped",
"CreationTime": "Creation time"</pre>
			<p>You can run the web <a id="_idIndexMarker178"/>application again to see the product data table in action:</p>
			<div><div><img src="img/Figure_3.12_B17287.jpg" alt="Figure 3.12 – The Products data table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The Products data table</p>
			<p>We've created a fully working page that lists the products with paging and sorting support. In the next sections, we will add functionality to create, edit, and delete the products.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor093"/>Creating products</h1>
			<p>In this section, we will<a id="_idIndexMarker179"/> create the necessary functionality to add a new product. A product should have a category. So, we should select a category while adding a new product. We will define new application service methods to get categories and create products. In the UI section, we will use ABP's dynamic form feature to automatically generate the product creation form, based on a C# class.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor094"/>Application service contracts</h2>
			<p>L<a id="_idTextAnchor095"/>et's start by adding <a id="_idIndexMarker180"/>two new methods to the <code>IProductAppService</code> interface:</p>
			<pre>Task CreateAsync(CreateUpdateProductDto input);
Task&lt;ListResultDto&lt;CategoryLookupDto&gt;&gt; GetCategoriesAsync();</pre>
			<p>We will use the <code>GetCategoriesAsync</code> method to show a drop-down list of categories on product creation. We've introduced two new DTOs, and we should define them.</p>
			<p><code>CreateUpdateProductDto</code> is used to create and update products (we will reuse it in the <em class="italic">Editing products</em> section). Define it in t<a id="_idTextAnchor096"/>he <em class="italic">Products</em> folder of the <em class="italic">ProductManagement.Application.Contracts</em> project:</p>
			<pre>using System;
using System.ComponentModel.DataAnnotations;
namespace ProductManagement.Products
{
    public class CreateUpdateProductDto
    {
        public Guid CategoryId { get; set; }
        [Required]
        [StringLength(ProductConsts.MaxNameLength)]
        public string Name { get; set; }
        public float Price { get; set; }
        public bool IsFreeCargo { get; set; }
        public DateTime ReleaseDate { get; set; }
        public ProductStockState StockState { get; set; }
    }
}</pre>
			<p>Next, define<a id="_idIndexMarker181"/> a <code>CategoryLookupDto</code> class in the <em class="italic">Categories</em> folder of the <em class="italic">ProductManagement.Application.Contracts</em> project:</p>
			<pre>using System;
namespace <a id="_idTextAnchor097"/>ProductManagement.Categories
{
    public class CategoryLookupDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
    }
}</pre>
			<p>We've created the contracts, so now we can implement the contracts in the application layer.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor098"/>Application service implementation</h2>
			<p>Implement <a id="_idIndexMarker182"/>the <code>CreateAsync</code> and <code>GetCategoriesAsync</code> methods in <code>ProductAppService</code> (in the <em class="italic">P<a id="_idTextAnchor099"/>roductManagement.Application</em> project), as shown in the following code block:</p>
			<pre>public async Task CreateAsync(CreateUpdateProductDto input)
{
    await _productRepository.InsertAsync(
        ObjectMapper.Map&lt;CreateUpdateProductDto, Product&gt;                (input)
    );
}
public async Task&lt;ListResultDto&lt;CategoryLookupDto&gt;&gt;
       GetCategoriesAsync()
{
    var categories = await _categoryRepository.GetListAsync();
    return new ListResultDto&lt;CategoryLookupDto&gt;(
        ObjectMapper
        .Map&lt;List&lt;Category&gt;, List&lt;CategoryLookupDto&gt;&gt;                    (categories)
    );
}</pre>
			<p>Here, <code>_categoryRepository</code> is a type of <code>IRepository&lt;Category, Guid&gt;</code> service. You<a id="_idIndexMarker183"/> inject it just as you did for <code>_productRepository</code> earlier. I think the method implementations are pretty simple, and there is no need for additional explanation.</p>
			<p>We've used object mapping in two places, and now we have to define the mapping configuration. Open the <code>ProductManagementApplicationAutoMapperProfile.cs</code> f<a id="_idTextAnchor100"/>ile in the <em class="italic">ProductManagement.Application</em> project, and add the following code:</p>
			<pre>CreateMap&lt;CreateUpdateProductDto, Product&gt;();
CreateMap&lt;Category, CategoryLookupDto&gt;();</pre>
			<p>This code sets <a id="_idIndexMarker184"/>up the AutoMapper configuration for the object mapping.</p>
			<p class="callout-heading">Automated Tests</p>
			<p class="callout">I will not show any more automated tests in this chapter; however, I have added them to the solution. You can check the source code in the GitHub repository.</p>
			<p>Now, we can go and consume these methods from the UI layer.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor101"/>UI</h2>
			<p>Create a <a id="_idIndexMarker185"/>new <code>CreateProductModal.cshtml</code> Razor Page under the <em class="italic">Pages/Products</em> folder of the <em class="italic">ProductManagement.Web</em> project. Open the <code>CreateProductModal.cshtml.<a id="_idTextAnchor102"/>cs</code> file, and change the <code>CreateProductModalModel</code> class using the following code:</p>
			<pre>using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using ProductManagement.Products;
namespace ProductManagement.Web.Pages.Products
{
    Public class CreateProductModalModel:
        ProductManagementPageModel
    {
        [BindProperty]
        public CreateEditProductViewModel Product { get;                 set; }
        public SelectListItem[] Categories { get; set; }
        private readonly IProductAppService                             _productAppService;
        public CreateProductModalModel(
            IProductAppService productAppService)
        {
            _productAppService = productAppService;
        }
        public async Task OnGetAsync()
        {
            // TODO
        }
        public async Task&lt;IActionResult&gt; OnPostAsync()
        {
            // TODO
        }
    }
}</pre>
			<p>Here, <code>ProductManagementPageModel</code> is a base class defined in the startup template. You <a id="_idIndexMarker186"/>can inherit it to create <code>PageModel</code> classes. <code>Categories</code> will be used to show a list of the categories in a drop-down list. <code>[BindProperty]</code> is a standard ASP.NET Core attribute to bind the post data to the <code>Product</code> property on an HTTP Post request. We are injecting the <code>IProductAppService</code> interface to use the methods defined earlier.</p>
			<p>We've already used <code>CreateEditProductViewModel</code>, so we need to define it. Define it in the <a id="_idIndexMarker187"/>same folder as <code>CreateProductModal.cshtml</code>:</p>
			<pre>using ProductManagement.Products;
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Form;
namespace ProductManagement.Web.Pages.Products
{
    public class CreateEditProductViewModel
    {
        [SelectItems("Categories")]
        [DisplayName("Category")]
        public Guid CategoryId { get; set; }
        [Required]
        [StringLength(ProductConsts.MaxNameLength)]
        public string Name { get; set; }
        public float Price { get; set; }
        public bool IsFreeCargo { get; set; }
        [DataType(DataType.Date)]
        public DateTime ReleaseDate { get; set; }
        public ProductStockState StockState { get; set; }
    }
}</pre>
			<p><code>SelectItems</code> tells us that the <code>CategoryId</code> property will be selected from the <code>Categories</code> list. We <a id="_idIndexMarker188"/>will reuse this class in the edit modal dialog. That's why I named it <code>CreateEditProductViewModel</code>.</p>
			<p class="callout-heading">DTOs versus ViewModels</p>
			<p class="callout">It might seem unnecessary to define the view model (<code>CreateEditProductViewModel</code>) since it is very similar to the DTO (<code>CreateUpdateProductDto</code>). However, it has just a few more attributes. These attributes can be easily <a id="_idIndexMarker189"/>added to the DTO, and we can reuse the DTO on the view<a id="_idIndexMarker190"/> side. It is up to your design decision, and you can do it. However, I think it is better practice to separate each concern, considering these classes have different purposes and evolve in different directions over time. For example, the <code>[SelectItems("Categories")]</code> attribute refers to the Razor Page model, and it has no meaning in the application layer.</p>
			<p>Now, we can implement the <code>OnGe<a id="_idTextAnchor103"/>tAsync</code> method in the <code>CreateProductModalModel</code> class:</p>
			<pre>public async Task OnGetAsync()
{
    Product = new CreateEditProductViewModel
    {
        ReleaseDate = Clock.Now,
        StockState = ProductStockState.PreOrder
    };
    
    var categoryLookup =
        await _productAppService.GetCategoriesAsync();
    Categories = categoryLookup.Items
        .Select(x =&gt; new SelectListItem(x.Name,                         x.Id.ToString()))
                .ToArray();
}</pre>
			<p>We are creating the <code>Product</code> class with default values, then filling the <code>Categories</code> list using the product application service. <code>Clock</code> is a service provided by ABP Framework to<a id="_idIndexMarker191"/> get the current time without dealing with time zones and Local/UTC times. We use it instead of <code>DateTime.Now</code>. This will be explained in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p>We can implement <code>OnPostAsync</code>, a<a id="_idTextAnchor104"/>s shown in the following code block:</p>
			<pre>public async Task&lt;IActionResult&gt; OnPostAsync()
{
    await _productAppService.CreateAsync(
        ObjectMapper
            .Map&lt;CreateEditProductViewModel,CreateUpdateProductDto&gt;                   (Product)
    );
    return NoContent();
}</pre>
			<p>Since we are mapping <code>CreateEditProductViewModel</code> to <code>CreateProductDto</code>, we need to define the mapping configuration. Open the <code>ProductManagementWebAutoMapperProfile</code> class in the <em class="italic">ProductManagement.Web</em> project, and change the content using the following code block:</p>
			<pre>public class ProductManagementWebAutoMappe<a id="_idTextAnchor105"/>rProfile : Profile
{
    public ProductManagementWebAutoMapperProfile()
    {
        CreateMap&lt;CreateEditProductViewModel,                                   CreateUpdateProductDto&gt;();
    }
}</pre>
			<p>This class defines the object mappings for the AutoMapper library.</p>
			<p>We've completed the C# side of the product creation UI. </p>
			<p>Now we can start<a id="_idIndexMarker192"/> to build the UI markup and JavaScript code. T<a id="_idTextAnchor106"/>o do this, open the <code>CreateProductModal.cshtml</code> file, and change the content as follows:</p>
			<pre>@page
@using Microsoft.AspNetCore.Mvc.Localization
@using ProductManagement.Localization
@using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Modal
@model ProductManagement.Web.Pages.Products.CreateProductModalModel
@inject IHtmlLocalizer&lt;ProductManagementResource&gt; L
@{
    Layout = null;
}
&lt;abp-dynamic-form abp-model="Product"
                  asp-page="/Products/CreateProductModal"&gt;
    &lt;abp-modal&gt;
        &lt;abp-modal-header title="@L["NewProduct"].Value"&gt;&lt;/abp-                  modal-header&gt;
        &lt;abp-modal-body&gt;
            &lt;abp-form-content /&gt;
        &lt;/abp-modal-body&gt;
        &lt;abp-modal-footer buttons="@(AbpModalButtons.Cancel|AbpModalButtons.Save)"&gt;&lt;/abp-modal-footer&gt;
    &lt;/abp-modal&gt;
&lt;/abp-dynamic-form&gt;</pre>
			<p>Here, <code>abp-dynamic-form</code> automatically creates the form elements based on the C# model class. <code>abp-form-content</code> is where the form elements are rendered. <code>abp-modal</code> is used to create a modal dialog.</p>
			<p>You can use the standard Bootstrap HTML elements and ASP.NET Core's bindings to create form elements. However, ABP's Bootstrap and dynamic form tag helpers simplify the UI code a lot. We will cover ABP tag helpers in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>We've completed <a id="_idIndexMarker193"/>the product creation modal code. Now, we will add a <code>Index.cshtm<a id="_idTextAnchor107"/>l</code> file in the <em class="italic">Pages/Products</em> folder, and change the <code>abp-card-header</code> section as follows:</p>
			<pre>&lt;abp-card-header&gt;
    &lt;abp-row&gt;
        &lt;abp-column size-md="_6"&gt;
            &lt;abp-card-title&gt;@L["Menu:Products"]&lt;/abp-card-                  title&gt;
        &lt;/abp-column&gt;
        &lt;abp-column size-md="_6" class="text-end"&gt;
            &lt;abp-button id="NewProductButton"
                        text="@L["NewProduct"].Value"
                        icon="plus"
                        button-type="Primary"/&gt;
        &lt;/abp-column&gt;
    &lt;/abp-row&gt;
&lt;/abp-card-header&gt;</pre>
			<p>I've added 2 columns where each column has a <code>size-md="_6"</code> attribute (that is half of the 12-column Bootstrap grid). Then, I placed a button on the right-hand side by keeping the card title on the left-hand side.</p>
			<p>Following this, I added the follow<a id="_idTextAnchor108"/>ing code to the end of the <code>Index.cshtml.js</code> file (right before the final <code>});</code> code part):</p>
			<pre>var createModal = new abp.ModalManager(abp.appPath +                     'Products/CreateProductModal');
createModal.onResult(function () {
    dataTable.ajax.reload();
});
$('#NewProductButton').click(function (e) {
    e.preventDefault();
    createModal.open();
});</pre>
			<p><code>abp.ModalManager</code> is used to <a id="_idIndexMarker194"/>manage modal dialogs on the client side. Internally, it uses Twitter Bootstrap's standard modal component but abstracts many details by providing a simple API. <code>createModal.onResult()</code> is a callback that is called when the modal is saved. <code>createModal.open();</code> is used to open the modal dialog.</p>
			<p>Finally, we need to define some localization texts in the <code>en.json</code> file in t<a id="_idTextAnchor109"/>he <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared</em> project:</p>
			<pre>"NewProduct": "New Product",
"Category": "Category",
"IsFreeCargo": "Free Cargo",
"ReleaseDate": "Release Date"</pre>
			<p>You can run the web application again and try to create a new product:</p>
			<div><div><img src="img/Figure_3.13_B17287.jpg" alt="Figure 3.13 – The New Product modal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – The New Product modal</p>
			<p>ABP has<a id="_idIndexMarker195"/> automatically created the form fields based on the C# class model. Localization and validation also work automatically by reading the attributes and using the conventions. Try to leave the name field empty and save the modal to see an example of the validation error mesage. We will cover the validation and localization topics in more detail in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>We can now create products on the UI. Now, let's see how to edit products.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor110"/>Editing products</h1>
			<p>Editing a <a id="_idIndexMarker196"/>product is similar to adding a new product. This time, we need to get the product to edit and prepare the edit form.</p>
			<h2 id="_idParaDest-75">Application servic<a id="_idTextAnchor111"/>e contracts</h2>
			<p>Let's start by<a id="_idIndexMarker197"/> defining two new methods for the <code>IProductAppService</code> interface:</p>
			<pre>Task&lt;ProductDto&gt; GetAsync(Guid id);
Task UpdateAsync(Guid id, CreateUpdateProductDto input);</pre>
			<p>The first method will be used to obtain the product data by ID. We are reusing <code>CreateUpdateProductDto</code> (which was defined earlier) in the <code>UpdateAsync</code> method.</p>
			<p>We haven't introduced a new DTO, so we can go straight to the implementation.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor112"/>Application service implementation</h2>
			<p>Implementing <a id="_idIndexMarker198"/>th<a id="_idTextAnchor113"/>ese new methods is pretty simple. Add the following methods to the <code>ProductAppService</code> class:</p>
			<pre>public async Task&lt;ProductDto&gt; GetAsync(Guid id)
{
    return ObjectMapper.Map&lt;Product, ProductDto&gt;(
        await _productRepository.GetAsync(id)
    );
}
public async Task UpdateAsync(Guid id, CreateUpdateProductDto input)
{
    var product = await _productRepository.GetAsync(id);
    ObjectMapper.Map(input, product);
}</pre>
			<p>The <code>GetAsync</code> method uses <code>productRepository.GetAsync</code> to get the product from the database and returns it by mapping it to a <code>ProductDto</code> object. The <code>UpdateAsync</code> method gets the product and maps the given input properties to the product's properties. In this way, we overwrite the product properties with new values.</p>
			<p>For this example, we don't need to call <code>_productRepository.UpdateAsync</code> because EF Core<a id="_idIndexMarker199"/> has a change tracking system. ABP's <strong class="bold">Unit of Work</strong> system<a id="_idIndexMarker200"/> automatically saves the changes at the end of the request if it doesn't throw an exception. We will cover the Unit of Work system in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<p>The application layer is now complete. In the next section, we'll create a product editing UI.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor114"/>UI</h2>
			<p>Create a<a id="_idIndexMarker201"/> new <code>EditProductModal.cshtml</code> Razor Page under the <em class="italic">Pages/Products</em> folder of the <em class="italic">ProductManagement.<a id="_idTextAnchor115"/>Web</em> project. Open <code>EditProductModal.cshtml.cs</code>, and change the content using the following code:</p>
			<pre>using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using ProductManagement.Products;
namespace ProductManagement.Web.Pages.Products
{
    public class EditProductModalModel :                             ProductManagementPageModel
    {
        [HiddenInput]
        [BindProperty(SupportsGet = true)]
        public Guid Id { get; set; }
        [BindProperty]
        public CreateEditProductViewModel Product { get; set; }
        public SelectListItem[] Categories { get; set; }
        private readonly IProductAppService _productAppService;
        public EditProductModalModel(IProductAppService                         productAppService)
        {
            _productAppService = productAppService;
        }
        public async Task OnGetAsync()
        {
            // TODO
        }
        public async Task&lt;IActionResult&gt; OnPostAsync()
        {
            // TODO
        }
    }
}</pre>
			<p>The <code>Id</code> property <a id="_idIndexMarker202"/>will be a hidden field in the form. It should also support an HTTP GET request since a GET request opens this modal, and we need the product's ID to prepare the edit form. The <code>Product</code> and <code>Categories</code> properties are similar to the create modal. We are also injecting the <code>IProductAppService</code> interface into<a id="_idTextAnchor116"/> the constructor.</p>
			<p>We can implement the <code>OnGetAsync</code> method, as shown in the following code block:</p>
			<pre>public async Task OnGetAsync()
{
    var productDto = await _productAppService.GetAsync(Id);
    Product = ObjectMapper.Map&lt;ProductDto,                                   CreateEditProductViewModel&gt;(productDto);
    
    var categoryLookup = await                                               _productAppService.GetCategoriesAsync();
    Categories = categoryLookup.Items
        .Select(x =&gt; new SelectListItem(x.Name, x.Id.ToString()))
        .ToArray();
}</pre>
			<p>First, we are getting the product (<code>ProductDto</code>) to edit. We are converting it into <code>CreateEditProductViewModel</code>, which is then used on the UI to create the edit form. Then, we are getting the categories to select on the form, as we did earlier for the creation form.</p>
			<p>We've mapped <code>ProductDto</code> to <code>CreateEditProductViewModel</code>, so now we need to define the mapping configuration in the <code>ProductManagementWeb<a id="_idTextAnchor117"/>AutoMapperProfile</code> class (in the <em class="italic">ProductManagement.Web</em> project) just like we've done previously:</p>
			<pre>CreateMap&lt;ProductDto, CreateEditProductViewModel&gt;();</pre>
			<p>The <code>OnPostAsync</code> method<a id="_idIndexMarker203"/> is simple; we c<a id="_idTextAnchor118"/>all the <code>UpdateAsync</code> method by converting <code>CreateEditProductViewModel</code> into <code>CreateUpdateProductDto</code>:</p>
			<pre>public async Task&lt;IActionResult&gt; OnPostAsync()
{
    await _productAppService.UpdateAsync(Id,
        ObjectMapper.Map&lt;CreateEditProductViewModel,                             CreateUpdateProductDto&gt;(Product)
    );
    return<a id="_idTextAnchor119"/> NoContent();
}</pre>
			<p>Now we can switch to <code>EditProductModal.cshtml</code>, and change its content as follows:</p>
			<pre>@page
@using Microsoft.AspNetCore.Mvc.Localization
@using ProductManagement.Localization
@using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Modal
@model ProductManagement.Web.Pages.Products.EditProductModalModel
@inject IHtmlLocalizer&lt;ProductManagementResource&gt; L
@{
    Layout = null;
}
&lt;abp-dynamic-form abp-model="Product"
                  asp-page="/Products/EditProductModal"&gt;
    &lt;abp-modal&gt;
        &lt;abp-modal-header title="@Model.Product.Name"&gt;&lt;/abp-modal-              header&gt;
        &lt;abp-modal-body&gt;
            &lt;abp-input asp-for="Id" /&gt;
            &lt;abp-form-content/&gt;
        &lt;/abp-modal-body&gt;
        &lt;abp-modal-footer buttons="@(AbpModalButtons.Cancel|AbpModalButtons.Save)"&gt;&lt;/abp-modal-footer&gt;
    &lt;/abp-modal&gt;
&lt;/abp-dynamic-form&gt;</pre>
			<p>This page is very similar to <code>CreateProductModal.cshtml</code>. I just added the <code>Id</code> field to the form (as a hidden input) to store the <code>Id</code> property of the product being edited.</p>
			<p>Finally, we can<a id="_idIndexMarker204"/> add an <code>Ind<a id="_idTextAnchor120"/>ex.cshtml.js</code> file, and add a new <code>ModalManager</code> object on top of the <code>dataTable</code> initialization code:</p>
			<pre>var editModal = new abp.ModalManager(abp.appPath + 'Products/EditProductModal');</pre>
			<p>Then, add a new colu<a id="_idTextAnchor121"/>mn definition as the first item in the <code>columnDefs</code> array within the <code>dataTable</code> initialization code:</p>
			<pre>{
    title: l('Actions'),
    rowAction: {
        items:
            [
                {
                    text: l('Edit'),
                    action: function (data) {
                        editModal.open({ id: data.record.id });
                    }
                }
            ]
    }
},</pre>
			<p>This code adds a new <code>rowAction</code> is a special option provided by ABP Framework. It is used to add one or more actions<a id="_idTextAnchor122"/> for a row in the table.</p>
			<p>Finally, add the<a id="_idIndexMarker205"/> following code after the <code>dataTable</code> initialization code:</p>
			<pre>editModal.onResult(function () {
    dataTable.ajax.reload();
});</pre>
			<p>This code refreshes the data table after saving a product edit dialog, so we can see the latest data on the table. The final UI looks similar to <em class="italic">Figure 3.14</em>:</p>
			<div><div><img src="img/Figure_3.14_B17287.jpg" alt="Figure 3.14 – Editing an existing product&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Editing an existing product</p>
			<p>We can now see the products, create new products, and edit existing ones. The final section will add a new action to delete an existing product.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor123"/>Deleting products</h1>
			<p>Deleting a <a id="_idIndexMarker206"/>product is pretty simple compared to the create or edit actions since, in this<a id="_idTextAnchor124"/> case, we don't need to build a form. First, add a new method to the <code>IProductA<a id="_idTextAnchor125"/>ppService</code> interface:</p>
			<pre>Task DeleteAsync(Guid id);</pre>
			<p>Then, implement it in the <code>ProductAppService</code> class:</p>
			<pre>public async Task DeleteAsync(Guid id)
{
    await _productRepository.DeleteAsync(id);
}</pre>
			<p>We can now add a new action to the product data table. Open <code>Index.csht<a id="_idTextAnchor126"/>ml.js</code>, and add the following definition just after the <code>rowAction.items</code> array):</p>
			<pre>{
    text: l('Delete'),
    confirmMessage: function (data) {
        return l('ProductDeletionConfirmationMessage',                           data.record.name);
    },
    action: function (data) {
        productManagement.p<a id="_idTextAnchor127"/>roducts.product
            .delete(data.record.id)
            .then(function() {
                abp.notify.info(l('SuccessfullyDeleted'));
                dataTable.ajax.reload();
            });
    }
}</pre>
			<p>Here, <code>confirmMessage</code> is a function that is used to get a confirmation from the user before <a id="_idIndexMarker207"/>executing the action. The <code>productManagement.products.product.delete</code> function is dynamically created by ABP Framework, as explained earlier. In this way, you can directly call server-side methods in your JavaScript code. We are just passing the current record's ID. It returns a promise so that we can register a callback to the <code>then</code> function. Finally, we use <code>abp.notify.info</code> to send a notification to inform the user, then refresh the data table.</p>
			<p>We've used some localization texts, so we need to add the following lines to the localization file (the <code>en.json<a id="_idTextAnchor128"/></code> file in the <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared</em> project):</p>
			<pre>"ProductDeletionConfirmationMessage": "Are you sure to delete this book: {0}",
"SuccessfullyDeleted": "Successfully deleted!"</pre>
			<p>You can run <a id="_idIndexMarker208"/>the web project again to see the result:</p>
			<div><div><img src="img/Figure_3.15_B17287.jpg" alt="Figure 3.15 – The Delete action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – The Delete action</p>
			<p>The <strong class="bold">Edit</strong> button automatically turns into an <strong class="bold">Action</strong> drop-down button since we now have two actions. When you click on the <strong class="bold">Delete</strong> action, you get a confirmation message to delete the product:</p>
			<div><div><img src="img/Figure_3.16_B17287.jpg" alt="Figure 3.16 – The delete confirmation message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – The delete confirmation message</p>
			<p>If you click<a id="_idIndexMarker209"/> on the <strong class="bold">Yes</strong> button, you will see a notification on the page, and the data table will be refreshed. </p>
			<p>Implementing product deletion was pretty simple. ABP's built-in features helped us by implementing common patterns such as client-to-server communication, confirmation dialogs, and UI notifications.</p>
			<p>Notice that the <code>Product</code> entity has been inherited from the <code>FullAuditedAggregateRoot</code> class that made it Soft-Delete. Check the database after deleting a product. You will see that it was not really deleted, but the <code>IsDeleted</code> field is set to <code>true</code>. Setting <code>IsDeleted</code> to <code>true</code> makes the product entity soft-deleted (that is, deleted logically but not physically). The next time you query products, deleted products are automatically filtered and not included in the query result. That's done by the data filtering system of ABP Framework and will be covered in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor129"/>Summary</h1>
			<p>In this chapter, we created a fully working CRUD page. We went through all layers of the application and have seen the fundamental approaches of ABP-based application development.</p>
			<p>You were introduced to many different concepts, such as entities, repositories, database mapping and migrations, automated tests, API controllers, dynamic JavaScript proxies, object to object mapping, Soft-Delete, and more. If you're building a serious software solution, you will use all of them, with ABP or not. ABP is a full-stack application framework that helps you implement these concepts with best practices. It provides the necessary infrastructure to make your daily development easier.</p>
			<p>You might not understand all of the details at this point. That's not a problem because the purpose of the remaining chapters is to deep dive into these concepts and show their details and different use cases.</p>
			<p>This example application was relatively simple. It doesn't contain any important business logic because I've introduced many concepts and tried to keep the application simple to focus on these concepts rather than business complexities. I've ignored authorization in this example. Authorization will be explained in <a href="B17287_07_Epub_AM.xhtml#_idTextAnchor213"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Cross-Cutting Concerns</em>.</p>
			<p>Demonstrating an example application with real-world complexity is not easy in a book. However, I've prepared a complete reference application with real-world qualities and complexities for the readers of this book. The reference application is open source and available on GitHub. Additionally, it is a live application, so you can try it directly.</p>
			<p>The next chapter will introduce that reference application and show the reference solution's functionalities, layers, and code structure. The remaining chapters frequently refer to the source code of that application. </p>
		</div>
	</body></html>