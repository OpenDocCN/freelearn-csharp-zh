- en: Chapter 5. Using C# 6.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look through native asynchronous programming support
    in the C# 6.0 programming language. You will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `await` operator to get asynchronous task results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `await` operator in a lambda expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `await` operator with consequent asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `await` operator for the execution of parallel asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions in asynchronous operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the use of the captured synchronization context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working around the `async void` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a custom awaitable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `dynamic` type with `await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, you learned about the Task Parallel Library, the latest asynchronous
    programming infrastructure from Microsoft. It allows us to design our program
    in a modular manner, combining different asynchronous operations together.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is still difficult to understand the actual program flow when
    reading such a program. In a large program, there will be numerous tasks and continuations
    that depend on each other, continuations that run other continuations, and continuations
    for exception handling. They are all gathered together in the program code in
    very different places. Therefore, understanding the sequence of which operation
    goes first and what happens next becomes a very challenging problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue to watch out for is whether the proper synchronization context
    is propagated to each asynchronous task that could touch user interface controls.
    It is only permitted to use these controls from the UI thread; otherwise, we would
    get a multithreaded access exception.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about exceptions, we also have to use separate continuation tasks to
    handle errors that occur inside antecedent asynchronous operation or operations.
    This in turn results in complicated error-handling code that is spread through
    different parts of the code, not logically related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: To address these issues, the authors of C# introduced new language enhancements
    called **asynchronous functions** along with C# version 5.0\. They really make
    asynchronous programming simple, but at the same time, it is a higher level abstraction
    over TPL. As we mentioned in [Chapter 4](ch04.html "Chapter 4. Using the Task
    Parallel Library"), *Using the Task Parallel Library*, abstraction hides important
    implementation details and makes asynchronous programming easier at the cost of
    taking away many important things from a programmer. It is very important to understand
    the concept behind asynchronous functions to create robust and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an asynchronous function, you first mark a method with the `async`
    keyword. It is not possible to have the `async` property or event accessor methods
    and constructors without doing this first. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Another important fact is that asynchronous functions must return the `Task`
    or `Task<T>` type. It is possible to have `async void` methods, but it is preferable
    to use the `async Task` method instead. The only reasonable option to use `async
    void` functions is when using top-level UI control event handlers in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a method marked with the `async` keyword, you can use the `await` operator.
    This operator works with tasks from TPL and gets the result of the asynchronous
    operation inside the task. The details will be covered later in the chapter. You
    cannot use the `await` operator outside the `async` method; there will be a compilation
    error. In addition, asynchronous functions should have at least one `await` operator
    inside their code. However, not having an `await` operator will lead to just a
    compilation warning, not an error.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that this method returns immediately after the line
    with the `await` call. In case of a synchronous execution, the executing thread
    will be blocked for 2 seconds and then return a result. Here, we wait asynchronously
    while returning a worker thread to a thread pool immediately after executing the
    `await` operator. After 2 seconds, we get the worker thread from a thread pool
    once again and run the rest of the asynchronous method on it. This allows us to
    reuse this worker thread to do some other work while these 2 seconds pass, which
    is extremely important for application scalability. With the help of asynchronous
    functions, we have a linear program control flow, but it is still asynchronous.
    This is both very comfortable and very confusing. The recipes in this chapter
    will help you learn every important aspect of asynchronous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In my experience, there is a common misunderstanding about how programs work
    if there are two consecutive `await` operators in it. Many people think that if
    we use the await function on one asynchronous operation after another, they run
    in parallel. However, they actually run sequentially; the second one starts only
    when the first operation completes. It is very important to remember this, and
    later in the chapter, we will cover this topic in detail.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of limitations connected with using `async` and `await` operators.
    In C# 5.0, for example, it is not possible to mark the console application's `Main`
    method as `async`; you cannot have the `await` operator inside a `catch`, `finally`,
    `lock`, or `unsafe` block. It is not allowed to have `ref` and `out` parameters
    on an asynchronous function. There are more subtleties, but these are the major
    points. In C# 6.0, some of these limitations have been removed; you can use `await`
    inside `catch` and `finally` blocks due to compiler internal enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous functions are turned into complex program constructs by the C#
    compiler behind the scenes. I intentionally will not describe this in detail;
    the resulting code is quite similar to another C# construct, called **iterators**,
    and is implemented as a sort of state machine. Since many developers have started
    using the `async` modifier almost on every method, I would like to emphasize that
    there is no sense in marking a method `async` if it is not intended to be used
    in an asynchronous or parallel manner. Calling the `async` method includes a significant
    performance hit, and the usual method call is going to be about 40 to 50 times
    faster as compared to the same method marked with the `async` keyword. Please
    be aware of that.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn to use the C# `async` and `await` keywords to
    work with asynchronous operations. We will cover how to await asynchronous operations
    sequentially and parallelly. We will discuss how to use `await` in lambda expressions,
    how to handle exceptions, and how to avoid pitfalls when using the `async void`
    methods. To conclude the chapter, we will dive deep into synchronization context
    propagation and you will learn how to create your own awaitable objects instead
    of using tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator to get asynchronous task results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks you through the basic scenario of using asynchronous functions.
    We will compare how to get an asynchronous operation result with TPL and with
    the `await` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `await` operator in order to get asynchronous task results, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, we run two asynchronous operations. One of them is standard
    TPL-powered code and the second one uses the new `async` and `await` C# features.
    The `AsynchronyWithTPL` method starts a task that runs for 2 seconds and then
    returns a string with information about the worker thread. Then, we define a continuation
    to print out the asynchronous operation result after the operation is complete
    and another one to print the exception details in case errors occur. Finally,
    we return a task representing one of the continuation tasks and wait for its completion
    in the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AsynchronyWithAwait` method, we achieve the same result by using `await`
    with the task. It is as if we write just the usual synchronous code—we get the
    result from the task, print out the result, and catch an exception if the task
    is completed with errors. The key difference is that we actually have an asynchronous
    program. Immediately after using `await`, C# creates a task that has a continuation
    task with all the remaining code after the `await` operator and deals with exception
    propagation as well. Then, we return this task to the `Main` method and wait until
    it gets completed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that depending on the nature of the underlying asynchronous operation and
    the current synchronization context, the exact means of executing asynchronous
    code may differ. We will explain this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can see that the first and the second parts of the program are
    conceptually equivalent, but in the second part the C# compiler does the work
    of handling asynchronous code implicitly. It is, in fact, even more complicated
    than the first part, and we will cover the details in the next few recipes of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that it is not recommended to use the `Task.Wait` and `Task.Result`
    methods in environments such as the Windows GUI or ASP.NET. This could lead to
    deadlocks if the programmer is not 100% aware of what is really going on in the
    code. This was illustrated in the *Tweaking the execution of tasks with TaskScheduler*
    recipe in [Chapter 4](ch04.html "Chapter 4. Using the Task Parallel Library"),
    *Using the Task Parallel Library*, when we used `Task.Result` in the WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: To test how exception handling works, just uncomment the `throw new Exception`
    line inside the `GetInfoAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator in a lambda expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to use `await` inside a lambda expression. We
    will write an anonymous method that uses `await` and get a result of the method
    execution asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write an anonymous method that uses `await` and get a result of the method
    execution asynchronously using the `await` operator in a lambda expression, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we move out the asynchronous function into the `AsynchronousProcessing`
    method, since we cannot use `async` with `Main`. Then, we describe a lambda expression
    using the `async` keyword. As the type of any lambda expression cannot be inferred
    from lambda itself, we have to specify its type to the C# compiler explicitly.
    In our case, the type means that our lambda expression accepts one string parameter
    and returns a `Task<string>` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the lambda expression body. One aberration is that the method
    is defined to return a `Task<string>` object, but we actually return a string
    and get no compilation errors! The C# compiler automatically generates a task
    and returns it for us.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to await the asynchronous lambda expression execution and print
    out the result.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator with consequent asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how exactly the program flows when we have several
    consecutive `await` methods in the code. You will learn how to read the code with
    the `await` method and understand why the `await` call is an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand a program flow in the presence of consecutive `await` methods,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the program runs, we run two asynchronous operations just as we did in
    the first recipe. However, this time, we shall start from the `AsynchronyWithAwait`
    method. It still looks like the usual synchronous code; the only difference is
    the two `await` statements. The most important point is that the code is still
    sequential, and the `Async 2` task will start only after the previous one is completed.
    When we read the code, the program flow is very clear: we see what runs first
    and what goes after. Then, how is this program asynchronous? Well, first, it is
    not always asynchronous. If a task is already complete when we use `await`, we
    will get its result synchronously. Otherwise, the common approach when we see
    an `await` statement inside the code is to note that at this point, the method
    will return immediately and the rest of the code will be run in a continuation
    task. Since we do not block the execution, waiting for the result of an operation,
    it is an asynchronous call. Instead of calling `t.Wait` in the `Main` method,
    we can perform any other task while the code in the `AsynchronyWithAwait` method
    is being executed. However, the main thread must wait until all the asynchronous
    operations complete, or they will be stopped as they run on background threads.'
  prefs: []
  type: TYPE_NORMAL
- en: The `AsynchronyWithTPL` method imitates the same program flow as the `AsynchronyWithAwait`
    method does. We need a container task to handle all the dependent tasks together.
    Then, we start the main task and add a set of continuations to it. When the task
    is complete, we print out the result; we then start one more task, which in turn
    has more continuations to continue work after the second task is complete. To
    test the exception handling, we throw an exception on purpose when running the
    second task and get its information printed out. This set of continuations creates
    the same program flow as in the first method, and when we compare it to the code
    with the `await` methods, we can see that it is much easier to read and understand.
    The only trick is to remember that asynchrony does not always mean parallel execution.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator for the execution of parallel asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use `await` to run asynchronous operations
    in parallel instead of the usual sequential execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `await` operator for parallel asynchronous task
    execution, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we define two asynchronous tasks running for 3 and 5 seconds, respectively.
    Then, we use a `Task.WhenAll` helper method to create another task that will be
    complete only when all of the underlying tasks get completed. Then, we await the
    result of this combined task. After 5 seconds, we get all the results, which means
    that the tasks were running simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one interesting observation. When you run the program, you
    might note that both tasks are likely to be served by the same worker thread from
    a thread pool. How is this possible when we have run the tasks in parallel? To
    make things even more interesting, let's comment out the `await Task.Delay` line
    inside the `GetIntroAsync` method and uncomment the `await Task.Run` line, and
    then run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see that in this case, both the tasks will be served by different worker
    threads. The difference is that `Task.Delay` uses a timer under the hood, and
    the processing goes as follows: we get the worker thread from a thread pool, which
    awaits the `Task.Delay` method to return a result. Then, the `Task.Delay` method
    starts the timer and specifies a piece of code that will be called when the timer
    counts the number of seconds specified to the `Task.Delay` method. Then, we immediately
    return the worker thread to a thread pool. When the timer event runs, we get any
    available worker thread from a thread pool once again (which could be the same
    thread that we used first) and run the code provided to the timer on it.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `Task.Run` method, we get a worker thread from a thread pool
    and make it block for a number of seconds, provided to the `Thread.Sleep` method.
    Then, we get a second worker thread and block it as well. In this scenario, we
    consume two worker threads and they do absolutely nothing, as they are not able
    to perform any other task while waiting.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk in detail about the first scenario in [Chapter 9](ch09.html "Chapter 9. Using
    Asynchronous I/O"), *Using Asynchronous I/O*, where we will discuss a large set
    of asynchronous operations working with data inputs and outputs. Using the first
    approach whenever possible is the key to creating scalable server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions in asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to deal with exception handling using asynchronous
    functions in C#. You will learn how to work with aggregate exceptions in case
    you use `await` with multiple parallel asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand handling exceptions in asynchronous operations, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We run four scenarios to illustrate the most common cases of error handling
    using `async` and `await` in C#. The first case is very simple and almost identical
    to the usual synchronous code. We just use the `try`/`catch` statement and get
    the exception's details.
  prefs: []
  type: TYPE_NORMAL
- en: A very common mistake is using the same approach when more than one asynchronous
    operations are being awaited. If we use the `catch` block in the same way as we
    did before, we will get only the first exception from the underlying `AggregateException`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To collect all the information, we have to use the awaited tasks' `Exception`
    property. In the third scenario, we flatten the `AggregateException` hierarchy
    and then unwrap all the underlying exceptions from it using the `Flatten` method
    of `AggregateException`.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate C# 6.0 changes, we use `await` inside `catch` and `finally` blocks
    of the exception handling code. To verify that it was not possible to use `await`
    inside `catch` and `finally` blocks in the previous version of C#, you can compile
    it against C# 5.0 by specifying it in the project properties under the build section
    advanced settings.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the use of the captured synchronization context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe discusses the details of the synchronization context behavior when
    `await` is used to get asynchronous operation results. You will learn how and
    when to turn off the synchronization context flow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the details of the synchronization context behavior when `await`
    is used and to learn how and when to turn off the synchronization context flow,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add references to the Windows Presentation Foundation Library by following
    these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **References** folder in the project, and select the **Add
    reference…** menu option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add references to these libraries: **PresentationCore**, **PresentationFramework**,
    **System.Xaml**, and **WindowsBase**. You can use the search function in the reference
    manager dialog as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/B05292_05_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `Main` method with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we studied one of the most important aspects of an asynchronous
    function's default behavior. You already know about task schedulers and synchronization
    contexts from [Chapter 4](ch04.html "Chapter 4. Using the Task Parallel Library"),
    *Using the Task Parallel Library*. By default, the `await` operator tries to capture
    synchronization contexts and executes the preceding code on it. As we already
    know, this helps us write asynchronous code by working with user interface controls.
    In addition, deadlock situations, such as those that were described in the previous
    chapter, will not happen when using `await`, since we do not block the UI thread
    while waiting for the result.
  prefs: []
  type: TYPE_NORMAL
- en: This is reasonable, but let's see what can potentially happen. In this example,
    we create a Windows Presentation Foundation application programmatically and subscribe
    to its button-click event. When clicking on the button, we run two asynchronous
    operations. One of them uses a regular `await` operator, while the other uses
    the `ConfigureAwait` method with `false` as a parameter value. It explicitly instructs
    that we should not use captured synchronization contexts to run continuation code
    on it. Inside each operation, we measure the time they take to complete, and then,
    we display the respective time and ratios on the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we see that the regular `await` operator takes much more time to
    complete. This is because we post 100,000 continuation tasks on the UI thread,
    which uses its message loop to asynchronously work with those tasks. In this case,
    we do not need this code to run on the UI thread, since we do not access the UI
    components from the asynchronous operation; using `ConfigureAwait` with `false`
    will be a much more efficient solution.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing worth noting. Try to run the program by just clicking
    on the button and waiting for the results. Now, do the same thing again, but this
    time, click on the button and try to drag the application window from side to
    side in a random manner. You will note that the code on the captured synchronization
    context becomes slower! This funny side effect perfectly illustrates how dangerous
    asynchronous programming is. It is very easy to experience a situation like this,
    and it would be almost impossible to debug it if you have never experienced such
    a behavior before.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, let's see the opposite scenario. In the preceding code snippet,
    inside the `Click` method, uncomment the commented line and comment out the line
    immediately preceding it. When running the application, we will get a multithreaded
    control access exception because the code that sets the `Label` control text will
    not be posted on the captured context, but it will be executed on a thread pool
    worker thread instead.
  prefs: []
  type: TYPE_NORMAL
- en: Working around the async void method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes why `async void` methods are quite dangerous to use. You
    will learn in what situations it is acceptable to use this method and what to
    use instead, when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to work with the `async void` method, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program starts, we start two asynchronous operations by calling the
    two methods, `AsyncTask` and `AsyncVoid`. The first method returns a `Task` object,
    while the other returns nothing since it is declared `async void`. They both return
    immediately since they are asynchronous, but then, the first one can be easily
    monitored with the returned task status or just by calling the `Wait` method on
    it. The only way to wait for the second method to complete is to literally wait
    for some time because we have not declared any object that we can use to monitor
    the state of the asynchronous operation. Of course, it is possible to use some
    kind of shared state variable and set it from the `async void` method while checking
    it from the `calling` method, but it is better to just return a `Task` object
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: The most dangerous part is exception handling. In case of the `async void` method,
    an exception will be posted to a current synchronization context; in our case,
    a thread pool. An unhandled exception on a thread pool will terminate the whole
    process. It is possible to intercept unhandled exceptions using the `AppDomain.UnhandledException`
    event, but there is no way to recover the process from there. To experience this,
    we should uncomment the `try`/`catch` block inside the `Main` method and then
    run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Another fact about using `async void` lambda expressions is that they are compatible
    with the `Action` type, which is widely used in the standard .NET Framework class
    library. It is very easy to forget about exception handling inside this lambda
    expression, which will crash the program again. To see an example of this, uncomment
    the second commented-out block inside the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend using `async void` only in UI event handlers. In all other
    situations, use the methods that return `Task` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a custom awaitable type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to design a very basic awaitable type that is compatible
    with the `await` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To design a custom awaitable type, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be compatible with the `await` operator, a type should comply with a number
    of requirements that are stated in the C# language specification. If you have
    Visual Studio 2015 installed, you may find the specifications document inside
    the `C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC#\Specifications\1033`
    folder (assuming you have a 64-bit OS and used the default installation path).
  prefs: []
  type: TYPE_NORMAL
- en: 'In paragraph 7.7.7.1, we find a definition of awaitable expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The task of an* `await` *expression is required to be awaitable. An expression*
    `t` *is awaitable if one of the following holds:*'
  prefs: []
  type: TYPE_NORMAL
- en: '`t` *is of compile time type dynamic*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t` *has an accessible instance or extension method called* `GetAwaiter` *with
    no parameters and no type parameters, and a return type* `A` *for which all of
    the following hold:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` *implements the interface* `System.Runtime.CompilerServices.INotifyCompletion`
    *(hereafter known as* `INotifyCompletion` *for brevity).*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A` *has an accessible, readable instance property* `IsCompleted` *of type*
    `bool`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A` *has an accessible instance method* `GetResult` *with no parameters and
    no type parameters*.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This information is enough to get started. First, we define an awaitable type
    `CustomAwaitable` and implement the `GetAwaiter` method. This in turn returns
    an instance of the `CustomAwaiter` type. `CustomAwaiter` implements the `INotifyCompletion`
    interface, has the `IsCompleted` property of the type `bool`, and has the `GetResult`
    method, which returns a `string` type. Finally, we write a piece of code that
    creates two `CustomAwaitable` objects and awaits both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should understand the way `await` expressions are evaluated. This time,
    the specifications have not been quoted to avoid unnecessary details. Basically,
    if the `IsCompleted` property returns `true`, we just call the `GetResult` method
    synchronously. This prevents us from allocating resources for asynchronous task
    execution if the operation has already been completed. We cover this scenario
    by providing the `completeSynchronously` parameter to the constructor method of
    the `CustomAwaitable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we register a callback action to the `OnCompleted` method of `CustomAwaiter`
    and start the asynchronous operation. When it gets completed, it calls the provided
    callback, which will get the result by calling the `GetResult` method on the `CustomAwaiter`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This implementation has been used for educational purposes only. Whenever you
    write asynchronous functions, the most natural approach is to use the standard
    `Task` type. You should define your own awaitable type only if you have a solid
    reason why you cannot use `Task` and you know exactly what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other topics related to designing custom awaitable types, such
    as the `ICriticalNotifyCompletion` interface implementation and synchronization
    context propagation. After understanding the basics of how an awaitable type is
    designed, you will be able to use the C# language specification and other information
    sources to find out the details you need with ease. But I would like to emphasize
    that you should just use the `Task` type, unless you have a really good reason
    not to.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dynamic type with await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to design a very basic type that is compatible with
    the `await` operator and the dynamic C# type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. You will need
    Internet access to download the NuGet package. There are no other prerequisites.
    The source code for this recipe can be found at `BookSamples\Chapter5\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to use the `dynamic` type with `await`, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add references to the **ImpromptuInterface** NuGet package by following these
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **References** folder in the project, and select the **Manage
    NuGet Packages…** menu option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add your preferred references to the **ImpromptuInterface NuGet** package.
    You can use the search function in the **Manage NuGet Packages** dialog as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/B05292_05_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the `Program.cs` file, use the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code below the `Program` class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we repeat the trick from the previous recipe but this time, with the help
    of dynamic expressions. We can achieve this goal with the help of NuGet—a package
    manager that contains many useful libraries. This time, we use a library that
    dynamically creates wrappers, implementing the interfaces we need.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we create two instances of the `ExpandoObject` type and assign
    them to dynamic local variables. These variables will be our `awaitable` and `awaiter`
    objects. Since an `awaitable` object just requires having the `GetAwaiter` method,
    there are no problems with providing it. `ExpandoObject` (combined with the `dynamic`
    keyword) allows us to customize itself and add properties and methods by assigning
    corresponding values. It is in fact a dictionary-type collection with keys of
    the type `string` and values of the type `object`. If you are familiar with the
    JavaScript programming language, you might note that this is very similar to JavaScript
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since `dynamic` allows us to skip compile-time checks in C#, `ExpandoObject`
    is written in such a way that if you assign something to a property, it creates
    a dictionary entry, where the key is the property name and a value is any value
    that is supplied. When you try to get the property value, it goes into the dictionary
    and provides the value that is stored in the corresponding dictionary entry. If
    the value is of the type `Action` or `Func`, we actually store a delegate, which
    in turn can be used like a method. Therefore, a combination of the `dynamic` type
    with `ExpandoObject` allows us to create an object and dynamically provide it
    with properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to construct our `awaiter` and `awaitable` objects. Let's start
    with `awaiter`. First, we provide a property called `Message` and an initial value
    to this property. Then, we define the `GetResult` method using a `Func<string>`
    type. We assign a lambda expression, which returns the `Message` property value.
    We then implement the `IsCompleted` property. If it is set to `true`, we can skip
    the rest of the work and proceed to our `awaitable` object that is stored in the
    `result` local variable. We just need to add a method returning the `dynamic`
    object and return our `awaiter` object from it. Then, we can use `result` as the
    `await` expression; however, it will run synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge is implementing asynchronous processing on our dynamic object.
    The C# language specifications state that an `awaiter` object must implement the
    `INotifyCompletion` or `ICriticalNotifyCompletion` interface, which `ExpandoObject`
    does not. And even when we implement the `OnCompleted` method dynamically, adding
    it to the `awaiter` object, we will not succeed because our object does not implement
    either of the aforementioned interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this problem, we use the `ImpromptuInterface` library that we
    obtained from NuGet. It allows us to use the `Impromptu.ActLike` method to dynamically
    create proxy objects that will implement the required interface. If we try to
    create a proxy implementing the `INotifyCompletion` interface, we will still fail
    because the `proxy` object is not dynamic anymore, and this interface has the
    `OnCompleted` method only, but it does not have the `IsCompleted` property or
    the `GetResult` method. As the last workaround, we define a generic interface,
    `IAwaiter<T>`, which implements `INotifyCompletion` and adds all the required
    properties and methods. Now, we use it for proxy generation and change the `result`
    object to return a `proxy` instead of `awaiter` from the `GetAwaiter` method.
    The program now works; we just constructed an `awaitable` object that is completely
    dynamic at runtime.
  prefs: []
  type: TYPE_NORMAL
