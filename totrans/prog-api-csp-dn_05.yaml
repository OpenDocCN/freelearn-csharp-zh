- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending data from your API to the database only to find out that the input is
    invalid is unnecessarily expensive. Far better is to test the data on the way
    in to make sure it meets basic criteria. This preliminary set of tests (known
    as validation) examines the input data to make sure it meets the minimum criteria
    and that it is formatted properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to validate input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to respond to invalid data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, create a new branch off the existing **data transfer object**
    ( **DTO** ) branch (so that we start with valid data). You will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AutoMapper**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FluentValidation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **FluentValidation** library is a powerful tool for creating validators
    that we will use throughout this chapter. You can install it in various ways,
    but the easiest is as a NuGet package. You’ll also want the package for ASP.NET,
    as shown in *Figure 5* *.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – NuGet installation](img/B21998_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – NuGet installation
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete documentation for **FluentValidation** at [https://docs.fluentvalidation.net/en/latest/index.html#](https://docs.fluentvalidation.net/en/latest/index.html#)
    . I will provide detailed steps as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found in the GitHub repository here:
    [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter05](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Tuning your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the fundamentals for our program, we want to validate the data
    that is coming in, both to speed things up and to protect against malicious data.
    We can do that with validation, but first, we need to make a couple of changes
    to give us good code to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Paging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that we are simulating an automobile buying and selling application.
    There can be literally hundreds of cars in our database. We need to add paging
    to our **Get** endpoint so that when we get the list of vehicles, they don’t all
    come down at once. This will also give us something to validate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate this, we need to know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How big the page is – that is, the number of cars on each page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of the page the client wants to see
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll accomplish this by modifying our **Get** endpoint to take two additional
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pageOffset**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pageSize**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of these are **int** data types, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first new parameter ( **pageNumber** ) will tell **Get** which page it
    is on, and the second ( **pageSize** ) will tell how many rows to get. Let’s look
    at an example in Postman, as shown in *Figure 5* *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Paging](img/B21998_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Paging
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have set **pageNumber** to **0** , indicating we want to start at the
    beginning of the list, and **pageSize** to **3** , indicating we want only three
    records. As a result, the API will extract the first three records. If we set
    **pageNumber** to **3** , we will get records **10** , **11** , and **12** (that
    is, start at the fourth page and get the next three records).
  prefs: []
  type: TYPE_NORMAL
- en: One enhancement you might want to make to reduce confusion for the user is to
    subtract 1 from the page number to get the offset. This will allow the user to
    enter Page 1 for offset 0.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a best practice to validate the incoming properties on your endpoint *before*
    executing the associated method. This not only increases the performance of the
    API, but it also protects you from some forms of hacking (for example, injection).
  prefs: []
  type: TYPE_NORMAL
- en: Our recommendation is to use the **FluentValidation** NuGet package, which you
    can install as shown in the *Technical requirements* section at the start of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you have many options as to how to capture errors. Let’s look
    at a few.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll remember that our **Car** object (defined in [*Chapter 3*](B21998_03.xhtml#_idTextAnchor038)
    ) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also say that cars must not be deleted. You can create a validator for
    that pretty quickly. First, add a **Using** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class that derives from **AbstractValidator** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, put your validation rules in the constructor for that class. Each
    rule is created by using the **RuleFor** keyword and a lambda expression that
    indicates which property you want to validate and the validation rule. Our simple
    example will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Equal** operator is one of many that you can find on the **FluentValidation**
    documentation page: [https://docs.fluentvalidation.net/en/latest/built-in-validators.html](https://docs.fluentvalidation.net/en/latest/built-in-validators.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll test the data and then either compare it to what is valid and return an
    error if appropriate, or, more commonly, we’ll throw an exception if the data
    fails validation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the return value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a number of ways to deal with a validation error. One is to return
    an error to the calling method. Thus, to validate a **Car** object, conceptually
    you want the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our **insert** method, we’ll check to make sure **CarDto** is valid (in
    this case, that it is not deleted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at returning an error code for data that fails our validation
    check.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we now send **CarDto** to the endpoint using Postman but set **Is_Deleted**
    to **1** , we will get an error as shown in *Figure 5* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Validation error](img/B21998_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Validation error
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the return HTTP value is **400 – Bad Request** . This makes sense
    as the DTO passed in was not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This input is great and provides a lot of information, but the **1** value that
    is in the **Is_Deleted** field has meaning; specifically that the record is already
    deleted. This fails the validation check.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the error clearer with a custom message. Return to **CarDtoValidator**
    and modify the rule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see a new error message in *Figure 5* *.4* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Custom error message](img/B21998_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Custom error message
  prefs: []
  type: TYPE_NORMAL
- en: Custom messages provide vital information to your client. They help avoid confusion
    and make immediately clear what is wrong with the submitted data.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to validate more than one aspect of a property, you can chain tests
    using the **dot** operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This test ensures that the **Is_Deleted** field is not empty and also verifies
    that its value is equal to **0** , and returns an error message if the submitted
    value is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: The default is that even if the first test ( **NotEmpty** ) fails, the second
    test will run ( **Equal("0"** ). You can prevent this by using **CascadeMode**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want the second test ( **NotEmpty** ) to run if the first test
    ( **Is_Deleted** ) fails, use **CascadeMode.Stop** as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This now works like **&&** in C# – that is, if the first test fails the second
    is never evaluated. The two values for **CascadeMode** are **Stop** and **Continue**
    , with the latter being the default.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an exception
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an alternative to validating and then checking the result, you can call
    **ValidateAndThrow** . With this terser expression each of your rules will be
    evaluated, and if one fails, an exception will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The exception that is thrown is of type **ValidationException** , so you can
    test for that in your **catch** blocks. In addition, that exception has an **Errors**
    property, which has the error message for your failed attempt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code snippet, you can see how to set up to throw an exception if
    the validation fails. We create the validator and then call **ValidateAndThrow**
    , passing in the **Dto** object. You can then catch that exception and examine
    the errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To save you the time and effort of creating custom validators for common scenarios,
    **FluentValidation** provides a number of built-in validators.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a cornucopia of built-in validators in addition to the **Equal** and
    **NotEmpty** validators we’ve seen so far. I won’t provide a comprehensive list
    (see the documentation) but one of the most interesting is the **PredicateValidator**
    validator. This passes the value of the property to a delegate, which can use
    custom validation logic. This is accomplished with the keyword **Must** keyword,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If this validation fails, the issue is displayed in the results as shown in
    *Figure 5* *.5* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – PredicateValidator error](img/B21998_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – PredicateValidator error
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a **RegularExpression** validator that uses the **Matches** keyword
    (instead of **Must** ), but one of my favorites is **EmailValidator** , which
    ensures that the value submitted is a valid email. Similarly, there is a **CreditCard**
    validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few more, such as **NotNull** , **NotEmpty** , **Equal** ,
    **NotEqual** , and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to see a complete list of built-in validators and how to use
    them is in the **FluentValidation** documentation: [https://docs.fluentvalidation.net/en/latest/index.html#](https://docs.fluentvalidation.net/en/latest/index.html#)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to use **FluentValidation** to validate input properties
    before executing code for the API.
  prefs: []
  type: TYPE_NORMAL
- en: You saw how to create rules, how to chain them, and how to ensure that a second
    rule in a chain is not evaluated if the first fails.
  prefs: []
  type: TYPE_NORMAL
- en: You learned two ways of dealing with errors – testing the return error or throwing
    an exception – and you saw how to create a custom error message.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention to Azure Functions – a critical
    part of programming APIs in .NET. Following that, we will look at Durable Azure
    Functions and what they add to Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a set of rules for the **Car** class (or another class you create) and
    throw an exception if a validation rule is violated. Ensure that the failure of
    the validation is handled.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, create a predicate ( **must** ) custom rule and test against that.
  prefs: []
  type: TYPE_NORMAL
