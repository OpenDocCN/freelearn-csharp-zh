<html><head></head><body>
  <div id="_idContainer538" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-142" class="chapterTitle">Material Alchemy: Using URP and Shader Graph for Stunning Visuals</h1>
    <p class="normal">Welcome to the first chapter of <em class="chapterRef">Section 3</em>, <em class="italic">Elevating Visuals, Effects, and Audio</em> Here, we will dive deep into the different graphics and audio systems of Unity to dramatically improve the look and feel of the game. Let’s begin our journey into the world of shaders, the artists behind the scenes in every Unity game, and learn how to craft our own from scratch. We will start by discussing what a shader is and how to create our own to achieve several custom effects that couldn’t be accomplished using the default Unity shaders. We will be creating a simple water animation effect using Shader Graph, a visual shader editor included in the Universal Render Pipeline (URP), the preferred option for creators to launch their games on a wide variety of devices, including web and mobile. Also known as URP, this is one of the different rendering pipelines available in Unity, which provides rendering features oriented toward performance. We will be discussing some of its capabilities in this chapter.</p>
    <p class="normal">In this chapter, we will examine the following shader concepts:</p>
    <ul>
      <li class="bulletList">Introducing shaders and URP</li>
      <li class="bulletList">Creating shaders with Shader Graph</li>
    </ul>
    <h1 id="_idParaDest-143" class="heading-1">Introducing shaders and URP</h1>
    <p class="normal">Remember the <a id="_idIndexMarker608"/>glowing orb material we created in <em class="chapterRef">Section 1</em>, <em class="italic">Getting Started with Unity</em>? Let’s explore how its shader property manipulates light to create that glow effect. In this first section, we will be exploring the concept of a shader as a way to program the video card to achieve custom visual effects. We will also be discussing how URP works with those shaders, and the default shaders it provides.</p>
    <p class="normal">In this section, we will cover the following concepts related to shaders:</p>
    <ul>
      <li class="bulletList">Shader pipeline</li>
      <li class="bulletList">Render pipeline and URP</li>
      <li class="bulletList">URP built-in shaders</li>
    </ul>
    <p class="normal">Let’s start by discussing how a shader modifies the shader pipeline to achieve effects.</p>
    <h2 id="_idParaDest-144" class="heading-2">Shader pipeline</h2>
    <p class="normal">Whenever<a id="_idIndexMarker609"/> a video card renders a 3D model, it needs different information to process, such as a <strong class="screenText">mesh</strong>, <strong class="screenText">textures</strong>, the transformation of the object (position, rotation, and scale), and lights that affect the object. With that data, the video card must output the pixels of the object into the <strong class="screenText">back buffer</strong>, an image where the video card will be drawing our objects, but the user won’t see this yet. This is done to prevent the user from seeing unfinished results, given we can still be drawing at the time the monitor refreshes. That image will be shown when Unity finishes rendering all objects (and some effects) to display the finished scene, swapping the <strong class="screenText">back buffer </strong>with the <strong class="screenText">front buffer</strong>, the image that the user actually sees. You can imagine this as having a page with an image that is being shown to the user while you draw a new image, and when you finish the new drawing, you just swap the pages and start drawing again on the page the user does not see, repeating this with every frame.</p>
    <p class="normal">That’s the usual way to render an object, but what happens between the input of the data and the output of the pixels can be handled in a myriad of different ways and techniques that depend on how you want your object to look; maybe you want it to be realistic or look like a hologram, or maybe the object needs a disintegration effect or a toon effect—there are endless possibilities. The way to specify how our video card will handle the rendering of the object is through a shader.</p>
    <p class="normal">A <strong class="screenText">shader</strong> is a program <a id="_idIndexMarker610"/>coded in specific video card languages, such as:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">HLSL</strong>: The DirectX<a id="_idIndexMarker611"/> shading language, DirectX being a graphics library.</li>
      <li class="bulletList"><strong class="keyWord">GLSL</strong>: The<a id="_idIndexMarker612"/> OpenGL shading language, OpenGL also being a graphics library.</li>
      <li class="bulletList"><strong class="keyWord">CG</strong>: A language <a id="_idIndexMarker613"/>that can output either HLSL or GLSL, depending on which graphics library we use in our game.</li>
      <li class="bulletList"><strong class="keyWord">Shader Graph</strong>: A <a id="_idIndexMarker614"/>visual language that will be automatically converted into one of the previously mentioned languages according to our needs. This is the one we will be using given its simplicity (more on that later).</li>
    </ul>
    <p class="normal">Any of those languages can be used to configure different stages of the render process necessary to render a given object, sometimes not only configuring them but also replacing them with completely custom code to achieve the exact effect we want. All of the stages to render an object make up what we call the shader pipeline, a chain of modifications applied to the input data until it is transformed into pixels.</p>
    <p class="normal">Each stage of the pipeline is in charge of different modifications, and depending on the video card shader model, this pipeline can vary a lot. In the next diagram, you can find a simplified shader pipeline, skipping advanced/optional stages that are not important right now:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_01_PE.png" alt="A blue rectangle with black text  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.1: Common shader pipeline</p>
    <p class="normal">Think of the shader pipeline as an assembly line in a factory, where each stage represents a different worker specializing in a specific task, collectively contributing to the final product.</p>
    <p class="normal">Let’s discuss each of the stages:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Input Assembler</strong>: Here <a id="_idIndexMarker615"/>is where all of the mesh data, such as vertex position, UVs, and normals, is assembled to be prepared for the next stage.</li>
      <li class="bulletList"><strong class="keyWord">Vertex Shader</strong>: This <a id="_idIndexMarker616"/>stage used to be limited to applying the transformation of the object, the position and perspective of the camera, and simple lighting calculations. In modern GPUs, you are in charge of doing whatever you want. This stage receives each of the vertices of the object to render and outputs a modified one. You have the chance to modify the geometry of the object here. The usual code here applies the transform of the object, but you can also apply several effects, such as inflating the object along its normals to apply the old toon effect technique or apply distortion, adding random offsets to each vertex to recreate a hologram. There’s also the opportunity to calculate data for the next stages.</li>
      <li class="bulletList"><strong class="keyWord">Primitive Culling</strong>: Most <a id="_idIndexMarker617"/>of the models you are going to render have the particularity that you will never see the back side of a model face. With a cube, there’s no way to look at its inner sides. Given that, rendering both sides of each face of the cube makes no sense, and this stage takes care of that. Primitive culling will determine whether the face needs to be rendered based on the orientation of the face, saving lots of pixel calculation of occluded faces. You can change this to behave differently for specific cases; as an example, we can create a glass box that needs to be transparent to see all sides of the box. Don’t confuse this with other types of culling, like frustum culling. This other type of culling filters objects outside the camera view area before they are even sent to the shader pipeline.</li>
      <li class="bulletList"><strong class="keyWord">Rasterizer</strong>: Now that <a id="_idIndexMarker618"/>we have the modified and visible geometry of our model calculated, it’s time to convert it into pixels. The rasterizer creates all pixels for the triangles of our mesh. Lots of things happen here, but again, we have very little control over that; the usual way to rasterize is just to create all pixels inside the edges of the mesh triangles. We have other modes that just render the pixels on the edges to see a wireframe effect, but this is usually used for debugging purposes:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B21361_10_02_PE.png" alt="Image result for rasterizer"/></figure>
    <p class="packt_figref">Figure 10.2: Example of figures being rasterized</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Fragment Shader</strong>: This<a id="_idIndexMarker619"/> is one of the most customizable stages of all. Its purpose is simple: just determine the color of each of the fragments (pixels) that the rasterizer has generated. Here, lots of things can happen, from simply outputting a plain color or sampling a texture to applying complex lighting calculations such as normal mapping and PBR. Also, you can use this stage to create special effects such as water animations, holograms, distortions, disintegrations, and any special effects that require you to modify what the pixels look like. We will explore how we can use this stage in the next sections of this chapter.</li>
      <li class="bulletList"><strong class="keyWord">Depth Testing</strong>: Before <a id="_idIndexMarker620"/>showing a pixel on the screen, we need to check whether it can be seen. This stage checks whether the pixel’s depth is behind or in front of the previous pixel rendered in the same position, guaranteeing that, regardless of the rendering order of the objects, the nearest pixels to the camera are always drawn on top of others. Again, usually, this stage is left in its default state, prioritizing pixels that are nearer to the camera, but some effects require different behavior. Also, nowadays we<a id="_idIndexMarker621"/> have <strong class="keyWord">early-Z testing</strong>, which does this same test but before the Fragment Shader stage. But let’s keep things simple for now. As an example, in the next screenshot, you can see an effect that allows you to see objects that are behind other objects, like the one used in <em class="italic">Age of Empires</em> when a unit is behind a building:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B21361_10_03_PE.png" alt="Image result for occluded effect shader"/></figure>
    <p class="packt_figref">Figure 10.3: Rendering the occluded parts of the character</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Blending</strong>: Once the<a id="_idIndexMarker622"/> color of the pixel is determined and we are sure the pixel is not occluded by a previous pixel, the final step is to put it in the back buffer (the frame or image you are drawing). Usually, we just override whatever pixel was in that position (because our pixel is nearer to the camera), but if you think about transparent objects, we need to combine our pixel with the previous one to make the transparent effect. Transparencies have other things to take into account aside from the blending, but the main idea is that blending controls exactly how the pixel will be combined with the previously rendered pixel in the back buffer.</li>
    </ul>
    <p class="normal">Shader pipelines would require an entire book to cover, but for the scope of this book, the previous description will give you a good idea of what a shader does, and the possible effects that it can achieve. Now that we have discussed how a shader renders a single object, it is worth discussing how Unity renders all of the objects using the render pipeline.</p>
    <div class="note">
      <p class="normal">For more information about shaders, you can use the following link: <a href="https://docs.unity3d.com/Manual/shader-writing.html"><span class="url">https://docs.unity3d.com/Manual/shader-writing.html</span></a></p>
    </div>
    <h2 id="_idParaDest-145" class="heading-2">Render pipeline and URP</h2>
    <p class="normal">We have<a id="_idIndexMarker623"/> covered how the video card renders an object, but Unity is in charge of asking the video card to execute a shader pipeline per object. To do so, Unity needs to do lots of preparations and calculations to determine exactly how and when each shader needs to be executed. The responsibility of doing this is with what Unity calls the render pipeline.</p>
    <p class="normal">Think of Unity’s render pipeline like a film director orchestrating how each scene (object) is presented, with <a id="_idIndexMarker624"/>URP as one of its advanced cameras, optimizing how each shot is captured. Also, think of the render pipeline as the stage crew of a theater, setting the scene and lighting for each object (actor) to ensure they look the best under the spotlight.</p>
    <p class="normal">A render pipeline is a way to draw the objects of the scene. At first, it sounds like there should be just one simple way of doing this, for example, iterating over all objects in the scene and executing the shader pipeline with the shader specified in each object’s material, but it can be more complex than that.</p>
    <p class="normal">Usually, the main difference between one render pipeline and another is the way in which lighting and some advanced effects are calculated, but they can differ in other ways.</p>
    <p class="normal">In previous Unity versions, there <a id="_idIndexMarker625"/>was just one single render pipeline, which is now called the <strong class="screenText">built-in renderer pipeline</strong> (also known as <strong class="screenText">BIRP</strong>). It was a pipeline that had all of the possible features you would need for all kinds of projects, from mobile 2D graphics and simple 3D to cutting-edge 3D graphics like the ones you can find in consoles or high-end PCs. This sounds ideal, but actually, it isn’t. Having one single giant renderer that needs to be highly customizable to adapt to all possible scenarios generates lots of overhead and limitations that cause more headaches than creating a custom render pipeline. Luckily, the last versions of Unity introduced <a id="_idIndexMarker626"/>the <strong class="screenText">Scriptable Render Pipeline</strong> (<strong class="screenText">SRP</strong>), a way to create a render pipeline adapted to your project.</p>
    <p class="normal">Luckily, Unity doesn’t want you to create your own render pipeline for each project (which is a complex task), so it has created two custom pipelines for you that are ready to use: <strong class="screenText">URP</strong> (formerly called LWRP, or Lightweight Render Pipeline), which stands for <strong class="screenText">Universal Render Pipeline</strong>, and <strong class="screenText">HDRP</strong>, which stands for <strong class="screenText">High Definition Render Pipeline</strong>. The<a id="_idIndexMarker627"/> idea is that you must choose one or the other based on your project’s requirements (unless you really need to create your own).</p>
    <p class="normal">URP, the <a id="_idIndexMarker628"/>one <a id="_idIndexMarker629"/>we selected when creating the project for our game, is a render pipeline suitable for most games that don’t require lots of advanced graphics features, such as mobile games or simple PC games, while HDRP is packed with lots of advanced rendering features for high-quality games. The latter requires high-end hardware to run, while URP runs on almost every relevant target device. It is worth mentioning that you can swap between BIRP, HDRP, and URP whenever you want, including after creating the project (but this is not recommended):</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.4: Project wizard showing HDRP and URP templates</p>
    <p class="normal">We could discuss how each one is implemented and the differences between each, but again, this could fill entire chapters. Right now, the idea of this section is for you to know why we picked URP when we created our project; it has some restrictions we will encounter throughout this book that we will need to take into account, so it is good to know why we accepted those limitations. One reason we chose it was that it allows us to run our game on all relevant hardware.</p>
    <p class="normal">Another<a id="_idIndexMarker630"/> reason <a id="_idIndexMarker631"/>why we have chosen URP is that it has support for Shader Graph, the Unity tool that we will be using in this chapter to create custom effects. Previous Unity built-in pipelines didn’t provide us with such a tool (aside from third-party plugins). Finally, another reason to introduce the concept of URP is that it comes with lots of built-in shaders that we will need to know about before creating our own to prevent reinventing the wheel. This will allow us to get used to those shaders, because if you came from previous versions of Unity, the shaders you already know won’t work here; actually, this is exactly what we are going to discuss in the next section of this chapter: the difference between the different URP built-in shaders.</p>
    <h2 id="_idParaDest-146" class="heading-2">URP built-in shaders</h2>
    <p class="normal">Now that we know the difference between URP and other pipelines, let’s discuss which shaders are integrated into URP. Let’s briefly describe the three most important shaders in this pipeline:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Lit</strong>: This is <a id="_idIndexMarker632"/>the replacement of the old Standard Shader. This shader is useful for creating all kinds of realistic physics materials, such as wood, rubber, metal, skin, and combinations of them (such as a character with skin and metal armor). It supports features like normal mapping, occlusion, different lighting workflows like Metallic and Specular, and transparencies.</li>
      <li class="bulletList"><strong class="keyWord">Simple Lit</strong>: This <a id="_idIndexMarker633"/>is the replacement of the old Mobile/Diffuse Shader. As the name suggests, this shader is a simpler version of Lit, meaning that its lighting calculations are simpler approximations of how light works, with fewer features than its counterpart. Basically, when you have simple graphics without realistic lighting effects, this is the best choice.</li>
      <li class="bulletList"><strong class="keyWord">Unlit</strong>: This is <a id="_idIndexMarker634"/>the replacement of the old Unlit/Texture Shader. Sometimes, you need objects with no lighting whatsoever, and in that case, this is the shader for you. No lighting doesn’t mean an absence of light or complete darkness; it actually means that the object has no shadows at all, and it’s fully visible without any shade. Some simplistic graphics can work with this, relying on shadowing being baked in the texture, meaning that the texture comes with the shadow.</li>
    </ul>
    <p class="normal">This is extremely performant, especially for low-end devices such as mobile phones. Also, you have other cases such as light tubes or screens, objects that can’t receive shadows because they emit light, so they will be seen at their full color even in complete darkness. In the following screenshot, you can see a 3D model using an Unlit Shader. It looks like it’s being lit, but it’s just the texture of the model that applied lighter and darker colors in different parts of the object:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_05_PE.png" alt="A picture containing design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.5: Pod using an Unlit effect to simulate cheap lighting</p>
    <p class="normal">Let’s do an interesting disintegration effect with the Simple Lit Shader to demonstrate its capabilities. You<a id="_idIndexMarker635"/> must do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Begin by sourcing a <strong class="screenText">Cloud Noise</strong> texture. You can find suitable textures on various free asset websites. Ensure the texture’s resolution and format are compatible with Unity for optimal results:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_06_PE.png" alt="Image result for cloud noise texture"/></figure>
    <p class="packt_figref">Figure 10.6: Noise texture</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Select the<a id="_idIndexMarker636"/> recently imported texture in the <strong class="screenText">Project</strong> panel.</li>
      <li class="numberedList">In the Inspector, set the <strong class="screenText">Alpha Source</strong> property to <strong class="screenText">From Gray Scale</strong>. This will make the alpha channel of the texture be calculated based on the grayscale of the image. We will use the calculated alpha value to determine which pixels need to be deintegrated first (the darker ones first):
    <figure class="mediaobject"><img src="../Images/B21361_10_07_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.7: Applying the Alpha Source From Gray Scale texture setting</p>
    <p class="normal">The <a id="_idIndexMarker637"/>alpha channel of a color is often associated with transparency, but you will notice that our object won’t be transparent. The alpha channel is extra color data that can be used for several purposes when creating effects. In this case, we will use it to determine which pixels are being disintegrated first.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Click the <strong class="screenText">+</strong> icon in the <strong class="screenText">Project</strong> view and select <strong class="screenText">Material. </strong>You can rename it, giving it a name that makes it easier to find later:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_08.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.8: Material creation button</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Create a cube by going to the top menu and selecting <strong class="screenText">GameObject | 3D Object | Cube</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_09.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.9: Cube primitive creation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Drag the material from the <strong class="screenText">Project</strong> window to the cube in the <strong class="screenText">Scene</strong> window.</li>
      <li class="numberedList">Click <a id="_idIndexMarker638"/>in the drop-down menu at the right of the <strong class="screenText">Shader</strong> property in the Inspector and look for the <strong class="screenText">Universal Render Pipeline | Simple Lit</strong> option. We could also work with the default shader (<strong class="screenText">Lit</strong>), but <strong class="screenText">Simple Lit</strong> is going to be easier on performance, and we don’t need the advanced features of <strong class="screenText">Lit</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_10.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.10: Simple Lit Shader selection</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Next, select the newly created material in your project. Drag and drop the downloaded <code class="inlineCode">Cloud Noise</code> texture into the <strong class="screenText">Base Map </strong>section. This step visually binds your texture to the shader, enabling the disintegration effect.</li>
      <li class="numberedList">Enable<a id="_idIndexMarker639"/> the <strong class="screenText">Alpha Clipping</strong> option and adjust the <strong class="screenText">Threshold</strong> slider to <code class="inlineCode">0.5</code>. <strong class="screenText">Alpha Clipping</strong> plays a critical role in how the shader interprets texture transparency, influencing the disintegration effect’s appearance.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_11.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.11: Alpha Clipping Threshold material slider</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="10">As you move the <strong class="screenText">Threshold</strong> slider, the object will start to disintegrate. <strong class="screenText">Alpha Clipping</strong> discards pixels that have less alpha intensity than the <strong class="screenText">Threshold</strong> value:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_12_PE.png" alt="A black and white cube  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.12: Disintegration effect with Alpha Clipping</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="11">Finally, set<a id="_idIndexMarker640"/> <strong class="screenText">Render Face</strong> to <strong class="screenText">Both</strong> to see both sides of the cube’s faces:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_13.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.13: Double-sided render face</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="12">Take into account that the artist that creates the texture can configure the <strong class="keyWord">Alpha</strong> channel manually instead of calculating it from the grayscale, just to control exactly how the disintegration effect must look regardless of the texture’s color distribution:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_14_PE.png" alt="A black and white cube  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.14: Double-sided Alpha Clipping</p>
    <p class="normal">The idea of this<a id="_idIndexMarker641"/> section is not to give a comprehensive guide of all of the properties of all URP shaders but to give you an idea of what a shader can do when properly configured and when to use each of the integrated shaders. Sometimes, you can achieve the effect you need just by using existing shaders, probably in 99% of cases in simple games, so try to stick to them as much as you can. But if you really need to create a custom shader to create a very specific effect, the next section will teach you how to use the URP tool called Shader Graph.</p>
    <h1 id="_idParaDest-147" class="heading-1">Creating shaders with Shader Graph</h1>
    <p class="normal">Now that <a id="_idIndexMarker642"/>we know how shaders work and the existing shaders in URP, we have a basic notion of when it is necessary to create a custom shader and when it is not necessary. In case you really need to create one, this section will cover the basics of effects creation with Shader Graph, a tool to create effects using a visual node-based editor. This is an easy tool to use when you are not used to coding.</p>
    <p class="normal">In this section, we will discuss the following concepts of Shader Graph:</p>
    <ul>
      <li class="bulletList">Creating our first Shader Graph</li>
      <li class="bulletList">Using textures</li>
      <li class="bulletList">Combining textures</li>
      <li class="bulletList">Applying transparency</li>
      <li class="bulletList">Creating vertex effects</li>
    </ul>
    <p class="normal">Let’s start by seeing how we can create and use a Shader Graph.</p>
    <h2 id="_idParaDest-148" class="heading-2">Creating our first Shader Graph</h2>
    <p class="normal">Shader Graph is a tool that <a id="_idIndexMarker643"/>allows us to create custom effects using a node-based system. An effect in Shader Graph can look like in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_15_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.15: Shader Graph with nodes to create a custom effect</p>
    <p class="normal">We will discuss later what those nodes do and we will be creating an example effect step by step, but in the screenshot, you can see how we created and connected several nodes—the interconnected boxes—with each one executing a specific process to achieve the effect. The idea of creating effects with Shader Graph is to learn which specific nodes you need and how to connect them properly. This is similar to the way we code the gameplay of <a id="_idIndexMarker644"/>the game, but this Shader Graph is adapted and simplified just for effect purposes.</p>
    <p class="normal">To create and edit our first Shader Graph, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In the <strong class="screenText">Project</strong> window, click the <strong class="screenText">+</strong> icon and find the <strong class="screenText">Shader Graph | URP | Lit Shader Graph</strong> option. This will create a Shader Graph using the PBR mode, meaning that this shader will support lighting effects (unlike Unlit graphs):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_16.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.16: PBR Shader Graph creation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Name it <code class="inlineCode">Water</code>. If you want the opportunity to rename the asset, remember that you can select the asset, right-click, and select <strong class="screenText">Rename</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_17_PE.png" alt="A picture containing screenshot, symbol, logo, electric blue  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.17: Shader Graph asset</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Create a new material called <code class="inlineCode">WaterMaterial</code> and set <strong class="screenText">Shader</strong> to <strong class="screenText">Shader Graphs/Water</strong>. If for some reason Unity doesn’t allow you to do that, try right-clicking on the <strong class="screenText">Water </strong>graph and clicking <strong class="screenText">Reimport</strong>. As you can see, the created Shader Graph now appears as a shader in the material:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_18_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.18: Setting a Shader Graph as a material shader</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Create a<a id="_idIndexMarker645"/> plane with the <strong class="screenText">GameObject | 3D Object | Plane </strong>option by right-clicking from the <strong class="screenText">Hierarchy</strong> window.</li>
      <li class="numberedList">Drag the material to the plane to apply it.</li>
    </ol>
    <p class="normal">Now, you have created your first custom shader and applied it to a material. So far, it doesn’t look interesting at all—it’s just a gray effect—but now it’s time to edit the graph to unlock its full potential. As the name of the graph suggests, we will be creating a water effect in this chapter to illustrate several nodes of the Shader Graph toolset and how to connect them. So, let’s start by discussing the Master Node.</p>
    <p class="normal">When you open the graph by double-clicking the shader asset, you will see the following:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_19_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.19: Master Node with all of the properties needed to calculate the object’s appearance</p>
    <p class="normal">All nodes will <a id="_idIndexMarker646"/>have input pins, the data needed to work, and output pins, the results of their process. As an example, in a sum operation, we will have two input numbers and an output number, the result of the sum. In this case, you can see that the Master Node only contains inputs, and that’s because all data that enters the Master Node will be used by Unity to calculate the rendering and lighting of the object, things such as the desired object color or texture (the <strong class="screenText">Base Color</strong> input pin), how smooth it is (the <strong class="screenText">Smoothness</strong> input pin), or how much metal it contains (the <strong class="screenText">Metallic </strong>input pin), properties that will affect how the lighting will be applied to the object.</p>
    <p class="normal">You can see that the Master Node is split between a <strong class="screenText">Vertex</strong> section and a <strong class="screenText">Fragment</strong> section. The first is capable of changing the mesh of the object we are modifying to deform it, animate it, etc., while the latter will change how it will look, which textures to use, how it will be illuminated, etc. Let’s start exploring how we can change that data in the <strong class="screenText">Fragment</strong> section by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Double-click the <strong class="screenText">Shader Graph</strong> asset in the <strong class="screenText">Project</strong> view to open its editor.</li>
      <li class="numberedList">Click in the gray rectangle at the left of the <strong class="screenText">Base Color</strong> input pin:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_20_PE.png" alt="A picture containing text, screenshot, font, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.20: Base Color node input pin</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">In the color picker, select a light blue color, like water. Select the bluish part of the circle and then a shade of that color in the middle rectangle:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_21_PE.png" alt="A screenshot of a phone  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.21: Color picker</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Set <strong class="screenText">Smoothness</strong> to <code class="inlineCode">0.9</code>, which will <a id="_idIndexMarker647"/>make the object almost completely smooth (90% of the total smoothness possible). This will make our water reflect the sky almost completely:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_22_PE.png" alt="A picture containing text, screenshot, font, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.22: Smoothness PBR Master Node input pin</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Click the <strong class="screenText">Save Asset</strong> button at the top left of the window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_23_PE.png" alt="A screen shot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.23: Shader Graph saving options</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Go back<a id="_idIndexMarker648"/> to the <strong class="screenText">Scene</strong> view and check that the plane is light blue with the sun reflected on it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_24_PE.png" alt="A screenshot of a video game  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.24: Initial Shader Graph results</p>
    <p class="normal">As you can see, the behavior of the shader varies according to the properties you set in the Master Node, but so far, doing this is no different than creating an Unlit Shader and setting up its properties; the real power of Shader Graph is when you use nodes that do specific calculations as inputs of the Master Node. We will start looking at the texture nodes, which allow us to apply textures to our model.</p>
    <h2 id="_idParaDest-149" class="heading-2">Using textures</h2>
    <p class="normal">The idea of <a id="_idIndexMarker649"/>using textures is to have an image applied to the model in a way that we can paint different parts of the models with different colors. Remember that the model has a UV map, which allows Unity to know which part of the texture will be applied to which part of the model:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_25.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.25: On the left, a face texture; on the right, the same texture applied to a face mesh</p>
    <p class="normal">Like in visual scripting, we will use interconnected nodes in our shader graph that will execute specific shader operations. We have several nodes to do this task, one of them being <strong class="screenText">Sample Texture 2D</strong>, a node that has two main inputs. First, it asks us for the texture to sample or apply to the model, and then for the UV. You can see it in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_26_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.26: Sample Texture 2D node</p>
    <p class="normal">As you<a id="_idIndexMarker650"/> can see, the default value of the <strong class="screenText">Texture</strong> input node is <strong class="screenText">None</strong>, so there’s no texture by default, and we need to manually specify that. For <strong class="screenText">UV</strong>, the default value is <code class="inlineCode">UV0</code>, meaning that, by default, the node will use the main UV channel of the model; and yes, a model can have several UVs set. For now, we will stick with the main one. If you are not sure what that means, <strong class="screenText">UV0</strong> is the safest option. Let’s try this node, by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Download and import a tileable water texture from the internet:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_27_PE.png" alt="Image result for tileable water texture"/></figure>
    <p class="packt_figref">Figure 10.27: Tileable water texture</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Select<a id="_idIndexMarker651"/> the texture and be sure that the <strong class="screenText">Wrap Mode</strong> property of the texture is set to <strong class="screenText">Repeat</strong>, which will allow us to repeat the texture as we did in the terrain because the idea is to use this shader to cover large water areas:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_28_PE.png" alt="A picture containing text, font, screenshot, white  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.28: Texture Repeat mode</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">In the <strong class="screenText">Water Shader Graph</strong>, right-click in an empty area of the Shader Graph and select <strong class="screenText">Create Node</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_29_PE.png" alt="A picture containing text, font, screenshot, graphics  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.29: Shader Graph Create Node option</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In the <strong class="screenText">Search</strong> box, write <code class="inlineCode">Sample texture</code> and all of the sampler nodes will show up. Double-click <strong class="screenText">SampleTexture2D</strong>. If for some reason you can’t double-click the option, right-click on it first and then try again. There is a known bug in this tool and this is <a id="_idIndexMarker652"/>the workaround:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_30_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.30: Sample texture node search</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Click in the circle to the left of the <strong class="screenText">Texture</strong> input pin of the <strong class="screenText">Sample Texture 2D</strong> node. It will allow us to pick a texture to sample—just select the <strong class="screenText">water</strong> one. You can see that the texture can be previewed in the bottom part of the node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_31_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.31: Sample texture node with a texture in its input pin</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Drag the <a id="_idIndexMarker653"/><strong class="screenText">RGBA</strong> output pin from the <strong class="screenText">Sample Texture 2D</strong> node to the <strong class="screenText">Base Color</strong> input pin of the Master Node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_32_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.32: Connecting the results of texture sampling with the Base Color pin of the Master Node</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Click<a id="_idIndexMarker654"/> the <strong class="screenText">Save Asset</strong> button in the top-left part of the Shader Graph editor and see the changes in the <strong class="screenText">Scene</strong> view:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_33_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.33: Results of applying a texture in our Shader Graph</p>
    <p class="normal">As you can see, the texture is properly applied to the model, but if you take into account that the default plane has a size of 10x10 meters, the ripples of the water seem too big. So, let’s tile the texture!</p>
    <p class="normal">To do this, we<a id="_idIndexMarker655"/> need to change the UVs of the model, making them bigger. You may imagine that bigger UVs mean the texture should also get bigger, but take into account that we are not making the object bigger; we are just modifying the UV.</p>
    <p class="normal">In the same object area, we will display more of the texture area, meaning that in the bigger texture sample area (achieved by bigger UVs), repetitions of the texture may appear. To do so, follow the next steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Right-click in any empty space and click <strong class="screenText">New Node</strong> to search for the <strong class="screenText">UV</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_34_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.34: Searching for the UV node</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Using the same method, create a <strong class="screenText">Multiply</strong> node.</li>
      <li class="numberedList">Drag the <strong class="screenText">Out</strong> pin of the <strong class="screenText">UV</strong> node to the <strong class="screenText">A</strong> pin of the <strong class="screenText">Multiply</strong> node to connect them.</li>
      <li class="numberedList">Set the <strong class="screenText">B</strong> pin input value of <strong class="screenText">Multiply</strong> to <code class="inlineCode">4</code>,<code class="inlineCode">4</code>,<code class="inlineCode">4</code>,<code class="inlineCode">4</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_35_PE.png" alt="A picture containing screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.35: Multiplying the UVs by 4</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Drag the <strong class="screenText">Out</strong> pin of the <strong class="screenText">Multiply</strong> node to <strong class="screenText">UV</strong> of the <strong class="screenText">Sample Texture 2D</strong> node to connect <a id="_idIndexMarker656"/>them:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_36_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.36: Using the multiplied UVs to sample the texture</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">If you save the graph and go back to the <strong class="screenText">Scene</strong> view, you can see that now the ripples are smaller, because we have tiled the UVs of our model. You can also see that in the preview of the <strong class="screenText">Sampler Texture 2D</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_37_PE.png" alt="A picture containing screenshot, aqua, turquoise, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.37: Results of the model’s UV multiplication</p>
    <p class="normal">Another interesting <a id="_idIndexMarker657"/>effect we can do now is to apply an offset to the texture to move it. The idea is that even if the plane is not actually moving, we will simulate the flow of the water through it, moving just the texture. Remember, the responsibility of determining the part of the texture to apply to each part of the model belongs to the UV, so if we add values to the UV coordinates, we will be moving them, generating a texture sliding effect. To do so, let’s do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an <strong class="screenText">Add</strong> node to the right of the <strong class="screenText">UV</strong> node.</li>
      <li class="numberedList">Connect the <strong class="screenText">Out</strong> pin of <strong class="screenText">UV</strong> to the <strong class="screenText">A</strong> pin of the <strong class="screenText">Add</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_38_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.38: Adding values to the UVs</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Create a <strong class="screenText">Time</strong> node at the left of the <strong class="screenText">Add</strong> node.</li>
      <li class="numberedList">Connect the <strong class="screenText">Time</strong> node <a id="_idIndexMarker658"/>to the <strong class="screenText">B</strong> pin of the <strong class="screenText">Add</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_39_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.39: Adding Time to the UVs</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Connect the <strong class="screenText">Out</strong> pin of the <strong class="screenText">Add</strong> node to the <strong class="screenText">A</strong> input pin of the <strong class="screenText">Multiply</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_40_PE.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.40: Added and multiplied UVs as an input of the sample texture</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Save and see <a id="_idIndexMarker659"/>the water moving in the <strong class="screenText">Scene</strong> view. If you don’t see it moving, click the layers icon in the top bar of the scene and check <strong class="screenText">Always Refresh</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_41_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.41: Enabling Always Refresh to preview the effect</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">If you feel the water is moving too fast, try using the multiplication node to make the<a id="_idIndexMarker660"/> time a smaller value. I recommend you try it by yourself before looking at the next screenshot, which has the answer:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_42_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.42: Multiplication of time to move the texture more slowly</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">If you feel the graph is too big, try to hide some of the node previews by clicking on the <strong class="screenText">up</strong> (<strong class="screenText">^</strong>) arrow that appears on the preview when you move the mouse over it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_43_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.43: Hiding the preview from the graph nodes</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">Also, you<a id="_idIndexMarker661"/> can hide unused pins by selecting the node and clicking the arrow at its top right:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_44_PE.png" alt="A picture containing screenshot, text, font, number  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.44: Hiding unused pins from the graph nodes</p>
    <p class="normal">So, to recap, first we added the time to the UV to move it and then multiplied the result of the moved UV to make it bigger to tile the texture. It is worth mentioning that there’s a <strong class="screenText">Tiling and Offset</strong> node that does all of this process for us, but I wanted to show you how a simple multiplication to scale the UV and an add operation to move it generates a nice effect; you can’t imagine all of the possible effects you can achieve with other simple mathematical nodes! Actually, let’s explore other usages of mathematical nodes to combine textures in the next section.</p>
    <div class="note">
      <p class="normal">When learning DirectX, making shaders was harder given you needed to learn a less user-friendly language called HLSL. While for most cases Shader Graph is all you need, I don’t regret at all learning such shader languages, as they have access to more advanced features that node-based shading languages usually don’t, and they give you a deeper understanding of the internals of the GPU. For more info about how to create code-based shaders in URP, you can check this: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html"><span class="url">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html</span></a></p>
    </div>
    <h2 id="_idParaDest-150" class="heading-2">Combining textures</h2>
    <p class="normal">Even though <a id="_idIndexMarker662"/>we have used nodes, we haven’t created anything that can’t be created using regular shaders, but that’s about to change. So far, we can see the water moving, but it still looks static, and that’s because the ripples are always the same. We have several techniques to generate ripples; the simplest one would be to combine two water textures moving in different directions to mix their ripples. Actually, we can simply use the same texture, just flipped to save some memory. To combine the textures, we will sum them and then divide them by 2, so basically, we are calculating the average of the textures! Let’s do that by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select all of the nodes between <strong class="screenText">Time</strong> and <strong class="screenText">Sampler 2D</strong> (including them) by creating a selection rectangle by clicking in any empty space in the graph, holding and dragging the click, and then releasing when all target nodes are covered:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_45_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.45: Selecting several nodes</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Right-click and select <strong class="screenText">Copy</strong>, and then again right-click and select <strong class="screenText">Paste</strong>, or use the classic <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em>, <em class="keystroke">Ctrl</em> + <em class="keystroke">V</em> commands (<em class="keystroke">Command</em> + <em class="keystroke">C</em>, <em class="keystroke">Command</em> + <em class="keystroke">V</em> on Mac).</li>
      <li class="numberedList">Move the<a id="_idIndexMarker663"/> copied nodes below the original ones:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_46_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.46: Duplication of nodes</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">For the copied nodes, set the <strong class="screenText">B</strong> pin of the <strong class="screenText">Multiply</strong> node connected to <strong class="screenText">Sample Texture 2D</strong> to <code class="inlineCode">-4</code>,<code class="inlineCode">-4</code>,<code class="inlineCode">-4</code>,<code class="inlineCode">-4</code>. You can see that that flipped the texture.</li>
      <li class="numberedList">Also, set the <strong class="screenText">B</strong> pin of the <strong class="screenText">Multiply</strong> node connected to the <strong class="screenText">Time</strong> node to <code class="inlineCode">-0.1</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_47_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.47: Multiplication of values</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Create <a id="_idIndexMarker664"/>an <strong class="screenText">Add</strong> node at the right of both <strong class="screenText">Sampler Texture 2D</strong> nodes and connect the outputs of those nodes to the <strong class="screenText">A</strong> and <strong class="screenText">B</strong> input pins of the <strong class="screenText">Add</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_48_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.48: Adding two textures</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">You can<a id="_idIndexMarker665"/> see that the resulting combination is too bright because we have summed up the intensity of both textures, so let’s fix that by multiplying the <strong class="screenText">Out</strong> of the <strong class="screenText">Add</strong> node by <code class="inlineCode">0.5,0.5,0.5,0.5</code>, which will divide each resulting color channel by 2, averaging the color. You can also experiment with what happens when you set different values for each channel if you want, but for our purposes, <code class="inlineCode">0.5</code> is the proper value for each channel:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_49_PE.png" alt="A picture containing screenshot, text, multimedia software, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.49: Dividing the sum of two textures to get the average</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Connect<a id="_idIndexMarker666"/> the <strong class="screenText">Out</strong> pin of the <strong class="screenText">Multiply</strong> node to the <strong class="screenText">Base Color</strong> pin of the <strong class="screenText">Master</strong> Node to apply all of those calculations to the color of the object.</li>
      <li class="numberedList">Save the asset and see the results in the <strong class="screenText">Scene</strong> view:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_50_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.50: Results of texture blending</p>
    <p class="normal">You can keep adding nodes to make the effect more diverse, such as using <strong class="screenText">Sine</strong> nodes (which will execute the trigonometry sine function) to apply non-linear movements, but I will let you learn that by experimenting with it by yourself. For now, we will stop here. As always, this topic deserves a full book, and the intention of this chapter is to give you a small taste <a id="_idIndexMarker667"/>of this powerful Unity tool. I recommend you look for other Shader Graph examples on the internet to learn other usages of the same nodes and, of course, new nodes. One thing to consider here is that everything we have done so far is basically applied to the Fragment Shader stage of the shader pipeline we discussed earlier. Now, let’s use the Blending shader pipeline stage to apply some transparency to the water.</p>
    <div class="note">
      <p class="normal">For more examples of shader graphs, I recommend checking out the following link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html"><span class="url">https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html</span></a></p>
    </div>
    <h2 id="_idParaDest-151" class="heading-2">Applying transparency</h2>
    <p class="normal">Before <a id="_idIndexMarker668"/>declaring our effect finished, a little addition we can do is to make the water a little bit transparent. Remember that the shader pipeline has a blending stage, which has the responsibility of blending each pixel of our model into the image being rendered in this frame. The idea is to make our Shader Graph modify that stage to apply <strong class="screenText">Alpha Blending</strong>, a blending mode that combines our model and the previously rendered models based on the <code class="inlineCode">Alpha</code> value of our model.</p>
    <p class="normal">To get that effect, take the following steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Look for the <strong class="screenText">Graph Inspector</strong> window floating around. If you don’t see it, click the <strong class="screenText">Graph Inspector</strong> button in the top-right part of the Shader Graph editor. Try also expanding the Shader Graph window to display it in case it’s hidden behind the right bound of the window.</li>
      <li class="numberedList">Click the <strong class="screenText">Graph Settings</strong> tab.</li>
      <li class="numberedList">Set the <strong class="screenText">Surface Type</strong> property to <strong class="screenText">Transparent</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Blending Mode</strong> property to <strong class="screenText">Alpha</strong> if it isn’t already at that value:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_51_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.51: Graph Inspector transparency settings</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Set the <strong class="screenText">Alpha</strong> input <a id="_idIndexMarker669"/>pin of the Master Node to <code class="inlineCode">0.5</code>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_52_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.52: Setting Alpha of the Master Node</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Save the Shader Graph and see the transparency applied in the <strong class="screenText">Scene</strong> view. If you can’t see the effect, just put a cube into the water to make the effect more evident:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_53_PE.png" alt="A black and white cube on a tile floor  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.53: Shadows from the water being applied to a cube</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">You can <a id="_idIndexMarker670"/>see the shadows that the water is casting on our cube because Unity doesn’t know the object is transparent and hence casts shadows. Click on the water plane and look for the <strong class="screenText">Mesh Renderer</strong> component in the Inspector. If you don’t see the shadow, click the lightbulb at the top of the <strong class="screenText">Scene</strong> view.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_54_PE.png" alt="A screen shot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.54: Enabling lights in the Scene view</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">In the <strong class="screenText">Lighting</strong> section, set <strong class="screenText">Cast Shadows</strong> to <strong class="screenText">Off</strong>; this will disable shadow casting from the plane on the parts of the cube that are underwater:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_10_55.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 10.55: Disabling shadow casting</p>
    <p class="normal">Adding<a id="_idIndexMarker671"/> transparency is a simple process but it has its caveats, like the shadow problem, and in more complex scenarios, it can have other problems, like increasing overdraw, meaning the same pixel needs to be drawn several times (the pixel belonging to the transparent object, and one of the objects behind). I would suggest you avoid using transparency unless it is necessary. Actually, our water can live without transparency, especially when we apply this water to the river basin around the base, because we don’t need to see the part under the water; but the idea is for you to know all of your options. In the next screenshot, you can see how we have put a giant plane with this effect below our base, big enough to cover the entire basin:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_56_PE.png" alt="A picture containing grass, screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.56: Using our water in the main scene</p>
    <div class="note">
      <p class="normal">I have a friend who always jokes about me, saying that everything can be solved with a shader, but jokes aside, it is an extremely useful tool if used cleverly. In the past, developers used shaders to do non-graphics-related processing, like mathematics simulations, reading the generated pixels as the needed results. That led to what today is known as compute shaders, which essentially refers to running custom programs on a GPU to do calculations, leveraging the power of the GPU. Of course, Unity supports compute shaders; you can learn more about them here: <a href="https://docs.unity3d.com/Manual/class-ComputeShader.html"><span class="url">https://docs.unity3d.com/Manual/class-ComputeShader.html</span></a></p>
    </div>
    <p class="normal">From now on, we <a id="_idIndexMarker672"/>can do plenty of things with our shader. We can think about simulating water foam for the pixels that are higher than a certain height, leveraging the vertex animation we added. We could also change the water scrolling direction via scripting or using sine nodes. The sky is the limit!</p>
    <p class="normal">Now that we have modified how the object looks through the <strong class="screenText">Fragment</strong> node section, let’s discuss how to use the <strong class="keyWord">Vertex</strong> section to apply a mesh animation to our water.</p>
    <h2 id="_idParaDest-152" class="heading-2">Creating vertex effects</h2>
    <p class="normal">So far, we <a id="_idIndexMarker673"/>have applied water textures to our water, but it’s still a flat plane. We can go further than that and make the ripples not only via textures but also by animating the mesh. To do so, we will apply the noise texture we used at the beginning of the chapter in the shader, but instead of using it as another color to add to the <strong class="keyWord">Base Color</strong> of the shader, we will instead use it to offset the <strong class="screenText">Y</strong> position of the vertexes of our plane.</p>
    <p class="normal">Due to the chaotic nature of the noise texture, the idea is that we will apply a vertical offset to different parts of the model, so we can emulate the ripples:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_57_PE.png" alt="A picture containing line, symmetry, square, black and white  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.57: Default plane mesh subdivided into a grid of 10x10 with no offset</p>
    <p class="normal">To accomplish something like this, you can modify the <strong class="screenText">Vertex</strong> section of your shader to look like the following:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_58_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.58: Ripples vertex effect</p>
    <p class="normal">In the graph, you<a id="_idIndexMarker674"/> can see how we are creating a vector whose <em class="italic">y</em> axis depends on the noise texture we downloaded at the beginning of the chapter. The idea behind that is to create a vector pointing upward whose length is proportional to the grayscale factor of the texture; the whiter the pixel of the texture, the longer the offset. This texture has an irregular yet smooth pattern so it can emulate the behavior of the tide.</p>
    <p class="normal">Please notice that, here, we used <strong class="screenText">Sample Texture 2D LOD</strong> instead of <strong class="screenText">Sample Texture 2D</strong>; the latter does not work in the <strong class="screenText">Vertex</strong> section, so keep that in mind.</p>
    <p class="normal">Then we multiply the result by <code class="inlineCode">0.3</code> to reduce the height of the offset to add, and then we add the result to the <strong class="screenText">Position</strong> node. See that the <strong class="screenText">Space</strong> property of the <strong class="screenText">Position</strong> node is set to <strong class="screenText">Object</strong> mode. We need that mode to work with the <strong class="screenText">Vertex</strong> section of the Shader Graph (we discussed <em class="italic">World</em> and <em class="italic">Local</em> spaces before in <em class="chapterRef">Chapter 2</em>, <em class="italic">Crafting Scenes and Game Elements</em>, but you can also search <code class="inlineCode">Object vs World Space</code> on the internet for more info about this). Finally, the result is connected to the <strong class="screenText">Position</strong> node of the <strong class="screenText">Vertex</strong> section.</p>
    <p class="normal">If you save, you will see something like the following image:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_59_PE.png" alt="A picture containing aqua, turquoise, pattern, teal  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.59: Ripples vertex effect applied</p>
    <p class="normal">Of course, in <a id="_idIndexMarker675"/>this case, the ripples are static because we didn’t add any time offset to the UV as we did before. In the following screenshot, you can see how to add that, but before looking at it, I recommend you try to resolve it first by yourself as a personal challenge:</p>
    <figure class="mediaobject"><img src="../Images/B21361_10_60_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.60: Animated ripples vertex effect graph</p>
    <p class="normal">As you can see, we<a id="_idIndexMarker676"/> are again taking the original UV and adding the time multiplied by any factor so it will slowly move, the same as we did previously with our water texture. You can keep playing around with this, changing how this looks with different textures, multiplying the offset to increase or reduce the height of the ripples, applying interesting math functions like sine, and so much more; but for now, let’s finish with this.</p>
    <h1 id="_idParaDest-153" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed how a shader works in the GPU and how to create our first simple shader to achieve a nice water effect. Working with shaders is a complex and interesting job, and in a team, there is usually one or more people in charge of creating all of these effects, in a position called technical artist; so, as you can see, this topic can expand to a whole career. Remember, the intention of this book is to give you a small taste of all the possible roles you can take in the industry, so if you really liked this role, I suggest you start reading shader-exclusive books. You have a long but super interesting road in front of you.</p>
    <p class="normal">Enough shaders for now! In the next chapter, we will look at how to improve our graphics and create visual effects with particle systems!</p>
  </div>
  <div id="_idContainer540">
    <h1 id="_idParaDest-154" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev"><span class="url">https://packt.link/unitydev</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>