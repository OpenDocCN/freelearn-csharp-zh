- en: Chapter 4. Rigidbody Types and Their Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the types of Rigidbody components and their
    properties. To detect collision, add gravity, and several other Physics functionalities,
    a game object must have a Rigidbody component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of Rigidbody components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties of Rigidbody components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example using Rigidbody components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can handle a Rigidbody component using a script as well as by manually applying
    linear and angular velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For accurate Physics calculation, a Rigidbody component requires a collider
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Rigidbody components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We enable our game objects to act under the control of Physics using Rigidbodies.
    Here, we will learn how to use and handle a Rigidbody component. A Rigidbody can
    be handled in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Physics Rigidbody
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinematic Rigidbody
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics Rigidbody
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To influence a game object by gravity or forces, the game object must have a
    Rigidbody. When a Rigidbody is completely controlled by the engine, it is called
    a Physics Rigidbody. We can manually apply forces and torque to handle linear
    and angular velocity of a game object. Manual implementation of forces and torque
    gives you the freedom to get the desired effect. Let's look at an example of a
    Rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: An example of creating a Physics Rigidbody
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the following steps to apply a Physics Rigidbody:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a new scene and save it as `Physics Rigidbody`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Cube** game object, as shown in the following screenshot:![An example
    of creating a Physics Rigidbody](img/00044.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable our game objects to act under the control of Physics, we use Rigidbodies.
    Add the **Rigidbody** component to the cube game object, as shown in the following
    screenshot:![An example of creating a Physics Rigidbody](img/00045.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, make sure that the **Is Kinematic** property is
    unchecked. If we enable **Is Kinematic**, the object can only be manipulated by
    its Transform property. Generally, we use this for moving platforms or if we want
    to animate a Rigidbody that has a HingeJoint attached.![An example of creating
    a Physics Rigidbody](img/00046.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the previous steps, we can get the desired effect using the different
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Kinematic Rigidbody
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we check the **Is Kinematic** property of a Rigidbody, it is known as a
    Kinematic Rigidbody. We cannot apply forces or torque manually to a Kinematic
    Rigidbody. We can move a Kinematic Rigidbody by changing the values of a GameObject's
    Transform component. This is useful for moving platforms or animated HingeJoint
    GameObjects where the engine does not handle the object directly and where we
    can manipulate its Transform property as per our requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Kinematic Rigidbody](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can use this property by checking it in the **Inspector** panel, as shown
    in the previous screenshot. Now, we will learn about the properties of a Rigidbody
    and their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of Rigidbody components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get familiar with the properties of a Rigidbody:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mass**: If we look at the **Inspector** panel of a Rigidbody component, we
    will see **Mass** as one of the listed properties. This property of a Rigidbody
    defines the mass that should be based on the relative size and density of the
    object that is attached to it. The mass of a Rigidbody defines how much force
    is required to move the Rigidbody fast or slow. We can calculate the force using
    Newton''s law of motion as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F=ma*, that is, Force = Mass x Acceleration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Drag**: This property defines the linear velocity due to air resistance.
    For example, if we need to add an outer-space behavior to a game object, we set
    this value as `0`. An object with mass `1` should have a **Drag** value of `998`
    to resist the force of gravity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drag**: This property defines the angular velocity due to air resistance.
    For example, if we need to add an infinitely-spinning-unless-used external force
    behavior on a game object, we set this value as `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Gravity**: If we want our game object to be affected by gravity, we use
    this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is Kinematic**: To add kinematic behavior, we set this to true. By setting
    its behavior to true, we can directly change the position and orientation of the
    Rigidbody using its Transform properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpolate**: Using this property, we make a Rigidbody move smoothly. We
    can adjust the **Interpolate** method using **None**, **Interpolate**, and **Extrapolate**,
    as seen in the following screenshot:![Properties of Rigidbody components](img/00048.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **None**, no interpolation is applied; using **Interpolate**, we smoothly
    transform based on its previous frame; and in **Extrapolate**, we smoothly transform
    based on its estimated next frame.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Collision Detection**: Using this property, we can determine how the Rigidbody
    will perform collision detection with other Rigidbodies. This property consists
    of the following subproperties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discreet**: By setting this property, we use the simplest form of collision
    detection. At each frame, an intersection test is done. The drawback of this property
    is that small, fast moving objects will pass directly through solid objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous**: By setting this property, a Rigidbody performs continuous collision
    detection against all the other static colliders.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Dynamic**: By setting this property, a Rigidbody detects the collision
    with fast moving objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constraints**: This property is used for Physics Rigidbodies. Using this
    property, we can make the position and orientation of a Rigidbody constraint.
    This property consists of the following subproperties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreezePosition**: By setting this property, a Rigidbody constrains the linear
    motion'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreezeRotation**: By setting this property, the rotation of a Rigidbody is
    prevented'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Example using a Rigidbody
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that in our game, we require a cube to be our character. In this
    case, we won''t be using the character controller. Let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and save it as `Rigidbody example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the following screenshot, create a **Plane** game object and set
    its properties to position `0` (all axes), rotation `0` (all axes), and scale
    `20`, `1`, `20` for the *x*, *y*, and *z* axes respectively:![Example using a
    Rigidbody](img/00049.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Cube** game object and a Rigidbody Collider. Place it above the plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the following screenshot, add material to the red cube:![Example
    using a Rigidbody](img/00050.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another **Cube** game object. I have used a white cube without a Rigidbody.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another **Cube** object without a Rigidbody. I have used a blue cube,
    as shown in the following screenshot, and have set the **Is Trigger** property
    to true:![Example using a Rigidbody](img/00051.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have set the **Is Trigger** property in the
    blue cube.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new script and save it as `TriggerController.js`; add it to the **Trigger
    Collider** game object and put the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will show the logon events in the console window: **OnTriggerEnter**
    and **OnTriggerExit**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's move to the next step. Create a new script and save it as `RigidbodyController.js`.
    Add it to the **Red Cube** game object, as shown in the following screenshot:![Example
    using a Rigidbody](img/00052.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `RigidbodyController.js` script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run the project and you will see the Rigidbody actions on the red cube by clicking
    on the **Jump** button.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have learned how to apply actions on a Rigidbody
    using scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the types of Rigidbodies and their properties.
    We have seen the properties and uses of the Physics Rigidbody and Is Kinematic
    Rigidbody. We have learned how to implement actions on them using scripts. In
    the next chapter, we will learn about the types of joints and their properties.
    We will also see how we can implement joints on the game objects using different
    examples.
  prefs: []
  type: TYPE_NORMAL
