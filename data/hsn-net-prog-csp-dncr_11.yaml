- en: Sockets and Ports
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字和端口
- en: 'At this point, we understand how to handle data streams from remote hosts,
    process those streams asynchronously on background threads, and handle the errors
    that arise from processing that data. Now we''re going to look at the most primitive
    connections you can make with a remote host. In this chapter, we''ll be looking
    at the physical ports through which your machine is going to do this, and we''ll
    be looking at the concept of a socket: the software structure that exposes access
    to a port for network interaction. We''ll examine the WinSocks library for instantiating
    and working with those ports, and we''ll consider the various ways sockets can
    be leveraged by your application code for efficient, low-level communication with
    a target host.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经了解了如何处理来自远程主机的数据流，如何在后台线程上异步处理这些流，以及如何处理处理这些数据时出现的错误。现在，我们将探讨你可以与远程主机建立的最原始的连接。在本章中，我们将探讨你的机器将要通过这些物理端口来完成这项工作，并且我们将探讨套接字的概念：一种软件结构，它暴露了对端口的访问以进行网络交互。我们将检查WinSocks库以实例化和使用这些端口，并考虑各种方式，你的应用程序代码可以利用套接字与目标主机进行高效、低级别的通信。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the `System.Net.Sockets` classes serve as the C# interface to your hardware-level
    network APIs for communication with external machines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net.Sockets`类如何作为C#接口服务于你的硬件级网络API，用于与外部机器通信'
- en: How to establish a connection to a socket exposed by another machine on your
    network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何连接到网络上另一台机器暴露的套接字
- en: How to program server applications that expose sockets to accept external connection
    requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写暴露套接字以接受外部连接请求的服务器应用程序
- en: The nature of communicating over serial ports and exposing serial ports to accept
    serial data for processing, and how this can open you up to interesting use cases
    for C# and .NET Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在串行端口上进行通信的性质，以及如何将串行端口暴露出来以接受用于处理的数据，以及这如何为你打开C#和.NET Core的有趣用例。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will have a number of samples and driver programs to demonstrate
    the concepts discussed, each of which will be available here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    8](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%208).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包含多个示例和驱动程序程序来演示所讨论的概念，每个都将在此处提供：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%208](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%208)。
- en: As always, clone the repository locally and begin playing with the source code,
    or writing your own along with the topics in the chapter to get comfortable with
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在本地克隆存储库，开始与源代码一起玩耍，或者编写你自己的代码，与章节中的主题一起熟悉它。
- en: 'We''ll also start using external tools to test and inspect the behavior of
    a sample API. For this, you''ll need to download and install either Postman, which
    can be found here: [https://www.getpostman.com/apps/](https://www.getpostman.com/apps) ,Or
    you''ll need the Insomnia REST client, which can be found here[:](https://www.getpostman.com/apps)
    [https://insomnia.rest/.](https://insomnia.rest/)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将开始使用外部工具来测试和检查示例API的行为。为此，你需要下载并安装Postman，它可以在以下位置找到：[https://www.getpostman.com/apps](https://www.getpostman.com/apps)，或者你需要Insomnia
    REST客户端，它可以在以下位置找到：[:](https://www.getpostman.com/apps) [https://insomnia.rest/](https://insomnia.rest/)。
- en: The feature set of each of these applications is almost identical, and each
    will allow you to send arbitrary requests to a local API through an intuitive
    UI. We'll be using them to test out our web software going forward, and I'd recommend
    spending at least a little time getting familiar with some of the basic functionality
    of whichever tool you choose to use. Throughout this chapter I'll be presenting
    screenshots captured from Postman, but that's not an endorsement of Postman over
    Insomnia, and the steps and UI when following along should be virtually identical
    in both.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序的功能集几乎完全相同，每个都将允许你通过直观的用户界面向本地API发送任意请求。我们将使用它们来测试我们的网络软件，并建议你至少花一点时间熟悉你选择的工具的一些基本功能。在本章中，我将展示从Postman捕获的屏幕截图，但这并不是对Postman优于Insomnia的认可，并且跟随步骤和UI在两者中应该是几乎相同的。
- en: 'Finally, we''ll be using Docker to demonstrate port mapping. While you could
    manage an understanding of the specific concepts of this chapter without this
    tool, I''d strongly recommend downloading and familiarizing yourself with it.
    It is core to the modern web application development experience, and you will
    only benefit from practicing with it. This chapter provides one of the best opportunities
    to do so, and I''d certainly encourage you to try. Docker can be downloaded here:
    [https://hub.docker.com/editions/community/docker-ce-desktop-windows](https://hub.docker.com/editions/community/docker-ce-desktop-windows).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Docker来演示端口映射。虽然您可以在没有这个工具的情况下理解本章的具体概念，但我强烈建议您下载并熟悉它。它是现代Web应用程序开发体验的核心，您将从中受益匪浅。本章提供了最好的实践机会之一，我肯定会鼓励您尝试。Docker可以在此处下载：[https://hub.docker.com/editions/community/docker-ce-desktop-windows](https://hub.docker.com/editions/community/docker-ce-desktop-windows)。
- en: Check out the following video to see the code in action: [http://bit.ly/2HYmX49](http://bit.ly/2HYmX49)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HYmX49](http://bit.ly/2HYmX49)
- en: Sockets versus ports
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字与端口
- en: The first thing we should do as we look at these connection mechanisms is to
    distinguish between the two. While they are two words identifying a common hardware
    interaction, the software or abstract concepts each term identifies are actually
    mutually exclusive. These terms aren't as interchangeable as abstract class and
    interface were in previous chapters, so when we use each term, it will be for
    a specific purpose, and you'll need to know what it is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看这些连接机制时，我们应该首先区分这两者。虽然它们是两个标识常见硬件交互的词，但每个术语所标识的软件或抽象概念实际上是相互排斥的。这些术语不像之前章节中的抽象类和接口那样可以互换，因此当我们使用每个术语时，它将具有特定的目的，您需要知道它是什么。
- en: Ports – a hardware interface
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口 – 硬件接口
- en: As we already know, machines are identified by their IP address, or the hostname
    mapped to that IP address in the DNS registry. So for any given connection between
    machines to be resolved, the initiating host will ultimately need the underlying
    IP address of the target host. However, simply specifying the target IP address
    is insufficient to target a service or application running on the host. It only
    gives us the location of the host itself. That's where ports come in. A port is
    a two byte unsigned integer that identifies a running process on a target machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，机器通过其IP地址或DNS注册表中映射到该IP地址的主机名来识别。因此，对于任何给定机器之间的连接要得到解决，发起主机最终需要目标主机的底层IP地址。然而，仅指定目标IP地址不足以针对在主机上运行的服务或应用程序。它只给出了主机本身的位置。这就是端口的作用所在。端口是一个表示目标机器上运行进程的两个字节的无符号整数。
- en: Each application on your host that will interact with remote processes must
    do so on a designated port. Furthermore, no two applications can listen on the
    same port. Every time you want to start up your application and designate it as
    listening for network requests, you must assign it to an unsigned port on your
    machine. If you've ever tried to run multiple instances of an API project on the
    `8099` or `8080` port (or any other common listening port) on your local machine,
    you'll have seen the startup failure message indicating that the target port is
    already in use. That port is occupied, so you'll have to find a different one
    to process transactions targeting your new application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主机上的每个将与远程进程交互的应用程序都必须在指定的端口上进行操作。此外，没有任何两个应用程序可以监听相同的端口。每次您想要启动应用程序并将其指定为监听网络请求时，您都必须将其分配到您机器上的一个无符号端口。如果您曾经尝试在本地机器上的`8099`或`8080`端口（或任何其他常见监听端口）上运行多个API项目的实例，您将看到启动失败的消息，表明目标端口已被占用。该端口已被占用，因此您必须找到一个不同的端口来处理针对您新应用程序的事务。
- en: The reason for this should be fairly obvious. If you want to host multiple services
    on a single device, you will need some way of distinguishing between incoming
    requests for service *A* and incoming requests for service B. By designating mutually-exclusive
    listening ports for each hosted application, you move the burden of proper routing
    back to the client. This is perfectly acceptable, since the client already has
    to keep track of the remote hosts URI, and if you remember from our earlier chapter,
    the port number is simply another component of that API. The alternative would
    require an application to serve as an intermediary between your hosted listening
    applications and all incoming network requests. Such an application would have
    to have reasonable knowledge of the state or expectations of each listening application,
    then it will parse every incoming request to identify which expectation the following
    requests meets. It would be just a whole mess of state management that would become
    infeasible incredibly quickly. So instead, we simply add 2-byte address suffixes
    to specify the target listening application built directly into our URI specification.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种原因应该是相当明显的。如果你想在一个设备上托管多个服务，你需要一种方法来区分对服务A的入站请求和对服务B的入站请求。通过为每个托管应用程序指定互斥的监听端口，你将正确的路由负担转回到客户端。这是完全可以接受的，因为客户端已经需要跟踪远程主机的URI，而且如果你记得我们之前章节的内容，端口号只是该API的另一个组成部分。另一种选择需要应用程序作为你的托管监听应用程序和所有入站网络请求之间的中介。这样的应用程序必须对每个监听应用程序的状态或期望有合理的了解，然后它将解析每个入站请求以确定哪些期望被后续请求满足。这将变成一大堆状态管理，很快就会变得不可行。所以，我们只是在我们的URI规范中添加2字节地址后缀来指定目标监听应用程序，它是直接嵌入到我们的URI规范中的。
- en: Reserved ports
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留端口
- en: If you know the valid integer values of an unsigned 2-byte `int`, you already
    know the full range of possible exposed ports for a machine. Using this data type,
    a port specification could have a value from `0` to `65535`. However, just because
    a port designation falls within the range for the data-type of a port, it doesn't
    mean you should attempt to listen on it. There are in fact a number of port ranges
    that your user-application code should never attempt to listen on. These are designated
    as reserved ports and typically handle very specific functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已知一个无符号2字节`int`的有效整数值，那么你已经知道了机器可能暴露的所有端口的完整范围。使用这种数据类型，端口号的指定值可以从`0`到`65535`。然而，仅仅因为端口号的指定值落在这个数据类型允许的范围内，并不意味着你应该尝试监听它。实际上，有一些端口号范围是你用户应用程序代码绝对不应该尝试监听的。这些被指定为保留端口，通常处理非常特定的功能。
- en: The first set of ports that are reserved, and thus unavailable for you to register
    your application to, are called the **well-known ports**. These ports fall between
    `0` and `1023`, and are used for anything from DNS address resolution (the port `53` 
    used to make sure there is still a machine listening at the address listed in
    the registry) to FTP data and control ports (the ports `20` and `21` , respectively).
    If you've done any sort of network programming prior to reading this book, you're
    already likely to be familiar with the fact that the `80` port is the designated
    port for incoming HTTP requests and the `443` port is reserved for HTTPS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组保留的端口，因此你不能注册你的应用程序，被称为**知名端口**。这些端口介于`0`和`1023`之间，用于从DNS地址解析（用于确保在注册表中列出的地址上仍然有机器在监听，该端口号为`53`）到FTP数据和控制端口（分别为端口号`20`和`21`）。如果你在阅读这本书之前做过任何形式的网络编程，你很可能已经熟悉了这样一个事实，即`80`端口是入站HTTP请求指定的端口，而`443`端口是为HTTPS保留的。
- en: The other list of ports that you won't be able to register your application
    to is what's known as the **dynamic port range**. Dynamic ports, or private ports,
    are used to establish connections for private or customized services or interactions,
    or used for temporary **Transmission Control Protocol** (**TCP**) or **User Datagram
    Protocol** (**UDP**) interactions between two hosts. When used in a temporary
    context to service a brief need from either machine, the designated port is known
    as an **ephemeral** **port**. These ports cannot be registered with the **Internet
    Assigned Numbers Authority** (**IANA**) for use in general-purpose network interactions
    on a given host. The range for these ports begins at port number `49152` and ends
    at `65535`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法注册应用程序的另一组端口被称为**动态端口范围**。动态端口，或称为私有端口，用于建立私有或定制服务或交互的连接，或用于两个主机之间的临时**传输控制协议**（**TCP**）或**用户数据报协议**（**UDP**）交互。当在临时环境中为机器的短暂需求提供服务时，指定的端口被称为**临时端口**。这些端口不能在给定的主机上注册给**互联网数字分配机构**（**IANA**）用于通用网络交互。这些端口的范围从端口号`49152`开始，到`65535`结束。
- en: The IANA is a non-profit organization responsible for managing the allocation
    of IP addresses, among other things. As I mentioned in [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml),
    *Networks in a Nutshell*, a centralized system for standards (and names) is important
    to guarantee that every device routes requests for one IP address to the same
    device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网数字分配机构**（**IANA**）是一个负责管理IP地址分配（以及其他事项）的非营利组织。正如我在[第1章](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml)，“网络概要”中提到的，一个集中化的标准（和名称）系统对于确保每个设备将一个IP地址的请求路由到同一设备非常重要。'
- en: With that specification, that appears to leave everything between and including
    `1024` and `49151` as available for use by your applications. These are what's
    known as **registered ports***.* They are available for assignment by user applications
    or system services as needed, and won't interfere with default behavior from your
    hardware or other connected hosts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据该规范，这似乎意味着在`1024`和`49151`之间以及包括这两个端口号的所有内容都可用于您的应用程序。这些被称为**已注册端口**。它们可根据需要由用户应用程序或系统服务分配，并且不会干扰您的硬件或其他连接主机的默认行为。
- en: It probably seems like configuring your application to listen within the registered
    port range will be sufficient for use. However, that's still not *quite* the case.
    If you've ever run a JBoss application server (back in the bad old days of bloated
    application servers like JBoss, you probably remember accessing your locally-hosted
    development environment by accessing `http://localhost:8080/my-java-application`,
    or at least that's what I used to have to do. The reason JBoss always configured
    that port specifically is because it actually serves as an alias for the `80`
    port, the HTTP port. The same is true for `8008`. So, even though the ports fall
    within the registered port range, there are specific expectations around their
    behavior. It really just provides a value within the registered ports range for
    users to define default HTTP handlers, since you can't really assign an application
    directly to the `80` port.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来将您的应用程序配置为在已注册端口范围内监听就足够使用了。然而，这仍然不是**完全**如此。如果您曾经运行过JBoss应用程序服务器（在像JBoss这样的膨胀应用程序服务器的糟糕旧日子里，您可能记得通过访问`http://localhost:8080/my-java-application`来访问您本地的开发环境，或者至少这是我过去不得不做的。JBoss总是配置那个端口的原因是它实际上充当了`80`端口的别名，即HTTP端口。`8008`也是一样。因此，尽管端口位于已注册端口范围内，但对其行为有特定的期望。它实际上只是为用户提供了一个值，以便在已注册端口范围内定义默认的HTTP处理器，因为您无法直接将应用程序分配到`80`端口。
- en: There are other ports within the registered port range that will likely be occupied
    by common services and applications on your local machine. Since .NET Core will
    stop if it can't register itself with the designated port, though, you'll notice
    immediately if you need to update your configuration with a different port number.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在已注册端口范围内还有其他端口，这些端口可能被您本地机器上的常见服务和应用程序占用。尽管.NET Core如果无法在指定端口上注册自己就会停止，但您会立即注意到，如果您需要使用不同的端口号更新您的配置。
- en: Exposing multiple applications on a single port
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单个端口上暴露多个应用程序
- en: If you have been working in web development for a substantial amount of time,
    you may already be familiar with wrangling the various configurations and settings
    in **Internet Information Services** (**IIS**) or the aforementioned JBoss whenever
    you wanted to deploy a web application on a Windows host. This is what's called
    an **application server**, and it essentially serves as a shared hosting environment
    for any network-exposed applications on your system. When working with IIS, you
    can register any number of applications to respond to requests against a single
    port (`80` for HTTP, or `443` for HTTPS) and distinguish between them with application
    paths in the URI, or sub-domain specifications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在网络开发领域工作了相当长的时间，你可能已经熟悉了在 Windows 宿主上部署网络应用程序时，如何处理 **Internet Information
    Services**（IIS）或上述 JBoss 的各种配置和设置。这被称为 **应用服务器**，它本质上为系统上任何公开的网络应用程序提供了一个共享的托管环境。当使用
    IIS 时，你可以注册任意数量的应用程序以响应针对单个端口的请求（HTTP 的 `80` 端口或 HTTPS 的 `443` 端口），并通过 URI 中的应用程序路径或子域规范来区分它们。
- en: So if you had two applications named, for instance, `TestApp` and `SampleApp`,
    and you wanted to host both on a single machine, but expose both over the HTTP
    port, you would do so by registering them and deploying them within IIS. In doing
    so, you would specify an application directory within IIS, such as `/sample` and
    `/test`. This would tell IIS that any requests to your hostname over the `80`
    port, the request paths had as their first component the `/sample` directory,
    should be routed to your `SampleApp` as though the request went directly to that
    application. This essentially moved the problem of mapping specific ports to mapping
    specific application directories.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有两个名为 `TestApp` 和 `SampleApp` 的应用程序，并且你希望在单个机器上托管它们，同时通过 HTTP 端口公开它们，你可以通过在
    IIS 中注册和部署它们来实现。这样做时，你会在 IIS 中指定一个应用程序目录，例如 `/sample` 和 `/test`。这将告诉 IIS，任何通过
    `80` 端口到达你的主机名的请求，其请求路径的第一个组件是 `/sample` 目录，应该被路由到你的 `SampleApp`，就像请求直接发送到该应用程序一样。这实际上将映射特定端口的问题转化为映射特定应用程序目录的问题。
- en: While IIS still supports deployment of .NET Core applications, it's much less
    common in modern web-hosting contexts. IIS specifically is known for its convoluted
    configuration schemes and the immense memory and CPU usage footprint it imposes
    on your host machine. That's not to mention the fact that IIS is exclusive to
    Windows operating systems, making portability of IIS hosted applications non-existent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 IIS 仍然支持部署 .NET Core 应用程序，但在现代网络托管环境中，这种情况要少得多。IIS 特别以其复杂的配置方案以及它对宿主机器造成的巨大内存和
    CPU 使用影响而闻名。更不用说 IIS 仅限于 Windows 操作系统，这使得 IIS 托管应用程序的可移植性几乎不存在。
- en: 'More typically, engineers are embracing a more lightweight approach to hosting
    concerns. With the cross-platform support of the .NET Core  runtime, engineers
    that have the benefit of working in greenfield applications are encouraged to
    pursue more cutting- edge solutions. Typically, .NET Core developers deploy your
    application to a remote host by way of a Docker container. Docker provides an
    isolated hosting context for your application, and exposes the ports your application
    is listening on to the outside world by mapping the container''s internal listening
    ports to an available port on the machine that''s actually running your Docker
    container. You can specify the port you''d like your application to listen on
    within what''s called a **Dockerfile**, which specifies the build and deployment
    steps for a Docker-hosted application. It''s not unlike a PowerShell script or
    bash script for automating common OS-level operations. Once you specify your desired
    port, you can map it to a port on the host machine within the `run` command like
    so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，工程师们正在采用更轻量级的方法来处理托管问题。随着 .NET Core 运行时的跨平台支持，那些在绿色场应用中工作的工程师被鼓励追求更前沿的解决方案。通常，.NET
    Core 开发者通过 Docker 容器将应用程序部署到远程主机。Docker 为你的应用程序提供了一个隔离的托管环境，并通过将容器的内部监听端口映射到运行
    Docker 容器的机器上的可用端口，将你的应用程序监听的端口暴露给外界。你可以在所谓的 **Dockerfile** 中指定应用程序希望监听的端口，该文件指定了
    Docker 托管应用程序的构建和部署步骤。它与 PowerShell 脚本或 bash 脚本类似，用于自动化常见的操作系统级操作。一旦指定了所需的端口，你可以在
    `run` 命令中将它映射到宿主机器上的一个端口，如下所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command will map from the port `5000` inside our **Docker Container**
    to the `80` port on the host machine, and the `5001` port to the `443` port. So
    from our hosting context, we''ll get a request against the `80` port, and that
    will be listened to by our Docker instance, which will forward the request into
    our running **.NET Core App**, which will be listening on the `5000` port:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将把我们的**Docker容器**内部的`5000`端口映射到主机机器上的`80`端口，以及`5001`端口映射到`443`端口。因此，从我们的托管上下文来看，我们将收到针对`80`端口的请求，这将由我们的Docker实例监听，并将请求转发到我们的正在运行的**.NET
    Core应用程序**，该应用程序将监听`5000`端口：
- en: '![](img/e6214c27-0fca-42c8-8266-d87737cecc75.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6214c27-0fca-42c8-8266-d87737cecc75.png)'
- en: From here, the problem of hosting multiple applications behind a single port
    that was solved by IIS or JBoss is often simply a matter of configuration. If
    your application is cloud-hosted, you can typically do the same sort of route-prefix
    mapping that was provided by IIS. In other contexts, you can host your suite of
    applications behind what's called a **reverse-proxy**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，由IIS或JBoss解决的在单个端口后面托管多个应用程序的问题通常只是配置问题。如果你的应用程序是云托管，你通常可以执行与IIS提供的相同类型的路由前缀映射。在其他上下文中，你可以在所谓的**反向代理**后面托管你的应用程序套件。
- en: We'll take the time to look at, and in some cases even build, each of these
    approaches in later chapters. For now though, it is sufficient that you understand
    the nature of ports as a mechanism by which external requests can access specific
    services or applications hosted on a target device. When exposing your application
    to network resources, the specific port over which you do so is typically a matter
    of simple configuration and convention; for now, we'll take a look at how to interact
    with those specific ports in our software through sockets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中花时间查看，在某些情况下甚至构建这些方法中的每一个。然而，现在，你只需要理解端口作为外部请求可以通过它访问目标设备上特定服务或应用程序的机制的性质就足够了。当将你的应用程序暴露给网络资源时，你使用的特定端口通常是简单配置和惯例的问题；现在，我们将看看如何通过套接字在我们的软件中与这些特定端口进行交互。
- en: Sockets – a software interface to a port
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字 – 对端口的软件接口
- en: So now that we understand how ports are used to route requests to specific processes
    on a host device, how do we set up our applications to actually *accept* requests
    over those ports? This is where a socket comes in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了端口是如何用于将请求路由到主机设备上的特定进程的，我们该如何设置我们的应用程序以实际*接受*通过这些端口的请求呢？这就是套接字发挥作用的地方。
- en: A socket provides a software interface to a specific port on a specific remote
    host. It's an open connection stream between your application and any remote application
    exposed at the server and port address you specify. Once this connection is established,
    you're free to write (or read) any data to the open stream of that connection
    that you need. Sockets are a versatile concept, implemented in almost any server-side
    programming language, and .NET Core is no different.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字为特定远程主机上的特定端口提供了一个软件接口。它是在你指定的服务器和端口地址处暴露的任何远程应用程序与你的应用程序之间的开放连接流。一旦建立这种连接，你就可以自由地向该连接的开放流写入（或读取）任何你需要的数据。套接字是一个多用途的概念，几乎在任何服务器端编程语言中都有实现，.NET
    Core也不例外。
- en: 'One key distinction between a socket and its underlying port is that the port
    represents access to a single process on a remote device. Therefore, a port can
    only be registered for a single application. Sockets, however, represent active
    connections to that single resource. Therefore, there can be as many active sockets
    connected to a resource as can be supported by the network and the remote host:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字与其底层端口之间的一个关键区别是，端口代表对远程设备上单个进程的访问。因此，端口只能为单个应用程序注册。然而，套接字代表对该单个资源的活动连接。因此，可以连接到资源的活动套接字数量可以由网络和远程主机支持：
- en: '![](img/2086663d-49a1-4de5-90de-659a148cc28a.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2086663d-49a1-4de5-90de-659a148cc28a.png)'
- en: So, a port represents a single process running on a remote machine, while a
    socket represents a connection to a process on a remote machine, designated by
    a port number. When we run our applications and intend to expose them to remote
    resources, we must register them to a specific port. If we want to connect to
    our application to an exposed port, we do so with a socket. A port is merely a
    configuration concern, whereas leveraging sockets is an implementation detail,
    so let's take a look now at how to instantiate and leverage sockets for network
    communication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，端口代表在远程机器上运行的单个进程，而套接字代表一个连接到远程机器上进程的连接，该进程由端口号指定。当我们运行应用程序并打算将其暴露给远程资源时，我们必须将其注册到特定的端口。如果我们想通过一个暴露的端口连接到我们的应用程序，我们使用套接字来完成。端口仅仅是配置问题，而利用套接字则是实现细节，因此现在让我们看看如何实例化和利用套接字进行网络通信。
- en: While I brush aside port registration as *merely* a configuration concern, that
    doesn't mean it's not your responsibility to understand and configure. Full-stack
    network engineering requires you to understand not only how to write your applications,
    but how to properly configure and deploy them to your various preproduction and
    production environments so that others can use them. We'll take a look at application
    deployment in the next chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我把端口注册视为仅仅是配置问题，但这并不意味着你不负责任去理解和配置。全栈网络工程要求你不仅要了解如何编写应用程序，还要了解如何正确配置和部署它们到各种预生产和生产环境中，以便其他人可以使用它们。我们将在下一章中探讨应用程序部署。
- en: Leveraging sockets in C#
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中利用套接字
- en: Sockets in C# are an extremely versatile and flexible concept. As their definition
    indicates, they only expose a connection to a remote resource, and how that connection
    is used is almost entirely up to the developer who establishes it. An instance
    of the `Socket` class in C# provides synchronous and asynchronous data transfer
    of packets of arbitrary collections of bytes. The contents, structure, and even
    protocol used to transmit those packets is up to you (though I do strongly recommend
    that you always leverage asynchronous communication over synchronous communication).
    So, let's look at how we'll use it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的套接字是一个极其灵活和通用的概念。正如其定义所示，它们仅暴露对远程资源的连接，而如何使用该连接几乎完全取决于建立该连接的开发者。C#中`Socket`类的一个实例提供了同步和异步的数据包传输，这些数据包是任意字节数组的集合。这些数据包的内容、结构和甚至用于传输这些数据包的协议都由你决定（尽管我强烈建议你始终优先考虑异步通信而不是同步通信）。因此，让我们看看我们将如何使用它。
- en: The socket specification
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络套接字规范
- en: The first thing to know about a socket is how to initialize it. The most basic
    information necessary to initialize a socket is understanding what kind of socket
    we'll be working with, and what protocol it will be operating on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解套接字的第一件事是了解如何初始化它。初始化套接字所需的最基本信息是理解我们将要处理哪种类型的套接字，以及它将运行在哪种协议上。
- en: The first aspect of that specification, the socket type, tells our code how
    we'll be interacting with the connection once it's established. This is defined
    in a `SocketType` array, located in the `System.Net.Sockets` namespace, which
    defines the full set of valid interaction mechanisms. The values of `enum` include
    `Dgram`, which indicates that we'll be working directly with unordered, connectionless
    datagrams between our software and the connected host; the `Seqpacket` type, which
    operates with ordered, boundary-protected bytes transmitted back and forth over
    a stream; and the `Stream` type, which provides the asynchronous flow of bytes
    over a `Stream` instance that we've become familiar with so far. There are a handful
    of other `SocketType` values, and you can find them and descriptions of what they
    mean, and how they're used on the Microsoft documentation page. For this chapter,
    we'll just be working with a `Stream` type, since that most closely resembles
    the `Stream` classes from the `System.IO` namespace that we're already so familiar
    with.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范的第一个方面，即套接字类型，告诉我们的代码一旦建立连接，我们将如何与之交互。这由`SocketType`数组定义，位于`System.Net.Sockets`命名空间中，该命名空间定义了完整的有效交互机制。`enum`的值包括`Dgram`，表示我们将直接与我们的软件和连接的主机之间的无序、无连接的数据报进行工作；`Seqpacket`类型，它通过有序、边界保护的字节在流中来回传输；以及`Stream`类型，它提供了我们迄今为止已经熟悉的`Stream`实例上的异步字节流。还有一些其他的`SocketType`值，你可以在微软文档页面上找到它们以及它们的意义和用法描述。对于本章，我们只需使用`Stream`类型，因为它与我们已经非常熟悉的`System.IO`命名空间中的`Stream`类最为相似。
- en: A `Socket` can connect and communicate over a wide array of protocols from the
    transmission layer of the OSI network stack. This means that when you're constructing
    a socket, you'll need to specify specifically what protocol you'll be using to
    communicate once the connection is established. This informs the remote host of
    how it should be parsing the primitive datagrams or packets it will be receiving
    once the connection is established (provided the host supports the requested protocol
    in the first place). To define the protocol your `Socket` instance will be using,
    you'll be looking to values of the `ProtocolType` enum found in the `System.Net.Sockets`
    namespace. There are a number of defined values that correspond to well-established
    transmission protocols, including IPv4, IPv6, TCP, UDP, IDP, Raw, and others.
    For the purposes of our code, we'll be connecting to a local application listening
    for HTTP requests, which is handled by the TCP protocol, so we'll specify the
    TCP protocol when we initialize `Socket`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket`可以连接并使用OSI网络栈传输层上的多种协议进行通信。这意味着当你构造一个套接字时，你需要指定一旦建立连接，你将使用什么协议进行通信。这会通知远程主机在连接建立后如何解析它将接收到的原始数据报或数据包（前提是主机最初支持请求的协议）。为了定义你的`Socket`实例将使用的协议，你将查看`System.Net.Sockets`命名空间中`ProtocolType`枚举的值。有几个定义的值对应于已建立的传输协议，包括IPv4、IPv6、TCP、UDP、IDP、原始协议等。为了我们代码的目的，我们将连接到一个本地应用程序，该应用程序正在监听HTTP请求，由TCP协议处理，因此我们在初始化`Socket`时将指定TCP协议。'
- en: 'And those two pieces of information are the minimum details we''re required
    to specify for a socket, the public constructor signature being as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两块信息是我们为套接字所必需的最小细节，公共构造函数的签名如下：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is also an option to specify what's known as the `AddressFamily` of your
    connection. This can actually be derived from your connection endpoint and provided
    to the constructor for your socket. Typically, for an HTTP resource transmitted
    over TCP, your specification will be `AddressFamily.Osi`, indicating that you're
    using OSI addressing schemes. So now that we know how to initialize a socket,
    let's look at what it takes to connect a socket to a remote endpoint.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项可以指定连接的`AddressFamily`。这实际上可以从你的连接端点推导出来，并提供给套接字构造函数。通常，对于通过TCP传输的HTTP资源，你的指定将是`AddressFamily.Osi`，表示你正在使用OSI寻址方案。既然我们已经知道了如何初始化套接字，让我们看看连接套接字到远程端点需要什么。
- en: Establishing a socket connection
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立套接字连接
- en: 'The first thing we''ll want to do is set up a simple listening server to which
    we can connect our socket driver program. To do this, we''ll spin up a simple,
    `WebAPI` project and run it. Start by opening up Command Prompt and navigating
    to the directory where you want to create your sample API. Next, create a new
    `WebAPI` with the following command from the .NET Core CLI:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是设置一个简单的监听服务器，我们可以将其连接到我们的套接字驱动程序。为此，我们将启动一个简单的`WebAPI`项目并运行它。首先，打开命令提示符并导航到你想要创建示例API的目录。接下来，使用以下命令从.NET
    Core CLI创建一个新的`WebAPI`：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will spin up a new application from scratch that will be ready-made to
    receive and respond to HTTP and HTTPS requests made to your local machine and
    a pre-configured port.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从头开始启动一个新的应用程序，该应用程序将准备好接收和响应发送到你的本地机器和预配置端口的HTTP和HTTPS请求。
- en: 'For the purposes of this demonstration, we''ll actually want to disable some
    default functionality in this application. The template for a WebAPI will redirect
    all calls made to the HTTP port to the HTTPS port instead. We want to prevent
    this from happening so the HTTP port, can service requests directly. You''ll see
    why later, but for now you can disable this functionality by opening up your `SampleApp`
    project and navigating to the `Startup.cs` file. Within this file, you''ll find
    a method with the following signature:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本次演示的目的，我们实际上需要禁用此应用程序中的一些默认功能。WebAPI的模板将重定向所有发送到HTTP端口的调用到HTTPS端口。我们希望阻止这种情况发生，以便HTTP端口可以直接服务请求。你稍后会明白原因，但现在你可以通过打开你的`SampleApp`项目并导航到`Startup.cs`文件来禁用此功能。在这个文件中，你会找到一个具有以下签名的函数：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the bottom of this method, delete or comment out the line of code that reads:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法的底部，删除或注释掉读取以下代码行的行：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once that''s done, you can close that folder and ignore its contents for the
    rest of this sample project. Now, let''s run it and test it, first by navigating
    into the folder that was just created, and then calling the CLI `dotnet run` command.
    Once you''ve done that, you should see the following output from your running
    application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，您可以关闭该文件夹，并在本示例项目的剩余部分忽略其内容。现在，让我们运行它并测试它，首先导航到刚刚创建的文件夹，然后调用 CLI 的 `dotnet
    run` 命令。完成这些操作后，您应该会看到运行中的应用程序以下输出：
- en: '![](img/e02c49cd-5085-429f-95eb-02094047f785.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e02c49cd-5085-429f-95eb-02094047f785.png)'
- en: You can take your time investigating the project template created by the `dotnet
    new` command if you're curious, but we'll be covering WebAPI applications, among
    many others, in much greater detail in the next chapter. For now, it's just important
    that we have an application that's listening for requests and returning responses.
    You can simply take my word on its expected functionality going forward, if you'd
    rather defer learning that until later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对由 `dotnet new` 命令创建的项目模板感兴趣，可以花些时间进行调查，但我们将在本章的下一部分更详细地介绍 WebAPI 应用程序，以及其他许多内容。现在，重要的是我们有一个正在监听请求并返回响应的应用程序。如果您愿意稍后再学习，可以简单地相信我对其预期功能的前进，如果愿意的话。
- en: The last three lines of your console output give you some valuable information;
    they tell you the exact host and port through which your application is exposed
    to outside connections. As you can see, the default from new WebAPIs created by
    .NET is going to be port `5000` for incoming HTTP requests, and `5001` for HTTPS.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您控制台输出的最后三行提供了有价值的信息；它们告诉您应用程序通过哪个确切的主机和端口对外暴露连接。如您所见，由 .NET 创建的新 WebAPIs 的默认端口将是
    `5000`，用于传入的 HTTP 请求，而 `5001` 用于 HTTPS。
- en: 'To confirm that the application is responding to requests, open up Postman
    (or Insomniac, if that was your REST client of choice), and send a GET request
    to `http://localhost:5000/api/values`. You should see the following response in
    your output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认应用程序正在响应用户请求，请打开 Postman（或如果您选择的是 Insomniac，则打开 Insomniac），并发送一个 GET 请求到
    `http://localhost:5000/api/values`。您应该在输出中看到以下响应：
- en: '![](img/b2185971-58e0-4437-83fa-fe4c12330170.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2185971-58e0-4437-83fa-fe4c12330170.png)'
- en: We can see a valid response with two strings in a `JSON` array. Once you have
    this, we're ready to connect with `Socket`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `JSON` 数组中看到一个有效的响应，包含两个字符串。一旦您有了这些，我们就可以使用 `Socket` 进行连接。
- en: Create a new console application in the parent directory of `SampleApp`, using
    the `dotnet new console -n SocketTest` command in the CLI. This will be our driver
    application for working with the `Socket` class. The objective of this sample
    project is to connect to our `SampleApp`*,* which is listening on the `5000` port,
    submit a request to the `/api/values` endpoint, and then parse and print the response.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SampleApp` 的父目录中创建一个新的控制台应用程序，使用 CLI 中的 `dotnet new console -n SocketTest`
    命令。这将是我们与 `Socket` 类一起工作的驱动应用程序。本示例项目的目标是连接到正在 `5000` 端口监听的 `SampleApp`，向 `/api/values`
    端点提交请求，然后解析并打印响应。
- en: So, the first thing we'll have to do is define an `IPEndPoint` instance for
    `Socket` to connect to. `IPEndPoint` is a specific implementation of the `EndPoint`
    abstract class required by the `Socket.ConnectAsync()` method we'll be using.
    It defines the specific location of the remote resource we intend to connect to,
    and exposes metadata about that endpoint. It also provides the `AddressFamily`
    value for our `Socket` constructor signature. So let's first define that with
    the host address and port, and use it to construct `Socket`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要为 `Socket` 定义一个 `IPEndPoint` 实例以进行连接。`IPEndPoint` 是 `EndPoint` 抽象类的一个特定实现，该类是我们将要使用的
    `Socket.ConnectAsync()` 方法所要求的。它定义了我们打算连接到的远程资源的特定位置，并公开了有关该端点的元数据。它还为我们 `Socket`
    构造函数签名提供了 `AddressFamily` 值。所以让我们首先使用主机地址和端口定义它，并使用它来构造 `Socket`。
- en: 'To do so, we need an `IPAddress` instance, which we could build ourselves based
    on the 4 bytes stored in our localhost address of `127.0.0.1`, or we could simply
    request it explicitly from our DNS using the `Dns.GetHostEntry()` method from
    [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml), *DNS and Resource Location*.
    You can do as you please when following along, but since it involves less math,
    I''ll be using the DNS. However, since `AddressList` returned by a host entry
    can have an arbitrarily large list of IP Addresses to which the name could resolve,
    we''ll want to connect to the first address that allows us to, and proceed from
    there. This means looping through `AddressList` until a connection is established.
    So the initial setup to attempt to establish our connection will look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要一个`IPAddress`实例，我们可以根据存储在我们本地主机地址`127.0.0.1`中的4个字节自己构建它，或者我们可以简单地使用`Dns.GetHostEntry()`方法从[第2章](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml)，*DNS和资源定位*显式请求它。当你跟随时，你可以随意操作，但由于它涉及较少的数学，我将使用DNS。然而，由于主机条目返回的`AddressList`可以包含一个任意大的IP地址列表，这些地址可以解析该名称，我们希望连接到允许我们连接的第一个地址，并从这里开始。这意味着我们需要在`AddressList`中循环，直到建立连接。因此，尝试建立我们连接的初始设置将看起来像这样：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One thing that might jump out to you about this code is that we''re using the
    `async` version of the `Main()` method. This is a feature that was only added
    in version 7.2 of C#, and if your project isn''t configured to target at least
    that version, you''ll encounter build errors. To resolve them, simply modify the
    `PropertyGroup` tag of your `.csproj` file to include the `LangVersion` tag with
    its version set to `latest`, as seen here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能让你注意到的是，我们正在使用`Main()`方法的`async`版本。这是一个仅在C# 7.2版本中添加的功能，如果你的项目没有配置为至少针对那个版本，你将遇到构建错误。要解决这些问题，只需修改`.csproj`文件的`PropertyGroup`标签，包括带有其版本设置为`latest`的`LangVersion`标签，就像这里看到的那样：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you've made this change, your source code will always target the latest
    minor version of C#. With that in place, you should have no problems running your
    `Main()` method asynchronously.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了这个更改，你的源代码将始终针对C#的最新次要版本。有了这个，你应该没有问题异步运行你的`Main()`方法。
- en: If you want to make sure things are behaving as expected, you can go ahead and
    run your application, placing a breakpoint on the `break;` operator, and you should
    see that the breakpoint is hit, and so a connection was established between your
    two applications. You'll notice, though, that simply establishing the connection
    didn't trigger any log messages in your running WebAPI application. This is because,
    while a connection was established, no request was made of the resource to which
    we connected. Requests must be sent as a well-formed message over an established
    connection. So now, let's build our request and send it over the connected socket.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保一切按预期运行，你可以运行你的应用程序，在`break;`操作符上放置一个断点，你应该会看到断点被命中，这意味着你的两个应用程序之间已经建立了连接。然而，你会注意到，仅仅建立连接并没有在你的运行WebAPI应用程序中触发任何日志消息。这是因为，尽管建立了连接，但我们没有对连接到的资源发出请求。请求必须作为格式良好的消息通过已建立的连接发送。所以现在，让我们构建我们的请求，并通过连接的套接字发送它。
- en: 'Sending requests is as simple as calling the `SendAsync()` method on our socket
    with a byte array representing our data buffer to be sent over the connection.
    So for an HTTP request, we have to build our message from scratch. That means
    specifying the method or HTTP verb we''ll be using, the specific URL of our requested
    resource, the size of any content we intend to send over, and any request headers
    we need to attach. I''m sure by now you can already see how tedious it is to work
    directly with sockets. For such a simple request, however, we can easily construct
    our message with a simple utility function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求就像在我们的套接字上调用`SendAsync()`方法一样简单，该方法需要一个表示要发送的数据缓冲区的字节数组。因此，对于一个HTTP请求，我们必须从头开始构建我们的消息。这意味着指定我们将要使用的方法或HTTP动词，我们请求的资源的具体URL，我们打算发送的任何内容的尺寸，以及我们需要附加的任何请求头。我相信到现在你已经能看出直接与套接字工作是多么繁琐。然而，对于这样一个简单的请求，我们可以通过一个简单的实用函数轻松构建我们的消息：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then using this, we can build our byte array just as we did when writing to
    streams. So back in our main method, we''ll get our request message, convert it
    to a byte array, and then send the request to our remote host (*SampleApp*, running
    at `http://localhost:5000`). Add the following lines into the main method after
    the connection has been established by the `Socket` instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像写入流一样构建我们的字节数组。所以回到我们的主方法中，我们将获取我们的请求消息，将其转换为字节数组，然后将请求发送到我们的远程主机（*SampleApp*，运行在`http://localhost:5000`）。在通过`Socket`实例建立连接后，将以下几行代码添加到主方法中：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you add this code and then run your application, you''ll know you''ve succeeded
    when you begin to see logging information in the console displayed by your WebAPI
    project, as seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了这段代码并运行你的应用程序，当你开始在WebAPI项目的控制台看到日志信息时，你就知道你已经成功了，就像这里看到的那样：
- en: '![](img/4ef05055-81cf-43ee-a743-062dbb81db9e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ef05055-81cf-43ee-a743-062dbb81db9e.png)'
- en: And just like that, you've managed to send your first transport-level message
    over a socket connection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你已经成功地在套接字连接上发送了你的第一条传输层消息。
- en: Now, to confirm that we're receiving the responses from the server properly,
    we'll try to write to our `SocketTest` application's console the same message
    that we saw earlier in the responses from our Postman (or Insomnia) requests.
    In order to do that, we'll have to use the `ReceiveAsync()` method to accept whatever
    byte arrays were returned by the server in response to our request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了确认我们正确地收到了服务器的响应，我们将尝试将之前在Postman（或Insomnia）请求的响应中看到的相同消息写入我们的`SocketTest`应用程序的控制台。为了做到这一点，我们必须使用`ReceiveAsync()`方法来接收服务器针对我们的请求返回的任何字节数组。
- en: 'Just like with the instances of the `Stream` class we used in earlier chapters,
    the `ReceiveAsync()` method accepts a byte array into which it will write. For
    this, we''ll provide it with an empty array, 512 bytes long. Once we define that,
    we can receive the response from the remote resource, and simply write it to our
    console, one line at a time. Just add the following lines of code to the bottom
    of your `Main()` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的章节中使用的`Stream`类的实例一样，`ReceiveAsync()`方法接受一个字节数组，它将写入这个数组。为此，我们将提供一个长度为512字节的空数组。一旦我们定义了这一点，我们就可以接收来自远程资源的响应，并将其逐行写入我们的控制台。只需将以下几行代码添加到`Main()`方法的底部：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run the application now, you should see the message headers, along
    with the body containing the string array we saw earlier in Postman, printed to
    your console:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行应用程序时，你应该会在控制台看到消息头，以及包含我们之前在Postman中看到的字符串数组的正文打印出来：
- en: '![](img/45cee704-5e2e-4f03-adc9-9b1814956ce4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45cee704-5e2e-4f03-adc9-9b1814956ce4.png)'
- en: And just like that, you've successfully executed an HTTP request over TCP from
    scratch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你已经成功地在TCP上从头开始执行了一个HTTP请求。
- en: 'The last order of business is to disconnect from your host, and dispose of
    your socket. Let the last two lines of your application `Main()` method read as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是从你的主机断开连接，并销毁你的套接字。让你的应用程序`Main()`方法的最后两行看起来像这样：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a major courtesy on your part. Even though a port can handle multiple
    connections simultaneously, there is an upper limit to how many connection requests
    it can service at a given point in time. Disconnecting your own Socket frees up
    resources on the remote host for others to take advantage of. While there is a
    maximum time limit for an inactive connection, after which the remote host will
    forcibly cancel the connection, you shouldn't ever let an inactive connection
    remain alive for that long. If you're done with the host, disconnect from the
    host.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的一大礼貌。尽管端口可以同时处理多个连接，但在任何给定时间点，它能够服务的连接请求数量是有限的。断开你自己的套接字会为其他人腾出远程主机上的资源。虽然对于非活动连接有一个最大时间限制，在此之后远程主机将强制取消连接，但你绝对不应该让非活动连接保持那么长时间。如果你完成了主机的工作，就断开与主机的连接。
- en: Parsing responses
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析响应
- en: As I'm sure you already figured out, the simple string of ASCII characters that
    encapsulated the entirety of a response from your remote host is not exactly a
    computer-friendly format. Receiving a response is one thing, but leveraging its
    contents in your application is a whole different kinds of beast. Doing this kind
    of work from scratch every time you needed to access something on a different
    machine would slow the software development life cycle down to a crawl.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，封装您远程主机响应全部内容的简单ASCII字符字符串并不是一个计算机友好的格式。接收响应是一回事，但在您的应用程序中利用其内容则是完全不同的一种生物。每次需要访问不同机器上的内容时，从头开始做这种工作将使软件开发周期慢如蜗牛。
- en: This is why .NET Core provides so many functional flexible wrapper and utility
    classes for the specific protocols and interactions you're most likely to deal
    with day to day. So, while I think it's important that you understand exactly
    how to establish and then leverage a direct connection from your application to
    any other application running on any other machine on your network, it's also
    not exactly so common that you'll find yourself needing to do so. As we move into
    the next few chapters, we'll see how the templates and libraries provided by .NET
    Core (and ASP.NET Core, in the case of HTTP) do all the heavy lifting so that
    we don't have to. If you're curious to learn more about low-level network interactions
    in C#, there's an entire ocean of knowledge and use cases that I simply didn't
    have time to cover in this chapter, and I would encourage you to spend some time
    digging in. If this content seemed a bit boring or tedious, though, don't worry.
    It's about to get a lot more fun.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么.NET Core为日常可能遇到的具体协议和交互提供了如此多的功能灵活的包装类和实用类。因此，虽然我认为了解如何从您的应用程序直接连接到网络中任何其他机器上运行的任何其他应用程序的建立和利用是非常重要的，但这并不常见，您不太可能需要这样做。随着我们进入下一章，我们将看到.NET
    Core（以及ASP.NET Core，在HTTP的情况下）提供的模板和库是如何完成所有繁重的工作，这样我们就不必亲自去做。如果您对C#中低级网络交互感兴趣，那么有一个关于知识和用例的广阔海洋，我简单地没有时间在这一章中涵盖，我鼓励您花些时间深入研究。尽管如此，如果这个内容看起来有点无聊或乏味，请不要担心。它即将变得更有趣。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began to leverage and finally build from the foundation
    we've laid in previous chapters, opening up our applications to the full spectrum
    of network functionality available in C#. We learned that any application we write
    that we expect to be used by resources on our network must first be exposed to
    those resources through a port on our host machine. We looked at how ports are
    specified and registered, and learned about some restrictions that exist on how
    we can register our own, looking at the reason for, and the range, of well-known
    port addresses and the range of dynamic or ephemeral ports to which we cannot
    (or at least should not) register our applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始利用并最终构建在前几章中奠定的基础，使我们的应用程序能够访问C#中可用的全部网络功能。我们了解到，我们编写的任何应用程序，如果预期将在我们的网络上使用资源，必须首先通过我们主机机器上的端口向这些资源公开。我们研究了端口的指定和注册方式，并了解了一些关于我们如何注册自己的限制，包括知名端口号的原因和范围，以及我们不能（或至少不应该）注册应用程序的动态或临时端口号的范围。
- en: Once we cemented that concept, we looked at the other side of the connection,
    and started working with sockets. We learned that sockets are a generic in-code
    representation of an active connection to an open port on a remote machine. We
    saw how the simplicity of that concept opened up a wide array of applications
    for socket-based network code and the low-level control it gives over packet-level
    communication.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确立了这一概念，我们就转向连接的另一端，并开始使用套接字。我们了解到套接字是远程机器上开放端口上活跃连接的通用代码表示。我们看到了这个概念的简单性如何为基于套接字的网络代码和它对数据包级通信的低级控制开辟了广泛的应用。
- en: With the concepts we've covered in this book so far, you have the resources
    necessary to write any network software you could ever need. Understanding the
    nature of asynchronous streams, packet construction and parsing, and socket connections
    to remote resources would be sufficient to implement any piece of networking functionality
    possible. It would be far from ideal, though, using such primitive building blocks.
    That's why the .NET Standard provides so many useful templates, patterns, and
    libraries for the myriad of applications you might have to write, and that's what
    we'll start looking at in the next chapter, starting with HTTP-based applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书到目前为止所涵盖的概念，你拥有了编写任何可能需要的网络软件所需的资源。理解异步流的本质、数据包构造和解析，以及与远程资源的套接字连接就足以实现任何可能的网络功能。然而，使用这些原始构建块远非理想。这就是为什么.NET
    Standard为可能需要编写的各种应用程序提供了如此多的有用模板、模式和库，我们将在下一章开始探讨这些内容，从基于HTTP的应用程序开始。
- en: Questions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the definition of a port?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口的定义是什么？
- en: What is the range of well-known ports?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已知端口的范围是什么？
- en: What is the dynamic port range?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态端口的范围是什么？
- en: What is one of the primary functions of an application server?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用服务器的主要功能之一是什么？
- en: What is the definition of a socket?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口的定义是什么？
- en: What are some of the primary distinctions between a socket and a port?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套接字和端口之间的一些主要区别是什么？
- en: Which construct provides the range of protocols over which a socket can connect?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个构造提供了套接字可以连接的协议范围？
- en: What are some of the protocols that sockets support?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套接字支持哪些协议？
- en: Further reading
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For further reading on this subject, many of the books I've recommended in previous
    chapters still apply.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的进一步阅读，我在前几章推荐的大多数书籍仍然适用。
- en: 'For additional insight, though, you can look at *ASP.NET Core 1.0 High Performance*,
    *James Single**ton,* Packt Publishing*.* While the subject of that book is specifically
    application-layer network programming, he addresses the performance benefits of
    managing direct connection I/O, and the subject may be of interest. You can find
    it through *Packt Publishing*, here: [https://www.packtpub.com/application-development/aspnet-core-10-high-performance.](https://www.packtpub.com/application-development/aspnet-core-10-high-performance)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了获得更多见解，你可以查看 *ASP.NET Core 1.0 高性能*，*詹姆斯·辛顿*，*Packt 出版*.* 虽然那本书的主题是特定于应用层网络编程，但他讨论了管理直接连接I/O的性能优势，这个主题可能很有趣。你可以在
    *Packt 出版* 上找到它：[https://www.packtpub.com/application-development/aspnet-core-10-high-performance.](https://www.packtpub.com/application-development/aspnet-core-10-high-performance)
