- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introduction to Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法简介
- en: While reading the first chapter of this book, you learned about various data
    types. Now, it is high time to introduce the topic of algorithms. In this chapter,
    you will take a look at their **definition**, as well as some real-world **examples**,
    **notations**, and **types**. As you should take care of the performance of your
    applications, the subject of computational complexity of the algorithms, including
    time complexity, will also be presented and explained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书的第一章时，你了解到了各种数据类型。现在，是时候介绍算法这一主题了。在这一章中，你将了解它们的**定义**，以及一些现实世界的**例子**、**表示法**和**类型**。由于你应该注意应用程序的性能，因此算法的计算复杂性，包括时间复杂性，也将被介绍和解释。
- en: First, it is worth mentioning that the topic of algorithms is very broad and
    complex. You can easily find a lot of scientific publications about them on the
    internet, published by researchers from all over the world. The number of algorithms
    is enormous and it is almost impossible to even remember the names of all the
    commonly used ones. Of course, some algorithms are simple to understand and implement,
    while others are extremely complex and almost impossible to understand without
    deep knowledge of algorithmics, mathematics, and other dedicated field of science.
    There are also various classifications of algorithms by different key features,
    and there are a lot of types, including recursive, greedy, divide-and-conquer,
    back-tracking, and heuristic. However, for various algorithms, you can specify
    the computational complexity by stating how much time or space they require to
    operate with the increasing size of a processed input.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，值得指出的是，算法这一主题非常广泛且复杂。你可以在互联网上轻松找到大量关于它们的科学出版物，这些出版物由来自世界各地的研究人员发表。算法的数量是巨大的，甚至记住所有常用算法的名称都几乎是不可能的。当然，有些算法易于理解和实现，而有些则极其复杂，没有对算法学、数学和其他相关科学领域的深入了解几乎无法理解。还有根据不同关键特征的算法分类，有很多类型，包括递归、贪婪、分而治之、回溯和启发式。然而，对于各种算法，你可以通过说明它们在处理输入大小增加时所需的时间和空间来指定计算复杂性。
- en: Does this sound overwhelming, complicated, and difficult? Don’t worry. In this
    chapter, I will try to introduce the topic of algorithms in a way that everyone
    can understand, not only mathematicians or other scientists. For this reason,
    in this chapter, you will find some simplifications to make this topic simpler
    and easier to follow. However, the aim is to introduce you to this topic and **make
    you interested in algorithms**, not create another research publication or book
    with a lot of formal definitions and formulas. Are you ready? Let’s get started!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是不是令人感到压倒性、复杂和困难？别担心。在这一章中，我将尝试以每个人都能理解的方式介绍算法这一主题，而不仅仅是数学家或其他科学家。因此，在这一章中，你会发现一些简化，以便使这个主题更简单、更容易理解。然而，目标是让你对这个主题感兴趣，**而不是创建另一本包含大量正式定义和公式的学术出版物或书籍**。你准备好了吗？让我们开始吧！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: What are algorithms?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: Notations for algorithm representation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法表示的符号
- en: Types of algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的类型
- en: Computational complexity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算复杂性
- en: What are algorithms?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: Did you know you typically use algorithms every day and that you are already
    an author of some algorithms, even without writing any lines of code or drawing
    a diagram? If this sounds impossible, give me a few minutes and read this section
    to get to know how is it possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗，你通常每天都会使用算法，甚至在没有编写任何代码或绘制图表的情况下，你已经是某些算法的作者了吗？如果这听起来不可能，给我几分钟时间，阅读这一节来了解这是如何可能的。
- en: Definition
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义
- en: 'First, you need to know what an **algorithm** is. It is a **well-defined solution
    for solving a particular problem or performing a computation**. It is an ordered
    list of precise **instructions** that are performed in a given order and take
    a well-defined **input** into account (if any) to produce a well-defined **output**,
    as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要知道什么是**算法**。它是一个**为解决特定问题或执行计算而定义良好的解决方案**。它是一系列按给定顺序执行的精确**指令**，考虑（如果有）一个定义良好的**输入**，以产生一个定义良好的**输出**，如下所示：
- en: '![Figure 2.1 – Illustration of an algorithm](img/B18069_02_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 算法的示意图](img/B18069_02_1.jpg)'
- en: Figure 2.1 – Illustration of an algorithm
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 算法的示意图
- en: To be more precise, **an algorithm should contain a finite sequence of unambiguous
    instructions, which provides you with an effective and efficient way of solving
    the problem**. Of course, an algorithm can contain **conditional expressions**,
    **loops**, or **recursion**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要更精确地说，**算法应该包含有限的一系列明确指令，这为你提供了一种有效且高效地解决问题的方法**。当然，算法可以包含**条件表达式**、**循环**或**递归**。
- en: Where can you find more information?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里可以找到更多信息？
- en: If you are interested in the topic of algorithms, you can find a lot of detailed
    information about them in many books, including *Introduction to Algorithms*,
    by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.
    Of course, there are also many resources available online, such as *GeeksForGeeks*
    ([https://www.geeksforgeeks.org](https://www.geeksforgeeks.org)), *The Algorithms*
    ([https://the-algorithms.com](https://the-algorithms.com)), and *Algorithms, 4th
    Edition*, by Robert Sedgewick and Kevin Wayne ([https://algs4.cs.princeton.edu](https://algs4.cs.princeton.edu)).
    A huge number of resources is also available if you browse the *Algorithms* topic
    on GitHub ([https://github.com/topics/algorithms](https://github.com/topics/algorithms)).
    I strongly encourage you to search for various resources, either in books or over
    the internet, and continue learning about algorithms when you’ve finished reading
    this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个算法主题感兴趣，你可以在许多书中找到关于它们的详细信息，包括托马斯·H·科门、查尔斯·E·利瑟森、罗纳德·L·里维斯和克利福德·斯坦因合著的《算法导论》。当然，还有许多在线资源，如*GeeksForGeeks*
    ([https://www.geeksforgeeks.org](https://www.geeksforgeeks.org))、*The Algorithms*
    ([https://the-algorithms.com](https://the-algorithms.com))和罗伯特·赛奇威克与凯文·韦恩合著的《算法，第4版》([https://algs4.cs.princeton.edu](https://algs4.cs.princeton.edu))。如果你在GitHub上浏览*算法*主题，你还可以找到大量的资源([https://github.com/topics/algorithms](https://github.com/topics/algorithms))。我强烈建议你在阅读完这本书后，在书籍或互联网上搜索各种资源，并继续学习算法。
- en: Real-world examples
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: With the definition of algorithms under your belt, you might be thinking, “*Come
    on – inputs, outputs, instructions… where I can find them?*” The answer turns
    out to be much simpler than you might expect because you can find such items almost
    everywhere, all the time!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握算法的定义后，你可能正在想，“**好吧——输入、输出、指令……我在哪里能找到它们？**”答案比你想象的要简单得多，因为你可以几乎在任何地方、任何时候找到这些项目！
- en: Let’s start with a **simple morning routine**. First, you wake up and take a
    look at your phone. If there are any notifications, you go through them and reply
    to urgent messages. For any unurgent items, you postpone them. Then, you go to
    the bathroom. If it is occupied, you wait until it is free, telling the person
    inside to hurry up. As soon as you are in the bathroom, you take a shower and
    brush your teeth. Finally, you choose suitable clothes according to the current
    weather and temperature. Surprise! Your morning routine is an algorithm. You can
    describe it as a set of instructions, which has some inputs, such as notifications
    and the current temperature, as well as outputs, such as chosen clothes. What’s
    more, some of the instructions are conditional, such as only replying to urgent
    messages. Others can be executed in a loop, such as waiting until the bathroom
    is vacant.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**简单的早晨例行程序**开始。首先，你醒来，看看你的手机。如果有任何通知，你会浏览它们并回复紧急信息。对于任何非紧急事项，你会推迟它们。然后，你去洗手间。如果它被占用，你会等待直到它空闲，告诉里面的人快点。一旦你在洗手间里，你就洗澡并刷牙。最后，你根据当前的天气和温度选择合适的衣服。惊喜！你的早晨例行程序就是一个算法。你可以将其描述为一系列指令，它有一些输入，例如通知和当前温度，以及输出，例如选择的衣服。更重要的是，一些指令是条件性的，例如只回复紧急信息。其他指令可以在循环中执行，例如等待洗手间空闲。
- en: The preceding morning routine also contains other algorithms, such as those
    for **unlocking a smartphone using face recognition**. It is an algorithm-based
    mechanism that you can use to ensure that only you can unlock your phone. What’s
    more, even **organizing notifications on your phone** is the result of an algorithm
    that takes into account notifications as input, arranges them into groups, and
    sorts them suitably before presenting them to you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述早晨例行程序还包含其他算法，例如使用**面部识别解锁智能手机**的算法。这是一个基于算法的机制，你可以用它来确保只有你才能解锁你的手机。更重要的是，甚至**在手机上组织通知**也是考虑通知作为输入，将它们分组并适当排序后呈现给你的算法的结果。
- en: At this point, you are dressed up and ready for a healthy and yummy breakfast.
    Imagine that you want to **prepare scrambled eggs** using your grandma’s secret
    recipe. You need some ingredients, namely three eggs, salt, and pepper. As a result,
    you will have created an amazing dish for your perfect breakfast. First, you crack
    the eggs into a bowl and whisk them with a pinch of salt and pepper. Then, you
    melt butter in a non-stick skillet over medium-low heat. Next, you pour the egg
    mixture into the skillet and keep the eggs moving until there is no liquid egg.
    With that, your breakfast is ready. However, what is it if not a well-written
    and organized algorithm with a precise input and yummy output?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你已经穿戴整齐，准备享用一顿健康美味的早餐。想象一下，你想要用你奶奶的秘密食谱**准备炒鸡蛋**。你需要一些原料，即三个鸡蛋、盐和胡椒。结果，你将为你完美的早餐制作出一道惊人的菜肴。首先，你将鸡蛋敲入碗中，并用一小撮盐和胡椒搅拌。然后，你在中火至小火的平底锅中融化黄油。接下来，你将鸡蛋混合物倒入平底锅中，并保持鸡蛋移动，直到没有液态鸡蛋。这样，你的早餐就准备好了。然而，如果没有一个写得很好且组织有序的算法，具有精确的输入和美味的输出，那它又是什么呢？
- en: After breakfast, you need to go to work. So, you jump into your car and launch
    a navigation app on your smartphone to see **the fastest route to work** while
    taking the current traffic into account. This task is performed by complicated
    algorithms that can even involve **artificial intelligence** (**AI**), together
    with a computer-understandable representation of routes that use specialized data
    structures, as well as data obtained from other users. When combined, this forms
    traffic data. As you can see, the algorithm takes the complex input and performs
    various calculations to present you with an ordered list of route directions –
    for example, go to route A4, turn right to route S19, and follow this route until
    you reach your destination.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 早餐后，你需要去上班。所以，你跳进你的车，在智能手机上启动导航应用，查看考虑到当前交通情况的**最快路线**。这个任务由复杂的算法完成，甚至可能涉及**人工智能**（**AI**），以及使用专用数据结构表示的计算机可理解的路由，以及从其他用户那里获得的数据。当它们结合在一起时，就形成了交通数据。正如你所见，算法对复杂的输入进行各种计算，为你提供一个有序的路线方向列表——例如，前往A4路线，右转至S19路线，并沿着这条路线直到你到达目的地。
- en: While at work, you need to prepare documents for your accountant, so you need
    to gather documents from colleagues, print some of them from emails, and then
    **sort all invoices by numbers**. How do you perform sorting? You take the first
    document from the stack and put it on the table. Then, you take the second document
    from the unsorted stack and put it either above, if the number is smaller than
    the first invoice, or below the previous one. Then, you take the third invoice
    and find a suitable place for it in the ordered stack. You perform this operation
    until there are no documents in the unsorted stack. Wow, another algorithm? Exactly!
    This is one of **sorting algorithms**. You'll learn about them in the next chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作中，你需要为你的会计师准备文件，因此你需要从同事那里收集文件，从电子邮件中打印一些，然后**按编号对所有发票进行排序**。你如何进行排序？你从文件堆中取出第一份文件并将其放在桌子上。然后，你从未排序的文件堆中取出第二份文件，如果编号小于第一张发票，就把它放在上面，否则就放在上一张下面。接着，你取出第三张发票，并在有序的文件堆中找到合适的位置。你一直这样做，直到未排序的文件堆中没有文件为止。哇，又一个算法？没错！这正是**排序算法**之一。你将在下一章中了解它们。
- en: It’s time for a break at work! You launch your favorite social app and **receive
    suggestions for new friends**. However, how are they found and proposed to you?
    Yes, you’re right – this is another algorithm that takes data from your profile
    and your activities, as well as the data of available users, as input, and returns
    a collection of best-suited suggestions for you. It can use many complex and advanced
    techniques, such as **machine learning** (**ML**) algorithms, which can learn
    and take your previous reactions into account. Just think for a second about the
    data structures that can be used in such cases. How you can organize your relationships
    with friends and how can you find out how many other people are between you and
    your favorite actor from Hollywood? It would be great to know that your friend
    knows Mary, who knows Adam, who is a friend of your idol, wouldn’t it? Such a
    task can be accomplished using some graph-based structures, as you will see later
    in this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 工作时间到了，该休息一下了！你打开你最喜欢的社交应用，**收到新朋友的建议**。然而，他们是如何被找到并推荐给你的呢？是的，你是对的——这又是另一个算法，它从你的个人资料和活动数据以及可用用户的数据中获取输入，并为你返回一系列最适合的建议。它可以使用许多复杂和高级的技术，例如**机器学习**（ML）算法，这些算法可以学习并考虑你之前的反应。想想看，在这种情况下可以使用哪些数据结构。你如何组织与朋友的关系，以及你如何找出有多少其他人在你和好莱坞你最喜欢的演员之间？知道你的朋友认识玛丽，玛丽认识亚当，亚当是你的偶像的朋友，这不是很好吗？这样的任务可以使用一些图结构来完成，正如你将在本书后面看到的。
- en: Will you learn about AI algorithms in this book?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在本书中学到AI算法吗？
- en: Unfortunately, no. Due to the limited number of pages, various algorithms related
    to AI are not included in this book. However, note that it is a very interesting
    topic that involves many concepts, such as **ML** and **deep learning** (**DL**),
    which are used in many applications, including recommendation systems, speech-to-text,
    searching over extremely high amounts of data (the concept of **big data**), generating
    textual and graphical content, as well as controlling self-driving cars. To achieve
    these goals, a lot of interesting algorithms are used. I strongly encourage you
    to take a look at this topic on your own or choose one of Packt’s books that focuses
    on AI-related topics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，不是的。由于页面有限，本书没有包括与AI相关的各种算法。然而，请注意，这是一个非常有趣的话题，涉及许多概念，例如**机器学习**（ML）和**深度学习**（DL），这些在许多应用中使用，包括推荐系统、语音转文本、在极大量数据上搜索（大数据的概念）、生成文本和图形内容，以及控制自动驾驶汽车。为了实现这些目标，使用了大量有趣的算法。我强烈建议你亲自研究这个话题，或者选择Packt出版的专注于AI相关主题的书籍之一。
- en: Are these examples enough? If not, just think about **choosing a movie in a
    cinema for the evening** while considering the AI-based suggestions of movies
    with geolocation-based data of cinemas, or **setting a clock alarm** depending
    on your plan for the next day. As you can see, **algorithms are everywhere and
    all of us use them, even if we do not** **realize it**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子足够了吗？如果还不够，就想想在晚上去电影院看电影时**选择一部电影**，同时考虑基于电影院地理位置数据的电影推荐，或者根据你第二天计划的**设定闹钟**。正如你所看到的，**算法无处不在，我们都在使用它们，即使我们没有意识到**。
- en: So, if algorithms are so common and so useful, why don’t we benefit from the
    huge collection of ones that are available or even write our own algorithms? There
    are still some problems that need to be solved using algorithms. I, as the author
    of this book, am keeping my fingers crossed for you to solve them!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果算法如此普遍且如此有用，我们为什么不从可用的巨大算法集合中受益，甚至编写我们自己的算法呢？仍然有一些问题需要使用算法来解决。作为这本书的作者，我衷心希望你能解决这些问题！
- en: Notations for algorithm representation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法表示的符号
- en: In the previous section, algorithms were presented in English. However, this
    is not the only way of specifying and documenting an algorithm. In this section,
    you will learn about four notations for algorithm representation, namely **natural
    language**, **flowchart, pseudocode**, and **programming language**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，算法是用英语表示的。然而，这并不是指定和记录算法的唯一方式。在本节中，你将了解四种算法表示的符号，即**自然语言**、**流程图**、**伪代码**和**编程语言**。
- en: 'To make this task easier to understand, you will specify the algorithm for
    calculating an **arithmetic mean** in all of these notations. As a reminder, the
    mean can be calculated using the following formula:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个任务更容易理解，你将使用所有这些符号指定计算**算术平均值**的算法。作为提醒，平均值可以使用以下公式计算：
- en: '![Figure 2.2 – Formula for calculating an arithmetic mean](img/B18069_02_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 计算算术平均数的公式](img/B18069_02_2.jpg)'
- en: Figure 2.2 – Formula for calculating an arithmetic mean
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 计算算术平均数的公式
- en: As you can see, two inputs are used, namely the provided numbers (*a*) and the
    total number of elements (*n*). If no numbers are provided, `null` is returned,
    indicating that no mean is available. Otherwise, you sum the numbers and divide
    them by the total number of elements to get the result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用了两个输入，即提供的数字（*a*）和元素总数（*n*）。如果没有提供数字，则返回`null`，表示没有可用的平均值。否则，您将数字相加，然后除以元素总数以获得结果。
- en: Natural language
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然语言
- en: 'First, let’s specify the algorithm using a natural language. It is a very easy
    way of providing information about algorithms, but it can be ambiguous and unclear.
    So, let’s describe our algorithm in this way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用自然语言指定算法。这是一种提供算法信息非常简单的方法，但它可能含糊不清。因此，让我们这样描述我们的算法：
- en: '*The algorithm reads the input, which represents the total number of elements
    from which an arithmetic mean will be calculated. If the entered number is equal
    to 0, the algorithm should return null. Otherwise, it should read the numbers
    in the amount equal to the expected total count. Finally, it should return the
    result as the sum of numbers divided by* *their count.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*该算法读取输入，表示将从其中计算算术平均数的元素总数。如果输入的数字等于0，则算法应返回null。否则，它应读取等于预期总数量的数字。最后，它应以数字的总和除以它们的数量作为结果返回。*'
- en: Quite simple and understandable, isn’t it? You can use this notation for simple
    algorithms, but it can be useless for complex and advanced algorithms. Of course,
    some descriptions in the natural language are often useful, regardless of the
    complexity of an algorithm. They can give you a brief understanding of what the
    aim of the algorithm is, how it works, and what aspects should be taken into account
    while you’re analyzing or implementing the algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单易懂，不是吗？您可以使用这种符号表示简单的算法，但对于复杂和高级算法可能毫无用处。当然，无论算法的复杂程度如何，自然语言中的某些描述通常是有用的。它们可以为您提供算法目的的简要了解，以及算法的工作原理和您在分析或实现算法时应考虑的方面。
- en: Flowchart
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程图
- en: 'Another way of presenting an algorithm is via a **flowchart**. A flowchart
    uses a set of graphical elements to prepare a diagram that specifies the algorithm’s
    operation. Some of the available symbols are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示算法的方法是通过**流程图**。流程图使用一组图形元素来准备一个指定算法操作的图表。以下是一些可用的符号：
- en: '![Figure 2.3 – The available symbols while designing a flowchart](img/B18069_02_3.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 设计流程图时可用符号](img/B18069_02_3.jpg)'
- en: Figure 2.3 – The available symbols while designing a flowchart
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 设计流程图时可用符号
- en: The algorithm should contain the **entry point** and one or more **exit points**.
    It can also contain other blocks, including **operation**, **input**, **output**,
    or **condition**. The following blocks are connected with **arrows** that specify
    the order of execution. You can also draw **loops**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 算法应包含**入口点**和一个或多个**出口点**。它还可以包含其他块，包括**操作**、**输入**、**输出**或**条件**。以下块通过**箭头**连接，指定执行顺序。您还可以绘制**循环**。
- en: 'Let’s take a look at a flowchart for calculating the arithmetic mean:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看计算算术平均数的流程图：
- en: '![Figure 2.4 – Flowchart for calculating the arithmetic mean](img/B18069_02_4.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 计算算术平均数的流程图](img/B18069_02_4.jpg)'
- en: Figure 2.4 – Flowchart for calculating the arithmetic mean
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 计算算术平均数的流程图
- en: The execution starts in the `START` block. Then, we assign `0` as a value of
    the `sum` variable, which stores the sum of all the entered numbers. Next, we
    read a value from the input and store it as a value of the `n` variable. This
    is the total number of elements used to calculate the arithmetic mean. Next, we
    check whether `n` is equal to `0`. If so, the `YES` branch is chosen, `null` is
    returned to the output, and the execution stops. If `n` is not equal to `0`, the
    `NO` branch is chosen and we assign `0` as a value of the `i` variable. It stores
    the number of elements already read from the input. Next, we read the number from
    the input and save it as a value of the `a` variable. The following operation
    block increases `sum` by the value of `a`, as well as increments the value of
    `i`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行从`START`块开始。然后，我们将`sum`变量的值赋为`0`，该变量存储所有输入数字的总和。接下来，我们从输入读取一个值并将其存储为`n`变量的值。这是用于计算算术平均数的元素总数。接下来，我们检查`n`是否等于`0`。如果是这样，则选择`YES`分支，将`null`返回到输出，并停止执行。如果`n`不等于`0`，则选择`NO`分支，并将`i`变量的值赋为`0`。它存储已从输入中读取的元素数量。接下来，我们从输入读取一个数字并将其保存为`a`变量的值。接下来的操作块将`sum`增加`a`的值，并增加`i`的值。
- en: The next block is a conditional one that checks whether `i` is not equal to
    `n`, which means that the required number of elements is not read from the input
    yet. If `i` is equal to `n`, the `NO` branch is chosen and a value of the `result`
    variable is set to a result of a division of `sum` by `n`. Then, the `result`
    variable is returned and the execution stops. An interesting construction is used
    when the conditional expression evaluates to `true`, which means that we need
    to read another input. Then, the loop is used and the execution comes back just
    before the input block for reading `a`. Thus, we can execute some operations multiple
    times, until the condition is met.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个块是一个条件块，它检查`i`是否不等于`n`，这意味着所需的元素数量尚未从输入中读取。如果`i`等于`n`，则选择`NO`分支，并将`result`变量的值设置为`sum`除以`n`的结果。然后，返回`result`变量并停止执行。当条件表达式评估为`true`时，使用了一个有趣的构造，这意味着我们需要读取另一个输入。然后，使用循环，执行回到读取`a`的输入块之前。因此，我们可以多次执行某些操作，直到满足条件。
- en: As you can see, a flowchart is a diagram that makes it possible to specify a
    way of algorithm operation in a more precise way than using natural language.
    It is an interesting option for simple algorithms, but it can be quite cumbersome
    in the case of advanced and complex ones, where it is impossible to present the
    whole operation within a diagram of a reasonably small size.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，流程图是一种图表，它以比自然语言更精确的方式指定算法的操作方式。对于简单的算法来说，这是一个有趣的选择，但在高级和复杂的算法中，它可能相当繁琐，因为不可能在合理大小的图表中展示整个操作。
- en: Pseudocode
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟代码
- en: The next notation we’ll look at is **pseudocode**. It allows you to specify
    algorithms in another way, which is a bit similar to the code written in a programming
    language. Here, we use the English language to define inputs and outputs, as well
    as to present a set of instructions clearly and concisely, but without the syntax
    of any programming language.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探讨的下一个表示法是**模拟代码**。它允许你以另一种方式指定算法，这与编写在编程语言中的代码有点相似。在这里，我们使用英语来定义输入和输出，以及清晰地、简洁地展示一系列指令，但不包含任何编程语言的语法。
- en: 'Here’s some example pseudocode for calculating the arithmetic mean:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用于计算算术平均数的模拟代码示例：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the pseudocode provides us with a syntax that is easy to understand
    and follow, as well as quite close to a programming language. For this reason,
    it is a precise way of algorithm presentation and documentation that can be later
    used to transform it into a set of instructions in our chosen programming language.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模拟代码为我们提供了一种易于理解和遵循的语法，以及相当接近编程语言的语法。因此，它是一种精确的算法表示和文档化方式，可以后来将其转换为所选编程语言中的一系列指令。
- en: Programming language
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程语言
- en: 'Now, let’s look at the last form of algorithm notation: **programming language**.
    It is very precise, can be compiled and run. Thus, we can see the result of its
    operation and check it using a set of test cases. Of course, we can implement
    an algorithm in any programming language. However, in this book, you will see
    only examples in the C# language.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看算法表示法的最后一种形式：**编程语言**。它非常精确，可以编译和运行。因此，我们可以看到其操作的结果，并使用一组测试案例进行检查。当然，我们可以用任何编程语言实现算法。然而，在这本书中，你将只会看到用C#语言编写的示例。
- en: 'Let’s take a look at the implementation of the mean calculation algorithm:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看均值计算算法的实现：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code contains an `if` conditional statement and a `do-while` loop.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码包含一个`if`条件语句和一个`do-while`循环。
- en: 'If we run the application, we need to enter the number of elements from which
    we would like to calculate the arithmetic mean. Then, we will be asked to enter
    the number `n` times. When the number of provided elements is equal to the expected
    value, the result is calculated and presented in the console, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们需要输入要计算算术平均值的元素数量。然后，我们将被要求输入数字`n`次。当提供的元素数量等于预期值时，结果将在控制台计算并显示，如下所示：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s all! Now, you know what algorithms are, where you can find them in your
    daily life, as well as how to represent algorithms using natural language, flowcharts,
    pseudocode, and programming languages. With this knowledge, let’s proceed to learn
    about different types of algorithms, including recursive and heuristic algorithms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在，你知道了算法是什么，你可以在日常生活中找到它们，以及如何使用自然语言、流程图、伪代码和编程语言来表示算法。有了这些知识，让我们继续学习不同类型的算法，包括递归和启发式算法。
- en: Types of algorithms
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法类型
- en: As mentioned previously, algorithms are almost everywhere, and even intuitively,
    you use them each day while solving various tasks. There is an enormous amount
    of algorithms and a lot of their types, chosen according to different criteria.
    To simplify this topic, only a few types will be presented here, chosen from different
    classifications, to show you a variety and encourage you to learn more about them
    on your own. It is also quite common that the same algorithm is classified into
    a few groups.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，算法几乎无处不在，甚至直观上，你在解决各种任务时每天都在使用它们。有大量的算法和许多类型，根据不同的标准进行选择。为了简化这个主题，这里将只展示一些类型，这些类型来自不同的分类，以展示多样性并鼓励你自己了解更多。同样，同一个算法也可能被归入几个不同的组。
- en: Recursive algorithms
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归算法
- en: First, let’s take a look at **recursive algorithms**, which are strictly connected
    with the idea of **recursion** and are the opposite of **iterative algorithms**.
    What does this mean? **An algorithm is recursive if it calls itself to solve smaller
    subproblems of the original problem**. The algorithm calls itself multiple times
    until the **base condition** is met.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看**递归算法**，它与**递归**的概念紧密相连，是**迭代算法**的对立面。这意味着什么？**如果一个算法通过调用自身来解决原始问题的较小子问题，则该算法是递归的**。算法会多次调用自身，直到满足**基本条件**。
- en: This technique provides you with a powerful solution for solving problems, can
    limit the amount of code, and can be easy to understand and maintain. However,
    recursion has some drawbacks related to performance or the requirement for more
    space in the stack’s memory, which could lead to stack overflow problems. Fortunately,
    you can prevent some of these issues using **dynamic programming**, an optimization
    technique that supports recursion.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为你提供了解决问题的强大解决方案，可以限制代码量，并且易于理解和维护。然而，递归有一些与性能或栈内存空间需求相关的缺点，这可能导致栈溢出问题。幸运的是，你可以使用**动态规划**来预防这些问题，这是一种支持递归的优化技术。
- en: 'Recursion can be used in several algorithms, including the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 递归可以在多个算法中使用，包括以下：
- en: Sorting an array with the **merge sort** and **quicksort** algorithms, which
    are implemented and presented in detail in [*Chapter 3*](B18069_03.xhtml#_idTextAnchor088),
    *Arrays* *and Sorting*
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**归并排序**和**快速排序**算法对数组进行排序，这些算法在[*第3章*](B18069_03.xhtml#_idTextAnchor088)中详细实现和介绍，*数组和排序*
- en: Solving the **Towers of Hanoi** game, as depicted in [*Chapter 5*](B18069_05.xhtml#_idTextAnchor165),
    *Stacks* *and Queues*
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**汉诺塔**游戏，如[*第5章*](B18069_05.xhtml#_idTextAnchor165)中所示，*栈和队列*
- en: '**Traversing a tree**, as described in [*Chapter 7*](B18069_07.xhtml#_idTextAnchor233),
    *Variants* *of Trees*'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遍历树**，如[*第7章*](B18069_07.xhtml#_idTextAnchor233)中所述，*树的变体*'
- en: Getting a number from the **Fibonacci series**, as shown in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See* *in Action*
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**斐波那契数列**中获取一个数，如[*第9章*](B18069_09.xhtml#_idTextAnchor367)中所示，*实战* *见*
- en: '**Generating fractals**, as shown in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See* *in Action*'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成分形**，如[*第9章*](B18069_09.xhtml#_idTextAnchor367)中所示，*实战* *见*'
- en: Calculating a `n!`)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算`n!`
- en: Getting the **greatest common divisor of two numbers** using the Euclidean algorithm
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用欧几里得算法计算**两个数的最大公约数**
- en: '**Traversing the filesystem** with directories and subdirectories'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遍历文件系统**中的目录和子目录'
- en: Divide and conquer algorithms
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: Another group of algorithms is named **divide and conquer**. It is related to
    the **algorithmic paradigm of solving a problem by breaking it down into smaller
    subproblems (the “divide” step), calling them recursively until they are simple
    enough to be solved directly (“conquer”), and combining the results of subproblems
    to get the final result (“combine”)**. This approach has many advantages, also
    taken from the pros of recursion, including ease of implementation, understanding,
    and maintenance. By dividing the problem into many subproblems, it supports **parallel
    computing**, which can lead to performance improvements. Unfortunately, this paradigm
    also has some disadvantages, including the necessity for a proper base case definition
    to terminate the execution of the algorithm. Performance issues, similar as in
    the case of recursive algorithms, can exist as well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组算法被称为**分而治之**。它与**通过将问题分解为更小的子问题（“分”步骤）来解决问题的算法范式相关**，递归调用它们，直到它们足够简单可以直接解决（“治”），然后将子问题的结果组合起来以获得最终结果（“合”）。这种方法具有许多优点，也借鉴了递归的优点，包括易于实现、理解和维护。通过将问题分解为许多子问题，它支持**并行计算**，这可能导致性能提升。不幸的是，这种范式也有一些缺点，包括需要正确定义基本案例以终止算法的执行。与递归算法类似，也可能存在性能问题。
- en: 'Divide and conquer is a popular approach for solving various algorithmic problems
    and you can see its implementations in a broad range of applications:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之是解决各种算法问题的流行方法，您可以在广泛的应用程序中看到其实现：
- en: Sorting an array with the **m****erge sort** and **quicksort** algorithms, which
    are implemented and presented in detail in [*Chapter 3*](B18069_03.xhtml#_idTextAnchor088),
    *Arrays* *and Sorting*
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**归并排序**和**快速排序**算法对数组进行排序，这些算法在[*第3章*](B18069_03.xhtml#_idTextAnchor088)中实现并详细介绍，*数组和排序*
- en: '**Finding the closest pair of points** located on the two-dimensional surface,
    which will be presented in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367), *See*
    *in Action*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**找到**位于二维表面上的**最近点对**，这将在[*第9章*](B18069_09.xhtml#_idTextAnchor367)中介绍，*见*
    *实际操作*'
- en: Calculating the **power of** **a number**
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算一个数的**幂**
- en: Finding the **minimum and maximum values** in an array
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组中找到**最小值和最大值**
- en: Calculating the **fast** **Fourier transform**
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算快速**傅里叶变换**
- en: '**Multiplying large numbers** using Karatsuba’s algorithm'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Karatsuba算法**进行**大数乘法**'
- en: Back-tracking algorithms
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回溯算法
- en: Next, we’ll cover **back-tracking algorithms**. **They are used for solving
    problems that consist of a sequence of decisions, each depending on the decisions
    that have already been taken, incrementally building the solution. When you realize
    that the decisions that have been taken do not provide the correct solution, you**
    **backtrack**. Of course, you can support this approach with recursion to try
    various variants and therefore find a suitable solution, if one exists.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍**回溯算法**。**它们用于解决由一系列决策组成的问题，每个决策都依赖于已经做出的决策，逐步构建解决方案。当您意识到已经做出的决策不能提供正确的解决方案时，您**
    **回溯**。当然，您可以使用递归来支持这种方法，尝试各种变体，从而找到合适的解决方案，如果存在的话。
- en: 'You can use this approach for many tasks, including the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方法来完成许多任务，包括以下内容：
- en: Solving the **rat in a maze** problem, as shown in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See* *in Action*
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**迷宫中的老鼠**问题，如[*第9章*](B18069_09.xhtml#_idTextAnchor367)中所示，*见* *实际操作*
- en: Solving **Sudoku**, as shown in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See* *in Action*
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[*第9章*](B18069_09.xhtml#_idTextAnchor367)中所示，解决**数独**，*见* *实际操作*
- en: Solving **crosswords** by entering letters into empty spaces
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在空格中输入字母来解决**填字游戏**
- en: Solving the **eight queens** problem of placing eight queens on a chessboard
    and not allowing them to attack each other
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**八皇后问题**，即在棋盘上放置八个皇后，并确保它们不能相互攻击
- en: Solving the **knight’s tour**, where you place a knight on the first block on
    a chessboard and move it so that it visits all blocks exactly once
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**骑士巡游问题**，其中您在棋盘的第一个方块上放置一个骑士，并移动它以便它恰好访问所有方块一次
- en: Generating **gray codes** to create bit patterns where the following ones differ
    by one bit only
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成**格雷码**以创建只有一位不同的位模式
- en: Solving the **m-coloring problem** for graph-related topics
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决与图相关主题的**m-着色问题**
- en: Greedy algorithms
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贪心算法
- en: Now that we’ve covered the recursive, divide-and-conquer, and back-tracking
    algorithms, it’s high time to present another type, namely greedy algorithms.
    **A** **greedy algorithm** **builds the solution piece by piece by choosing the
    best option in each step, not concerned about the overall solution, and being
    short-sighted in its operation**. For this reason, there is no guarantee that
    the final result is optimal. However, in many scenarios, using the local optimal
    solutions can lead to global optimal solutions or can be good enough.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了递归、分治和回溯算法，是时候介绍另一种类型了，即贪心算法。**贪心算法**通过在每一步选择最佳选项来逐步构建解决方案，不考虑整体解决方案，并且在操作上具有短视性。因此，无法保证最终结果是最优的。然而，在许多场景中，使用局部最优解可以导致全局最优解，或者足够好。
- en: 'Here are some examples:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: Finding the shortest path in a graph using **Dijkstra’s algorithm**, as shown
    and explained in detail in [*Chapter 8*](B18069_08.xhtml#_idTextAnchor296), *Exploring
    Graphs*
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**迪杰斯特拉算法**在图中找到最短路径，如[*第8章*](B18069_08.xhtml#_idTextAnchor296)《探索图论》中所示并详细解释。
- en: Calculating the minimum spanning tree in a graph with **Kruskal’s algorithm**
    and **Prim’s algorithm**, as shown in [*Chapter 8*](B18069_08.xhtml#_idTextAnchor296),
    *Exploring Graphs*
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[*第8章*](B18069_08.xhtml#_idTextAnchor296)《探索图论》中所示，使用**克鲁斯卡尔算法**和**普里姆算法**计算图中的最小生成树
- en: Solving the **minimum coin change** problem, as explained in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See* *in Action*
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**最小硬币找零问题**，如[*第9章*](B18069_09.xhtml#_idTextAnchor367)《见行动》中解释。
- en: The greedy approach to **Huffman coding** in **data** **compression algorithms**
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据压缩算法**中**霍夫曼编码**的贪心方法'
- en: '**Load balancing** and **network routing**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**和**网络路由**'
- en: Heuristic algorithms
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启发式算法
- en: Now, it’s time to add more “magic” to your algorithms via heuristics! **A**
    **heuristic algorithm** **calculates a near-optimal solution for an optimization
    problem and is especially useful for scenarios when the exact methods are not
    available or are too slow. Thus, you can see a significant speed boost, but with
    a decreased accuracy of the result.** Such an approach is popular and adequate
    for solving various real-world problems, often complex and big, and is applied
    in many different fields of science, even those regarding bioinformatics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过启发式算法给你的算法添加更多“魔法”了！**启发式算法**为优化问题计算一个近似最优解，特别适用于精确方法不可用或太慢的场景。因此，你可以看到显著的加速，但结果的准确性会降低。**这种方法**在解决各种现实世界问题中很受欢迎且适用，这些问题通常很复杂且规模很大，并且应用于许多不同的科学领域，甚至包括生物信息学。
- en: 'Heuristic algorithms have many applications and subtypes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式算法有许多应用和子类型：
- en: '**Genetic algorithms**, which are **adaptive heuristic search algorithms**,
    and can be used to guess the title of this book, as depicted in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See* *in Action*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗传算法**，这是一种**自适应启发式搜索算法**，可以用来猜测这本书的标题，如[*第9章*](B18069_09.xhtml#_idTextAnchor367)《见行动》中所示。'
- en: Solving **vehicle routing problems** and the **traveling salesman problem**
    with the **Tabu** **Search algorithm**
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**禁忌搜索算法**解决**车辆路径问题**和**旅行商问题**
- en: Solving the **Knapsack problem**, where you need to choose items of the maximum
    total value to be packed within the mass limit
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**背包问题**，其中需要选择具有最大总价值的物品，在质量限制内打包
- en: '**Filtering and** **processing signals**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤和处理信号**'
- en: '**Detecting viruses**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测病毒**'
- en: Dynamic programming
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态规划
- en: 'Since we’re talking about various types of algorithms, it is worth mentioning
    **dynamic programming**. It is a **technique that optimizes recursive algorithms
    by limiting the necessity of computing the same result multiple times**. This
    technique can be used in one of two approaches:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论各种类型的算法，值得提一下**动态规划**。这是一种**通过限制重复计算相同结果的需要来优化递归算法的技术**。这种技术可以使用两种方法之一：
- en: The **top-down approach**, which uses **memoization** to save the results of
    subproblems. Therefore, the algorithm can use the value from the cache and does
    not need to recalculate the same results multiple times or does not need to call
    the method with the same parameters multiple times.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自顶向下**的方法，它使用**记忆化**来保存子问题的结果。因此，算法可以使用缓存中的值，无需多次重新计算相同的结果，或者无需多次调用具有相同参数的方法。'
- en: The **bottom-up approach**, which uses **tabulation** to replace recursion with
    iteration. It limits the number of function calls and problems regarding stack
    overflow.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自底向上的方法**，它使用**表格**来用迭代替换递归。它限制了函数调用的次数，并解决了栈溢出的问题。'
- en: Both of these approaches can significantly decrease the time complexity and
    increase performance, and therefore speed up your algorithm. Every time you use
    recursion, it is a good idea to try to optimize it using dynamic programming.
    If you want to learn how to optimize calculating a number from the **Fibonacci
    series**, go to [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367), *See* *in Action*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都可以显著降低时间复杂度并提高性能，因此可以加快你的算法。每次使用递归时，尝试使用动态规划优化它都是一个好主意。如果你想学习如何优化计算**斐波那契数列**中的数字，请参阅[*第9章*](B18069_09.xhtml#_idTextAnchor367)，*见*
    *实战*。
- en: You can also use dynamic programming to find the **shortest path between all
    pairs of vertices in a graph** by using the **Floyd-Warshall algorithm**, as well
    as in **Dijkstra’s algorithm**. Another application is for solving the **Tower
    of Hanoi** mathematical game. Possibilities are even broader and you can also
    apply it to **artificial** **neural networks**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用动态规划通过使用**Floyd-Warshall算法**在图中找到所有顶点对之间的**最短路径**，以及在**Dijkstra算法**中。另一个应用是解决**汉诺塔**数学游戏。可能性甚至更广泛，你还可以将其应用于**人工****神经网络**。
- en: Brute-force algorithms
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴力算法
- en: While we’re presenting various types of algorithms, we should also consider
    brute-force algorithms. **A** **brute-force algorithm** **is a general solution
    for solving a problem by checking all possible options and choosing the best one**.
    It is an approach that can have huge time complexity and its operation can take
    a lot of time, so it can be useless in real-world scenarios. However, a brute-force
    algorithm is often the first choice when you need to solve some algorithmic problem.
    There’s nothing bad in doing this as you can learn more about the domain of the
    problem you wish to solve and see some results for simpler cases. Nevertheless,
    while developing an algorithm, it is a good idea to enhance it significantly by
    using other paradigms.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍各种类型的算法时，我们也应该考虑暴力算法。**暴力算法**是解决一个问题的通用解决方案，通过检查所有可能的选项并选择最佳选项。这是一种可能具有巨大时间复杂度的方法，其操作可能需要很长时间，因此在现实场景中可能毫无用处。然而，当需要解决某些算法问题时，暴力算法通常是首选。这样做并没有什么不好，因为你可以更多地了解你想要解决的领域，并看到一些简单情况的结果。然而，在开发算法时，使用其他范式显著改进它是明智的。
- en: 'Here are some examples of where you can use brute-force algorithms:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以使用暴力算法的例子：
- en: '**Guessing a password**, where you check each possible password one after the
    other, as presented in [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367)*,* *See*
    *in Action*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**猜测密码**，正如在[*第9章*](B18069_09.xhtml#_idTextAnchor367)*,* *见* *实战*中所述，逐个检查每个可能的密码'
- en: '**Finding the minimum value in an unsorted array**, where you need to iterate
    through all items as there is no relationship between values in the array'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在未排序数组中寻找最小值**，因为你需要遍历所有项，因为数组中的值之间没有关系'
- en: '**Finding the best possible plan for a day**, placing various tasks between
    meetings, and trying to organize it in a way that you can start working late and
    ending early'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻找一天中最佳的计划**，在会议之间安排各种任务，并尝试以你可以晚些开始工作并早点结束的方式组织它'
- en: Solving the **traveling** **salesman** problem
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决**旅行商问题**
- en: After introducing a few types of algorithms, you can see that some of them provide
    you with a faster solution while others can have huge time complexity. But what
    does this mean? You will learn about computational complexity, especially time
    complexity, in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了几种算法类型之后，你会发现其中一些提供了更快的解决方案，而另一些则可能具有巨大的时间复杂度。但这意味着什么呢？你将在下一节中学习关于计算复杂度，特别是时间复杂度。
- en: Computational complexity
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算复杂度
- en: In this final section, let’s take a look at the **computational complexity**
    of algorithms, focusing on both **time complexity** and **space complexity**.
    Why is this so important? Because it can decide whether your algorithm can be
    used in real-world scenarios. As an example, which of the following do you prefer?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，让我们看看算法的**计算复杂度**，重点关注**时间复杂度**和**空间复杂度**。为什么这如此重要？因为它可以决定你的算法是否可以在现实场景中使用。例如，以下哪个是你更喜欢的？
- en: '*(A) Absolutely the best route directions to work, but you receive them after
    an hour, when you are already* *at work.*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (A) 绝对是最好的工作路线方向，但你是在已经**在工作**后一个小时才收到它们的。
- en: '*(B) Good enough route directions to work, but you receive them within a few
    seconds, a moment after you enter* *your car.*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (B) 足够好的工作路线方向，但你是在进入**你的车**后几秒钟内收到的。
- en: I am sure that you chose *B* – me too!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信你选择了**B** – 我也是！
- en: Time complexity
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间复杂度
- en: First, let’s focus on **time complexity**, which indicates **the amount of time
    necessary to run an algorithm as a function of the input length**, namely *n*.
    You can specify it using **asymptotic analysis**. This includes **Big-O notation**,
    which is used to indicate **how much time the algorithm will take with the increasing
    size of** **the input**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们关注**时间复杂度**，它表示**算法作为输入长度函数所需的时间量**，即*n*。你可以使用**渐近分析**来指定它。这包括**大O符号**，用于表示**算法随着输入大小的增加将花费多少时间**。
- en: For example, if you search for the minimum value in an unsorted array of size
    *n*, you need to visit all elements so that the maximum number of operations is
    equal to *n*, which is written as *O(n)*. If the algorithm iterates through each
    item in a two-dimensional array of size *n x n*, the time complexity is *O(n*n)*,
    so it is *O(n*2*)*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在一个大小为*n*的无序数组中搜索最小值，你需要访问所有元素，因此最大操作数等于*n*，表示为*O(n)*。如果算法遍历一个大小为*n x
    n*的二维数组中的每个项目，时间复杂度是*O(n*n)*，所以它是*O(n^2)*。
- en: 'There are various time complexities, including the ones presented here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种时间复杂度，包括这里展示的：
- en: '![Figure 2.5 – Illustration of time complexities](img/B18069_02_5.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 时间复杂性的说明](img/B18069_02_5.jpg)'
- en: Figure 2.5 – Illustration of time complexities
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 时间复杂性的说明
- en: The first is **O(1)** and is named the **constant time**. It indicates an algorithm
    whose execution time does not depend on the input size. The exemplary operations
    consistent with the *O(1)* constraint are getting an *i*-th element from an array,
    checking whether a hash set contains a given value, or checking whether a number
    is even or odd.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是**O(1**)，被称为**常数时间**。它表示一个执行时间不依赖于输入大小的算法。符合**O(1)**约束的典型操作包括从数组中获取第*i*个元素、检查哈希集合是否包含给定值或检查一个数字是偶数还是奇数。
- en: The next time complexity shown here is **O(log n)**, which is named the **logarithmic
    time**. In this case, the execution time is not constant, but it increases slower
    than in the linear approach. A well-known example of the *O(log n)* constraint
    is the problem of finding an item in a sorted array with binary search.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里接下来展示的时间复杂度是**O(log n**)，被称为**对数时间**。在这种情况下，执行时间不是常数，但它的增长速度比线性方法慢。*O(log
    n)*约束的一个著名例子是在排序数组中使用二分查找来查找一个项目。
- en: The third case is **O(n)** and is named the **linear time**. Here, the execution
    time increases linearly with the input length. You can take an algorithm for finding
    the minimum or maximum value in an unordered list or simply finding a given value
    in an unordered list as examples of the *O(n)* constraint.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况是**O(n**)，被称为**线性时间**。在这里，执行时间与输入长度成线性增长。你可以将找到无序列表中最小或最大值的算法或简单地找到无序列表中的给定值作为**O(n**)约束的例子。
- en: The last time complexity shown here is the **polynomial time**, which is **O(n**m**)**,
    so it can be *O(n*2*)* (**quadratic time**), *O(n*3*)* (**cubic time**), and so
    on. In this case, the execution time increases much faster than in the case of
    the linear constraint. It can involve solutions that use nested loops. Examples
    include the bubble sort, insertion sort, and selection sort algorithms. We'll
    cover these in [*Chapter 3*](B18069_03.xhtml#_idTextAnchor088), *Arrays* *and
    Sorting*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最后展示的时间复杂度是**多项式时间**，表示为**O(n^m**)，所以它可以表示为*O(n^2)*（**二次时间**）、*O(n^3)*（**三次时间**）等等。在这种情况下，执行时间比线性约束的情况增长得更快。它可以涉及使用嵌套循环的解决方案。例如，冒泡排序、插入排序和选择排序算法。我们将在[*第3章*](B18069_03.xhtml#_idTextAnchor088)中介绍这些，*数组和排序*。
- en: Of course, there are even more time complexities available, among which you
    will find **double logarithmic time**, **polylogarithmic time**, **fractional
    power time**, **linearithmic time**, **exponential time**, and **factorial time**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多的时间复杂度可用，其中包括**双对数时间**、**多项对数时间**、**分数幂时间**、**线性对数时间**、**指数时间**和**阶乘时间**。
- en: Space complexity
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间复杂度
- en: Similar to time complexity, you can specify the **space complexity** using asymptotic
    analysis and the Big-O notation. Space complexity indicates **how much memory
    is necessary to run the algorithm with the increasing length of input**. You can
    use similar indicators, such as *O(1)*, *O(n)*, or *O(n*2*)*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与时间复杂度类似，你可以使用渐近分析和大O符号来指定**空间复杂度**。空间复杂度表示**随着输入长度的增加，运行算法所需的内存量**。你可以使用类似的指标，如*O(1)*，*O(n)*，或*O(n^2)*。
- en: Where can you find more information?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: In this chapter, only a very brief introduction to the subject of algorithms
    was presented. I strongly encourage you to try to broaden your knowledge regarding
    algorithms on your own. It is an extremely interesting and challenging topic.
    For example, you can learn more about various types of algorithms at [https://www.techtarget.com/whatis/definition/algorithm](https://www.techtarget.com/whatis/definition/algorithm)
    and at [https://www.geeksforgeeks.org/most-important-type-of-algorithms/](https://www.geeksforgeeks.org/most-important-type-of-algorithms/),
    while about the computational complexity at [https://en.wikipedia.org/wiki/Computational_complexity](https://en.wikipedia.org/wiki/Computational_complexity).
    I am keeping my fingers crossed for you success with algorithms!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，只对算法的主题进行了非常简短的介绍。我强烈建议你尝试自己扩展关于算法的知识。这是一个极其有趣且具有挑战性的主题。例如，你可以在[https://www.techtarget.com/whatis/definition/algorithm](https://www.techtarget.com/whatis/definition/algorithm)和[https://www.geeksforgeeks.org/most-important-type-of-algorithms/](https://www.geeksforgeeks.org/most-important-type-of-algorithms/)了解更多关于各种算法的类型，而在[https://en.wikipedia.org/wiki/Computational_complexity](https://en.wikipedia.org/wiki/Computational_complexity)了解计算复杂性。我衷心祝愿你在算法学习上取得成功！
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You’ve just completed the second chapter of this book, which was all about data
    structures and algorithms in the C# language. This time, we focused on algorithms
    and indicated their crucial role in the development of various applications, regardless
    of their types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了这本书的第二章，本章全部关于C#语言中的数据结构和算法。这次，我们专注于算法，并指出了它们在各种应用开发中的关键作用，无论其类型如何。
- en: First, you learned **what an algorithm is** and **where you can find algorithms**
    in your daily life. As you saw, algorithms are almost everywhere and you use and
    design them without even knowing it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你学习了**什么是算法**以及**在日常生活中你可以在哪里找到算法**。正如你所看到的，算法几乎无处不在，你甚至在不自知的情况下使用和设计它们。
- en: Then, you learned about **notations for algorithm representation**. There, you
    learned how to specify algorithms in a few ways, namely in a natural language,
    using a flowchart, via pseudocode, or directly in a programming language.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了**算法表示的符号**。在那里，你学习了如何以几种方式指定算法，即在自然语言中、使用流程图、通过伪代码或直接在编程语言中。
- en: Next, you learned **about a few different types of algorithms**, starting with
    the recursive algorithms that call themselves to solve smaller subproblems. Then,
    you learned about **divide and conquer** algorithms, which divide the problem
    into three stages, namely divide, conquer, and combine. Next, you learned about
    **back-tracking** algorithms, which allow you to solve problems consisting of
    a sequence of decisions, each depending on a decision that’s already been taken,
    together with the backtrack option if the decisions do not provide a correct solution.
    Then, you learned about **greedy** algorithms, which choose the best option in
    each step of their operation while not being concerned about the overall solution.
    Another group you learned about was **heuristic** algorithms for finding near-optimal
    solutions. Then, you learned that you can optimize recursive algorithms using
    **dynamic programming** and its top-down and bottom-up approaches. Finally, you
    learned about **brute-force** algorithms.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了**关于几种不同类型的算法**，从递归算法开始，这些算法通过调用自身来解决更小的子问题。然后，你学习了**分而治之**算法，它将问题分为三个阶段，即分解、征服和合并。接下来，你学习了**回溯**算法，它允许你解决由一系列决策组成的问题，每个决策都依赖于已经做出的决策，以及如果决策不提供正确解决方案时的回溯选项。然后，你学习了**贪心**算法，它们在操作的每一步都选择最佳选项，而不关心整体解决方案。你学习的一组算法还包括用于寻找近似最优解的**启发式**算法。然后，你学习了如何使用**动态规划**及其自顶向下和自底向上的方法来优化递归算法。最后，你学习了**暴力**算法。
- en: The final part of this chapter looked at **computational complexity** in terms
    of time and space complexity. Asymptotic analysis, together with Big-O notation,
    was presented.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一部分探讨了**计算复杂性**，从时间和空间复杂性的角度进行。介绍了渐近分析和大O符号。
- en: In the next chapter, we’ll cover **arrays** and various **sorting algorithms**.
    Are you ready to continue your adventure with data structures and algorithms in
    the C# language? If so, let’s go!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍**数组**和多种**排序算法**。你准备好继续在C#语言中探索数据结构和算法的冒险了吗？如果是的话，那就让我们出发吧！
