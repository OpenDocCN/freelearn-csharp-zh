- en: 4 REST APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 个 REST API
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下找到“architecting-aspnet-core-apps-3e”频道）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file19.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file19.png)'
- en: 'This chapter delves into the heart of web application communication–REST APIs.
    In today''s connected digital world, effective communication between different
    applications is paramount, and RESTful APIs play a pivotal role in facilitating
    this interaction.We start by exploring the basic fabric of the web: the HTTP protocol.
    We touch on the core HTTP methods such as GET, POST, PUT, and DELETE to see how
    they carry out CRUD (Create, Read, Update, Delete) operations in a RESTful context.
    We then turn our attention to HTTP status codes–the system''s way of informing
    clients about the status of their requests–and HTTP headers.Since APIs evolve
    and managing these changes without disrupting existing clients is a significant
    challenge, we look at different strategies for API versioning and the trade-offs
    involved with each.Then we learn about the Data-Transfer Object (DTO) pattern.
    Packaging data into DTOs can provide many benefits, from reducing the number of
    calls to better encapsulation and improved performance when sending data over
    the network.Finally, we also explore the importance of defining clear and robust
    API contracts, which ensures API stability. We discuss techniques for designing
    and documenting these contracts, ensuring they serve as practical guides for API
    consumers.By the end of this chapter, you''ll know how REST APIs work and will
    be ready to start building some using ASP.NET Core as we move further into our
    architectural journey in the next few chapters.In this chapter, we cover the following
    topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了网络应用程序通信的核心——REST API。在当今互联的数字世界中，不同应用程序之间的有效通信至关重要，RESTful API 在促进这种交互中发挥着关键作用。我们首先探索网络的基石：HTTP
    协议。我们简要介绍了核心 HTTP 方法，如 GET、POST、PUT 和 DELETE，以了解它们如何在 RESTful 环境中执行 CRUD（创建、读取、更新、删除）操作。然后，我们将注意力转向
    HTTP 状态码——系统通知客户端其请求状态的方式，以及 HTTP 头部。由于 API 会发展，而管理这些变化而不影响现有客户端是一个重大挑战，因此我们探讨了不同的
    API 版本策略及其各自的权衡。然后，我们学习了数据传输对象（DTO）模式。将数据打包到 DTO 中可以提供许多好处，从减少调用次数到更好的封装和在网络发送数据时的性能提升。最后，我们还探讨了定义清晰且健壮的
    API 合同的重要性，这确保了 API 的稳定性。我们讨论了设计和记录这些合同的技术，确保它们作为 API 消费者的实用指南。到本章结束时，您将了解 REST
    API 的工作原理，并准备好开始使用 ASP.NET Core 构建一些，随着我们进入下一章的架构之旅，我们将继续前进。在本章中，我们涵盖了以下主题：
- en: REST & HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST & HTTP
- en: Data Transfer Object (DTO)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输对象 (DTO)
- en: API contracts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 合同
- en: Let’s begin with REST.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 REST 开始。
- en: REST & HTTP
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST & HTTP
- en: '**REST**, or **Representational State Transfer**, is a way to create internet-based
    services, known as web services, web APIs, REST APIs, or RESTful APIs. Those services
    commonly use HTTP as their transport protocol. REST reuses well-known HTTP specifications
    instead of recreating new ways of exchanging data. For example, returning an HTTP
    status code `200 OK` indicates success, while `400 Bad Request` indicates failure.Here
    are some defining characteristics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**，或**表示性状态转移**，是一种创建基于互联网的服务的方法，称为网络服务、网络 API、REST API 或 RESTful API。这些服务通常使用
    HTTP 作为其传输协议。REST 重新使用已知的 HTTP 规范，而不是重新创建交换数据的新方法。例如，返回 HTTP 状态码 `200 OK` 表示成功，而
    `400 Bad Request` 表示失败。以下是一些定义特征：'
- en: '**Statelessness:** In a RESTful system, every client-to-server request should
    contain all the details necessary for the server to comprehend and execute it.
    The server retains no information about the client''s most recent HTTP request.
    This enhances both reliability and scalability.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性：** 在 RESTful 系统中，每个客户端到服务器的请求都应该包含服务器理解并执行它所需的所有细节。服务器不保留关于客户端最近 HTTP
    请求的任何信息。这提高了可靠性和可伸缩性。'
- en: '**Caching capabilities:** Clients should be able to cache responses to enhance
    performance.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存功能：** 客户端应该能够缓存响应以提高性能。'
- en: '**Simplicity and lose coupling:** REST uses HTTP to ensure a simplified, decoupled
    architecture. This makes the development, maintenance, and scaling of REST APIs
    easier and facilitates their usage.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性和解耦**：REST 使用 HTTP 确保简化和解耦的架构。这使得 REST API 的开发、维护和扩展变得更容易，并促进了它们的用法。'
- en: '**Resource identifiability:** Each REST API endpoint is a distinct resource,
    enabling us to secure each piece of the system separately.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源可识别性**：每个 REST API 端点是独特的资源，使我们能够分别保护系统的每一部分。'
- en: '**Interface as a contract:** The REST API layer serves as an exchange contract
    or an abstraction. It effectively conceals the backend system''s underlying implementation,
    fostering streamlined interactions.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口作为契约**：REST API 层作为交换契约或抽象。它有效地隐藏了后端系统的底层实现，促进了简化的交互。'
- en: While we could delve much deeper into the intricacies of REST APIs, the preceding
    characteristics serve as foundational knowledge, providing good enough knowledge
    to get started with RESTful services. Having navigated through these essentials,
    let's shift our focus toward understanding how REST APIs harness the power of
    HTTP.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以深入探讨 REST API 的复杂性，但前面的特性作为基础知识，提供了足够的知识以开始使用 RESTful 服务。在掌握了这些基本知识后，让我们将重点转向理解
    REST API 如何利用 HTTP 的力量。
- en: HTTP methods
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: 'HTTP methods, also known as verbs, define the type of action a client can perform
    on a resource in a RESTful API. Each method represents a specific operation that
    defines the endpoint''s intent on a resource. Here is a list of the most frequently
    used methods, what they are for, and their expected success status code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 方法，也称为动词，定义了客户端在 RESTful API 中可以对资源执行的操作类型。每种方法代表一个特定的操作，定义了端点对资源的意图。以下是常用方法的列表、它们的作用以及预期的成功状态码：
- en: '| **Method** | **Typical role** | **Success status code** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **典型角色** | **成功状态码** |'
- en: '| `GET` | Retrieve a resource (read data). | 200 OK |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取资源（读取数据） | 200 OK |'
- en: '| `POST` | Create a new resource. | 201 CREATED |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建新资源 | 201 CREATED |'
- en: '| `PUT` | Replace a resource. | 200 OK or 204 No Content |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 替换资源 | 200 OK 或 204 No Content |'
- en: '| `DELETE` | Delete a resource. | 200 OK or 204 No Content |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源 | 200 OK 或 204 No Content |'
- en: '| `PATCH` | Partially update a resource. | 200 OK |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 部分更新资源 | 200 OK |'
- en: Next, we explore the commonly used status codes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨常用的状态码。
- en: HTTP Status code
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: 'HTTP status codes are part of the HTTP response and provide the client with
    information about the success or failure of their request; the status of the request.Status
    codes touching similar subjects are grouped under the same broad “hundredth” categories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码是 HTTP 响的一部分，并向客户端提供有关其请求成功或失败的信息；涉及类似主题的状态码被分组在相同的广泛“百位”类别下：
- en: '`1XX` (informational) codes indicate that the request was received and the
    process is continuing, such as **100 Continue** and **101 Switching Protocols**.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1XX` (信息性) 状态码表示请求已接收且处理正在进行中，例如 **100 Continue** 和 **101 Switching Protocols**。'
- en: '`2XX` (successful) codes indicate that the request was received successfully.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2XX` (成功) 状态码表示请求已成功接收。'
- en: '`3XX` (redirection) codes indicate that the client must take further action
    to complete the redirection request.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3XX` (重定向) 状态码表示客户端必须采取进一步操作以完成重定向请求。'
- en: '`4XX` (client error) codes indicate an error on the client''s part, such as
    validation errors. The client sent an empty required field, for example.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4XX` (客户端错误) 状态码表示客户端方面的错误，例如验证错误。例如，客户端发送了一个空白的必填字段。'
- en: '`5XX` (server error) codes indicate that the server failed to fulfill an apparently
    valid request and that the client cannot do anything about it (retrying the request
    is not an option).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5XX` (服务器错误) 状态码表示服务器未能满足显然有效的请求，并且客户端无法对此做出任何反应（重试请求不是选项）。'
- en: 'The following table explains some of the most common ones:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下表解释了一些最常见的状态码：
- en: '| **Status code** | **Role** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **角色** |'
- en: '| **200 OK** | Indicates the request has succeeded. It usually includes data
    related to the resource in the response body. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **200 OK** | 表示请求已成功。它通常包括与资源相关的数据，位于响应体中。 |'
- en: '| **201 CREATED** | Indicates the has succeeded and the system created a resource.
    It should also include a `Location` HTTP header pointing to the newly created
    resource and can include the new entity in the response body. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **201 CREATED** | 表示请求已成功，系统已创建资源。它还应包括一个指向新创建资源的 `Location` HTTP 标头，并且可以在响应体中包含新实体。
    |'
- en: '| **202 ACCEPTED** | Indicates the request has been accepted for processing
    but is not processed yet. We use this code for asynchronous operations.In an event-driven
    system (see *Chapter 17*, *Introduction to Microservices Architecture*), this
    could mean that an event has been published, the current resource has completed
    its job (published the event), but to know more, the client needs to contact another
    resource, wait for a notification, just wait, or can’t know. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **202 ACCEPTED** | 表示请求已被接受进行处理，但尚未处理。我们使用此代码进行异步操作。在一个事件驱动系统中（见第17章，*微服务架构简介*），这可能意味着已发布事件，当前资源已完成其工作（发布了事件），但为了了解更多信息，客户端需要联系另一个资源，等待通知，只是等待，或者无法知道。|'
- en: '| **204 NO CONTENT** | Indicates the request has succeeded with no content
    in the response body. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **204 NO CONTENT** | 表示请求已成功，但响应体中没有内容。|'
- en: '| **302 FOUND** | Indicates that the requested resource resides temporarily
    under a different URL specified in the `Location` header. We commonly use this
    status code for redirection. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **302 FOUND** | 表示请求的资源临时位于`Location`头中指定的不同URL下。我们通常使用此状态码进行重定向。|'
- en: '| **400 BAD REQUEST** | Indicates that the server could not understand or process
    the request. This usually relates to a validation error like a bad input or a
    missing field. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **400 BAD REQUEST** | 表示服务器无法理解或处理请求。这通常与验证错误有关，如输入错误或缺少字段。|'
- en: '| **401 UNAUTHORIZED** | Indicates that the request requires user authentication
    to access the resource. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **401 UNAUTHORIZED** | 表示请求需要用户身份验证才能访问资源。|'
- en: '| **403 FORBIDDEN** | Indicates that the server understood the request but
    refused to authorize it. This usually means the client lacks the access rights
    for the resource (authorization). |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **403 FORBIDDEN** | 表示服务器理解了请求，但拒绝授权它。这通常意味着客户端缺乏对资源的访问权限（授权）。|'
- en: '| **404 NOT FOUND** | Indicates the resource does not exist or was not found.
    REST APIs often return this from valid endpoints. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **404 NOT FOUND** | 表示资源不存在或未找到。REST API通常从有效端点返回此状态码。|'
- en: '| **409 CONFLICT** | Indicates that the server cannot complete the request
    due to a conflict with the current state of the resource. A typical scenario would
    be that the entity has changed between its read operation ( `GET` ) and the current
    update ( `PUT` ) operation. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **409 CONFLICT** | 表示由于与资源的当前状态冲突，服务器无法完成请求。一个典型场景是实体在其读取操作（`GET`）和当前更新操作（`PUT`）之间已更改。|'
- en: '| **500 INTERNAL SERVER ERROR** | Indicates that an unhandled error occurred
    on the server side and prevented it from fulfilling the request. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **500 INTERNAL SERVER ERROR** | 表示服务器端发生未处理的错误，阻止其满足请求。|'
- en: Now that we covered the HTTP methods and status codes, we look at how to pass
    more metadata between the client and the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了HTTP方法和状态码，我们来看看如何在不同客户端和服务器之间传递更多的元数据。
- en: HTTP headers
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP头
- en: 'REST APIs leverage HTTP headers to transmit clients’ information and describe
    their options and capabilities. Headers are part of both the request and the response.One
    well-known header is the `Location` header, that we use for different purposes.
    For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: REST API利用HTTP头传输客户端信息并描述其选项和功能。头是请求和响应的一部分。一个著名的头是`Location`头，我们用它用于不同的目的。例如：
- en: After creating an entity (`201 Created`), the `Location` header should point
    to the `GET` endpoint where the client can access that new entity.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建实体（`201 Created`）后，`Location`头应指向客户端可以访问该新实体的`GET`端点。
- en: After starting an asynchronous operation (`202 Accepted`), the `Location` header
    could point to the status endpoint where you can poll for the state of the operation
    (has it completed, failed, or is it still ongoing).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动异步操作（`202 Accepted`）后，`Location`头可能指向状态端点，您可以在其中轮询操作的状态（是否已完成、失败或仍在进行中）。
- en: 'When a server wants to instruct a client to load another page (a redirection),
    the `Location` header contains the destination URL. The following status codes
    are the most common for redirections: `301 Moved Permanently`, `302 Found`, `303
    See Other`, `307 Temporary Redirect`, and `308 Permanent Redirect`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器想要指示客户端加载另一个页面（重定向）时，`Location`头包含目标URL。以下状态码是重定向中最常见的：`301 Moved Permanently`、`302
    Found`、`303 See Other`、`307 Temporary Redirect`和`308 Permanent Redirect`。
- en: 'The `Retry-After` header can also come in handy when mixed with `202` `Accepted`,
    `301 Moved Permanently`, `429 Too Many Requests`, or `503 Service Unavailable`.
    The `ETag` header identifies the version of the entity and can be used in conjunction
    with `If-Match` to avoid *mid-air collisions*. The `ETag` and `If-Match` headers
    form a sort of *optimistic concurrency* method that prevents *request two* from
    overwriting changes made by *request one* when changes are happening simultaneously
    or not in the expected order; a.k.a. a way to manage conflicts. We can also add
    the following to the mix as an example of HTTP headers that describe a REST endpoint:
    `Allow`, `Authorization`, and `Cache-Control`. The list is very long, and it would
    help no one to enumerate all HTTP headers here.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retry-After` 头部在与 `202` `Accepted`、`301 Moved Permanently`、`429 Too Many Requests`
    或 `503 Service Unavailable` 混合使用时也很有用。`ETag` 头部标识实体的版本，可以与 `If-Match` 一起使用以避免*空中碰撞*。`ETag`
    和 `If-Match` 头部形成一种*乐观并发*方法，防止*请求二*在同时发生或不是按预期顺序发生时覆盖*请求一*所做的更改；即管理冲突的一种方式。我们可以添加以下内容作为描述
    REST 端点的 HTTP 头部的示例：`Allow`、`Authorization` 和 `Cache-Control`。列表非常长，在这里列举所有 HTTP
    头部对任何人都没有帮助。'
- en: This information should be enough theory to get you started with HTTP and REST.
    In case you want to know more, I left links to the MDN web docs about HTTP in
    the Further Reading section at the end of the chapter.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该足够作为理论来让你开始学习 HTTP 和 REST。如果你还想了解更多，我在章节末尾的“进一步阅读”部分留下了关于 HTTP 的 MDN 网络文档的链接。
- en: Next, we look at versioning because nothing stays the same forever; business
    needs change, and APIs must evolve with them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看版本控制，因为没有什么是一成不变的；业务需求会变化，API 必须随之发展。
- en: Versioning
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制
- en: Versioning is a crucial aspect of a REST API. Whether the version of the API
    is long-lived or transitory (during the decommissioning cycle of an old endpoint,
    for example), both ends of the pipe must know what to expect; what API contract
    to respect. Unless you are your only consumer, you’ll need a way for the API clients
    to query specific API versions when the contract changes.This section explores
    a few ways to think about our versioning strategy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是 REST API 的一个关键方面。无论 API 的版本是长期存在还是临时（例如，在旧端点退役周期中），管道的两端都必须知道期望什么；要遵守的
    API 合同。除非你是唯一的消费者，否则你需要一种方法让 API 客户端在合同更改时查询特定的 API 版本。本节探讨了关于我们的版本控制策略的一些思考方式。
- en: Default versioning strategy
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认版本策略
- en: The default strategy is the first thing to consider when versioning an API.
    What happens when no version is specified? Will the endpoint return an error,
    the first or the latest version?If the API returns an error, you should implement
    that versioning strategy from day one so clients know a version is required. In
    this case, there is no real drawback. On the other hand, putting this strategy
    in place after the fact will break all clients that do not specify a version number,
    which might not be the best way to keep your consumers happy.The second way is
    always to return the first version. This method is an excellent way to preserve
    backward compatibility. You can add more endpoint versions without breaking your
    consumers.The opposite way is always to return the latest version. For consumers,
    this means specifying a version to consume or be up to date or break, and this
    might not be the best user experience to provide to your consumers. Nonetheless,
    many have opted for this default strategy.Another way to go is to pick any version
    as the default baseline for the API (like version 3.2, for example) or even choose
    a different version per endpoint. Say you default to 3.2, then deploy 4.0\. Since
    the clients must opt-in to access the new API, they won’t break automatically
    and will have the time to update from 3.2 to 4.0 following their own roadmap.
    This is a good strategy to default to a well-known and stable API version before
    moving forward with breaking changes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当对API进行版本化时，首先要考虑的是默认策略。如果没有指定版本会发生什么？端点会返回错误、第一个版本还是最新版本？如果API返回错误，你应该从一开始就实施这种版本化策略，这样客户端就知道需要版本。在这种情况下，实际上没有真正的缺点。另一方面，在事后实施这种策略将破坏所有未指定版本号的客户端，这可能不是让消费者满意的最佳方式。另一方面，总是返回第一个版本是一种很好的方法，可以保持向后兼容性。你可以添加更多端点版本，而不会破坏你的消费者。相反的方式是总是返回最新版本。对于消费者来说，这意味着指定要消费的版本或保持最新或中断，这可能不是提供给消费者的最佳用户体验。尽管如此，许多人选择了这种默认策略。另一种选择是选择任何版本作为API的默认基线（例如版本3.2）或甚至为每个端点选择不同的版本。比如说，你默认为3.2，然后部署4.0。由于客户端必须选择加入以访问新API，它们不会自动中断，并且将有时间根据他们自己的路线图从3.2更新到4.0。这是在向前推进破坏性更改之前将已知和稳定的API版本作为默认策略的好方法。
- en: No matter what you choose, always think it through by weighing the pros and
    cons.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你选择什么，都要权衡利弊，仔细思考。
- en: Next, we explore ways to define those versions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨定义这些版本的方法。
- en: Versioning strategy
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 版本化策略
- en: 'Of course, there are multiple ways to think this through. You can leverage
    URL patterns to define and include the API version, like `https://localhost/v2/some-entities`.
    This strategy is easier to query from a browser, making it simple to know the
    version at a glance, but the endpoint is not pointing to a unique resource anymore
    (a key principle of REST), as each resource has one endpoint for each version.
    Nonetheless, this way of versioning an API is used extensively and is one of the
    most popular, if not *the* most popular way of doing REST versioning, even if
    it violates one of its core principles (debatably).The other way is to use HTTP
    headers. You can use a custom header like `api-version` or `Accept-version`, for
    example, or the standard `Accept` header. This way allows resources to have unique
    endpoints (URI) while enabling multiple versions of each entity (multiple versions
    of each API contract describing the same entity).For example, a client could specify
    an HTTP header while calling the endpoint like this (custom header):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有多个方法来思考这个问题。你可以利用URL模式来定义和包含API版本，例如`https://localhost/v2/some-entities`。这种策略更容易从浏览器中查询，使得一眼就能知道版本，但端点不再指向唯一的资源（REST的一个关键原则），因为每个资源都有一个端点对应每个版本。尽管如此，这种版本化API的方式被广泛使用，并且是最受欢迎的方法之一，如果不是*最*受欢迎的方法，即使它违反了其核心原则（有争议）。另一种方式是使用HTTP头。你可以使用自定义头，如`api-version`或`Accept-version`，例如，或者标准的`Accept`头。这种方式允许资源有唯一的端点（URI），同时使每个实体有多个版本（描述相同实体的每个API合约的多个版本）。例如，客户端可以在调用端点时指定HTTP头，如下所示（自定义头）：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or like the following, by leveraging the `Accept` header for *content negotiation*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像下面这样，通过利用`Accept`头进行*内容协商*：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Different people are using different values for the `Accept` headers, for example:'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不同的人在使用`Accept`头时使用不同的值，例如：
- en: '`application/vnd.myapplication.v2+json`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/vnd.myapplication.v2+json`'
- en: '`application/vnd.myapplication.entity.v2+json`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/vnd.myapplication.entity.v2+json`'
- en: '`application/vnd.myapplication.api+json; version=2`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/vnd.myapplication.api+json; version=2`'
- en: '`application/json; version=2`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json; version=2`'
- en: 'Whether you are using one way or another, you’ll most likely need to version
    your APIs at some point. Some people are strong advocates of one way or the other,
    but ultimately, you should decide on a case-by-case basis what best covers your
    needs and capacities: simplicity, formality, or a mix of both.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种方式，你很可能会在某些时候需要对API进行版本控制。有些人强烈支持一种方式或另一种方式，但最终，你应该根据具体情况决定哪种方式最适合你的需求和能力：简单性、正式性或两者的结合。
- en: Wrapping up
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: With a method (verb), the client (and the endpoint) can express the intent to
    create, update, read, or delete an entity. With a status code, the endpoint can
    tell the client the state of the operation. Adding HTTP headers, clients, and
    servers can add more metadata to the request or response. Finally, by adding versioning,
    the REST API can evolve without breaking existing clients while giving them options
    to consume specific versions.With what we just covered, you should have more than
    what’s needed to follow along with the examples in this book and build a few REST
    APIs along the way. Next, we explore how those HTTP pieces create API contracts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个方法（动词），客户端（和端点）可以表达创建、更新、读取或删除实体的意图。通过状态码，端点可以告诉客户端操作的状态。通过添加HTTP头，客户端和服务器可以向请求或响应添加更多元数据。最后，通过添加版本控制，REST
    API可以在不破坏现有客户端的同时，给他们提供消费特定版本的选择。根据我们刚才所讨论的，你应该有足够的知识来跟随本书中的示例，并在构建REST API的过程中构建一些API。
- en: Data Transfer Object (DTO)
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据传输对象（DTO）
- en: The Data Transfer Object (DTO) design pattern is a robust approach to managing
    and transferring data in a service-oriented architecture like REST APIs. The DTO
    pattern is about organizing the data to deliver it to API clients optimally. DTOs
    are an integral part of the API contract, that we explore next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输对象（DTO）设计模式是一种在类似REST API这样的面向服务的架构中管理和传输数据的稳健方法。DTO模式是关于组织数据以最优地将其传递给API客户端。DTO是API合同的一个组成部分，我们将在下一部分进行探讨。
- en: Goal
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: A DTO's objective is to *control an endpoint's inputs and outputs* by loosely
    coupling the exposed API surface from the application’s inner workings. DTOs empower
    us to craft our web services the way we want the consumers to interact with them.
    So, no matter the underlying system, we can use DTOs to design endpoints that
    are easier to consume, maintain, and evolve.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: DTO的目标是通过松散耦合暴露的API表面与应用程序的内部工作方式来*控制端点的输入和输出*。DTO赋予我们以我们希望消费者与之交互的方式构建我们的网络服务。因此，无论底层系统如何，我们都可以使用DTO来设计更容易消费、维护和演化的端点。
- en: Design
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'Each DTO represents an entity with all the necessary properties. That entity
    is either an input or an output and allows crafting the interaction between the
    clients and the API.DTOs serve to loosely couple our domain from the data exposed
    over the API by adding a level of abstraction. This allows us to change the underlying
    domain model without affecting the data exposed to the API consumers and vice
    versa.Another way to use a DTO is by packaging related pieces of information together,
    allowing a client to make a single call to fetch all necessary data, thereby eliminating
    the need for multiple requests.Based on REST and HTTP, the flow of a request goes
    like the following: an HTTP request comes in, some code is executed (domain logic),
    and an HTTP response goes back to the client. The following diagram represents
    this flow:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个DTO代表一个具有所有必要属性的实体。该实体可以是输入或输出，并允许构建客户端和API之间的交互。DTO通过增加一个抽象层，将我们的领域与通过API暴露的数据松散耦合。这允许我们在不影响API消费者暴露的数据的情况下更改底层领域模型，反之亦然。另一种使用DTO的方法是将相关的信息片段打包在一起，允许客户端通过单个调用获取所有必要的数据，从而消除多次请求的需要。基于REST和HTTP，请求的流程如下：一个HTTP请求进来，执行一些代码（领域逻辑），然后一个HTTP响应返回给客户端。以下图表表示了这个流程：
- en: '![Figure 4.1: An HTTP request getting in and out of a REST API endpoint.](img/file20.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：一个HTTP请求进入并离开REST API端点。](img/file20.png)'
- en: 'Figure 4.1: An HTTP request getting in and out of a REST API endpoint.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：一个HTTP请求进入并离开REST API端点。
- en: 'Now, if we take that flow and change HTTP with DTO, we can see that a DTO can
    be part of the data contract as an input or an output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用DTO替换那个流程中的HTTP，我们可以看到DTO可以作为数据合同的一部分，作为输入或输出：
- en: '![Figure 4.2: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO](img/file21.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：一个输入DTO触发了某些领域逻辑，然后端点返回一个输出DTO](img/file21.png)'
- en: 'Figure 4.2: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：一个输入 DTO 撞击某些领域逻辑，然后端点返回一个输出 DTO
- en: 'How can the HTTP request become an object? Most of the time:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将 HTTP 请求变成一个对象？大多数时候：
- en: We use deserialization or data binding for inputs.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对输入使用反序列化或数据绑定。
- en: We use serialization for outputs.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对输出使用序列化。
- en: Let’s look at a few examples.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子。
- en: Conceptual examples
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概念示例
- en: Conceptually, say that we are building a web application allowing people to
    register for events. We explore two use cases next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上讲，假设我们正在构建一个允许人们注册活动的网络应用程序。我们接下来探索两个用例。
- en: Registering for an activity
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 活动注册
- en: 'The first scenario we are exploring is a user registering for an activity.
    An activity is a sort of event in the system. We use an external payment gateway,
    so our application never handles financial data. Nevertheless, we must send transaction
    data to our backend to associate and complete the payment. The following diagram
    depicts the workflow:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在探索的第一个场景是用户注册活动。活动是系统中的某种事件。我们使用外部支付网关，因此我们的应用程序永远不会处理财务数据。尽管如此，我们必须将交易数据发送到我们的后端以关联和完成支付。以下图表示例描述了工作流程：
- en: '![Figure 4.3: The DTOs implicated in an activity registration flow.](img/file22.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：活动注册流程中涉及的 DTO。](img/file22.png)'
- en: 'Figure 4.3: The DTOs implicated in an activity registration flow.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：活动注册流程中涉及的 DTO。
- en: 'The body of the request could look like the following JSON snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体可能看起来如下 JSON 片段：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, the following JSON snippet could represent the body of the response:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下 JSON 片段可能代表响应体：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, this is a very lightweight version of a registration system. The
    objective is to show that:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个非常轻量级的注册系统版本。目标是展示：
- en: Three entities came in as an HTTP POST request (a registrant, an activity, and
    payment information).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个实体作为 HTTP POST 请求进入（注册者、活动和支付信息）。
- en: The system executed some business logic to register the person to the activity
    and to complete the financial transaction.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统执行了一些业务逻辑，将人员注册到活动中，并完成财务交易。
- en: The API returned mixed information to the client.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 向客户端返回了混合信息。
- en: This pattern is handy to input and output only what you need. If you are designing
    the user interface that consumes the API, outputting a well-thought DTO can ensure
    that the UI renders the next screen just by reading the response from the server,
    saving your UI to fetch more data, speeding up the process, and improving the
    user experience.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种模式便于只输入和输出所需的内容。如果您正在设计消费 API 的用户界面，输出一个经过深思熟虑的 DTO 可以确保 UI 只需读取来自服务器的响应即可渲染下一屏幕，从而节省
    UI 获取更多数据，加快处理速度，并提高用户体验。
- en: We explore fetching information about an activity registration next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来探索获取活动注册信息。
- en: Fetching activity registration details
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取活动注册详情
- en: 'In the same system, the user wants to review the details of an activity he
    registered using the preceding process. In this case, the flow goes like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一系统中，用户想要使用前面的过程查看他注册的活动详情。在这种情况下，流程如下：
- en: The client sends the registration identifier over a `GET` request.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户通过 `GET` 请求发送注册标识符。
- en: The system fetches the registrant information, the activity information, and
    the number of seats the user reserved for that activity.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统获取注册者信息、活动信息和用户为该活动预留的座位数。
- en: The server returns the data to the client.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将数据返回给客户端。
- en: 'The following diagram visually represents the use case:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示直观地表示了用例：
- en: '![Figure 4.4: The DTOs implicated in fetching the info related to a registered
    activity.](img/file23.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：获取已注册活动相关信息的 DTO。](img/file23.png)'
- en: 'Figure 4.4: The DTOs implicated in fetching the info related to a registered
    activity.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：获取已注册活动相关信息的 DTO。
- en: 'In this case, the input would be part of the URL, like `/registrations/123`.
    The output would be part of the response body, and could look like the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入将是 URL 的一部分，例如 `/registrations/123`。输出将是响应体的一部分，可能看起来如下：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By creating that endpoint using a well-crafted output DTO, we condensed three
    HTTP requests into one: the registrant, the activity, and the registration (number
    of seats). This powerful technique applies to any technology, not just ASP.NET
    Core, and allows us to design APIs without connecting clients directly to our
    data (loose coupling).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用精心设计的输出DTO创建该端点，我们将三个HTTP请求压缩成了一个：注册者、活动和注册（座位数）。这种强大的技术适用于任何技术，而不仅仅是ASP.NET
    Core，并允许我们设计API，而不需要直接将客户端连接到我们的数据（松散耦合）。
- en: Conclusion
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: A data transfer object (DTO) allows us to design an API endpoint with specialized
    input and output instead of exposing the domain or data model. Those DTOs shield
    our internal business logic, which improves our ability to design our APIs and
    also helps us make them more secure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输对象（DTO）允许我们设计一个具有专用输入和输出的API端点，而不是暴露领域或数据模型。这些DTO保护我们的内部业务逻辑，这提高了我们设计API的能力，并有助于使它们更加安全。
- en: By defining DTOs, we can avoid a malicious actor trying to bind data that he
    should not have access to. For example, when using an input “Login DTO” that only
    contains a `username` and `password` properties, a malicious user could not try
    to bind the `IsAdmin` field available in our domain and database. There are other
    ways to mitigate this, but they are out of the scope of this chapter, yet, a DTO
    is a great candidate to mitigate this attack vector.
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过定义DTO，我们可以避免恶意行为者尝试绑定他不应访问的数据。例如，当使用仅包含`username`和`password`属性的输入“登录DTO”时，恶意用户无法尝试绑定我们领域和数据库中可用的`IsAdmin`字段。还有其他方法可以减轻这种攻击，但它们超出了本章的范围。然而，DTO是减轻这种攻击向量的绝佳候选者。
- en: 'This separation between the presentation and the domain is a crucial element
    that leads to having multiple independent components instead of a bigger, more
    fragile one or leaking the internal data structure to the clients consuming the
    API.We explore building APIs in the next few chapters and explore some topics
    more in-depth in *Section 4*, *Designing at Application Scale*.Using the DTO pattern
    helps us follow the SOLID principles in the following ways:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 展示层与领域之间的这种分离是一个关键元素，它导致我们拥有多个独立的组件，而不是一个更大、更脆弱的组件，或者将内部数据结构泄露给使用API的客户端。我们在接下来的几章中探讨构建API，并在*第4节，设计应用规模*中更深入地探讨一些主题。使用DTO模式可以帮助我们以下列方式遵循SOLID原则：
- en: '**S**: A DTO adds clear boundaries between the domain logic or the data and
    the API contract, dividing one model into several distinct responsibilities to
    help keep things isolated.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: DTO（数据传输对象）在领域逻辑或数据与API契约之间建立了清晰的边界，将一个模型划分为几个不同的职责，以帮助保持事物的隔离。'
- en: '**O**: N/A'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: N/A'
- en: '**L**: N/A'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: N/A'
- en: '**I**: A DTO is a smaller, specifically crafted model that serves a clear purpose.
    With a DTO, we now have two models (domain and API contract) and several classes
    (input DTO, output DTO, and domain or data entities) instead of a generic one
    (only the domain or data entity).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: DTO是一个更小、专门定制的模型，它服务于一个明确的目的。有了DTO，我们现在有两个模型（领域和API契约）和几个类（输入DTO、输出DTO和领域或数据实体），而不是一个通用的模型（只有领域或数据实体）。'
- en: '**D**: N/A'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: N/A'
- en: Next, we look at how we can glue the pieces that we explored so far into API
    contracts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何将我们迄今为止探索的各个部分粘合到API契约中。
- en: API contracts
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API契约
- en: 'API Contracts serve as an essential blueprint, outlining the rules of engagement
    between your API and its consumers. This includes available endpoints, HTTP methods
    they support, expected request formats, and potential response structures, including
    HTTP status codes.These contracts provide clarity, robustness, consistency, and
    interoperability, facilitating seamless system interactions, no matter the language
    they are built with. Moreover, well-documented API contracts are a reliable reference
    guide, helping developers understand and utilize your API effectively. Thus, designing
    comprehensive and clear API contracts is critical in building high-quality, maintainable,
    and user-friendly APIs.An API contract describes a REST API, so a consumer should
    know how to call an endpoint and what to expect from it in return. What an endpoint
    does or the capability it provides should be clear just by reading its contract.Each
    endpoint in a REST API should provide at least the following signature:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: API合约作为一项基本蓝图，概述了您的API与其消费者之间的互动规则。这包括可用的端点、它们支持的HTTP方法、预期的请求格式以及可能的响应结构，包括HTTP状态码。这些合约提供了清晰性、健壮性、一致性和互操作性，促进了无论使用何种语言构建的系统之间的无缝交互。此外，良好的API合约文档是一个可靠的参考指南，帮助开发者有效地理解和利用您的API。因此，设计全面且清晰的API合约对于构建高质量、可维护和用户友好的API至关重要。API合约描述了一个REST
    API，因此消费者应该知道如何调用端点以及可以期待得到什么回报。端点所做的事情或它提供的功能仅通过阅读其合约就可以明确。REST API中的每个端点至少应提供以下签名：
- en: A Uniform Resource Identifier (URI) that indicates where to access it.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个统一资源标识符（URI），指示如何访问它。
- en: An HTTP method that describes the type of operation it does.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述它执行操作类型的HTTP方法。
- en: An input that defines what is needed for the operation to happen. For example,
    the input can be the HTTP body, URL parameters, query parameters, HTTP headers,
    or even a combination.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入定义，说明操作发生所需的条件。例如，输入可以是HTTP体、URL参数、查询参数、HTTP头，甚至它们的组合。
- en: An output that defines what the client should expect. A client should expect
    multiple output definitions since an endpoint will not return the same information
    if the request succeeds or fails.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出定义，说明客户端应该期待什么。客户端应该期待多个输出定义，因为端点在请求成功或失败时不会返回相同的信息。
- en: The input and output of an endpoint are often DTOs, making DTOs even more important.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 端点的输入和输出通常是DTO（数据传输对象），这使得DTO变得更加重要。
- en: 'There are multiple ways to define API contracts. For example, to define an
    API contract, we could do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 定义API合约有多种方式。例如，为了定义一个API合约，我们可以做以下事情：
- en: Open any text editor, such as MS Word or Notepad, and start writing a document
    describing our web APIs; this is probably the most tedious and least flexible
    way. I do not recommend this for many reasons.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开任何文本编辑器，例如MS Word或记事本，开始编写描述我们的Web API的文档；这可能是最繁琐且最不灵活的方法。我不推荐这种方法，有多个原因。
- en: Writing specifications in Markdown files and saving those files within your
    project Git repository for easy discoverability. Very similar to MS Word, but
    more accessible for all team members to consume. This approach is better than
    Word, yet not optimal since you need to manually update those files when the API
    changes.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Markdown文件中编写规范并将其保存到您的项目Git仓库中以便易于发现。这与MS Word非常相似，但更易于所有团队成员消费。这种方法比Word更好，但还不是最佳选择，因为当API发生变化时，您需要手动更新这些文件。
- en: Use an existing standard, such as the OpenAPI specification (formerly Swagger).
    This technique implies a learning curve, but the result should be easier to consume.
    Moreover, many tools allow us to create automation using the OpenAPI specs. This
    approach is starting to remove the need for manual intervention.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有的标准，例如OpenAPI规范（以前称为Swagger）。这种技术意味着有一个学习曲线，但结果应该更容易消费。此外，许多工具允许我们使用OpenAPI规范创建自动化。这种方法开始消除手动干预的需求。
- en: Use a code-first approach and ASP.NET Core tooling to extract the OpenAPI specs
    from your code.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以代码优先的方法和ASP.NET Core工具从您的代码中提取OpenAPI规范。
- en: Use any other tools that fit our requirements.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任何其他符合我们要求的工具。
- en: '**Tip**'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Postman is a fantastic tool for building web APIs documentation, test suites,
    and experimenting with your APIs. It supports OpenAPI specifications, allows you
    to create mock servers, supports environments, and more.
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Postman是一个构建Web API文档、测试套件以及实验API的绝佳工具。它支持OpenAPI规范，允许您创建模拟服务器，支持环境，等等。
- en: 'No matter the tools, there are two major trends in how to design the API contract
    of a REST API:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用什么工具，在如何设计REST API的API合约方面，有两个主要趋势：
- en: Design the contract first, then build the API (contract-first).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先设计合约，然后构建API（合约优先）。
- en: Build the API, then extract the contract for the code (code-first).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建API，然后从代码中提取合约（代码优先）。
- en: To design the contract-first, one must adopt a tool to write the specifications,
    then code the API according to the specs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计合约优先，必须采用一个工具来编写规范，然后根据规范编写API。
- en: I left a link in the *Further Reading* section below about Open API.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在下面的*进一步阅读*部分留下了一个关于Open API的链接。
- en: On the other hand, to use a code-first approach and automatically extract the
    OpenAPI specifications from the API, we must ensure our endpoints are discoverable
    by the .NET `ApiExplorer`.No matter how you do it, in ASP.NET Core, we use classes
    and struct to represent the data contract of our REST APIs; whether it happens
    before or after you write the API contract does not matter. Since I prefer to
    write C# to YAML or JSON, we explore how to leverage Swagger to generate a data
    contract in a code-first manner next.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了使用代码优先方法并自动从API中提取OpenAPI规范，我们必须确保我们的端点可以被.NET的`ApiExplorer`发现。无论您如何操作，在ASP.NET
    Core中，我们使用类和结构来表示我们的REST API的数据合约；无论是在编写API合约之前还是之后，这都不重要。由于我更喜欢将C#转换为YAML或JSON，我们接下来探讨如何利用Swagger以代码优先的方式生成数据合约。
- en: Code-first API Contract
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码优先API合约
- en: 'In this example, we have a tiny API with two endpoints:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个包含两个端点的微小API：
- en: Read the specified entity.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取指定的实体。
- en: Create a new entity.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的实体。
- en: The code doesn’t do much and returns fake data, but it is enough to explore
    its data contract.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码做得不多，只返回假数据，但足以探索其数据合约。
- en: Remember that code is like playing LEGO® blocks, but we connect many tiny patterns
    used together to create our software and create value. Understanding and learning
    that skill will lead you beyond just being able to use some canned magic recipe,
    which limits you to what people share with you.
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，代码就像玩乐高®积木，但我们通过连接许多一起使用的微小模式来创建我们的软件和创造价值。理解和学习这项技能将使你超越仅仅能够使用一些现成的魔法食谱，这限制了你对人们分享给你的内容的依赖。
- en: In this sample, we use the OpenAPI specification to describe our API. To save
    ourselves from writing JSON and go code-first instead, we leverage the SwagerGen
    package.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用OpenAPI规范来描述我们的API。为了节省我们编写JSON并采用代码优先的方式，我们利用SwaggerGen包。
- en: To use SwaggerGen, we must install the `Swashbuckle.AspNetCore.SwaggerGen` NuGet
    package.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要使用SwaggerGen，我们必须安装`Swashbuckle.AspNetCore.SwaggerGen` NuGet包。
- en: 'Here’s the `Program.cs` file, without the endpoints, showing how to leverage
    SwaggerGen:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Program.cs`文件，没有端点，展示了如何利用SwaggerGen：
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The highlighted lines are the only things we must do to use SwaggerGen in a
    project, which will generate the API contract in the OpenAPI specification for
    us. The JSON file is very long (113 lines), so I only pasted some snippets in
    the book for clarity. However, you can navigate to the `/swagger/v1/swagger.json`
    URL to access the complete JSON code or open the `swagger.json` file in the project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行是我们必须做的唯一事情，以便在项目中使用SwaggerGen，它将为我们生成OpenAPI规范中的API合约。JSON文件非常长（113行），所以我只在书中粘贴了一些片段以供清晰。然而，您可以导航到`/swagger/v1/swagger.json`
    URL以访问完整的JSON代码或打开项目中的`swagger.json`文件。
- en: I created the `swagger.json` file in the project for convenience. The tool does
    not generate a physical file.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在项目中创建了`swagger.json`文件以方便使用。工具不会生成物理文件。
- en: Let’s have a look at those endpoints.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那些端点。
- en: The first endpoint
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一个端点
- en: 'The code of the first endpoint that allows a client to read an entity looks
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 允许客户端读取实体的第一个端点的代码如下：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the API contract we can extract from the preceding code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们可以从前面的代码中提取的API合约：
- en: '| **Contract segment** | **Value** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **合约段** | **值** |'
- en: '| HTTP Method | GET |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | GET |'
- en: '| URI | `/{id}` (for example, `/123` ) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| URI | `/id`（例如，`/123`） |'
- en: '| Input | The `id` parameter |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | `id`参数 |'
- en: '| Output | An instance of the `ReadOneDto` class. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | `ReadOneDto`类的实例。 |'
- en: 'Sending the following HTTP request (you can use the `ReadOneEntity.http` file)
    results in the output that follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 发送以下HTTP请求（您可以使用`ReadOneEntity.http`文件）将产生以下输出：
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The trimmed-down response is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 简化后的响应是：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, when we query the API for the entity `id=123`, the endpoint returns
    that entity with a `200 OK` status code, and the response body is a serialized
    instance of the `ReadOneDto` class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当我们查询 API 以获取 `id=123` 的实体时，端点返回该实体，状态码为 `200 OK`，响应体是 `ReadOneDto` 类的序列化实例。
- en: The `.http` files are new to VS 2022 and allow us to write and execute HTTP
    requests from VS itself. I left a link in the *Further Reading* section if you
    want to know more.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`.http` 文件是 VS 2022 的新功能，允许我们从 VS 本身编写和执行 HTTP 请求。如果您想了解更多信息，我在 *进一步阅读* 部分留下了一个链接。'
- en: 'SwaggerGen generated the following OpenAPI specs for the first endpoint:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SwaggerGen 为第一个端点生成了以下 OpenAPI 规范：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That snippet describes the endpoint and references our output model (highlighted
    line). The schemas are at the bottom of the JSON file. Here’s the schema that
    represents the `ReadOneDto`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码描述了端点并引用了我们的输出模型（高亮行）。模式在 JSON 文件的底部。以下是表示 `ReadOneDto` 的模式：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see from the highlighted lines, that schema has a property `name`
    of type `string` and a property `id` of type `integer`, the same as our `ReadOneDto`
    class. Fortunately, we don’t need to write that JSON since the tool generates
    it based on our code. Next, we look at the second endpoint.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如高亮行所示，该模式有一个 `name` 属性，类型为 `string`，一个 `id` 属性，类型为 `integer`，与我们的 `ReadOneDto`
    类相同。幸运的是，我们不需要编写那个 JSON，因为工具根据我们的代码生成它。接下来，我们看看第二个端点。
- en: The second endpoint
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二个端点
- en: 'The code of the second endpoint that allows a client to create an entity looks
    like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个端点的代码允许客户端创建实体如下所示：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s the API contract we can extract from the preceding code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以从前面的代码中提取的 API 合同：
- en: '| **Contract segment** | **Value** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **合同段** | **值** |'
- en: '| HTTP Method | POST |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 方法 | POST |'
- en: '| URI | `/` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| URI | `/` |'
- en: '| Input | An instance of the `CreateDto` class. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | `CreateDto` 类的一个实例。 |'
- en: '| Output | An instance of the `CreatedDto` class. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | `CreatedDto` 类的一个实例。 |'
- en: 'Sending the following HTTP request (you can use the `CreateEntity.http` file)
    results in the output that follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发送以下 HTTP 请求（您可以使用 `CreateEntity.http` 文件）将产生以下输出：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The trimmed-down response is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 简化后的响应如下：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see from the preceding request, the client sent a serialized instance
    of the `CreateDto` class, set the name to Jane Doe, and received that same entity
    back but with a numeric `id` property (an instance of the `CreatedDto` class).The
    OpenAPI specs of our endpoint look like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的请求所示，客户端发送了 `CreateDto` 类的序列化实例，将名称设置为 Jane Doe，并收到了相同的实体，但具有数字 `id` 属性（`CreatedDto`
    类的一个实例）。我们的端点 OpenAPI 规范如下所示：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The input and output schemas are:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出模式如下：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar to the first endpoint, SwaggerGen translates our C# classes into OpenAPI
    specs. Let’s wrap this up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个端点类似，SwaggerGen 将我们的 C# 类转换为 OpenAPI 规范。让我们总结一下。
- en: Wrapping up
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'Some ASP.NET Core templates come with SwaggerGen preconfigured. It also comes
    with the Swagger UI that lets you visually explore the API contract from your
    application and even query it. NSwag is another tool that offers similar features.
    Plenty of online documentation shows how to take advantage of those tools.Besides
    exploring tooling, we defined that an API contract is fundamental and promotes
    robustness and reliability. Each endpoint has the following pieces as part of
    the overall API contract:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 ASP.NET Core 模板预配置了 SwaggerGen。它还包含 Swagger UI，允许您从您的应用程序中直观地探索 API 合同，甚至查询它。NSwag
    是另一个提供类似功能的工具。大量的在线文档展示了如何利用这些工具。除了探索工具之外，我们还定义了 API 合同是基本的，并促进了健壮性和可靠性。每个端点都有以下部分作为整体
    API 合同的一部分：
- en: The URI it is accessible from.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可访问的 URI。
- en: The HTTP method that best defines the operation.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳定义操作的 HTTP 方法。
- en: An input.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入。
- en: One or more outputs.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个输出。
- en: A single URI can lead to multiple endpoints by combining different HTTP methods
    and inputs. For example, `GET /api/entities` may return a list of entities, while
    `POST /api/entities` may create a new entity. Using the entity's name in its plural
    form is a convention used by many.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过组合不同的 HTTP 方法和输入，单个 URI 可以指向多个端点。例如，`GET /api/entities` 可能返回实体列表，而 `POST /api/entities`
    可能创建一个新的实体。使用实体的复数形式作为约定被许多人所采用。
- en: We explore data transfer objects next to add more clarity to that pattern.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来探讨数据传输对象，以增加对该模式的清晰度。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'REST APIs facilitate communication between applications in today''s interconnected
    digital world. We explored the HTTP protocol, HTTP methods, HTTP status codes,
    and HTTP headers. We then explored API versioning, the Data Transfer Objects (DTOs),
    and the importance of API contracts. Here are a few Key Takeaways:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: REST API促进了当今互联数字世界中应用程序之间的通信。我们探讨了HTTP协议、HTTP方法、HTTP状态码和HTTP头部信息。然后我们探讨了API版本控制、数据传输对象（DTOs）以及API合约的重要性。以下是一些关键要点：
- en: '**REST & HTTP**: REST APIs are integral to web application communication. They
    use HTTP as their transport protocol, leveraging its methods, status codes, and
    headers to facilitate interaction between different applications.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST与HTTP**：REST API是网络应用通信的核心。它们使用HTTP作为传输协议，利用其方法、状态码和头部信息来促进不同应用之间的交互。'
- en: '**HTTP Methods**: HTTP methods or verbs (GET, POST, PUT, DELETE, PATCH) define
    the type of action a client can perform on a resource in a RESTful API. Understanding
    these methods is crucial for carrying out CRUD operations.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP方法**：HTTP方法或动词（GET、POST、PUT、DELETE、PATCH）定义了客户端在RESTful API中对资源可以执行的操作类型。理解这些方法是执行CRUD操作的关键。'
- en: '**HTTP Status Codes and Headers**: HTTP status codes inform clients about the
    success or failure of their requests. HTTP headers transmit additional information
    and describe clients'' options and capabilities. Both are essential components
    of HTTP communication.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP状态码和头部信息**：HTTP状态码通知客户端其请求的成功或失败。HTTP头部传输额外的信息，并描述客户端的选项和能力。这两者都是HTTP通信的基本组成部分。'
- en: '**Versioning**: Managing changes in APIs without disrupting existing clients
    is a significant challenge. Different strategies for API versioning can help address
    this issue, but each comes with its own trade-offs.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：在不干扰现有客户端的情况下管理API的变化是一个重大挑战。不同的API版本控制策略可以帮助解决这个问题，但每种策略都有其自身的权衡。'
- en: '**Data Transfer Object (DTO)**: DTOs package data into a format that can provide
    many benefits, including reducing the number of HTTP calls, improving encapsulation,
    and enhancing performance when sending data over the network.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输对象 (DTO)**: DTOs将数据打包成一种格式，可以提供许多好处，包括减少HTTP调用次数、提高封装性，以及在通过网络发送数据时提升性能。'
- en: '**API Contracts**: Clear and robust API contracts ensure API stability. They
    serve as a blueprint for interaction between an API and its consumers, outlining
    available endpoints, supported HTTP methods, expected request formats, and potential
    response structures.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API合约**：清晰且健壮的API合约确保API的稳定性。它们作为API与其消费者之间交互的蓝图，概述了可用的端点、支持的HTTP方法、预期的请求格式和可能的响应结构。'
- en: '**Practical Application**: Understanding these concepts is not only theoretically
    important but also practically helpful in building and working with REST APIs
    using ASP.NET Core or any other similar technology.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际应用**：理解这些概念不仅从理论上重要，而且在使用ASP.NET Core或任何其他类似技术构建和操作REST API时也非常实用。'
- en: 'By now, you should have a solid understanding of REST APIs and be ready to
    explore how to implement one using ASP.NET Core. ASP.NET Core makes writing REST
    APIs using MVC or minimal APIs a breeze. MVC is a well-used pattern that is almost
    impossible to avoid. However, the new minimal API model makes the process leaner.
    Moreover, with application patterns like Request-EndPoint-Response (REPR) or Vertical
    Slice Architecture, we can organize our API per feature instead of by layer, leading
    to an improved organization. We cover those topics in *Section 4*: *Application
    patterns*.Next, we explore designing with ASP.NET Core, starting with Minimal
    APIs.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对REST API有了扎实的理解，并准备好探索如何使用ASP.NET Core实现一个API。ASP.NET Core使得使用MVC或最小API编写REST
    API变得轻而易举。MVC是一个广泛使用的模式，几乎无法避免。然而，新的最小API模型使过程更加精简。此外，通过应用模式如请求-端点-响应（REPR）或垂直切片架构，我们可以按功能而不是按层组织我们的API，从而提高组织效率。我们将在*第4节*：*应用模式*中介绍这些主题。接下来，我们将探讨使用ASP.NET
    Core进行设计，从最小API开始。
- en: Questions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s look at a few practice questions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: What is the most common status code sent in a REST API after creating an entity?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建实体后，REST API中最常见的状态码是什么？
- en: If you introduce a default strategy that returns the lowest possible version
    when no version is specified, would it break existing clients?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你引入一个默认策略，在没有指定版本时返回最低版本，这会破坏现有的客户端吗？
- en: If you want to read data from the server, what HTTP method would you use?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想从服务器读取数据，你会使用哪种HTTP方法？
- en: Can DTOs add flexibility and robustness to a system?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTOs能否为系统增加灵活性和健壮性？
- en: Are DTOs part of an API contract?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTOs是API合约的一部分吗？
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build on what we have learned in the chapter:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'HTTP request methods (MDN): [https://adpg.link/MFWb](https://adpg.link/MFWb)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求方法（MDN）：[https://adpg.link/MFWb](https://adpg.link/MFWb)
- en: 'HTTP response status codes (MDN): [https://adpg.link/34Jq](https://adpg.link/34Jq)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP响应状态码（MDN）：[https://adpg.link/34Jq](https://adpg.link/34Jq)
- en: 'HTTP headers (MDN): [https://adpg.link/Hx55](https://adpg.link/Hx55)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头部（MDN）：[https://adpg.link/Hx55](https://adpg.link/Hx55)
- en: 'Use .http files in Visual Studio 2022: [https://adpg.link/cbhv](https://adpg.link/cbhv)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中使用.http文件：[https://adpg.link/cbhv](https://adpg.link/cbhv)
- en: 'OpenAPI specification: [https://adpg.link/M4Uz](https://adpg.link/M4Uz)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI规范：[https://adpg.link/M4Uz](https://adpg.link/M4Uz)
- en: Answers
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: An API usually returns the status code `201 Created` after creating a new entity.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个API在创建新实体后通常会返回状态码`201 Created`。
- en: No, it will not break clients because they will either be using the lowest API
    version or have already specified a specific version.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它不会破坏客户端，因为它们要么在使用最低的API版本，要么已经指定了特定的版本。
- en: We typically use the HTTP GET method to read data from a REST API.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通常使用HTTP GET方法从REST API读取数据。
- en: Yes, Data Transfer Objects (DTOs) can add flexibility and robustness to a system.
    They allow you to control exactly what data you expose to the client and can reduce
    the amount of unnecessary data that needs to be sent over the network.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，数据传输对象（DTOs）可以为系统增加灵活性和健壮性。它们允许你精确控制向客户端暴露的数据，并且可以减少需要通过网络发送的不必要数据量。
- en: Yes, DTOs are part of an API contract. They define the data format exchanged
    between the client and server, ensuring both sides understand the data being sent
    and received.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，DTOs是API合约的一部分。它们定义了客户端和服务器之间交换的数据格式，确保双方都能理解发送和接收的数据。
