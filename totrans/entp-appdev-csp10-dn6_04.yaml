- en: '*Chapter 3*: Introducing C# 10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is an elegant and type-safe object-oriented programming language that allows
    developers to build a wide range of secure and robust applications that run in
    the .NET ecosystem and is in the top 5 of the popular programming languages list
    published by GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: C# was initially developed by Anders Hejlsberg at Microsoft as part of the .NET
    initiative. Since its first release in January 2002, there have been new features
    added consistently to the language to improve performance and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 10 released with .NET 6 comes with some cool new language features along
    with enhancements to the features released in earlier versions, which improve
    developer productivity. In this chapter, we will explore some of the new C# language
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplification of the using directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements to the Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancements to interpolated strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended property patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additions to the caller argument attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By end of this chapter, you'll be familiar with the major new additions to C#
    10\. Also, this chapter will help us to upskill ourselves to build our next enterprise
    application in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to understand the concepts of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 Community Edition with the .NET 6.0 runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of Microsoft .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Simplification of the using directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A top-level statement is a new feature introduced in C# 9.0, which makes it
    easy for developers to remove the ceremony code. The project templates that come
    with Visual Studio 2022 embrace the language changes introduced in C# such as
    top-level statements. For example, if you create a `Console` application, you
    will see the `Program.cs` file contains the code shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code came with a `console` application template that did not have
    the ceremony code such as class definition and the `main` method. This simplified
    the number of lines we could write by removing the redundant code.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts of the `implicit` using directives and `global` using directives
    introduced in C# 10 reduce the repetition of the `using` statements in each CS
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The global using directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `global` `using` directives, we do not repeat the namespace `using`
    statements in all the `.cs` files. The `global` keyword is used to mark a `global`
    `using` directive as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we marked `System.Threading` as `global`. Now, we can
    reference the types under `System.Threading` by having the `using` directive at
    the start of the `.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create `global` aliases to the namespaces to resolve the namespace
    conflicts, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By defining this, we can refer to all the classes defined under `System.Runtime.Serialization`
    using the alias name, `SRS`. We can also define a `global using static` directive
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can use all the `static` functions defined in the `System.Console`
    class directly without referring to the class name. For example, to write a line
    to the console, we can just call the `WriteLine` method without referring to the
    `Console` class name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can specify `global` `using` directives in any `.cs` file of the project.
    The only constraint is they should appear before any regular file-scoped using
    directives. The common practice seen among the developers is to create a `.cs`
    with the name `GlobalUsings.cs` and add the `global` `using` directive in that
    file. This will help to restrict the change to a single file when we need to add
    or remove a `global` `using` directive. The scope of the `global` `using` directives
    is the complication unit that is the current project.
  prefs: []
  type: TYPE_NORMAL
- en: The implicit using directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C#, we find a few framework namespaces, such as `System` and `System.Linq`,
    are present in almost all the classes. With C# 10, these commonly-used namespaces
    are implicitly added as `global` using directives. The namespaces added implicitly
    are based on the project target SDK and are documented here: https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these, if we wish to include any other namespace to be part
    of these implicit directives or remove any of the predefined namespaces, we can
    do so by adding `ItemGroup` to the `.csproj` file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we are including `System.Threading` and removing `System.IO`
    from the `implicit` `using` directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To completely remove the `implicit` `using` directives, we can uncheck the
    `ImplicitUsings` flag in the `.csproj` file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The simplification of `using` directives is another step toward removing the
    redundant ceremony code and making the content in the `.cs` files concise.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the `record` structs introduced with C#
    10.
  prefs: []
  type: TYPE_NORMAL
- en: The record structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *record types* introduced in C# 9 provide type declaration to create immutable
    reference types with synthesized methods for equality check and `ToString`. C#
    10 brings us the *record structs*. In this section, we will see what `record struct`
    is and how it is different from `record class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `record` keyword to declare `record class`, and we use the same
    `record` keyword to declare `record struct`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In C# 9, to declare a `record` class, we don''t explicitly use the `class`
    keyword. We simply specify `record` to declare it as shown here: `public` record
    `Shape(string Name);`'
  prefs: []
  type: TYPE_NORMAL
- en: Simply using the `record` keyword will continue to work in C# 10 to declare
    a `record` class, but it is recommended to specify `class` or `struct` explicitly
    for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: '`record struct` offers similar benefits to what `record class` offers, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplified declaration syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deconstruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meaningful `ToString` output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand these by creating a sample `Console` application and defining
    an `EmployeeRecord` record struct. Add the following code to the `Program.cs`
    file, which is using the `EmployeeRecord` record struct defined in the previous
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating two instances of the `EmployeeRecord`
    record struct with name field values using the simplified declaration syntax,
    then printing the hash code of the instance objects, and then checking the equality.
    Here, we are also deconstructing the fields from the `employee` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the code, we see the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Output of record struct example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Output of record struct example
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the output, we observe that `ToString` is overridden to include
    the contents of the instance. As expected, the hash code of both instances is
    the same, as the field values are the same. In a regular struct, the hash code
    of the object is generated based on the first non-nullable field. In the `record`
    struct, the `GetHashCode` method is also overridden to include all the fields
    to generate the hash code.
  prefs: []
  type: TYPE_NORMAL
- en: The `record` struct synthesizes the implementation of the `IEquatable<T>` interface.
    It also implements the `==` and `!=` operators. The regular struct does not have
    these operators implemented by default. The regular struct has the `Equals` method
    inherited from `ValueType`, which uses reflection to do the equality check. So,
    the synthesized equality check in the `record` struct is more performant. The
    `record` struct also synthesizes the `Deconstruct` method to populate the fields
    out of the object. If you take a closer look at the deconstruction code, you will
    notice the mixed declaration of the variables. We have `lastName` being declared
    during deconstruction, whereas `firstName` was declared in the preceding statement.
    This mixed declaration of variables is only possible in C#10 and above.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we disassemble the code in a disassembler tool such as ILSpy or Reflector,
    we see the generated code as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Generated code of the Employee class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Generated code of the Employee class
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can install ILSpy from [https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy](https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look closely at the `Employee` type definition, we can see all the plumbing
    synthesized by the C# compiler for the `record struct` type. From this, we can
    understand that the `record` struct is basically a struct that implements the
    `IEquatable` interface and overrides the `GetHashCode` and `ToString` methods.
    You can overwrite the `ToString` method to create your own string representation
    for the record type. Beginning with C# 10, you can also mark the `ToString` override
    as sealed, which prevents the compiler from synthesizing a `ToString` method or
    derived types from overriding it. Sealing the `ToString` method in the base record
    type ensures that the string representation is consistent across all derived types.
    The compiler also provides the `Deconstruct` method, which is used to deconstruct
    the `record` struct into its component properties. Unlike `record` classes, the
    `record` structs are mutable. To make a `record` struct immutable, we can add
    a `readonly` modifier to the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the fields of the `readonly record` struct, we can use the operator
    as shown here like with the `record` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned about the `record` struct introduced in C#
    10 and how it compares with the `record` class and regular struct. In the next
    section, let's learn about improvements to Lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements to Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Lambda expression is a way to represent an anonymous method. It allows us
    to define the method implementation inline.
  prefs: []
  type: TYPE_NORMAL
- en: A delegate type may be created from any Lambda expression. The types of a Lambda
    expression's parameters and return value determine the delegate type to which
    it can be transformed. A Lambda expression can be changed to an `Action` delegate
    type if it doesn't return a value; otherwise, it can be converted to one of the
    `Func` delegate types. In this section, we will learn about the improvements C#
    10 brings to Lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Inferring the expression type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# language compiler will now infer the expression type if the parameter''s
    types are explicit and the return type can be inferred. For example, consider
    the following code snippet where we defined a Lambda expression to find the square
    of the given integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the parameter `x` type is specified as `int` and the
    return type is inferred as `int` from the expression. If we mouse-hover on `var`
    in Visual Studio, we can see the inferred type of the `Square` Lambda expression,
    as shown in the next screenshot, which uses the `Func` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Inferred type of Square expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Inferred type of Square expression
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code shown here, the compiler will use the `Action` delegate, as the
    expression return type is `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The inferred type will use `Func` or `Action` delegates if it is suitable.
    Otherwise, the compiler will synthesize a delegate type, for example, if the Lambda
    expression is taking a `ref` type, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The synthesized type for the previous expression will be an `anonymous` delegate
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will try to infer the return type based on the expression. Sometimes,
    it may not be possible to infer the type. We will get a compilation error if it
    is unable to infer the type information.
  prefs: []
  type: TYPE_NORMAL
- en: Return types for Lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In situations where it is not possible for the compiler to infer the return
    type, we can specify explicitly in C# 10\. Consider the following code snippet,
    where we have `record` classes of `Employee` and `Manager` inherited from a `Person`
    record class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createExpression` term in the preceding code snippet creates an instance
    of an `Employee` or `Manager` type based on the condition passed in. In this situation,
    the compiler cannot infer the return type, which will result in a compilation
    error. With C#10, we can now explicitly specify the return type for a Lambda expression
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The expression type inferred for the preceding code is `Func<bool, Person>`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes to Lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from C# 10, we can add attributes to the Lambda expressions and their
    parameters and return types. The following code snippet defines a Lambda expression
    to retrieve employees for the given ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `GetEmployeeeById` expression has the `[Authorize]` attribute and the `id`
    parameter is attributed with `[FromRoute]`.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes on Lambda expressions don't have any effect when they are invoked,
    as the invocation is via the underlying delegate type. The attributes defined
    on Lambda expressions can be discovered via reflection.
  prefs: []
  type: TYPE_NORMAL
- en: The minimal API introduced with ASP.NET 6.0 is one of the driving factors behind
    these improvements. We will see the usage of this in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the improvements to the Lambda expressions;
    in the next section, we will see improvements to interpolated strings.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements to interpolated strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost every application will have some sort of text processing. In .NET, there
    are many ways available for string manipulation, such as the `string` primitive
    type, `StringBuilder`, `ToString` overrides on types, String concatenation, and
    `string.Format`, which provides functionality to build a string from a composite
    format string. `String.Format` takes a format string and format items as input
    and generates the formatted string as depicted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the positions `{0}` and `{1}` in the format string will
    be filled with the `Greeting` and `Message` format items respectively passed in
    as arguments. To make it more friendly and readable, C# 6 added a new language
    syntax called **interpolated strings**, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When interpolated strings syntax is used, the .NET compiler generates the code
    that is best suited for the interpolated string to produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a disassembler such as ILSpy or SharpLab to look at the generated code
    for the previous code snippet; it will look something like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[https://sharplab.io/](https://sharplab.io/) is a .NET code playground that
    shows the intermediate results of code compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: For the `message` interpolated string, the code was generated using concatenation.
    For the second string, `messageWithVersion`, where a non-string literal is involved,
    the generated code uses `string.Format`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler did what was intended, but it had a few issues where the code
    was generated using `string.Format`:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler parsed the interpolated string to generate code with `string.Format`.
    The same string must be parsed by the .NET runtime also to find the literal positions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The argument type of the literals in the `string.Format` method is `Object`.
    So, any value type used in `string.Format` involves boxing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overload of `string.Format` takes a maximum of three arguments. Beyond three
    is served by the overload that takes `params object[]`. So, more than three arguments
    require the instantiation of an array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `string.Format` accepts only the `Object` type, we cannot use `ref struct`
    types such as `Span<T>` and `ReadOnlySpan<char>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `ToString` is called on the captured expression, multiple transient strings
    will be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the shortcomings mentioned here will be addressed with C# 10 by generating
    code with a series of appends to the string builder. For the same code that we
    discussed, if you look at the generated code in C# 10, it uses `DefaultInterpolatedStringHandler`
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: For interpolated strings, instead of using `string.Format`, C# 10 compiler now
    uses `DefaultInterpolatedStringHandler`. In the previously-generated code, `DefaultInterpolatedStringHandler`
    is constructed by passing in the two arguments, the number of characters in the
    literal portion of the interpolated string, and the number of positions in the
    string to be filled. `AppendLiteral` or `AppendFormatted` are called to append
    the literal or to append the formatted string, respectively. With the introduction
    of interpolated string handlers, the concerns discussed previously were addressed.
  prefs: []
  type: TYPE_NORMAL
- en: For the same interpolated string code written in earlier versions of C#, there
    will be an improvement in the performance in C# 10\. We can also build our custom
    interpolated string handlers, which may be useful in situations when the data
    isn't going to be used as a string, or where conditional execution would be a
    logical fit for the target method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the improvements to the interpolated
    string, which gives us better performance over earlier versions. In the next section,
    let's learn about the extended property patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Extended property patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is a way to check an object's value or the value of a property
    having a full or partial match to a sequence. This is supported in C# in the form
    of `if…else` and `switch…case` statements. In modern languages, especially in
    functional programming languages such as F#, there is advanced support for pattern
    matching. With C# 7.0, new pattern matching concepts were introduced. Pattern
    matching provides a different way to express conditions to have more human-readable
    code. Pattern matching is being extended with every major release of C# since
    its introduction in C# 7.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let's learn about the extended property pattern introduced
    in C# 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we have an object of the `Product` type, which contains
    the location of the product origin. Prior to C# 10, if we wanted to check whether
    the country of origin of this product was the USA, we would do something similar
    to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 10, we can access the extended properties to make it more readable,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are validating the `Country` property of `Location`
    using an extended property pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about extended property patterns. Let's learn
    about the new addition to `caller` argument attributes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Addition to the caller argument attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# 5 first introduced `caller` argument attributes. They are `CallerMemberName`,
    `CallerFilePath`, and `CallerLineNumber`. These attributes make the compiler populate
    the method arguments in the generated code. They are used in various scenarios
    such as populating more data in the debug traces while firing an `OnNotifyPropertyChanged`
    event in the MVVM pattern. For example, consider the following code snippet, which
    defines a `Gift` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `Gift` class definition, the `OnPropertyChanged` method is
    called every time the setter of the `Description` property is called. In the `OnProperyChanged`
    method implementation, we have the `propertyName` argument attributed with `CallerMemberName`.
    This will make the compiler generate a setter as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: In this generated code, the argument to `OnProperyChanged` is auto-populated
    with the property name, `Description`, by the compiler. This is a handy feature
    for the developer that helps to write error-free code. The other two `caller`
    argument attributes, `CallerFilePath` and `CallerLineNumber`, populate the file
    path of the `caller` method and line number respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`CallerArgumentExpression` is a new addition to these in C# 10\. As the name
    suggests, the attribute makes the compiler auto-populate the argument expression.
    Let''s build a simple argument validation helper class that does the `null` check
    for the parameters passed. Consider the following implementation of an `ArgumentValidation`
    class, which implements a helper method that throws `ArgumentException` if the
    argument value is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ThrowIfNull` method, we are performing the `null` check and throwing
    `ArgumentException` with the details including the parameter name, which is picked
    from `CallerArgumentExpression`. We can use the preceding helper class to perform
    the `null` check on the arguments passed to a method. For example, consider the
    following method, which adds the passed-in product to the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we use the `ArgumentValidation` helper class to check the `null`
    condition of the `product` argument. The generated code for the call to the `ThrowIfNull`
    helper method will be `ArgumentValidation.ThrowIfNull(product, "product");`.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler auto-populated the parameter name in the string argument. Caller
    arguments will be useful where we want to add more details to the traces, which
    will help in troubleshooting the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the major additions to the C# language
    features in version 10\. We have seen how C# 10 simplifies the code written with
    `implicit` and `global` using directives. We have learned about `record` structs
    and how they compare with the `record` class introduced in C# 9\. We have also
    learned about the improvements to Lambda expressions, expression type inference,
    and explicitly specifying the return type for the expression. We have also seen
    performance improvements in interpolated strings. We have also learned how to
    build throw helpers using the `CallerArgumentExpression` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this chapter, we have gained the skills to leverage these new features
    of C# 10 features in the enterprise e-commerce application that we are going to
    build in the coming chapters. In addition to these, there are a few more small
    enhancements. You can refer to the C# language documentation to learn more here:
    [https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10).
    We will be highlighting the new features of C# 10 and .NET 6 throughout this book
    while implementing different features of our e-commerce application.'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming part, we will learn about the cross-cutting concerns that form
    the building blocks of our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading the chapter, you should be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false? Record structs are mutable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: Which keyword should you use to make a record struct immutable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. A record struct is immutable by default.
  prefs: []
  type: TYPE_NORMAL
- en: b. `readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: c. `finally`.
  prefs: []
  type: TYPE_NORMAL
- en: d. `sealed`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false? A compiler will infer the type expressions in all the scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: In which version of C# were caller argument attributes first introduced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. C# 9
  prefs: []
  type: TYPE_NORMAL
- en: b. C# 8
  prefs: []
  type: TYPE_NORMAL
- en: c. C# 5
  prefs: []
  type: TYPE_NORMAL
- en: d. C# 7
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
