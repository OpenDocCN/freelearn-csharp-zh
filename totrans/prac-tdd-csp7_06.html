<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Approaching the Problem</h1>
                
            
            
                
<p class="calibre2">In <a target="_blank" href="part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 5</a>, <em class="calibre12">Tabula Rasa – Approaching an Application with TDD in Mind</em>, the details of the Speaker Meet application were discussed. The requirements have been defined at a very high level. A picture has been painted with very, very broad strokes. This is often how the concept for many applications begins, with a high-level description and an important key functionality defined. It may have started with a bar napkin or a whiteboard sketch, but somewhere, somehow an idea was formed.</p>
<p class="calibre2">In this chapter, we'll cover:</p>
<ul class="calibre7">
<li class="calibre8">Defining the Speaker Meet application</li>
<li class="calibre8">Architectural choices</li>
<li class="calibre8">Testing direction</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining the problem</h1>
                
            
            
                
<p class="calibre2">To define the problem, first the vision must be defined. Clear objectives should be described and outlined. The Speaker Meet problem came about as a result of technology speakers looking for a single, centralized place in which to find speaking opportunities and venues. It was determined that user group and conference organizers were equally in need of a solution to seek and find speakers for their meetings.</p>
<p class="calibre2">Thus, the idea for Speaker Meet was born. But, how would the application work? Should it be a mobile application or a website? How would the data be collected and managed? Would users be allowed to create their own profiles? Could users submit speaker, community, and conference information? Where would the application live and how would it be hosted? And where in the world do we begin?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Digesting the problem</h1>
                
            
            
                
<p class="calibre2">The problem the application will be designed to solve has been defined. Speaker Meet will bring technology speakers, communities, and conferences together. Now that the purpose has been defined, it must be digested.</p>
<p class="calibre2">As was suggested before in a previous chapter, attacking a new application from all directions is ill-advised. It can be quite a daunting task to attempt to approach a new software project by implementing each and every desired feature all at once. It can also be a large chore to define every want and need of the system.</p>
<p class="calibre2">It would be far better to define small, manageable chunks of the application that can be delivered quickly in order to evaluate their correctness and effectiveness. The trouble is, how does one define what can be separated into small pieces and determine that this small piece is of sufficient value?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Epics, features, and stories; oh my!</h1>
                
            
            
                
<p class="calibre2">Many software development projects will maintain what is referred to as a <em class="calibre12">product backlog</em>. This is where everything that the system might be asked to do is compiled. The product backlog might contain the largest of ideas down to the most minute detail. The important thing is that these ideas are recorded.</p>
<p class="calibre2">The backlog should be regularly groomed and maintained. Items should be evaluated for their importance and ordered appropriately. If it is determined that an item is the next most important thing on which to be worked, it should be broken down into appropriately sized stories for the team to effectively deliver in a timely manner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Epics</h1>
                
            
            
                
<p class="calibre2">Larger, broader ideas are defined as <em class="calibre12">epics</em>. These could potentially be quite significant and wide-ranging in scope and size. Speakers would be defined as an epic. The speakers epic is a segment of the application devoted to anything and everything related to technology speakers.</p>
<p class="calibre2">The term epic is used to signify that the features and stories contained within the epic all revolve around a single, central idea. These essentially start life as a single, large user story, and are broken down into smaller features and stories. Epics can often take several sprints to complete.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Features</h1>
                
            
            
                
<p class="calibre2">Features are generally smaller than epics and are contained within epics. A feature will usually contain many stories related to the subject matter it is responsible for. Think of features the same way you think of epics, they are just a smaller grouping.</p>
<p class="calibre2">A feature might comprise a s<em class="calibre12">peaker catalog</em> or s<em class="calibre12">peaker detail</em>. The speaker catalog might contain everything associated with displaying, sorting, filtering, and searching for speakers within the system. The speaker detail feature might define details and functionality regarding single, individual speaker information and how it is displayed within the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Stories</h1>
                
            
            
                
<p class="calibre2">Depending on team preference, a story might be as small as seeing a speaker's name when viewing their details. A word of caution: it is possible to have too small a story. It is better to break a story down so it's just small enough and begin work than to waste time on minute details. If done correctly, the details will emerge during the development cycle.</p>
<p class="calibre2">Determining what is small enough should be left to the team to decide. A good rule of thumb is that stories should take from half a day to three days to complete. Less than half a days' worth of work and the story will likely be broken down into pieces that are too small. More than three day's work and there is likely an opportunity to break the story into two or more stories.</p>
<div><p class="calibre36">It is possible to have too small a story.</p>
</div>
<p class="calibre2">Don't fall into the trap of breaking down stories into piece that are too small. Effort can be wasted by trying to compose smaller and smaller stories. If you're practicing Scrum, remember that small improvements can and should be proposed at the conclusion of each sprint. During the retrospective, story size and its effectiveness should be discussed. If it is decided that the size was not appropriate, whether that be too large or too small, adjustments should be made before the next sprint begins.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Maintain your backlog</h1>
                
            
            
                
<p class="calibre2">So why is it so important to maintain the product backlog? A well-maintained backlog will define what the team should work on and help them plan for known, upcoming tasks. This will also help a team put together forecasting in order to plan for when a particular feature might be completed.</p>
<div><img src="img/00017.jpeg" class="calibre24"/></div>
<p class="calibre2">If appropriate metrics are captured, a well-disciplined team can deliver a reliable velocity in each sprint. With appropriately sized and estimated stories a reasonable timeline can be predicted for upcoming items in the backlog. For example, if a team has reliably delivered 20 points per sprint and the next five stories have been estimated at 8 points each it would not be unreasonable to expect these five stories to be completed in about two sprints. Of course, this is not a commitment; it is merely an estimate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Speaker Meet problem</h1>
                
            
            
                
<p class="calibre2">Remember that the application scope will initially be kept small and limited in functionality. Some features might be identified now as an item for the future, but the limited scope for the Minimum Viable Product still needs to be better defined. More features will continue to be added to the product backlog and prioritized quite low if it is determined that they are not needed for a first release. Consider, though, that a minimum viable product still needs to deliver some value. A software application that doesn't do anything isn't worth much to anyone.</p>
<p class="calibre2">Taking the time to prioritize the potential value of features and stories will help decide what should be included in an initial release, and what can wait. By determining the effort involved to deliver specific functionality and combining that information with the proposed value, an educated decision can be made regarding which features will be delivered first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Meaningful separation</h1>
                
            
            
                
<p class="calibre2">Brainstorming the proposed features of the application will help to describe the system. Finding meaningful, logical separation will help define the scope of particular sections of the software solution. Logical boundaries could include epics and features as defined in the product backlog. They could also be determined by divisions in technology.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Speakers</h1>
                
            
            
                
<p class="calibre2">The speaker epic will be made up of all of the features and stories surrounding the speakers portion of the application. This will include the speaker catalog and speaker details. This section will also contain any future enhancements and features that might be added at a later date. Future functionality might include speaker ratings and reviews, slide decks, and presentations, YouTube or Vimeo videos, and so on. These have yet to be determined and can be evaluated at a later date when a proposed value can be weighed.</p>
<div><p class="calibre36">Not all functionality needs to be decided up front. Remember, work towards a Minimum Viable Product and build functionality as it's needed.</p>
</div>
<p class="calibre2">Here are some basic features stories for the speaker epic:</p>
<pre class="calibre19">As user group organizer<br class="title-page-name"/> I want to see a listing of all speakers<br class="title-page-name"/> So that I can find speakers for my user group.<br class="title-page-name"/><br class="title-page-name"/>As conference organizer<br class="title-page-name"/> I want to see details of a particular speaker<br class="title-page-name"/> So that I might view more information about them.</pre>
<p>We are using a story format to describe detail at all levels of the application. That is, epics are presented as a story, themes or features are presented as a story, and specific requirements are presented as a story. In the hierarchy, only the specific requirements are called user stories though. The reason for giving them all the story format is simple. We want to be able to write a requirement and be able to transition it from user story to feature or even to epic with minimal hassle. So, we use the same format for a requirement regardless of the abstraction level of that requirement.</p>
<p class="calibre2">These feature stories are a good start. This will provide the business with an opportunity to grade and prioritize features before determining what should be worked on first. When presented to the team, these will likely need to be broken down into smaller, more detailed user stories with acceptance criteria.</p>
<p class="calibre2">Good acceptance criteria will help the team determine when a story can be marked complete. If all conditions have been met, then the story is done and can be delivered. If at some point, it is decided that more work is needed in order to deliver the requested functionality, additional criteria should be included or new stories added to the backlog.</p>
<pre class="calibre19">As user group organizer<br class="title-page-name"/> I want to see a listing of all speakers<br class="title-page-name"/> So that I can find speakers for my user group.</pre>
<pre class="calibre19">Given system contains speakers<br class="title-page-name"/> When viewing speaker catalog<br class="title-page-name"/> Then a listing of all speaker summaries is returned.</pre>
<pre class="calibre19">As conference organizer<br class="title-page-name"/> I want to see details of a particular speaker<br class="title-page-name"/> So that I might view more information about them.</pre>
<pre class="calibre19">Given specified speaker exists<br class="title-page-name"/> When speaker selected<br class="title-page-name"/> Then speaker details are returned.</pre>
<pre class="calibre19">Given specified speaker does not exists<br class="title-page-name"/> When speaker selected<br class="title-page-name"/> Then a friendly error message should be returned.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Communities</h1>
                
            
            
                
<p class="calibre2">User groups and meetups comprise the community section of the application. The main purpose of this portion of the application is to provide a place for speakers and potential members and attendees to find and discover technical communities in their area. Anyone traveling to a specific city might also be interested in learning which user groups or meetups are available to them, whether for speaking purposes or general attendance. The community segment of the application will include the community directory and user group details. If any future enhancements are proposed, they can be added as new features or user stories to the community epic.</p>
<p class="calibre2">At some point in the near future, location search will be added to the community portion of the system. This would allow the user to search for communities based on distance, perhaps allowing speakers to determine communities within a 200-mile radius at which they may be interested in speaking. This feature was determined to be unnecessary for an initial release of the Speaker Meet application.</p>
<p class="calibre2">A small list of community feature stories can be found here:</p>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see a listing of all communities<br class="title-page-name"/> So that I can find potential user groups at which to speak.</pre>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see details of a particular community<br class="title-page-name"/> So that I can learn more about the user group.</pre>
<p class="calibre2">Much like the speaker feature stories, the community feature stories will help the product owner prioritize the functionality to be developed. These, too, will likely need to be broken down into smaller, more detailed user stories with acceptance criteria. Take a look at the stories here:</p>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see a listing of all communities<br class="title-page-name"/> So that I can find potential user groups at which to speak.</pre>
<pre class="calibre19">Given system contains communities<br class="title-page-name"/> When viewing community catalog<br class="title-page-name"/> Then a listing of all user groups is returned.</pre>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see details of a particular community<br class="title-page-name"/> So that I can learn more about the user group.</pre>
<pre class="calibre19">Given community selected<br class="title-page-name"/> When specified community exists<br class="title-page-name"/> Then community detail returned.</pre>
<pre class="calibre19">Given community selected<br class="title-page-name"/> When specified community does not exists<br class="title-page-name"/> Then a friendly error message should be returned.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Conferences</h1>
                
            
            
                
<p class="calibre2">The details and functionality within the application regarding conferences are defined and described in the conferences epic. This will include the conference catalog and conference details. Future enhancements and features proposed at a later date may be added to the conferences epic.</p>
<p class="calibre2">Conferences, too, may utilize location search. There are a variety of third-party services available and they can be evaluated for inclusion in a future release. Like all third-party code, these will be abstracted away from the main application, so that the system is insulated from potential changes.</p>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see a listing of all conferences<br class="title-page-name"/> So that I can find conferences at which to speak.</pre>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see details of a particular conference<br class="title-page-name"/> So that I can learn more about the conference.</pre>
<p class="calibre2">Conferences differ from communities in that they happen only once per year and often have many speakers and sessions for the event. The conference feature stories will help the product owner prioritize the functionality to be developed. These, too, will likely need to be broken down into smaller, more detailed user stories with acceptance criteria. Take a look at the stories here:</p>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see a listing of all conferences<br class="title-page-name"/> So that I can find conferences at which to speak.</pre>
<pre class="calibre19">Given system contains conferences<br class="title-page-name"/> When viewing conference catalog<br class="title-page-name"/> Then a listing of all conferences is returned.</pre>
<pre class="calibre19">As a speaker<br class="title-page-name"/> I want to see details of a particular community<br class="title-page-name"/> So that I can learn more about the user group.</pre>
<pre class="calibre19">Given specified conference exists<br class="title-page-name"/> When conference selected<br class="title-page-name"/> Then conference detail returned.</pre>
<pre class="calibre19">Given specified conference does not exists<br class="title-page-name"/> When conference selected<br class="title-page-name"/> Then a friendly error message should be returned.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Separate by team function</h1>
                
            
            
                
<p class="calibre2">Many self-organizing teams split themselves by expertise. This might mean that members divide themselves into front-end developers, back-end developers, QA, and so on. Likewise, stories and tasks can be separated by functionality.</p>
<p class="calibre2">It is best left up to the team to decide how to effectively organize themselves and their body of work. For example, Sally may be the most knowledgeable developer when it comes to the .NET framework, while Steve may have more expertise with React. It might prove better to let Sally take a majority of the back-end stories and let Steve focus on front-end functionality. </p>
<p class="calibre2">Note that it is an easy pitfall to prioritize stories in such a manner that each team member has the most suitable work for them available. This will be efficient but not effective. Instead, priorities should focus on value delivered and optimized later on. There's no harm in letting someone (for example, Sally) work on UI features together with Steve when for example large UI design changes are needed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Technical separations</h1>
                
            
            
                
<p class="calibre2">There may be a time when you must perform some work that doesn't fit neatly into the epics defined previously. Non-functionality requirements may include items related to the technology chosen for parts of the system. Stories could comprise purely web or front-end functionality, such as bundling JavaScript files. Alternatively, back-end or server-side functionality may need to be defined outside the previous epics.</p>
<p class="calibre2">There will likely be a number of non-functional or system specifications that will also need to be evaluated. Examples of these requirements might include response times, throughput, or memory consumption. These are commonly added to the checklist for <em class="calibre12">Definition of Done</em> so that each story should confirm the non-functional requirements.</p>
<p class="calibre2">Many modern web-enabled applications are built as a <strong class="calibre1">Single Page Application</strong> (<strong class="calibre1">SPA</strong>) using JavaScript. These applications are hosted by a web server and delivered to a web browser on request. The entire application, or rather large pieces of the application, are delivered all at once. As requests are made by the client browser, the SPA will update the data on screen or mimic a page transition. Full-page postbacks and page reloading are not used with an SPA. This provides a perceptible increase in performance and increases in responsiveness for the end user. It also allows for distributing some of the processing of an application to client machines.</p>
<p class="calibre2">With this division of the SPA, much of the functionality can be split into <em class="calibre12">web</em> and <em class="calibre12">non-web</em> designations. A team may choose to write their stories in this way. Similarly, a team may choose to designate web specialists to work primarily on web-related functionality. One issue with this split is that the single story with just a front-end or back-end is not potentially shippable software. They do not separately deliver value. Instead, the story could be split by stripping out special case handling, offering only one purpose, keeping the UI simpler, and so on.</p>
<p class="calibre2">Like the web designation, a team may decide to separate stories into server-side or back-end functionality. This might cover all functionality from the API to the database and everything in between. The back-end of the Speaker Meet application is written in .NET with C# and Entity Framework Core and a SQL Server database. These technologies provide an excellent opportunity to create technical separations.</p>
<p class="calibre2">Defining a consistent API, for example, is an excellent place to start. How the back-end might be further subdivided is discussed later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            
                
<p class="calibre2">The Speaker Meet application has an assortment of technical requirements. Language choices and platform decisions can have an immense effect on an application. These decisions will determine how an application is delivered to a client and how many parts of the application are expected to behave.</p>
<p class="calibre2">Technology specifications can have a big impact on an application. Whether <strong class="calibre1">LAMP</strong> (<strong class="calibre1">Linux, Apache, MySQL, PHP</strong>/<strong class="calibre1">Perl</strong>/<strong class="calibre1">Python</strong>), <strong class="calibre1">MEAN</strong> (<strong class="calibre1">MongoDB, Express, Angular, Node</strong>), or in the case of Speaker Meet .NET and React, programming languages and frameworks can play a big role in a software system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">React web user interface</h1>
                
            
            
                
<p class="calibre2">The first <em class="calibre12">user interface d</em>efined for the Speaker Meet application is an SPA using React, a JavaScript library. React was written by the Facebook team for the purpose of developing modern web applications. This equates to the View in the traditional <em class="calibre12">Model-View-Controller</em> template. By using a one-way data flow model along with the <em class="calibre12">Virtual DOM</em>, React is an extremely powerful library that performs well and scales nicely.</p>
<p class="calibre2">Many additional libraries will be included using the JavaScript package manager NPM. Additional libraries include webpack, a bundler for JavaScript, CSS, and other such files. More will be introduced in the following chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">.NET Core</h1>
                
            
            
                
<p class="calibre2">The primary language for the server-side application will be C# in .NET Core. With the release of the latest overhaul to the .NET Framework, developers can choose which parts of the framework to include within their application and keep core level libraries to a minimum.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">.NET Web API</h1>
                
            
            
                
<p class="calibre2">The way to expose internal information and behavior to an external system, and the SPA is considered an external system, is to provide an <strong class="calibre1">Application Programming Interface</strong> (<strong class="calibre1">API</strong>). The API layer exposes data functionality to the outside world. The primary gateway into the application is an assemblage of APIs using .NET Web API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Entity Framework</h1>
                
            
            
                
<p class="calibre2">For the Speaker Meet application, an <strong class="calibre1">Object-Relational Mapper</strong> (<strong class="calibre1">ORM</strong>) is utilized to convert database objects into C# objects. There are many such ORMs available for a variety of different languages and platforms. In .NET alone there is NHibernate, LLBLGen, Dapper, and many more. For the Speaker Meet application, <strong class="calibre1">Entity Framework</strong> (<strong class="calibre1">EF</strong>) Core was selected.</p>
<p class="calibre2">Choosing an ORM mapper such as EF Core in and of itself is a requirement that will affect architectural choices for an application. The team will likely need to determine the pros and cons of ORM options available to them, and whether to use an ORM at all.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Azure</h1>
                
            
            
                
<p class="calibre2">The Speaker Meet application is hosted using Microsoft Azure. Choosing Azure allows the team to scale up or down parts of the application as demand arises. Of course, there are architectural decisions that must be made to effectively leverage the available functionality that Azure provides.</p>
<div><p class="calibre36">Knowing about upcoming or desired future functionality can allow a team to make wise decisions while developing parts of an application.</p>
</div>
<p class="calibre2">Future enhancements are planned to employ the power of Azure Search. The core search functionality was written in such a way that switching to Azure Search would have minimal impact on the rest of the system. Implementing Azure Search, of course, would be developed using TDD.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Database</h1>
                
            
            
                
<p class="calibre2">Microsoft SQL Azure is utilized to persist speaker information, user group and community particulars, information about conferences, as well as user login details. SQL Azure is very similar to using SQL Server on-premise, with a few caveats. For example, SQL Azure requires clustered indexes on each table. Knowing the requirements and differences of available database options allows the team to make an informed decision about their data storage choices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">An N-Tiered hexagonal architecture</h1>
                
            
            
                
<p class="calibre2">In a previous chapter, the N-Tiered architecture was discussed, where a software application is divided up into layers. N-Tiered applications are typically separated in successive layers, like the layers of a cake, from <em class="calibre12">A</em> to <em class="calibre12">B</em> to <em class="calibre12">C</em> and so on. There is a danger in defining an application in this way, as sometimes pieces of functionality don't cleanly fall into one layer. As long as the layers remain loosely coupled and functionality does not cross the boundaries, your application should remain well-structured and organized.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Hexagonal architecture</h1>
                
            
            
                
<p class="calibre2">The hexagonal architecture was first described by Alistair Cockburn in the 2000s. Hexagonal architecture has also been referred to as ports and adapters, in which ports are abstractions and adapters are the implementations. This approach to designing applications changes the concept of layers to one of internal and external pieces to the application.</p>
<p class="calibre2">Some may argue that the hexagonal architecture and N-Tiered architecture are one and the same. While it's possible to achieve a hexagonal architecture using an N-Tiered linear layered approach, the main distinction lies in how the layers interact with one another—linear or through specific ports and adapters: two distinct zones, internal and external bits. In the simplest of terms, a hexagonal method will save you in the event that something doesn’t fit neatly into a series of sequential layers and helps to prevent tight coupling between layers.</p>
<p class="calibre2">The main thing to remember is that there are things that need to be separated—data source, user interface, third-party libraries, frameworks—essentially anything that isn't written by your team, possibly even the layers themselves. With the use of the <em class="calibre12">Dependency Inversion Principle</em>, as discussed in a previous chapter, and the <em class="calibre12">Repository Pattern,</em> coupling can be kept to a minimum. This allows for greater flexibility, maintainability, and testability.</p>
<p class="calibre2">Greater flexibility can be provided by minimizing coupling between parts. New features can be plugged into the existing application. Existing parts of an application can be swapped out in favor of something else entirely. This simply cannot be done if existing parts of your application are tightly coupled to other parts.</p>
<p class="calibre2">If an application is segmented properly, it becomes much easier to maintain. By strictly adhering to the SOLID Principles as outlined in a previous chapters, this becomes almost effortless. With the strict adherence to hexagonal design and by keeping internal logic free from outside dependencies, it is simple to make modifications without impacts on other parts of the system.</p>
<p class="calibre2">Testing a loosely coupled system is much easier than the alternative. By limiting the dependencies, tests can be limited to the functionality of the method, function, or system under test. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Basic yet effective N-Tiered divisions</h1>
                
            
            
                
<p class="calibre2">Typical layers in a three-tiered application include presentation, business logic, and data access. These can be and often are subdivided even further, but this is a basic starting point for many applications.</p>
<p class="calibre2">By dividing an application in this way, the first separation of concerns is born. Business logic should not be found in the presentation layer. Data access code should not be found in the business logic layer.</p>
<p>A place for everything and everything in its place.</p>
<p>-Mary Poppins</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service layer</h1>
                
            
            
                
<p class="calibre2">The business layer, or <em class="calibre12">service layer</em>, is where the business logic for the application resides. Whether you choose to use the idea of individual services, managers, or domain objects, the idea is effectively the same. The logic of the application should reside in a separate place from the presentation information and data access code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Microservices</h1>
                
            
            
                
<p class="calibre2">You may have heard the term <em class="calibre12">microservices</em> at some point in your development career. These are typically very small, independent applications that serve one and only one purpose for the rest of the system. Whether they be standalone APIs or executables deployed to Azure Service Fabric, they can be developed and deployed independently from the rest of the application. Microservices tend to be small, reusable functions, often consumed by a number of different applications or deployed user interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Data access layer</h1>
                
            
            
                
<p class="calibre2">Instead of littering the rest of the application with data persistence code, many applications rely on a data access layer of some sort. This allows for a centralized location of all data retrieval and storage procedures.</p>
<p class="calibre2">As the Speaker Meet application relies on EF Core, the data access layer is where much of this information will reside.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Repository Pattern</h1>
                
            
            
                
<p class="calibre2">The Repository Pattern allows for abstraction between the domain layer and the data access layer. This allows for the rest of the application to be agnostic to the way data is persisted or retrieved. This allows for improved testability and for code reuse within the repositories themselves.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generic repository</h1>
                
            
            
                
<p class="calibre2">As much of the data access functionality is the same across database models, a g<em class="calibre12">eneric repository</em> is used to minimize duplication of code. Many standard <strong class="calibre1">CRUD</strong> (<strong class="calibre1">Create, Read, Update, Delete</strong>) operations are used across all database objects. This provides the opportunity to create a generic repository to be used across all models and this will be covered in <a target="_blank" href="part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 7</a>, <em class="calibre12">Test Driving C# Applications</em>.</p>
<p class="calibre2">As in life, often one size does not fit all. While the generic repository fits most cases, there may come a time when you need to create a specific repository or to extend the generic repository. These instances should be carefully evaluated and a proper solution should be put in place for them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">User interface adapter layer</h1>
                
            
            
                
<p class="calibre2">The user interface adapter layer is where a user interface can "plug in" to the rest of the application. The Speaker Meet application provides a collection of web APIs to provide data and functionality to external systems. The first such external system is the React SPA. Utilizing a user interface adapter layer allows for the replacement or addition of a new UI application. This could be in the form of native mobile application, a Facebook application, or integration with another external site such as Meetup.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">User interface layer</h1>
                
            
            
                
<p class="calibre2">Modern applications have a dual N-Tiered approach with architectures on both the back-end and front-end. This means that as much planning and separation as is done on the server side, the same amount of effort could also be spent architecting a UI application.</p>
<p class="calibre2">With much of the functionality of an entire system being delivered to the client, the SPA in the case of the Speaker Meet system can be treated as a wholly independent application. It, too, must have its own application architecture specification.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Front-end business layer</h1>
                
            
            
                
<p class="calibre2">Using Redux action creators allows for front-end business logic to be contained in a single layer or location. Within an action creator, behavior can be encapsulated and concerns separated. Reusable functions may be exposed, minimizing code duplication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Front-end user interface layer</h1>
                
            
            
                
<p class="calibre2">React components and containers provide the presentation to the end user. Reusable components should be created and kept small, and without external dependencies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Front-end data source layer</h1>
                
            
            
                
<p class="calibre2">Using React with Redux, data will be stored in state on the client's machine by way of a reducer. The shape of the data store should be carefully planned and evaluated. If something is not shared by more than one component, then it should likely not be placed in state. If you need the same data to take on many shapes, consider the use of something such as React Reselect, which provides a way to transform or compute derived data for use throughout your application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Testing direction</h1>
                
            
            
                
<p class="calibre2">Now that you have a basic plan for your architecture you have to think about where you should begin your testing. There are a few options for where to start:</p>
<ul class="calibre7">
<li class="calibre8">You could choose to start testing at the data access or data source layers and work your way up to the user interface layers. This method is a back-to-front approach to testing.</li>
<li class="calibre8">You could start at the user interface layers and work your way to the data access layers. Approaching the tests in this manner is a front-to-back method of testing.</li>
<li class="calibre8">Lastly, you could start testing in the business layers and work your way out to the hexagonal boundaries of the system. This method is an inside-out testing approach.</li>
</ul>
<p class="calibre2">As a demonstration of the three testing directions to be examined, the same scenario of user login will be used.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Back-to-front</h1>
                
            
            
                
<p class="calibre2">Most back-end developers have been taught to think in a database-first manner. This style of thinking will lead them to find that a back-to-front style of testing makes more sense. As mentioned previously, in back-to-front testing you start at the data access layers. Mentally you really start by imagining the data structure within the data source. Once a data source has been defined, you can move up a layer and begin thinking about the business layer's design. Finally, you can apply the models and functionality you have created to a user interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining a data source</h1>
                
            
            
                
<p class="calibre2">By starting in the data layer, you are presented with defining your data model as early as possible. For this application and the requirements you have received, we suggest you go with a SQL database and use an entity framework for your data connections. Since you are working in a relational database, you will need some kind of primary key. These keys are for relational database concerns and are often not mentioned in the system requirements. In a situation like this you might end up with a table that looks something like this.</p>
<table class="calibre38">
<tbody class="calibre39">
<tr class="calibre40">
<td class="calibre41">
<p class="calibre2">UserProfile</p>
</td>
<td class="calibre41">
<p class="calibre2"> </p>
</td>
<td class="calibre41">
<p class="calibre2"> </p>
</td>
</tr>
<tr class="calibre40">
<td class="calibre41">
<p class="calibre2"><strong class="calibre1">ID</strong></p>
</td>
<td class="calibre41">
<p class="calibre2"><strong class="calibre1">Integer</strong></p>
</td>
<td class="calibre41">
<p class="calibre2"><strong class="calibre1">Primary Key, Identity</strong></p>
</td>
</tr>
<tr class="calibre40">
<td class="calibre41">
<p class="calibre2">Username</p>
</td>
<td class="calibre41">
<p class="calibre2"><kbd class="calibre11">Varchar(255)</kbd></p>
</td>
<td class="calibre41">
<p class="calibre2">Unique, Not Null</p>
</td>
</tr>
<tr class="calibre40">
<td class="calibre41">
<p class="calibre2">PasswordHash</p>
</td>
<td class="calibre41">
<p class="calibre2"><kbd class="calibre11">Binary(64)</kbd></p>
</td>
<td class="calibre41">
<p class="calibre2">Not Null</p>
</td>
</tr>
<tr class="calibre40">
<td class="calibre41">
<p class="calibre2">FirstName</p>
</td>
<td class="calibre41">
<p class="calibre2"><kbd class="calibre11">Varchar(255)</kbd></p>
</td>
<td class="calibre41">
<p class="calibre2">Not Null</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Now that you have a table defined, you can see that, instead of having a simple password field, you must use a password hash for security reasons. The next step is to create the data access layer code that will interact with this table.</p>
<p class="calibre2">Start with tests to properly define the model. These tests will provide some of the validations defined in your requirements and put you in a good place to define the entity framework model builder relationships.</p>
<pre class="calibre19">public class UserProfileDtoTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]  <br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var dto = new UserProfileDto();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItHasAnId()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var dto = new UserProfileDto();<br class="title-page-name"/>    dto.Id = 1;<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(1, dto.Id);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">These are the tests that will get you started testing the model, the rest is up to you as an exercise. At the end of it, you should have a model that looks similar to this one.</p>
<pre class="calibre19">public class UserProfileDto<br class="title-page-name"/>{ <br class="title-page-name"/>  public int Id { get; set; }<br class="title-page-name"/>  public string Username { get; set; }<br class="title-page-name"/>  public string FirstName {get; set;}<br class="title-page-name"/>  public byte[] PasswordHash { get; set; }<br class="title-page-name"/>}</pre>
<p class="calibre2">As you can see, this model is not too complicated, but could get that way quickly if the number of database fields needed to expand. This is only a partial example of what a user profile would look like. Before moving on, think about what other fields would be needed and how they might need to be tested.</p>
<p class="calibre2">Now that you have a data transfer object, you need to be able to read that model into the application from the database. As mentioned in <a target="_blank" href="part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 3</a>, <em class="calibre12">Setting up a JavaScript Environment</em>, in the <em class="calibre12">What to Know Before Getting Started</em> section, we prefer to use a repository pattern for this. As a quick recap, the repository pattern is a simple pattern that helps us deal with create, read, update, and delete operations on a data source.</p>
<p class="calibre2">We are only going to use as much of the <kbd class="calibre11">FakeRepository</kbd> as is needed. For now that means that we will only implement <kbd class="calibre11">Get</kbd> and <kbd class="calibre11">GetAll</kbd>. </p>
<pre class="calibre19">public class FakeRepository&lt;T&gt; : IRepository&lt;T&gt; where T : class<br class="title-page-name"/>{<br class="title-page-name"/>    public IList&lt;T&gt; DataSet { get; set; } = new List&lt;T&gt;(); <br class="title-page-name"/>    public T Get(Func&lt;T, bool&gt; predicate)<br class="title-page-name"/>    { <br class="title-page-name"/>        return GetAll().Where(predicate).FirstOrDefault(); <br class="title-page-name"/>    }<br class="title-page-name"/> <br class="title-page-name"/>    public IQueryable&lt;T&gt; GetAll() <br class="title-page-name"/>    { <br class="title-page-name"/>        return DataSet.AsQueryable(); <br class="title-page-name"/>    } <br class="title-page-name"/>} </pre>
<p class="calibre2">Now that we are using a <kbd class="calibre11">FakeRepository</kbd>, we can move on to business layer integration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a business layer</h1>
                
            
            
                
<p class="calibre2">Using the <kbd class="calibre11">UserProfileDto</kbd> defined previously, you can now focus on the service needed to log on. As you will be dealing with the <kbd class="calibre11">UserProfileDto</kbd> and repository, call this the <kbd class="calibre11">UserProfileService</kbd>. It will house all the interactions in the app with user profile objects.</p>
<p class="calibre2">Right now, you only need to worry about the logon capabilities of the system. You will create a <kbd class="calibre11">GetUser</kbd> method which will consume a username and return a <kbd class="calibre11">UserProfile</kbd>. Then you will use the <kbd class="calibre11">UserProfile</kbd> and a password to authenticate.</p>
<p class="calibre2">First, here is the starting test to create a <kbd class="calibre11">UserProfileService</kbd>.</p>
<pre class="calibre19">public class UserProfileServiceTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var service = new UserProfileService();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class UserProfileService<br class="title-page-name"/>{<br class="title-page-name"/>  public UserProfileService()<br class="title-page-name"/>  {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">What we normally do at this point is create a new class and a folder structure to support tests related to the <kbd class="calibre11">UserProfileService</kbd>. Our next test class with be for testing the <kbd class="calibre11">GetUserProfile</kbd> method, so we will create the folder structure and add that test class.</p>
<p class="calibre2">Folder structure:</p>
<div><img src="img/00018.jpeg" class="calibre42"/></div>
<p class="calibre2">Now write tests for a <kbd class="calibre11">GetUserProfile</kbd> method.</p>
<pre class="calibre19">public class GetUserProfileTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsNullForNonExistentUsers()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserProfileDto&gt;();<br class="title-page-name"/>    var service = new UserProfileService(repository);<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var profile = service.GetUserProfile("NonExistantUser@email.com");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Null(profile);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsUserProfileForUsersThatExist()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserProfileDto&gt;();<br class="title-page-name"/>    var service = new UserProfileService(repository);<br class="title-page-name"/>    <br class="title-page-name"/>    repository.DataSet.Add(new UserProfileDto<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ExistingUser@email.com"<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var profile = service.GetUserProfile("ExistingUser@email.com");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(profile);<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;UserProfileDto&gt;(profile);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In this case, we will let you implement the class method that will pass these tests. Remember, we only want to the write a minimal amount of code to pass the tests. You will also want to create tests to verify case insensitivity, if that is something you believe the system needs.</p>
<p class="calibre2">Now that you have a user profile, you need to verify that the password supplied by the user is the correct password. We won't be getting into security concerns too much as part of this book, but you should know that passwords should be a one-way hash. Now, write the test to check the password before you move on to creating a user interface for logging in.</p>
<pre class="calibre19">public class IsUserPasswordValid<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly UserProfileService _service;<br class="title-page-name"/>  private readonly UserProfileDto _profile;<br class="title-page-name"/><br class="title-page-name"/>  public IsUserPasswordValid()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserProfileDto&gt;();<br class="title-page-name"/>    _service = new UserProfileService(repository);<br class="title-page-name"/>    _profile = new UserProfileDto<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      // This should be an encryption helper utility. Try to write and <br class="title-page-name"/>         test a utility to replace this code.<br class="title-page-name"/>      PasswordHash = SHA512.Create().ComputeHash(Encoding.ASCII.GetBytes("ValidPassword"))<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    repository.DataSet.Add(_profile);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsFalseForInvalidPasswords()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _service.IsUserPasswordValid(_profile, "InvalidPassword");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.False(result);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsTrueForValidPasswords()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _service.IsUserPasswordValid(_profile, "ValidPassword");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.True(result);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class UserProfileService<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly IRepository&lt;UserProfileDto&gt; _repository;<br class="title-page-name"/>  <br class="title-page-name"/>  public UserProfileService(IRepository&lt;UserProfileDto&gt; repository)<br class="title-page-name"/>  {<br class="title-page-name"/>    _repository = repository;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public object GetUserProfile(string username)<br class="title-page-name"/>  {<br class="title-page-name"/>    return _repository.GetAll().FirstOrDefault(u =&gt; u.Username == username);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public bool IsUserPasswordValid(UserProfileDto profile, string password)<br class="title-page-name"/>  {<br class="title-page-name"/>    // Now we have the same code in production code as we do in our tests.<br class="title-page-name"/>    var hash = SHA512.Create().ComputeHash(Encoding.ASCII.GetBytes(password));<br class="title-page-name"/><br class="title-page-name"/>    return profile.PasswordHash.SequenceEqual(hash);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Building a user interface</h1>
                
            
            
                
<p class="calibre2">Now there is enough functionality for you to begin working on your user interface. In a C# web API, the user interface is an API controller. The basic tests needed for an API controller are that it exists and that it inherits correctly from the controller class.</p>
<pre class="calibre19">public class UserProfileControllerTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var controller = new UserProfileController();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItIsAController()<br class="title-page-name"/>  {<br class="title-page-name"/>    var controller = new UserProfileController();<br class="title-page-name"/><br class="title-page-name"/>    Assert.IsAssignableFrom&lt;Controller&gt;(controller);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class UserProfileController : Controller<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, you need to make sure it has a logon method that accepts a username and password. That same method must also return either a 200 OK or 401 NOT AUTHORIZED, depending on the validity of the user information:</p>
<pre class="calibre19">public class UserLogon<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly UserProfileController _controller;<br class="title-page-name"/><br class="title-page-name"/>  public UserLogon()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserProfileDto&gt;();<br class="title-page-name"/>    var service = new UserProfileService(repository);<br class="title-page-name"/>    _controller = new UserProfileController(service);<br class="title-page-name"/><br class="title-page-name"/>    repository.DataSet.Add(new UserProfileDto<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "TestUser@email.com",<br class="title-page-name"/>      PasswordHash = SHA512.Create().ComputeHash(Encoding.UTF8.GetBytes("ValidPassword"))<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = _controller.LogonUser("TestUser@email.com", "Password");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsAnActionResult()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = _controller.LogonUser("TestUser@email.com", "Password");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;IActionResult&gt;(response);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsNotAuthorizedForBadUsername()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (StatusCodeResult) _controller.LogonUser("BadUser@email.com", "ValidPassword");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(HttpStatusCode.Unauthorized, (HttpStatusCode)response.StatusCode);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsOkForValidUsernameAndPassword()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (StatusCodeResult)_controller.LogonUser("TestUser@email.com", "ValidPassword");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(HttpStatusCode.OK, (HttpStatusCode)response.StatusCode);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsUnauthorizedForInvlalidPassword()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (StatusCodeResult)_controller.LogonUser("TestUser@email.com", "InvalidPassword");<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(HttpStatusCode.Unauthorized, (HttpStatusCode)response.StatusCode);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class UserProfileController : Controller<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly UserProfileService _service;<br class="title-page-name"/><br class="title-page-name"/>  public UserProfileController(UserProfileService service)<br class="title-page-name"/>  {<br class="title-page-name"/>    _service = service;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public IActionResult LogonUser(string username, string password)<br class="title-page-name"/>  {<br class="title-page-name"/>    var user = _service.GetUserProfile(username);<br class="title-page-name"/><br class="title-page-name"/>    if (user != null &amp;&amp; _service.IsUserPasswordValid(user, password))<br class="title-page-name"/>    {<br class="title-page-name"/>      return Ok();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return Unauthorized();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">One of the downsides to approaching the application in this manner is that now almost all of our layers are concerned with an object that is almost an exact representation of the database. Normally, this is not a real problem. But database tables do change so what if our user profile table needs some touching up in the future? Our entire application will need to be updated at this point. Did you pick up on some of the side-effects of thinking about the application in a back-to-front way? If not, that is okay, but keep an eye open as you explore the two other directional approaches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Front-to-back</h1>
                
            
            
                
<p class="calibre2">Another way that some developers choose to approach application design and implementation is from a user experience perspective. First, think about how the user would want to interact with the system, then design the system around that concept.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining a user interface</h1>
                
            
            
                
<p class="calibre2">To attack the application in this way, first you must determine what you think the best user experience would be. It would probably be best if the user not only got notified whether the logon was accepted, but also received a message explaining to them the current status.</p>
<p class="calibre2">What would you call our controller when testing from this direction? The user is wanting to log on so, you should call it a logon controller.</p>
<p class="calibre2">As before, you need to test that your controller exists. Then test that it properly inherits from the controller.</p>
<pre class="calibre19">public class LogonControllerTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItIsAnIActionResult()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;Controller&gt;(controller);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class LogonController : Controller<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, you can test for your API method. What should it be called? Think again about the user. They are trying to log on so, again, we should probably stick with something simple related to logon. The default post action on this controller should probably be the method used to activate a logon.</p>
<pre class="calibre19">public class Post<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = controller.Post(null);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsAnIActionResult()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = controller.Post(null);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;IActionResult&gt;(response);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsUnauthorizedForInvalidUser()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "InvalidUser@email.com",<br class="title-page-name"/>      Password = "BadPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (ObjectResult)controller.Post(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(response.StatusCode);<br class="title-page-name"/>    Assert.Equal(HttpStatusCode.Unauthorized, (HttpStatusCode)response.StatusCode);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsOkForValidUser()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      Password = "ValidPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (ObjectResult)controller.Post(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(response.StatusCode);<br class="title-page-name"/>    Assert.Equal(HttpStatusCode.OK, (HttpStatusCode)response.StatusCode);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsUnauthorizedForInvalidPassword()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      Password = "InvalidPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (ObjectResult)controller.Post(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(response.StatusCode);<br class="title-page-name"/>    Assert.Equal(HttpStatusCode.Unauthorized, (HttpStatusCode)response.StatusCode);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsSuccessfulLogonMessageWhenSuccessful()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      Password = "ValidPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (ObjectResult)controller.Post(attempt);<br class="title-page-name"/>   <br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal("Logon Successful", response.Value);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsUnauthorizedLogonMessageWhenUnauthorized()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var controller = new LogonController();<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "InvalidUser@email.com",<br class="title-page-name"/>      Password = "Password"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = (ObjectResult)controller.Post(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal("Username or Password invalid", response.Value);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class LoginAttempt<br class="title-page-name"/>{<br class="title-page-name"/>  public string Username { get; set; }<br class="title-page-name"/>  public string Password { get; set; }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class LogonController : Controller<br class="title-page-name"/>{<br class="title-page-name"/>  [HttpPost]<br class="title-page-name"/>  public IActionResult Post(LoginAttempt attempt)<br class="title-page-name"/>  {<br class="title-page-name"/>    if (attempt != null &amp;&amp; attempt.Username == "ValidUser@email.com" &amp;&amp; attempt.Password == "ValidPassword")<br class="title-page-name"/>    {<br class="title-page-name"/>      return Ok("Logon Successful");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return new ObjectResult("Username or Password invalid") {<br class="title-page-name"/>      StatusCode = (int?)HttpStatusCode.Unauthorized<br class="title-page-name"/>    };<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">With the front-to-back directional approach, you don't yet have any of your dependencies defined so you have no choice but to hardcode decisions. You can push those decisions back slightly, though.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a business layer</h1>
                
            
            
                
<p class="calibre2">Create an interface and move your valid user login into a fake logon service for that interface.</p>
<pre class="calibre19">public class LogonController : Controller<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly ILogonService _service;<br class="title-page-name"/><br class="title-page-name"/>  public LogonController(ILogonService service)<br class="title-page-name"/>  {<br class="title-page-name"/>    _service = service;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public IActionResult Post(LoginAttempt attempt)<br class="title-page-name"/>  {<br class="title-page-name"/>    return _service.IsLogonValid(attempt) ? <br class="title-page-name"/>      Ok("Logon Successful") :<br class="title-page-name"/>      new ObjectResult("Username or Password invalid") {<br class="title-page-name"/>        StatusCode = (int?)HttpStatusCode.Unauthorized<br class="title-page-name"/>      };<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public interface ILogonService<br class="title-page-name"/>{<br class="title-page-name"/>  bool IsLogonValid(LoginAttempt attempt);<br class="title-page-name"/>}</pre>
<pre class="calibre19">class FakeLogonService : ILogonService<br class="title-page-name"/>{<br class="title-page-name"/>  public bool IsLogonValid(LoginAttempt attempt)<br class="title-page-name"/>  {<br class="title-page-name"/>    return attempt != null &amp;&amp;<br class="title-page-name"/>      attempt.Username == "ValidUser@email.com" &amp;&amp;<br class="title-page-name"/>      attempt.Password == "ValidPassword";<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">If you are following along, you will need to update all the controller references in the tests to use this new fake logon service.</p>
<p class="calibre2">Now that you have an interface defined, you can write tests to create a service layer.</p>
<pre class="calibre19">public class IsValidLogon<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly LogonService _service;<br class="title-page-name"/><br class="title-page-name"/>  public IsValidLogon()<br class="title-page-name"/>  {<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserLogonDto&gt;();<br class="title-page-name"/>    _service = new LogonService(repository);<br class="title-page-name"/>    var userLogon = new UserLogonDto<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      PasswordHash =  SHA512.Create().ComputeHash(Encoding.ASCII.GetBytes("ValidPassword"))<br class="title-page-name"/>    };<br class="title-page-name"/>    <br class="title-page-name"/>    repository.DataSet.Add(userLogon);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserLogonDto&gt;();<br class="title-page-name"/>    var service = new LogonService(repository);<br class="title-page-name"/>    var attempt = new LoginAttempt();<br class="title-page-name"/><br class="title-page-name"/>    service.IsLogonValid(attempt);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsTrueForValidAttempt()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      Password = "ValidPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _service.IsLogonValid(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.True(result);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsFalseForInvalidUsername()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "InvalidUser@email.com",<br class="title-page-name"/>      Password = "ValidPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _service.IsLogonValid(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.False(result);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsFalseForInvalidPassword()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var attempt = new LoginAttempt<br class="title-page-name"/>    {<br class="title-page-name"/>      Username = "ValidUser@email.com",<br class="title-page-name"/>      Password = "InvalidPassword"<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _service.IsLogonValid(attempt);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.False(result);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class LogonService : ILogonService<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly IRepository&lt;UserLogonDto&gt; _repository;<br class="title-page-name"/><br class="title-page-name"/>  public LogonService(IRepository&lt;UserLogonDto&gt; repository)<br class="title-page-name"/>  {<br class="title-page-name"/>    _repository = repository;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public bool IsLogonValid(LoginAttempt attempt)<br class="title-page-name"/>  {<br class="title-page-name"/>    attempt = attempt ?? new LoginAttempt();<br class="title-page-name"/>    <br class="title-page-name"/>    var user = _repository.GetAll().FirstOrDefault(u =&gt; u.Username == attempt.Username);<br class="title-page-name"/><br class="title-page-name"/>    var hash = SHA512.Create().ComputeHash(Encoding.ASCII.GetBytes(attempt.Password ?? ""));<br class="title-page-name"/> <br class="title-page-name"/>    return user != null &amp;&amp; user.PasswordHash.SequenceEqual(hash);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class UserLogonDto : IIdentity<br class="title-page-name"/>{<br class="title-page-name"/>  public int Id { get; set; }<br class="title-page-name"/>  public string Username { get; set; }<br class="title-page-name"/>  public byte[] PasswordHash { get; set; }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Building a data source</h1>
                
            
            
                
<p class="calibre2">Now that you have a service, you can focus on the data layer. Believe it or not, this part is not really any different from what we did at this stage for the back-to-front approach.</p>
<p class="calibre2">We have managed to do one thing differently. We have created a contract for our data interaction. The rest of the table, if we are using a relational data store, could be anything and we don't care. We only care about the username and password hash. We only have ID because the <kbd class="calibre11">FakeRepository</kbd> requires it.</p>
<p>There are ways to program the repository that do not require this feature. We are not going to recreate the table from the previous example. It is the same table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inside out</h1>
                
            
            
                
<p class="calibre2">The last directional approach that we are going to cover in this chapter is the inside-out approach. With the inside-out approach, you begin, not with the UI or the data source, but instead with the business rules defined in the requirements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining a business layer</h1>
                
            
            
                
<p class="calibre2">Looking back at our requirements, we can build tests and logic that are a one-to-one match for our requirements such as: </p>
<ul class="calibre7">
<li class="calibre8">Given a registered speaker</li>
<li class="calibre8">And given an invalid username</li>
<li class="calibre8">When attempting login</li>
<li class="calibre8">Then an INVALID_USERNAME_OR_PASSWORD error occurs</li>
</ul>
<pre class="calibre19">public class LoginTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void GivenAnInvalidUsername()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange/Given<br class="title-page-name"/>    var username = "InvalidUser@email.com";<br class="title-page-name"/><br class="title-page-name"/>    // Act/When<br class="title-page-name"/>    var exception = Record.Exception(() =&gt; Account.Logon(username));<br class="title-page-name"/>  <br class="title-page-name"/>    // Assert/Then<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;InvalidUsernameOrPasswordException&gt;(exception);<br class="title-page-name"/>    Assert.Equal("Invalid Username or Password", exception.Message);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class InvalidUsernameOrPasswordException: Exception<br class="title-page-name"/>{<br class="title-page-name"/>  public InvalidUsernameOrPasswordException() : base("Invalid Username or Password")<br class="title-page-name"/>  {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class Account<br class="title-page-name"/>{<br class="title-page-name"/>  public object Logon(string username)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new InvalidUsernameOrPasswordException();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Some significant changes are made by the next requirement in order to provide some latitude going forward.</p>
<ul class="calibre7">
<li class="calibre8">Given a registered speaker</li>
<li class="calibre8">And given a valid username</li>
<li class="calibre8">And given a valid password</li>
<li class="calibre8">When attempting login</li>
<li class="calibre8">Then the user is granted access to the application</li>
</ul>
<pre class="calibre19">public class LoginTests<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly string _accessKey;<br class="title-page-name"/>  private readonly Account _account;<br class="title-page-name"/><br class="title-page-name"/>  public LoginTests()<br class="title-page-name"/>  {<br class="title-page-name"/>    _accessKey = "GrantedAccessKey";<br class="title-page-name"/>    var repository = new FakeRepository&lt;UserCredentials&gt;();<br class="title-page-name"/>    _account = new AccountTestDouble(repository);<br class="title-page-name"/><br class="title-page-name"/>    repository.DataSet.Add(new UserCredentials {<br class="title-page-name"/>      Username = "ValidUser@email.com"<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void GivenAnInvalidUsername()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange/Given<br class="title-page-name"/>    var username = "InvalidUser@email.com";<br class="title-page-name"/>    var password = "UnimportantPassword";<br class="title-page-name"/><br class="title-page-name"/>    // Act/When<br class="title-page-name"/>    var exception = Record.Exception(() =&gt; _account.Logon(username, password));<br class="title-page-name"/><br class="title-page-name"/>    // Assert/Then<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;InvalidUsernameOrPasswordException&gt;(exception);<br class="title-page-name"/>    Assert.Equal("Invalid Username or Password", exception.Message);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void GivenAValidUsernameAndPassword()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange/Given<br class="title-page-name"/>    var username = "ValidUser@email.com";<br class="title-page-name"/>    var password = "ValidPassword";<br class="title-page-name"/><br class="title-page-name"/>    // Act/When<br class="title-page-name"/>    var result = _account.Logon(username, password);<br class="title-page-name"/><br class="title-page-name"/>    // Assert/Then<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;string&gt;(result);<br class="title-page-name"/>    Assert.Equal(_accessKey, result);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class InvalidUsernameOrPasswordException : Exception<br class="title-page-name"/>{<br class="title-page-name"/>  public InvalidUsernameOrPasswordException() : base("Invalid Username or Password")<br class="title-page-name"/>  {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class Account<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly IRepository&lt;UserCredentials&gt; _repository;<br class="title-page-name"/><br class="title-page-name"/>  public Account(IRepository&lt;UserCredentials&gt; repository)<br class="title-page-name"/>  {<br class="title-page-name"/>    _repository = repository;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public string Logon(string username, string password)<br class="title-page-name"/>  {<br class="title-page-name"/>    var uc =_repository.GetAll().FirstOrDefault(u =&gt; u.Username == username);<br class="title-page-name"/>  <br class="title-page-name"/>    if (uc == null)<br class="title-page-name"/>    {<br class="title-page-name"/>      throw new InvalidUsernameOrPasswordException();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return GenerateAccessKey(uc);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  protected virtual string GenerateAccessKey(UserCredentials userCredentials)<br class="title-page-name"/>  {<br class="title-page-name"/>    // Here we would need to actually generate an access token<br class="title-page-name"/>    return "DefaultKey";<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class AccountTestDouble : Account<br class="title-page-name"/>{<br class="title-page-name"/>  public AccountTestDouble(IRepository&lt;UserCredentials&gt; repository) : base(repository) { }<br class="title-page-name"/><br class="title-page-name"/>  protected override string GenerateAccessKey(UserCredentials userCredentials)<br class="title-page-name"/>  {<br class="title-page-name"/>    return "GrantedAccessKey";<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">public class UserCredentials : IIdentity<br class="title-page-name"/>{<br class="title-page-name"/>  public int Id { get; set; }<br class="title-page-name"/>  public string Username { get; set; }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now for the last requirement that we were provided:</p>
<ul class="calibre7">
<li class="calibre8">Given a registered speaker</li>
<li class="calibre8">And given a valid username</li>
<li class="calibre8">And given an invalid password</li>
<li class="calibre8">When attempting login</li>
<li class="calibre8">Then an INVALID_USERNAME_OR_PASSWORD error occurs</li>
</ul>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenAnInvalidPassword()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange/Given<br class="title-page-name"/>  var username = "ValidUser@email.com";<br class="title-page-name"/>  var password = "InvalidPassword";<br class="title-page-name"/><br class="title-page-name"/>  // Act/When<br class="title-page-name"/>  var exception = Record.Exception(() =&gt; _account.Logon(username, password));<br class="title-page-name"/><br class="title-page-name"/>  // Assert/Then<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;InvalidUsernameOrPasswordException&gt;(exception);<br class="title-page-name"/>  Assert.Equal("Invalid Username or Password", exception.Message);<br class="title-page-name"/>}</pre>
<p class="calibre2">This last test was quite simple and closely resembles the first test we wrote for inside-out development. One thing to note, but which we are not showing here, is that we had to extend our <kbd class="calibre11">UserCredentials</kbd> class with the password hash property.</p>
<p class="calibre2">Creating the user interface and data layers from this point is almost exactly like what we have shown in the earlier examples, so we will not show them here.</p>
<p class="calibre2">The tasks left for this example are abstracting the business layer behind an interface, using the business object in the UI, and creating the appropriate data configuration for the data layer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we've defined the Speaker Meet application in more detail. Architectural choices were discussed and a path has been set. Epics, features, and user stories have been covered in enough detail that we're now ready to take the next steps with the Speaker Meet application.</p>
<p class="calibre2">In <a target="_blank" href="part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 7</a>, <em class="calibre12">Test Driving C# Applications</em>, we'll focus on test driving the C# API. Topics such as <em class="calibre12">fakes, stubs, </em>and <em class="calibre12">mocks</em> will be introduced to help you navigate the testing world.</p>


            

            
        
    </body></html>