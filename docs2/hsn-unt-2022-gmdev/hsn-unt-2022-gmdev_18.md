

# 第十八章：使用 Profiler、帧调试器和内存 Profiler 进行优化

欢迎来到本书的第四部分——我很高兴你到达了这一部分，这意味着你几乎完成了一个完整游戏！在本章中，我们将讨论优化技术来审查你的游戏性能并提高它，因为保持良好的和稳定的帧率对任何游戏都是至关重要的。

性能是一个广泛的话题，需要深入理解几个 Unity 系统，可能涉及几本书的内容。我们将探讨如何衡量性能，并探索我们对系统所做的更改的影响，通过测试来了解它们是如何工作的。

在本章中，我们将检查以下性能概念：

+   图形优化

+   优化处理

+   优化内存

到本章结束时，你将能够收集运行你的游戏的三件主要硬件的性能数据——GPU、CPU 和 RAM。你将能够分析这些数据以检测可能存在的性能问题，并了解如何解决最常见的问题。

我们将首先学习如何优化我们游戏中的图形方面。

# 图形优化

性能问题最常见的原因与资产误用有关，尤其是在图形方面，这主要是因为对 Unity 图形引擎工作原理了解不足。我们将探讨 GPU 在高级别上是如何工作的，以及如何提高其使用效率。

在本节中，我们将检查以下图形优化概念：

+   图形引擎简介

+   使用帧调试器

+   使用批处理

+   其他优化

我们将首先查看图形渲染的高级概述，以便更好地理解我们将在帧调试器中收集的性能数据。基于调试器的结果，我们将确定可以应用**批处理**（这是一种将多个对象的渲染过程组合起来的技术，以降低其成本）以及其他需要考虑的常见优化领域。

## 图形引擎简介

现在，每个游戏设备，无论是电脑、移动设备还是游戏机，都有一个显卡——一组专门从事图形处理的硬件。它在微妙但重要的方式上与 CPU 不同。图形处理涉及处理数千个网格顶点和渲染数百万个像素，因此 GPU 被设计为运行简短程序数以万计次，而 CPU 可以处理任何长度的程序，但并行化能力有限。拥有这些处理单元（CPU 和 GPU）的原因是，我们的程序可以在需要时使用每一个。

这里的问题是图形不仅仅依赖于 GPU。CPU 也参与了这个过程，进行计算并向 GPU 发出命令，因此它们必须协同工作。为了实现这一点，这两个处理单元需要通信，因为它们通常是物理上分开的，所以它们需要另一块硬件来实现这一点：总线，最常见的类型是**外围组件互连扩展**（**PCI Express**）总线。

PCI Express 是一种连接类型，允许在 GPU 和 CPU 之间移动大量数据，但问题是即使它非常快，如果你在这两个单元之间发出大量命令，通信时间也可能变得明显。因此，这里的关键概念是，图形性能主要通过减少 GPU 和 CPU 之间的通信来提高：

![图片](img/B18585_18_01.png)

图 18.1：通过 PCI Express 总线进行的 CPU/GPU 通信

现在，新的硬件架构允许 CPU 和 GPU 在同一芯片组中共存，减少通信时间，甚至共享内存。遗憾的是，这种架构不允许视频游戏所需的处理能力，因为将这两者分开可以让它们有足够的空间容纳大量核心。

图形引擎的基本算法是使用剔除算法确定哪些对象是可见的，根据它们的相似性对它们进行排序和分组，然后向 GPU 发出绘制命令以渲染这些对象组，有时会多次。CPU 和 GPU 之间主要的通信形式是**绘制命令**，通常称为**绘制调用**，我们在优化图形时的主要任务是尽可能减少它们。问题是存在多个需要考虑的绘制调用来源，例如光照或某些特殊效果。研究每一个都需要花费很长时间，即使如此，Unity 的新版本也可能引入具有自己绘制调用的新图形功能。相反，我们将探索使用帧调试器发现这些绘制调用的方法。

## 使用帧调试器

**帧调试器**是一个工具，它允许我们查看 Unity 渲染引擎发送给 GPU 的所有绘制调用的列表。它不仅列出它们，还提供了有关每个绘制调用的信息，包括检测优化机会所需的数据。通过使用帧调试器，我们可以看到我们的更改如何修改绘制调用的数量，立即对我们的努力给出反馈。

注意，减少绘制调用有时并不足以提高性能，因为每个绘制调用可能具有不同的处理时间；但通常，这种差异并不足以考虑。此外，在某些特殊的渲染技术中，例如光线追踪或光线步进，单个绘制调用可能会耗尽我们所有的 GPU 性能。在我们的游戏中不会出现这种情况，所以我们现在不考虑这一点。

让我们通过以下步骤使用帧调试器分析我们游戏的渲染过程：

1.  打开帧调试器（**窗口** | **分析** | **帧调试器**）。

1.  游戏并当您想要分析性能时，点击**帧调试器**（**启用**）左上角的**启用**按钮（在游戏过程中按*Esc*键可以恢复鼠标控制）：

![图形用户界面，应用程序描述自动生成](img/B18585_18_02.png)

图 18.2：启用帧调试器

1.  点击**游戏**选项卡以打开游戏视图。

1.  将**禁用**按钮右侧的滑块从左到右缓慢移动，以查看场景的渲染方式。每一步都是一个在 CPU 上为该游戏帧执行的绘制调用。您还可以观察窗口左侧的列表如何突出显示当时正在执行的绘制调用的名称：

![图形用户界面，应用程序描述自动生成](img/B18585_18_03.png)

图 18.3：分析我们的帧的绘制调用

1.  如果列表中的某些绘制调用在游戏面板中输出灰色图像，同时在控制台出现警告，则此问题的临时解决方案是选择场景的主相机，并将其**MSAA**属性在**相机**组件的**输出**部分设置为**关闭**。请记住，之后使用帧调试器撤销此更改。

1.  点击列表中的任何绘制调用，并观察窗口右侧的详细信息。

如果您不习惯于代码引擎或着色器，其中大部分可能会让您感到困惑，但您可以看到其中一些有可读的部分，说明**为什么这个绘制调用不能与上一个一起批处理**，这告诉您为什么两个对象没有在单个绘制调用中一起绘制。我们将在稍后检查这些原因：

![文本描述自动生成](img/B18585_18_04.png)

图 18.4：帧调试器中的批处理中断原因

1.  在**播放**模式下打开窗口，禁用地面，并立即查看绘制调用数量的变化。有时，仅仅打开或关闭对象就足以检测导致性能问题的原因。还可以尝试禁用后期处理和其他与图形相关的对象，如粒子。

即使我们对每个绘制调用来自哪里并不完全清楚，我们也可以至少从修改 Unity 中的设置开始，看看这些变化的影响。没有比通过每个切换并查看测量工具中这些变化的影响更好的方式来发现像 Unity 这样庞大的东西是如何工作的。当然，有时我们可能需要付出某些绘制调用的代价来实现某些效果，比如在地面场景中，尽管你总是可以怀疑这是否值得，但这需要逐个案例进行分析。

即使帧调试器给我们提供了大量信息，有时你可以额外采取一步，并使用更高级的工具，如 RenderDoc 或 Nvidia Nsight 等，这些工具在功能上与帧调试器相似，即它们显示了所有的绘制调用，但还显示了每个绘制调用的计时信息、每个调用使用的网格、着色器和纹理等信息。

现在，让我们讨论减少绘制调用的基本技术，并查看它们在帧调试器中的效果。

## 使用批处理

在前几章中，我们讨论了几种优化技术，其中光照是最重要的。如果你在实现这些技术时测量绘制调用，你会注意到这些操作对绘制调用数量的影响。然而，在本节中，我们将关注另一种称为批处理的图形优化技术。**批处理**是将多个对象分组以在单个绘制调用中一起绘制的进程。

你可能想知道为什么我们不能只在一个绘制调用中绘制所有内容，虽然这在技术上可行，但为了合并两个对象，需要满足一系列条件，通常情况是合并材质。

记住，材料是作为图形配置文件使用的资产，它指定了一个**材质**模式或着色器以及一组参数来定制我们对象的外观，并且记住我们可以在多个对象中使用相同的材质。如果 Unity 需要绘制一个与上一个不同的材质的对象，必须在发出绘制调用之前调用`SetPass`，这是另一种形式的 CPU/GPU 通信，用于在 GPU 中设置**材质**属性，例如其纹理和颜色。如果两个对象使用相同的材质，则可以跳过此步骤。第一个对象的`SetPass`调用会被第二个对象重用，这为批处理对象打开了机会。如果它们共享相同的设置，Unity 可以在 CPU 中将网格合并成一个，然后通过单个绘制调用将合并后的网格发送到 GPU。

有几种方法可以减少材质的数量，例如删除重复项，但最有效的方法是通过一个称为**纹理图集**的概念。这意味着将不同对象的纹理合并到一个纹理中。这样，由于使用的纹理可以应用于多个对象，因此多个对象可以使用相同的材质。遗憾的是，Unity 中没有自动系统来合并三维对象的纹理，例如我们在 2D 中使用的 Texture Atlas 对象。可能有一些系统在 Asset Store 中，但自动系统可能会有一些副作用。这项工作通常由艺术家完成，所以当与专门的 3D 艺术家（或如果你是自己）工作时，请记住这个技术：

![](img/B18585_18_05.png)

图 18.5：不同金属物体的碎片

通过以下操作使用帧调试器探索批处理：

1.  前往**编辑** | **首选项** | **核心渲染管线**并将**可见性**设置为**所有可见**。这将允许我们看到基本和高级图形设置：

![](img/B18585_18_06.png)

图 18.6：启用显示所有可用图形设置

1.  搜索我们目前想要使用的**可脚本渲染管线设置**资产（**编辑** | **项目设置** | **图形** | **可脚本渲染管线设置**）：

![](img/B18585_18_07.png)

图 18.7：可脚本渲染管线设置

1.  在**渲染**部分取消勾选**SRP Batcher**并勾选**动态批处理**。我们将在本章后面讨论**SRP Batcher**：

![](img/B18585_18_08.png)

图 18.8：禁用 SRP Batcher

1.  为测试创建一个新的空场景（**文件** | **新建场景**）。

1.  创建两种不同颜色的材质。

1.  创建两个立方体，并将一个材质放入第一个立方体，另一个材质放入第二个立方体。

1.  打开帧调试器并点击**启用**以查看我们立方体的绘制调用列表：

![文本描述自动生成](img/B18585_18_09.png)

图 18.9：立方体的绘制调用

1.  选择第二个**绘制网格立方体**调用，并查看批处理中断的原因。它应该说明对象具有不同的材质。

1.  在两个立方体上使用相同的材质，并再次查看列表。你会注意到现在我们只有一个**绘制网格立方体**调用。如果你没有在玩游戏，可能需要再次禁用和启用帧调试器以正确刷新。

现在，我挑战你尝试相同的步骤，但用球体代替立方体。如果你这样做，你可能会注意到，即使使用相同的材质，球体也没有被批处理！这就是我们需要引入**动态批处理**概念的地方。

记住，GameObject 有一个**静态**复选框，它用于通知几个 Unity 系统该对象不会移动，以便它们可以应用一些优化。未勾选此复选框的对象被认为是动态的。到目前为止，我们用于测试的立方体和球体都是动态的，因此 Unity 需要在每一帧将它们组合起来，因为它们可以移动，组合不是“免费的”。其成本与模型中的顶点数直接相关。你可以从 Unity 手册中获得确切的数字和所有必要的考虑，这可以通过在互联网上搜索`Unity Batching`或通过此链接访问：[`docs.unity3d.com/Manual/DrawCallBatching.html`](https://docs.unity3d.com/Manual/DrawCallBatching.html)。然而，可以说，如果一个对象的顶点数足够大，那么该对象就不会被批处理，这样做将需要发出超过两个绘制调用。这就是为什么我们的球体没有被批处理；球体有太多的顶点。

现在，如果我们有静态对象，情况就不同了，因为它们使用第二个批处理系统——**静态批处理器**。这个概念是相同的。合并对象以在一个绘制调用中渲染它们，并且这些对象需要共享相同的材质。主要区别在于，这个批处理器将批处理比动态批处理更多的对象，因为合并是在场景加载时一次性完成的，然后保存在内存中以供下一帧使用，这会消耗内存，但每个帧都会节省大量的处理时间。你可以使用我们用来测试动态批处理的方法来测试静态版本，只需这次检查球体的**静态**复选框，并在**播放**模式下查看结果；在**编辑**模式（当它没有播放时），静态批处理器不会工作：

![图形用户界面、文本、应用程序 描述自动生成](img/B18585_18_10.png)

图 18.10：一个静态球体及其静态批处理

在继续之前，让我们讨论一下为什么我们禁用了 SRP Batcher 以及这如何改变我们刚才讨论的内容。在 2020 版中，Unity 引入了**通用渲染管线**（**URP**），这是一种新的渲染管线。

除了几个改进之外，目前一个相关的改进是 SRP Batcher，这是一个新的批处理器，它对没有顶点或材质限制的动态对象进行工作（但有其他限制）。SRP Batcher 不是依赖于与批处理对象共享相同的材质，它可以有一个使用相同着色器的对象批处理，这意味着我们可以有，例如，100 个对象，每个对象有 100 种不同的材质，并且它们将根据材质使用相同的着色器和变体进行批处理，只要材质使用相同的着色器和变体，无论顶点数量多少：

![包含文本、标志、屏幕截图的图片 描述自动生成](img/B18585_18_11.png)

图 18.11：材质的 GPU 数据持久性，这允许 SRP Batcher 存在

一个着色器可以有多个版本或变体，选择的变体基于设置。我们可以有一个不使用法线贴图的着色器，以及一个不计算法线的变体将被使用，这可能会影响 SRP Batcher。所以，使用 SRP Batcher 基本上没有缺点，所以请继续将其打开。尝试创建尽可能多的球体，使用尽可能多的材质，并在帧调试器中检查它将生成的批次数。只是考虑一下，如果你需要在一个 URP 时代之前完成的项目上工作，这将不可用，因此你需要知道适当的批处理策略来使用。

## 其他优化

如前所述，有许多可能的图形优化，因此让我们简要讨论一下基本优化，从**细节级别**（**LOD**）开始。LOD 是根据物体与摄像机的距离改变物体网格的过程。如果在物体距离较远时，用单个具有较少细节的合并网格替换由几个部分和部件组成的房子，这可以减少绘制调用。使用 LOD 的另一个好处是，由于顶点数量的减少，可以降低绘制调用的成本。

要使用此功能，请执行以下操作：

1.  创建一个空对象，并将模型的两个版本作为父对象。你需要使用具有不同细节级别的好几个版本，但现在我们只是使用一个立方体和一个球体来测试这个功能：

![包含图表的图片  描述自动生成](img/B18585_18_12.png)

图 18.12：一个具有两个 LOD 网格的单个对象

1.  将**LOD 组**组件添加到父对象中。

1.  默认的**LOD 组**已准备好支持三个 LOD 网格组，但因为我们只有两个，所以右键单击一个，然后点击**删除**。您也可以选择**插入之前**来添加更多 LOD 组：

![漏斗图  描述自动生成，置信度低](img/B18585_18_13.png)

图 18.13：移除 LOD 组

1.  选择**LOD 0**，这是最高细节的 LOD 组，然后点击下面的**渲染器**列表中的**添加**按钮，将该球体添加到该组。你可以添加任意数量的网格渲染器。

1.  选择**LOD 1**并添加立方体：

![图形用户界面  描述自动生成](img/B18585_18_14.png)

图 18.14：向 LOD 组添加渲染器

1.  拖动两个组之间的线来控制每个组将占据的距离范围。当你拖动时，你会看到相机需要移动多远才能切换组。此外，你还有**裁剪**组，这是相机不会渲染任何组的距离。

1.  只需在**场景**面板中移动场景，就可以看到网格是如何交换的。

1.  这里需要考虑的是，物体的碰撞器不会被禁用，所以只需在 LOD 子对象中放置渲染器。将 LOD 0 形状的碰撞器放在父对象中，或者只需从 LOD 组对象中移除碰撞器，除了组 0。

另一个需要考虑的优化是**视锥裁剪**。默认情况下，Unity 会渲染任何落在摄像机视图区域或视锥体内的对象，跳过那些不在的对象。该算法足够便宜，可以始终使用，而且无法禁用它。然而，它确实有一个缺陷。如果我们有一堵墙隐藏了它后面的所有对象，即使它们被遮挡，它们也会落在视锥体内，所以它们仍然会被渲染。检测网格的每个像素是否遮挡了另一个网格的每个像素几乎是不可能在实时中完成的，但幸运的是，我们有一个解决方案：遮挡裁剪。

**遮挡剔除**是一个分析场景并确定场景不同部分中可以看到哪些对象的过程，将它们分为区域并分析每一个。由于这个过程可能需要相当长的时间，它是在编辑器中完成的，类似于光照贴图。正如你可以想象的那样，它只对静态对象有效，因为它的计算是在编辑器中进行的。要使用它，请执行以下操作：

1.  将不应移动的对象标记为静态，或者如果你只想让这个对象在遮挡剔除系统中被视为静态，请检查**静态**复选框右侧的箭头处的**遮挡者静态**和**被遮挡者静态**复选框。

1.  打开**遮挡剔除**窗口（**窗口** | **渲染** | **遮挡剔除**）。

1.  保存场景并点击窗口底部的**烘焙**按钮，然后等待烘焙过程。如果你在烘焙过程之前没有保存场景，它将不会执行。

1.  在**遮挡剔除**窗口中选择**可视化**选项卡。

1.  当**遮挡剔除**窗口可见时，选择相机（或 Cinemachine 控制的相机的情况下的虚拟相机）并拖动它，观察随着相机移动，物体是如何被遮挡的：

![包含户外和飞机的图片，描述自动生成](img/B18585_18_15.png)

图 18.15：左侧是正常场景，右侧是应用了遮挡剔除的场景

请注意，如果你将相机移动到计算区域之外，该过程将不会进行，Unity 将只计算静态对象附近的区域。你可以通过创建一个空对象并添加**遮挡区域**组件来扩展计算区域，设置其位置和大小以覆盖相机将到达的区域，最后重新烘焙剔除。尽量对立方体的尺寸保持敏感。要计算的区域越大，你磁盘上存储生成的数据所需的空间就越大。

你可以使用这些区域中的几个来提高精确度——例如，在一个 L 形场景中，你可以使用其中的两个：

![图表描述自动生成，置信度中等](img/B18585_18_16.png)

图 18.16：遮挡区域

如果你看到物体没有被遮挡，可能是因为遮挡对象（在这个例子中是墙壁）不够大，不能被考虑。你可以增加对象的大小或减少窗口**烘焙**选项卡中的**最小遮挡者**设置。这样做将进一步细分场景以检测小遮挡者，但这将在磁盘上占用更多空间来存储更多数据。因此，再次提醒，对这个设置保持敏感。

尽管我们还可以应用一些其他技术到我们的游戏中，但我们讨论的这些已经足够用于我们的游戏。因此，在本节中，我们学习了在视频卡中渲染图形的过程，批处理的概念，如何分析它们以确切知道我们有多少个批处理以及它们在做什么，最后，如何尽可能减少它们。现在，让我们开始讨论其他优化领域，例如处理领域。

# 优化处理

虽然图形通常占用生成帧所需的大部分时间，但我们绝不能低估代码和场景优化不良的成本。游戏中有几个部分仍在 CPU 中进行计算，包括图形处理的一部分（如批处理计算）、物理、音频以及我们的代码。在这里，我们比图形方面有更多的性能问题原因，所以，我们再次不讨论每一个优化，而是学习如何发现它们。

在本节中，我们将探讨以下 CPU 优化概念：

+   检测 CPU 和 GPU 限制

+   使用**CPU 使用情况**Profiler

+   通用 CPU 优化技术

我们将首先讨论 CPU 和 GPU 限制的概念，这些概念侧重于优化过程，确定问题是否与 GPU 或 CPU 相关。稍后，就像 GPU 优化过程一样，我们将探讨如何收集 CPU 的性能数据并解释它以检测可能要应用的优化技术。

## 检测 CPU 和 GPU 限制

与帧调试器类似，Unity Profiler 允许我们通过一系列 Profiler 模块收集关于游戏性能的数据，每个模块都设计用来收集每帧不同 Unity 系统的数据，例如物理、音频，最重要的是**CPU 使用情况**。这个最后的模块允许我们看到 Unity 执行以处理帧的最重要操作——从我们的脚本到物理和图形（CPU 部分）等系统。

在探索**CPU 使用情况**之前，我们可以在本模块中收集的一个重要数据点是我们是否受 CPU 或 GPU 限制。正如之前所解释的，一个帧的处理既使用 CPU 也使用 GPU，这些硬件可以并行工作。当 GPU 执行绘图命令时，CPU 可以非常高效地执行物理和我们的脚本。但是，现在假设 CPU 完成其工作，而 GPU 仍在工作。CPU 可以开始处理下一帧吗？答案是不了。这会导致不同步，因此在这种情况下，CPU 需要等待。这被称为 CPU-bound，我们还有相反的情况，即 GPU-bound，当 GPU 比 CPU 先完成时。

集中我们的优化努力是很重要的，因此如果我们检测到我们的游戏是 GPU 限制的，我们将专注于 GPU 图形优化（如减少网格和着色器复杂性），如果是 CPU 限制的，那么我们将专注于其他系统和图形处理的 CPU 部分。为了检测我们的游戏是哪种情况，请执行以下操作：

1.  打开 **分析器**（**窗口** | **分析** | **分析器**）。

1.  在左上角的 **分析器模块** 下拉菜单中，勾选 **GPU** 以启用 GPU 分析器：

![表格，描述自动生成](img/B18585_18_17.png)

图 18.17：启用 GPU 分析器

1.  播放游戏并选择 **CPU 使用率** 分析器，点击 **分析器** 窗口的左侧部分其名称。

1.  点击 **最后一帧** 按钮，即指向右的双箭头按钮，以始终显示正在渲染的最后一帧的信息：

![包含日历的图片，描述自动生成](img/B18585_18_18.png)

图 18.18：最后一帧按钮（向右的双箭头）

1.  还点击 **Live** 按钮以启用实时模式，这允许你实时查看分析结果。这可能会影响性能，因此你可以稍后禁用它：

![图形用户界面、文本、应用程序，描述自动生成](img/B18585_18_19.png)

图 18.19：启用实时模式

1.  观察窗口中间带有 **CPU** 和 **GPU** 标签的条形图。它应该说明 CPU 和 GPU 消耗了多少毫秒。数值较高的那个将是限制我们的帧率的那个，并确定我们是 GPU-还是 CPU-限制的：

![包含表格的图片，描述自动生成](img/B18585_18_20.png)

图 18.20：确定我们是 CPU-还是 GPU-限制的

1.  有可能当你尝试打开 GPU 分析器时，你会看到一个不支持的消息，这种情况可能发生在某些情况下（例如在使用 Metal 图形 API 的 Mac 设备上）。在这种情况下，另一种查看我们是否是 GPU 限制的方法是在选择 **CPU 使用率** 分析器时，在 CPU/GPU 标签旁边的搜索栏中搜索 `waitforpresent`。如果你看不到搜索栏，点击 **Live**（应显示为 **时间轴**）左侧的下拉菜单并选择 **层次结构**：

![](img/B18585_18_21.png)

图 18.21：搜索 waitforpresent

1.  在这里，你可以看到 CPU 等待 GPU 的时间有多长。检查 **时间 ms** 列以获取数字。如果你看到 **0.00**，这意味着 CPU 不在等待 GPU，这意味着我们是 CPU-限制的。在前面的屏幕截图中，你可以看到我的屏幕显示 **0.00**，而 CPU 正在消耗 **9.41ms**，GPU 正在消耗 **6.73ms**。所以，我的设备是 CPU-限制的，但请考虑你的设备和项目可能带来不同的结果。

现在我们能够检测到我们是 CPU 受限还是 GPU 受限，我们可以集中优化努力。到目前为止，我们在*优化图形*部分讨论了如何分析和优化 GPU 过程的一部分。现在，如果我们检测到我们是 CPU 受限，让我们看看如何分析 CPU。

## 使用 CPU 使用率分析器

分析 CPU 的方式与分析 GPU 的方式类似。我们需要获取 CPU 执行的动作列表，并尝试减少它们的数量，或者至少减少它们的成本。在这里，**CPU 使用率分析器**模块就派上用场了——这是一个允许我们查看 CPU 在一个帧中执行的所有指令的工具。主要区别在于 GPU 主要执行绘制调用，我们只有几种类型，而 CPU 可以执行数百种不同的指令，有时其中一些指令无法删除，例如物理或音频处理。在这些情况下，我们希望减少这些函数的成本，以防它们消耗了太多时间。因此，在这里的一个重要提示是检测哪个函数消耗了太多时间，然后减少其成本或删除它，这需要更深入地了解底层系统。让我们首先开始检测函数。

当你在打开**分析器**标签的情况下玩游戏时，你会看到一系列显示游戏性能的图形，在**CPU 使用率**分析器中，你会看到图形被分成不同的颜色，每个颜色都指代帧处理的不同部分。你可以查看分析器左侧的信息，以了解每种颜色的含义，但让我们讨论最重要的几个。

在下面的屏幕截图中，你可以看到图形应该如何显示：

![图表描述自动生成](img/B18585_18_22.png)

图 18.22：分析 CPU 使用率图

如果你看到图形，你可能会认为图表中深绿色的部分占据了大部分的性能时间，虽然这是真的，但你也可以从图例中看到，深绿色代表**其他**，这是因为我们在编辑器中分析游戏。编辑器不会表现得完全像最终的游戏。为了运行它，它必须执行许多额外的处理，这些处理在游戏中不会执行，所以你能做的最好的事情就是直接在游戏构建中进行分析。在那里，你会收集到更准确的数据。我们将在下一章讨论如何进行构建，所以现在我们可以忽略那个区域。我们现在能做的就是简单地点击**其他**标签左侧的彩色方块，以从图中禁用该测量，以便稍微清理一下。如果你也看到一个很大的黄色部分，它指的是**垂直同步**，这基本上是我们等待处理与显示器刷新率匹配的时间。这也是我们可以忽略的东西，所以你也应该禁用它。在下一张屏幕截图中，你可以检查图形颜色类别以及如何禁用它们：

![图形用户界面，应用程序描述自动生成](img/B18585_18_23.png)

图 18.23：从性能分析器中禁用 VSync 及其他设置

现在我们已经清理了图表，我们可以通过查看带有**ms**标签的线条（在我们的案例中，**5ms (200FPS)**）来了解我们游戏潜在帧率的良好概念，这表明低于该线的帧有超过 200 FPS，而高于该线的帧则较少。

在我的情况下，我拥有出色的性能，但请记住，我是在一台强大的机器上测试的。进行性能分析的最佳方式不仅是在游戏的构建（作为可执行文件）中，还包括在目标设备上，这应该是我们打算让游戏运行的最低配置硬件。我们的目标设备很大程度上取决于游戏的目标受众。如果我们正在制作休闲游戏，我们可能针对的是移动设备，因此我们应该在最低配置的手机上测试游戏，但如果我们的目标是针对核心玩家，他们可能拥有强大的机器来运行我们的游戏。

如果你针对的是核心玩家，当然，这并不意味着我们可以因为这一点就制作一个非常未优化的游戏，但这将给我们足够的空间来添加更多细节。无论如何，我强烈建议如果你是初学者，避免那些类型的游戏，因为它们更难开发，你可能很快就会意识到这一点。一开始就坚持简单的游戏。

通过观察图形颜色，你可以观察到渲染在 CPU 方面的成本以浅绿色表示，图表显示它占用了相当一部分的处理时间，这是正常的。然后，在蓝色中，我们可以看到我们的脚本和其他系统执行的代价，这也占用了相当一部分，但同样，这也是相当正常的。我们还可以观察到一点橙色，代表物理，还有一点浅蓝色，代表动画。请记住检查性能分析器中的彩色标签，以记住哪种颜色代表什么。

现在，那些彩色条代表一组操作，如果我们认为**渲染**条代表 10 个操作，我们如何知道这包括哪些操作？同样，我们如何知道这些操作中哪一个占用了最多的性能时间？在这 10 个操作中，任何一个都可能是导致这些问题的原因。这就是性能分析器底部部分有用的地方。它显示了一帧中所有被调用的函数列表。要使用它，请执行以下操作：

1.  点击性能分析器中**CPU 使用率**部分的任何部分，并检查性能分析器底部栏左上角的按钮是否显示为**层次结构**。如果不是（例如，如果显示为**时间线**），点击它并选择**层次结构**。

1.  清除我们之前使用的搜索栏。它将按名称过滤函数调用，而我们希望看到所有调用。

1.  点击**时间 ms**列，直到你看到一个指向下方的箭头。这将按成本降序排列调用。

1.  点击图表中引起你注意的帧——可能是那些高度最大、消耗更多处理时间的帧之一。这将使 Profiler 立即停止游戏并显示有关该帧的信息。

在查看图表时，有两个方面需要考虑。如果你看到高于其他帧的峰值，这可能会在游戏中造成中断——一个非常短暂的瞬间，游戏会冻结，这可能会破坏性能。此外，你可以寻找长时间消耗较高的帧序列。尝试减少它们。即使这只是一个临时的解决方案，但玩家很容易就能感知到它的影响，尤其是在 VR 游戏中，因为这可能会引起恶心。

1.  **PlayerLoop** 可能会显示为耗时最长的帧，但这并不很有信息量。你可以通过点击其左侧的箭头进一步探索它。

1.  点击每个函数以在图表中突出显示它。处理时间较长的函数将以较粗的条形显示，我们将重点关注这些函数：

![表格描述自动生成，置信度中等](img/B18585_18_24.png)

图 18.24：图中突出显示的渲染相机功能

1.  你可以继续点击箭头以进一步探索函数，直到达到限制。如果你想深入了解，可以在 Profiler 的顶部栏中启用**深度分析**模式。这将提供更多细节，但请注意，这个过程成本高昂，会使游戏运行变慢，改变图表中显示的时间，使其看起来比实际时间高得多。在这里，忽略数字，根据图表查看函数占用的过程量。你需要停止，启用**深度分析**，然后再次播放以使其工作：

![图形用户界面、文本、应用程序、聊天或短信描述自动生成](img/B18585_18_25.png)

图 18.25：启用深度分析

借助这些知识，我们可以开始提高我们的游戏性能（如果它低于目标帧率），但每个函数都是由 CPU 调用的，并且以它独特的方式得到改进，这需要我们对 Unity 内部工作有更深入的了解。这可能需要几本书的内容，而且无论如何，内部结构会随着版本的不同而变化。相反，你可以通过在网上查找关于该特定系统的数据以及官方文档来研究每个函数的工作原理，或者再次，通过禁用和启用我们的代码或其部分来探索我们行动的影响，就像我们在帧调试器中所做的那样。性能分析需要创造力和推理来解释和相应地反应所获得的数据，因此你需要一些耐心。

既然我们已经讨论了如何获取与 CPU 相关的性能分析数据，那么让我们来讨论一些常见的降低**CPU 使用率**的方法。

## 通用 CPU 优化技术

在 CPU 优化方面，有许多可能导致性能高的原因，包括滥用 Unity 的功能、大量物理或音频对象、不正确的资产/对象配置等。我们的脚本也可以以非优化的方式编写，滥用或误用昂贵的 Unity API 函数。到目前为止，我们已经讨论了使用 Unity 系统的几个良好实践，例如音频配置、纹理大小、批处理，以及将`GameObject.Find`等函数替换为管理器。因此，让我们讨论一些常见情况的具体细节。

让我们从观察大量对象如何影响我们的性能开始。在这里，您只需创建大量带有`Rigidbody`（至少 200 个）的对象，并在**动态配置文件**中配置，然后在剖析器中观察结果。

在下面的屏幕截图中，您会注意到，剖析器的橙色部分变大了，而`Physics.Processing`函数是导致这种增加的原因：

![包含表格的图片描述自动生成](img/B18585_18_26.png)

图 18.26：多个对象的物理处理

请记住，剖析器还有其他可以通过点击**剖析器模块**按钮激活的模块，其中一个用于物理。考虑启用它并检查它提供的信息。还要查看剖析器的官方文档，以获取有关这些模块的更多信息。

另一个测试多个对象影响的方法是创建大量的音频源。在下面的屏幕截图中，您可以看到我们需要重新启用**其他**，因为部分音频处理属于该类别。我们之前提到**其他**属于编辑器，但它也可以包括其他过程，所以请记住这一点：

![图表描述自动生成，置信度低](img/B18585_18_27.png)

图 18.27：多个对象的物理处理

因此，为了发现这类问题，您可以简单地开始禁用和启用对象，看看它们是否增加了时间。最后的测试是在粒子上进行。创建一个系统，生成足够多的粒子以影响我们的帧率，并检查剖析器。

在下面的屏幕截图中，您可以检查粒子处理功能在图表中的高亮显示，显示它需要大量时间：

![时间轴描述自动生成](img/B18585_18_28.png)

图 18.28：粒子处理

然后，在脚本方面，我们还有其他需要考虑的问题，其中一些是所有编程语言和平台共有的，例如迭代长列表的对象、数据结构的误用和深度递归。然而，在本节中，我主要将讨论 Unity 特定的 API，从`print`或`Debug.Log`开始。

这个函数在控制台中获取调试信息很有用，但它也可能很昂贵，因为所有日志都会立即写入磁盘，以避免我们的游戏崩溃时丢失有价值的信息。当然，我们希望保留这些有价值的日志，但又不希望它们影响性能，我们该怎么办呢？

一种可能的方法是保留这些消息，但在最终构建中禁用非必要的消息，例如信息性消息，保持错误报告功能活跃。一种实现方式是通过编译器指令，如下面的截图所示。请记住，这种`if`语句是由编译器执行的，如果条件不满足，可以在编译时排除整个代码段：

![](img/B18585_18_29.png)

图 18.29：禁用代码

在前面的截图中，你可以看到我们正在询问这段代码是否由编辑器编译，或者是为了开发构建而编译，这是一种特殊的构建，旨在用于测试（更多内容将在下一章中介绍）。你还可以使用带有编译器指令的函数创建自己的日志系统，这样你就不需要在想要排除的每个日志中都使用它们。

在本节中，我们了解了 CPU 在处理视频游戏时面临的任务，如何分析它们以查看哪些是不必要的，以及如何减少这些过程的影响。还有一些其他脚本方面会影响性能，不仅是在处理方面，也在内存方面，所以让我们在下一节中讨论它们。

# 优化内存

我们讨论了如何分析并优化两块硬件——CPU 和 GPU，但还有另一块硬件在我们的游戏中扮演着关键角色——RAM。这是我们放置所有游戏数据的地方。游戏可能是内存密集型应用程序，并且与许多其他应用程序不同，它们不断执行代码，因此我们需要特别注意这一点。

在本节中，我们将检查以下内存优化概念：

+   内存分配和垃圾回收

+   使用内存分析器

让我们开始讨论内存分配是如何工作的，以及垃圾回收在这里扮演什么角色。

## 内存分配和垃圾回收

每次我们实例化一个对象时，我们都在 RAM 中分配内存，在游戏中，我们将不断分配内存。在其他编程语言中，除了分配内存外，你还需要手动释放它，但 C#有一个垃圾回收器，这是一个跟踪未使用内存并清理它的系统。这个系统与引用计数器一起工作，它跟踪一个对象存在的引用数量，当这个计数器达到`0`时，这意味着所有引用都已变为 null，对象可以被释放。这个释放过程可以在几种情况下触发，最常见的情况是我们达到分配的最大内存量，并想要分配一个新的对象。在这种情况下，我们可以释放足够的内存来分配我们的对象，如果这不可能，内存就会被扩展。

在任何游戏中，你可能会不断分配和释放内存，这可能导致内存碎片化，意味着在活动对象内存块之间存在小空间，这些空间大部分是无用的，因为它们不够大以分配一个对象，或者也许这些空间的总和足够大，但我们需要连续的内存空间来分配我们的对象。在下面的图中，你可以看到一个经典的例子，即尝试将一大块内存放入由碎片化产生的细小缝隙中：

![图形用户界面 描述由低置信度自动生成](img/B18585_18_30.png)

图 18.30：尝试在碎片化内存空间中实例化一个对象

一些垃圾回收系统类型，例如常规 C#中的系统，是按代进行的，这意味着内存根据其“年龄”被分成代存储桶。较新的内存将被放置在第一个桶中，这种内存往往被频繁地分配和释放。因为这个桶很小，所以在其中工作很快。第二个桶包含在第一个桶中经过先前释放扫描过程的内存。这些内存被移动到第二个桶中，以防止在经过这个过程后不断检查它是否存活，并且这种内存可能持续我们程序的生命周期。第三个桶只是第二个桶的另一层。其想法是，大多数时候，分配和释放系统将在第一个桶中工作，并且由于它足够小，连续分配、释放和压缩内存很快。

这里的问题是 Unity 使用它自己的垃圾回收系统版本，而这个版本是非代际和非压缩的，这意味着内存不会被分成桶，内存也不会被移动来填补空隙。这表明在 Unity 中分配和释放内存仍然会导致碎片化问题，如果你不调节你的内存分配，你可能会频繁执行昂贵的垃圾回收系统，导致我们的游戏出现卡顿，这在**Profiler CPU Usage**模块中可以以浅黄色显示。

处理这个问题的一种方法是在尽可能的情况下防止内存分配，在不必要的时候避免它。这里有一些小调整可以防止内存分配，但在查看这些调整之前，再次强调，在开始修复可能不是问题的东西之前，首先获取关于问题的数据是很重要的。这条建议适用于任何类型的优化过程。在这里，我们仍然可以使用 **CPU Usage** 分析器来查看 CPU 在每一帧中执行每个函数调用分配了多少内存，这很简单，只需查看 **GC Alloc** 列，它表示函数分配的内存量：

![表描述自动生成，置信度中等](img/B18585_18_31.png)

图 18.31：Sight 更新事件函数的内存分配

在前面的截图中，我们可以看到我们的函数分配了过多的内存，这是由于场景中有许多敌人造成的。但这并不是借口；我们每帧都在分配这么多 RAM，因此我们需要改进这一点。有几件事情可能导致我们的内存被分配，让我们先讨论基本的一些，从返回数组的函数开始。

如果我们回顾 `Sight` 脚本代码，我们可以看到我们分配内存的唯一时刻是在调用 `Physics.OverlapSphere`，这是显而易见的，因为它是一个返回数组的函数，这是一个返回可变数量数据的函数。为了做到这一点，它需要分配一个数组并将该数组返回给我们。这需要在创建函数的旁边进行，即 Unity，但在这个案例中，Unity 给我们提供了两个版本的函数——我们正在使用的版本和 `NonAlloc` 版本。通常建议使用第二个版本，但 Unity 使用另一个版本来简化初学者的编码。

`NonAlloc` 版本如下截图所示：

![](img/B18585_18_32.png)

图 18.32：Sight 更新事件函数的内存分配

这个版本要求我们分配一个数组，以保存`OverlapSphere`变量可以找到的最大数量的碰撞器，并将其作为第三个参数传递。这允许我们只分配一次数组，并在需要时重复使用它。在先前的截图中，你可以看到数组是静态的，这意味着它在所有`Sight`变量之间共享，因为它们不会并行执行（没有`Update`函数）。这将正常工作。请注意，该函数将返回检测到的对象数量，所以我们只需迭代这个计数。数组可以存储之前的结果。

现在，检查你的 Profiler，注意内存分配量已经大大减少。在我们的函数中可能还有一些剩余的内存分配，但有时没有方法可以将其保持在`0`。然而，你可以尝试使用深度分析或通过注释一些代码来查看哪些注释可以消除分配。我挑战你尝试这样做。此外，`OverlapSphere`不是唯一可能发生这种情况的情况。你还有其他情况，例如`GetComponents`函数家族，与`GetComponent`不同，它找到给定类型的所有组件，而不仅仅是第一个组件，所以请注意 Unity 中任何返回数组的函数，并尝试用非分配版本替换它，如果有的话。

另一个常见的内存分配来源是字符串连接。记住，字符串是不可变的，这意味着如果你连接两个字符串，它们不会改变。第三个需要生成足够的空间来容纳前两个字符串。如果你需要多次连接，考虑使用`string.Format`，如果你只是在一个模板字符串中替换占位符，例如在消息中放入玩家的名字和得分，或者使用`StringBuilder`，这是一个只将所有要连接的字符串放在列表中的类，在需要时，它会将它们连接在一起，而不是像**+**运算符那样逐个连接。此外，考虑使用 C#的新字符串插值功能。你可以在以下截图中看到一些示例：

![图片](img/B18585_18_33.png)

图 18.33：C#中的字符串管理

最后，一个值得考虑的经典技术是对象池，它适用于需要不断实例化和销毁对象的情况，例如子弹或效果。在这种情况下，使用常规的`Instantiate`和`Destroy`函数会导致内存碎片化，但对象池通过分配尽可能多的所需对象来解决这个问题。它通过从预分配的函数中取一个来替换`Instantiate`，并通过将对象返回到池中来替换`Destroy`。

以下截图显示了简单的池：

![图片](img/B18585_18_34.png)

图 18.34：简单的对象池

有几种方法可以改进这个池，但现在它已经足够好了。请注意，当对象从池中取出时，需要重新初始化它们，你可以通过 `OnEnable` 事件函数或创建一个自定义函数来通知对象这样做。此外，请注意，Unity 最近添加了一个 Object Pool 类，你可以在以下链接中调查：[`docs.unity3d.com/2022.1/Documentation/ScriptReference/Pool.ObjectPool_1.html`](https://docs.unity3d.com/2022.1/Documentation/ScriptReference/Pool.ObjectPool_1.html)，但我仍然建议先自己制作，以掌握池的概念。

现在我们已经探索了一些基本的内存分配减少技术，让我们看看最新版 Unity 中引入的新 **内存分析器** 工具，以更详细地探索内存。

## 使用内存分析器

使用这个分析器，我们可以按帧检测分配的内存，但它不会显示到目前为止分配的总内存，这对于研究我们如何使用内存会有所帮助。这就是 **内存分析器** 可以帮助我们的地方。这个相对较新的 Unity 包允许我们在原生和托管方面对每个分配的对象进行内存快照——原生意味着内部 C++ Unity 代码，托管意味着属于 C# 方面的任何内容（即，我们的代码和 Unity 的 C# 引擎代码）。我们可以使用可视化工具探索快照，并快速看到哪种类型的对象消耗了最多的 RAM 以及它们是如何被其他对象引用的。

要开始使用 **内存分析器**，请执行以下操作：

1.  打开 **包管理器** （**窗口** | **包管理器**）并启用预览包（**轮形图标** | **项目设置** | **启用预发布包**）：

![Graphical user interface, application Description automatically generated](img/B18585_18_35.png)

图 18.35：启用预览包

1.  点击 **+** 按钮，选择 **按名称添加包…**：

![img/B18585_18_36.png]

图 18.36：从 Git URLs 安装包

1.  在对话框中，输入 `com.unity.memoryprofiler` 并点击 **添加**。我们需要以这种方式添加包，因为它仍然是一个实验性的包：

![img/B18585_18_37.png]

图 18.37：安装内存分析器

1.  安装完成后，在 **窗口** | **分析** | **内存分析器** 中打开 **内存分析器**。

1.  玩游戏并点击 **内存分析器** 窗口中的 **捕获** 按钮：

![img/B18585_18_38.png]

图 18.38：捕获快照

1.  点击列表中出现的快照（位于 **会话 1** 标签下方）以查看在捕获快照时的内存消耗摘要：

![img/B18585_18_39.png]

图 18.39：内存摘要

1.  在我们的案例中，我们可以看到我们正在消耗 4.79 GB 的内存，这些内存被分配在**托管堆**（C#代码变量）、**其他原生内存**（Unity 的 C++内存）、**图形与图形驱动程序**、**音频**以及更多。这些类别中包含了不同的事物，但就目前而言，我们做得很好。在包管理器中打开包文档以获取更多关于它们的信息。

1.  点击**内存分析器**窗口中间部分顶部的**树图**按钮。这将打开**树视图**，允许您直观地看到哪些类型的资源在内存方面要求更高：

![](img/B18585_18_40.png)

图 18.40：内存树视图

1.  在我们的案例中，我们可以看到`RenderTexture`消耗了最多的内存，这属于场景中显示的图像以及一些用于后期处理效果的纹理。尝试禁用`PPVolume`对象并再次截图以检测差异。

1.  在我的案例中，这减少了 130 MB。还有其他纹理用于其他效果，例如 HDR。如果您想探索剩余的 MB 来自哪里，请单击**RenderTexture**块将其细分为其对象，并根据纹理的名称进行自己的猜测：

![包含应用程序描述的图片，自动生成](img/B18585_18_41.png)

图 18.41：内存块详细视图

1.  您可以在`Texture2D`块类型中重复相同的操作，这属于我们模型材料中使用的纹理。您可以查看最大的一个并检测其使用情况——可能是一个从未被足够接近地看到以证明其大小的纹理。然后，我们可以使用**纹理最大尺寸**导入设置来减小其大小。

就像任何分析器一样，始终在构建中直接执行分析非常有用（关于这一点将在下一章中详细介绍），因为在编辑器中捕获快照将捕获大量编辑器使用的内存，这些内存在构建中不会被使用。一个例子是加载不必要的纹理，因为编辑器可能是在您点击它们以在**检查器**窗口中查看预览时加载它们的。

请注意，由于**内存分析器**是一个包，其 UI 可能会经常变化，但其基本理念将保持不变。您可以使用此工具检测您是否以意外的方式使用内存。这里值得考虑的一个有用因素是 Unity 在加载场景时如何加载资源，这包括在加载时加载场景中引用的所有资源。这意味着您可以有，例如，一个预制体数组，这些预制体引用了具有引用纹理的材料，即使您没有实例化它们的单个实例，预制体也必须在内存中加载，从而占用空间。在这种情况下，我建议您探索使用`Addressables`，它提供了一种动态加载资源的方法。但现在让我们保持简单。

# 摘要

优化游戏并非易事，尤其是如果你不熟悉每个 Unity 系统的工作原理。遗憾的是，这是一个巨大的任务，没有人知道每个系统及其最细微细节的每一个方面，但通过本章学到的工具，我们有一种方法来探索变化如何通过探索影响系统。我们学习了如何分析 CPU、GPU 和 RAM，以及任何游戏中关键硬件是什么，还介绍了一些常见的良好实践，以避免滥用它们。

现在，你能够诊断游戏中的性能问题，收集关于 CPU、GPU 和 RAM 这三件主要硬件性能的数据，然后使用这些数据来集中优化努力，应用正确的优化技术。性能很重要，因为你的游戏需要流畅运行，以给用户带来愉快的体验。

在下一章中，我们将了解如何创建一个无需安装 Unity 的游戏构建版本，以便与他人分享。这对于性能分析也非常有用，因为性能分析构建版本将比在编辑器中进行性能分析提供更准确的数据。

# 加入我们的 Discord 社区！

与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。

提出问题，为其他读者提供解决方案，通过 Ask Me Anything（AMA）环节与作者聊天，等等。

扫描二维码或访问链接加入社区。

![尼古拉斯二维码](img/Nicolas_QR_Code.png)

[`packt.link/handsonunity22`](https://packt.link/handsonunity22)
