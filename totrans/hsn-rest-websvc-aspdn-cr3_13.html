<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing the RESTful HTTP Layer</h1>
                
            
            
                
<p class="mce-root">In the previous chapter, we learned how to deal with the logic of our web service in the <kbd>Catalog.Domain</kbd> project. This chapter will walk you through the HTTP part of the web service and all the components inside the <kbd>Catalog.API</kbd> project.</p>
<p class="mce-root">We will also demonstrate how to implement and test the controller part of a web service. By the end of the chapter, you will be able to implement, test, and validate HTTP routes using ASP.NET Core. We will cover the following topics:</p>
<ul>
<li>Implementing the HTTP layer of a service</li>
<li>Carrying out tests using the tools provided by ASP.NET Core</li>
<li>Improving the resilience of the HTTP layer</li>
</ul>
<p>The code presented in this chapter is available from the following GitHub repository: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the item controller</h1>
                
            
            
                
<p class="mce-root">This section focuses on building the routes to read, writing the catalog data, and exposing the functionalities we already built in the domain layer using the HTTP protocol. Our controller will include the verbs listed in the following routing table:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Verb</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Path</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/items</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves all the items present in our catalog</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/items/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves the item with the corresponding ID</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>POST</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/items/</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Creates a new item by taking the body payload of the request</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>PUT</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/items/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Updates the item with the corresponding ID</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding routes allow web service consumers to get, add, and update the <kbd>Item</kbd> entities. Before starting the implementation, let's look at an overview of the solution schema that we are going to implement:</p>
<div><img src="img/d956dbc7-7b0d-4763-90fd-f7fa25b3b59f.png" style=""/></div>
<p>In <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml"/><a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer,</em> and <a href="f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml">Chapter 9</a>, <em>Implementing the Domain Logic,</em> we implemented and tested, respectively, the <kbd>Catalog.Infrastructure</kbd> and <kbd>Catalog.Domain</kbd> projects. This chapter focuses on the <kbd>Catalog.API</kbd> project. We are going to build and test the action methods that will call the service layer built in the <kbd>Catalog.Domain</kbd> project. Let's start by defining a new controller in the <kbd>Controllers</kbd> folder of our <kbd>Catalog.API</kbd> project, named <kbd>ItemController</kbd>:</p>
<pre>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    public class ItemController : ControllerBase<br/>    {<br/>    }<br/>}</pre>
<p>The <kbd>ItemController</kbd> class will reflect the routes that we defined earlier. We should note that we decorated the controller class with the <kbd>Route</kbd> and <kbd>ApiController</kbd> attributes: the first specifies the base URL of the controller and the second provides some utilities and conventions on the responses type produced by the action methods. The controller will also use the <kbd>IItemService</kbd> interface to query and write data on our data source. We can use the <kbd>IItemService</kbd> interface to the <kbd>ItemController</kbd> class via the constructor injection:</p>
<pre>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    public class ItemController : ControllerBase<br/>    {<br/>      <strong>  private readonly IItemService _itemService;</strong><br/><br/>        public ItemController(<strong>IItemService itemService</strong>)<br/>        {<br/>           <strong> _itemService = itemService;</strong><br/>        }<br/>    }<br/>}</pre>
<p>The preceding code uses dependency injection to add the <kbd>IItemService</kbd> class as a dependency of the <kbd>ItemController</kbd> class. Once we have added the <kbd>IItemService</kbd> interface, we can proceed by implementing the action methods of the controller.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing action methods</h1>
                
            
            
                
<p>We have already dealt with action methods in <a href="deede298-fc20-4523-afa6-02ed2c0592fd.xhtml">Chapter 5</a>, <em>Web Service Stack in ASP.NET Core</em>. In the following implementation, we will use the <kbd>IItemService</kbd> interface in the action methods, as follows<em>:</em></p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    public class ItemController : ControllerBase<br/>    {<br/>        private readonly IItemService _itemService;<br/><br/>        public ItemController(IItemService itemService)<br/>        {<br/>            _itemService = itemService;<br/>        }<br/>        [HttpGet]<br/>       <strong> public async Task&lt;IActionResult&gt; Get()</strong><br/>        {<br/>            var result = await _itemService.GetItemsAsync();<br/>            return Ok(result);<br/>        }<br/><br/>        [HttpGet("{id:guid}")]<br/>        <strong>public async Task&lt;IActionResult&gt; GetById(Guid id)</strong><br/>        {<br/>            var result = await _itemService.GetItemAsync(new GetItemRequest <br/>             { Id = id });<br/>            return Ok(result);<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>Get</kbd> and <kbd>GetById</kbd> action methods perform read operations by referring to the <kbd>IItemService</kbd> interface and calling the <kbd>GetItemsAsync</kbd> and <kbd>GetItemAsync</kbd> methods of the underlying service layer, in this case the <kbd>IItemService</kbd> interface. Let's proceed by using the same approach to implement the <kbd>Post</kbd> and <kbd>Put</kbd> action methods of the controller:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    public class ItemController : ControllerBase<br/>    {<br/>        ...<br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; Post(AddItemRequest request)<br/>        {<br/>            var result = await _itemService.AddItemAsync(request);<br/>            return CreatedAtAction(nameof(GetById), new { id = result.Id }, <br/>             null);<br/>        }<br/><br/>        [HttpPut("{id:guid}")]<br/>        public async Task&lt;IActionResult&gt; Put(Guid id, EditItemRequest <br/>         request)<br/>        {<br/>            request.Id = id;<br/>            var result = await _itemService.EditItemAsync(request);<br/><br/>            return Ok(result);<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>Post</kbd> and <kbd>Put</kbd> actions use <kbd>AddItemRequest</kbd> and <kbd>EditItemRequest</kbd>, respectively, to bind data from the HTTP request and pass it through the <kbd>IItemService</kbd> interface. Under the hood, the <kbd>IItemService</kbd> implementation refers to <kbd>IItemMapper</kbd> to get back an entity from the request type and send it through the <kbd>IItemRepository</kbd> implementation. With the help of the dependency injection, we can easily loose couple the dependency between the different components. We should also note that the <kbd>Post</kbd> action method uses the <kbd>CreatedAtAction()</kbd> method exposed by <kbd>ControllerBase</kbd> to retrieve the location of the created resource as part of the response. Once we have bound the <kbd>IItemService</kbd> APIs into the <kbd>ItemController</kbd> action method, we can continue by testing the implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing controllers using the WebApplicationFactory&lt;T&gt; class</h1>
                
            
            
                
<p>The ASP.NET Core Framework provides a way to perform <em>integration tests</em> using the <kbd>WebApplicationFactory&lt;T&gt;</kbd> class. This class allows us to create a new <kbd>TestServer</kbd> that emulates a real HTTP server in a separate process. Therefore, it is possible to test our <kbd>ItemController</kbd> by calling it through an <kbd>HttpClient</kbd> instance provided by the factory. It is essential to note that <kbd>WebApplicationFactory</kbd> is a generic class and that it accepts a <kbd>TEntryPoint</kbd> type, which is represented by the <kbd>Startup</kbd> class of our web service. Before proceeding with the implementation of the test class, let's create a new project in the <kbd>tests</kbd> folder that will contain all tests related to the <kbd>Catalog.API</kbd> project. Therefore, we can execute the following commands inside the <kbd>tests</kbd> folder:</p>
<pre><strong>dotnet new xunit -n Catalog.API.Tests<br/>cd Catalog.API.Tests<br/></strong><strong>dotnet add reference ../Catalog.Fixtures<br/>dotnet add reference ../../src/Catalog.API<br/>dotnet sln ../../Catalog.API.sln add .</strong></pre>
<p>The preceding commands add a new <kbd>Catalog.API.Tests</kbd> project into the <kbd>tests</kbd> folder of the solution, which refers to the <kbd>Catalog.Fixtures</kbd> and <kbd>Catalog.API</kbd> projects. The project is included in the solution file of the project. The next section describes how to extend the <kbd>WebApplicationFactory</kbd> class in order to support the execution of the web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the WebApplicationFactory</h1>
                
            
            
                
<p>The <kbd>WebApplicationFactory</kbd> class exposes set properties and methods that are useful for configuring the instance of the <kbd>TestServer</kbd> and for creating the proper tests fixture for our controllers. In addition, it is possible to extend <kbd>WebApplicationFactory</kbd> by overriding the <kbd>ConfigureWebHost</kbd> method and substituting the behavior of the <em>dependency injection services</em> declared in the original <kbd>Startup</kbd> class of the <kbd>Catalog.API</kbd> project. The <kbd>WebApplicationFactory</kbd> class is part of the <kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> package; therefore, it is necessary to add the NuGet package to the <kbd>Catalog.Fixture</kbd> project and to the Catalog.API.Tests project by running the following commands in the tests folder of the project:</p>
<pre><strong>dotnet add Catalog.Fixtures package Microsoft.AspNetCore.Mvc.Testing<br/>dotnet add Catalog.API.Tests package Microsoft.AspNetCore.Mvc.Testing</strong></pre>
<p>Let's proceed by creating a new <kbd>InMemoryWebApplicationFactory</kbd> class inside the <kbd>Catalog.Fixtures</kbd> project. The class will be used by the test classes to instantiate a new <kbd>TestServer</kbd> object. Therefore, the next step is to create a new <kbd>InMemoryWebApplicationFactory</kbd> class that extends the <kbd>WebApplicationFactory</kbd> base class and overrides the <kbd>ConfigureWebHost</kbd> method to inject the custom <em>in</em>-<em>memory</em> database provider:</p>
<pre>using System;<br/>using Catalog.Infrastructure;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Mvc.Testing;<br/>using Microsoft.AspNetCore.TestHost;<br/>using Microsoft.EntityFrameworkCore;<br/>using Microsoft.Extensions.DependencyInjection;<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class InMemoryApplicationFactory&lt;TStartup&gt;<br/>        : <strong>WebApplicationFactory&lt;TStartup&gt; where TStartup : class</strong><br/>    {<br/>        protected override void ConfigureWebHost(IWebHostBuilder builder)<br/>        {<br/>            builder<br/>                .UseEnvironment("Testing")<br/>                .ConfigureTestServices(services =&gt;<br/>                {<br/>                    var options = new <br/>                     DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                       <strong> .UseInMemoryDatabase(Guid.NewGuid().ToString())</strong><br/>                        .Options;<br/><br/>                   <strong> services.AddScoped&lt;CatalogContext&gt;(serviceProvider =&gt; <br/>                     new TestCatalogContext(options));</strong><br/><strong>                    </strong><br/>                    var sp = services.BuildServiceProvider();<br/><br/>                    using var scope = sp.CreateScope();<br/>                    <br/>                    var scopedServices = scope.ServiceProvider;<br/>                    var db = scopedServices.GetRequiredService<br/>                     &lt;CatalogContext&gt;();<br/>                    db.Database.EnsureCreated();<br/>                });<br/>        }<br/>    }<br/>}</pre>
<p>The preceding <kbd>InMemoryApplicationFactory</kbd> class implements the <kbd>ConfigureWebHost</kbd> method, and it initializes an in-memory database using the <kbd>UseInMemoryDatabase</kbd> extension method. It also inserts a new instance of the <kbd>TestCatalogContext</kbd> class in the <kbd>CatalogContext</kbd> service registered using the dependency injection. Therefore, the tests will use the same in-memory database infrastructure we already used for the test cases implemented in the <kbd>Catalog.Infrastructure.Tests</kbd> and <kbd>Catalog.Domain.Tests</kbd> projects.</p>
<p>Additionally, the <kbd>InMemoryApplicationFactory</kbd> implementation creates a new scope that will be used to execute the <kbd>EnsureCreated</kbd> method. Thus, each new instance of <kbd>InMemoryApplicationFactory</kbd> will generate the database from the same snapshot of data.</p>
<p>Finally, the entire implementation is executed in the context of the <kbd>ConfigureTestServices</kbd> method, which provides a way to override the dependency injection services defined in the <kbd>Startup</kbd> class of the <kbd>Catalog.API</kbd> project.</p>
<p>As mentioned in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, the in-memory database is not always the preferred alternative, for two reasons. First, it doesn't reflect a real relational database with real constraints on the data. Secondly, it is tricky to deal with in-memory databases when multiple test methods use the same instance, since they may generate inconsistent data. For this reason, we are creating a new instance, using the <kbd>UseInMemoryDatabase(Guid.NewGuid().ToString());</kbd> statement, for each test class. The <kbd>Guid.NewGuid()</kbd> instruction guarantees uniqueness between the instances. In real-world applications, another common approach is to create a new instance of a temporary data source and recreate it after each test.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing a controller</h1>
                
            
            
                
<p>Once we have implemented the <kbd>InMemoryApplicationFactory</kbd> class, it is possible to utilize it by implementing the <kbd>IClassFixture</kbd> interface in our test classes. Therefore, let's start by initializing a new <kbd>ItemControllerTests</kbd> class in the <kbd>Catalog.API.Tests</kbd> project:</p>
<pre>using System.Net.Http;<br/>using System.Text;<br/>using System.Threading.Tasks;<br/>using Newtonsoft.Json;<br/>using Shouldly;<br/>using Catalog.Domain.Infrastructure.Entities;<br/>using Catalog.Fixtures;<br/>using Xunit;<br/><br/>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class ItemControllerTests : <strong>IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;</strong><br/>    {<br/>        private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;<br/>        public ItemControllerTests(InMemoryApplicationFactory&lt;Startup&gt; <br/>         factory)<br/>        {<br/>           <strong> _factory = factory;</strong><br/>        }<br/>        ....<br/>    }<br/>}</pre>
<p>The <kbd>ItemControllerTests</kbd> class provides remarkable test coverage for the action methods. First of all, the test class implements the generic <kbd>IClassFixture</kbd> interface provided by the <kbd>xUnit.Sdk</kbd> package. The <kbd>IClassFixture</kbd> interface refers to the previously defined <kbd>InMemoryApplicationFactory&lt;Startup&gt;</kbd> and it injects the new instance of the <kbd>factory</kbd> class into the constructor of the test classes. Consequently, a new instance of the <kbd>factory</kbd> will be provided for each test class executed.</p>
<p>Let's take a look at the test methods that cover the get operation of <kbd>ItemController</kbd>:</p>
<pre>..<br/>[Theory]<br/>[InlineData("/api/items/")]<br/>public async Task <strong>get_should_return_success(string url)</strong><br/><br/>{<br/>    var client = _factory.CreateClient();<br/>    var response = await client.GetAsync(url);<br/><br/>    response.EnsureSuccessStatusCode();<br/>}<br/><br/>[Fact]<br/><strong>public async Task get_by_id_should_return_item_data()</strong><br/>{<br/>    const string id = "86bff4f7-05a7-46b6-ba73-d43e2c45840f";<br/>    var client = _factory.CreateClient();<br/>    var response = await client.GetAsync($"/api/items/{id}");<br/><br/>    response.EnsureSuccessStatusCode();<br/>    var responseContent = await response.Content.ReadAsStringAsync();<br/>    var responseEntity = JsonConvert.<br/>     DeserializeObject&lt;Item&gt;(responseContent);<br/><br/>    responseEntity.ShouldNotBeNull();<br/>}</pre>
<p>The preceding implementation uses the <kbd>CreateClient</kbd> method provided by <kbd>InMemoryApplicationFactory&lt;Startup&gt;</kbd> to initialize a new <kbd>HttpClient</kbd> instance. Therefore, if we take the <kbd>get_by_id_should_return_item_data</kbd> method as an example, it uses the client to call the <kbd>/api/items/{id}</kbd> route and checks that the information returned is not <kbd>null</kbd>. We can proceed by testing the add item operation by adding the following test methods to the <kbd>ItemControllerTests</kbd> class:</p>
<pre>[Fact]<br/>public async Task add_should_create_new_record()<br/>{<br/>    var request = new AddItemRequest<br/>    {<br/>        Name = "Test album",<br/>        Description = "Description",<br/>        LabelName = "Label name",<br/>        Price = new Price { Amount = 13, Currency = "EUR" },<br/>        PictureUri = "https://mycdn.com/pictures/32423423",<br/>        ReleaseDate = DateTimeOffset.Now,<br/>        AvailableStock = 6,<br/>        GenreId = new Guid("c04f05c0-f6ad-44d1-a400-3375bfb5dfd6"),<br/>        ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-3b0473c7cdab")<br/>    };<br/><br/>    var client = _factory.CreateClient();<br/><br/>    var httpContent = new StringContent(JsonConvert.SerializeObject(request), Encoding.UTF8, "application/json");<br/>    var response = await client.PostAsync($"/api/items", httpContent);<br/><br/>    response.EnsureSuccessStatusCode();<br/>    response.Headers.Location.ShouldNotBeNull();<br/>}</pre>
<p class="mce-root">Consequently, we can choose a similar approach for the <kbd>Put</kbd> action method implemented in the controller:</p>
<pre>[Fact]<br/>public async Task update_should_modify_existing_item()<br/>{<br/>    var client = _factory.CreateClient();<br/><br/>    var request = new EditItemRequest<br/>    {<br/>        Id = new Guid("b5b05534-9263-448c-a69e-0bbd8b3eb90e"),<br/>        Name = "Test album",<br/>        Description = "Description updated",<br/>        LabelName = "Label name",<br/>        Price = new Price { Amount = 50, Currency = "EUR" },<br/>        PictureUri = "https://mycdn.com/pictures/32423423",<br/>        ReleaseDate = DateTimeOffset.Now,<br/>        AvailableStock = 6,<br/>        GenreId = new Guid("c04f05c0-f6ad-44d1-a400-3375bfb5dfd6"),<br/>        ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-3b0473c7cdab")<br/>    };<br/><br/>    var httpContent = new StringContent(JsonConvert.SerializeObject(request), Encoding.UTF8, "application/json");<br/>    var response = await client.PutAsync($"/api/items/{request.Id}", httpContent);<br/><br/>    response.EnsureSuccessStatusCode();<br/><br/>    var responseContent = await response.Content.ReadAsStringAsync();<br/>    var responseEntity = JsonConvert.DeserializeObject&lt;Item&gt;(responseContent);<br/><br/>    responseEntity.Name.ShouldBe(request.Name);<br/>    responseEntity.Description.ShouldBe(request.Description);<br/>    responseEntity.GenreId.ShouldBe(request.GenreId);<br/>    responseEntity.ArtistId.ShouldBe(request.ArtistId);<br/>}</pre>
<p>The <kbd>add_should_create_new_record</kbd> test method and the <kbd>update_should_modify_existing_item</kbd> method adopt the corresponding approach to test the <kbd>Post</kbd> and <kbd>Put</kbd> requests and the corresponding action methods. In this case, we are using the same request objects we defined for the <kbd>ItemServiceTests</kbd> and <kbd>ItemRepositoryTests</kbd> classes.</p>
<p>We can proceed by executing the previously implemented tests by running the <kbd>dotnet test</kbd> command in the solution folder, or by using the test runner of our preferred IDE. Later in this next subsection, we will look at how to optimize the initialization of the request and hold the test data at a unique point.</p>
<p>Using <kbd>IClassFixture</kbd> implies that the same <kbd>InMemoryApplicationFactory</kbd> instance will be shared by all the test methods. Therefore, we will have the same underlying data for every test method. If we want to keep the tests fully isolated, we can avoid the use of the class fixture and initialize a new <kbd>InMemoryApplicationFactory</kbd> instance in the constructor of the test class: 
<pre> public class ItemControllerTests<br/>    {<br/>        private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;<br/><br/>        public ItemControllerTests()<br/>        {<br/>           <strong> _factory = new InMemoryApplicationFactory&lt;Startup&gt;();</strong><br/>        }<br/>        ....<br/>    }</pre>
This approach also guarantees isolation between every single test method implemented in the test class. Furthermore, the constructor will provide a new instance every time.</p>
<p>Next, let's have a look at how to load test data using xUnit data attributes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading test data using xUnit data attributes</h1>
                
            
            
                
<p>The <em>xUnit</em> framework is the preferred choice for testing .NET applications and services. The framework also provides some utilities to extend its capabilities and to implement a more maintainable testing code. It is possible to extend the <kbd>DataAttribute</kbd> class exposed by the <kbd>xUnit.Sdk</kbd> namespace to perform custom operations inside our attributes. For example, let's suppose that we create a new custom <kbd>DataAttribute</kbd> to load test data from a file, as follows:</p>
<pre><br/>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class ItemControllerTests : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>       ...<br/><br/>        [Theory]<br/>        <strong>[LoadData( "item")]</strong><br/>        public async Task get_by_id_should_return_right_data(<strong>Item request</strong>)<br/>        {<br/>            var client = _factory.CreateClient();<br/>            var response = await client.GetAsync($"/api/items/{request.Id}");<br/><br/>            response.EnsureSuccessStatusCode();<br/><br/>            var responseContent = <br/>             await response.Content.ReadAsStringAsync();<br/>            var responseEntity = JsonConvert.DeserializeObject<br/>             &lt;ItemResponse&gt;(responseContent);<br/><br/>            responseEntity.Name.ShouldBe(request.Name);<br/>            responseEntity.Description.ShouldBe(request.Description);<br/>            responseEntity.Price.Amount.ShouldBe(request.Price.Amount);<br/>            responseEntity.Price.Currency.ShouldBe(request.Price.Currency);<br/>            responseEntity.Format.ShouldBe(request.Format);<br/>            responseEntity.PictureUri.ShouldBe(request.PictureUri);<br/>            responseEntity.GenreId.ShouldBe(request.GenreId);<br/>            responseEntity.ArtistId.ShouldBe(request.ArtistId);<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>In this scenario, the implementation decorates the test method using the <kbd>LoadData</kbd> attribute, which is reading an <kbd>item</kbd> section from a file. Therefore, we will have a JSON file that contains all the test records, and we will use the <kbd>LoadData</kbd> attribute to load one of them. To customize the behavior for the <kbd>ItemControllerTests</kbd> class, we should create a new class and extend the <kbd>DataAttribute</kbd> class provided by xUnit:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.IO;<br/>using System.Linq;<br/>using System.Reflection;<br/>using Newtonsoft.Json;<br/>using Newtonsoft.Json.Linq;<br/>using Xunit.Sdk;<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class LoadDataAttribute : DataAttribute<br/>    {<br/>        private readonly string _fileName;<br/>        private readonly string _section;<br/>        public LoadDataAttribute(string section)<br/>        {<br/>            <strong>_fileName = "record-data.json";</strong><br/>            _section = section;<br/>        }<br/>       <strong> public override IEnumerable&lt;object[]&gt; GetData(MethodInfo testMethod)</strong><br/>        {<br/>            if (testMethod == null) throw new ArgumentNullException(nameof(testMethod));<br/><br/>            var path = Path.IsPathRooted(_fileName)<br/>                ? _fileName<br/>                : Path.GetRelativePath(Directory.GetCurrentDirectory(), _fileName);<br/><br/>            if (!File.Exists(path)) throw new ArgumentException<br/>             ($"File not found: {path}");<br/><br/>            var fileData = File.ReadAllText(_fileName);<br/><br/>            if (string.IsNullOrEmpty(_section)) return <br/>             JsonConvert.DeserializeObject&lt;List&lt;string[]&gt;&gt;(fileData);<br/><br/>            var allData = JObject.Parse(fileData);<br/>            var data = allData[_section];<br/>            return new List&lt;object[]&gt; { new[] {              <br/>             data.ToObject(<strong>testMethod.GetParameters()<br/>             .First().ParameterType</strong>) } };<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>LoadDataAttribute</kbd> class overrides <kbd>GetData(MethodInfo testMethod);</kbd>, which is supplied by the <kbd>DataAttribute</kbd> class, and it returns the data utilized by the test methods. The implementation of the <kbd>GetData</kbd> method reads the content of the file defined by the <kbd>_filePath</kbd> attribute; it tries to serialize the content of the specified <kbd>section</kbd> of the file into a generic <kbd>object</kbd>. Finally, the implementation calls the <kbd>ToObject</kbd> method to convert the generic <kbd>JObject</kbd> into the type associated with the first parameter of the test method. The last step in the process is to create a new JSON file called <kbd>record-data.json</kbd> in the <kbd>Catalog.API.Tests</kbd> project. The file will contain the test data used by our tests:</p>
<pre>{<br/>  "item": {<br/>    "Id": "86bff4f7-05a7-46b6-ba73-d43e2c45840f",<br/>    "Name": "DAMN.",<br/>    "Description": "DAMN. by Kendrick Lamar",<br/>    "LabelName": "TDE, Top Dawg Entertainment",<br/>    "Price": {<br/>      "Amount": 34.5,<br/>      "Currency": "EUR"<br/>    },<br/>    "PictureUri": "https://mycdn.com/pictures/45345345",<br/>    "ReleaseDate": "2017-01-01T00:00:00+00:00",<br/>    "Format": "Vinyl 33g",<br/>    "AvailableStock": 5,<br/>    "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>    "Genre": null,<br/>    "ArtistId": "3eb00b42-a9f0-4012-841d-70ebf3ab7474",<br/>    "Artist": null<br/>  },<br/>  "genre": {<br/>    "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>    "GenreDescription": "Hip-Hop"<br/>  },<br/>  "artist": {<br/>    "ArtistId": "f08a333d-30db-4dd1-b8ba-3b0473c7cdab",<br/>    "ArtistName": "Anderson Paak."<br/>  }<br/>}</pre>
<p>The JSON snippet has the following fields: <kbd>item</kbd>, <kbd>artist</kbd>, and <kbd>genre</kbd>. The fields contain data related to the test entities. Therefore, we will use them to deserialize the data into the request models and into the entity types. Consequently, we can apply the <kbd>LoadData</kbd> attribute to the <kbd>ItemControllerTests</kbd> class in the following way: </p>
<pre>using System;<br/>using System.Net;<br/>using System.Net.Http;<br/>using System.Text;<br/>using System.Threading.Tasks;<br/>using Newtonsoft.Json;<br/>using Shouldly;<br/>using Catalog.Domain.Infrastructure.Entities;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Fixtures;<br/>using Xunit;<br/><br/>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class ItemControllerTests : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>        ...<br/>        <br/>        [Theory]<br/>      <strong>  [LoadData("item")]</strong><br/>        public async Task get_by_id_should_return_right_data(<strong>Item request</strong>){...}<br/> <br/>        [Theory]<br/>      <strong>  [LoadData("item")]</strong><br/>        public async Task add_should_create_new_item(<strong>AddItemRequest request</strong>){...}<br/>        <br/>        [Theory]<br/>       <strong> [LoadTestData("item")]</strong><br/>        public async Task update_should_modify_existing_item(<strong>EditItemRequest request</strong>){...}<br/>       <br/>    }<br/>}</pre>
<p>Now, the test methods accept a <kbd>request</kbd> parameter of the <kbd>Item</kbd>, <kbd>EditItemRequest</kbd>, or <kbd>AddItemRequest</kbd> type, which will contain the data provided by the <kbd>record-data.json</kbd> file. Then, the object is serialized into the <kbd>request</kbd> parameter and sent using the <kbd>HttpClient</kbd> instance supplied by the <kbd>InMemoryApplicationFactory</kbd>:</p>
<pre>[Theory]<br/><strong>[LoadData( "item")]</strong><br/>public async Task add_should_create_new_record(<strong>AddItemRequest request</strong>)<br/>{<br/>    var client = _factory.CreateClient();<br/><br/>    var httpContent = new StringContent(<strong>JsonConvert.SerializeObject(request)</strong>, Encoding.UTF8, "application/json");<br/>   <strong> var response = await client.PostAsync($"/api/items", httpContent);</strong><br/><br/><strong>    response.EnsureSuccessStatusCode();</strong><br/><strong>    response.Headers.Location.ShouldNotBeNull();</strong><br/>}<br/></pre>
<p><kbd>LoadData</kbd> serializes the content defined in the <kbd>record-data.json</kbd> file into the <kbd>AddItemRequest</kbd> type. The request is then serialized as <kbd>StringContent</kbd> and posted using the HTTP client created by the factory. Finally, the method asserts that the resultant code is successful and the <kbd>Location</kbd> header is not <kbd>null</kbd>. </p>
<p>We can now verify the behavior of the <kbd>ItemController</kbd> class by executing the <kbd>dotnet test</kbd> command in the root of the solution, or by running the test runner provided by our preferred IDE.</p>
<p>In conclusion, now we are able to define the test data in a unique central JSON file. In addition to this, we can add as much data as we want by adding new sections to the JSON file. The next part of this section will focus on improving the resilience of the APIs by adding some existence checks and handling exceptions using filters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving the resilience of the API </h1>
                
            
            
                
<p>The previous sections show a possible implementation of <kbd>ItemController</kbd> class and how to test it using the tools provided by ASP.NET Core. In this section, we will learn how to improve the resilience of our service by performing some <em>restriction checks</em> on the information exposed by the <kbd>ItemController</kbd>. Additionally, we will look at how to present validation errors and how to paginate returned data. This section will apply the concepts explained in the previous chapters to the web service project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Existence check</h1>
                
            
            
                
<p>Let's start by implementing the action filter that performs an existence check on the requested data. The filter will be used by the action methods that get or edit a single item. As seen in <a href="13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml">Chapter 7</a>, <em>Filter Pipeline</em>, we are going to implement the following filter:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/><br/>namespace Catalog.API.Filters<br/>{<br/>    public class ItemExistsAttribute : TypeFilterAttribute<br/>    {<br/>        public ItemExistsAttribute() : base(typeof<br/>            (ItemExistsFilterImpl))<br/>        {<br/>        }<br/><br/>        public class ItemExistsFilterImpl : IAsyncActionFilter<br/>        {<br/>            <strong>private readonly IItemService _itemService;</strong><br/><br/>            public ItemExistsFilterImpl(IItemService itemService)<br/>            {<br/>                _itemService = itemService;<br/>            }<br/><br/>            public async Task OnActionExecutionAsync(ActionExecutingContext context,<br/>                ActionExecutionDelegate next)<br/>            {<br/>                if (!(context.ActionArguments["id"] is Guid id))<br/>                {<br/>                    context.Result = new BadRequestResult();<br/>                    return;<br/>                }<br/><br/>              <strong>  var result = await _itemService.GetItemAsync(new GetItemRequest { Id = id });</strong><br/><br/>                if (result == null)<br/>                {<br/>                    <strong>context.Result = new NotFoundObjectResult($"Item with id {id} not exist.");</strong><br/>                    return;<br/>                }<br/><br/>                await next();<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The action filter resolves the <kbd>IItemService</kbd> interface in the constructor and uses the injected instance to verify the existence of the entity using the <kbd>id</kbd> present in the request. If the request contains a valid <kbd>Guid id</kbd>, and the <kbd>id</kbd> exists in our data source, the <kbd>OnActionExecutionAsync</kbd> method proceeds by calling the <kbd>await next()</kbd> method to continue the pipeline. Otherwise, it stops the pipeline and returns a <kbd>NotFoundObjectResult</kbd> instance. We can apply a filter to the action methods of <kbd>ItemController</kbd> by adding the <kbd>[ItemExists]</kbd> attribute:</p>
<pre><strong>using Catalog.API.Filters;</strong><br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    public class ItemController : ControllerBase<br/>    {<br/>        ...<br/><br/>        [HttpGet("{id:guid}")]<br/>       <strong> [ItemExists]</strong><br/>        public async Task&lt;IActionResult&gt; GetById(Guid id)<br/>        {<br/>           ...<br/>        }<br/>    <br/>        [HttpPut("{id:guid}")]<br/>       <strong> [ItemExists]</strong><br/>        public async Task&lt;IActionResult&gt; Put(Guid id, EditItemCommand request)<br/>        {<br/>          ...<br/>        }<br/>    }<br/>}</pre>
<p>After applying the <kbd>ItemExists</kbd> attribute, the API will return 404 if the ID sent by the request doesn't exist. We can also verify the logic implemented in the action filter by injecting a mock instance of the <kbd>IItemService</kbd> interface and making some assertions about the resulting response. In the following test class, we will use <kbd>Moq</kbd> to verify the call to the <kbd>next()</kbd> method. As a first step, we need to add <kbd>Moq</kbd> to the <kbd>Catalog.API.Tests</kbd> project by using the following command inside the project folder:</p>
<pre>dotnet add package Moq</pre>
<p>Furthermore, we can proceed by defining the <kbd>ItemExistsAttributeTests</kbd> class:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Catalog.API.Filters;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Responses;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Http;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Abstractions;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/>using Microsoft.AspNetCore.Routing;<br/>using Moq;<br/>using Xunit;<br/><br/>namespace Catalog.API.Tests.Filters<br/>{<br/>    public class ItemExistsAttributeTests<br/>    {<br/>        [Fact]<br/>       <strong> public async Task should_continue_pipeline_when_id_is_present()</strong><br/>        {<br/>            var id = Guid.NewGuid();<br/>            var itemService = new Mock&lt;IItemService&gt;();<br/><br/>            itemService<br/>                .Setup(x =&gt; x.GetItemAsync(It.IsAny&lt;GetItemRequest&gt;()))<br/>                .ReturnsAsync(new ItemResponse { Id = id });<br/><br/>            var filter = new ItemExistsAttribute.ItemExistsFilterImpl(itemService.Object);<br/><br/>            var actionExecutedContext = new ActionExecutingContext(<br/>                new ActionContext(new DefaultHttpContext(), new RouteData(), new ActionDescriptor()),<br/>                new List&lt;IFilterMetadata&gt;(),<br/>                new Dictionary&lt;string, object&gt;<br/>                {<br/>                    {"id", id}<br/>                }, new object());<br/><br/>            var nextCallback = new Mock&lt;ActionExecutionDelegate&gt;();<br/>            <br/>            await filter.OnActionExecutionAsync(actionExecutedContext, nextCallback.Object);<br/><br/>          <strong>  nextCallback.Verify(executionDelegate =&gt; executionDelegate(), Times.Once);</strong><br/>        }<br/>    }<br/>}</pre>
<p>The preceding <kbd>ItemExistsAttributeTests</kbd> class mocks the whole <kbd>IItemService</kbd> interface to simulate the response of the <kbd>GetItemAsync</kbd> method. Then, it initializes <kbd>ItemExistsAttribute</kbd> by injecting the mocked <kbd>IItemService</kbd> interface. Finally, it calls the <kbd>OnActionExecutionAsync</kbd> method exposed by the <kbd>filter</kbd> class and it combines the result with the <kbd>Verify</kbd> method provided by the <kbd>Moq</kbd> framework to check that the <kbd>ItemExistsFilter</kbd> class correctly calls the <kbd>next()</kbd> callback method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JSON-customized errors</h1>
                
            
            
                
<p>The customization and serialization of the exceptions is a helpful way to simplify <em>error handling</em> and improve the monitoring of the web service<em>.</em> These techniques are sometimes necessary for communicating exceptions to a client so that errors can be handled and managed. In general, while the <em>HTTP status code </em>provides summary information about the status of the request, the content of the response provides more detailed information about the error.</p>
<p>It is possible to extend the error handling behavior using filters. First of all, let's create a new standard model that represents an error result:</p>
<pre>namespace Catalog.API.Exceptions<br/>{<br/>    public class JsonErrorPayload<br/>    {<br/>        public int EventId { get; set; }<br/>        public object DetailedMessage { get; set; }<br/>    }<br/>}</pre>
<p>The preceding class is under the <kbd>Filters</kbd> folder structure. It contains an <kbd>EventId</kbd> attribute and a <kbd>DetailedMessage</kbd> of an <kbd>object</kbd> type. Secondly, we should continue by implementing a new filter that extends the <kbd>IExceptionFilter</kbd> interface. The filter will be triggered when an exception is raised, and it will modify the content of the response returned to the client:</p>
<pre>using System.Net;<br/>using Catalog.API.Exceptions;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/>using Microsoft.Extensions.Hosting;<br/>using Microsoft.Extensions.Logging;<br/><br/>namespace Catalog.API.Filters<br/>{<br/>    public class JsonExceptionAttribute : TypeFilterAttribute<br/>    {<br/>        public JsonExceptionAttribute() : base(typeof(HttpCustomExceptionFilterImpl))<br/>        {<br/>        }<br/><br/>        <strong>private class HttpCustomExceptionFilterImpl : </strong><strong>IExceptionFilter</strong><br/>        {<br/>            private readonly IWebHostEnvironment _env;<br/>            private readonly ILogger&lt;HttpCustomExceptionFilterImpl&gt; _logger;<br/><br/>            public HttpCustomExceptionFilterImpl(IWebHostEnvironment env,<br/>                ILogger&lt;HttpCustomExceptionFilterImpl&gt; logger)<br/>            {<br/>                _env = env;<br/>                _logger = logger;<br/>            }<br/><br/>            public void OnException(ExceptionContext context)<br/>            {<br/>                var eventId = new EventId(context.Exception.HResult);<br/><br/>                _logger.LogError(eventId,<br/>                    context.Exception,<br/>                    context.Exception.Message);<br/><br/>                var json = new JsonErrorPayload { EventId = eventId.Id };<br/><br/>                if (_env.IsDevelopment())<br/>                {<br/>                    json.DetailedMessage = context.Exception;<br/>                }<br/><br/>                var exceptionObject = new ObjectResult(json) { StatusCode = 500 };<br/><br/>                context.Result = exceptionObject;<br/>                context.HttpContext.Response.StatusCode = (int) HttpStatusCode.InternalServerError;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code implements the <kbd>IExceptionFilter</kbd> interface. The class contains the definition of the constructor used to inject some of the dependencies of the filter. It also contains the <kbd>OnException</kbd> method, which initializes a new <kbd>JsonErrorPayload</kbd> object populated with the <kbd>eventId</kbd> field and the content of the message contained in the exception. Depending on the environment, take a look at the <kbd>IsDevelopment()</kbd> check; it also populates the resulting exception object with a detailed error message. Finally, the <kbd>OnException</kbd> method uses the <kbd>HttpContext</kbd>, defined as a parameter, to set the <kbd>HttpStatusCode.InternalServerError</kbd>, and to add <kbd>exceptionObject</kbd> previously created as a result of the execution. This approach guarantees to handle exception in a unique way, by centralizing the serialization and the resulting message format of all the errors returned by the web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing pagination</h1>
                
            
            
                
<p>Pagination is another essential feature of APIs. <kbd>Get</kbd> operations usually return a significant number of records and information. Sometimes, it is necessary to implement pagination to avoid a large response size.</p>
<p>If your APIs are exposed to external clients, it is essential to reduce the response size when possible. Additionally, it could be that the client stores information in the memory of a device, such as a smartphone or an IoT device, that has limited memory.</p>
<p>Let's take a look at how to implement maintainable and reusable pagination in the <kbd>ItemController</kbd> class. First of all, we need to create a new pagination response model that represents the requested page. We can create a new <kbd>PaginatedItemResponseModel.cs</kbd> file in the <kbd>ResponseModels</kbd> folder inside the <kbd>Catalog.API</kbd> project, using the following content:</p>
<pre>using System.Collections.Generic;<br/><br/>namespace Catalog.API.ResponseModels<br/>{<br/>    public class PaginatedItemsResponseModel&lt;TEntity&gt; where TEntity : class<br/>    {<br/>        public PaginatedItemsResponseModel(int pageIndex, int pageSize, long total, IEnumerable&lt;TEntity&gt; data)<br/>        {<br/>            PageIndex = pageIndex;<br/>            PageSize = pageSize;<br/>            Total = total;<br/>            Data = data;<br/>        }<br/><br/>        public int PageIndex { get; }<br/>        public int PageSize { get; }<br/>        public long Total { get; }<br/>        public IEnumerable&lt;TEntity&gt; Data { get; }<br/>    }<br/>}</pre>
<p>The <kbd>PaginatedItemsResponseModel</kbd> function accepts a generic model, and it represents a paginated response type. It also implements some properties related to the page, such as <kbd>PageIndex</kbd>, <kbd>PageSize</kbd>, and <kbd>Total</kbd>. Additionally, it includes an <kbd>IEnumerable</kbd> interface that represents the records returned by the response. The next step is to change the <kbd>Get</kbd> action method that is already present in the <kbd>ItemController</kbd> class, as shown here:</p>
<pre><strong>using Catalog.API.ResponseModels;</strong><br/>...<br/>    <br/>    public class ItemController : ControllerBase<br/>    {<br/>        ...<br/><br/>        [HttpGet]<br/>        public async Task&lt;IActionResult&gt; Get(<strong>int pageSize = 10, int pageIndex = 0</strong>)<br/>        {<br/>            var result = await _itemService.GetItemsAsync();<br/><br/>            var totalItems = result.Count();<br/><br/>            var itemsOnPage = result<br/>                .OrderBy(c =&gt; c.Name)<br/>                .Skip(pageSize * pageIndex)<br/>                .Take(pageSize);<br/><br/>           <strong> var model = new PaginatedItemsResponseModel&lt;ItemResponse&gt;(</strong><br/><strong>                pageIndex, pageSize, totalItems, itemsOnPage);</strong><br/><br/>            return Ok(model);<br/>        }<br/>        ...<br/>    }<br/>}</pre>
<p>We changed the <kbd>Get</kbd> action method to implement pagination. First of all, note that the method receives some parameters related to pagination: the <kbd>pageSize</kbd> and <kbd>pageIndex</kbd> parameters. Secondly, it executes <kbd>IItemService</kbd> to get the related records and performs a LINQ query to take only the elements of the selected page. Finally, it instantiates a new <kbd>PaginatedItemsResponseModel&lt;ItemResponse&gt;</kbd> with the metadata related to the page and the data, and returns the instance.</p>
<p>We can cover the implementation using the unit tests by changing the already existing <kbd>ItemsControllerTests</kbd> file:</p>
<pre><strong>using Catalog.API.ResponseModels;</strong><br/>...<br/>    <br/>    public class ItemControllerTests : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>    <br/>        ...<br/><br/>        [Theory]<br/>        <strong>[InlineData("/api/items/?pageSize=1&amp;pageIndex=0", 1,0)]</strong><br/><strong>        [InlineData("/api/items/?pageSize=2&amp;pageIndex=0", 2,0)]</strong><br/><strong>        [InlineData("/api/items/?pageSize=1&amp;pageIndex=1", 1,1)]</strong><br/>        public async Task get_should_return_paginated_data(string url, int pageSize, int pageIndex)<br/><br/>        {<br/>            var client = _factory.CreateClient();<br/>            var response = await client.GetAsync(url);<br/><br/>                response.EnsureSuccessStatusCode();<br/><br/>            <strong>var responseContent = await response.Content.ReadAsStringAsync();</strong><br/><strong>            var responseEntity = JsonConvert.DeserializeObject&lt;PaginatedItemsResponseModel&lt;ItemResponse&gt;&gt;(responseContent);</strong><br/><br/><strong>            responseEntity.PageIndex.ShouldBe(pageIndex);</strong><br/><strong>            responseEntity.PageSize.ShouldBe(pageSize);</strong><br/><strong>            responseEntity.Data.Count().ShouldBe(pageSize);</strong><br/>        }<br/>       ...<br/>    }<br/>} </pre>
<p>The <kbd>should_get_item_using_pagination</kbd> test case uses the <kbd>InlineData</kbd> attribute to test some pagination routes. It calls the <kbd>Get</kbd> action method, serializes the result into a <kbd>PaginatedItemsResponseModel&lt;ItemResponse&gt;</kbd>, and, finally, it checks the results. </p>
<p>Although the pagination implementation technique examined in this chapter provides some performance benefits, it doesn't limit the interaction between our service and the database. To extend the performance benefits to the data source of the service as well, we should consider implementing an ad-hoc query to paginate data directly from our data source.</p>
<p>In the next section, we will continue our journey by extending the APIs in order to also handle related entities. For now, notice that we are exposing the information of the <kbd>Item</kbd>, <kbd>Artist</kbd>, and <kbd>Genre</kbd> entities, without managing the related entities and we are not exposing any route to edit the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exposing related entities </h1>
                
            
            
                
<p>At the moment, the current implementation in the <kbd>Catalog.API</kbd> project allows us to read, and modify the <kbd>Item</kbd> entity and its relationship with the <kbd>Genre</kbd> and <kbd>Artist</kbd> entities. In this section, we will enable a client to list and add the <kbd>Genre</kbd> and <kbd>Artist</kbd> entities. Therefore, we will extend the APIs that allow a client to interact with these entities. This implementation requires us to act on the full stack of the web service; additionally, it involves the <kbd>Catalog.Infrastructure</kbd>, the <kbd>Catalog.Domain</kbd>, and the  <kbd>Catalog.API</kbd> projects. Before we begin, let's take a look at the routes we are going to implement:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Verb</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Path</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artists</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves all the artists present in the database</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves the artist with the corresponding ID</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist/{id}/items/</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves the items with the corresponding artist ID</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>POST</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist/</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Creates a new artist and retrieves it</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In the same way, we will get the corresponding routes for the <kbd>Genre</kbd> entity as well:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Verb</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Path</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/genre</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves all the genres present in the database</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/genre/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves the genre with the corresponding ID</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/genre/{id}/items/</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Retrieves the items with the corresponding genre ID</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>POST</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/genre/</kbd></td>
<td class="CDPAlignCenter CDPAlign">
<p class="mce-root">Creates a new genre and retrieves it</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The routes mentioned in the previous tables provide a way to interact with the <kbd>Genre</kbd> and <kbd>Artist</kbd> entities. The implementation of these features will follow the same approach used by the item entity we have seen in the previous sections.  Before proceeding, we need to extend the <kbd>CatalogContext</kbd> class by adding the attributes that represent the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities:</p>
<pre>...<br/>public class CatalogContext : DbContext, IUnitOfWork<br/>{<br/>  <br/>    public DbSet&lt;Item&gt; Items { get; set; }<br/> <strong>   public DbSet&lt;Artist&gt; Artists { get; set; }</strong><br/><strong>    public DbSet&lt;Genre&gt; Genres { get; set; }</strong><br/><br/>    protected override void OnModelCreating(ModelBuilder modelBuilder)<br/>    {<br/>        modelBuilder.ApplyConfiguration(new ItemEntitySchemaDefinition());<br/><strong>        modelBuilder.ApplyConfiguration(new ArtistEntitySchemaConfiguration());</strong><br/><strong>        modelBuilder.ApplyConfiguration(new GenreEntitySchemaConfiguration());<br/>        <br/>        base.OnModelCreating(modelBuilder);</strong>   <br/>    }<br/>..</pre>
<p>Now <kbd>CatalogContext</kbd> also handles the <kbd>Artists</kbd> and <kbd>Genres</kbd> entities through the use of the <kbd>modelBuilder.ApplyConfiguration</kbd> method. In the next subsection, we will extend the implementation of the data access layer through the use of the <kbd>Repositories</kbd> classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the data access layer</h1>
                
            
            
                
<p>In order to extend our APIs with the related entities, we should start from the bottom of our stack. First of all, let's spread the capabilities of the data access layer by adding the following interfaces in the <kbd>Repositories</kbd> folder of the <kbd>Catalog.Domain</kbd> project:</p>
<pre><strong>// Repositories/IArtistsRepository.cs</strong><br/><br/>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Domain.Repositories<br/>{<br/>    public interface IArtistRepository : IRepository<br/>    {<br/>        Task&lt;IEnumerable&lt;Artist&gt;&gt; GetAsync();<br/>        Task&lt;Artist&gt; GetAsync(Guid id);<br/>        Artist Add(Artist item);<br/>    }<br/>}<br/><br/><strong>// Repositories/IGenreRepository.cs<br/><br/></strong>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Domain.Infrastructure.Repositories<br/>{<br/>    public interface IGenreRepository : IRepository<br/>    {<br/>        Task&lt;IEnumerable&lt;Genre&gt;&gt; GetAsync();<br/>        Task&lt;Genre&gt; GetAsync(Guid id);<br/>        Genre Add(Genre item);<br/>    }<br/>}</pre>
<p>Both the <kbd>IArtistRepository</kbd> and <kbd>IGenreRepository</kbd> interfaces reflect the routes initially defined in this section: the <kbd>GetAsync</kbd> method returns the list of the secondary entities, the <kbd>GetAsync(Guid id)</kbd> returns the single object, and the <kbd>Add</kbd> method allows us to create a new entity. We can now define the actual implementations of the specified interfaces. Likewise, the <kbd>ItemRepository</kbd> class implementations will be stored in the <kbd>Catalog.Infrastructure</kbd> project: </p>
<pre><strong>//Repositories/ArtistRepository.cs<br/><br/></strong>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Microsoft.EntityFrameworkCore;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/><br/>namespace Catalog.Infrastructure.Repositories<br/>{<br/>    public class ArtistRepository : IArtistRepository<br/>    {<br/>        private readonly CatalogContext _catalogContext;<br/>        public IUnitOfWork UnitOfWork =&gt; _catalogContext;<br/><br/>        public ArtistRepository(CatalogContext catalogContext)<br/>        {<br/>            _catalogContext = catalogContext;<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;Artist&gt;&gt; GetAsync()<br/>        {<br/>            return await _catalogContext.Artist<br/>                .AsNoTracking()<br/>                .ToListAsync();<br/>        }<br/><br/>        public async Task&lt;Artist&gt; GetAsync(Guid id)<br/>        {<br/>            var artist = await _catalogContext.Artist<br/>                .FindAsync(id);<br/><br/>            if (artist == null) return null;<br/><br/>            _catalogContext.Entry(artist).State = EntityState.Detached;<br/>            return artist;<br/>        }<br/><br/>        public Artist Add(Artist artist)<br/>        {<br/>            return _catalogContext.Artist.Add(artist).Entity;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code defines the <kbd>ArtistRepository</kbd> type and provides the implementation for the <kbd>IArtistRepository</kbd> interface. The class uses <kbd>CatalogContext</kbd> as a communication hub between our application and the SQL database. The <kbd>GetAsync</kbd> and <kbd>GetAsync(Guid id)</kbd> methods use the same pattern already implemented in the <kbd>ItemRepository</kbd> class to retrieve the information related to the required entities. Furthermore, the <kbd>Add</kbd> method refers to the <kbd>Artists</kbd> field exposed by <kbd>CatalogContext</kbd> to add a new artist. It is important to note that, in this case, the <kbd>Add</kbd> operation doesn't update the data source directly. </p>
<p>Let's proceed by defining the <kbd>GenreRepository</kbd> class:<br/></p>
<pre><strong>//Repositories/GenreRepository.cs<br/><br/></strong>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Microsoft.EntityFrameworkCore;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/><br/>namespace Catalog.Infrastructure.Repositories<br/>{<br/>    public class GenreRepository : IGenreRepository<br/>    {<br/>        private readonly CatalogContext _catalogContext;<br/>        public IUnitOfWork UnitOfWork =&gt; _catalogContext;<br/><br/>        <br/>        public GenreRepository(CatalogContext catalogContext)<br/>        {<br/>            _catalogContext = catalogContext;<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;Genre&gt;&gt; GetAsync()<br/>        {<br/>            return await _catalogContext.Genre<br/>                .AsNoTracking()<br/>                .ToListAsync();<br/>        }<br/><br/>        public async Task&lt;Genre&gt; GetAsync(Guid id)<br/>        {<br/>            var item = await _catalogContext.Genre<br/>                .FindAsync(id);<br/><br/>            if (item == null) return null;<br/><br/>            _catalogContext.Entry(item).State = EntityState.Detached;<br/>            return item;<br/>        }<br/><br/>        public Genre Add(Genre item)<br/>        {<br/>            return _catalogContext.Genre.Add(item).Entity;<br/>        }<br/>    }<br/>}</pre>
<p>In the same way as <kbd>ArtistRepository</kbd>, we are implementing the operations for querying and manipulating the <kbd>Genre</kbd> entities. Although the names of the methods and the implementations are quite similar, I have chosen to keep the repository interfaces separated and redefine each implementation separately. A quicker approach would be to create a generic class that represents the typical behavior of <kbd>ItemRepository</kbd>, <kbd>ArtistRepository</kbd>, and <kbd>GenreRepository</kbd>, but the generic repositories are not always the right choice. In addition to this, building the wrong abstraction is a lot more expensive than duplicating code, and building a unique generic repository for everything means tight coupling the entities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the test coverage </h1>
                
            
            
                
<p>As we did with the <kbd>ItemRepositoryTests</kbd> class, we can proceed by testing <kbd>ArtistRepository</kbd> and <kbd>GenreRepository</kbd> using the same approach. In <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, we defined <kbd>TestDataContextFactory</kbd>, which is part of the <kbd>Catalog.Fixtures</kbd> project. We can use this to instantiate an in-memory database for our test purposes:</p>
<pre>using System;<br/>using System.Linq;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Fixtures;<br/>using Catalog.Infrastructure.Repositories;<br/>using Shouldly;<br/>using Xunit;<br/><br/>namespace Catalog.Infrastructure.Tests<br/>{<br/>    public class ArtistRepositoryTests :<br/>        IClassFixture&lt;CatalogContextFactory&gt;<br/>    {<br/>        private readonly CatalogContextFactory _factory;<br/><br/>        public ArtistRepositoryTests(CatalogContextFactory factory)<br/>        {<br/>            _factory = factory;<br/>        }<br/><br/>        [Theory]<br/>        [LoadData("artist")]<br/>        public async Task should_return_record_by_id(Artist artist)<br/>        {<br/>            var sut = new ArtistRepository(_factory.ContextInstance);<br/>            var result = await sut.GetAsync(artist.ArtistId);<br/><br/>            result.ArtistId.ShouldBe(artist.ArtistId);<br/>            result.ArtistName.ShouldBe(artist.ArtistName);<br/>        }<br/><br/>        [Theory]<br/>        [LoadData("artist")]<br/>        public async Task should_add_new_item(Artist artist)<br/>        {<br/>            artist.ArtistId = Guid.NewGuid();<br/>            var sut = new ArtistRepository(_factory.ContextInstance);<br/><br/>            sut.Add(artist);<br/>            await sut.UnitOfWork.SaveEntitiesAsync();<br/><br/>            _factory.ContextInstance.Artist<br/>                .FirstOrDefault(x =&gt; x.ArtistId == artist.ArtistId)<br/>                .ShouldNotBeNull();<br/>        }<br/>    }<br/>}</pre>
<p>The previous code explores a way to implement the tests for the <kbd>ArtistRepository</kbd> class. The <kbd>ArtistRepositoryTests</kbd> class extends <kbd>IClassFixture&lt;CatalogContextFactory&gt;</kbd> to retrieve an instance of the <kbd>CatalogContextFactory</kbd> type. The test methods use the <kbd>ContextInstance</kbd> attribute to retrieve a new catalog context and to initialize a new repository.</p>
<p>They proceed by executing the method as a test and checking the results. It is important to notice that every test method uses the <kbd>LoadData</kbd> attribute in order to load the <kbd>artist</kbd> section of the <kbd>record-data.json</kbd> file. For brevity, I've omitted some of the test cases; however, the concept behind them is identical to what we have already seen, and it can be extended to the <kbd>GenreRepository</kbd> tests. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the IItemRepository interface</h1>
                
            
            
                
<p>Another step we can take to extend our web service project with the related entities is to implement two new methods to retrieve the items related to an artist or a genre in the <kbd>IItemRepository</kbd> interface: the <kbd>GetItemsByArtistIdAsync</kbd> and <kbd>GetItemsByGenreIdAsync</kbd> methods. Both of these methods can be used by the <kbd>GET /api/artists/{id}/items</kbd> and <kbd>GET /api/genre/{id}/items</kbd> routes to retrieve the items.</p>
<p>Let's proceed by adding the following methods to the <kbd>IItemsRepository</kbd> interface and implementing them in the corresponding implementation:</p>
<pre><strong>    //Repositories/IItemRepository.cs</strong><br/>    public interface <strong>IItemRepository </strong>: IRepository<br/>    {<br/>        ...<br/>       <strong> Task&lt;IEnumerable&lt;Item&gt;&gt; GetItemByArtistIdAsync(Guid id);</strong><br/><strong>        Task&lt;IEnumerable&lt;Item&gt;&gt; GetItemByGenreIdAsync(Guid id);</strong><br/>        ...<br/>    }<br/><br/><strong>    //Repositories/ItemRepository.cs</strong><br/>    public class ItemRepository<br/>        : IItemRepository<br/>    {<br/>        ...<br/>       <strong> public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetItemByArtistIdAsync(Guid id)</strong><br/><strong>        {</strong><br/><strong>            var items = await _context</strong><br/><strong>                .Items</strong><br/><strong>                .Where(item =&gt; item.ArtistId == id)</strong><br/><strong>                .Include(x =&gt; x.Genre)</strong><br/><strong>                .Include(x =&gt; x.Artist)</strong><br/><strong>                .ToListAsync();</strong><br/><br/><strong>            return items;</strong><br/><strong>        }</strong><br/><br/><strong>        public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetItemByGenreIdAsync(Guid id)</strong><br/><strong>        {</strong><br/><strong>            var items = await _context.Items</strong><br/><strong>                .Where(item =&gt; item.GenreId == id)</strong><br/><strong>                .Include(x =&gt; x.Genre)</strong><br/><strong>                .Include(x =&gt; x.Artist)</strong><br/><strong>                .ToListAsync();</strong><br/><br/><strong>            return items;</strong><br/><strong>        }</strong><br/>       ...<br/>    }<br/>}</pre>
<p>This code extends the <kbd>IItemRepository</kbd> interface and its implementation in order to include the functionalities to query the items using <kbd>ArtistId</kbd> and <kbd>GenreId</kbd>. Both methods retrieve data using the <kbd>Where</kbd> clause and by calling the <kbd>Include</kbd> statement to include the related entities in the result of the query. Once we have fully extended the repository layer, we can continue by also extending the service classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the capabilities of the service layer</h1>
                
            
            
                
<p>The new <kbd>Catalog.Infrastructure</kbd> functionalities extend the <kbd>Catalog.Domain</kbd> project and expose <kbd>IArtistRepository</kbd> and <kbd>IGenreRepository</kbd> to the controllers of the API project. First of all, we should create a couple of new service classes in the <kbd>Catalog.Domain</kbd> project in order to query the underlying <kbd>Catalog.Infrastructure</kbd> layer. Let's start by defining the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> interfaces in the <kbd>Services</kbd> folder of the <kbd>Catalog.Domain</kbd> project:</p>
<pre>using System.Collections.Generic;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Requests.Artists;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public interface IArtistService<br/>    {<br/>        Task&lt;IEnumerable&lt;ArtistResponse&gt;&gt; GetArtistsAsync();<br/>        Task&lt;ArtistResponse&gt; GetArtistAsync(GetArtistRequest request);<br/>        Task&lt;IEnumerable&lt;ItemResponse&gt;&gt; GetItemByArtistIdAsync(GetArtistRequest request);<br/>        Task&lt;ArtistResponse&gt; AddArtistAsync(AddArtistRequest request);<br/>    }<br/><br/>    public interface IGenreService<br/>    {<br/>        Task&lt;IEnumerable&lt;GenreResponse&gt;&gt; GetGenreAsync();<br/>        Task&lt;GenreResponse&gt; GetGenreAsync(GetGenreRequest request);<br/>        Task&lt;IEnumerable&lt;ItemResponse&gt;&gt; GetItemByGenreIdAsync(GetGenreRequest request);<br/>        Task&lt;GenreResponse&gt; AddGenreAsync(AddGenreRequest request);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding code snippet contains the declarations of the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> interfaces. For brevity, I've kept them in the same code snippet. Both interfaces define the methods in the lists, get the details, and then add a related entity. The <kbd>GetArtistsAsync()</kbd> and <kbd>GetGenreAsync()</kbd> methods can return the complete list of entities or a single entity, depending on whether the <kbd>request</kbd> parameter is specified or not. Additionally, it is possible to retrieve a list of <kbd>ItemResponse</kbd> by artist ID or genre ID using the <kbd>GetItemByArtistIdAsync</kbd> and <kbd>GetItemByGenreIdAsync</kbd> methods. Finally, we can add a new artist and genre using the <kbd>AddArtistAsync</kbd> and <kbd>AddGenreAsync</kbd> methods. </p>
<p>The preceding implementation also depends on the definition of the following request models:</p>
<pre>namespace Catalog.Domain.Requests.Artists<br/>{<br/>    public class AddArtistRequest<br/>    {<br/>        public string ArtistName { get; set; }<br/>    }<br/>    <br/>    public class GetArtistRequest<br/>    {<br/>        public Guid Id { get; set; }<br/>    }<br/>}<br/><br/>namespace Catalog.Domain.Requests.Genre<br/>{<br/>    public class AddGenreRequest<br/>    {<br/>        public string GenreDescription { get; set; }<br/>    }<br/>    <br/>    public class GetGenreRequest<br/>    {<br/>        public Guid Id { get; set; }<br/>    }<br/>}</pre>
<p>Here, the request classes define the allowed operation for the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities. They are stored in the <kbd>Requests/Artist</kbd> and <kbd>Requests/Genre</kbd> folders, respectively. We can continue by implementing the concrete part of the <kbd>ArtistService</kbd> class, as follows:</p>
<div><pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Mappers;<br/>using Catalog.Domain.Repositories;<br/>using Catalog.Domain.Requests.Artists;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public class ArtistService : IArtistService<br/>    {<br/>        private readonly IArtistRepository _artistRepository;<br/>        private readonly IItemRepository _itemRepository;<br/>        private readonly IArtistMapper _artistMapper;<br/>        private readonly IItemMapper _itemMapper;<br/><br/>        public ArtistService(IArtistRepository artistRepository, IItemRepository itemRepository,<br/>            IArtistMapper artistMapper, IItemMapper itemMapper)<br/>        {<br/>            _artistRepository = artistRepository;<br/>            _itemRepository = itemRepository;<br/>            _artistMapper = artistMapper;<br/>            _itemMapper = itemMapper;<br/>        }<br/>        ...<br/>    }<br/>}</pre></div>
<p class="mce-root">The preceding code defines the properties and the constructor of the <kbd>ArtistService</kbd> class. The implementation injects the <kbd>IArtistRepository</kbd>, <kbd>IItemRepository</kbd>, <kbd>IArtistMapper</kbd>, and <kbd>IItemMapper</kbd> dependencies. The <kbd>Repositories</kbd> classes will be used for communicating with the underlying data source of the application. On the other side, the mappers will be called to initialize and map the values sent as responses.</p>
<p class="mce-root">Once we have defined the dependencies of the <kbd>ArtistService</kbd> class, we can proceed with the implementation of the core methods:</p>
<pre>    public class ArtistService : IArtistService<br/>    {<br/>        ...<br/><br/>        public async Task&lt;IEnumerable&lt;ArtistResponse&gt;&gt; GetArtistsAsync()<br/>        {<br/>            var result = await _artistRepository.GetAsync();<br/><br/>            return result.Select(_artistMapper.Map);<br/>        }<br/><br/>        public async Task&lt;ArtistResponse&gt; GetArtistAsync(GetArtistRequest<br/>            request)<br/>        {<br/>            if (request?.Id == null) throw new ArgumentNullException();<br/><br/>            var result = await _artistRepository.GetAsync(request.Id);<br/><br/>            return result == null ? null : _artistMapper.Map(result);<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;ItemResponse&gt;&gt; GetItemByArtistIdAsync(GetArtistRequest request)<br/>        {<br/>            if (request?.Id == null) throw new ArgumentNullException();<br/><br/>            var result = await _itemRepository.GetItemByArtistIdAsync(request.Id);<br/><br/>            return result.Select(_itemMapper.Map);<br/>        }<br/><br/>        public async Task&lt;ArtistResponse&gt; AddArtistAsync(AddArtistRequest request)<br/>        {<br/>            var item = new Entities.Artist {ArtistName = request.ArtistName};<br/><br/>            var result = _artistRepository.Add(item);<br/><br/>            await _artistRepository.UnitOfWork.SaveChangesAsync();<br/><br/>            return _artistMapper.Map(result);<br/>        }<br/>    }</pre>
<p class="mce-root">The implementation represents the methods already defined in the <kbd>IArtistService</kbd> interface. It is quite easy to understand the purpose of the methods by looking at<br/>
their signatures.</p>
<p class="mce-root">The <kbd>GetAsync</kbd> method invokes the <kbd>IArtistRepository</kbd> dependency to map and retrieve the result in an <kbd>ArtistResponse</kbd> object. <kbd>GetItemByArtistIdAsync</kbd> executes the corresponding method with the same name defined in the <kbd>IItemRepository</kbd> interface. Finally, <kbd>AddArtistAsync</kbd> executes the <kbd>Add</kbd> method defined in the <kbd>IArtistRepository</kbd> interface and executes the <kbd>UnitOfWork.SaveChangesAsync</kbd> method to apply the changes to the data source, and then map the resulting data.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The same approach can be taken by the <kbd>GenreService</kbd> implementation class, which will depend on the <kbd>IGenreRepository</kbd> and <kbd>IGenreMapper</kbd> interfaces.</p>
<p>You can find the implementation of the <kbd>GenreService</kbd> class in the official GitHub repository of the book: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>
<p>Finally, we should also remember to include the definition of these interfaces in the <kbd>AddServices</kbd> extension method defined in the previous chapter, by incorporating the following changes:</p>
<pre>using Catalog.Domain.Mappers;<br/>using Catalog.Domain.Services;<br/>using Microsoft.Extensions.DependencyInjection;<br/><br/>namespace Catalog.Domain.Extensions<br/>{<br/>    public static class DependenciesRegistration<br/>    {<br/>        ...<br/><br/>        public static IServiceCollection AddServices(this IServiceCollection services)<br/>        {<br/>            services<br/>                .AddScoped&lt;IItemService, ItemService&gt;()<br/>               <strong> .AddScoped&lt;IArtistService, ArtistService&gt;()</strong><br/><strong>                .AddScoped&lt;IGenreService, GenreService&gt;();</strong><br/>            return services;<br/>        }<br/>    }<br/>}</pre>
<p>These changes register the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> interfaces in order to be used by the controllers and the other dependencies of the application. In the next section, we will continue the implementation by adding some validation logic to the request models. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving the validation mechanism</h1>
                
            
            
                
<p>As we explained in the previous chapter, we are using the <kbd>FluentValidation</kbd> package to implement the validation mechanism of the web service. Since we have built the service interfaces to handle the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities, it is now possible to improve the validation checks already present in the <kbd>AddItemRequestValidator</kbd> and <kbd>EditItemRequestValidator</kbd> classes. Now, we are going to implement the existence check for the <kbd>Artist</kbd>- and <kbd>Genre</kbd>-related entities.</p>
<p>Let's start by extending the implementation of the <kbd>AddItemRequestValidator</kbd> class:</p>
<pre>using System;<br/>using FluentValidation;<br/><strong>using System.Threading.Tasks;</strong><br/><strong>using Catalog.Domain.Requests.Artists;</strong><br/><strong>using Catalog.Domain.Requests.Genre;</strong><br/><strong>using Catalog.Domain.Services;</strong><br/><br/>namespace Catalog.Domain.Requests.Item.Validators<br/>{<br/>   <strong> public class AddItemRequestValidator : AbstractValidator&lt;AddItemRequest&gt;</strong><br/>    {<br/>       <strong> private readonly IArtistService _artistService;</strong><br/><strong>        private readonly IGenreService _genreService;</strong><br/><br/><strong>        public AddItemRequestValidator(IArtistService artistService, IGenreService genreService)</strong><br/><strong>        {</strong><br/><strong>            _artistService = artistService;</strong><br/><strong>            _genreService = genreService;</strong><br/><strong>        }</strong><br/>        <br/>       private async Task&lt;bool&gt; ArtistExists(Guid artistId, CancellationToken cancellationToken)<br/>        {<br/>            if (string.IsNullOrEmpty(artistId.ToString()))<br/>                return false;<br/><br/>            var artist = await _artistService.GetArtistAsync(new GetArtistRequest {Id = artistId});<br/><br/>            return artist != null;<br/>        }<br/><br/>        private async Task&lt;bool&gt; GenreExists(Guid genreId, CancellationToken cancellationToken)<br/>        {<br/>            if (string.IsNullOrEmpty(genreId.ToString()))<br/>                return false;<br/><br/>            var genre = await _genreService.GetGenreAsync(new GetGenreRequest {Id = genreId});<br/><br/>            return genre != null;<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>AddItemRequestValidator</kbd> class now injects the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> interfaces using the constructor injection pattern. In addition to this, the validation class defines two methods, <kbd>ArtistExists</kbd> and <kbd>GenreExists</kbd>, which will be used to verify that the <kbd>ArtistId</kbd> and <kbd>GenreId</kbd> fields exist in the database by calling the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> interface methods. Moreover, we can improve the validation rules by checking the existence of the related entities in the following way:</p>
<pre>using System;<br/>...<br/><br/>namespace Catalog.Domain.Item.Validators<br/>{<br/>    public class AddItemRequestValidator : AbstractValidator&lt;AddItemRequest&gt;<br/>    {<br/>         ..<br/>        public AddItemRequestValidator(IArtistService artistService, IGenreService genreService)<br/>        {<br/>            _artistService = artistService;<br/>            _genreService = genreService;<br/>           <strong> RuleFor(x =&gt; x.ArtistId)</strong><br/><strong>                .NotEmpty()</strong><br/><strong>                .MustAsync(ArtistExists).WithMessage("Artist must exists");</strong><br/><strong>            RuleFor(x =&gt; x.GenreId)</strong><br/><strong>                .NotEmpty()</strong><br/><strong>                .MustAsync(GenreExists).WithMessage("Genre must exists");</strong><br/>           ...<br/>        }<br/>...</pre>
<p>The new rules bind the <kbd>ArtistId</kbd> and <kbd>GenreId</kbd> fields with the <kbd>ArtistExists</kbd> and <kbd>GenreExists</kbd> methods, respectively. The same approach can be taken for the <kbd>EditItemRequestValidator</kbd> implementation, which will use the same pattern to validate the related entities. Therefore, we now need to extend the test classes in order to verify the new validation rules:</p>
<pre>...<br/><strong>using FluentValidation.TestHelper;</strong><br/><strong>using Moq;</strong><br/><br/>namespace Catalog.Domain.Tests.Requests.Item.Validators<br/>{<br/>    public class AddItemRequestValidatorTests<br/>    {<br/>        private readonly Mock&lt;IArtistService&gt; _artistServiceMock;<br/>        private readonly Mock&lt;IGenreService&gt; _genreServiceMock;<br/>        private readonly AddItemRequestValidator _validator;<br/><br/>        public AddItemRequestValidatorTests()<br/>        {<br/>            _artistServiceMock = new Mock&lt;IArtistService&gt;();<br/>            _artistServiceMock<br/>                .Setup(x =&gt; x.GetArtistAsync(It.IsAny&lt;GetArtistRequest&gt;()))<br/>                .ReturnsAsync(() =&gt; new ArtistResponse());<br/><br/>            _genreServiceMock = new Mock&lt;IGenreService&gt;();<br/>            _genreServiceMock<br/>                .Setup(x =&gt; x.GetGenreAsync(It.IsAny&lt;GetGenreRequest&gt;()))<br/>                .ReturnsAsync(() =&gt; new GenreResponse());<br/><br/>            _validator = new AddItemRequestValidator(_artistServiceMock.Object, _genreServiceMock.Object);<br/>        }<br/>        <br/>        [Fact]<br/>        <strong>public void should_have_error_when_ArtistId_doesnt_exist()</strong><br/>        {<br/>            _artistServiceMock<br/>                .Setup(x =&gt; x.GetArtistAsync(It.IsAny&lt;GetArtistRequest&gt;()))<br/>                .ReturnsAsync(() =&gt; null);<br/><br/>            var addItemRequest = new AddItemRequest { Price = new Price(), ArtistId = Guid.NewGuid() };<br/><br/>            _validator.ShouldHaveValidationErrorFor(x =&gt; x.ArtistId, addItemRequest);<br/>        }<br/><br/>        [Fact]<br/>        <strong>public void should_have_error_when_GenreId_doesnt_exist()</strong><br/>        {<br/>            _genreServiceMock<br/>                .Setup(x =&gt; x.GetGenreAsync(It.IsAny&lt;GetGenreRequest&gt;()))<br/>                .ReturnsAsync(() =&gt; null);<br/><br/>            var addItemRequest = new AddItemRequest { Price = new Price(), GenreId = Guid.NewGuid() };<br/><br/>            _validator.ShouldHaveValidationErrorFor(x =&gt; x.GenreId, addItemRequest);<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code injects the <kbd>Mock&lt;IArtistService&gt;</kbd> and <kbd>Mock&lt;IGenreService&gt;</kbd> types into the validator class constructor in order to mock the behavior of the service layer and verify the logic of the validator class. It also uses the <kbd>ShouldHaveValidationErrorFor</kbd> method to check the expected response. The <kbd>ArtistExists</kbd> and <kbd>GenreExists</kbd> methods should throw a validation error in case the ID of one of the related entities is missing from the data source. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the dependencies in the Startup class</h1>
                
            
            
                
<p>In the previous few sections, we created the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> interfaces, and their corresponding implementations. Therefore, we want to update the dependency graph of the application. Although we have already called the <kbd>AddMappers</kbd> and <kbd>AddServices</kbd> extension methods of the <kbd>DependenciesRegistration</kbd> static class in the <kbd>ConfigureService</kbd> method, we need to update the dependencies in the following way:</p>
<pre>    public static class DependenciesRegistration<br/>    {<br/>        ...<br/><br/>        public static IServiceCollection AddServices(this IServiceCollection services)<br/>        {<br/>            services<br/>                .AddScoped&lt;IItemService, ItemService&gt;()<br/>               <strong> .AddScoped&lt;IArtistService, ArtistService&gt;()</strong><br/><strong>                .AddScoped&lt;IGenreService, GenreService&gt;();</strong><br/><br/>            return services;<br/>        }<br/>    }</pre>
<p>We should also add <kbd>IArtistRepository</kbd> and <kbd>IGenreRepository</kbd> to the <kbd>ConfigureService</kbd> method:</p>
<pre>...<br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services<br/>         ...<br/>        .AddScoped&lt;IItemRepository, ItemRepository&gt;()<br/><strong>        .AddScoped&lt;IArtistRepository, ArtistRepository&gt;()</strong><br/><strong>        .AddScoped&lt;IGenreRepository, GenreRepository&gt;()</strong><br/>        ....<br/>}</pre>
<p>Now, the <kbd>ConfigureServices</kbd> method of the <kbd>Startup</kbd> class defines all the required dependencies used by our stack. We are currently able to resolve the dependency chain related to the <kbd>ArtistController</kbd> and <kbd>GenreController</kbd> classes, which we will define in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the related controllers</h1>
                
            
            
                
<p>The <kbd>Catalog.Domain</kbd> project is now capable of handling requests related to the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities through the logic we implemented in the <kbd>IArtistService</kbd> and <kbd>IGenreService</kbd> classes. Therefore, we can proceed by creating the controller layer to handle the incoming HTTP requests. Since we have different separate entities, we are going to implement the <kbd>ArtistController</kbd> and <kbd>GenreController</kbd> controller classes. Let's first focus on <kbd>ArtistController</kbd>:</p>
<pre>using Catalog.API.Filters;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/artist")]<br/>    [ApiController]<br/>    [JsonException]<br/>    public class ArtistController : ControllerBase<br/>    {<br/>        private readonly IArtistService _artistService;<br/><br/>        public ArtistController(IArtistService artistService)<br/>        {<br/>            _artistService = artistService;<br/>        }<br/>    }<br/>}</pre>
<p>The above code defines the initial signature of the <kbd>ArtistController</kbd> class: the implementation injects the <kbd>IArtistService</kbd> interface from the service layer in order to interact with the information stored in the database. We can proceed further, by defining the implementation of the <kbd>Get</kbd> and <kbd>GetById</kbd> action methods:</p>
<pre><strong>using System;</strong><br/><strong>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;</strong><br/><strong>using Catalog.API.ResponseModels;</strong><br/><strong>using Catalog.Domain.Requests.Artists;</strong><br/><strong>using Catalog.Domain.Responses;</strong><br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    ..<br/>    public class ArtistController : ControllerBase<br/>    {<br/>        ...<br/>        [HttpGet]<br/>        <strong>public async Task&lt;IActionResult&gt; Get([FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0)</strong><br/>        {<br/>            var result = await _artistService.GetArtistsAsync();<br/><br/>            var totalItems = result.ToList().Count;<br/><br/>            var itemsOnPage = result<br/>                .OrderBy(c =&gt; c.ArtistName)<br/>                .Skip(pageSize * pageIndex)<br/>                .Take(pageSize);<br/><br/>            var model = new PaginatedItemsResponseModel&lt;ArtistResponse&gt;(<br/>                pageIndex, pageSize, totalItems, itemsOnPage);<br/><br/>            return Ok(model);<br/>        }<br/><br/>        [HttpGet("{id:guid}")]<br/>        <strong>public async Task&lt;IActionResult&gt; GetById(Guid id)</strong><br/>        {<br/>            var result = await _artistService.GetArtistAsync(new GetArtistRequest {Id = id});<br/><br/>            return Ok(result);<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code shows the implementation of <kbd>ArtistController</kbd>, which corresponds to the <kbd>/api/artist</kbd> route. <kbd>ArtistController</kbd> uses <kbd>PaginatedItemsResponseModel</kbd> to retrieve the information related to all the artists. In the same way, we can use the <kbd>IAritstService</kbd> interface to execute the other operations and map them with the action methods:</p>
<pre>...<br/>        [HttpGet("{id:guid}/items")]<br/>        public async Task&lt;IActionResult&gt; GetItemsById(Guid id)<br/>        {<br/>            var result = await _artistService.GetItemByArtistIdAsync(new GetArtistRequest { Id = id });<br/><br/>            return Ok(result);<br/>        }<br/><br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; Post(AddArtistRequest request)<br/>        {<br/>            var result = await _artistService.AddArtistAsync(request);<br/><br/>            return CreatedAtAction(nameof(GetById), new { id = result.ArtistId }, null);<br/>        }<br/>}</pre>
<p>The preceding <kbd>ArtistController</kbd> class defines the following routes:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Verb</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Path</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist</kbd></td>
<td class="CDPAlignCenter CDPAlign">Retrieves all the artists present in the database</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">Retrieves the artist with the corresponding <em>ID</em></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist/{id}/items/</kbd></td>
<td class="CDPAlignCenter CDPAlign">Retrieves the items with the corresponding artist <em>ID</em></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>POST</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>/api/artist/</kbd></td>
<td class="CDPAlignCenter CDPAlign">Creates a new artist and retrieves it</td>
</tr>
</tbody>
</table>
<p>For each route, the <em>catalog service</em> will retrieve the corresponding data by executing the <kbd>IArtistService</kbd> interface methods. The <kbd>ArtistService</kbd> implementation will dispatch the request to the corresponding method of the repository implementations contained in the <kbd>Catalog.Infrastructure</kbd> project. Similar to <kbd>ItemController</kbd>, we can implement any additional validation behavior by using <kbd>FluentValidation</kbd>. For example, in the case of <kbd>AddArtistRequest</kbd>, we can proceed with the following implementation:</p>
<pre>using FluentValidation;<br/><br/>namespace Catalog.Domain.Requests.Artists.Validators<br/>{<br/>    public class AddArtistRequestValidator : AbstractValidator&lt;AddArtistRequest&gt;<br/>    {<br/>        public AddArtistRequestValidator()<br/>        {<br/>            RuleFor(artist =&gt; artist.ArtistName).NotEmpty();<br/>        }<br/>    }<br/>}</pre>
<p>In the case of <kbd>AddArtistRequest</kbd>, we want to prevent the user from adding empty <kbd>ArtistName</kbd> fields. We can create an additional <kbd>AddArtistRequestValidator</kbd> class under the <kbd>Requests/Artist/Validator</kbd> path. The validator class contains only one rule related to the non-empty <kbd>ArtistName</kbd> field. </p>
<p>The same implementation pattern can be also taken by the <kbd>GenreController</kbd> class. The following code defines the signature of the class implementation:</p>
<pre>using System;<br/>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.API.Filters;<br/>using Catalog.API.ResponseModels;<br/>using Catalog.Domain.Requests.Genre;<br/>using Catalog.Domain.Responses;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/genre")]<br/>    [ApiController]<br/>    [JsonException]<br/>    public class GenreController : ControllerBase<br/>    {<br/>        private readonly IGenreService _genreService;<br/><br/>        public GenreController(IGenreService genreService)<br/>        {<br/>            _genreService = genreService;<br/>        }<br/>    }<br/>}</pre>
<p>The code above injects the <kbd>IGenreService</kbd> interface using the <em>constructor injection</em> practice.  Furthermore, we can proceed by creating the corresponding routes we defined for the <kbd>ArtistController</kbd> class:</p>
<pre>...<br/><br/>[HttpGet]<br/>public async Task&lt;IActionResult&gt; Get([FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0)<br/>{<br/>    var result = await _genreService.GetGenreAsync();<br/><br/>    var totalItems = result.ToList().Count;<br/><br/>    var itemsOnPage = result<br/>        .OrderBy(c =&gt; c.GenreDescription)<br/>        .Skip(pageSize * pageIndex)<br/>        .Take(pageSize);<br/><br/>    var model = new PaginatedItemsResponseModel&lt;GenreResponse&gt;(<br/>        pageIndex, pageSize, totalItems, itemsOnPage);<br/><br/>    return Ok(model);<br/>}<br/><br/>[HttpGet("{id:guid}")]<br/>public async Task&lt;IActionResult&gt; GetById(Guid id)<br/>{<br/>    var result = await _genreService.GetGenreAsync(new GetGenreRequest {Id = id});<br/><br/>    return Ok(result);<br/>}<br/><br/>[HttpGet("{id:guid}/items")]<br/>public async Task&lt;IActionResult&gt; GetItemById(Guid id)<br/>{<br/>    var result = await _genreService.GetItemByGenreIdAsync(new GetGenreRequest {Id = id});<br/><br/>    return Ok(result);<br/>}<br/><br/>[HttpPost]<br/>public async Task&lt;IActionResult&gt; Post(AddGenreRequest request)<br/>{<br/>    var result = await _genreService.AddGenreAsync(request);<br/><br/>    return CreatedAtAction(nameof(GetById), new {id = result.GenreId}, null);<br/>}<br/>...</pre>
<p>The code above defines the  <kbd>Get</kbd>, <kbd>GetById</kbd>, <kbd>GetItemById</kbd> and the <kbd>Post</kbd> action methods implemented in the <kbd>GenreController</kbd> class. Each action calls the underlying service layer in order to interact with the database. Although the implementation of the action methods is similar to the <kbd>ArtistController</kbd> class, I still keep the classes separate; therefore, the <kbd>Genre</kbd> and <kbd>Artist</kbd> entities can evolve separately without depending on each other. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending tests for the ArtistController class</h1>
                
            
            
                
<p>Once we expose the API routes through the <kbd>ArtistController</kbd> and <kbd>GenreController</kbd> classes, we are able to proceed by testing the revealed paths using the same approach that we used for <kbd>ItemController</kbd>. We should continue by creating a new <kbd>ArtistControllerTests</kbd> class in the <kbd>Catalog.API.Tests</kbd> project:</p>
<pre>using System.Collections.Generic;<br/>...<br/><br/>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class ArtistControllerTests : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>        public ArtistControllerTests(InMemoryApplicationFactory&lt;Startup&gt; factory)<br/>        {<br/>            _factory = factory;<br/>        }<br/><br/>        private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;<br/><br/>        [Theory]<br/>        [InlineData("/api/artist/")]<br/>        public async Task smoke_test_on_items(string url)<br/><br/>        {<br/>            var client = _factory.CreateClient();<br/>            var response = await client.GetAsync(url);<br/><br/>            response.EnsureSuccessStatusCode();<br/>        }<br/><br/>        [Theory]<br/>        [InlineData("/api/artist/?pageSize=1&amp;pageIndex=0", 1, 0)]<br/>        public async Task get_should_returns_paginated_data(string url, int pageSize, int pageIndex)<br/><br/>        {<br/>            var client = _factory.CreateClient();<br/>            var response = await client.GetAsync(url);<br/><br/>            response.EnsureSuccessStatusCode();<br/><br/>            var responseContent = await response.Content.ReadAsStringAsync();<br/>            var responseEntity =<br/>                JsonConvert.DeserializeObject&lt;PaginatedItemResponseModel&lt;GenreResponse&gt;&gt;(responseContent);<br/><br/>            responseEntity.PageIndex.ShouldBe(pageIndex);<br/>            responseEntity.PageSize.ShouldBe(pageSize);<br/>            responseEntity.Data.Count().ShouldBe(pageSize);<br/>        }<br/><br/>        [Theory]<br/>        [LoadData("artist")]<br/>        public async Task get_by_id_should_return_right_artist(Artist request)<br/>        {<br/>            var client = _factory.CreateClient();<br/>            var response = await client.GetAsync($"/api/artist/{request.ArtistId}");<br/><br/>            response.EnsureSuccessStatusCode();<br/><br/>            var responseContent = await response.Content.ReadAsStringAsync();<br/>            var responseEntity = JsonConvert.DeserializeObject&lt;Artist&gt;(responseContent);<br/><br/>            responseEntity.ArtistId.ShouldBe(request.ArtistId);<br/>        }<br/>  ...</pre>
<p>The preceding code describes the test case for the get paginated artist action method and the get by ID action method. Both use the same <kbd>InMemoryApplicationFactory</kbd> factory to set up the fake in-memory data source. It is also possible to combine additional tests to verify the add artist process<em>:</em></p>
<pre>...<br/>        [Fact]<br/>        public async Task add_should_create_new_artist()<br/>        {<br/>            var addArtistRequest = new AddArtistRequest{ ArtistName = "The Braze" };<br/><br/>            var client = _factory.CreateClient();<br/>            var httpContent = new StringContent(JsonConvert.SerializeObject(addArtistRequest), Encoding.UTF8,<br/>                "application/json");<br/>            var response = await client.PostAsync("/api/artist", httpContent);<br/><br/>            response.EnsureSuccessStatusCode();<br/><br/>            var responseHeader = response.Headers.Location;<br/><br/>            response.StatusCode.ShouldBe(HttpStatusCode.Created);<br/>            responseHeader.ToString().ShouldContain("/api/artist/");<br/>        }<br/>    }<br/>}</pre>
<p>The fixture class initializes a new <kbd>TestServer</kbd> instance for each test method and it provides a new <kbd>HttpClient</kbd> instance through the <kbd>CreateClient</kbd> method to test the routes exposed by the <kbd>ArtistController</kbd> class. The tests also use the <kbd>LoadData</kbd> attribute to get matching information about the testing records from the <kbd>record-data.json</kbd> file. A similar implementation approach can be taken to test the <kbd>GenreController</kbd> class action methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A final overview</h1>
                
            
            
                
<p>Finally, let's take a look at a quick overview of the code structure we implemented in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, <a href="f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml">Chapter 9</a>, <em>Implementing the Domain Logic</em>, and this chapter. The following architecture schema illustrates the actual construction of the <kbd>Catalog.API</kbd> solution:</p>
<div><img src="img/ef6629e2-50a2-4aa8-8e6a-a66028bcd14a.png" style=""/></div>
<p class="mce-root">Once the web service instance receives the client request, it dispatches the request to the corresponding action method of the controller. Following this, the action method executes the corresponding function exposed by the service classes defined in the <kbd>Catalog.Domain</kbd> project, which ships the request to the relevant repository defined in the <kbd>Catalog.Infrastructure</kbd> project, and then maps the entities with the request and response models.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has covered various topics regarding the design and development of the <kbd>Catalog.API</kbd> project. Moreover, it has shown you how to build the routes of our APIs. The topics covered in this chapter are part of the core implementation of our web services; therefore, they provide all the knowledge that is necessary for exposing HTTP routes and handling requests and responses in .NET Core. In addition to this, the chapter also covered integration testing and implementation using the web factory tools provided by the framework. </p>
<p>In the next chapter, we will cover other additional topics about web services, such as how to implement a soft-delete approach to our data and how to use a <strong>Hypermedia As The Engine Of Application State</strong> (<strong>HATEOAS</strong>) approach. The chapter will also cover some .NET Core-related topics such as a brief introduction to and the best practices of asynchronous programming in .NET Core.</p>


            

            
        
    </body></html>