<html><head></head><body>
		<div><h1 id="_idParaDest-111" class="chapter-number"><a id="_idTextAnchor162"/>10</h1>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor163"/>Convention over Configuration</h1>
			<p>Our programs need to be configured. Some of these configurations are things such as connection strings to a database or a URL for a REST API we are calling. These might change depending on the different environments our code is running in (e.g. development, testing, or production). On top of this, we often have to configure our code to be able to run as we expect. The type of configuration we do is often dictated by some third-party library or framework we’re using. In growing solutions, this type of configuration tends to also grow, and since configuration is often done at a specific point during the startup of the program, it’s not uncommon to end up with large files acting as dumping grounds for this type of thing.</p>
			<p>In this chapter, we will look into how we can leverage the power of the metadata we already have in running code to make code automatically configure itself and become more consistent as a result.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>Inversion of control and its role</li>
				<li>Automatic ServiceCollection registrations by convention</li>
			</ul>
			<p><a id="_idTextAnchor164"/>By end the of the chapter, you will have an idea of what conventions can do for you and how they can make you more productive and also allow you to create more consistent code bases.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor165"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10</a>) and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found at <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>.</p>
			<p>You will need Docker Desktop installed (<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>), Postman (<a href="https://www.postman.com">https://www.postman.com</a>), and a MongoDB editor such as Compass (<a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a>).</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor166"/>Inversion of control and its role</h1>
			<p>Software needs <a id="_idIndexMarker351"/>structure really fast when growing beyond one page of <a id="_idIndexMarker352"/>source code. Typically, you’d group things logically in types that have a specific purpose in your system. With your software being broken up for better maintainability, the different parts are then often dependent on each other to be able to perform the overall tasks you need it to do.</p>
			<h3>Building a module for registering users</h3>
			<p>Let’s build a <a id="_idIndexMarker353"/>simple system that handles <a id="_idIndexMarker354"/>a user sign-up feature exposed as a REST API. Start by creating a folder called <strong class="source-in ine">Chapter10</strong>. Change into this folder in your command line and create a new web-based project:</p>
			<pre class="source-code">
dotnet new web</pre>
			<p>The type of information you’d want to capture involves both personal information and also the user’s credentials that we want to have as part of the body of our API. Add a file called <strong class="source-in ine">RegisterUser.cs</strong> and add the following to it:</p>
			<pre class="source-code">
namespace Chapter10;
public record RegisterUser(string FirstName, string
  LastName, string SocialSecurityNumber, string UserName,
    string Password);</pre>
			<p>The <strong class="source-in ine">RegisterUser</strong> type takes all the different properties you want to capture for the user for the API. This is not what you want to store directly in a database. When you store this, you want to store this as two separate things – the user credentials and the user details. Create a file called <strong class="source-in ine">User.cs</strong> and add the following to it:</p>
			<pre class="source-code">
namespace Chapter10;
public record User(Guid Id, string UserName, string
  Password);</pre>
			<p>The <strong class="source-in ine">User</strong> type only captures the actual user name and the password and has a unique identifier for the user. Then add a file called <strong class="source-in ine">UserDetails</strong> and add the following to it:</p>
			<pre class="source-code">
namespace Chapter10;
public record UserDetails(Guid Id, Guid UserId, string
  FirstName, string LastName, string SocialSecurityNumber);</pre>
			<p><strong class="source-in ine">UserDetails</strong> holds the rest of the information we will be getting from the <strong class="source-in ine">RegisterUser</strong> type.</p>
			<p>The next thing we need is an API controller to take this and store the information in the database. We will be using MongoDB as a backing store.</p>
			<p>We will be relying on a third-party library to access MongoDB. Add the package to the project by running<a id="_idIndexMarker355"/> the following in<a id="_idIndexMarker356"/> the terminal:</p>
			<pre class="source-code">
dotnet add package mongodb.driver</pre>
			<p>Create a file called <strong class="source-in ine">UsersController</strong> and add the following to it:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
using MongoDB.Driver;
namespace Chapter10;
[Route("/api/users")]
public class UsersController : Controller
{
    IMongoCollection&lt;User&gt; _userCollection;
    IMongoCollection&lt;UserDetails&gt; _userDetailsCollection;
    public UsersController()
    {
        var client = new MongoClient
          ("mongodb://localhost:27017");
        var database = client.GetDatabase("TheSystem");
        _userCollection = database.GetCollection&lt;User&gt;
          ("Users");
        _userDetailsCollection = database.GetCollection
          &lt;UserDetails&gt;("UserDetails");
    }
    [HttpPost("register")]
    public async Task Register([FromBody] RegisterUser
      userRegistration)
    {
        var user = new User(Guid.NewGuid(),
           userRegistration.UserName,
             userRegistration.Password);
        var userDetails = new UserDetails(Guid.NewGuid(),
           user.Id, userRegistration.FirstName,
             userRegistration.LastName, userRegistration
               .SocialSecurityNumber);
        await _userCollection.InsertOneAsync(user);
        await _userDetailsCollection.InsertOneAsync
          (userDetails);
    }
}</pre>
			<p>The code sets up in its constructor the database and gets the two different collections in which we will be storing the user information coming in. The register API method then takes <strong class="source-in ine">RegisterUser</strong> and splits it up into the two respective types and inserts them into each of their MongoDB collections.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">In a real system, you would obviously encrypt the password with a strong (preferably one-way) encryption strategy and not just store the password as clear text.</p>
			<p>Open your <strong class="source-in ine">Program.cs</strong> file <a id="_idIndexMarker357"/>and make<a id="_idIndexMarker358"/> it look like the following:</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
var app = builder.Build();
app.UseRouting();
app.UseEndpoints(_ =&gt; _.MapControllers());
app.Run();</pre>
			<p>Before you run the solution so far, you need to start the MongoDB server. You do this by using Docker. In your terminal, run the following:</p>
			<pre class="source-code">
docker run -d -p 27017:27017 mongo</pre>
			<p>The command should start MongoDB as a background daemon and expose port <strong class="source-in ine">27017</strong> so that you can connect to it. You should see something similar to the following line:</p>
			<pre class="source-code">
9fb4b3c16d7647bfbb69eabd7863a169f6f2e4218191cc69c7454978627
f75d5</pre>
			<p>This is the unique identifier of the running Docker image.</p>
			<p>You can now run the code you’ve created so far from your terminal:</p>
			<pre class="source-code">
dotnet run</pre>
			<p>You should now see something similar to the following:</p>
			<pre class="source-code">
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5000
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /Users/einari/Projects/
        Metaprogramming-in-C/Chapter10/</pre>
			<h3>Testing the API</h3>
			<p>With the<a id="_idIndexMarker359"/> code thus far, you now have an API that has a<a id="_idIndexMarker360"/> route of <strong class="source-in ine">/api/users/register</strong> that accepts an HTTP POST.</p>
			<p>You can test your API by using Postman with the following steps:</p>
			<ol>
				<li>Select <strong class="bo d">POST</strong>.</li>
				<li>Enter the URL for the API – <strong class="source-in ine">http://localhost:5000/api/user/register</strong>.</li>
				<li>In the <strong class="bo d">Body</strong> tab, select <strong class="bo d">Raw</strong> as the input and then <strong class="bo d">JSON</strong> as the type.</li>
			</ol>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The port of the URL has to match the port in the output where it says <strong class="source-in ine">Now listening on: </strong><strong class="source-in ine">http://localhost:{your port}</strong>.</p>
			<div><div><img src="img/B19418_10_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Testing the API using Postman</p>
			<p>Once you’ve clicked <strong class="bo d">Send</strong>, you should get <strong class="bo d">200 OK</strong> at the bottom. Then you can open the MongoDB<a id="_idIndexMarker361"/> editor – for instance, Compass, as suggested in the <a id="_idIndexMarker362"/>pre-requisites.</p>
			<p>Create a new connection to the MongoDB server and perform the following steps:</p>
			<ol>
				<li>Make sure the connection string is pointing to your MongoDB server. By default, it should say <strong class="source-in ine">mongodb://localhost:27017</strong>, which matches the code.</li>
				<li>Click the <strong class="bo d">Connect</strong> button.</li>
			</ol>
			<div><div><img src="img/B19418_10_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Creating a new connection</p>
			<p>Once connected, you should see the database <strong class="bo d">TheSystem</strong> on the left-hand side and, within<a id="_idIndexMarker363"/> it, the<a id="_idIndexMarker364"/> collections. Clicking the <strong class="bo d">user</strong> collection or <strong class="bo d">user-details</strong>, you should see the data you registered on the right side.</p>
			<div><div><img src="img/B19418_10_03.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Registered data</p>
			<p>This is all fine, and <a id="_idIndexMarker365"/>the code certainly does its job as<a id="_idIndexMarker366"/> expected. But the code could <a id="_idTextAnchor167"/>be improved.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor168"/>Refactoring the code</h2>
			<p>There are a<a id="_idIndexMarker367"/> couple of challenges with this type of code:</p>
			<ul>
				<li>Firstly, the controller is taking on the responsibility for the infrastructure</li>
				<li>Secondly, it also takes on the responsibility for the actual domain logic and knowing exactly how to store things in a database</li>
			</ul>
			<p>An API surface should instead just rely on other subsystems to do their specific job and then delegate to them rather and then become a composition.</p>
			<p>For instance, we could go and isolate the user credential registration and the user details registration into two different services that we could use.</p>
			<h3>Creating services</h3>
			<p>Let’s pull it apart<a id="_idIndexMarker368"/> a little bit and start putting in some structure. Create a file called <strong class="source-in ine">UsersService.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using MongoDB.Driver;
namespace Chapter10;
public class UsersService
{
    readonly IMongoCollection&lt;User&gt; _usersCollection;
    public UserService()
    {
        var client = new MongoClient
          ("mongodb://localhost:27017");
        var database = client.GetDatabase("TheSystem");
        _usersCollection = database.GetCollection&lt;User&gt;
          ("Users");
    }
    public async Task&lt;Guid&gt; Register(string userName,
      string password)
    {
        var user = new User(Guid.NewGuid(),
          userRegistration.UserName, userRegistration
            .Password);
        await _usersCollection.InsertOneAsync(user);
        return user.Id;
    }
}</pre>
			<p>The code is doing <a id="_idIndexMarker369"/>exactly the same as it did in <strong class="source-in ine">UsersController</strong> for registering the user, just that it is now formalized as a service. Let’s do the same for the user details. Create a file called <strong class="source-in ine">UserDetailsService.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter10;
public class UserDetailsService
{
    readonly IMongoCollection&lt;User&gt; _userDetailsCollection;
    public UserDetailsService(IDatabase database)
    {
        var client = new MongoClient
          ("mongodb://localhost:27017");
        var database = client.GetDatabase("TheSystem");
        _userDetailsCollection = database.GetCollection
          &lt;User&gt;("UserDetails");
    }
    public Task Register(string firstName, string lastName,
      string socialSecurityNumber, Guid userId)
        =&gt; _userDetailsCollection_.InsertOneAsync
          (new(Guid.NewGuid(), userId, firstName, lastName,
            socialSecurityNumber));
}</pre>
			<p>As with <strong class="source-in ine">UsersService</strong>, the code does exactly the same as the original code in <strong class="source-in ine">UsersController</strong>, only now separated out and focused.</p>
			<p>This is a great step. Now the infrastructure details of the database are hidden from the outside world and anyone wanting to register a user only has to focus on the information <a id="_idIndexMarker370"/>needed to do so and not how it’s done.</p>
			<p>The next step is for you to change <strong class="source-in ine">UsersController</strong> to leverage the new services.</p>
			<h3>Changing the controller</h3>
			<p>Go and <a id="_idIndexMarker371"/>change the controller to look like the following:</p>
			<pre class="source-code">
[Route("/api/users")]
public class UsersController : Controller
{
    readonly UsersService _usersService;
    readonly UserDetailsService _usersDetailsService;
    public UsersController()
    {
        _usersService = new UsersService();
        _userDetailsService = new UserDetailsService();
    }
    [HttpPost("register")]
    public async Task Register([FromBody] RegisterUser
       userRegistration)
    {
        await _usersService.Register(
            userRegistration.UserName,
            userRegistration.Password);
        await _userDetailsService.Register(
            userRegistration.FirstName,
            userRegistration.LastName,
            userRegistration.SocialSecurityNumber);
    }
}</pre>
			<p>The code creates an<a id="_idIndexMarker372"/> instance of the <strong class="source-in ine">UsersService</strong> class in the constructor and uses the <strong class="source-in ine">Register</strong> method directly in the <strong class="source-in ine">Register</strong> API method.</p>
			<p>If you run the sample at this point and perform the <strong class="source-in ine">HTTP POST</strong> again, you will get the exact same result.</p>
			<p><strong class="source-in ine">UsersService</strong> and <strong class="source-in ine">UserDetailsService</strong> are now dependencies that <strong class="source-in ine">UsersController</strong> have and it creates those dependencies as instances itself. There are a couple of downsides to this. The dependencies are basically now following the life cycle of the controller. Since controllers are created once per web request, it means <strong class="source-in ine">UsersService</strong> and <strong class="source-in ine">UserDetailsService</strong> will be created every time as well. This could be a performance issue, and is not really a problem the controller should be worried about. Its main job is just to provide an API surface for registering users.</p>
			<p>It’s also very hard to be able to write tests for <strong class="source-in ine">UsersController</strong>, as the dependencies are now hard-wired and it brings in all the infrastructure with it and then makes it much harder to test the logic of <strong class="source-in ine">UsersController</strong> in isolation.</p>
			<p>This is where dependency inversion comes in, by reversing the relationship and saying that the system, in our case <strong class="source-in ine">UsersController</strong>, is not responsible for creating the instance itself, but rather has it as an argument to the constructor, and letting whoever is instantiating <a id="_idIndexMarker373"/>the controller be responsible for providing the dependencies <strong class="source-in ine">UsersController</strong> has.</p>
			<p>Change <strong class="source-in ine">UsersController</strong> to take the dependency on the constructor:</p>
			<pre class="source-code">
[Route("/api/users")]
public class UsersController : Controller
{
    readonly UsersService _usersService;
    readonly UserDetailsService _usersDetailsService;
    public UsersController(
        UsersService usersService,
        UserDetailsService userDetailsService)
    {
        _usersService = usersService;
        _userDetailsService = userDetailsService;
    }
    [HttpPost("register")]
    public async Task Register([FromBody] RegisterUser userRegistration)
    {
        await _usersService.Register(
            userRegistration.UserName,
            userRegistration.Password);
        await _userDetailsService.Register(
            userRegistration.FirstName,
            userRegistration.LastName,
            userRegistration.SocialSecurityNumber);
    }
}</pre>
			<p>The code now takes <strong class="source-in ine">UsersService</strong> and <strong class="source-in ine">UserDetailsService</strong> as arguments and uses those directly instead of creating an instance of them itself.</p>
			<p>We now have the benefit of the dependencies being very clear to the outside world. The life cycle of <strong class="source-in ine">UsersService</strong> can then be managed outside of the controller.</p>
			<p>However, since the controller is taking the concrete instances, it is still tied to the infrastructure. This <a id="_idIndexMarker374"/>can be improved upon to decouple the infrastructure and make it more testable.</p>
			<h3>Contract oriented</h3>
			<p>To improve further on<a id="_idIndexMarker375"/> this, we could also extract the content of <strong class="source-in ine">UsersService</strong> and <strong class="source-in ine">UserDetailsService</strong> into interfaces and use those instead. The benefits of that are that you would decouple from the concrete implementation and its infrastructure needs and add flexibility in your code by allowing different implementations and, depending on the configuration or the system being in a specific state, switch out which implementation of the interface to use.</p>
			<p>An additional benefit of extracting into an interface is that you make it easier to write tests that focus purely on the unit being tested and only the interaction with its dependencies, without having to bring in the entire infrastructure to write the automated test.</p>
			<p>Create a file called <strong class="source-in ine">IUsersService.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter10;
public interface IUsersService
{
    Task&lt;Guid&gt; Register(string userName, string password);
}</pre>
			<p>The code holds the <strong class="source-in ine">Register</strong> method with the same signature as in the original <strong class="source-in ine">UsersService</strong> class. Then<a id="_idIndexMarker376"/> the implementation of <strong class="source-in ine">UsersService</strong> only changes by adding the <strong class="source-in ine">IUsersService</strong> inheritance. Open the <strong class="source-in ine">UsersService</strong> file and make it implement the <strong class="source-in ine">IUsersService</strong> interface:</p>
			<pre class="source-code">
public class UsersService : IUsersService
{
    /*
    Same code as before within the UsersService
    */
}</pre>
			<p>For <strong class="source-in ine">UserDetailsService</strong>, we want to do the same. Add a file called <strong class="source-in ine">IUserDetailsService.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter10.Structured;
public interface IUserDetailsService
{
    Task Register(string firstName, string lastName, string
      socialSecurityNumber, Guid userId);
}</pre>
			<p>The code holds the <strong class="source-in ine">Register</strong> method with the same signature as in the original <strong class="source-in ine">UserDetailsService</strong> class. Then the implementation of <strong class="source-in ine">UserDetailsService</strong> only changes by adding the <strong class="source-in ine">IUserDetailsService</strong> inheritance. Open the <strong class="source-in ine">UserDetailsService</strong> file and make it implement the <strong class="source-in ine">IUserDetailsService</strong> interface:</p>
			<pre class="source-code">
public class UserDetailsService : IUserDetailsService
{
    /*
    Same code as before within the UserDetailsService
    */
}</pre>
			<p>With these two <a id="_idIndexMarker377"/>changes, we can now change how we express the dependencies. In <strong class="source-in ine">UsersController</strong>, you then change from using <strong class="source-in ine">UsersService</strong> to <strong class="source-in ine">IUsersService</strong> and <strong class="source-in ine">UserDetailsService</strong> to <strong class="source-in ine">IUserDetailsService</strong>:</p>
			<pre class="source-code">
[Route("/api/users")]
public class UsersController : Controller
{
    readonly IUsersService _usersService;
    readonly IUserDetailsService _userDetailsService;
    public UsersController(
        IUsersService usersService,
        IUserDetailsService userDetailsService)
    {
        _usersService = usersService;
        _userDetailsService = userDetailsService;
    }
    // Same register API method as before would go here
}</pre>
			<p>The code now takes the two <strong class="source-in ine">IUsersService</strong> and <strong class="source-in ine">IUserDetailsService</strong> dependencies using their interfaces and the rest of the code remains unchanged.</p>
			<p>So far, we’ve discussed dependencies and the benefits of the <strong class="bo d">dependency inversion principle</strong>. Still, we <a id="_idIndexMarker378"/>need to be able to provide these dependencies. And it is very impractical if we have to manually provide these all around our system and maintain life cycles of them in different ways. It could lead to a very messy, unmaintainable code base and could also lead to unknown side effects.</p>
			<p>What you really want is something that manages this for you. This is what is known as an <strong class="bo d">inversion of control container</strong> (<strong class="bo d">IoC container</strong>). Its job is to hold information about all <a id="_idIndexMarker379"/>your services, which implementation is used for what interface, and also the life cycle of these. The IoC container is a centralized piece that you configure at the beginning of your application and after its configuration is done, you can ask it to provide instances of anything that is registered with it. It’s very useful for registering any kind of dependencies, not just the ones where it is an interface to an implementation. You can register concrete types, delegate types, or pretty much anything.</p>
			<p>The IoC container works recursively and will deal with dependencies of dependencies and resolve everything correctly.</p>
			<p>In ASP.NET Core, the<a id="_idIndexMarker380"/> concept of an IoC container is already set up out of the box and is really easy to use with what is known as <strong class="source-in ine">ServiceCollection</strong>, where you can set up all <a id="_idTextAnchor169"/>the service registrations.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor170"/>Automatic ServiceCollection registrations by convention</h1>
			<p>We’ve now left <a id="_idIndexMarker381"/>the code in a non-functional state. This is because the built-in IoC container does not know how to resolve the <strong class="source-in ine">IUsersService</strong> dependency and <strong class="source-in ine">IUserDetailsService</strong>.</p>
			<p>You need to explicitly tell ASP.NET which implementation it should use. Open your <strong class="source-in ine">Program.cs</strong> file and put in the binding as follows:</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
// Add these two lines to bind the services
builder.Services.AddSingleton&lt;IUsersService,
  UsersService&gt;();
builder.Services.AddSingleton&lt;IUserDetailsService,
  UserDetailsService&gt;();
var app = builder.Build();
app.UseRouting();
app.UseEndpoints(_ =&gt; _.MapControllers());
app.Run();</pre>
			<p>The code adds a <a id="_idIndexMarker382"/>registration in the ASP.NET Core <strong class="source-in ine">ServiceCollection</strong> for <strong class="source-in ine">IUsersService</strong> to be resolved to <strong class="source-in ine">UsersService</strong>, and it also explicitly says that it should add it as a <strong class="bo d">singleton</strong>. This means that there will only be one instance of this service within the process.</p>
			<p>You should now have a working program again, the only difference now is that the ASP.NET IoC container is resolving the instance for you, and it will be the same instance for every request.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Singletons can be dangerous. If the type being a singleton has a dependency on something that shouldn’t be a singleton but should in fact be new on every request, the type being singleton will be a blocker for that. Use them wisely.</p>
			<p>The code thus far is very contained and simple. In real systems, you tend to want to be even clearer<a id="_idIndexMarker383"/> about responsibilities by dividing up the <a id="_idTextAnchor171"/>code into more focused units.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor172"/>Further refactoring</h2>
			<p>Too much <a id="_idIndexMarker384"/>responsibility lies on <strong class="source-in ine">UsersService</strong> right now. The database part is not something it should own. Knowing how to create a database connection is something that should be extracted so that you do that in one place. Be conscious of the responsibilities of each unit in your system.</p>
			<p>Let’s introduce a unit representing the database. Start by creating an interface by adding a file called <strong class="source-in ine">IDatabase.cs</strong> to the project, and make it look like the following:</p>
			<pre class="source-code">
using MongoDB.Driver;
namespace Chapter10;
public interface IDatabase
{
    IMongoCollection&lt;T&gt; GetCollectionFor&lt;T&gt;();
}</pre>
			<p>The interface gives us access to getting MongoDB collections for types specified using generics.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">By creating an abstraction for the database, one could argue we could have gone further and created something that represented the database operations you typically do adhering to what is known as the repository pattern. If you did that, you would quickly find that you would not be able to work with the underlying database and its capabilities. Also, for the context of this book, we’ll keep it at this level.</p>
			<p>With the <strong class="source-in ine">IDatabase</strong> interface in place, you now need an implementation of it. Create a file called <strong class="source-in ine">Database.cs</strong> and<a id="_idIndexMarker385"/> add the following to it:</p>
			<pre class="source-code">
using MongoDB.Driver;
namespace Chapter10;
public class Database : IDatabase
{
    static readonly Dictionary&lt;Type, string&gt;
      _typeToCollectionName = new()
    {
        { typeof(User), "Users" },
        { typeof(UserDetails), "UserDetails" }
    };
    readonly IMongoDatabase _mongoDatabase;
    public Database()
    {
        var client = new MongoClient
          ("mongodb://localhost:27017");
        _mongoDatabase = client.GetDatabase("TheSystem");
    }
    public IMongoCollection&lt;T&gt; GetCollectionFor&lt;T&gt;() =&gt;
      _mongoDatabase.GetCollection&lt;T&gt;(_typeToCollectionName
        [typeof(T)]);
}</pre>
			<p>The code contains most of the database access you had in <strong class="source-in ine">UsersService</strong> but adds a dimension of mapping types to collection names.</p>
			<p>As a little bit of a sidetrack, but still on the theme of convention over configuration, let’s improve the <strong class="source-in ine">Database</strong> class a little bit. At the top of the class, there is the map of <strong class="source-in ine">Type</strong> to the collection name. This is something that would grow over time. If you look at the <strong class="source-in ine">User</strong> type, it gets mapped to <strong class="source-in ine">Users</strong> – a convention that I prefer, having the collection names as plural, indicating there is more than one user.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The concept of convention over configuration was coined by David Heinemeier Hansson to describe the philosophy of the Ruby on Rails web framework. You can read more about it here: <a href="https://rubyonrails.org/doctrine#convention-over-configuration">https://rubyonrails.org/doctrine#convention-over-configuration</a>.</p>
			<p>This is something<a id="_idIndexMarker386"/> that can be automated and would truly be convention over configuration. Let’s pull in a third-party library that deals with pluralization for us. Go to your terminal and run the following in the <strong class="source-in ine">Chapter10</strong> folder:</p>
			<pre class="source-code">
dotnet add package Humanizer</pre>
			<p>The <strong class="source-in ine">Humanizer</strong> library knows how to pluralize English words by default, but it has support for other languages as well. I recommend reading more about it over on GitHub (<a href="https://github.com/Humanizr/Humanizer">https://github.com/Humanizr/Humanizer</a>).</p>
			<p>With the package installed, you can improve and simplify your <strong class="source-in ine">Database</strong> code. Change the <strong class="source-in ine">Database</strong> class to be like the following:</p>
			<pre class="source-code">
using Humanizer;
using MongoDB.Driver;
namespace Chapter10.Structured;
public class Database : IDatabase
{
    readonly IMongoDatabase _mongoDatabase;
    public Database()
    {
        var client = new MongoClient("mongodb://
          localhost:27017");
        _mongoDatabase = client.GetDatabase("TheSystem");
    }
    public IMongoCollection&lt;T&gt; GetCollectionFor&lt;T&gt;() =&gt;
      _mongoDatabase.GetCollection&lt;T&gt;(typeof(T).Name
        .Pluralize());
}</pre>
			<p>The code is pretty much the same, except you now don’t have <strong class="source-in ine">Dictionary</strong> with the mapping between <strong class="source-in ine">Type</strong> and collection names. Also, for the <strong class="source-in ine">GetCollection()</strong> method, you no longer need to do a lookup but instead, just use the type name and use the <strong class="source-in ine">.Pluralize()</strong> extension <a id="_idIndexMarker387"/>method on it. With this, you’re leveraging the type metadata to your advantage in a very simple way.</p>
			<p>With this fix, you’ve basically made your code future-proof and will not have to perform open-heart surgery on the code to add support for a new collection. It’s a predictable convention.</p>
			<p>Since you now have encapsulated the infrastructure part of the system into the <strong class="source-in ine">Database</strong> class, you can now start fixing <strong class="source-in ine">UserService</strong> and <strong class="source-in ine">UserDetailsService</strong> to leverage this centerpiece.</p>
			<p>Start by changing <strong class="source-in ine">UsersService</strong> to the following:</p>
			<pre class="source-code">
namespace Chapter10;
public class UsersService : IUsersService
{
    readonly IDatabase _database;
    public UsersService(IDatabase database)
    {
        _database = database;
    }
    public async Task&lt;Guid&gt; Register(string userName,
      string password)
    {
        var user = new User(Guid.NewGuid(), userName,
          password);
        await _database.GetCollectionFor&lt;User&gt;()
          .InsertOneAsync(user);
        return user.Id;
    }
}</pre>
			<p>The code now <a id="_idIndexMarker388"/>completely gets rid of the management of the database connection and how to get a collection, and also not even the name of the collection, instead pulling in <strong class="source-in ine">IDatabase</strong> as a dependency and letting the implementation of that interface take the full responsibility of the infrastructure. This is now just by convention, and you can trust that it will be a predictable collection name for the type you give it.</p>
			<p>You need to do the same to <strong class="source-in ine">UserDetailsService</strong>. Change it to the following:</p>
			<pre class="source-code">
namespace Chapter10.Structured;
public class UserDetailsService : IUserDetailsService
{
    readonly IDatabase _database;
    public UserDetailsService(IDatabase database)
    {
        _database = database;
    }
    public Task Register(string firstName, string lastName,
      string socialSecurityNumber, Guid userId)
        =&gt; _database.GetCollectionFor&lt;UserDetails&gt;()
          .InsertOneAsync(new(Guid.NewGuid(), userId,
            firstName, lastName, socialSecurityNumber));
}</pre>
			<p>As with <strong class="source-in ine">UsersService</strong>, the code change is pretty much the same, bringing in the <strong class="source-in ine">IDatabase</strong> infrastructure dependency and letting <strong class="source-in ine">UserDetailsService</strong> focus on its primary job of registering user details.</p>
			<p>The activity of refactoring the code has led to a more decoupled system and a more maintainable<a id="_idIndexMarker389"/> system, where each component is laser-focused on doing one thing, a single responsibility. I<a id="_idTextAnchor173"/>t now needs to be brought together.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor174"/>Composing</h2>
			<p>With the system <a id="_idIndexMarker390"/>broken up into focused components, we have to bring it together. Since the IoC container does not know how to resolve <strong class="source-in ine">IDatabase</strong>, we need to add that binding. Change your <strong class="source-in ine">Program.cs</strong> to look like the following:</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddSingleton&lt;IUsersService,
  UsersService&gt;();
builder.Services.AddSingleton&lt;IUserDetailsService,
  UserDetailsService&gt;();
// Add these two lines to bind the services
builder.Services.AddSingleton&lt;IDatabase, Database&gt;();
var app = builder.Build();
app.UseRouting();
app.UseEndpoints(_ =&gt; _.MapControllers());
app.Run();</pre>
			<p>The code adds the <strong class="source-in ine">.AddSingleton&lt;IDatabase, Database&gt;()</strong> call to register the binding between <strong class="source-in ine">IDatabase</strong> and <strong class="source-in ine">Database</strong> and also say we only need it to be a singleton. You should, at this point, have a working system again. Running this and performing the API call using Postman should give you the same result as before.</p>
			<p>However, already<a id="_idIndexMarker391"/> there is a bit of a code smell here. The fact that we have to go and manually add a registration to the IoC container for everything we add is again open-heart surgery we have to perform every time we create something. With just a couple of components, this not only becomes tedious but quickly also makes <strong class="source-in ine">Program.cs</strong> a dumping ground for this type of configuration.</p>
			<p>Luckily, there is a pattern we can turn into a convention. All the implementations have an interface representation that is named the same as the implementation, only prefixed with a capital <em class="ita ic">I</em>. This is a very common convention. We can make the code more future-proof by discovering the connections between the interfaces and implementations.</p>
			<p>Even though we can discover the relationship between implementations and interfaces, we wouldn’t know how to know which life cycle they should be. To do this, we shift the responsibility of knowing the life cycle onto the implementation. We do this by introducing metadata in the form of attributes. The default behavior should be that every binding we do is <strong class="bo d">transient</strong>, meaning that we get a new instance every time we ask the IoC container. Then all we need is attributes for overriding that behavior. For this sample, we’ll keep it to only one life cycle: singleton.</p>
			<p>Add a file called <strong class="source-in ine">SingletonAttribute.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter10;
[AttributeUsage(AttributeTargets.Class)]
public sealed class SingletonAttribute : Attribute
{
}</pre>
			<p>The code represents <a id="_idIndexMarker392"/>an attribute that is for classes and lets you look for during discovery and decide whether or not it is a singleton.</p>
			<p>Let’s take advantage of the <strong class="bo d">Fundamentals</strong> project in the GitHub repository mentioned in the pre-requisites. You should add a project reference to it for this chapter by doing the following in your terminal:</p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The path to the project might be different on your computer, depending on where you have the <strong class="source-in ine">Fundamentals</strong> project from the GitHub repository.</p>
			<p>What you now want to do is create an extension method for <strong class="source-in ine">IServiceCollection</strong> that you’ve been calling to register bindings with.</p>
			<p>Start by adding a file called <strong class="source-in ine">ServiceCollectionExtensions.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using Fundamentals;
namespace Chapter10;
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddBindingsBy
      Convention(this IServiceCollection services, ITypes
        types)
    {
        return services;
    }
}</pre>
			<p>The code just sets up a new extension method called <strong class="source-in ine">AddBindingsByConvention()</strong> that also takes the <strong class="source-in ine">ITypes</strong> system from <strong class="source-in ine">Fundamentals</strong> and<a id="_idIndexMarker393"/> returns <strong class="source-in ine">services</strong> given to it to be able to chain calls when using the method.</p>
			<p>Go and add the following to the top of the <strong class="source-in ine">AddBindingsConvention()</strong> method:</p>
			<pre class="source-code">
Func&lt;Type, Type, bool&gt; convention = (i, t) =&gt; i.Namespace
  == t.Namespace &amp;&amp; i.Name == $"I{t.Name}";
var conventionBasedTypes = types!.All.Where(_ =&gt;
{
    var interfaces = _.GetInterfaces();
    if (interfaces.Length &gt; 0)
    {
        var conventionInterface = interfaces
          .SingleOrDefault(i =&gt; convention(i, _));
        if (conventionInterface != default)
        {
            return types!.All.Count(type =&gt; type
              .HasInterface(conventionInterface)) == 1;
        }
    }
    return false;
});</pre>
			<p>The code uses <strong class="source-in ine">ITypes</strong> to get all the discovered types in the system. For every type, it looks at whether the type implements any interfaces. If it does implement an interface, it will see whether any of the interfaces match the convention. The convention is that the interface type and the implementation type have to be in the same namespace and that the interface type has to match the name of the implementation, only prefixed with a capital <em class="ita ic">I</em>.</p>
			<p>The result of this will be a collection of types that matches the convention. Next, you’ll need to add code that registers the bindings. Add the following code after the previous code you added in<a id="_idIndexMarker394"/> the <strong class="source-in ine">AddBindingsByConvention()</strong> method:</p>
			<pre class="source-code">
foreach (var conventionBasedType in conventionBasedTypes)
{
    var interfaceToBind = types.All.Single(_ =&gt;
      _.IsInterface &amp;&amp; convention(_, conventionBasedType));
    if (services.Any(_ =&gt; _.ServiceType == interfaceTo
      Bind))
    {
        continue;
    }
    _ = conventionBasedType.HasAttribute
        &lt;SingletonAttribute&gt;() ?
        services.AddSingleton(interfaceToBind,
          conventionBasedType) :
        services.AddTransient(interfaceToBind,
          conventionBasedType);
}</pre>
			<p>The code loops through all the types that adhere to the convention and gets the actual interface and then binds it either as a singleton or transient based on whether or not the implementation has <strong class="source-in ine">SingletonAttribute</strong> or not.</p>
			<p>Let’s go and make all the services singleton using the attribute. Open the <strong class="source-in ine">Database.cs</strong> file <a id="_idIndexMarker395"/>and add <strong class="source-in ine">SingletonAttribute</strong> in front of the type declaration:</p>
			<pre class="source-code">
[Singleton]
public class Database : IDatabase
{
    // Keep your original code
}</pre>
			<p>Do the same for <strong class="source-in ine">UserDetailsService</strong>:</p>
			<pre class="source-code">
[Singleton]
public class UserDetailsService : IUserDetailsService
{
    // Keep your original code
}</pre>
			<p>And then do the same for <strong class="source-in ine">UsersService</strong>.</p>
			<pre class="source-code">
[Singleton]
public class UsersService : IUsersService
{
    // Keep your original code
}</pre>
			<p>All you now need to do is change the program startup. Open <strong class="source-in ine">Program.cs</strong> and change it to look like the following:</p>
			<pre class="source-code">
using Chapter10;
using Fundamentals;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
// Create an instance of Types and register it with the IoC
var types = new Types();
builder.Services.AddSingleton&lt;ITypes&gt;(types);
// Add all the bindings based on convention
builder.Services.AddBindingsByConvention(types);
var app = builder.Build();
app.UseRouting();
app.UseEndpoints(_ =&gt; _.MapControllers());
app.Run();</pre>
			<p>The code changes <a id="_idIndexMarker396"/>from all the explicit bindings of the different services to now leverage the <strong class="source-in ine">Types</strong> class from <strong class="bo d">Fundamentals</strong>, binding it as a singleton, and then adding all the bindings discovered by convention.</p>
			<p>Running your application should still give you the same behavior and it should work in the exact same way. The only difference is that everything is now by convention, and you can just add th<a id="_idTextAnchor175"/>ings without having to configure anything.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor176"/>Summary</h1>
			<p>In this chapter, you’ve tasted a little bit of how powerful conventions can be for concrete everyday C# coding, touching on how to improve the experience working with the IoC container in ASP.NET Core by optimizing a common scenario of registering services by their interface. We’ve also looked at how designing by contract helps you create a system that is more flexible and much easier to test.</p>
			<p>The concept of <em class="ita ic">convention over configuration</em> is probably the thing that has impacted me personally the most in my career. It makes your code more consistent and if you fail to be consistent, it doesn’t work, which is a good thing because then you will have to fix your code to be more consistent.</p>
			<p>Having to not configure everything and just be able to add code is a true productivity boost, and anyone working on the project will thank you for it. However, you need to be clear with all team members about what the conventions are, otherwise, they will not thank you at all. There is nothing worse than having your code work or not work seemingly arbitrarily. Document it and be clear about how things work.</p>
			<p>Also worth mentioning is that conventions are not for all projects and are not necessarily for all teams. For conventions to make sense, the team needs to accept that way of working. If the team prefers reading code and seeing everything explicitly set up, then conventions will only cause confusion. If the project is a very small one, it might not be worth the cognitive overhead.</p>
			<p>Coming up in the next chapter, we’ll get more into the open/closed principle, something we’ve touched on in this chapter, and see how it can benefit your code base.</p>
		</div>
	</body></html>