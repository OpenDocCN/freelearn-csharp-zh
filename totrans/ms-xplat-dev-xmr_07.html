<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;View Elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. View Elements</h1></div></div></div><p>In this chapter, you will find introductory information about <span class="strong"><strong>User Experience</strong></span> (<span class="strong"><strong>UX</strong></span>) design concepts and <a class="indexterm" id="id363"/>explanations on the differences and similarities of design principles on Xamarin platforms. Correlation between the UI elements will be illustrated and useful design patterns will be demonstrated with real-life examples to create a consistent user experience across platforms without compromising the native look-and-feel. This chapter is divided into the following sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Design philosophy</li><li class="listitem" style="list-style-type: disc">Design elements</li><li class="listitem" style="list-style-type: disc">User interaction</li></ul></div><div class="section" title="Design philosophy"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Design philosophy</h1></div></div></div><p>One of the biggest pitfalls while designing an application for cross-platform use is to impose the design patterns from one OS to the other one. In the mobile world, each platform and users of those platforms have certain expectations from an application. These expectations <a class="indexterm" id="id364"/>can be as insignificant as an icon on a common feature access button (for example, the share button on iOS and Android), or as important as the layout of a view (for example, tab buttons on the bottom and top of a view on iOS and Windows Phone, respectively). In this paradigm, the designer's responsibility becomes much more complex, since the design, while creating a brand for the application, would need to be inviting and appealing for the users of the platform.</p><div class="section" title="User expectations"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec91"/>User expectations</h2></div></div></div><p>Mobile platform users are creatures of habit. One of the key deciding factors of the adoption rate of a <a class="indexterm" id="id365"/>mobile application is how easy it is to use and how discoverable the features are for the platform users. It is important to remember that when users become acquainted with a specific platform, they will expect certain patterns and behaviors while interacting with that device. Trying to change these habits and forcing the users into usage patterns that they are not accustomed to might be costly.</p></div><div class="section" title="Platform imperatives"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Platform imperatives</h2></div></div></div><p>Both iOS and Windows Runtime have well-defined design guidelines that were refined over the years <a class="indexterm" id="id366"/>with the help of Microsoft's and Apple's experience on various software platforms. Android, being an open source development platform, has been searching for an identity since the early versions and it was a general implementation principle to design first on iOS and port the design to Android. However, with the release of Material Design guidelines by Google, the Android platform and app developers finally seem to have found a scheme to adhere to and create a unified experience on the Android platform across different applications.</p><p>With the emergence of minimalism and flat design patterns in software design, Microsoft was the pioneer to release the Microsoft design language (the Modern UI, codenamed Metro). Modern UI design heavily depended on typograph and geometry. The motto of this design pattern is "content over chrome", and application developers were encouraged to use the content itself to provide the interactivity and remove any unnecessary ornaments that are not crucial to the content or the functionality.</p><div class="mediaobject"><img alt="Platform imperatives" src="graphics/B04693_07_01.jpg"/><div class="caption"><p>Panorama View from Windows Phone 7</p></div></div><p>With the release of iOS 7, Apple joined the minimalist movement with an overhaul of their user interface, which is described by Jonathan Ive (Senior VP of Design) as bringing order to complexity. Translucency, typography, and layering were the highlighted features of this new design. It was a major change of Apple's design direction which, at the time, was famous for its skeuomorphic designs on various applications and platforms.</p><div class="mediaobject"><img alt="Platform imperatives" src="graphics/B04693_07_02.jpg"/><div class="caption"><p>iOS 7 Home Page and an Android dialog</p></div></div><p>Google's take <a class="indexterm" id="id367"/>on flat design principles, Material Design (codenamed Quantum Paper), tries to address the same type of design concerns by reducing the design elements to their very basics and recreating interactive surfaces with strong typography resembling paper and ink in essence.</p></div><div class="section" title="Hardware dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Hardware dependency</h2></div></div></div><p>Similar to web applications, on Xamarin target platforms, especially on Windows and Android, the hardware<a class="indexterm" id="id368"/> that the Xamarin application is going to<a class="indexterm" id="id369"/> be running or displayed on varies greatly. An application designed for a specific platform can be used on a low-end touchscreen device with a mediocre resolution or on a high-end phablet with an HD display on landscape or portrait rotations. This hardware dependency should be one of the main concerns while designing the UI for mobile applications.</p><p>For instance, pre-Android 3.0 phones used to have hardware buttons that helped with the navigation throughout<a class="indexterm" id="id370"/> the application and the OS itself. These buttons consisted of a back, menu, search, and home buttons. Even though the hardware buttons were replaced with the bottom system navigation bar (software buttons) on later devices, this trait is followed by Windows Phone devices that still have the back, Windows, and search hardware buttons. On iOS, the navigation hierarchy implementation is completely up to the application and generally handled by the back button placed on the top navigation bar.</p><div class="section" title="Design metrics on Android"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec16"/>Design metrics on Android</h3></div></div></div><p>For varying<a class="indexterm" id="id371"/> resolutions, in order to create an adaptive user interface, each platform uses different methodologies. However, in <a class="indexterm" id="id372"/>each platform, the important metric unit is the pixel density. Pixel density can be defined as the number of pixels that can fit into an inch in length. According<a class="indexterm" id="id373"/> to the pixel density (PPI or pixels per inch), independent from the total physical width and height of the screen, developers can create consistent views across various mobile devices. In other words, total screen resolution (pixel density multiplied by screen dimensions) is a declining trait that is taken into consideration while designing cross device/platform applications.</p><p>On the Android platform, to create a uniform experience on different pixel densities, developers and designers are encouraged to use density-independent pixels (dp) unit for expressing various dimensions and measurements of UI controls. Density-independent pixels are calculated by considering the 160 pixel density as a norm and calculating the display size in normalized pixel values.</p><p>Check out the following table for more information on Android density-independent pixels:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Screen Density</p>
</th><th style="text-align: left" valign="bottom">
<p>Density Bucket</p>
</th><th style="text-align: left" valign="bottom">
<p>Screen Resolution (pixels)</p>
</th><th style="text-align: left" valign="bottom">
<p>Screen Resolution (dp)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>120</p>
</td><td style="text-align: left" valign="top">
<p>LDPI</p>
</td><td style="text-align: left" valign="top">
<p>360 x 480</p>
</td><td style="text-align: left" valign="top">
<p>480 x 640</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>160</p>
</td><td style="text-align: left" valign="top">
<p>MDPI</p>
</td><td style="text-align: left" valign="top">
<p>480 x 640</p>
</td><td style="text-align: left" valign="top">
<p>480 x 640</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>240</p>
</td><td style="text-align: left" valign="top">
<p>HDPI</p>
</td><td style="text-align: left" valign="top">
<p>720 x 960</p>
</td><td style="text-align: left" valign="top">
<p>480 x 640</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>320</p>
</td><td style="text-align: left" valign="top">
<p>XHDPI</p>
</td><td style="text-align: left" valign="top">
<p>960 x 1280</p>
</td><td style="text-align: left" valign="top">
<p>480 x 640</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Android Density-Independent pixels (dp)</em></span></p></blockquote></div><p>In order to demonstrate the scaling and density independent pixels, we can compare the following views on different devices. Using the pixels to design the content would be visualized differently on different devices:</p><div class="mediaobject"><img alt="Design metrics on Android" src="graphics/B04693_07_03.jpg"/><div class="caption"><p>Using pixels to design the UI</p></div></div><p>However, if we <a class="indexterm" id="id374"/>were to use the same design <a class="indexterm" id="id375"/>elements with dp as the measurement unit, the UI would be<a class="indexterm" id="id376"/> much more uniform.</p><div class="mediaobject"><img alt="Design metrics on Android" src="graphics/B04693_07_04.jpg"/><div class="caption"><p>Using dp to design the UI</p></div></div><p>Similar to dp, another density-independent measure unit on Android is "sp", or scalable pixels. The main difference between dp and sp is that sp is scaled according to the user's font settings and generally associated with text content, while dp is managed by the operating system and the user generally does not have any control over it.</p><p>For media resources (for example, images) and layouts, the Android solution structure supports creating specialized design elements. Icons and other graphics can be provided in alternative sizes and resolutions using the correct density bucket identifier as a suffix to the <code class="literal">drawable</code> folder (for example, <code class="literal">drawable-xhdpi</code> for extra high density). Similarly, if needed, multiple alternative layouts can be provided according to the screen size groups in the layouts folder (for example, <code class="literal">layout-xlarge</code> or <code class="literal">layout-xlarge-land</code> for portrait and landscape displays on an extra-large screen).</p><div class="section" title="Design metrics on iOS"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec17"/>Design metrics on iOS</h4></div></div></div><p>In the iOS <a class="indexterm" id="id377"/>ecosystem, there are<a class="indexterm" id="id378"/> only a handful <a class="indexterm" id="id379"/>of devices and screen resolutions. On this platform, the identifier on display scaling is the point (pt) notation. A point is displayed as one physical pixel on a non-retina display. On retina display and higher configurations (iPhone 6 Plus), the scaling factor is calculated as 2x and 3x, respectively, while the point measurements are kept as they are.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>iPhone 6 Plus<a class="indexterm" id="id380"/> has the scale factor of 3 and screen resolution of 414 x 736 points. This would translate to 1242 x 2208 pixel<a class="indexterm" id="id381"/> resolution. However, the physical supported resolution on this device is 1080 x 1920. For this reason, images rendered (or rasterized) with the 3x scale<a class="indexterm" id="id382"/> factor are then down-sampled with a ratio of 1:1.15 on this device.</p></div></div></div><div class="section" title="Design metrics on Windows Runtime"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec18"/>Design metrics on Windows Runtime</h4></div></div></div><p>On Windows <a class="indexterm" id="id383"/>Runtime, the scaling of the application view is taken care of by the scaling algorithms that normalize the size<a class="indexterm" id="id384"/> of controls, fonts, and other UI elements. This<a class="indexterm" id="id385"/> normalization process occurs on the runtime and developers generally do not need to deal with it. When designing Windows Runtime applications, the measurement unit is pixels. However, the pixels are referred to as effective pixels. Effective pixels are the normalized size unit of the operating system.</p><div class="mediaobject"><img alt="Design metrics on Windows Runtime" src="graphics/B04693_07_05.jpg"/><div class="caption"><p>Effective Pixels on Windows Runtime</p></div></div><p>A common example for the effective pixels is to consider a font of size 24px. Text visualized with this font is displayed the same way on a phone 5-10 cm away from the user and on a surface hub couple of meters away.</p></div></div></div></div></div>
<div class="section" title="Design elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Design elements</h1></div></div></div><p>In order to create<a class="indexterm" id="id386"/> a consistent layout across platforms, while conforming to the platform requirements, developers and designers need to familiarize themselves with each platform and draw parallels between the layouts and UI controls on these platforms. We will discuss this in the next chapter within the scope of Xamarin.Forms. The existence of parallels between these platforms makes the foundation of the Xamarin.Forms framework.</p><div class="section" title="The basic layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec94"/>The basic layout</h2></div></div></div><p>The main layout elements in<a class="indexterm" id="id387"/> all three platforms are very similar to each other. However, the placement of these elements differs greatly according to the platform.</p><div class="mediaobject"><img alt="The basic layout" src="graphics/B04693_07_06.jpg"/><div class="caption"><p>The User Interface Layout</p></div></div><p>On each platform, the status bar displaying the system information is located at the top of the screen (marked as "1" in the preceding screenshot). This section is one of the constant elements that should be kept in mind when designing applications for Xamarin target platforms.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>On Windows 10 operating system, the system bar can be expanded on user's initiative to give detailed information about the system. This expansion causes the elements to be hidden on the application canvas. However, this does not cause elements to offset, and the expansion occurs on a different layer of the screen.</p></div></div><p>On all three platforms, the second element is generally the navigation bar (marked as "2" on the screenshot). This element is only used to display information about the current view on Windows Phone. However, on iOS and especially on Android, the navigation bar has additional functions. The navigation bar on iOS applications can be used for hierarchical navigational items. However, on the Android platform, the so-called app-bar contains the context-related commands and navigation items. The context menu presenting the additional context-related commands that do not fit on the main app-bar (navigation panel on the right-hand side) and the Navigation Drawer that reveals the left navigation panel are the functional and structural elements of the main app-bar on Android applications. Having application and content-related buttons or links on the title area on Windows Phone applications has been discouraged. However, on Windows 10, similar to the Navigation Drawer on the Android platform, developers can implement an application-level switch.</p><p>On Windows platform, context-related application commands and the additional items that are displayed inside a context menu are generally located at the bottom of the screen on the application bar (marked as "5"). Even though the application bar can be created on the top of the screen, this is generally a use case for applications that use the peer-to-peer/horizontal navigation patterns (refer to the next section, <span class="emphasis"><em>Navigation</em></span>).</p><p>The system navigation bar (marked as "4") is located at the bottom of the screen on the Android platform. This bar contains three buttons, namely Back, Home, and History. These buttons used to be hardware buttons prior to Android 4.0.</p><p>Instead of the bottom app-bar on Windows Phone and the system navigation bar on Android, on iOS this area is generally occupied by the tab bar (marked as "3"). The tab bar provides the main navigation functionality in iOS applications and should be available on each screen of the application (similar to the peer-to-peer navigation app-bar on Windows Phone).</p></div><div class="section" title="Navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Navigation</h2></div></div></div><p>In application design, the <a class="indexterm" id="id388"/>navigation strategy should be one of the first decision items. According to the requirements of the application or the elements to focus on, developers can adopt different navigations strategies.</p><p>While building the <a class="indexterm" id="id389"/>navigation tree and preparing the flowchart for the application, you can make use of two types of traverses: hierarchical (vertical) and peer-to-peer (horizontal). Horizontal navigation occurs when the user wants to navigate between pages that are on the same level of the navigation tree. Hierarchical navigation can be on either direction on the vertical path. As a rule of thumb, as the user navigates deeper, the number of similarly typed objects on the screen decreases and the details about a single object increases. In other words, it is rare to see list views in the lower nodes of a sub-tree in an app navigation hierarchy.</p><div class="mediaobject"><img alt="Navigation" src="graphics/B04693_07_07.jpg"/><div class="caption"><p>Navigation Hierarchy</p></div></div><p>On top of the<a class="indexterm" id="id390"/> traditional navigation methods, jump links among the pages on various levels and sub-trees can also be used to provide easy access to these nodes (for example, a Home link navigating from the bottom of the hierarchy back to the main page).</p><p>In order to demonstrate the navigation design, we will be creating an interface for the TravelTrace application that was used as an example for functional implementations in the previous chapters.</p><div class="section" title="Horizontal navigation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec19"/>Horizontal navigation</h3></div></div></div><p>Navigation between<a class="indexterm" id="id391"/> peers or siblings can provide an easy way to switch context between the items on the <span class="emphasis"><em>top level</em></span>. In this case, peers would be representing the main features of an application that should generally be accessible to the user at all times. On this level, the navigation can be implemented with tabbed controls or application-level navigation providers such as the Navigation Drawer on the Android platform. The homepage should have clear design and focus; it should make a statement about what your app is tailored to do.</p><p>For instance, if we were to use our travel application to demonstrate the top-level peers, we would first need to decide on the main features that the application has to offer.</p><p>Possible features<a class="indexterm" id="id392"/> of this travel companion application could be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get detailed information on nearby attractions</li><li class="listitem" style="list-style-type: disc">Allow users to plan their trips</li><li class="listitem" style="list-style-type: disc">Create and share travel memorabilia (photos, notes, tips, and so on)</li></ul></div><p>Identifying features of the application could be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a social medium to share and re-use travel experience</li><li class="listitem" style="list-style-type: disc">Assisting the user before and during travels and cultural visits</li></ul></div><p>Overall, we want to emphasize the social aspect and also provide personal assistance for users during their visits. In the light of this "decision", we can start designing the initial concept for our application.</p><div class="mediaobject"><img alt="Horizontal navigation" src="graphics/B04693_07_08.jpg"/><div class="caption"><p>Home Screen Sample</p></div></div><p>On the Windows <a class="indexterm" id="id393"/>Phone platform, the home screen can be either implemented as a hub or a pivot view. Although each view has similar navigational properties, pivot control is generally used to display segregated groups of content that carry similar traits.</p><p>Hence, it is generally preferable to use a hub view as a homepage to make different top level sections of the application available and sub-nodes easily discoverable.</p><div class="mediaobject"><img alt="Horizontal navigation" src="graphics/B04693_07_09.jpg"/><div class="caption"><p>Hub View (Windows Phone)</p></div></div><p>When considering Windows Phone and <code class="literal">HubView</code>, the only possible way of navigating between the top-level items in the hierarchy is a swipe gesture, while it is possible to tap on the tab bar buttons on the other platforms.</p><p>Another type of<a class="indexterm" id="id394"/> horizontal navigation can occur when navigating through different categories or filtered views of content items. On the Android platform, the main app-bar can host a filter dropdown to select the proper category to display content items. On iOS, the navigation bar, or a secondary bottom tool bar, can be used to create a button to display a picker (aka spinner) to select the proper sibling on the navigation tree. Another possible horizontal navigation provider control on iOS would be the <code class="literal">SegmentedView</code> control, which can be used to display different perspectives of the same type of content (for example, previous trips as opposed to future plans or recent guides and recent albums).</p><div class="mediaobject"><img alt="Horizontal navigation" src="graphics/B04693_07_10.jpg"/><div class="caption"><p>SegmentedView control on iOS</p></div></div><p>On the Windows<a class="indexterm" id="id395"/> platform, it is generally a better idea to choose a master/detail type of implementation for use-cases with more than "several" categories where the possible categories are always visible and displayed side-by-side with the content area. It is also possible to use a drop-down menu on a fly-out attached to one of the command bar buttons. If the number of categories is limited, the <code class="literal">PivotView</code> control can be employed in the view implementation.</p><div class="mediaobject"><img alt="Horizontal navigation" src="graphics/B04693_07_11.jpg"/><div class="caption"><p>Command bar flyout on Windows Phone</p></div></div><p>It is also possible, on all platforms, to include in-content selection controls that help the user navigate between the categories (dropdowns, pickers, spinners, hyperlinks, buttons, and so on).</p><p>For instance, a catalog view for our travel application that allows users to browse the uploaded content freely would need to categorize the country items on different continents.</p><div class="mediaobject"><img alt="Horizontal navigation" src="graphics/B04693_07_12.jpg"/><div class="caption"><p>Main App Bar Filter on Android</p></div></div><p>Finally, the Next/Previous buttons used on the top navigation bar and the main app-bar on iOS and Android, respectively, together with the swipe left/right gestures on Windows Phone, can create a pleasant experience when navigating between the siblings and/or collection items. This type<a class="indexterm" id="id396"/> of navigation is generally used at the bottom of the hierarchical navigation tree or at the bottom of a sub-tree.</p></div><div class="section" title="Vertical navigation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec20"/>Vertical navigation</h3></div></div></div><p>Elements that<a class="indexterm" id="id397"/> have a parent-child relationship (for example, the parent page can be the country view and the child views can be the city details) can use the vertical traversal of the navigation tree. The simplest and most common way of vertical traversal is navigating to the details view of a content element when the user clicks on the item.</p><p>A common mistake related to the details concept is to make it a two-step process where the user first needs to select the item and then click on a details command button. In modern applications, it is crucial to make the UI intuitive by means of using the content elements themselves as interaction elements.</p><p>Once the user is in the details view, backward navigation to ascend in the navigation tree is implemented either with a back button on the main app-bar (on Android) and the navigation bar (on iOS), or by using the hardware back button (on Windows Phone) and the soft back button on the system bar (on Android). It is not recommended to use an additional back button on the Windows Phone platform since the design real estate is already limited and the same functionality can be implemented with the hardware button, as opposed to its desktop counterpart where there is no hardware button and the design canvas is relatively generous.</p><div class="mediaobject"><img alt="Vertical navigation" src="graphics/B04693_07_13.jpg"/><div class="caption"><p>Semantic Zoom on Windows Phone</p></div></div><p>On the <a class="indexterm" id="id398"/>Windows Phone platform, another way of creating a different perspective on the content elements without having to implement a secondary view is to use the <code class="literal">SemanticZoom</code> control. The <code class="literal">SemanticZoom</code> control provides two views of the same list of content elements where the first one is generally a categorized view with a smaller number of elements and the second one is the full list view with additional details on content items. The navigation between the two views is generally implemented with pinch-in and pinch-out gestures (see the <span class="emphasis"><em>Gestures</em></span> section for details).</p></div><div class="section" title="Jump navigation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec21"/>Jump navigation</h3></div></div></div><p>Jump or cross <a class="indexterm" id="id399"/>navigation occurs when the application navigates between different nodes without conforming to the navigation hierarchy (for example, it is possible to navigate to the details view of an item that is on the third-level from the hub page that is on the top level of a Windows Phone application).</p><p>This type of navigation is generally used with very particular features that do not relate to the general outline<a class="indexterm" id="id400"/> of the application. The navigation commands can be included on the navigation bar or as hyperlinks embedded into the content. It is also common to use the command bars to create item related navigation links.</p><div class="mediaobject"><img alt="Jump navigation" src="graphics/B04693_07_14.jpg"/><div class="caption"><p>Navigation Drawer on Android</p></div></div><p>Another possible way to create navigation access points for switching the context in an easy way is to use the Navigation Drawer type functionality on Android. A similar experience can be achieved with the persistent tab bar on iOS. As mentioned before, comparable functionality was added to the Windows Phone platform with the release of Windows 10.</p></div></div><div class="section" title="Content elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Content elements</h2></div></div></div><p>Each Xamarin target <a class="indexterm" id="id401"/>platform puts forward certain strategies and guidelines to visualize the content. Although developers are <a class="indexterm" id="id402"/>given the freedom to create appealing and innovative design blocks, especially on the Android and Windows Phone platforms, there are strict guidelines to adhere to. We can group these content blocks and controls in several categories.</p><div class="section" title="Collection views"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec22"/>Collection views</h3></div></div></div><p>Collection views provide an efficient way to display collection-based content elements. In most implementation use cases, collection elements are interactive and display attributes of the<a class="indexterm" id="id403"/> content items with text and image controls. It is also common to add item-related commands or flags on the content items themselves in<a class="indexterm" id="id404"/> the shape of tokens (for example, the command to add an item to favorites, display a status icon, and so on).</p><div class="section" title="UITableView (iOS)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec01"/>UITableView (iOS)</h4></div></div></div><p>On the iOS platform, <code class="literal">UITableView</code> provides a flexible way to display collection data on a customizable layout. On a<a class="indexterm" id="id405"/> table view, each cell can be customized to display a batch of attributes from the content items and developers are free to make use of the inbuilt events and commands to implement additional command logic (for example, row actions).</p><div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_15.jpg"/><div class="caption"><p>Grouped table view &amp; table view with details</p></div></div><p>Another out-of-the-box feature of the <code class="literal">UITableView</code> and the associated controller (<code class="literal">UITableViewSource</code>) is the so-called indexing of the content elements. Indexing works in a similar way as the jump lists on the Windows platform and provides an easy way to catalog the content items and enables the user to easily jump into the correct section or the group.</p><p>A <a class="indexterm" id="id406"/>search display controller can also be associated with a <code class="literal">UITableView</code>, creating a standard iOS search experience on a collection of items.</p><p>Some of the possible artefacts that can be included in a table view cell by default are as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-a.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Checkmark</p>
</td><td style="text-align: left" valign="top">
<p>Signifies that the row is selected</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-b.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Disclosure indicator</p>
</td><td style="text-align: left" valign="top">
<p>Signifies that another table is associated with the row</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-c.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Detail disclosure indicator</p>
</td><td style="text-align: left" valign="top">
<p>Identifies that the user can click tosee details about the current row (for example, Popover)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-d.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Row reorder</p>
</td><td style="text-align: left" valign="top">
<p>Identifies that the row can be dragged to re-order</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-e.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Row insert</p>
</td><td style="text-align: left" valign="top">
<p>Adds a new row to the table</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-f.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Delete view/hide</p>
</td><td style="text-align: left" valign="top">
<p>Reveals or hides the delete button for the current row</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img alt="UITableView (iOS)" src="graphics/B04693_07_16-g.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Delete button</p>
</td><td style="text-align: left" valign="top">
<p>Deletes the row</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Table view artifacts</em></span></p></blockquote></div></div><div class="section" title="UICollectionView (iOS)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec02"/>UICollectionView (iOS)</h4></div></div></div><p><code class="literal">UICollectionView</code> is used to create a grid-like layout on the iOS platform. Collection views are also<a class="indexterm" id="id407"/> customizable using the in-built properties and base-classes. Collection views are more flexible in nature compared to the table views which are inherently bound by the table structure and contained cells.</p><p>Collection views are also made up of cells that can be displayed in numerous layouts. The default layout can be customized using a <code class="literal">UICollectionViewFlowLayout</code>. The flow layout can define parameters such as the minimum line spacing between the rows, the minimum interim spacing between the items, item sizes, and section insets (margins assigned to the sections in the collection).</p><p>The following code sample creates a simple flow layout structure:</p><div class="informalexample"><pre class="programlisting">UICollectionViewFlowLayout flowLayout = 
                          new UICollectionViewFlowLayout();
flowLayout.MinimumLineSpacing = 20f;
flowLayout.MinimumInteritemSpacing = 4f;
flowLayout.SectionInset = new UIEdgeInset(4f, 4f, 4f, 4f);
flowLayout.ItemSize = new SizeF(20f, 20f);
myCollectionView.CollectionViewLayout = flowLayout;</pre></div><p>Another option for customizing the layout of a collection view is to inherit the <code class="literal">UICollectionViewLayout</code> class and implement a custom layout. In the custom layout implementation, the class is responsible for providing the layout attributes such as the size and the location of the cells according to the collection size and available layout area.</p><p><code class="literal">UICollectionViewController</code> is used to normalize the data that is to be presented and act as a delegate for the collection and item level events such as cell selection and context menus.</p><p>Additionally, the <code class="literal">SupplementaryView</code> and <code class="literal">DecorationView</code> classes provide additional customizations by giving section related details and UI customizations on the collection view layer.</p></div><div class="section" title="ListView (Android)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec03"/>ListView (Android)</h4></div></div></div><p><code class="literal">Listview</code> is one of the <a class="indexterm" id="id408"/>most overused components on the Android Platform. While it can be used to display a relatively small list of menu items, with adapters it can also be used to visualize data from other applications and services. It is possible to compare the <code class="literal">ListView</code> control to the <code class="literal">UITableView</code> control on the iOS platform and the data provider interfaces. Adapters on Android can be compared to <code class="literal">UITableViewSource</code> on iOS.</p><p>By default, <code class="literal">ListView</code> has 12 built-in views that can be accessed through the <code class="literal">Android.Resource.Layout</code> class. These layouts vary from simple single line of text to expandable grouped category views. Each layout uses several control references such as Text1, Text2, and Icon, which<a class="indexterm" id="id409"/> should be populated by the adapter assigning the values to the content fields. Implementing a custom layout is also possible by creating an AXML markup file and later referencing the markup in the adapter.</p><p>A sample custom layout implementation could look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;RelativeLayout 
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
<span class="strong"><strong>    android:background="@drawable/CustomSelector"</strong></span>
    android:padding="8dp"&gt;
    &lt;LinearLayout
        android:id="@+id/Text"
        android:orientation="vertical"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:paddingLeft="10dip"&gt;
        &lt;TextView
            android:id="@+id/Title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="20dip" /&gt;
        &lt;TextView
            android:id="@+id/Description"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14dip" /&gt;
    &lt;/LinearLayout&gt;
    &lt;ImageView
        android:id="@+id/Image"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:padding="5dp"
        android:src="@drawable/icon"
        android:layout_alignParentRight="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div><p>We can also extend the style by adding visual state selectors (see the background color assignment in the previous sample).</p><p>The custom visual state selector implementation could be defined as the following:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;selector &gt;
  &lt;item android:state_pressed="false"
        android:state_selected="false"
        android:drawable="@color/blue" /&gt;
  &lt;item android:state_pressed="true"
        android:state_selected="false"
        android:drawable="@color/red" /&gt;
&lt;/selector&gt;</pre></div><p>Finally, the list adapter implementation would look <a class="indexterm" id="id410"/>like:</p><div class="informalexample"><pre class="programlisting">    public class CountriesDataAdapter : BaseAdapter&lt;Country&gt;
    {
        private List&lt;Country&gt; m_Items;

        private Activity m_Context;

        public CountriesDataAdapter(Activity context, List&lt;Country&gt; items)
        {
            m_Context = context;
            m_Items = items;
        }

        public override long GetItemId(int position)
        {
            return position;
        }

        public override View GetView(int position, View convertView, ViewGroup parent)
        {
            var item = m_Items[position];

            View view = convertView ?? 
m_Context.LayoutInflater
.Inflate(Resource.Layout.CustomRowView, null);

            view.FindViewById&lt;TextView&gt;(Resource.Id.Title).Text = item.Name;
            view.FindViewById&lt;TextView&gt;(Resource.Id.Description).Text = string.Format("In {0} region of {1}", item.Region.Name, item.Region.Continent);
            view.FindViewById&lt;ImageView&gt;(Resource.Id.Image).SetImageResource(Resource.Drawable.Icon);

            return view;
        }

        public override int Count
        {
            get { return m_Items.Count; }
        }

        public override Country this[int position]
        {
            get { return m_Items[position]; }
        }
    }</pre></div><p>The preceding code<a class="indexterm" id="id411"/> should generate a view similar to the following screenshot:</p><div class="mediaobject"><img alt="ListView (Android)" src="graphics/B04693_07_17.jpg"/><div class="caption"><p>List View with custom layout</p></div></div></div><div class="section" title="GridView (Android)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec04"/>GridView (Android)</h4></div></div></div><p>Other than the <code class="literal">ListView</code> control, on the Android platform, collections can be visualized in <code class="literal">ViewGroup</code>. View groups are used to bundle different visual trees and display the items in a scrollable<a class="indexterm" id="id412"/> view element. The most common implementation of the <code class="literal">ViewGroup</code> is the <code class="literal">GridView</code> widget. <code class="literal">GridView</code> is a scrollable grid control where content items are again provided with a <code class="literal">ListAdapter</code> implementation.</p><p><code class="literal">GridView</code> is generally used with a homogenous set of content items. These content items consist of a set of text content and a related image item. Content items are generally referred to as tiles and they can also include several content related commands.</p><p>Tiles are conceptually similar to the live tile blocks of Modern UI design of Windows applications. They are made up of primary and secondary content. The primary content fills the entire cell (for example, album cover in a photo gallery application), while the secondary is represented by icons or text. The primary action is, in most cases, a vertical descending navigation command (navigating to the details view). Context actions related to the content item are <a class="indexterm" id="id413"/>generally considered to be the secondary content on a tile.</p><p>If the amount of actions on a content item or the content is not homogenous, it is advised to consider using cards rather than tiles in a grid view.</p></div><div class="section" title="CardView (Android)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec05"/>CardView (Android)</h4></div></div></div><p>The <code class="literal">CardView</code> control was introduced in Android 5.0, and it can be described as a self contained content unit. The term self-contained here would refer to the fact that cards generally include<a class="indexterm" id="id414"/> multiple actions and various content-related items. Users generally do not need to resort to secondary actions (select and then use the context menu) to interact with these content items.</p><div class="mediaobject"><img alt="CardView (Android)" src="graphics/B04693_07_18.jpg"/><div class="caption"><p>A standard card layout</p></div></div><p>Cards are generally used when there is neither the need nor the possibility for direct comparison between the collection elements and the content consists of various types of data. Cards can be interactive through the use of action buttons or, in some cases, in-content input controls. They can be expandable and generally have a fixed width.</p><p><code class="literal">CardView</code> is implemented as a <code class="literal">FrameLayout</code> widget and can be used in association with a <code class="literal">ListView</code> or <code class="literal">GridView</code> to<a class="indexterm" id="id415"/> represent content elements.</p></div><div class="section" title="ListView and ListBox (Windows Phone)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec06"/>ListView and ListBox (Windows Phone)</h4></div></div></div><p><code class="literal">ListView</code> and <code class="literal">ListBox</code> are the main collection visualization controls on the Windows Phone platform. <code class="literal">ListView</code> is a more specialized implementation of <code class="literal">ListBox</code>, and it is primarily used for displaying<a class="indexterm" id="id416"/> text-based content. Its counterpart <code class="literal">ListBox</code> is highly customizable and can be adopted to display content composed of multiple data types.</p><p>Both of these containers can be used for item-level context actions. However, <code class="literal">ListBox</code>, similar to <code class="literal">CardViews</code> on the Android platform, is used to create interactive content elements that might include actions and input controls.</p><p>Two-way data binding is available for both of these controls and items can be styled and customized using behaviors, item templates, and/or control styles. Orientation is vertical by default for both controls, but this can be set to horizontal if the content items are desired to be displayed on a horizontal line.</p><p>In case there is the need for more customization on the template level and how the items are laid out, developers can also use the <code class="literal">ItemsControl</code>, which is the base implementation for most of the collection views on the Windows Phone platform.</p><p>In order to customize how the items are displayed on a <code class="literal">ListView</code>, we would first need to create the <code class="literal">DataTemplate</code> that will be the template used for <code class="literal">ListViewItems</code>.</p><p>A sample DataTemplate declaration could look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;DataTemplate x:Key="SampleItemTemplate"&gt;
  &lt;Grid&gt;
    &lt;Grid.ColumnDefinitions&gt;
      &lt;ColumnDefinition Width="Auto" /&gt;
      &lt;ColumnDefinition /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Border Margin="0,10,0,0"&gt;
      &lt;Image Source="{Binding ImageUrl}" Height="80" Width="80" /&gt;
    &lt;/Border&gt;
    &lt;StackPanel Grid.Column="1" Margin="15,0,0,0"&gt;
      &lt;TextBlock Text="{Binding Title}"
        Style="{ThemeResource ListViewItemTextBlockStyle}" /&gt;
      &lt;TextBlock Text="{Binding Subtitle}"
        Style="{ThemeResource ListViewItemSubheaderTextBlockStyle}" /&gt;
    &lt;/StackPanel&gt;
  &lt;/Grid&gt;
&lt;/DataTemplate&gt;</pre></div><p>Once our template is ready, we can assign the template to our <code class="literal">ListView</code> together with the collection data source, which is a list of simple <code class="literal">SampleItem</code> objects with the properties described in the <code class="literal">DataTemplate</code>.</p><p>The code is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;Grid&gt;
  &lt;ListView
    ItemTemplate="{StaticResource SampleItemTemplate}"
    ItemsSource="{Binding MyItems}" /&gt;
&lt;/Grid&gt;</pre></div><p>Now, the content<a class="indexterm" id="id417"/> items are displayed in the <code class="literal">ListView</code> in a two-column style with an image, title, and description text.</p></div><div class="section" title="GridView (Windows Phone)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec07"/>GridView (Windows Phone)</h4></div></div></div><p><code class="literal">GridView</code> is another implementation <a class="indexterm" id="id418"/>of the <code class="literal">ItemsControl</code> on the Windows Phone platform, which allows the developers to create collection views in a flow layout. <code class="literal">GridView</code> should generally be preferred over <code class="literal">ListBox</code> or <code class="literal">ListView</code> when dealing with media elements.</p><div class="mediaobject"><img alt="GridView (Windows Phone)" src="graphics/B04693_07_19.jpg"/><div class="caption"><p>ListView versus GridView</p></div></div><p>Similar to the<a class="indexterm" id="id419"/> previously defined elements, <code class="literal">GridView</code> supports two-way data binding and can be customized using standard methodologies.</p></div><div class="section" title="Virtualizing panels (Windows Phone)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec08"/>Virtualizing panels (Windows Phone)</h4></div></div></div><p>It is important to <a class="indexterm" id="id420"/>realize the fact that mobile platforms are not as performant as desktop or tablet devices. Especially when dealing with big sets of data, even though applications can perform well visually on a desktop workstation, memory resources might cause the UI to flicker, lag, or even block on a mobile device. In order to decrease the memory usage and improve performance by means of loading only the needed data, Windows Runtime provides the virtualizing panel controls (for example, <code class="literal">VirtualizingStackPanel</code>). <code class="literal">ItemsControl</code>, which is the base for most of the collection view controls described here, supports both data and UI virtualizations.</p><div class="mediaobject"><img alt="Virtualizing panels (Windows Phone)" src="graphics/B04693_07_20.jpg"/><div class="caption"><p>UI Virtualization on Windows Runtime</p></div></div><p>UI virtualization deals with the controls being rendered on the application viewport. The application list view bound to a large number of items, in this case, does not need to render and keep the controls in the runtime memory but only deal with the ones that are in the viewport. In this paradigm, controls that are removed from the screen with a scrolling action need to be destroyed and redrawn if the user scrolls back.</p><p>Data virtualization <a class="indexterm" id="id421"/>deals with paged data sources. For instance, with a "virtualizable" data source (a collection that implements <code class="literal">ISupportIncrementalLoading</code>), only the data needed for the current viewport is loaded into the application and additional batches are requested from the data source when the UI control needs to display additional items. Random access virtualization lets developers retrieve a subset of data on any random ordinal. For this type of data virtualization, the data source needs to implement <code class="literal">INotifyCollectionChanged</code> and <code class="literal">IObservableVector</code>.</p></div></div><div class="section" title="Modal views"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec23"/>Modal views</h3></div></div></div><p>Modal views are temporary view components that can provide an interactive interface to get the user's input <a class="indexterm" id="id422"/>on a certain task or decide on the execution path of <a class="indexterm" id="id423"/>a workflow. It is also common to use alert dialogs to inform the user about critical information that is crucial for the execution of the application.</p><div class="section" title="Popover and alerts (iOS)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec09"/>Popover and alerts (iOS)</h4></div></div></div><p>The iOS platform <a class="indexterm" id="id424"/>provides various modal dialogs to display, edit, and manipulate data in different scenarios. Each of these dialog types look different but the common denominator is the fact that they always get the focus and are displayed on the highest layer on the screen, while the content under the dialog is hidden with a translucent overlay layer.</p><p>Action sheets are one<a class="indexterm" id="id425"/> of the most-frequently used modal dialogs. This dialog type is generally used to give the user an option before starting a task or cancelling the task. It is generally displayed as a list of buttons; the last of which is generally the "cancel" button, at the bottom of the screen.</p><div class="mediaobject"><img alt="Popover and alerts (iOS)" src="graphics/B04693_07_21.jpg"/><div class="caption"><p>Action sheet display on iOS</p></div></div><p>Action sheets can <a class="indexterm" id="id426"/>be initialized using a <code class="literal">UIAlertController</code> and specifying the <code class="literal">UIAlertControllerStyleActionSheet</code>. If the screen size permits (on a horizontally regular environment), action sheets are displayed as a popover.</p><p>Alert dialogs are another<a class="indexterm" id="id427"/> type of modal dialogs on iOS. Alerts are generally used to inform or ask consent from the user about an issue that affects the execution of the application. Unlike action sheets, alert dialogs can contain descriptive text, a title, and even a text input field.</p><div class="mediaobject"><img alt="Popover and alerts (iOS)" src="graphics/B04693_07_22.jpg"/><div class="caption"><p>Alert dialog with input field and with only description and title</p></div></div><p>Alert dialogs can be invoked with <code class="literal">UIAlertController</code>, using the <code class="literal">UIAlertControllerStyleAlert</code>. Alert dialogs should avoid any kind of redundant, informal, and negative content. If the title provides enough information for the user to continue with the execution, description text could be omitted.</p><p>Popovers are another type of temporary context views on the iOS platform. However, popovers only are<a class="indexterm" id="id428"/> displayed on a horizontally regular environment (in both portrait and landscape in iPad, and only in landscape rotation in iPhone 6 Plus). In horizontally compact environments, they are displayed as full screen modal dialogs.</p><p>In order to initialize a popover, <code class="literal">UIPopoverPresentationController</code> can be used.</p><p>Modal dialogs are another type of temporary view display used on iOS. Modal dialogs can be used in scenarios where a self-contained and compact view is needed to execute a very particular task or workflow.</p><div class="mediaobject"><img alt="Popover and alerts (iOS)" src="graphics/B04693_07_23.jpg"/><div class="caption"><p>Modal dialog with page sheet style</p></div></div><p>Modal dialogs can be created using the <code class="literal">UIPresentationController</code> with various modal presentation styles (full screen, page sheet, form sheet, and current context). However, the <a class="indexterm" id="id429"/>presentation styles associated with modal dialogs behave almost the same on horizontally compact environments (all iPhone models except iPhone 6 Plus in landscape orientation).</p></div><div class="section" title="Flyout, popups, and menus (Windows Phone)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec10"/>Flyout, popups, and menus (Windows Phone)</h4></div></div></div><p>Flyouts are the main<a class="indexterm" id="id430"/> modal dialogs on the Windows Phone platform. They can be used in various scenarios, including showing a context menu, showing additional details of an item, or getting consent from the user. The common behavior of different types of flyouts is that they are <a class="indexterm" id="id431"/>always displayed with the highest z-index on screen and the elements underneath are disabled with a translucent overlay. Flyouts have, by default, a light-dismiss <a class="indexterm" id="id432"/>mechanism. In other words, they can be dismissed if the user taps anywhere outside the flyout control's borders.</p><p>Flyouts are generally associated with another control on the current view either by using the attached properties or using the <code class="literal">ShowAt</code> function of the <code class="literal">Flyout</code> class. The Content property of the Flyout class is used to assign a <code class="literal">UIElement</code> to display on screen.</p><div class="informalexample"><pre class="programlisting">    var flyout = new Flyout();
    var stackPanel = new StackPanel { Orientation = Orientation.Vertical, Margin = new Thickness(5)};
    var textBlock = new TextBlock { Text = "Flyout Text Content", FontSize = 20 };
    var textInput = new TextBox { PlaceholderText = "Input Value", FontSize = 18 };
    var button = new Button { Content = "Apply", FontSize = 18 };
    stackPanel.Children.Add(textBlock);
    stackPanel.Children.Add(textInput);
    stackPanel.Children.Add(button);
    flyout.Content = stackPanel;
    flyout.ShowAt(TextBlock);</pre></div><p>The preceding sample <a class="indexterm" id="id433"/>code would create a flyout which has<a class="indexterm" id="id434"/> text content, an input field, and a<a class="indexterm" id="id435"/> button as its content:</p><div class="mediaobject"><img alt="Flyout, popups, and menus (Windows Phone)" src="graphics/B04693_07_24.jpg"/><div class="caption"><p>Simple flyout menu on Windows Phone</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>In spite of the fact that flyouts are always attached to a <code class="literal">UIElement</code> (either using XAML or through code) and the dialog should be displayed in the vicinity of the associated element, on Windows Phone, flyouts behave like message dialogs displaying on the top of the screen.</p></div></div><p>In Windows Runtime, it is possible to use the derived types of flyouts for specific scenarios. <code class="literal">MenuFlyout</code>, <code class="literal">TimePickerFlyout</code>, and <code class="literal">DateTimePickerFlyout</code> are examples for these implementations.</p><div class="mediaobject"><img alt="Flyout, popups, and menus (Windows Phone)" src="graphics/B04693_07_25.jpg"/><div class="caption"><p>Menu Flyout Usage</p></div></div><p>Other than flyouts, popup control can also be used to display a temporary view or details of a content item. Popups <a class="indexterm" id="id436"/>are generally stand-alone controls and can directly be included in the view XAML. They can optionally use light-dismiss and can be shown or hidden using the <code class="literal">IsOpen</code> property.</p><p>For alert dialogs <a class="indexterm" id="id437"/>or critical input requirements, the <code class="literal">MessageDialog</code> class provides developers a familiar implementation tool. <code class="literal">MessageDialog</code> is a simple dialog used to display text content and numerous UI commands. The <code class="literal">UICommand</code> class represents a button and the associated action (if any) and is used to display actions on the dialog and provide a result to the dialog once selected by the<a class="indexterm" id="id438"/> user. The following implementation creates a message dialog with a text field and two commands:</p><div class="informalexample"><pre class="programlisting">MessageDialog dialog = new MessageDialog("You are about to delete an important item", "Important Deletion");
dialog.Commands.Add(new UICommand("Sure"));
dialog.Commands.Add(new UICommand("Not Really"));
dialog.ShowAsync();</pre></div><p>This would be shown on the UI similar to how flyouts are visualized:</p><div class="mediaobject"><img alt="Flyout, popups, and menus (Windows Phone)" src="graphics/B04693_07_26.jpg"/><div class="caption"><p>MessageDialog example on Windows Phone</p></div></div></div><div class="section" title="Dialogs (Android)"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec11"/>Dialogs (Android)</h4></div></div></div><p>Dialogs on Android can be implemented as simple as an alert dialog or a full screen dialog that<a class="indexterm" id="id439"/> retrieves the required form data to continue the current task. Dialogs behave the same way as modal dialog implementations on other platforms; they interrupt the current task and are displayed on top of the underlying layer. The content underneath is hidden with a translucent grey overlay layer.</p><p>Simple alert dialogs, like their parallel implementations on other platforms, consist of a title, a descriptive content, and confirmation actions. They are invoked on critical scenarios where the user's input is crucial to continue with the execution.</p><div class="mediaobject"><img alt="Dialogs (Android)" src="graphics/B04693_07_27.jpg"/><div class="caption"><p>Android Alert Dialog</p></div></div><p>It is important to be careful to avoid any ambiguity in the descriptive content and the action button contents.</p><p>Another popular dialog used in Android applications are the context menu dialogs. This type of dialog does not require any confirmation once the item from the list is selected. They also have the light dismiss behavior. If the dialogs have additional information about the selection<a class="indexterm" id="id440"/> item and maybe additional actions, they are referred to as simple dialogs. The selection on these dialogs do not require confirmation either.</p><div class="mediaobject"><img alt="Dialogs (Android)" src="graphics/B04693_07_28.jpg"/><div class="caption"><p>Android Dialogs</p></div></div><p>If the dialog implementation requires the user to explicitly confirm the choice made, these dialogs are generally referred to as confirmation dialogs. It is common to have a "cancel" button at the bottom of the dialog screen so the previous selected option can be kept.</p></div></div><div class="section" title="Text views"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec24"/>Text views</h3></div></div></div><p>On all three platforms, with the emergence of the minimalist design inclinations, typography and text <a class="indexterm" id="id441"/>content items became the focus of UX design. Each platform has well-defined guidelines on font sizes and typefaces for different scenarios. More importantly, each of these platforms has specialized ways to display and edit rich text formats.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Windows</strong></span>: On the Windows Phone platform, Run elements are used to define specific sections of text that have a certain formatting applied to. Run elements can then be included in <code class="literal">TextBlock</code> elements or <code class="literal">RichTextBlock</code> controls. In<a class="indexterm" id="id442"/> addition to the Runs, <code class="literal">RichTextBlocks</code> can be used in conjunction with html-like styling elements (for example, bold, span, italics, and so on). Using the <code class="literal">RichTextBlocks</code> and <code class="literal">RichTextBlockOverflow</code> as a container, any shape and style text displays can be supported in Windows Phone applications.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Android</strong></span>: On the <a class="indexterm" id="id443"/>Android platform, text formatting is achieved using the so-called spans. There are numerous pre-styled span implementations such as <code class="literal">RelativeSizeSpan</code>, <code class="literal">ForegroundColorSpan</code>, and <code class="literal">ClickableSpan</code>. These span implementations are used to set certain sections of a <code class="literal">SpannableString</code> with the described styles. There is a <code class="literal">SpannableStringBuilder</code> class that can be used to create the styled paragraphs/text content. Once the <code class="literal">SpannableString</code> is complete, it can be used as content for the <code class="literal">TextView</code> control.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>iOS</strong></span>: On the iOS platform, text-related features and controls are introduced by the Core Text<a class="indexterm" id="id444"/> library. The <code class="literal">UITextView</code> control is the visualization element in this library. Text formatting is achieved by using the <code class="literal">NSMutableAttributedText</code> class. For attributed text content, different text ranges can be set to use certain attributes such as <code class="literal">NSUnderlineStyleAttribute</code>, <code class="literal">NSBackgroundColorAttribute</code>, and so on. When displaying attributed text blocks a <code class="literal">NSTextContainer</code> can be used to describe a shape as line fragments in which the text should be displayed.</li></ul></div></div><div class="section" title="Web views"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec25"/>Web views</h3></div></div></div><p>Web view <a class="indexterm" id="id445"/>controls are used to display rich HTML content on Xamarin target platforms. These web view controls build their own navigation stack independent from the application runtime. On Android and Windows phone, it is also possible to inject JavaScript into the HTML content that is being displayed on the control.</p><p>On all the<a class="indexterm" id="id446"/> platforms, it is possible to load not only remote, but also local web applications from the application resources.</p></div></div><div class="section" title="Feedback"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Feedback</h2></div></div></div><p>One of the pillars of modern application design is keeping the user informed at all times about the actions<a class="indexterm" id="id447"/> being executed by the application and the progress of these tasks. Even if the application is dealing with a blocking call (the execution cannot continue before finishing the task), displaying a progress ring creates the illusion that the <a class="indexterm" id="id448"/>application is still responsive.</p><p>Progress indicators can be categorized into two groups: indeterminate and determinate.</p><div class="section" title="Indeterminate progress"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Indeterminate progress</h3></div></div></div><p>Indeterminate tasks and the associated progress indicators are related to the operations where the<a class="indexterm" id="id449"/> application cannot provide neither an estimated completion time nor progress information. These operations might depend on completion of multiple sub-procedures and might be related to the whole application or only a single UI element.</p><p>With indeterminate processes, we first need to decide on how crucial the process is for the application. If the application cannot continue without completing the current process, this would be an application-level blocking call. In cases of blocking calls (involving single step or multiple steps), it is a good idea to use a progress ring on the main content area. A good example for this scenario would be a main client trying to retrieve e-mail messages from the server without knowing how many items there are on the server. If there are multiple steps involved in this process, you can additionally show an information text near or over the progress ring.</p><p>This implementation on Android can be achieved with the <code class="literal">ProgressDialog</code> class. Instantiating this control provides a modal dialog with the possibility to include a descriptive text. It is important to set the indeterminate flag to true before displaying it on the UI.</p><div class="mediaobject"><img alt="Indeterminate progress" src="graphics/B04693_07_29.jpg"/><div class="caption"><p>Progress rings on Android, iOS and Windows Phone</p></div></div><p>On iOS, the same visualization is achieved with the <code class="literal">UIActivityIndicatorView</code>. You can modify the behavior to animate and change the color.</p><p>On Windows Phone, the <code class="literal">ProgressRing</code> class provides the same type of functionality.</p><p>In indeterminate scenarios where the process being executed does not stop the user from continuing with application interaction, it is better to give a more subtle indication about the process and<a class="indexterm" id="id450"/> the controls involved in the execution. This can be achieved by using a progress ring or a bar in the vicinity of or over the control where the process started. On iOS, the only distinction between the progress bar and the ring is the process being determinate or indeterminate. However, on Android and Windows Phone, a progress bar can also act as an indeterminate task indicator. On the Windows Phone platform, it is also general practice to display an indeterminate progress bar on top of the screen if the process is an application level task, but the interaction with the application can continue without waiting for the result of this process.</p></div><div class="section" title="Determinate progress"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec27"/>Determinate progress</h3></div></div></div><p>Determinate tasks and associated indicators are related to processes where the application can provide a current <a class="indexterm" id="id451"/>state information to the user. A determinate progress indicator of choice on Xamarin target platforms is the progress bar. Progress bars, while providing a visual indication of the current completion state of the process, can also include a label giving a text description of the current state of the task.</p><p>It is important to also provide a cancellation method (for example, a cancel button near the progress bar) if the process is relatively long.</p><div class="mediaobject"><img alt="Determinate progress" src="graphics/B04693_07_30.jpg"/><div class="caption"><p>Android determinate progress bar displays</p></div></div><p>On the Android platform, in addition to the progress indication, a buffering percentage can also be displayed on the progress bar.</p></div></div></div>
<div class="section" title="User interaction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>User interaction</h1></div></div></div><p>Another important element in cross-platform development projects is the set of user interaction patterns for the application. Users already using the application on other platforms would <a class="indexterm" id="id452"/>want to find the same interaction patterns on clients running on another platform. This decision process gets even more complicated with platform specific interaction patterns, since the application should provide a familiar interface for platform users. It is important to achieve a balanced compromise between platform nativity and application identity in such scenarios and find the optimum solution.</p><p>A good example for branding by means of using an interaction pattern, would be the "pull-to-refresh" interactive pattern used in iOS applications. Most application providers dealing with information feeds (for example, Facebook, Twitter, and so on) used this implementation in their iOS applications. Even though this is not a native interaction pattern on Android and Windows Phone, a similar approach quickly became popular on these platforms; hence, most developers and users are now adopting this use-case on various platforms.</p><div class="section" title="Interactive controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Interactive controls</h2></div></div></div><p>In most cases, applications built for Xamarin target platforms would require input and other interactive<a class="indexterm" id="id453"/> controls to collect necessary information from<a class="indexterm" id="id454"/> the user. By interactive, we are referring to almost all the UI controls that can be used in a Xamarin application. In this case, even a simple filter dropdown control to select a different view perspective would be an interaction control, requesting information from the user display appropriate data or perspective.</p><div class="section" title="Text input"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec28"/>Text input</h3></div></div></div><p>Text input fields are<a class="indexterm" id="id455"/> one of the most used type of input fields. Text fields can be implemented as a single line of text or as a multiline. An important aspect of text fields is the fact that as soon as a text input field gets selected on a touch-enabled device, the virtual keyboard appears on the screen. It is generally a good idea to keep this in mind while designing the user interface and implementing it later on.</p><p>On iOS, while the <code class="literal">UITextField</code> provides an input mechanism for single line of text requirements, <code class="literal">UITextView</code> can be used to create editable rich text content. Both of these controls provide options such as capitalization and correction.</p><div class="mediaobject"><img alt="Text input" src="graphics/B04693_07_31.jpg"/><div class="caption"><p>UITextView Edit and Read-only Views</p></div></div><p>Additionally, <code class="literal">UITextView</code> provides detectors that can transform Internet addresses to links, addresses to<a class="indexterm" id="id456"/> map links, phone numbers into deep-links to make a phone call, and date/time values to calendar event items.</p><p>Android text input fields are similar to the ones on iOS platform. The key difference is that on Android, instead of two different controls, only the <code class="literal">EditText</code> control exists for multiline and single line text inputs. This is achieved by settings the <code class="literal">InputType</code> property of the control (or <code class="literal">inputType</code> attribute in AXML). Other input scopes, besides the text format, can be set such as postal address, capitalized words, autocorrect, and capitalized sentence beginnings. Note that these scope parameters are bit-wise combinations. Another specialized control that provides auto suggestions is the <code class="literal">AutoCompleteTextView</code>, to which developers can assign an <code class="literal">ArrayAdapter</code> as a source for suggestions.</p><p>On Windows Phone, <code class="literal">TextBox</code> is the most commonly used text input control. It can be highly customized to meet the previously mentioned requirements. Moreover, the input scope field lets developers control the virtual keyboard displayed for entering the value. For instance, setting<a class="indexterm" id="id457"/> the scope to be a telephone number would display a keyboard with only digits. <code class="literal">AutoSuggestBox</code>, <code class="literal">PasswordBox</code>, and <code class="literal">RichEditBox</code> are other controls that can be used for more specialized scenarios.</p></div><div class="section" title="Dropdown selection"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec29"/>Dropdown selection</h3></div></div></div><p>Dropdown <a class="indexterm" id="id458"/>elements can be used, on each platform, utilizing the specialized controls. While the <code class="literal">UIPickerView</code> is used on iOS, the same implementation is achieved on Android by so-called spinners. Spinners, very much like other content-driven controls, are populated with a <code class="literal">SpinnerAdapter</code>.</p><div class="mediaobject"><img alt="Dropdown selection" src="graphics/B04693_07_32.jpg"/><div class="caption"><p>Dropdown controls on iOS, Android and Windows Phone</p></div></div><p>In addition to the spinner control, simple menu dialogs can also be used for users' input. Windows Runtime provides additional specialized controls, the <code class="literal">ComboBox</code> and <code class="literal">ListView</code>, for different selection use cases.</p></div><div class="section" title="Option selection"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec30"/>Option selection</h3></div></div></div><p>Similar to the<a class="indexterm" id="id459"/> radio or check boxes on HTML forms, each platform provides options related UI elements. On Android, specialized controls for this scenario are Checkbox, RadioButton, and ToggleButton. Starting with Android 4.0 (API 14), Switch control can also be used. Other than the visual difference between these controls, the behavior is the same. On iOS, the main toggle control for Boolean data types is the Switch. Similar to Android, Windows Phone offers checkbox, radio button, and toggle switch control with option selections and Boolean types.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>There are many other controls on each platform, and each provides a specific use case for different UI interaction scenarios. UX guides for Windows Runtime and Material Design are great resources for the respective platforms. Even though the Apple human<a class="indexterm" id="id460"/> interface design documents do not provide extensive UX guidelines as the other platforms, they are great resources to learn about user control use cases.</p></div></div></div></div><div class="section" title="Gestures"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Gestures</h2></div></div></div><p>When developing for Xamarin target platforms, you should always keep in mind that the devices that are <a class="indexterm" id="id461"/>going to run the application will most probably have a touchscreen.</p><p>Touchscreen devices, apart from the classic pointer-like gestures (for example, tap, double tap, scroll, and so on), also provide various interaction gestures that help developers create an interface that can interact with the user in a more natural way.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td rowspan="11" style="text-align: left" valign="top">
<div class="mediaobject"><img alt="Gestures" src="graphics/B04693_07_33.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Tap</p>
</td><td style="text-align: left" valign="top">
<p>In most <a class="indexterm" id="id462"/>scenarios, the tap gesture is analogous to a single click with a pointer device. It is primarily used to select a control.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Long Press</p>
</td><td style="text-align: left" valign="top">
<p>Long press <a class="indexterm" id="id463"/>or tap and hold is used to access a context menu on Windows Phone. It is used for item selection on Android.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Double-Tap</p>
</td><td style="text-align: left" valign="top">
<p>Double tap is<a class="indexterm" id="id464"/> generally used for scaling up / zooming-in on a control.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Swipe Down</p>
</td><td style="text-align: left" valign="top">
<p>Swipe down or <a class="indexterm" id="id465"/>pan down is used on vertical scroll scenarios. Also, list controls support swipe down for selection on Windows. It is also common to be used with "Pull to Refresh" implementations.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Swipe Right</p>
</td><td style="text-align: left" valign="top">
<p>Similar to swipe<a class="indexterm" id="id466"/> down, swipe right is used on vertical scroll scenarios and sibling navigation scenarios. It is called "flick" if the gesture is fast.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Swipe Left</p>
</td><td style="text-align: left" valign="top">
<p>This is <a class="indexterm" id="id467"/>same as other pan gestures. It can also be used to delete a list item on iOS and Windows Phone 10.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Swipe Up</p>
</td><td style="text-align: left" valign="top">
<p>This is <a class="indexterm" id="id468"/>another panning gesture. It can additionally be used to reveal a bottom sheet on Android applications.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Tap &amp; Drag</p>
</td><td style="text-align: left" valign="top">
<p>This is generally used as an active gesture to interact with draggable<a class="indexterm" id="id469"/> components.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pinch Out</p>
</td><td style="text-align: left" valign="top">
<p>This is used in active canvas application patterns. It is used to zoom<a class="indexterm" id="id470"/> in on a view. On Windows, semantic zoom control makes use of this.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pinch In</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id471"/> similar to the Pinch-Out gesture and is used to zoom out of an active content area of application screen (for example, zoom in on a photo).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Rotate</p>
</td><td style="text-align: left" valign="top">
<p>This is <a class="indexterm" id="id472"/>another gesture used on active canvas applications (for example, a map client). It is used to rotate the current view-port.</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Common Gestures</em></span></p></blockquote></div><p>While some of these gestures are already implemented by out-of-box controls on Xamarin platforms, there might be scenarios where you need to use them to create a new interaction use case in your application. For these type of requirements, specialized implementations <a class="indexterm" id="id473"/>can be found on respective frameworks.</p><p>On the iOS platform, the starting point for gesture recognizer implementation is the abstract class <code class="literal">UIGestureRecognizer</code>. There are numerous implementations of gesture recognizer in the <code class="literal">UIKit</code> and they can be combined and used with delegate implementations.</p><p>On Android, the <code class="literal">GestureDetector</code> class and the <code class="literal">IOnGestureListener</code> interface can be used to provide implementations for various gesture events and user actions. Classic interaction events such as pan gestures and tap actions can already be accessed through the <code class="literal">OnTouchEvent</code> method of any <code class="literal">Activity</code> implementation.</p><p>On the Windows Phone platform, most of the default controls provide interaction with pointer or touch events for classic manipulation scenarios. However, for more complicated gestures, the <code class="literal">GestureRecognizer</code> class available in the <code class="literal">Windows.UI.Input</code> namespace can be used.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Summary</h1></div></div></div><p>This chapter presented an overview of the design philosophy of, and patterns on, Xamarin target platforms. The design elements section outlined the main controls and layouts that are at the disposal of designers and developers while providing various content display strategies. There were additional sections about interactive and modern user interface design.</p><p>Even though each platform provides its own UI design patterns and guidelines, the main focus of the design effort in a cross-platform application is to find an optimal compromise between native look-and-feel and application brand design.</p><p>In the next chapter, we will discuss the Xamarin.Forms framework and make use of the correlation between the design elements that are outlined here.</p></div></body></html>