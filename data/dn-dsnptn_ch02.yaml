- en: Chapter 2. Why We Need Design Patterns?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。为什么我们需要设计模式？
- en: 'In this chapter, we will try to understand the necessity of choosing a pattern-based
    approach to software development. We start with some principles of software development,
    that one might find useful while undertaking large projects. The working example
    in this chapter starts with a requirements specification and progresses toward
    a preliminary implementation. We will then try to iteratively improve the solution
    using patterns and idioms, and come up with a good design that supports a well-defined
    programming Interface. During this process, we will learn about some software
    development principles that one can adhere to, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试理解选择基于模式的方法进行软件开发的重要性。我们从一些软件开发的原则开始，这些原则在承担大型项目时可能会很有用。本章的工作示例从需求规范开始，逐步发展到初步实现。然后我们将尝试使用模式和惯用用法迭代地改进解决方案，并设计出一个支持良好定义的编程接口的良好设计。在这个过程中，我们将了解一些软件开发原则，人们可以坚持这些原则，包括以下内容：
- en: SOLID principles for OOP
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程的SOLID原则
- en: Three key uses of design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的三种关键用途
- en: Arlow/Nuestadt archetype patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arlow/Nuestadt原型模式
- en: Entity, value, and data transfer objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体、值和数据传输对象
- en: Command pattern and factory method pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式和工厂方法模式
- en: Design by contract idiom and the template method pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计约定惯用用法和模板方法模式
- en: Facade pattern for API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于API的外观模式
- en: Leveraging the .NET Reflection API for plugin architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用.NET反射API实现插件架构
- en: XML processing using LINQ for parsing configuration files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ解析配置文件的XML处理
- en: Deep cloning of CLR objects using extension methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展方法进行CLR对象的深度克隆
- en: Designing stateless classes for better scalability
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计无状态类以实现更好的可伸缩性
- en: Some principles of software development
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些软件开发原则
- en: 'Writing quality production code consistently is not easy without some foundational
    principles under your belt. The purpose of this section is to whet the developer''s
    appetite, and towards the end, some references are given for detailed study. Detailed
    coverage of these principles warrants a separate book on its own scale. The authors
    have tried to assimilate the following key principles of software development,
    which help one write quality code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有一些基础原则的情况下，持续编写高质量的生成代码并不容易。本节的目的在于激发开发者的兴趣，并在本节末尾提供一些详细研究的参考文献。对这些原则的详细覆盖需要一本单独的书籍。作者们试图吸收以下软件开发的关键原则，这些原则有助于人们编写高质量的代码：
- en: '**KISS**: Keep it simple, stupid'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KISS**: 简单，傻瓜'
- en: '**DRY**: Don''t repeat yourself'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRY**: 不要重复自己'
- en: '**YAGNI**:You aren''t gonna need it'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAGNI**: 你不需要它'
- en: '**Low coupling**: Minimize coupling between classes'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低耦合**: 最小化类之间的耦合'
- en: '**SOLID principles**: Principles for better OOP'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOLID原则**：面向对象编程的原则'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: William of Ockham framed the maxim **Keep it simple, stupid** (**KISS**). It
    is also called the law of parsimony. In programming terms, it can be translated
    as "writing code in a straightforward manner, focusing on a particular solution
    that solves the problem at hand".
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 奥卡姆的威廉提出了**简单，傻瓜**（**KISS**）的格言。它也被称为节约法则。在编程术语中，它可以被翻译为“以直接的方式编写代码，专注于解决当前问题的特定解决方案”。
- en: This maxim is important because, most often, developers fall into the trap of
    writing code in a generic manner for unwarranted extensibility. Even though it
    initially looks attractive, things slowly go out of bounds. The accidental complexity
    introduced in the code base for catering to improbable scenarios, often reduces
    readability and maintainability. The KISS principle can be applied to every human
    endeavor. Learn more about the KISS principle by consulting the Web.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格言之所以重要，是因为大多数情况下，开发者会陷入编写通用代码以实现不必要的可扩展性的陷阱。尽管一开始看起来很有吸引力，但事情会逐渐失控。为了应对不可能的场景而引入的意外复杂性，通常会降低代码的可读性和可维护性。KISS原则可以应用于人类活动的每一个方面。通过查阅网络了解更多关于KISS原则的信息。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Don''t repeat yourself** (**DRY**), a maxim that is often forgotten by programmers
    while implementing their domain logic. Most often, in a collaborative development
    scenario, code gets duplicated inadvertently due to a lack of communication and
    proper design specifications.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**），这是程序员在实现他们的领域逻辑时经常忘记的一个格言。在协作开发场景中，由于缺乏沟通和适当的设计规范，代码往往无意中重复。最常见的情况是，由于缺乏沟通和适当的设计规范，代码在协作开发场景中无意中重复。'
- en: This bloats the code base, induces subtle bugs, and makes things really difficult
    to change. By following the DRY maxim at all stages of development, we can avoid
    additional effort and make the code consistent. The opposite of DRY is **write
    everything twice** (**WET**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使代码库膨胀，引起微妙的错误，并使事情变得非常难以更改。通过在开发的各个阶段遵循DRY原则，我们可以避免额外的努力并使代码保持一致。DRY的反面是**写两次**（**WET**）。
    |
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**You aren''t gonna need it** (**YAGNI**), a principle that complements the
    KISS axiom. It serves as a warning for people who try to write code in the most
    general manner, anticipating changes right from the word go.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAGNI**（你不会需要它），这是一个补充KISS原则的原则。它作为对试图以最通用方式编写代码、从一开始就预测变化的人的警告。'
- en: Too often, in practice, most of the code which are written in a generic manner,
    might result in code smells.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数以通用方式编写的代码可能会产生代码异味。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While writing code, one should try to make sure that there are no hard-coded
    references to concrete classes. It is advisable to program to an interface as
    opposed to an implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，应该尽量确保没有对具体类的硬编码引用。建议按照接口编程而不是实现编程。
- en: This is a key principle which many patterns use to provide behavior acquisition
    at runtime. A dependency injection framework could be used to reduce coupling
    between classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个许多模式用来在运行时提供行为获取的关键原则。可以使用依赖注入框架来减少类之间的耦合。
- en: 'SOLID principles are a set of guidelines for writing better object-oriented
    software. It is a mnemonic acronym that embodies the following five principles:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是一套编写更好面向对象软件的指南。它是一个记忆法缩写词，代表了以下五个原则：
- en: '| **Sr. no** | **Principles** | **Description** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **序号** | **原则** | **描述** |'
- en: '| 1 | **Single Responsibility Principle** (**SRP**) | A class should have only
    one responsibility. If it is doing more than one unrelated thing, we need to split
    the class. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **单一职责原则**（**SRP**） | 一个类应该只有一个职责。如果它做了不止一件不相关的事情，我们需要将类拆分。 |'
- en: '| 2 | **Open Close Principle** (**OCP**) | A class should be open for extension,
    closed for modification. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **开放封闭原则**（**OCP**） | 一个类应该对扩展开放，对修改封闭。 |'
- en: '| 3 | **Liskov Substitution Principle** (**LSP**) | Named after Barbara Liskov,
    a Turing Award laureate, who postulated that a sub-class (derived class) could
    substitute any super class (base class) references without affecting the functionality.
    Even though it looks like stating the obvious, most implementations have quirks
    that violate this principle. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **里氏替换原则**（**LSP**） | 以图灵奖获得者芭芭拉·里士满的名字命名，她提出了一个子类（派生类）可以替代任何超类（基类）引用而不影响功能的主张。尽管这看起来像是在陈述显而易见的事实，但大多数实现都有违反这一原则的怪癖。
    |'
- en: '| 4 | **Interface Segregation Principle** (**ISP**) | It is more desirable
    to have multiple interfaces for a class (such classes can also be called components)
    than having one Uber interface that forces implementation of all methods (both
    relevant and non-relevant to the solution context). |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **接口隔离原则**（**ISP**） | 对于一个类（这样的类也可以称为组件）来说，拥有多个接口比拥有一个强制实现所有方法的Uber接口更可取（这些方法对于解决方案上下文来说既相关又无关）。
    |'
- en: '| 5 | **Dependency Inversion** (**DI**) | This is a principle which is very
    useful for framework design. In the case of frameworks, the client code will be
    invoked by server code, as opposed to the usual process of the client invoking
    the server. The main principle here is that abstraction should not depend upon
    details; rather, details should depend upon abstraction. This is also called the
    **Hollywood** principle (Do not call us, we will call you back). |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **依赖倒置**（**DI**） | 这是一个在框架设计中非常有用的原则。在框架的情况下，客户端代码将由服务器代码调用，而不是客户端通常调用的服务器。这里的主要原则是抽象不应该依赖于细节；相反，细节应该依赖于抽象。这也被称为**好莱坞原则**（不要联系我们，我们会联系你）。
    |'
- en: The authors consider the preceding five principles primarily as a verification
    mechanism. This will be demonstrated by verifying the ensuing case study implementations
    for violation of these principles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作者认为前五个原则主要是一个验证机制。这将通过验证以下案例研究实现对这些原则的违反来证明。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Karl Seguin has written an e-book titled *Foundations of Programming - Building
    Better Software*, which covers most of what has been outlined here. Read his book
    to gain an in-depth understanding of most of these topics. The SOLID principles
    are well covered in the Wikipedia page on the subject, which can be retrieved
    from [https://en.wikipedia.org/wiki/SOLID_(object-oriented_design](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design).
    Robert Martin's *Agile Principles, Patterns, and Practices in C#* is a definitive
    book on learning about SOLID, as Robert Martin himself is the creator of these
    principles, even though Michael Feathers coined the acronym.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔·塞圭恩（Karl Seguin）撰写了一本名为《编程基础 - 构建更好的软件》（*Foundations of Programming - Building
    Better Software*）的电子书，涵盖了此处概述的大部分内容。阅读他的书籍以深入了解这些主题的大部分内容。SOLID原则在维基百科的相关页面上有很好的介绍，可以通过[https://en.wikipedia.org/wiki/SOLID_(object-oriented_design](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)获取。
- en: Why are patterns required?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要模式？
- en: 'According to the authors, the three key advantages of pattern-oriented software
    development that stand out are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据作者的说法，面向模式的软件开发三个突出的关键优势如下：
- en: A language/platform-agnostic way to communicate about software artifacts
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种语言/平台无关的方式来沟通关于软件工件
- en: A tool for refactoring initiatives (targets for refactoring)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构倡议（重构目标）的工具
- en: Better API design
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的API设计
- en: With the advent of the pattern movement, the software development community
    got a canonical language to communicate about software design, architecture, and
    implementation. Software development is a craft that has got trade-offs attached
    to each strategy, and there are multiple ways to develop software. The various
    pattern catalogs brought some conceptual unification for this **cacophony** in
    software development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模式运动的兴起，软件开发社区获得了一种标准化的语言来沟通软件设计、架构和实现。软件开发是一项具有每个策略相关权衡的工艺，并且有多种软件开发方式。各种模式目录为软件开发中的这种**混乱**带来了一些概念上的统一。
- en: 'Most developers around the world today who are worth their salt can understand
    and speak this language. We believe you will be able to do the same by the end
    of the chapter. Imagine yourself stating the following about your recent implementation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，世界上大多数有实力的开发者都能理解和说出这种语言。我们相信你将在本章结束时也能做到。想象一下，关于你最近的实现，你将如何陈述以下内容：
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For our tax computation example, we have used the command pattern to handle
    the computation logic. The commands (handlers) are configured using an XML file,
    and a factory method takes care of the instantiation of classes on the fly using
    Lazy loading. We cache the commands, and avoid instantiation of more objects by
    imposing singleton constraints on the invocation. We support the prototype pattern
    where command objects can be cloned. The command objects have a base implementation,
    where concrete command objects use the template method pattern to override methods
    that are necessary. The command objects are implemented using the design by contracts
    idiom. The whole mechanism is encapsulated using a Facade class, which acts as
    an API layer for the application logic. The application logic uses entity objects
    (reference) to store the taxable entities, attributes such as tax parameters are
    stored as value objects. We use **data transfer object** (**DTO**) to transfer
    the data from the application layer to the computational layer. The Arlow/Nuestadt-based
    archetype pattern is the unit of structuring the tax computation logic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的税务计算示例中，我们使用了命令模式来处理计算逻辑。命令（处理器）通过XML文件进行配置，工厂方法负责使用懒加载动态实例化类。我们缓存命令，通过在调用上施加单例约束来避免更多对象的实例化。我们支持原型模式，其中命令对象可以被克隆。命令对象有一个基本实现，具体命令对象使用模板方法模式来覆盖必要的方法。命令对象使用基于契约的设计方法实现。整个机制被封装在一个外观类中，该类作为应用程序逻辑的API层。应用程序逻辑使用实体对象（引用）来存储应税实体，如税参数等属性存储为值对象。我们使用**数据传输对象**（**DTO**）将数据从应用程序层传输到计算层。基于Arlow/Nuestadt的构型模式是结构化税务计算逻辑的单位。
- en: For some developers, the preceding language/platform-independent description
    of the software being developed is enough to understand the approach taken. This
    will boost developer productivity (during all phases of SDLC, including development,
    maintenance, and support) as the developers will be able to get a good mental
    model of the code base. Without Pattern catalogs, such succinct descriptions of
    the design or implementation would have been impossible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发者来说，前面提供的语言/平台无关的软件开发描述就足以理解所采取的方法。这将提高开发者的生产力（包括开发、维护和支持在内的 SDLC 所有阶段），因为开发者将能够获得良好的代码库心理模型。没有模式目录，这样的简洁设计或实现描述是不可能的。
- en: In an Agile software development scenario, we develop software in an iterative
    fashion. Once we reach a certain maturity in a module, developers refactor their
    code. While refactoring a module, patterns do help in organizing the logic. The
    case study given next will help you to understand the rationale behind *patterns
    as refactoring targets*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷软件开发场景中，我们以迭代的方式开发软件。一旦我们在某个模块中达到一定的成熟度，开发者就会重构他们的代码。在重构模块时，模式有助于组织逻辑。接下来的案例研究将帮助你理解“模式作为重构目标”的合理性。
- en: APIs based on well-defined patterns are easy to use and impose less cognitive
    load on programmers. The success of the ASP.NET MVC framework, NHibernate, and
    APIs for writing HTTP modules and handlers in the ASP.NET pipeline are a few testimonies
    to the process. You will see how these three key advantages are put into practice
    in the ensuing chapters and case studies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基于定义良好的模式的 API 容易使用，并且对程序员施加的认知负荷较小。ASP.NET MVC 框架、NHibernate 以及 ASP.NET 管道中编写
    HTTP 模块和处理器 API 的成功，是这一过程的几个证明。你将在接下来的章节和案例研究中看到这三个关键优势是如何付诸实践的。
- en: A quick foray into the .NET Reflection API
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 .NET 反射 API 的快速探索
- en: 'When we write non-trivial software that should go to production, it is mandatory
    to have the ability to load and execute modules on the fly. This is useful when
    you are planning to provide user defined extensions as a mechanism to add new
    features to the existing software. The .NET Reflection API is a nifty mechanism
    supported by the Microsoft Corporation to help developers to write code that can
    be loaded dynamically, after the base software has been written. The platform
    technologies, such as ASP.net, WCF,EF, and WPF, use reflection extensively:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写应投入生产的非平凡软件时，必须具备动态加载和执行模块的能力。当你计划提供用户定义的扩展作为向现有软件添加新功能的一种机制时，这很有用。.NET
    反射 API 是微软公司支持的一种巧妙机制，可以帮助开发者编写在基础软件编写之后可以动态加载的代码。平台技术，如 ASP.net、WCF、EF 和 WPF，广泛使用反射：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will write a simple program that will instantiate the object using the `new`
    keyword, and after the object instantiation, a property (`X`) will be set to the
    value `0xBEEF`. The .NET Reflection API will be used to retrieve the property
    value and invoke a method (`Spit`) using them:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个简单的程序，使用 `new` 关键字实例化对象，并在对象实例化后，将属性（`X`）设置为值 `0xBEEF`。我们将使用 .NET 反射
    API 来检索属性值并使用它们调用方法（`Spit`）：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will be using .NET Reflection API extensively in our programs. A competent
    programmer should know the .NET Reflection API and its features to write any advanced
    piece of code. Do consult the Microsoft documentation to understand the features
    available and the nuances of the API. If you want to be a library or framework
    designer, you should know Reflection API in depth.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在程序中广泛使用 .NET 反射 API。一个合格的程序员应该了解 .NET 反射 API 及其特性，以便编写任何高级代码。请查阅微软文档以了解可用的特性和
    API 的细微差别。如果你想成为一名库或框架设计师，你应该深入了解反射 API。
- en: Personal income tax computation - A case study
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人所得税计算 - 案例研究
- en: Rather than explaining the advantages of patterns, the following example will
    help us to see things in action. Computation of annual income tax is a well-known
    problem domain across the globe. We have chosen an application domain that is
    well known for focusing on software development issues.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与其解释模式的优点，以下示例将帮助我们看到实际操作。年度所得税的计算是全球公认的问题领域。我们选择了一个以关注软件开发问题而闻名的应用领域。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application should receive inputs regarding the demographic profile (UID,
    Name, Age, Sex, Location) of a citizen and the income details (Basic, DA, HRA,
    CESS, Deductions) to compute their tax liability. The system should have discriminants
    based on the demographic profile, and have a separate logic for senior citizens,
    juveniles, disabled people, female senior citizens, and others. By discriminant
    we mean that demographic parameters such as age, sex, and location should determine
    the category to which a person belongs and therefore apply category-specific computation
    for that individual. As a first iteration, we will implement logic for the senior
    citizen and ordinary citizen categories.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应接收有关公民人口统计资料（UID、姓名、年龄、性别、位置）和收入详情（基本工资、DA、HRA、CESS、扣除额）的输入，以计算他们的税负。系统应根据人口统计资料设置判别标准，并为老年人、未成年人、残疾人、女性老年人以及其他人群设置单独的逻辑。我们所说的判别标准是指人口统计参数，如年龄、性别和位置应决定一个人所属的类别，因此为该个人应用特定类别的计算。作为第一次迭代，我们将实现针对老年人和普通公民类别的逻辑。
- en: 'After preliminary discussions, our developer created a prototype screen, as
    shown in the following image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步讨论后，我们的开发人员创建了一个原型屏幕，如下面的图像所示：
- en: '![Personal income tax computation - A case study](img/B05691_02_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![个人所得税计算 - 一个案例研究](img/B05691_02_01.jpg)'
- en: Archetypes and business archetype patterns
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型和商业原型模式
- en: The legendary Swiss psychologist, Carl Gustav Jung, created the concept of archetypes
    to explain fundamental entities that arise from a common repository of human experiences.
    The concept of archetypes percolated to the software industry from psychology.
    The Arlow/Nuestadt patterns describe business archetype patterns such as Party,
    Customer Call, Product, Money, Unit, Inventory, and so on. An example is the Apache
    Maven archetype, which helps us to generate projects of different natures, such
    as J2EE apps, Eclipse plugins, OSGI projects, and so on. The Microsoft patterns
    and practices describe archetypes for targeting builds such as web applications,
    rich client applications, mobile applications, and services applications. Various
    domain-specific archetypes can exist in respective contexts as organizing and
    structuring mechanisms.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇的瑞士心理学家卡尔·古斯塔夫·荣格（Carl Gustav Jung）创造了原型的概念来解释从人类共同经验库中产生的根本实体。原型的概念从心理学渗透到软件行业。Arlow/Nuestadt模式描述了诸如派对、客户呼叫、产品、金钱、单元、库存等商业原型模式。一个例子是Apache
    Maven原型，它帮助我们生成不同性质的项目，如J2EE应用、Eclipse插件、OSGI项目等。微软的模式和实践描述了针对构建目标的原型，如Web应用、富客户端应用、移动应用和服务应用。在相应的上下文中，可以存在各种特定领域的原型，作为组织和结构化机制。
- en: 'In our case, we will define some archetypes that are common in the taxation
    domain. Some of the key archetypes in this domain are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将定义一些在税收领域常见的原型。该领域的一些关键原型如下：
- en: '| **Sr.no** | **Archetype** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **序号** | **原型** | **描述** |'
- en: '| 1 | SeniorCitizenFemale | Tax payers who are female, and above the age of
    60 years. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | SeniorCitizenFemale | 年龄在60岁以上且为女性的纳税人。|'
- en: '| 2 | SeniorCitizen | Tax payers who are male, and above the age of 60 years.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | SeniorCitizen | 年龄在60岁以上且为男性的纳税人。|'
- en: '| 3 | OrdinaryCitizen | Tax payers who are male/female, and above 18 years
    of age. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 3 | OrdinaryCitizen | 年龄在18岁以上且为男性/女性的纳税人。|'
- en: '| 4 | DisabledCitizen | Tax payers who have any disability. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 4 | DisabledCitizen | 有任何残疾的纳税人。|'
- en: '| 5 | MilitaryPersonnel | Tax payers who are military personnel. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 5 | MilitaryPersonnel | 军事人员纳税人。|'
- en: '| 6 | Juveniles | Tax payers whose age is less than 18 years. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Juveniles | 年龄小于18岁的纳税人。|'
- en: We will use demographic parameters as discriminants to find the archetype that
    corresponds to the entity. The whole idea of inducing archetypes is to organize
    the tax computation logic around them. Once we are able to resolve the archetypes,
    it is easy to locate and delegate the computations corresponding to the archetypes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用人口统计参数作为判别标准来找到与实体相对应的原型。诱导原型的整个想法是将税收计算逻辑围绕它们组织。一旦我们能够解决原型，就很容易找到并委派与原型对应的计算。
- en: Entity, value, and data transfer objects
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体、值和数据传输对象
- en: 'We are going to create a class that represents a citizen. Since a citizen needs
    to be uniquely identified, we are going to create an entity object, which is also
    called a reference object (from the DDD catalog). The **universal identifier**
    (**UID**) of an entity object is the handle to which an application refers. Entity
    objects are not identified by their attributes, as there can be two people with
    the same name. The ID uniquely identifies an entity object. The definition of
    an entity object is given as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个表示公民的类。由于公民需要唯一标识，我们将创建一个实体对象，这也可以称为参考对象（来自DDD目录）。实体对象的**通用标识符**（**UID**）是应用程序引用的句柄。实体对象不是通过其属性来识别的，因为可能有两个人有相同的名字。ID唯一标识实体对象。实体对象的定义如下：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding class definition, `Id` uniquely identifies the entity object.
    TaxParams is a value object (from the DDD catalog) associated with the entity
    object. Value objects do not have a conceptual identity. They describe some attributes
    of things (entities). The definition of TaxParams is given as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，`Id`唯一标识实体对象。TaxParams是与实体对象关联的值对象（来自DDD目录）。值对象没有概念上的身份。它们描述了一些事物的属性（实体）。TaxParams的定义如下：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While writing applications ever since Smalltalk, **Model-view-controller**
    (**MVC**) is the most dominant paradigm for structuring applications. The application
    is split into a model layer (which mostly deals with data), a view layer (which
    acts as a display layer), and a controller (to mediate between the two). In the
    web development scenario, they are physically partitioned across machines. To
    transfer data between layers, the J2EE pattern catalog identified the DTO. The
    DTO object is defined as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自从使用Smalltalk编写应用程序以来，**模型-视图-控制器**（**MVC**）一直是结构化应用程序的最主要范式。应用程序被分为模型层（主要处理数据）、视图层（作为显示层）和控制器（在两者之间进行调解）。在Web开发场景中，它们在物理上分布在不同的机器上。为了在层之间传输数据，J2EE模式目录确定了DTO。DTO对象定义为如下：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the layering exists within the same process, we can transfer these objects
    as-is. If layers are partitioned across processes or systems, we can use XML or
    JSON serialization to transfer objects between the layers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分层存在于同一进程中，我们可以直接传递这些对象。如果层分布在不同的进程或系统中，我们可以使用XML或JSON序列化在层之间传递对象。
- en: A computation engine
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个计算引擎
- en: We need to separate UI processing, input validation, and computation to create
    a solution that can be extended to handle additional requirements. The computation
    engine will execute different logic depending upon the command received. The GoF
    command pattern is leveraged for executing the logic based on the command received.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将UI处理、输入验证和计算分离，以创建一个可以扩展以处理额外需求的解决方案。计算引擎将根据接收到的命令执行不同的逻辑。GoF命令模式被用来根据接收到的命令执行逻辑。
- en: 'The command pattern consists of four constituents. They are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式由四个组成部分组成。具体如下：
- en: Command object
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令对象
- en: Parameters
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: Command Dispatcher
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令调度器
- en: Client
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: 'The command object''s interface has an `Execute` method. The parameters to
    the command objects are passed through a bag. The client invokes the command object
    by passing the parameters through a bag to be consumed by the Command Dispatcher.
    The parameters are passed to the command object through the following data structure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 命令对象的接口有一个`Execute`方法。命令对象的参数通过一个包传递。客户端通过将参数通过包传递给命令对象来调用命令对象，以便由命令调度器消费。参数通过以下数据结构传递给命令对象：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ComputationCommand` interface, which all the command objects implement,
    has only one `Execute` method, which is shown next. The `Execute` method takes
    a bag as a parameter. The `COMPUTATION_CONTEXT` data structure acts as the bag
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令对象都实现的`ComputationCommand`接口只有一个`Execute`方法，如下所示。`Execute`方法接受一个包作为参数。在这里，`COMPUTATION_CONTEXT`数据结构充当包：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since we have already implemented a command interface and bag to transfer the
    parameters, it is time that we implemented a command object. For the sake of simplicity,
    we will implement two commands where we hardcode the tax liability:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已实现了命令接口和用于传递参数的包，现在是时候实现命令对象了。为了简化，我们将实现两个命令，其中硬编码了税负：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The commands will be invoked by a `CommandDispatcher` object, which takes an
    `archetype` string and a `COMPUTATION_CONTEXT` object. The `CommandDispatcher`
    acts as an API layer for the application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将由一个 `CommandDispatcher` 对象调用，该对象接受一个 `archetype` 字符串和一个 `COMPUTATION_CONTEXT`
    对象。`CommandDispatcher` 作为应用程序的 API 层：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The application to engine communication
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序到引擎通信
- en: 'The data from the application UI, be it web or desktop, has to flow to the
    computation engine. The following `ViewHandler` routine shows how data, retrieved
    from the application UI, is passed to the engine, via the Command Dispatcher,
    by a client:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 来自应用程序 UI 的数据，无论是网页还是桌面，都必须流向计算引擎。下面的 `ViewHandler` 例程显示了如何通过命令调度器将应用程序 UI 中检索到的数据传递给引擎，由客户端完成：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, imagine that a change in requirements has been received from
    the stakeholders. Now we need to support tax computation for new categories.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，假设我们已经收到了利益相关者的需求变更。现在我们需要支持新类别的税务计算。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Initially, we had different computations for senior citizens and ordinary citizens.
    Now we need to add new archetypes. At the same time, to make the software extensible
    (loosely coupled) and maintainable, it would be ideal if we provided the capability
    to support the new archetypes in a configurable manner, as opposed to recompiling
    the application for every new archetype owing to concrete references.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们有针对老年人和普通公民的不同计算。现在我们需要添加新的原型。同时，为了使软件可扩展（松耦合）和可维护，如果我们能够以可配置的方式支持新的原型，而不是为每个新的原型重新编译应用程序，这将是非常理想的，因为具体引用。
- en: The Command Dispatcher object does not scale well to handle additional archetypes.
    We need to change the assembly whenever a new archetype is included, as the tax
    computation logic varies for each archetype. We need to create a pluggable architecture
    to add or remove archetypes at will.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 命令调度器对象在处理额外的原型时扩展性不好。每当包含新的原型时，我们需要更改程序集，因为每个原型的税务计算逻辑都不同。我们需要创建一个可插拔的架构，以便随意添加或删除原型。
- en: The plugin system to make system extensible
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使系统可扩展的插件系统
- en: Writing system logic without impacting the application warrants a mechanism--that
    of loading a class on the fly. Luckily, the .NET Reflection API provides a mechanism
    for one to load a class during runtime, and invoke methods within it. A developer
    worth his salt should learn the Reflection API to write systems that change dynamically.
    In fact, most of the technologies such as ASP.NET, Entity Framework, .NET Remoting,
    and WCF work because of the availability of Reflection API in the .NET stack.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在不影响应用程序的情况下编写系统逻辑需要一个机制——即动态加载类的机制。幸运的是，.NET 反射 API 提供了一种在运行时加载类并调用其中方法的机制。一个有价值的开发者应该学习反射
    API 来编写动态变化的系统。实际上，大多数技术如 ASP.NET、Entity Framework、.NET Remoting 和 WCF 都是因为 .NET
    堆栈中反射 API 的可用性而得以工作。
- en: 'Henceforth, we will be using an XML configuration file to specify our tax computation
    logic. A sample XML file is given next:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从此以后，我们将使用 XML 配置文件来指定我们的税务计算逻辑。下面给出一个示例 XML 文件：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The contents of the XML file can be read very easily using LINQ to XML. We
    will be generating a `Dictionary` object with the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 LINQ to XML 非常容易地读取 XML 文件的内容。我们将使用以下代码片段生成一个 `Dictionary` 对象：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Factory method pattern and plugins
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法模式和插件
- en: The factory method (from the GoF catalog) is a pattern that solves the creation
    of objects through a static method exposed solely for this purpose. The object
    we create will be based on a particular class or derived class. In our case, we
    need to create objects that have implemented the `ComputationCommand` interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法（来自 GoF 目录）是一种通过仅为此目的公开的静态方法解决对象创建的模式。我们创建的对象将基于特定的类或派生类。在我们的情况下，我们需要创建实现了
    `ComputationCommand` 接口的对象。
- en: 'The consumer of the `Factory` class can also indicate whether it requires a
    singleton or a prototype. The default behavior of the factory method is singleton,
    and it is supposed to return the same instance whenever a call to the `Factory`
    (`Get`) method is received. If the prototype option is given, a clone of the object
    will be created and returned:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factory` 类的消费者也可以指示它是否需要单例或原型。工厂方法的默认行为是单例，它应该在收到对 `Factory` (`Get`) 方法的调用时返回相同的实例。如果提供了原型选项，将创建对象的副本并返回：'
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The consumer of the `ObjectFactory` class will indicate whether it wants a
    reference to the object to be available in the plugin cache or a clone of the
    object. We can clone an object using binary serialization. By writing an extension
    method leveraging generics, we can write an all-purpose clone routine. The following
    code snippet will help us to achieve that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectFactory`类的消费者将指示它是否希望对象引用在插件缓存中可用或对象的一个克隆。我们可以使用二进制序列化来克隆对象。通过利用泛型的扩展方法，我们可以编写一个通用的克隆例程。以下代码片段将帮助我们实现这一点：'
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the implementation of `Get` becomes a straightforward affair; the full
    listing of the `Get` method is given as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Get`的实现变得简单直接；`Get`方法的完整列表如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have got a factory method implementation, let us see how one can
    consume the code. The Command Dispatcher will get a handle to the instance of
    a command based on the archetype provided to it. Once the handle to the object
    is received, the `Execute` method can be invoked:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个工厂方法实现，让我们看看如何消费这段代码。命令调度器将根据提供的原型获取命令实例的句柄。一旦收到对象的句柄，就可以调用`Execute`方法：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The authors of the book feel that command objects should be designed in a stateless
    manner. In the imperative programming world, this means that there shouldn't be
    any shared variables between the methods of a class. We should not add class-level
    variables in order to avoid locks in a multithreaded environment. In effect, parameters
    become the sole determinant of the results. If you cannot avoid having class-level
    variables, they should be immutable (read only). If we mutate the state of an
    object, the prototype created out of that will have an impact because of object
    references. The Java servlet specification expects the servlets to be stateless,
    and Spring controllers are also stateless. The Microsoft ASP.NET MVC controllers
    need not be stateless (not sure why Microsoft chose things that way).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 书的作者认为命令对象应该以无状态的方式设计。在命令式编程世界中，这意味着类的方法之间不应有任何共享变量。我们不应添加类级别变量，以避免在多线程环境中出现锁。实际上，参数成为结果的唯一决定因素。如果你无法避免有类级别变量，它们应该是不可变的（只读）。如果我们改变对象的状态，由此产生的原型将因为对象引用而受到影响。Java
    servlet规范期望servlet是无状态的，Spring控制器也是无状态的。Microsoft ASP.NET MVC控制器不需要是无状态的（不清楚为什么微软选择了这种方式）。
- en: 'Now, let us revisit our `ViewHandler` routine. The interface does not change
    here. The real magic happens beneath the Command Dispatcher object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视我们的`ViewHandler`例程。这里的接口没有变化。真正的魔法发生在命令调度器对象之下：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The view handler routine does the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 视图处理程序例程执行以下操作：
- en: Retrieves the value from the UI elements to create entity
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从UI元素中检索值以创建实体
- en: Determines the archetype based on demographic parameters
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据人口统计参数确定原型
- en: Creates a DTO and places it in a bag
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个DTO并将其放入一个包中
- en: Dispatches the method through `CommandDispatcher`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`CommandDispatcher`调度方法
- en: Updates the UI based on the status
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据状态更新UI
- en: 'Let''s create a new command that will compute taxes for senior citizens who
    are female:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的命令，该命令将为女性老年人计算税款：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have to make some changes to the configuration file. The resulting XML configuration
    is given as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对配置文件进行一些修改。生成的XML配置如下所示：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finalizing the solution
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成解决方案
- en: We started with a solution that solved the problem at hand. After creating a
    basic pipeline, we created an elaborate pipeline, which made the solution extensible.
    Now we can add new commands without recompiling the application. This is very
    important in the case of applications that are governed by amendable laws. To
    make our code robust, we will add the design by contract strategy to our command
    objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个解决当前问题的解决方案开始。在创建基本管道后，我们创建了一个复杂的管道，这使得解决方案具有可扩展性。现在我们可以添加新的命令而无需重新编译应用程序。这对于受可修改法律约束的应用程序来说非常重要。为了使我们的代码健壮，我们将设计合同策略添加到我们的命令对象中。
- en: Design by contract and template method pattern
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计合同和模板方法模式
- en: 'The design by contract idiom, created by Bertrand Meyer (creator of the Eiffel
    language), extends the ordinary definition of abstract data types with preconditions,
    post conditions, and invariants. To execute any contract in real life, we need
    to satisfy some preconditions, followed by execution, and a post execution (verification)
    phase as listed here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Bertrand Meyer（Eiffel 语言创造者）创建的设计由合同（Design by Contract）习语，扩展了抽象数据类型的普通定义，包括前置条件、后置条件和不变性。为了在现实生活中执行任何合同，我们需要满足一些前置条件，然后执行，并有一个后执行（验证）阶段，如下所示：
- en: Pre-Execute
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pre-Execute
- en: Execute
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Execute
- en: Post-Execute
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Post-Execute
- en: 'At the end of the Post-Execute phase, the invariants are checked to see whether
    they are violated. The consumer will call `PreExecute` to determine whether there
    is a context for the execution of the contract. The invocation will proceed only
    if `PreExecute` returns true. To incorporate design by contract, we extend the
    interface with two additional methods. The resultant `interface` is given as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Post-Execute 阶段结束时，将检查不变性以确定它们是否被违反。消费者将调用 `PreExecute` 以确定是否存在执行合同的上下文。只有当
    `PreExecute` 返回 true 时，调用才会继续。为了实现设计由合同（Design by Contract），我们通过两个额外的方法扩展了接口。结果
    `interface` 如下所示：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will create a `BaseComputationCommand` class, which will stub the methods
    in the `ComputationCommand` interface. This will help the concrete, derived command
    classes to override only those methods which have the respective changes. After
    redefining the interface, we will create a default implementation of the command
    pattern with methods marked as `virtual`. This helps us to override the implementation
    in the derived class. This is an instance of the template method pattern:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `BaseComputationCommand` 类，它将模拟 `ComputationCommand` 接口中的方法。这将帮助具体的派生命令类仅覆盖那些具有相应更改的方法。在重新定义接口后，我们将创建一个带有标记为
    `virtual` 的方法的命令模式的默认实现。这有助于我们在派生类中覆盖实现。这是一个模板方法模式的实例：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our commands here will use the template method pattern to override only those
    methods that are relevant. Otherwise, there is already a fallback in the `BaseComputationCommand`.
    The template method pattern defines the program skeleton of an algorithm(s) in
    a method, and they are called template method(s). These template methods are overridden
    by sub-classes, which implement the concrete logic:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的命令将使用模板方法模式来覆盖仅与相关的方法。否则，`BaseComputationCommand` 中已经有了回退机制。模板方法模式在方法中定义算法（s）的程序骨架，它们被称为模板方法（s）。这些模板方法被子类覆盖，以实现具体的逻辑：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We need not override every method, and yet, the whole scheme would still work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要覆盖每个方法，而且整个方案仍然可以工作：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to rewrite the command pattern to reflect the implementation of
    the design by contract idiom in the command classes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重写命令模式，以反映命令类中设计由合同（Design by Contract）习语的实现：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In some implementations, the clients will check the return value to see whether
    invariants have been violated. In some cases, a compensating transaction will
    be executed to restore the state to the previous one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些实现中，客户端将检查返回值以查看是否违反了不变性。在某些情况下，将执行补偿事务以将状态恢复到之前的状态。
- en: Using the Facade pattern to expose the computation API
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用门面（Facade）模式公开计算 API
- en: Our computation engine contains a lot of classes that coordinate to implement
    the application logic. Any client who wants to interact with this implementation
    would prefer a simplified interface to this subsystem. A facade is an object that
    provides a simple interface to a large body of code in large classes or modules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算引擎包含许多类，它们协同工作以实现应用程序逻辑。任何想要与这种实现交互的客户端都会更喜欢一个简化的子系统接口。门面（Facade）是一个对象，它为大型类或模块中的大量代码提供简单的接口。
- en: 'The GoF facade pattern is a mechanism that we can use to expose a coarse-grained
    API:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GoF 门面（Facade）模式是我们可以使用来公开粗粒度 API 的机制：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the `ViewHandler` has become much simpler, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ViewHandler` 已经变得简单多了，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered quite a lot of ground in understanding why
    pattern-oriented software development is a good way to develop modern software.
    We started the chapter by citing some key principles. We progressed further to
    demonstrate the applicability of these key principles by iteratively skinning
    an application that is extensible and resilient to changes. Through this journey,
    we covered concepts such as the command pattern, factory method pattern, facade
    pattern, design by contract, template method pattern, XML configuration files,
    LINQ to XML, and so on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了为什么面向模式的软件开发是开发现代软件的一种好方法。我们通过引用一些关键原则开始了本章的讨论。然后，我们通过迭代地修改一个可扩展且对变化具有弹性的应用程序，进一步展示了这些关键原则的应用性。在这个过程中，我们涵盖了诸如命令模式、工厂方法模式、外观模式、基于契约的设计、模板方法模式、XML配置文件、LINQ
    to XML等概念。
- en: In the next chapter, we will continue our discussion of patterns by implementing
    a logging library, which can serialize contents into file, database, or remote
    network.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现一个日志库来继续我们的模式讨论，该库可以将内容序列化到文件、数据库或远程网络中。
