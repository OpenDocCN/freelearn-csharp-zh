- en: Best Practices and Other Related Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和其他相关技术
- en: The last chapter was a very interesting one as we explored Dependency Injection
    in different frameworks such as TypeScript, ES2015, and Angular 2\. This is the
    last chapter and we are going to discuss the coding and architectural practices
    proved to be the best while implementing Dependency Injection in the project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章非常有趣，因为我们探索了在不同框架中实现依赖注入，例如TypeScript、ES2015和Angular 2。这是最后一章，我们将讨论在项目中实现依赖注入时证明是最好的编码和架构实践。
- en: It's obvious that, when you learn something new and try to implement it in your
    application, excitement might lead you to create a bad architecture. That would
    eventually lead to a bad practice because, after you code it for a few times unknowingly,
    it becomes a habit. Suppose, you get a requirement to save user details to the
    database. You will definitely send the details to the `Service Layer` method which
    in turn would connect to the `Data Access Layer` method, to save the details.
    Quickly (if you are new to the application and don't know about the architecture
    implemented), the first thing you would do is to use the `new` keyword to instantiate
    the dependencies and directly call the methods. In that way, we can't achieve
    loosely coupled modules. However, we could have designed the app and the layers
    in such a way that the consumers won't be able to generate coupling by any means.
    We will explore these techniques in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当你学习新事物并尝试将其应用于你的应用程序时，兴奋可能会让你创建一个糟糕的架构。这最终会导致不良的实践，因为在你不知不觉中多次编码之后，它就变成了习惯。假设，你接到一个将用户详情保存到数据库的要求。你肯定会将详情发送到`服务层`方法，该方法反过来会连接到`数据访问层`方法以保存详情。如果你是新手并且不了解应用的架构，你首先会做的事情就是使用`new`关键字来实例化依赖项并直接调用方法。这样，我们就无法实现松散耦合的模块。然而，我们可以以这样的方式设计和设计应用和层，使得消费者无法通过任何方式产生耦合。我们将在本章中探讨这些技术。
- en: So, exploring how to deliver your best with the concept you just learned is
    important for you and your app. For that reason, there are best practices which
    you should be aware of. Dependency Injection deals with Object Composition, Object
    Lifetime, and Interception as a whole, which should be ideally managed by DI Containers.
    If we try to deal with these building blocks ourselves instead of using a container
    to manage the dependencies, we might end up with a bad design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，探索如何利用你刚刚学到的概念来达到最佳效果对你和你的应用来说非常重要。为此，有一些最佳实践你应该了解。依赖注入涉及对象组合、对象生命周期和拦截的整体处理，这些理想上应由DI容器管理。如果我们试图自己处理这些构建块而不是使用容器来管理依赖项，我们可能会得到一个糟糕的设计。
- en: Although we can choose one DI Container, designing and refactoring our code
    accordingly to help the container to work with our classes might be an erroneous
    task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以选择一个DI容器，但根据容器设计并重构我们的代码以帮助容器与我们的类一起工作可能是一项错误的任务。
- en: In this chapter, we will touch upon these points in detail to understand the
    real-time problems faced during the induction of DI into the projects. We will
    learn techniques to avoid bad habits in DI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨这些点，以了解在项目引入DI时面临的实时问题。我们将学习避免DI中不良习惯的技术。
- en: 'We will discuss the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Best practices and recommendations in Dependency Injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入中的最佳实践和建议
- en: Some recommended techniques to remove tight coupling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些推荐的去除紧密耦合的技术
- en: Refactoring and implementation of DI in legacy layered applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构和实现遗留分层应用中的DI
- en: Tightly coupled systems
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧密耦合的系统
- en: Till now, we have discussed *DI in .NET Core 2.0, Pillars of DI, DI Patterns,
    Anti-Patterns, DI in other frameworks*. Someone who is new to the DI concept might
    do make mistakes and it's normal. We will see more of such scenarios in upcoming
    sections. Before that, let's analyze something which you might find more often
    in ASP.NET MVC projects. If you don't, ask your colleagues and friends. You will
    definitely see such instances.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了*在.NET Core 2.0中的依赖注入（DI）、DI的支柱、DI模式、反模式以及在其他框架中的DI*。对于依赖注入概念的新手来说，犯错误是很正常的。我们将在接下来的章节中看到更多这样的场景。在此之前，让我们分析一下你可能在ASP.NET
    MVC项目中更常遇到的情况。如果你没有遇到，可以询问你的同事和朋友。你肯定会看到这样的例子。
- en: Let's see one simple controller without DI implemented and learn how to refactor
    that so that it will respect the principles of *Inversion of Control*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个没有实现DI的简单控制器，并学习如何重构它，使其遵循*控制反转（IoC）*的原则。
- en: Inversion of Control states *Do not call us we will call you*. When a class
    tries to instantiate another class inside it, it basically creates a coupling
    with the second class. Now the first class creation depends on the second class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转（IoC）原则是“不要调用我们，我们会调用你”。当一个类试图在其内部实例化另一个类时，它基本上与第二个类建立了耦合。现在第一个类的创建依赖于第二个类。
- en: 'If the second class fails, for any reason, we won''t be able to get the instance
    of the first class, as the constructor will break:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个类因为任何原因失败，我们将无法获取第一个类的实例，因为构造函数会出错：
- en: '![](img/62615398-6b59-4eb3-8657-451926cf6fe7.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62615398-6b59-4eb3-8657-451926cf6fe7.png)'
- en: The **Someone** in the picture can be an IoC Container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的**某人**可以是一个IoC容器。
- en: I would strongly recommend Mr. Shivprasad Koirala's article, if you want to
    grasp this concept in depth. Here is the link--[https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency](https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入理解这个概念，我强烈推荐Shivprasad Koirala先生的这篇文章。以下是链接--[https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency](https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency)。
- en: The problem
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following diagram depicts what we are going to do now. We will have a **Controller**
    depending on a **Service**, which in turn depends on a **Repository** for data:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们现在将要做什么。我们将有一个**控制器**依赖于一个**服务**，而这个服务又依赖于一个**仓库**来获取数据：
- en: '![](img/2a6cbf62-357a-46b5-9785-14b3fb11853a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a6cbf62-357a-46b5-9785-14b3fb11853a.png)'
- en: 'First of all, let''s think of a simple controller and how that is generally
    implemented in projects. The following is a simple `UsersController` which has
    an action method `Edit`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个简单的控制器以及它在项目中通常是如何实现的。以下是一个简单的`UsersController`，它有一个动作方法`Edit`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the conclusions (more accurately the problems), which can
    be made from the preceding code block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的代码块中可以得出的结论（更准确地说，是问题），：
- en: '`UsersController` instantiates `UsersService` using the `new` keyword (creates
    an instance of a concrete class)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsersController`使用`new`关键字实例化`UsersService`（创建一个具体类的实例）'
- en: '`UsersController` is tightly coupled with `UsersService`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsersController`与`UsersService`紧密耦合'
- en: As far as our knowledge from other chapters is concerned, we should definitely
    avoid both of the preceding points. This makes Unit Testing difficult. DI principles
    encourage us to utilize the area of the Composition Root to register all required
    classes/dependencies (such as `UsersService`) and then use a DI container to resolve
    the instances instead of using the `new` keyword whenever required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们从前几章学到的知识而言，我们绝对应该避免前述的两个点。这会使单元测试变得困难。依赖注入（DI）原则鼓励我们利用组合根区域来注册所有必需的类/依赖（例如`UsersService`），然后使用DI容器来解析实例，而不是在需要时每次都使用`new`关键字。
- en: 'Next is `UsersService`, which might look something like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`UsersService`，它可能看起来如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yet another concrete dependency with `UsersRepository`. `UsersService` now does
    the same kind of stuff as we saw in the case of the controller. In this example,
    the service is trying to pass the data returned from the repository. But in reality,
    it might do a lot of things. The important aspect here is how we are managing
    our dependencies inside a class which might get uglier as we build a complex system
    in the future. The exercise we are doing now is just to point out the problem,
    so don't go by the simplicity of the structure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个具体的依赖项与`UsersRepository`相关。`UsersService`现在所做的与我们在控制器案例中看到的是同一类事情。在这个例子中，服务试图传递从仓库返回的数据。但在现实中，它可能做很多事情。这里的重要方面是我们如何在一个可能在未来构建复杂系统时变得更加复杂的类中管理我们的依赖关系。我们现在所做的练习只是指出问题，所以不要仅仅根据结构的简单性来判断。
- en: 'The repository would look like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库看起来可能如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following diagram explains what has been done so far:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了到目前为止所做的工作：
- en: '![](img/f1e7fe9d-fda2-48ee-989f-a17cc250d795.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1e7fe9d-fda2-48ee-989f-a17cc250d795.png)'
- en: 'Everything stops here. This is the last in the queue. It gets the data from
    the `Users` table and sends it back to the client. This architecture works, but
    there are shortcomings which might get worse as you progress:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都到此为止。这是队列中的最后一个。它从`Users`表中获取数据并将其发送回客户端。这种架构是可行的，但存在一些缺点，这些缺点可能会随着你继续前进而变得更加严重：
- en: Unit testing is not easy as the classes are tightly coupled with each other.
    For instance, `UsersController` depends on `UsersService`, which in turn depends
    upon `UsersRepository`, and then, at last, it deals with the database, while unit
    testing might fail due to database interactions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试并不容易，因为类之间紧密耦合。例如，`UsersController`依赖于`UsersService`，而`UsersService`又依赖于`UsersRepository`，最后，它处理数据库，而单元测试可能会因为数据库交互而失败。
- en: If this architecture grows and becomes a fully fledged application, then maintenance
    becomes difficult as the classes are wound up with dependencies all over which
    will be difficult to identify and manage.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这种架构增长并成为一个完整的应用程序，那么维护会变得困难，因为类被各种依赖关系缠绕，这些依赖关系难以识别和管理。
- en: There is no technique/method by which we can easily modify the dependencies.
    Suppose we want to implement another class for a service named `UsersNewService`
    and we want to use that instead of `UsersService`. It will be a tedious task as
    we have to identify all dependencies of `UsersService` and then change them everywhere.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何技术/方法可以轻松地修改依赖关系。假设我们想要实现一个名为`UsersNewService`的服务类，并希望使用它而不是`UsersService`。这将是一项繁琐的任务，因为我们必须识别`UsersService`的所有依赖关系，然后更改它们。
- en: Moreover, the concrete service reference might fail in certain circumstances
    where the method signatures may vary across different classes. For example, the `GetUser`
    method in both of these service classes may vary in the signature, making the
    developer's life difficult as you have to modify the `GetUser` caller methods
    as well, including service reference changes.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，具体服务引用可能在某些情况下失败，因为方法签名可能在不同类之间有所不同。例如，这两个服务类中的`GetUser`方法可能在签名上有所不同，这使得开发者的生活变得困难，因为你必须修改`GetUser`调用方法，包括服务引用更改。
- en: These flaws not only describe a poorly architected project but also become a
    developer's nightmare to refactor and maintain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺陷不仅描述了一个架构不良的项目，而且成为开发者重构和维护的噩梦。
- en: The solution - refactoring with DI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案 - 使用依赖注入进行重构
- en: 'As we all know, the Dependency Inversion Principle states the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，依赖倒置原则（Dependency Inversion Principle）表述如下：
- en: High-level modules should not depend on low-level modules. Both should depend
    on **abstractions**.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应该依赖于低级模块。两者都应该依赖于**抽象**。
- en: Abstractions should not depend on details. Details should depend on abstractions.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应该依赖于细节。细节应该依赖于抽象。
- en: Therefore, let's design the interfaces to abstract out the concrete classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们设计接口以抽象出具体类。
- en: 'Start from the last one in the hierarchy, which is the repository:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从层次结构的最后一个开始，即仓库：
- en: '![](img/7487ff3b-e86b-480e-a7ac-5520ffbc3fd5.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7487ff3b-e86b-480e-a7ac-5520ffbc3fd5.png)'
- en: 'The abstraction for the repository would look like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的抽象看起来如下：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, `UsersRepository` would implement `IUsersRepository` as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`UsersRepository`将如下实现`IUsersRepository`：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Interface extraction
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口提取
- en: 'Do you know how easy it is to extract an interface out of a class? It''s very
    easy and effective with Visual Studio. Let''s see the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道从类中提取接口有多容易吗？使用Visual Studio非常容易且有效。让我们看看以下步骤：
- en: Hover on the concrete class; you will see a bulb at the left side.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在具体类上；你会在左侧看到一个灯泡。
- en: 'Click on that to open a drop-down menu. Refer to the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它以打开下拉菜单。参见图示：
- en: '![](img/0a1663e5-99b6-41d1-9af6-3d7527067b01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a1663e5-99b6-41d1-9af6-3d7527067b01.png)'
- en: Select the `Extract` Interface.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`提取接口`。
- en: 'A modal pops up which also lists the public members of the class. See the following
    screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会弹出一个模态窗口，其中也列出了类的公共成员。参见以下截图：
- en: '![](img/4ee3d902-fa21-4d9c-919a-7eda2914b586.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ee3d902-fa21-4d9c-919a-7eda2914b586.png)'
- en: Hit OK. It will create the interface for you.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”。它将为您创建接口。
- en: 'There is another way to extract an interface. You can write the interface name
    and then do a *Ctrl* + *.* (dot) so that the option bubble appears. You need to
    select either of the top two options to generate the interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种提取接口的方法是，你可以写下接口名称，然后按*Ctrl* + *.*（点），这样就会出现选项气泡。你需要选择顶部两个选项之一来生成接口：
- en: '![](img/1fc8f6e0-c1f6-4ecc-b9a3-6ae91d585fa9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fc8f6e0-c1f6-4ecc-b9a3-6ae91d585fa9.png)'
- en: However, there is a difference in comparison to the first approach; its marked
    with the red block. If you select either of the `Generate` options shown in the
    screenshot, it will create a block for interface with a blank block without any
    code inside it (indicated inside the red block). However, in the first case, we
    had the opportunity to select the public members to include them in the interface.
    Imagine a huge class with lots of public members. Undoubtedly, the first approach
    wins for obvious reasons as previously described.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与第一种方法相比，这里有一个区别；它用红色块标记了。如果你选择截图中所显示的任何 `Generate` 选项，它将创建一个带有空白块的接口块，其中没有任何代码（如红色块内所示）。然而，在第一种情况下，我们有选择将公共成员包含在接口中的机会。想象一下一个具有大量公共成员的大类。毫无疑问，正如之前所述，第一种方法在明显的原因下获胜。
- en: 'Alright. Now we can modify the `UsersService` to inject the repository as a
    dependency instead of instantiating using the `new` keyword inside the constructor.
    The `IUsersService` interface can be designed as we did for the repository in
    order to use it inside the controller, which we will see in a while:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们可以修改 `UsersService`，将其作为依赖项注入，而不是在构造函数中使用 `new` 关键字来实例化。`IUsersService`
    接口可以设计成我们为仓库所做的那样，以便在控制器中使用，我们稍后会看到：
- en: '![](img/05c82b32-7b0b-461c-907c-2ba6bdfe3bf9.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05c82b32-7b0b-461c-907c-2ba6bdfe3bf9.png)'
- en: '`IUsersService` is just a simple interface with `GetUser` as a public member:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUsersService` 只是一个简单的接口，其中 `GetUser` 是一个公共成员：'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`UsersService` can be modified now to implement `IUsersService`. Injection
    can be done using the Constructor Injection pattern to inject the `IUserRepository`
    dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以修改 `UsersService` 以实现 `IUsersService`。可以使用构造函数注入模式来注入 `IUserRepository`
    依赖项：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This change will trigger a modification to the controller; otherwise the compiler
    would complain. Let''s make the compiler happy:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将触发对控制器的修改；否则，编译器会报错。让我们让编译器高兴起来：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can now inject/insert the repository instance to the service inside the controller
    action `Edit`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将仓库实例注入到控制器中的 `Edit` 动作服务中。
- en: So far, we have eliminated one concrete reference from the architecture that
    is from the `UsersService` class. It's very important to understand our goal.
    We are actually trying to get every dependency in one place so that the design
    gets simplified. Thus, with minimal change, we can easily inject different types
    of dependency into the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从架构中消除了一个具体引用，即来自 `UsersService` 类的引用。理解我们的目标是至关重要的。我们实际上是在尝试将每个依赖项放在一个地方，以便简化设计。因此，通过最小的更改，我们可以轻松地将不同类型的依赖项注入到系统中。
- en: For example, our `UsersService` is now taking responsibility for managing the
    `UsersRepository` dependency instead of the service managing it internally with
    a tight coupling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的 `UsersService` 现在负责管理 `UsersRepository` 依赖项，而不是服务内部通过紧密耦合来管理它。
- en: However, we are still not done. We have another clearly visible dependency in
    the controller instantiated using the `new` keyword inside the action `Edit` and
    that is none other than the `UsersService`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完成。我们还有一个明显的依赖项在控制器中，使用 `new` 关键字在 `Edit` 动作中实例化，那就是 `UsersService`。
- en: 'The refactored injectible `UsersController` would look like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的可注入 `UsersController` 将如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Simple, isn't it? Constructor Injection again comes to our rescue and allows
    us to inject the service so that we can use it for further operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？构造函数注入再次拯救了我们，并允许我们注入服务，以便我们可以用于后续操作。
- en: 'Awesome, now we removed all dependencies. Go ahead and run the app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，现在我们移除了所有依赖项。继续运行应用程序：
- en: '![](img/57020285-5416-42e4-b3e2-57a2503a9318.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57020285-5416-42e4-b3e2-57a2503a9318.png)'
- en: Unfortunately, it threw an exception. It isn't a surprise. The framework would
    expect one parameter less constructor inside the controller which we don't have
    anymore and then it found one parameterized constructor accepting the `IUsersService`
    implementation instance which was never provided anywhere in the app. Thus, the
    exception was formulated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它抛出了一个异常。这并不奇怪。框架期望控制器中的构造函数少一个参数，而我们不再有这个参数，然后它发现了一个接受 `IUsersService`
    实现实例的参数化构造函数，而这个实例在应用程序的任何地方都没有提供。因此，异常被形成。
- en: 'Okay, I know what you are thinking. Adding one parameter less or default constructor
    won''t change the scene. Rather it will show the following in the browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我知道你在想什么。添加一个参数更少或默认构造函数不会改变场景。相反，它会在浏览器中显示以下内容：
- en: '![](img/5fc28848-c597-42cc-9482-e8261406f8d4.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fc28848-c597-42cc-9482-e8261406f8d4.png)'
- en: Moreover, DI does not recommend using multiple constructors, so that is not
    an option anyway.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖注入（DI）不推荐使用多个构造函数，所以这也不是一个选择。
- en: Before we go ahead with the solution, let me summarise what we have done so
    far.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续解决方案之前，让我总结一下到目前为止我们所做的工作。
- en: We created abstractions for concrete classes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为具体类创建了抽象
- en: We replaced new keywords with constructors injected with abstractions
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用带有抽象的构造函数注入替换了`new`关键字
- en: In the process, we also modified the default constructor of `UsersController`
    to inject the `IUsersService` dependency
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还修改了`UsersController`的默认构造函数，以注入`IUsersService`依赖
- en: However, we received exceptions. That is because we have neither instantiated
    any implementation of the `IUsersService` interface nor provided it to the constructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了异常。这是因为我们既没有实例化`IUsersService`接口的任何实现，也没有将其提供给构造函数。
- en: 'We need to do two more things to make the app run. That is to let the compiler
    know what the implementations of the following are:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序运行，我们还需要做两件事。那就是让编译器知道以下实现的细节：
- en: '`IUsersService` interface'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IUsersService`接口'
- en: '`IUsersRepository` interface'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IUsersRepository`接口'
- en: 'That can be done with an IoC Container. As we are on .NET Core 2.0, let''s
    use the built-in container and see what happens. The `ConfigureServices` method
    of the `Startup` class would look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个IoC容器来完成。既然我们使用的是.NET Core 2.0，让我们使用内置的容器并看看会发生什么。`Startup`类的`ConfigureServices`方法看起来如下：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run the app now:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行应用程序：
- en: '![](img/b96498fe-fcd1-4546-9f01-953678456324.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b96498fe-fcd1-4546-9f01-953678456324.png)'
- en: Finally, it runs. Everything is perfect and we got the output in the browser,
    thanks to the DI engine of .NET Core and yes, of course, to the progress you have
    made so far with the book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它运行起来了。一切都很完美，我们在浏览器中得到了输出，多亏了.NET Core的DI引擎，当然，也多亏了你在这本书中到目前为止所取得的进步。
- en: We did a fabulous job in refactoring the classes to inject dependencies instead
    of referring concrete classes which were inefficient and not maintainable. Still,
    the tight coupling is not totally eliminated. The service is still returning a
    database model class `User` instance to the controller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在重构类以注入依赖而不是引用具体类方面做得非常出色，这些具体类效率低下且难以维护。尽管如此，紧耦合并没有完全消除。服务仍然向控制器返回数据库模型类`User`的实例。
- en: Imagine a three-layered architecture, where the layers can be the `ASP.NET MVC
    Web App Layer`, `Service/Business Layer`, and `Data Access Layer`. If a developer
    uses the model classes directly in the presentation layer (`ASP.NET MVC Web App
    Layer`), that means it is tightly coupled and can't live without a reference to
    the `Data Access Layer` in the project. In the next section, we will see such
    a problem and try to refactor it to DI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个三层架构，其中层可以是`ASP.NET MVC Web App Layer`、`Service/Business Layer`和`Data Access
    Layer`。如果一个开发者在表示层（`ASP.NET MVC Web App Layer`）直接使用模型类，这意味着它是紧密耦合的，并且不能在没有项目中的`Data
    Access Layer`引用的情况下生存。在下一节中，我们将看到这样的问题，并尝试将其重构为依赖注入。
- en: Layered architecture
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层架构
- en: 'In a typical modern ASP.NET MVC web app, you will find a three-layered architecture
    with isolated components depending on each other as shown in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的现代ASP.NET MVC Web应用程序中，你会找到一个三层架构，其中各个层相互独立且相互依赖，如下面的图所示：
- en: '![](img/877c5277-733d-409e-8e5e-ef8fffdb14ff.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/877c5277-733d-409e-8e5e-ef8fffdb14ff.png)'
- en: When we say some layer depends on another, that means the layer that depends,
    needs instances of the dependency objects to perform certain operations. As we
    saw in the previous section, to get a user from the database, the controller was
    asking the service to provide it from the repository. Thus, we can easily separate
    the classes and package them as components or a class library, speaking technically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说某个层依赖于另一个层时，这意味着依赖的那个层需要依赖对象的实例来执行某些操作。正如我们在上一节中看到的，要从数据库获取用户，控制器会要求服务从存储库中提供它。因此，我们可以很容易地将类分离并将它们作为组件或类库打包，从技术角度来说。
- en: That means my controller remains in `UI Layer` or `Presentation Layer`, `Service
    Class` make another layer who talks to the database through `Data Access Layer`
    classes. Now, as we chose Dependency Injection Technique to manage the dependencies,
    it's the responsibility of the IoC Container to provide the dependent `Data Access
    Layer` objects to the `Service Layer`, and `Service Layer` objects to the UI Layer.
    Most importantly, it takes the control from each layer for object creation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我的控制器仍然位于`UI Layer`或`Presentation Layer`，`Service Class`则创建另一个层，该层通过`Data
    Access Layer`类与数据库通信。现在，由于我们选择了依赖注入技术来管理依赖关系，因此IoC容器负责向`Service Layer`提供依赖的`Data
    Access Layer`对象，并向UI层提供`Service Layer`对象。最重要的是，它从每个层中接管了对象创建的控制权。
- en: The problem - The concrete class reference again
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 - 再次是具体类的引用
- en: I think you may not have noticed one thing in the last section. We tried to
    decouple the system as far as we could. But we have not totally achieved a loosely
    coupled architecture. Let me explain in the next paragraph.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '我想你可能没有注意到上一节中的一个东西。我们尽可能地解耦了系统。但我们并没有完全实现松散耦合的架构。让我在下一段中解释。 '
- en: 'Composition Root is the place where we register all the dependencies to be
    used by the application. The `ConfigureServices` method in the `Startup` class
    was the location of this dependency registration as we saw:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 组合根是注册所有应用程序将使用的依赖项的地方。`Startup`类中的`ConfigureServices`方法就是依赖项注册的位置，正如我们所看到的：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that we are saying, take the `UsersService` instance when `IUserService`
    dependency is required and the `UsersRepository` instance when `IUsersRepository`
    is required. So, basically, we now have to get the assembly references of both
    `Service Layer` and `Data Access Layer` in order to run this code without compilation
    issues. Check out the following screenshot, which proves what I just said:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们说，当需要`IUserService`依赖项时，取`UsersService`实例，当需要`IUsersRepository`时，取`UsersRepository`实例。所以，基本上，我们现在必须获取`Service
    Layer`和`Data Access Layer`的组件引用，才能在没有编译错误的情况下运行此代码。查看以下截图，它证明了我说的话：
- en: '![](img/d51c44e6-078c-46d8-95ee-81e4513f18c8.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d51c44e6-078c-46d8-95ee-81e4513f18c8.png)'
- en: Whatever classes we have designed so far are just separated out in these three
    layers. The repository is in the `Data Access Layer` and the service is inside
    the `Business Layer`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止设计的所有类都只是在这三个层次中分离出来。仓库位于`Data Access Layer`，而服务位于`Business Layer`内部。
- en: Clearly, you can see there is a `Business Layer` assembly reference in the UI
    Layer. As the `Business Layer` has a reference to the `Data Access Layer`, so
    automatically it is carried over to the UI Layer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，你可以看到在UI层中存在一个`Business Layer`的引用。由于`Business Layer`有一个对`Data Access Layer`的引用，所以它自动传递到UI层。
- en: Due to this, the `Presentation Layer` now has access to various implementations
    of the `Service Layer` and `Data Access Layer`. This is a very bad coding practice
    as we are trying to violate the layered architecture concept altogether. There
    is no separation existing between the layers. Moreover, developers can misuse
    the concrete class implementations, as they have direct access due to the assembly
    reference. This is not acceptable at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Presentation Layer`现在可以访问`Service Layer`和`Data Access Layer`的各种实现。这实际上是一种非常糟糕的编码实践，因为我们试图完全违反分层架构的概念。层与层之间没有存在分离。此外，由于开发者可以直接通过引用访问具体的类实现，他们可能会滥用这些实现。这是绝对不可接受的。
- en: Misuse of business and Data Access Layer assemblies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业层和数据访问层组件的滥用
- en: 'Here we will discuss how we, as developers, could misuse the layers in the
    code by direct reference to the layers. Let''s try to understand a few scenarios
    where these assemblies can be misused in the `UI Layer`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论作为开发者，我们如何通过直接引用层来滥用代码中的层。让我们尝试理解一些在这些组件中可能被滥用的场景，特别是在`UI Layer`中：
- en: '**Direct Business Layer Service Access**: As we have a reference of `Business
    Layer`, so we can instantiate it and then call the `GetUser()` method. We needed
    a `Repository` instance for the `Service` constructor, which we can also easily
    provide.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接访问业务层服务**：由于我们有`Business Layer`的引用，因此我们可以实例化它，然后调用`GetUser()`方法。我们需要一个`Repository`实例用于`Service`构造函数，这也可以很容易地提供。'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how we can easily instantiate the `UsersService` class by passing the `Repository`
    instance to its constructor. That means we still love the `new` keyword.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何可以轻松地通过将`Repository`实例传递给其构造函数来实例化`UsersService`类。这意味着我们仍然喜欢使用`new`关键字。
- en: '**Direct Data Access Repository Access**: Why go through `Service` when we
    have the `Data Access` reference? Why not directly deal with the Repository to
    get the data? Cool isn''t it!'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接数据访问仓库访问**：当我们已经有了`数据访问`引用时，为什么还要通过`服务`呢？为什么不直接与仓库打交道来获取数据？这不是很酷吗！'
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Yet another `new` keyword usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种`new`关键字的使用。
- en: '**Direct Data Layer Context Access**: Even better is the following approach
    where we don''t even need these intermediate `Service` or `Repository` instances.
    We can directly get data from contexts:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接数据层上下文访问**：更好的是以下方法，我们甚至不需要这些中间的`服务`或`仓库`实例。我们可以直接从上下文中获取数据：'
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`DataContext` can provide the data directly inside the Controller Action as
    shown in the preceding code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataContext`可以在控制器操作中直接提供数据，如前述代码所示。'
- en: We destroyed the layered architecture and the modules are not independent anymore.
    Rather the `Business Layer` and `Data Access Layer` are now tightly coupled with
    the `UI Layer`. This happened just because we had to register concrete implementations
    for the interfaces with the Service Collections inside the `ConfigureServices`
    method. For DI injection to take place, we need this registration step so that
    we can ask the container for dependencies whenever required.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们破坏了分层架构，模块也不再是独立的。相反，`业务层`和`数据访问层`现在与`UI层`紧密耦合。这仅仅是因为我们不得不在`ConfigureServices`方法内部为接口注册具体的实现到服务集合中。为了进行依赖注入，我们需要这个注册步骤，这样我们就可以在需要时向容器请求依赖项。
- en: Now, we have to find a way. Let's discover a best practice for this kind of
    problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须找到一种方法。让我们为这类问题找到一个最佳实践。
- en: Best practice for layered architecture
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层架构的最佳实践
- en: Remember, you can do a ton of things to improve the architecture and optimize
    the performance whilst using DI techniques; however, you can't remove the assemblies
    from inside the `bin` folder of the ASP.NET MVP web application. You need to understand
    that the problem lies with access to different concrete implementations of the `Business
    Layer` and `Data Access Layer` inside the `Presentation Layer`; as we saw how devastating
    it can be when developers try to play with the layers instead of properly using
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用依赖注入技术的同时，你可以做很多事情来改进架构和优化性能；然而，你不能从ASP.NET MVP Web应用的`bin`文件夹中移除程序集。你需要理解，问题在于`表示层`对`业务层`和`数据访问层`内部的不同具体实现访问；正如我们所见，当开发者试图玩弄层而不是正确使用它们时，这可能会造成灾难性的后果。
- en: Therefore, we need to figure out a way to overcome this situation and not allow
    the `Presentation Layer` to access the concrete classes of other layers while
    being benefited by Dependency Injection. The solution is MEF. Let's explore more
    in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找出一种方法来克服这种情况，不让`表示层`在受益于依赖注入的同时访问其他层的具体类。解决方案是MEF。让我们在下一节中进一步探讨。
- en: Managed Extensibility Framework (MEF)
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理扩展性框架 (MEF)
- en: Before exploring MEF, let me summarize the problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索MEF之前，让我总结一下这个问题。
- en: '**Tight coupling:** Concrete classes are referenced inside the `UI Layer` by
    DI during the `Startup` inside `ConfigureServices` method.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**紧密耦合**：在`ConfigureServices`方法中的`Startup`阶段，通过依赖注入在`UI层`内部引用了具体的类。'
- en: So, basically, we need to do some automation which enables us not to depend
    upon concrete classes of other layers. That is where MEF comes into the picture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们需要做一些自动化工作，这样我们就不依赖于其他层的具体类。这就是MEF发挥作用的地方。
- en: MEF is a library for creating lightweight extensible applications. With the help
    of MEF, developers can easily build the an app to automatically bind extensions
    together without any configurations. There is more on MEF at [https://docs.microsoft.com/en-us/dotnet/framework/mef/index](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)[.](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MEF是一个用于创建轻量级可扩展应用的库。借助MEF，开发者可以轻松构建一个应用程序，自动将扩展绑定在一起，而无需任何配置。有关MEF的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/framework/mef/index](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)[.]。
- en: We are not going deeply into the MEF; you can do that from the preceding link
    I shared. We just need to understand how we can solve our issue with MEF. For
    example, we have a `Service` class and a `Repository` class which we don't want
    to expose to UI for direct consumption as we saw in our preceding code snippets.
    MEF would do that for us by pulling the classes required to register the dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 MEF；您可以从我分享的先前的链接中了解。我们只需要了解我们如何用 MEF 解决我们的问题。例如，我们有一个 `Service` 类和一个
    `Repository` 类，我们不想将其直接暴露给 UI 以供消费，就像我们在先前的代码片段中看到的那样。MEF 会为我们做这件事，通过拉取注册依赖项所需的类。
- en: 'The following diagram depicts the role MEF is going to play in our app:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了 MEF 在我们的应用中将扮演的角色：
- en: '![](img/84fe4a37-b067-4153-bc63-a5eed43e85ad.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84fe4a37-b067-4153-bc63-a5eed43e85ad.png)'
- en: You can see we have `ModuleInit` classes in every layer with one `Init()` method
    and these classes implement a common interface called `IModule`. It's obvious
    that the DLLs of all the layers will be there in the `bin` folder of the ASP.NET
    MVC Web Project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在每个层级中我们都有 `ModuleInit` 类，每个类都有一个 `Init()` 方法，并且这些类实现了一个名为 `IModule` 的通用接口。很明显，所有层级的
    DLL 都将位于 ASP.NET MVC Web 项目的 `bin` 文件夹中。
- en: 'Now the interesting scene. MEF gets all assemblies from the `bin` folder of
    the App, then it does the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的一幕。MEF 从应用的 `bin` 文件夹中获取所有程序集，然后执行以下操作：
- en: Searches for the implementations of `IModule`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `IModule` 的实现。
- en: Fires the `Init()` method of each found module.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发每个找到的模块的 `Init()` 方法。
- en: In the next section, we will see the codes in different layers and how MEF can
    bring back loosely coupled modules to optimise the architecture.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到不同层级的代码以及 MEF 如何将松散耦合的模块带回来以优化架构。
- en: Layers and MEF implementation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层级和 MEF 实现
- en: Before going into the code in some depth, let's first analyze the layers. So,
    there are three layers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，让我们首先分析一下层级。所以，这里有三个层级。
- en: '**Web App Layer:** Contains `Controller`, `View`, and so on. Most importantly,
    it has the entry point `Startup.cs`.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Web 应用层：** 包含 `Controller`、`View` 等。最重要的是，它有入口点 `Startup.cs`。'
- en: '**Business/Service Layer:** Contains the `Services` where we can include our
    business logic.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**业务/服务层：** 包含 `Services`，其中我们可以包含我们的业务逻辑。'
- en: '**Data Access Layer:** Contains `Contexts`, `DbSets`, and `Repository` for
    data retrieval from the database.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据访问层：** 包含 `Contexts`、`DbSets` 和 `Repository`，用于从数据库中检索数据。'
- en: 'Let''s have a quick look at the `Visual Studio Solution` window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下 `Visual Studio 解决方案` 窗口：
- en: '![](img/5b265d83-5dbe-47be-acc9-6cc7b21a2e61.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b265d83-5dbe-47be-acc9-6cc7b21a2e61.png)'
- en: We have organized our classes into different layers. Interestingly, we have
    introduced another layer named as `Common Layer`, where we have placed all common
    code related to `Business Layer` and `Data Access Layer`. A common project is
    referenced both by `Business Layer` and `Data Access Layer`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的类组织到不同的层级中。有趣的是，我们引入了另一个名为 `Common Layer` 的层，其中我们放置了与 `Business Layer`
    和 `Data Access Layer` 相关的所有通用代码。一个通用项目被 `Business Layer` 和 `Data Access Layer`
    同时引用。
- en: This common code will help us fetch the dependencies from assemblies related
    to different layers and package them into one (called `ModuleLoader`) so that
    the web app can call just one method to initiate everything. Let's understand
    each part one by one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这段通用代码将帮助我们从与不同层级相关的程序集中获取依赖项，并将它们打包成一个（称为 `ModuleLoader`），这样 web 应用就可以通过调用一个方法来启动一切。让我们逐个理解每个部分。
- en: Introduction of IUser
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 IUser
- en: The goal is to remove the concrete class access from the UI layer. We started
    to move all common items into one central layer called `Common`. As we moved `IUsersService`
    to `Common`, we identified a `GetUser` method, which is actually returning a concrete
    `User` instance. Moreover, `UserService` inside the `Business Layer` also has
    the same method as it implements `IUsersService`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是从 UI 层移除对具体类的访问。我们开始将所有通用项移动到一个名为 `Common` 的中央层。当我们把 `IUsersService` 移到 `Common`
    时，我们识别了一个 `GetUser` 方法，它实际上返回一个具体的 `User` 实例。此外，`Business Layer` 内的 `UserService`
    也有相同的方法，因为它实现了 `IUsersService`。
- en: 'The following code shows how the return type of `GetUser` can be updated to
    `IUser` type instead of `User` type:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何将 `GetUser` 方法的返回类型从 `User` 类型更新为 `IUser` 类型：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to get rid of this `User` class dependency, otherwise, `Common Layer`
    has to again refer to the `Data Access Layer` because the `User` resides in that,
    which is the same case for `Business Layer` to refer `Data Access`. Moreover,
    `Common` is designed to be referred by other layers and not to get other layers
    references inside itself. It should be free from project dependencies. This is
    important.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要消除对`User`类的依赖，否则`Common Layer`又必须再次引用`Data Access Layer`，因为`User`类就位于那里，对于`Business
    Layer`引用`Data Access`的情况也是一样的。此外，`Common`被设计成可以被其他层引用，而不是在自身内部获取其他层的引用。它应该摆脱项目依赖。这一点很重要。
- en: The solution is very easy. One `IUser` interface can be added inside the `Common/Entities/Users` directory,
    which will be used as a return type for the `GetUser` method. So, `GetUser` inside `UsersService`
    and `UsersRepository` can return the `IUser` type instead of the `User` instance.
    Now we can easily remove the coupling of `Data Access` with the `Common Layer`.
    Also `Data Access` coupling with the `Business Layer`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常简单。在`Common/Entities/Users`目录中添加一个`IUser`接口，它将被用作`GetUser`方法的返回类型。因此，`UsersService`和`UsersRepository`中的`GetUser`可以返回`IUser`类型而不是`User`实例。现在我们可以轻松地消除`Data
    Access`与`Common Layer`的耦合。同样，`Data Access`与`Business Layer`的耦合。
- en: 'The following diagram tells us what was wrong when we used `User` class. We
    had references to the `Common Layer` and `Data Access Layer` in the `Business
    Layer`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示告诉我们，当我们使用`User`类时出了什么问题。在`Business Layer`中存在对`Common Layer`和`Data Access
    Layer`的引用：
- en: '![](img/fb81c646-ecdf-482b-86ca-6c67be4f09f6.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb81c646-ecdf-482b-86ca-6c67be4f09f6.png)'
- en: 'The following is the approach which is correct with an interface `IUser`, which
    allows us to reduce the coupling of layers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的方法使用接口`IUser`是正确的，它允许我们减少层的耦合：
- en: '![](img/f327c048-c7b6-4e4d-a3c2-f3097482ab56.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f327c048-c7b6-4e4d-a3c2-f3097482ab56.png)'
- en: Now there is no need for a reference to the `Data Layer` inside the `Common
    Layer`. On the contrary, the `Business Layer` and `Data Layer` are dependent on
    `Common`, which is our intention.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Common Layer`内部不再需要`Data Layer`的引用。相反，`Business Layer`和`Data Layer`依赖于`Common`，这正是我们的意图。
- en: The IModuleRegistrar interface
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IModuleRegistrar 接口
- en: The `IModuleRegistrar` interface is responsible for adding the dependency into
    the service collection. Basically, the implementer of this interface will have
    an `Add()` method with the signature mentioned, which does the job of the `Add***` (`AddTransient`/`AddScoped`/`AddSingleton`)
    methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`IModuleRegistrar`接口负责将依赖项添加到服务集合中。基本上，实现此接口的类将有一个具有指定签名的`Add()`方法，该方法执行`Add***`（`AddTransient`/`AddScoped`/`AddSingleton`）方法的工作。'
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is present inside the `Common Layer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`Common Layer`中实现的。
- en: The ModuleRegistrar class
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ModuleRegistrar 类
- en: '`ModuleRegistrar`, which implements the previously mentioned interface, will
    look something like the following. This basically behaves as a wrapper for the
    built-in IoC Container to register dependencies:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModuleRegistrar`，该类实现了之前提到的接口，其结构大致如下。它基本上是一个内置 IoC 容器的包装器，用于注册依赖项：'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice the two important aspects of this class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个类的两个重要方面：
- en: '`IServiceCollection` is injected into the constructor'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IServiceCollection`被注入到构造函数中'
- en: Injected `IServiceCollection` used to add dependencies into the container using
    `ServiceDescriptor` instance
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ServiceDescriptor`实例注入`IServiceCollection`，用于将依赖项添加到容器中
- en: This class is a part of the Common Library.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是 Common 库的一部分。
- en: '**Service Descriptor:** `IServiceCollection` is the collection of the service
    descriptors. A Service Descriptor instance when created can provide full information
    about a service or dependency. We have different methods for different lifestyles
    such as `AddTransient`, `AddScoped`, and `AddSingleton` to register dependencies.
    However, we can''t write all three methods to manage the dependencies at a commonplace.
    That is where a Service Descriptor can help takes lifetime as a parameter and
    can be added directly to the `ServiceCollection` using the `Add` method.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务描述符**：`IServiceCollection`是服务描述符的集合。当创建服务描述符实例时，它可以提供关于服务或依赖项的完整信息。我们有不同的方法用于不同的生命周期，如`AddTransient`、`AddScoped`和`AddSingleton`来注册依赖项。然而，我们无法将所有三种方法都写在一个地方来管理依赖项。这就是服务描述符发挥作用的地方，它可以将生命周期作为参数，并可以直接使用`Add`方法将其添加到`ServiceCollection`中。'
- en: The IModule interface
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IModule 接口
- en: '`IModule` is the main hero of the architecture because this is the first thing
    which will be used by a Loader to recognize what modules are required to be fetched
    from all the assemblies that are targeted. This interface exposes one method, `Initialize()` which
    is invoked by the Loader to add dependencies into the container. Consider the
    following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`IModule`是架构中的主要英雄，因为这是Loader首先使用的东西，用于识别需要从所有目标程序集中获取哪些模块。此接口公开一个方法，`Initialize()`，由Loader调用以将依赖项添加到容器中。考虑以下代码片段：'
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This interface lies inside Common Library as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口也位于通用库中。
- en: The ModuleInit class
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ModuleInit`类'
- en: 'Let''s see how the preceding `IModule` interface can be implemented inside
    the `Business Layer`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的`IModule`接口如何在`Business Layer`中实现：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ModuleInit` is present inside both the `Business Layer` and `Data Access Layer`.
    This class helps us to add different dependencies in each layer such as `UsersService`
    in `Business` and `UsersRepository` in `Data Access`. You can see how `UserService`
    is added to the registrar inside `Business Layer`. I am skipping `ModuleInit`
    of the `DataAccess Layer`. It''s just a change of one line inside `Initialize`.
    The following line of code can be added for `UserRepository` dependency registration
    inside `ModuleInit` of `Data Access Layer`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModuleInit`存在于`Business Layer`和`Data Access Layer`中。这个类帮助我们向每一层添加不同的依赖项，例如在`Business`中的`UsersService`和在`Data
    Access`中的`UsersRepository`。您可以看到`UserService`是如何在`Business Layer`中添加到注册器的。我正在跳过`Data
    Access Layer`中的`ModuleInit`。它只是在`Initialize`中更改了一行。以下代码可以在`Data Access Layer`的`ModuleInit`中添加以注册`UserRepository`依赖项：'
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just make a note of the bold part `([Export(typeof(IModule))])` in the last-but-one
    code block, which is very important. This is the attribute, which helps MEF to
    grab the `ModuleInit` classes in the specified assemblies, with the interface
    `IModule`. It can then easily call `Initialize` to start the process of registering
    dependencies. We will very soon see the code, that does this task for us.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意最后第二个代码块中的粗体部分`([Export(typeof(IModule))])`，这非常重要。这是一个属性，它帮助MEF从指定的程序集中抓取具有`IModule`接口的`ModuleInit`类。然后它可以轻松调用`Initialize`以启动注册依赖项的过程。我们很快就会看到执行此任务的代码。
- en: Wait! We have a Constructor Injection here. And what is that used for? Actually,
    the code for registering the dependency lies inside the registrar, so we definitely
    need the `IModuleRegistrar` dependency in order to call `Add()` of `Registrar`,
    which registers the required dependency, for example, `UsersService` here inside
    `Business Layer`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！这里有一个构造函数注入。那它是用来做什么的呢？实际上，注册依赖项的代码位于注册器内部，因此我们确实需要`IModuleRegistrar`依赖项来调用`Registrar`的`Add()`方法，以便注册所需的依赖项，例如在`Business
    Layer`中的`UsersService`。
- en: 'Check out the flow of controls during the process of dependency registrations.
    Typically the flow is like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 检查依赖项注册过程中的控件流。通常流程如下：
- en: '`ModuleLoader` | `ModuleInit(IRegistrar)` | `ModuleRegistrar` | `Add()` (adds
    the dependency to collection):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModuleLoader` | `ModuleInit(IRegistrar)` | `ModuleRegistrar` | `Add()`（将依赖项添加到集合）：'
- en: 'The following diagram visualizes the work of **Module Loader** through the
    available layers as discussed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表通过讨论的可用层可视化了**模块加载器**的工作：
- en: '![](img/64d3c9f2-a4db-427e-bc1b-a9bd16890fb0.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64d3c9f2-a4db-427e-bc1b-a9bd16890fb0.png)'
- en: The ModuleLoader class
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块加载器类
- en: To work with MEF, we need a Nuget package known as </span>`Microsoft.Composition.`
    This will install `System.Composition` into the project. You need to add the package
    inside the `Common Layer`. `ContainerConfiguration` is the class present inside
    the `System.Composition.Hosting` namespace, which composes all assemblies and
    can provide us with a Container, from which we can easilyextract the required
    concrete implementations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MEF，我们需要一个名为`Microsoft.Composition`的Nuget包。这将`System.Composition`安装到项目中。您需要在`Common
    Layer`中添加此包。`ContainerConfiguration`是`System.Composition.Hosting`命名空间中的类，它组合所有程序集，并可以为我们提供一个容器，我们可以从中轻松提取所需的具体实现。
- en: 'The following screenshot is the `NuGet` Package preview shown in the NuGet
    Package Manager window when you search:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是在NuGet包管理器窗口中搜索时显示的`NuGet`包预览：
- en: '![](img/c8b5c02b-44b6-42f5-9f65-79fe3ef5a5f3.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8b5c02b-44b6-42f5-9f65-79fe3ef5a5f3.png)'
- en: 'Finally the last, but not the least,  `ModuleLoader`. All that we have learned
    till now is managed by the Loader which is a static class with one method `LoadContainer`.
    This method is invoked by our MVC Web App `Startup` to initialize the dependency
    registration process. Let''s have a sneak peek at the codes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，是 `ModuleLoader`。我们至今所学的一切都由 Loader 管理，它是一个具有一个方法 `LoadContainer`
    的静态类。此方法由我们的 MVC Web App `Startup` 调用以初始化依赖项注册过程。让我们先睹为快代码：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I have added comments over each step so that it will be easy for you to analyze
    the steps. The steps can be defined as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每个步骤上都添加了注释，这样你就可以轻松分析这些步骤了。这些步骤可以定义为以下内容：
- en: Get the `Web App Assembly Location`. As we are going to call this method from
    Web App and every other assembly is placed there, we need that location to find
    others.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `Web App 程序集位置`。由于我们将从这个 Web App 调用此方法，并且每个其他程序集都放置在那里，我们需要这个位置来查找其他程序集。
- en: 'Find out, what other assemblies present in that particular location. However,
    we need to have DLLs of the layers we have in our app. For that reason, a pattern
    is necessary to recognize the assemblies of the layers. According to our layers,
    we only need to find all assembly names starting with PacktDIExamples and ending
    with `.dll`, because the Layer names are like `PacktDIExamples.Business.dll` and `PacktDIExamples.DataAccess.dll`.
    So, the pattern will be `PacktDIExamples.*.dll`. We will see the code sends this
    pattern to the `LoadContainer` in a moment. You can see the extracted modules
    shown in the Visual Studio tooltip while debugging, shown as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找在该特定位置存在的其他程序集。然而，我们需要我们应用中层的 DLL。因此，需要一个模式来识别层的程序集。根据我们的层，我们只需要找到所有以 PacktDIExamples
    开头并以 `.dll` 结尾的程序集名称，因为层名称类似于 `PacktDIExamples.Business.dll` 和 `PacktDIExamples.DataAccess.dll`。因此，模式将是
    `PacktDIExamples.*.dll`。我们将在稍后看到代码将此模式发送到 `LoadContainer`。你可以在调试时看到提取的模块，如下所示：
- en: '![](img/118fd71a-eb45-4c62-a0c7-ab68c473a375.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/118fd71a-eb45-4c62-a0c7-ab68c473a375.png)'
- en: Create a container to hold all the assemblies using the `ContainerConfiguration`
    instance.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ContainerConfiguration` 实例创建一个容器来保存所有程序集。
- en: Now `container.GetExports<IModule>()` is used to extract the `IModule` implementation
    from these assemblies.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 `container.GetExports<IModule>()` 用于从这些程序集中提取 `IModule` 实现
- en: Execute the `Initialize` method for each `IModule` implementations with a registrar
    instance as a dependency because the `Registrar` has the actual `Add` method for
    dependency registration with the `ServiceCollection`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注册实例作为依赖项为每个 `IModule` 实现执行 `Initialize` 方法，因为 `Registrar` 具有实际的 `Add` 方法，用于在
    `ServiceCollection` 中进行依赖项注册。
- en: I would advise you to put `try...catch` blocks in this method to handle the
    exceptions. Due to the space restrictions, I have not posted the `try...catch`
    block. I just want to show the core logic of a `ModuleLoader`. I have also removed
    the `usings`, which were taking up a lot of space. You can figure out the `usings`,
    anyway; if not, use Visual Studio. Hover on the red lines and then follow the
    steps which will include the required libraries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在该方法中添加 `try...catch` 块来处理异常。由于空间限制，我没有发布 `try...catch` 块。我只是想展示 `ModuleLoader`
    的核心逻辑。我还移除了占用大量空间的 `usings`，但你可以自己找出这些 `usings`；如果找不到，可以使用 Visual Studio。将鼠标悬停在红色行上，然后按照步骤进行，这些步骤将包括所需的库。
- en: Executing the ModuleLoader.LoaderContainer() method from Web App
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Web App 执行 ModuleLoader.LoaderContainer() 方法
- en: 'This is the final step and the simplest one. See how we can call this Loader
    from the Web App inside the `Startup` as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一步，也是最简单的一步。看看我们如何在 `Startup` 内部从 Web App 调用此 Loader，如下所示：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As I mentioned, we need to send a pattern to fetch the Assembly names from `bin/debug/netcoreapp2.0`;
    otherwise, it will fetch all assemblies, which is unnecessary.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，我们需要发送一个模式来从 `bin/debug/netcoreapp2.0` 获取程序集名称；否则，它会获取所有程序集，这是不必要的。
- en: Notice that we are sending the services to the `LoadContainer`. Now the previous
    code for registering the dependencies is commented, which got optimized by the `ModuleLoader.LoadContainer`
    call.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在正在将服务发送到 `LoadContainer`。现在之前的依赖项注册代码已被注释，并且通过 `ModuleLoader.LoadContainer`
    调用进行了优化。
- en: What have we achieved with MEF?
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们使用 MEF 实现了什么？
- en: If you have not yet realized the benefits of refactoring the layered architecture
    with MEF, have a close look at the following screenshot with explanations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有意识到使用 MEF 重构分层架构的好处，请仔细查看以下带有解释的截图。
- en: Layers are separated
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层被分隔
- en: 'Layers were tightly coupled as the UI was referencing the `Business Layer`
    and the `Data Access Layer`. Now after MEF, the UI is not tied to the `Data Access
    Layer` anymore. However, the UI has one `Business Layer` assembly reference as
    shown in the following screenshot. But that is not used anywhere inside the project.
    It is there because the assembly should be inside the `bin` folder so that the
    MEF Module is able to read it while initializing to export the `IModule` implementations.
    The following is a quick comparison of Project Dependencies before and after MEF:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 层与层之间紧密耦合，因为UI引用了`Business Layer`和`Data Access Layer`。现在在MEF之后，UI不再与`Data Access
    Layer`绑定。然而，UI有一个`Business Layer`程序集引用，如以下截图所示。但它在项目内部任何地方都没有被使用。它之所以存在，是因为程序集应该放在`bin`文件夹中，这样MEF模块在初始化时能够读取它，以便导出`IModule`实现。以下是在MEF实现前后项目依赖的快速比较：
- en: '![](img/a29dad10-90ff-43ba-b7a0-fd385789141e.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a29dad10-90ff-43ba-b7a0-fd385789141e.png)'
- en: If you try to remove the Business reference from the UI and run the app, it
    will throw an exception, as follows. And this is for obvious reasons. Unless you
    have the reference, MEF won't be able to extract the `IUsersService` implementation
    and register to the DI Container, simple!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从UI中移除业务引用并运行应用程序，它将抛出异常，如下所示。这是显而易见的原因。除非你有引用，否则MEF无法提取`IUsersService`实现并将其注册到DI容器中，简单！
- en: 'Thus, the issue happens as soon as you hit the controller, as nothing has been
    registered to the `IServiceCollection`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题发生在你点击控制器的那一刻，因为`IServiceCollection`上还没有注册任何内容：
- en: '![](img/f3c845fb-67be-48ee-917b-ad6b5b5fc745.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3c845fb-67be-48ee-917b-ad6b5b5fc745.png)'
- en: All classes inside layers are now internal
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在层内的所有类都是`internal`
- en: 'Instead of having `public` as the access specifiers for the classes, we can
    make them `internal` so that they are only accessible inside the assembly (this
    means only internally inside the Layer):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类的访问修饰符从`public`改为`internal`，这样它们就只能在程序集内部访问（这意味着只在Layer内部内部访问）：
- en: '>![](img/ffb885fe-c0ca-4295-8741-62720a46541f.png)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/ffb885fe-c0ca-4295-8741-62720a46541f.png)'
- en: No concrete class instantiation inside the UI Layer
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI层内部不允许有具体的类实例化
- en: Before MEF implementation, we saw how, inside the `Edit` action method, we could
    directly reference the `Data Access Layer` and `Business Layer` classes. Now we
    won't be able to do this because the classes are not accessible anymore.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在MEF实现之前，我们看到了如何在`Edit`操作方法内部直接引用`Data Access Layer`和`Business Layer`类。现在我们无法这样做，因为类不再可访问。
- en: 'That is proved from the compiler errors inside `UsersController` as shown in
    the following screenshot. Notice the tooltip preview, which indicates the unavailability
    of the UsersService. So, misusing classes of other layers is restricted even if
    you add the references:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以从`UsersController`内部的编译错误中得到证明，如以下截图所示。注意工具提示预览，它表明`UsersService`不可用。因此，即使添加了引用，也限制了滥用其他层的类：
- en: '![](img/1bf50224-e455-4124-bc5d-b38f56c0f499.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bf50224-e455-4124-bc5d-b38f56c0f499.png)'
- en: More layers can be added to the architecture
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以向架构中添加更多层
- en: When, in the future, you add more layers for optimisation or any other business-related
    requirements, that assembly can be simply referred to by the UI; then every dependency
    will automatically get registered to the IoC Container. Remember, you need have
    to a `ModuleInit` class implementing the interface `IModule` to automate the process.
    The application is totally flexible now, allowing new modules to be attached easily
    with no hassle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当未来为了优化或任何其他业务相关需求添加更多层时，该程序集可以简单地由UI引用；然后每个依赖项将自动注册到IoC容器中。记住，你需要有一个实现`IModule`接口的`ModuleInit`类来自动化这个过程。现在应用程序非常灵活，可以轻松地附加新模块，无需麻烦。
- en: Conclusion
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Most modern applications follow a layered architecture. Having a Dependency
    Injection technique to manage the dependencies required inside the layers is something
    we should be following. Having said that, we need to be careful with layer designs.
    That is because we applied DI, thinking that it would resolve issues of tight
    coupling with the dependencies of a class. However, we did not realize that the
    layers are getting connected with each other through concrete dependencies (such
    as the `User` instance return type).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序都遵循分层架构。拥有一种依赖注入技术来管理层内所需的依赖关系是我们应该遵循的。话虽如此，我们需要小心设计层。这是因为我们应用了DI，认为它将解决类依赖的紧密耦合问题。然而，我们没有意识到层通过具体的依赖关系（如`User`实例的返回类型）相互连接。
- en: '*Managed Extensibility Framework* provided us with a few easy steps to dynamically
    bind the dependencies from different layers, package them into one, and then register
    it to the container for further use by the controllers in the `UI Layer`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*托管扩展性框架*为我们提供了一些简单的步骤，用于动态绑定来自不同层的依赖项，将它们打包成一个，然后将其注册到容器中，以便 UI 层的控制器进一步使用。'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After learning DI Techniques, Patterns, Anti-Patterns and so on, we still needed
    some pointers to deal with practical scenarios where DI comes into play.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了 DI 技术、模式、反模式等内容之后，我们仍然需要一些指导来处理 DI 发挥作用的实际场景。
- en: We explored a few real-time application instances where DI can help eliminate
    coupling and introduce a cleaner dependency structure.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了一些实时应用程序实例，其中 DI 可以帮助消除耦合并引入更清晰的依赖结构。
- en: Tightly coupled systems are often seen when a developer tries to be lazy and
    instantiates the required dependencies directly inside the class using the `new` operator.
    Keep in mind that new is glue. This not only instills a bad practice in you as
    a coder but also makes your code untestable. Unit testing becomes difficult. We
    learned the technique to deal with the problem of tight coupling by following
    DI techniques.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者试图偷懒，直接在类中使用 `new` 操作符实例化所需的依赖项时，经常会看到紧密耦合的系统。请记住，`new` 是粘合剂。这不仅在你作为编码者时养成了一种不良习惯，而且也使得你的代码不可测试。单元测试变得困难。我们通过遵循
    DI 技术学习了处理紧密耦合问题的技术。
- en: Then we realized that layering in an application is a common approach with applications.
    Having DI is definitely going to help us in the long run for layered systems.
    However, there might be loose ends in the layered approach which should be addressed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们意识到在应用程序中分层是一种常见的方法。拥有 DI 一定会在长期内帮助我们处理分层系统。然而，分层方法中可能存在一些悬而未决的问题，需要解决。
- en: MEF is the technique which we adopted to solve a couple of problems with layered
    architecture. By implementing MEF, the business or data layer implementations
    can be marked as internal so that they are not exposed to other layers. Also,
    layer architectural rules for the separation of concerns can remain intact with
    a DI container. Thus, the layers can breathe independently without any interference
    and decorate the architecture in such a way that the introduction of new modules
    into it becomes very smooth.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MEF 是我们采用的技术，用于解决具有分层架构的一些问题。通过实现 MEF，业务或数据层实现可以被标记为内部，这样它们就不会暴露给其他层。此外，使用 DI
    容器，关注点分离的分层架构规则可以保持完整。因此，层可以独立呼吸，不受任何干扰，并以一种方式装饰架构，使得新模块的引入变得非常顺畅。
