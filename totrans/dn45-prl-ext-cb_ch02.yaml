- en: Chapter 2. Implementing Continuations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 实现延续
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Continuing a task
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续任务
- en: Passing task results to a continuation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务结果传递给延续
- en: Continue "WhenAny" and "WhenAll"
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续使用 "WhenAny" 和 "WhenAll"
- en: Specifying when a continuation will run
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定延续何时运行
- en: Using a continuation for exception handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延续进行异常处理
- en: Cancelling a continuation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消延续
- en: Using a continuation to chain multiple tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延续来链接多个任务
- en: Using a continuation to update a UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延续来更新UI
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When you are writing an application that has tasks and that execute in parallel,
    it is common to have some parallel tasks that depend on the results of other tasks.
    These tasks should not be started until the earlier tasks, known as antecedents,
    have been completed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个具有任务且并行执行的应用程序时，通常会有一些并行任务依赖于其他任务的结果。这些任务应该在被称为前驱的早期任务完成之后才开始。
- en: In fact, to write truly scalable software, you should not have threads that
    block. Calling `Wait` or querying `Task.Result`, when the task has not finished
    running, will cause your threads to block. Fortunately, there is a better way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为了编写真正可扩展的软件，你不应该有阻塞的线程。当任务尚未完成运行时调用`Wait`或查询`Task.Result`，将导致你的线程阻塞。幸运的是，有一种更好的方法。
- en: Prior to the introduction of the **Task Parallel Library** (**TPL**), this type
    of interdependent thread execution was done with callbacks, where a method was
    called, and one of its parameters was a delegate to execute when the task completed.
    This provided a viable solution to the dependency problems but quickly became
    very complex in the real-world application. This is especially true if, for example,
    you had a task that needed to run after several other tasks had completed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Task Parallel Library**（**TPL**）引入之前，这种相互依赖的线程执行是通过回调完成的，其中调用一个方法，其中一个参数是在任务完成时执行的委托。这提供了一种可行的解决方案来处理依赖性问题，但在实际应用中很快变得非常复杂。这尤其适用于，例如，你需要运行在几个其他任务完成之后的任务。
- en: With the TPL, a simpler solution exists in the form of continuation tasks. These
    tasks are linked to their antecedents, and are automatically started after the
    earlier tasks have been completed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TPL，存在一种更简单的解决方案，即延续任务。这些任务与前驱任务相关联，并在早期任务完成后自动启动。
- en: What makes continuations so powerful is that, you can create continuations that
    run when a task or a group of tasks completes throws an exception, or gets cancelled.
    As you will see in this chapter, continuations can even provide a means to synchronize
    the asynchronous method results with the user interface running on another thread.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 延续之所以如此强大，是因为你可以创建在任务或一组任务完成时抛出异常或被取消时运行的延续。正如你将在本章中看到的，延续甚至可以提供一种将异步方法的结果与在另一个线程上运行的用户界面同步的手段。
- en: We will start the chapter with a basic, simple continuation that runs when a
    single task completes. From there, we will look at using continuations to control
    a collection of tasks, using continuations to handle exceptions, and using continuations
    to chain multiple tasks together. We will finish the chapter by creating a **Windows
    Presentation Foundation** (**WPF**) application, using a continuation to marshal
    data created in a task back to the user interface.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个基本的、简单的延续开始本章，该延续在单个任务完成时运行。从那里，我们将探讨使用延续来控制任务集合，使用延续来处理异常，以及使用延续将多个任务链接在一起。我们将通过创建一个**Windows
    Presentation Foundation**（**WPF**）应用程序来结束本章，使用延续将任务中创建的数据回传到用户界面。
- en: Continuing a task
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续任务
- en: In its simplest form, a continuation is an action that runs asynchronously after
    a target task, called an antecedent, completes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，延续是在目标任务（称为前驱）完成后异步运行的操作。
- en: In the first recipe of this chapter, we will build a basic continuation. We
    will accomplish this by using the `Task.ContinueWith(Action<Task>)` method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个菜谱中，我们将构建一个基本的延续。我们将通过使用`Task.ContinueWith(Action<Task>)`方法来完成这个任务。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s go to Visual Studio and create a console application that runs a task
    continuation after our word count task completes. The steps to create a console
    application are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去Visual Studio创建一个控制台应用程序，在单词计数任务完成后运行任务延续。创建控制台应用程序的步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation1` as the **Solution name**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C# Console Application**项目模板启动一个新项目，并将`Continuation1`分配为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类的顶部：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s put a try/catch block and some basic exception handling. The `Main`
    method of the program class, at this point, should look as shown in the following
    code snippet:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个try/catch块和一些基本的异常处理。在这个时候，程序类的`Main`方法应该看起来如下代码片段所示：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `try` block, create a `WebClient` object and set the user-agent
    header as shown in the following code snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块内部，创建一个`WebClient`对象，并设置用户代理头，如下代码片段所示：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, in the body of the `try` block, let's create an anonymous `Task` (no name),
    followed by a `.ContinueWith()` right after the closing parenthesis of the `Task`.
    The antecedent `Task` doesn't return any results in this recipe.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`try`块的主体中，让我们创建一个匿名`Task`（没有名称），然后在`Task`关闭括号后立即跟一个`.ContinueWith()`。在这个配方中，前驱`Task`不返回任何结果。
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we need to create the body of the `Task` and the continuation. The
    `Task` will execute one of our familiar word counts. The continuation will be
    used to clean up the reference to the `WebClient` object after the antecedent
    task completes. After the continuation, prompt the user to exit.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要创建`Task`和后续任务的主体。`Task`将执行我们熟悉的单词计数。后续任务将在前驱任务完成后用于清理对`WebClient`对象的引用。在后续任务之后，提示用户退出。
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_01.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何做…](img/0225OT_02_01.jpg)
- en: How it works…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: There isn't a lot to explain about this basic continuation, but there are a
    couple of small points to note.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个基本的后续任务，没有太多要解释的，但有几个小点需要注意。
- en: 'For this recipe, we created an anonymous `Task` and made the call to `ContinueWith`
    right after the closing parenthesis of the task as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们创建了一个匿名`Task`，并在任务关闭括号后立即调用`ContinueWith`，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We could just as well have created a named task and made the call to `ContinueWith`
    in a separate statement shown as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个命名任务，并在单独的语句中调用`ContinueWith`，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Also, notice that we can wait for a continuation using the `Wait()` method;
    in the same way we could wait for a `Task` (however, you will not normally do
    this in practice. It causes the thread to block waiting for the continuation to
    complete. In general, you want to avoid causing your threads to block). In fact,
    tasks and continuations aren't much different and have many of the same instance
    methods and properties.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们可以使用`Wait()`方法等待后续任务；同样，我们也可以等待`Task`（然而，在实际操作中通常不会这样做。这会导致线程阻塞等待后续任务完成。一般来说，你想要避免使你的线程阻塞）。事实上，任务和后续任务并没有太大的区别，并且具有许多相同的实例方法和属性。
- en: Passing task results to a continuation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将任务结果传递给后续任务
- en: In this recipe, we will see how we can pass the results returned from an antecedent
    `Task` to a continuation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何将前驱`Task`返回的结果传递给一个后续任务。
- en: Our antecedent `Task` is going to read in the contents of a book as a string
    and display a word count to the user. The continuation, which will run after the
    antecedent completes, will take the string array returned by the antecedent and
    perform a LINQ query which will find the five most frequently used words.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前驱`Task`将读取书籍的内容作为字符串，并向用户显示单词计数。在前驱任务完成后运行的后续任务将获取前驱返回的字符串数组，并执行LINQ查询，以找到使用频率最高的五个单词。
- en: How to do it…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s start Visual Studio and build a Console Application that shows how to
    pass results from the antecedent to a continuation. The steps are given as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动Visual Studio，并构建一个控制台应用程序，展示如何从前驱传递结果到后续任务。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation2` as the **Solution name**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新项目，并将`Continuation2`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类的顶部：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To begin with, let''s put some basic stuff in the class. We will need a character
    array of delimiters so that we can parse out the words properly. Also, we need
    a try/catch block and some basic exception handling. The `Main` method of the
    Program class, at this point, should look as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在班级中放入一些基本的东西。我们需要一个分隔符字符数组，以便我们可以正确地解析单词。此外，我们还需要一个try/catch块和一些基本的异常处理。在这个时候，程序类的`Main`方法应该看起来如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s create a task called `task1` that returns an array of strings as
    its result. The purpose of `task1` will be to create `System.Net.WebClient` which
    will read in the text of the book as a string. Once the string is parsed and put
    into a string array, we will display the word count to the user by using the `Count`
    method of the array, and then return the array in the tasks result so that it
    can be used in our continuation. Create the task inside the `try` block. The body
    of the `try` block should now look something like the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `task1` 的任务，该任务返回一个字符串数组作为其结果。`task1` 的目的是创建 `System.Net.WebClient`，它将读取书籍的文本作为字符串。一旦字符串被解析并放入字符串数组中，我们将使用数组的
    `Count` 方法向用户显示单词计数，然后将数组作为任务的结果返回，以便在延续中使用。在 `try` 块内创建任务。`try` 块的主体现在应该类似于以下代码：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we are going to create our continuation using the `Task.ContinueWith()`
    method. Our continuation will have a `Task<string[]> state` parameter. The body
    of the continuation will perform a Linq query on the string array to sort all
    of the words contained in the array by the number of times the words occur. We
    will then execute another Linq operation to take the top five most frequently
    used words and write them to the console. Finally, we will want to wait on the
    continuation to complete with the `Wait()` method. Create the task continuation
    right after the body of the antecedent task.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `Task.ContinueWith()` 方法创建我们的延续。我们的延续将有一个 `Task<string[]> state` 参数。延续的主体将对字符串数组执行
    Linq 查询，按单词在数组中出现的次数对包含的所有单词进行排序。然后我们将执行另一个 Linq 操作，取出使用频率最高的前五个单词并将它们写入控制台。最后，我们希望使用
    `Wait()` 方法等待延续完成。在先验任务主体之后创建任务延续。
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: OK, the last step for this recipe is to let the user know that our application
    is finished and prompt them to exit. Put that code right after the continuation.
    It should be the last lines in the `try` block.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，本食谱的最后一步是让用户知道我们的应用程序已完成，并提示他们退出。将此代码放在延续之后。它应该是 `try` 块中的最后一行。
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    similar to the following screenshot:![How to do it…](img/0225OT_02_02.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_02_02.jpg)
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The continuation in this recipe was created using the `ContinueWith` method
    of an existing task instance as we did in the previous recipe. In this recipe
    however, we use a Lambda expression to pass in a `Task<string[]>` parameter representing
    the antecedent `Task`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用现有任务实例的 `ContinueWith` 方法创建了延续，就像我们在上一个食谱中所做的那样。然而，在本食谱中，我们使用 Lambda
    表达式传入一个代表先验 `Task` 的 `Task<string[]>` 参数。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the continuation accesses the result of the antecedent using the
    `Task.Result` property. If this looks familiar, it should. You access the results
    of a task in nearly the same way in a continuation as you would in any piece of
    your code, that is, by accessing the `Result` property of a `Task`. The Parallel
    Extensions team has made the coding experience very consistent across all parallel
    operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，延续使用 `Task.Result` 属性访问先验的结果。如果这看起来很熟悉，那应该如此。你几乎以相同的方式在延续中访问任务的结果，就像你会在任何代码片段中访问
    `Result` 属性一样。并行扩展团队已经使所有并行操作的编码体验非常一致。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Lastly, we wait for the continuation to complete before prompting the user to
    exit.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在提示用户退出之前等待延续完成。
- en: Continue "WhenAny" and "WhenAll"
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续使用 "WhenAny" 和 "WhenAll"
- en: In this recipe we will move from continuing single tasks to setting up continuations
    for groups of tasks. The two methods we will be looking at are `WhenAny` and `WhenAll`.
    Both methods are static members of the `Task.Factory` class, and take an array
    of tasks and `Action<Task>` as their parameters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将从延续单个任务转移到为任务组设置延续。我们将查看的两个方法是 `WhenAny` 和 `WhenAll`。这两个方法都是 `Task.Factory`
    类的静态成员，并接受一个任务数组和 `Action<Task>` 作为它们的参数。
- en: First we will look at the `WhenAny` continuations. The basic idea here is that
    we have a group of tasks and we only want to wait for the first and fastest of
    the group to complete its work before moving on. In our case, we will be downloading
    the text of three different books, and performing a word count on each. When the
    first task completes we will display the word count of the winner to the user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`WhenAny`延续。基本思想是，我们有一组任务，我们只想在组中的第一个和最快的任务完成其工作之前继续。在我们的情况下，我们将下载三本不同书籍的文本，并对每本书进行单词计数。当第一个任务完成时，我们将向用户显示获胜者的单词计数。
- en: After that we will change to `WhenAll` and display the results of all three
    word counts to the user.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将更改为`WhenAll`并向用户显示所有三个单词计数的结果。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s build a solution that shows how to conditionally continue a task. The
    steps are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个解决方案，展示如何有条件地继续一个任务。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation3` as the **Solution name**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板开始一个新的项目，并将`Continuation3`分配为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到你的程序类顶部：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, in the `Main` method of your program class, let's create a character
    array of delimiters we can use to split our words with, a string constant for
    the user agent header of our web client, and a `Dictionary<string, string>` method
    to hold our book titles and URLs. The dictionary will serve as the state object
    parameter for our tasks, which will be created in a `foreach` loop.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的程序类中的`Main`方法中，让我们创建一个字符数组，用于分割我们的单词，一个字符串常量用于我们的网络客户端的用户代理头部，以及一个`Dictionary<string,
    string>`方法来存储我们的书名和URL。这个字典将作为任务的状态对象参数，这些任务将在`foreach`循环中创建。
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, let's create a try/catch block with some basic error handling.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个带有一些基本错误处理的try/catch块。
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Inside the `try` block, let's create a new list of `Task<KeyValuePair<string,
    string>>`. Of course, this will be the list of our tasks. Each task will take
    a `KeyValuePair` from the dictionary we created in step 3 as their state parameters.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块内部，让我们创建一个新的`Task<KeyValuePair<string, string>>`列表。当然，这将是我们任务列表。每个任务将从一个我们在步骤3中创建的字典中获取一个`KeyValuePair`作为它们的状态参数。
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now let's create our task in a `foreach` loop. Each task will read the text
    of a book from a string, split the string into a character array, and do a word
    count. Our antecedent tasks return a `KeyValuePair<string, int>` with the book
    title and the word count for each book.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`foreach`循环中创建我们的任务。每个任务将从一个字符串中读取一本书的文本，将字符串分割成一个字符数组，并执行单词计数。我们的前驱任务将返回一个`KeyValuePair<string,
    int>`，包含每本书的标题和单词计数。
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now let's create the continuation by calling the `Task.Factory.WhenAny` method.
    The continuations will just display the title and word count of the winner to
    the user.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过调用`Task.Factory.WhenAny`方法来创建延续。延续将只向用户显示获胜者的标题和单词计数。
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lastly, after the catch block, prompt the user to exit and wait for the input.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`catch`块之后，提示用户退出并等待输入。
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following. Your winner may vary.![How to do it…](img/0225OT_02_03.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似以下输出的结果。你的获胜者可能会有所不同。![如何做到这一点…](img/0225OT_02_03.jpg)
- en: Before moving on, let's change our code a bit and continue when all of our tasks
    complete. All we need to do is change our method call from `Task.Factory.WhenAny`
    to `Task.Factory.WhenAll`, change the name of the continuation parameter from
    `antecedent` to `antecedents` to reflect plurality, and create a `foreach` loop
    in the body of the continuation to loop through the results.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们稍微修改一下我们的代码，并在所有任务完成时继续。我们只需要将我们的方法调用从`Task.Factory.WhenAny`更改为`Task.Factory.WhenAll`，将延续参数的名称从`antecedent`更改为`antecedents`以反映复数，并在延续的主体中创建一个`foreach`循环来遍历结果。
- en: '[PRE21]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_04.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似以下屏幕截图的输出：![如何做到这一点…](img/0225OT_02_04.jpg)
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The continuations in this recipe are created a bit differently from the continuations
    that we have created in previous tasks. Instead of calling the instance method
    `ContinueWith` on a `Task` variable, we are calling the `ContinueWhenAny` and
    `ContinueWhenAll` static methods on `Task.FactoryClass`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中创建的延续与我们在先前任务中创建的延续略有不同。我们不是在`Task`变量上调用实例方法`ContinueWith`，而是在`Task.FactoryClass`上调用`ContinueWhenAny`和`ContinueWhenAll`静态方法。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ContinueWhenAny` and `ContinueWhenAll` methods have a different parameter
    lists than `Task.ContinueWith`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWhenAny`和`ContinueWhenAll`方法与`Task.ContinueWith`的参数列表不同。'
- en: '`ContinueWhenAny` takes an array of `Task` as its first parameter and a single
    `Action<Task>` delegate as its second parameter.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWhenAny`将其第一个参数作为`Task`数组，第二个参数作为单个`Action<Task>`委托。'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ContinueWhenAll` takes the same array of `Task` as its first parameter and
    `Action<Task[]>` as its second parameter.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWhenAll`将其第一个参数作为与`Task`相同的数组，第二个参数作为`Action<Task[]>`。'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Specifying when a continuation will run
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定延续何时运行
- en: One of the most powerful features of task continuations is the ability to create
    multiple continuations for a task, and specify the exact conditions under which
    each continuation will be invoked by using the `Task.TaskContinuationOptions`
    enumeration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任务延续功能最强大的特性之一是能够为任务创建多个延续，并使用`Task.TaskContinuationOptions`枚举指定每个延续将在何种确切条件下被调用。
- en: When you create a continuation for a task, you can use `Task.ContinueWith` overload
    that takes the `TaskContinuationOptions` enumeration to specify that the continuation
    will only run if the antecedent `Task` completed, was cancelled, or is faulted.
    The enumeration also has members that specify when a continuation should not run.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为任务创建延续时，你可以使用`Task.ContinueWith`重载，它接受`TaskContinuationOptions`枚举来指定延续只有在先导`Task`完成、取消或出现故障时才会运行。枚举还有指定延续不应运行时的成员。
- en: In this recipe, we will be looking at two simple tasks, each with two continuations.
    One of the continuations for each task will run when the task completes, and one
    will run when the task is cancelled.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看两个简单的任务，每个任务都有两个延续。每个任务的其中一个延续将在任务完成时运行，另一个将在任务取消时运行。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, let''s create a console application that continues tasks conditionally.
    The steps to create a console application are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个条件性地继续任务的控制台应用程序。创建控制台应用程序的步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation4` as the **Solution name**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新项目，并将`Continuation4`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类顶部：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the top of the `Main` method, create two `CancellationTokenSource` objects
    and get a `CancellationToken` from each one of them.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法顶部，创建两个`CancellationTokenSource`对象，并从每个对象中获取一个`CancellationToken`。
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, let's create a try/catch block with some basic error handling.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个带有基本错误处理的try/catch块。
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Inside the `try` block, let's create two simple tasks. Both tasks just write
    a message to the console. Also create two continuations for each task using `TaskContinuationOptions.OnlyOnRanToCompletion`
    and `Task ContinuationOption.OnlyOnFaulted`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块内部，让我们创建两个简单的任务。这两个任务只是向控制台写入一条消息。同时，为每个任务创建两个延续，使用`TaskContinuationOptions.OnlyOnRanToCompletion`和`Task
    ContinuationOption.OnlyOnFaulted`。
- en: '[PRE28]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Lastly, after the `catch` block, let's cancel the token and wait for user input
    before exiting.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`catch`块之后，让我们取消令牌，并在退出之前等待用户输入。
- en: '[PRE29]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_05.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_02_05.jpg)
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this very simple example, we started by creating two `CancellationTokenSource`
    objects and getting a cancellation token source from each. If we had created a
    `CancellationTokenSource` object and passed the token into both tasks, both tasks
    would have been cancelled when we cancelled the token. In our case, we just wanted
    to cancel one of the two tasks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的例子中，我们首先创建了两个`CancellationTokenSource`对象，并从每个对象中获取一个取消令牌源。如果我们创建了一个`CancellationTokenSource`对象并将令牌传递给两个任务，那么当我们取消令牌时，两个任务都会被取消。在我们的情况下，我们只想取消两个任务中的其中一个。
- en: 'The tasks themselves are very simple. They just wait for a bit to give us some
    time to cancel the token and display a message to the console. We pass one `CancellationToken`
    into each task as shown in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任务本身非常简单。它们只是等待一段时间，给我们一些时间取消令牌并在控制台显示一条消息。我们像以下代码片段所示，将一个 `CancellationToken`
    传递给每个任务：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both of the continuations just display a message to the console, and both are
    created with a member of the `Task.TaskContinuationOptions` enumerator. The first
    continuation is fired when the task runs to completion and the second continuation
    fires when the task is cancelled.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个后续操作只是向控制台显示一条消息，并且都是使用 `Task.TaskContinuationOptions` 枚举的一个成员创建的。第一个后续操作在任务运行完成时触发，第二个后续操作在任务被取消时触发。
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We cancel the token for `task2`, but not for `task1` and the corresponding continuation
    for each executes, and we can see the message written on to the console.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取消了 `task2` 的令牌，但没有取消 `task1` 的令牌，并且每个对应的后续操作都会执行，我们可以在控制台上看到写入的消息。
- en: There's more…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `TaskContinuationOptions` enumeration has several members which control
    under which condition a continuation is triggered. The following table contains
    a list of these members. Note that this is not a complete list of continuation
    options. The complete list of continuation options can be found at [http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx).
    The `OnlyOnFaulted` member will have its own recipe later in the chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskContinuationOptions` 枚举有几个成员，用于控制在什么条件下触发后续操作。以下表格包含这些成员的列表。请注意，这并不是后续选项的完整列表。完整的后续选项列表可以在
    [http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx)
    找到。`OnlyOnFaulted` 成员将在本章后面的配方中单独介绍。'
- en: '| `NotOnRanToCompletion` | The continuation should not be scheduled if the
    task ran to completion. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `NotOnRanToCompletion` | 如果任务运行完成，则不应安排后续操作。 |'
- en: '| `NotOnFaulted` | The continuation should not be scheduled if the task faulted.
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `NotOnFaulted` | 如果任务出现故障，则不应安排后续操作。 |'
- en: '| `NotOnCancelled` | The continuation should not be triggered if the task was
    cancelled. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `NotOnCancelled` | 如果任务被取消，则不应触发后续操作。 |'
- en: '| `OnlyOnRanToCompletion` | The continuation should be scheduled if the task
    ran to completion. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `OnlyOnRanToCompletion` | 如果任务运行完成，则应安排后续操作。 |'
- en: '| `OnlyOnFaulted` | The continuation should be scheduled if the task faulted.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `OnlyOnFaulted` | 如果任务出现故障，则应安排后续操作。 |'
- en: '| `OnlyOnCancelled` | The continuation should be triggered if the task was
    cancelled. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `OnlyOnCancelled` | 如果任务被取消，则应触发后续操作。 |'
- en: The `TaskContinuationOptions` enumeration can be treated as a bit field and
    a bitwise combination can be performed on its members.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskContinuationOptions` 枚举可以被视为一个位字段，并且可以在其成员上执行位运算。'
- en: Using a continuation for exception handling
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后续操作进行异常处理
- en: In the *Handling task exceptions using try/catch* recipe, in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Task Parallel Library"), *Getting Started With
    Task Parallel Library* we looked at how to handle exceptions in task. In addition
    to the techniques used in that recipe, you can also use continuations to handle
    task exceptions. By using a continuation, we can handle errors in a cleaner, less
    inline way. An exception handling continuation allows for centralizing exception
    handling logic in cases where you would want to provide logging or other exception
    related code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 try/catch 处理任务异常* 的配方中，在 [第1章](ch01.html "第1章。使用任务并行库入门")，*使用任务并行库入门*
    我们探讨了如何处理任务中的异常。除了该配方中使用的技巧外，您还可以使用后续操作来处理任务异常。通过使用后续操作，我们可以以更干净、更不内联的方式处理错误。异常处理后续操作允许在需要提供日志或其他异常相关代码的情况下集中处理异常处理逻辑。
- en: The basic concept is to use the `Task.TaskContinuationOptions` enumeration so
    we can create a continuation that will be scheduled if the task ran to completion,
    and another continuation that will be scheduled if the task is put into a faulted
    state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基本概念是使用 `Task.TaskContinuationOptions` 枚举，这样我们就可以创建一个在任务运行完成时安排的后续操作，以及一个在任务被置于错误状态时安排的后续操作。
- en: Getting Ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe we need to turn off the **Visual Studio 2012 Exception Assistant**.
    The Exception Assistant appears whenever a run-time exception is thrown and intercepts
    the exception before it gets to our handler.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要关闭**Visual Studio 2012异常助手**。异常助手会在抛出运行时异常时出现，并在它到达我们的处理器之前拦截异常。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到**调试**菜单并选择**异常**。
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    Ready](img/0225OT_02_06.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**公共语言运行时异常**旁边的**用户未处理**复选框。![准备就绪](img/0225OT_02_06.jpg)
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Now, let''s go to Visual Studio and see how to use a continuation for exception
    handling. The steps are given as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去Visual Studio看看如何使用延续进行异常处理。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation5` as the **Solution name**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新项目，并将`Continuation5`作为**解决方案名称**。
- en: 'Add the following `using` directives at the top of your program class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序类顶部添加以下`using`指令：
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `Main` method of your program class, create a `Task`. The task doesn't
    need to accept a state parameter or return anything. In the body of the `Task`,
    create the try/finally blocks. In order to have a resource to dispose of, create
    a new WebClient in the `try` block, and then throw an exception. In the `finally`
    block, call the dispose method of the WebClient. Other than that, the exact details
    don't matter much.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序类的`Main`方法中创建一个`Task`。任务不需要接受状态参数或返回任何内容。在`Task`的主体中创建try/finally块。为了有一个可释放的资源，在`try`块中创建一个新的WebClient，然后抛出异常。在`finally`块中调用WebClient的dispose方法。除此之外，具体的细节并不重要。
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Immediately following the `Task`, use `TaskContinuationOptions.OnlyOnRanToCompletion`
    to create a trivial continuation to run when the task completes successfully.
    This continuation only needs to write a message to the console.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着`Task`之后，使用`TaskContinuationOptions.OnlyOnRanToCompletion`创建一个简单的延续，以便在任务成功完成时运行。这个延续只需要将一条消息写入控制台。
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next use `TaskContinuationOptions.OnlyOnFaulted` to create a continuation that
    only runs when `task1` throws a fault. After the continuation, add `Console.Readline`
    to wait for user input before exiting.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来使用`TaskContinuationOptions.OnlyOnFaulted`创建一个延续，只有当`task1`抛出故障时才会运行。在延续之后，添加`Console.Readline`以等待用户输入后再退出。
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the one shown in the following screenshot:![How to do it…](img/0225OT_02_07.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何实现…](img/0225OT_02_07.jpg)
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating a continuation that will run when a `Task` is in a faulted state, works
    the same as setting any of the other enumerations in `TaskContinuationOptions`
    on a continuation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在`Task`处于故障状态时运行的延续，与在延续上设置`TaskContinuationOptions`中的任何其他枚举的工作方式相同。
- en: 'In order to properly clean up resources used by the `Task`, we created `try/finally`
    blocks in our task and disposed of the WebClient in the `finally` block:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确清理`Task`使用的资源，我们在任务中创建了`try/finally`块，并在`finally`块中释放了WebClient。
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our exception handling continuation checks to see if the `AggregateException`
    is null before looping through the `InnerExceptions` collection, and writing the
    result to the console. The null check isn''t strictly necessary because the antecedent
    task needs to be in a faulted state before the continuation is scheduled, but
    it is a good defensive coding practice none the less:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对异常处理的延续进行检查，在遍历`InnerExceptions`集合并将结果写入控制台之前，查看`AggregateException`是否为null。null检查并不是严格必要的，因为延续被安排之前，前置任务需要处于故障状态，但无论如何，这是一种良好的防御性编程实践：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Cancelling a continuation
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消延续
- en: Cancelling a continuation follows the same basic rules as cancelling a `Task`.
    If a `Task` and its continuation are two parts of the same operation, you can
    pass the same cancellation token to both the `Task` and the continuation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 取消延续遵循与取消`Task`相同的基本规则。如果`Task`及其延续是同一操作的两个部分，则可以将相同的取消令牌传递给`Task`和延续。
- en: In this recipe we will have a simple `Task` that creates a list of numbers and
    a continuation that squares the numbers and return a result. After a few seconds
    of running, we will use the token to cancel both the `Task` and the continuation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将有一个简单的`Task`，它创建一个数字列表，并有一个后续操作对数字进行平方并返回结果。运行几秒钟后，我们将使用令牌来取消`Task`和后续操作。
- en: Getting Ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Since cancelling a `Task` or continuation raises and `OperationCanceledException`
    we need to turn off the Visual Studio 2012 Exception Assistant. The Exception
    Assistant appears whenever a runtime exception is thrown, and intercepts the exception
    before it gets to our handler.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于取消`Task`或后续操作会引发`OperationCanceledException`，我们需要关闭Visual Studio 2012异常助手。异常助手会在运行时异常抛出时出现，并在它到达我们的处理器之前拦截异常。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到**调试**菜单并选择**异常**。
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    Ready](img/0225OT_02_06.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选**用户未处理的**复选框旁边的**公共语言运行时异常**。![准备就绪](img/0225OT_02_06.jpg)
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now, let''s build a console application so that we can see how to cancel a
    continuation. The steps are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个控制台应用程序，以便我们可以看到如何取消后续操作。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation6` as the **Solution name**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`Continuation6`作为**解决方案名称**。
- en: Add the following `using` directives to the top of your program class.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类的顶部。
- en: '[PRE38]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `Main` method of your program class, let's start by creating our `CancellationTokenSource`
    and getting a token. We will pass this token to both the antecedent `Task` and
    the continuation.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序类的`Main`方法中，我们首先创建我们的`CancellationTokenSource`并获取一个令牌。我们将这个令牌传递给前驱`Task`和后续操作。
- en: '[PRE39]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next let's add try/catch/finally blocks to the `Main` method, just under the
    previous lines. Add some basic error handling to the `catch` block and dispose
    of the `CancellationTokenSource` in the `finally` block.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Main`方法中添加try/catch/finally块，就在之前的行下面。在`catch`块中添加一些基本的错误处理，并在`finally`块中处理`CancellationTokenSource`。
- en: '[PRE40]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Inside the `try` block, create a task that accepts an object state parameter.
    The parameter will determine the size of our number list. We will cast it to `Int32`
    and create a `for` loop to add numbers to our list. Also, pass the token created
    in step 1 to the task constructor.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块内部，创建一个接受对象状态参数的任务。该参数将确定我们的数字列表的大小。我们将它转换为`Int32`并创建一个`for`循环来向我们的列表中添加数字。同时，将步骤1中创建的令牌传递给任务构造函数。
- en: '[PRE41]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After the `Task`, let's create our continuation. The continuation will receive
    the results from the antecedent `Task`, loop through the list, and square the
    numbers. Pass the same `CancellationToken` into the continuations constructor.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Task`之后，让我们创建我们的后续操作。后续操作将接收前驱`Task`的结果，遍历列表，并对数字进行平方。将相同的`CancellationToken`传递给后续操作的构造函数。
- en: '[PRE42]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the end of the `try` block, we need to sleep the thread a bit to give the
    `Task` and continuation some time to run, and then we will cancel the token. Finally
    we will call the `Wait` method on `task1`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块的末尾，我们需要让线程休眠一段时间，以便`Task`和后续操作有足够的时间运行，然后我们将取消令牌。最后，我们将调用`task1`的`Wait`方法。
- en: '[PRE43]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Last, after the end of the `finally` block, write a message to the console that
    we are finished and wait for the user input.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`finally`块结束后，向控制台发送一条消息，表示我们已经完成，并等待用户输入。
- en: '[PRE44]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_08.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何做到这一点…](img/0225OT_02_08.jpg)
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When an antecedent task throws an `OperationCancelledException` in response
    to a cancellation request, as long as the continuation uses the same `CancellationToken`,
    the cancellation request will be treated as an acknowledgement of co-operative
    cancellation and both the antecedent task and the continuation will go into a
    cancelled state.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当前驱任务在响应取消请求时抛出`OperationCancelledException`，只要后续操作使用相同的`CancellationToken`，取消请求将被视为合作取消的确认，前驱任务和后续操作都将进入已取消状态。
- en: This is pretty easy to accomplish. We just need to get a `CancellationToken`
    from a `CancellationTokenSource`, and pass the token to the constructors for both
    the antecedent `Task` and the continuation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。我们只需要从一个 `CancellationTokenSource` 获取一个 `CancellationToken`，并将令牌传递给前驱
    `Task` 和连续操作的构造函数。
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Inside the body of the loops in our `Task` and the continuation, we need to
    poll for cancellation and throw an `OperationCancelledException` if the token
    gets cancelled. This can be done in one line of code with the `ThrowIfCancellationRequested`
    method of the `CancellationToken` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Task` 和连续操作体内的循环中，我们需要轮询取消操作，并在令牌被取消时抛出 `OperationCancelledException`。这可以通过
    `CancellationToken` 对象的 `ThrowIfCancellationRequested` 方法在一行代码中完成。
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Lastly, we just need to make sure we are handling `AggregateExceptions` in our
    `catch` block.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需确保我们在 `catch` 块中处理 `AggregateExceptions`。
- en: Using a continuation to chain multiple tasks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用连续操作链式连接多个任务
- en: Another feature of continuations is that you can continue continuations in order
    to chain tasks together to any length. The pipeline pattern can be implemented
    with a series of tasks and continuations. You can think of a pipeline as an assembly
    line in a factory. At the frontend of a pipeline, a producer task generates the
    data to be operated on, and each of the chained consumer stages operates on or
    changes the produced data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 连续的一个特点是你可以连续使用连续操作，以便将任务链在一起，长度不受限制。可以通过一系列任务和连续操作来实现管道模式。你可以将管道想象成工厂中的流水线。在管道的前端，一个生产任务生成要操作的数据，而每个链式消费者阶段都会对生成的数据进行操作或更改。
- en: In this recipe we will return to our word count example to create a simple three
    stage pipeline using continuations with `TaskContinuationOptions.OnlyOnRanToCompletion`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将回到我们的单词计数示例，使用 `TaskContinuationOptions.OnlyOnRanToCompletion` 创建一个简单的三阶段管道。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open up Visual Studio, and let''s see how to chain tasks together into a pipeline.
    The steps are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio，让我们看看如何将任务链在一起形成一个管道。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation7` as the **Solution name**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板创建一个新的项目，并将 `Continuation7` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类的顶部：
- en: '[PRE47]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let's start this application by adding try/catch blocks in the `Main` method
    of the program class. In the `catch` block add some handling for any `AggregateException`
    raised by the tasks. At the end of the `catch` block, write a message to the console
    to tell the user we are finished and wait for input to exit.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在程序类的 `Main` 方法中添加 try/catch 块开始这个应用程序。在 `catch` 块中添加对任务引发的任何 `AggregateException`
    的处理。在 `catch` 块的末尾，向控制台写入一条消息，告诉用户我们已经完成，并等待输入以退出。
- en: '[PRE48]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now we need to create a `producer` task that reads in the text of a book, and
    returns a string array, which the consumer continuations will consume.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 `producer` 任务，该任务读取书籍的文本，并返回一个字符串数组，消费者连续操作将消费这个数组。
- en: '[PRE49]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first consumer will perform a Linq query on the results of the producer
    to find the five most commonly used words.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个消费者将对生产者的结果执行 Linq 查询，以找出最常见的五个单词。
- en: '[PRE50]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_09.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 键运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_02_09.jpg)
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The task and continuations we used in this example are pretty much the same
    as the tasks we have created in other recipes. The primary difference is how we
    chained them together and the length of the chain. Our antecedent task produces
    and returns a string array, and then we have a continuation that finds the five
    most commonly used words, finally we continue the continuation to find the longest
    word.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的任务和连续操作与我们在其他菜谱中创建的任务几乎相同。主要区别在于我们如何将它们链在一起以及链的长度。我们的前驱任务生成并返回一个字符串数组，然后我们有一个连续操作来找出最常见的五个单词，最后我们继续连续操作来找出最长的单词。
- en: Note that we also use `TaskContinuationOptions.OnlyOnRanToCompletion` because
    we only want the consumers to be scheduled to run when the previous task succeeded.
    To be a more complete solution, we would want to use `TaskContinuationOptions.OnlyOnFaulted`
    to set up a continuation for the failure path as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还使用了 `TaskContinuationOptions.OnlyOnRanToCompletion`，因为我们只想在先前的任务成功时调度消费者运行。为了成为一个更完整的解决方案，我们还想使用
    `TaskContinuationOptions.OnlyOnFaulted` 来设置失败路径的后续操作。
- en: Using a continuation to update a UI
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后续操作更新 UI
- en: A common challenge when developing multithreaded WPF applications is that the
    UI controls have thread affinity, meaning they can only be updated by the thread
    that created them. This is usually the main thread of the application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发多线程 WPF 应用程序时，一个常见的挑战是 UI 控件具有线程亲和性，这意味着它们只能由创建它们的线程进行更新。这通常是应用程序的主线程。
- en: The TPL, however, offers a clean way to marshal the results from a TPL task
    to the correct thread for updating the UI. It accomplishes this with the `TaskScheduler.FromCurrentSynchronizationContext`
    method which creates a `TaskScheduler` associated with the current `SyncronizationContext`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TPL 提供了一种干净的方式来将 TPL 任务的结果传输到正确的线程以更新 UI。它通过 `TaskScheduler.FromCurrentSynchronizationContext`
    方法实现，该方法创建一个与当前 `SyncronizationContext` 关联的 `TaskScheduler`。
- en: In this recipe we are going to create a WPF application which will start a task
    to get the word count of a book. The task will have a continuation that is created
    in the correct synchronization context by calling `TaskScheduler.FromCurrentSynchronizationContext`.
    The continuation will perform the UI update.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个 WPF 应用程序，该程序将启动一个任务来获取书籍的单词计数。该任务将有一个后续操作，通过调用 `TaskScheduler.FromCurrentSynchronizationContext`
    在正确的同步上下文中创建。后续操作将执行 UI 更新。
- en: How to do it…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's create a WPF application and see how we can use the TPL marshal data to
    the UI thread.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 WPF 应用程序，看看我们如何使用 TPL 将数据传输到 UI 线程。
- en: Start a new project using the **WPF Application** project template and assign
    `Continuation8` as the **Solution name**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **WPF Application** 项目模板启动一个新项目，并将 `Continuation8` 作为 **Solution name** 分配。
- en: 'Open the `MainWindow.xaml.cs` file and ensure the following `using` directives
    to the top of your `MainWindow` class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml.cs` 文件，并确保将以下 `using` 指令添加到 `MainWindow` 类的顶部：
- en: '[PRE51]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Go back to `MainWindow.xaml` and replace the XAML with the following code to
    create the UI layout:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `MainWindow.xaml` 并将 XAML 替换为以下代码以创建 UI 布局：
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![How to do it…](img/0225OT_02_10.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/0225OT_02_10.jpg)'
- en: Now add a `Label` from the toolbox to your window. Change the **Name** property
    to `lblWordCount` and remove the default value from the **Content** property.![How
    to do it…](img/0225OT_02_12.jpg)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从工具箱中添加一个 `Label` 到您的窗口中。将 **Name** 属性更改为 `lblWordCount` 并从 **Content** 属性中删除默认值。![如何操作…](img/0225OT_02_12.jpg)
- en: OK, now double click on the **Get Word Count** button on your form to open up
    `Mai``nWindow.xaml.cs` in the `Button_Click_1` event handler. This is where we
    will create our task and continuation.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在双击表单上的 **Get Word Count** 按钮，在 `Button_Click_1` 事件处理程序中打开 `Mai``nWindow.xaml.cs`。这就是我们将创建任务和后续操作的地方。
- en: 'In the `Button_Click_1` event handler, create a `Task` that reads the content
    of a book into a string array. The `Task` will return a string array result which
    will be used in a continuation to display the word count to the UI. The `Task`
    will be continued with a continuation created with `TaskScheduler.FromCurrentSynchronizationContext`
    called in the constructor:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Button_Click_1` 事件处理程序中，创建一个 `Task`，将书籍的内容读取到字符串数组中。`Task` 将返回一个字符串数组结果，该结果将在后续操作中用于在
    UI 中显示单词计数。`Task` 将通过在构造函数中调用 `TaskScheduler.FromCurrentSynchronizationContext`
    来继续使用后续操作：
- en: '[PRE53]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application windows
    should look something as shown in the following screenshot:![How to do it…](img/0225OT_02_13.jpg)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。您的应用程序窗口应类似于以下截图所示：![如何操作…](img/0225OT_02_13.jpg)
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Tasks run on instances of the `TaskScheduler` class. Two implementations of
    `TaskScheduler` are included as part of the .NET Framework 4.5\. One is the default
    scheduler, which is integrated with the .NET ThreadPool. The other is the type
    of `TaskScheduler` returned from the static method `TaskScheduler.FromCurrentSynchronizationContext`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 任务在 `TaskScheduler` 类的实例上运行。.NET Framework 4.5 包含 `TaskScheduler` 的两个实现。一个是默认调度程序，它与
    .NET ThreadPool 集成。另一个是从静态方法 `TaskScheduler.FromCurrentSynchronizationContext`
    返回的 `TaskScheduler` 类型。
- en: '`SynchronizationContext` provides two methods, `Send` and `Post`, both of which
    accept a delegate to be executed. `Send` synchronously invokes the delegate, and
    `Post` asynchronously invokes the delegate.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`SynchronizationContext` 提供了两个方法，`Send` 和 `Post`，两者都接受一个要执行的委托。`Send` 方法会同步调用委托，而
    `Post` 方法则会异步调用委托。'
- en: UI controls should only be accessed by the thread that created them, usually
    the main UI thread. So, if a thread working in the background wants to update
    something in the UI, it needs to marshal that data back to the UI thread so that
    the controls can be accessed safely. In WPF, you would do this with the target
    thread's `Dispatcher` and corresponding `Invoke/BeginInvoke` methods. With the
    .NET 4.5 TPL, a new type may be derived from `SynchronizationContext` such that
    its `Send` method synchronously marshals a delegate to the right thread for execution,
    and `Post` does the same but asynchronously.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: UI 控件应由创建它们的线程访问，通常是主 UI 线程。因此，如果后台工作的线程想要更新 UI 中的某些内容，它需要将那些数据回传到 UI 线程，以便控件可以安全访问。在
    WPF 中，您会使用目标线程的 `Dispatcher` 和相应的 `Invoke/BeginInvoke` 方法来完成此操作。使用 .NET 4.5 TPL，可以从
    `SynchronizationContext` 派生出一个新类型，这样其 `Send` 方法会同步地将委托发送到正确的线程执行，而 `Post` 方法则异步地执行相同操作。
- en: UI frameworks like WPF publish an instance of their `SynchronizationContext`
    derived class to `SynchronizationContext.Current`. Your code can then get `SynchronizationContext.Current`
    and use it to marshal work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: UI 框架如 WPF 会将它们 `SynchronizationContext` 派生类的实例发布到 `SynchronizationContext.Current`。然后，您的代码可以获取
    `SynchronizationContext.Current` 并使用它来执行工作。
- en: '`TaskScheduler.FromCurrentSynchronizationContext` creates a `TaskScheduler`
    that wraps the `SynchronizationContext` returned from `SynchronizationContext.Current`.
    In doing so, this gives you a `TaskScheduler` that will execute `Tasks` on the
    current `SynchronizationContext`. This means you can create tasks that are able
    to access UI controls safely by running them on the right scheduler.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskScheduler.FromCurrentSynchronizationContext` 创建一个 `TaskScheduler`，它包装了从
    `SynchronizationContext.Current` 返回的 `SynchronizationContext`。这样做会为您提供可以在当前 `SynchronizationContext`
    上执行 `Tasks` 的 `TaskScheduler`。这意味着您可以通过在正确的调度器上运行来创建能够安全访问 UI 控件的 `Tasks`。'
- en: Since we can create a `Task` or continuation with a derived `TaskScheduler`,
    we can create the continuation with a scheduler that will execute the continuation
    on the proper context to update the UI.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以使用派生的 `TaskScheduler` 创建 `Task` 或延续，因此我们可以使用一个将延续在适当上下文中执行的调度器来创建延续。
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
