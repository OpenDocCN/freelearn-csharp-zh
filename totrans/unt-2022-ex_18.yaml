- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing AI with Sensors, Behavior Trees, and ML-Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B18347_12.xhtml#_idTextAnchor232), we dove into all the required
    details for approaching adding audio to our games. We did this by introducing
    an audio manager and individual reusable audio player components so that designers
    and developers can easily add different types of game audio to create a sound
    experience that encompasses our players. We enforced good coding practices to
    ensure we’re writing maintainable code, with an emphasis on reusability and extensibility,
    to simplify the challenges in our daily game developer lives.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have addressed the sound design of our game, we can continue to
    finish out the enemy **non-player character** (**NPC**) mechanics for our FPS
    game’s level by implementing some basic **artificial intelligence** (**AI**).
    We’ll accomplish adding simple AI navigation by reusing and refactoring our previous
    2D components and code to 3D. We’ll continue to discuss the elevation and sophistication
    of NPC systems with **behavior trees** and **machine learning** (**ML**) tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover the following main topics.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the 2D enemy systems to 3D with NavMesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic enemies with sensors and behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing ML with ML-Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create a remarkable gameplay experience
    for your players by implementing AI-based interactions with NPCs, seamlessly navigating
    the level environment, and executing a set of behaviors on their own. You will
    better understand the differences between 2D and 3D implementation because we’ll
    revisit the 2D methods and refactor for 3D while making improvements in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the 2D enemy systems to 3D with NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the goal is to guide you through the comprehensive process
    of bringing this hovering adversary to life, turned against us by the evil plant
    entity invading our systems. Its mission is to patrol the corridors of the habitat
    station to prevent the player from eradicating the infestation and getting back
    to Kryk’zylx normalcy (whatever that is).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Enemy hover bot on patrol](img/B18347_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Enemy hover bot on patrol
  prefs: []
  type: TYPE_NORMAL
- en: Way back in [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151), for our 2D game,
    we solved the problem of enemy NPC navigation by using a simple patrol waypoint
    behavior where the enemy robot moves between two waypoints in 2D space – a left
    and a right.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we’re going to do something similar here. However, because we’re now working
    in 3D space and have a more complex floor plan to navigate, we’ll still set up
    a patrol path using waypoints. Still, we’ll now use Unity’s **AI Navigation**
    package and its **NavMesh** components to accomplish the task of navigating between
    them. NPC navigation is crucial for creating immersive game environments, and
    Unity’s updated 3D NavMesh system, introduced in a Unity 2022.3 release, offers
    an efficient solution.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about the AI Navigation package can be found here: [https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/)'
  prefs: []
  type: TYPE_NORMAL
- en: Revising and refactoring previously programmed components to save on development
    time is something we’ve discussed a few times already since the inception of the
    3D FPS project, and there will be no exception now. There is no sense starting
    from scratch every time; let’s rely on the assets we already have in our bag of
    tricks and revise where required (ultimately, adding to our bag).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need a bit of a refresher for the basic component structure to understand
    where 3D-related revisions, specifically for NavMesh refactoring, will be required.
    So, here we go. Let’s review the following **Unified Modeling Language** (**UML**)
    diagram representing the behavior responsible for moving the NPC in the 2D project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – 2D patrol waypoints reference UML](img/B18347_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – 2D patrol waypoints reference UML
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough, we’re going to reuse about 96% of what we see in the preceding
    diagram (no, I didn’t do the math; don’t hold me to that percentage). It’s primarily
    the `PatrolWaypoints` class that is in need of revising because it’s the implementation
    of the `IBehaviorPatrolWaypoints` interface that actually moves the enemy NPCs
    between the waypoints. We simply need a behavior implementation for the NavMesh
    instead – because we did the work upfront, following good programming practices,
    to extend functionality without modifying the implementing class.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, let’s gather the 2D scripts for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Importing scripts from the 2D project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We currently require the scripts from the previous 2D adventure game project.
    We’ll need several files this time, unlike the previous time we reused and refactored
    the 2D components for 3D in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187),
    in the *Refactoring environment interactions to 3D API methods* section, where
    we only needed a few files. So, for the scripts necessary for the 3D FPS project,
    let’s use the Unity package exporter to obtain the scripts along with their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Download scripts
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, download **patrol-behavior-and-dependencies.zip**, with the
    already exported scripts and dependencies required, from the book’s GitHub repo
    here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets).'
  prefs: []
  type: TYPE_NORMAL
- en: For a review of the process, you can revisit [*Chapter 9*](B18347_09.xhtml#_idTextAnchor169),
    where we exported the sliding puzzle game assets. This process certainly isn’t
    one of the most fun parts of developing games, but you’ll find yourself doing
    these types of things from time to time. Let’s get to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the previous 2D adventure game project in Unity now and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `Assets/Scripts/Behaviors` folder in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `PatrolWaypoints.cs` file and select **Export Package…**,
    as seen in *Figure* *13**.3* (*A*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 2D patrolling waypoints behavior is what we want to leverage our reuse of
    for our enemy bot NPC in the 3D FPS game, so we’ll use it as the basis for our
    export and grab its dependencies and other related scripts in the process. Don’t
    worry – in the next step, I’ve already sorted out what scripts we’ll want here
    to save you the time and stress of figuring it out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure you’ve selected the following files in the `Assets/Scripts/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Bullet.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enemy.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnemyController.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerShootingPooled.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProjectileBase.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProjectileDamage.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponRanged.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Scripts/Behaviors/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PatrolWaypoints.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Scripts/Data/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EnemyConfigData.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Scripts/ExtensionMethods/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LayerMaskExtensions.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Scripts/Interfaces/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IBehaviorAttack.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IBehaviorPatrolWaypoints.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IWeapon.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IWeaponLaser.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Scripts/Systems/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EventSystem Example/`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExampleListener.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExampleTrigger.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventSystem.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see from the list of dependencies selected that we’ll be using some
    of these later to fast-track the implementation of projectile shooting and events.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the files selected, click the **Export…** button and save the
    exported package file (with any name you choose) to a location where we can easily
    find it to import into our current 3D FPS project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the 3D FPS project, if not already, so we can import the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in *Figure 13**.3* (*B*), we’ll be presented with the **Import Unity
    Package** dialog when we drag and drop the exported package from your system’s
    file manager to the 3D FPS game’s **Project** window.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3 – 2D project export and 3D project import](img/B18347_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – 2D project export and 3D project import
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll likely notice after the import finishes that we immediately have a console
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll first – quickly and easily – fix this compiler error while the remainder
    of the changes will be focused on the refactoring of the 2D to 3D functionality.
    So, to fix the error, we simply need to change `Collider2D` to `Collider` in the
    `ProjectileDamage` class’s `DoDamage()` method signature to properly implement
    the `IDamage` interface as defined in this 3D project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Assets/Scripts/ProjectileDamage.cs` in your IDE and change both the `UnityEvent`
    declaration and the `DoDamage()` method signature to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Simple.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on with the remaining refactoring will require an additional step to
    ensure we can reference the required 3D navigation types. This simply means we
    must first add the **AI Navigation** package to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Open `nav` in the search box to filter the available packages and select **AI
    Navigation** from the list view. Finish by clicking the **Install** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Installing the AI Navigation package](img/B18347_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Installing the AI Navigation package
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now we’re ready to move on updating our code reuse to use the NavMesh
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the PatrolWaypoints class for NavMesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity’s NavMesh system greatly simplifies setting up complex 3D waypoint navigation
    where NPCs can move more naturally and interact in believable ways, which contributes
    to enhancing the game’s immersion for our players. The modular, adaptable code
    design (i.e., SOLID principles and composition) we adhere to also makes switching
    between 2D and 3D and adding or swapping components easy. That’s why we’ll be
    able to quickly make only a few updates to our existing 2D components to have
    the 3D FPS game up and running with patrolling enemy bot NPCs!
  prefs: []
  type: TYPE_NORMAL
- en: Primarily, as indicated earlier in the UML diagram, the most significant revision
    will be with the patrol waypoints behavior class. We’ll actually end up replacing
    most of it, so open the newly imported `Assets/Scripts/Behaviors/PatrolWaypoints`
    script in your IDE now so we can get started. And the first thing we’ll start
    with – beginning at the top of the script and working our way down – is the waypoint
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the waypoint variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re simply going to replace the old transform `WaypointPatrolLeft` and `WaypointPatrolRight`
    variable declarations with the following single list of waypoint transforms declaration
    – serialized with the `[SerializeField]` attribute so they’re assignable in the
    Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Okay, off to a good start; we’ll now be able to add any number of waypoints
    to the `_waypoints` list for the enemy bot NPC to navigate. We’ll tackle the remaining
    variables next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll replace the movement-related private member variables with only the following
    two – `_waypointCurrentIndex` and `_navMeshAgent` – to hold the reference to `NavMeshAgent`
    and to keep track of the current waypoint the agent will head towards from the
    list of transforms we add to the preceding `_waypoints` list. Remove the 2D private
    member variables now and replace them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `_navMeshAgent` variable will hold the reference to `NavMeshAgent`
    that’s used to move our enemy NPC – its accessor is private and not serialized,
    we’ll have to ensure it’s assigned by using the Unity `Awake()` lifecycle message
    event. Do that now by adding the following method to the `PatrolWaypoints` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ll be adding the `NavMeshAgent` component to our enemy patrol bot when we
    set up its Prefab in the *Configuring the enemy NavMesh Agent (Prefab)* section.
    So, if we forget to add the component, `GetComponent()` will return a `null` assignment
    to the `_navMeshAgent` variable, and that just won’t do! To make ourselves aware
    of this potential forgetfulness, we’ll use a `Debug.Assert()` statement – if the
    condition is not met, an error message will be logged to the Unity console.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about **Debug.Assert** can be found here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of the variables! We can now move down to our first method to
    update, which involves getting things set up for the new patrolling behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the patrolling behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s look at the `Init()` method. First, we’ll change the method signature,
    specifically the parameters, because we no longer need the values for the rigid
    body nor the direction, as `NavMeshAgent` will now take care of these. We’re just
    going to leave the `acceleration` and `speed` parameters since they still apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Init()` method signature to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the contents of the `Init()` method, we’re going to remove all the previous
    movement code and replace it with the following – for working with `NavMeshAgent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick breakdown of the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_navMeshAgent.acceleration`: We assign the acceleration that will be passed
    in from our enemy configuration data to determine how quickly the agent will reach
    its maximum speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_navMeshAgent.speed`: We assign the speed passed in from our enemy configuration
    data to set the maximum speed the agent will travel along its path to the current
    waypoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_waypoints.Count > 0`: A quick insurance check that we indeed have a list
    of waypoints to work with before attempting to get the position of one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_navMeshAgent.SetDestination`: When the behavior is initialized, what waypoint
    will the NavMesh Agent travel to? This one. The index value of `0` addresses the
    first waypoint that was added to the `_waypoints` list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_waypointCurrentIndex`: Again, specifying the first waypoint in the `_waypoints`
    list by its index value of `0` as the current waypoint the agent will travel to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To quickly summarize what we did here, just as before in the 2D code, the `Init()`
    method is used to initialize the movement parameters for the NavMesh Agent. It
    is specifically designed to initiate navigation between waypoints as part of the
    implemented enemy NPC patrolling behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavMeshAgent` parameters can be a vital part of game balancing. They allow
    developers to adjust NPC behavior and game difficulty to match the design – creating
    challenging areas or guiding gameplay experiences. Hint: you’ll be adjusting these
    values later as you playtest the game level.'
  prefs: []
  type: TYPE_NORMAL
- en: With the initialization of the behavior completed, we can move down further
    in the class to revise the required methods.
  prefs: []
  type: TYPE_NORMAL
- en: Revising the update methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UpdateDirection()` method wasn’t technically responsible for moving the
    object in the previous 2D implementation (the `UpdateVelocity()` method was).
    Still, to keep within the same logical naming, I’ve decided to reuse it here.
  prefs: []
  type: TYPE_NORMAL
- en: The previous `UpdateDirection()` code was simply responsible for facing (flipping)
    the patrolling sprite object in the direction of movement – since the 2D game
    is a side-view, we don’t really have a rotation. Well, in a 3D perspective game,
    we certainly do have object rotation to contend with. Thankfully, the `NavMeshAgent`
    component will automatically calculate and apply the object’s rotation while pathfinding
    its way between waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To have more control over the agent’s rotation, you’ll have to manage it manually.
    Keep in mind that if you choose to, you’ll need to disable the NavMesh Agent’s
    automatic rotation by setting **_navMeshAgent.updateRotation =** **false**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the new `UpdateDirection()` method looks like now. Replace the
    code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, for the `UpdateDirection()` method, we’re now dealing directly
    with `NavMeshAgent`. We’re evaluating the current values for the progression using
    the `pathPending` and `remainingDistance` properties of the agent heading to the
    currently set destination waypoint. Precisely, we’ll execute a call to `MoveToNextWaypoint()`
    to set moving to the next waypoint when the agent’s current remaining distance
    is less than the stopping distance.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we rely on the **NavMeshAgent** component’s default values
    for its stopping distance, obstacle avoidance, and path-finding values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we’ve added a new method to handle setting the next waypoint
    from the list of available waypoints for when the agent arrives at the currently
    assigned waypoint. If you’re following along with the code directly, you can automatically
    use your IDE’s refactoring tools to generate the new `MoveToNextWaypoint()` method.
    Either way, with the new method created, add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too tricky is happening here; it’s just a simple *null check* and looping
    through the waypoints. Even so, a simple breakdown of these lines looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (_waypoints == null || _waypoints.Count == 0)`: Doing a double-check on
    the available waypoints in the list here, we’re ensuring it’s not `null`, and
    the count for the number of waypoints in the list is not `0` (zero) before continuing
    to execute statements to assign the next waypoint for the agent to travel to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_(_waypointCurrentIndex + 1) % _waypoints.Count`: The modulus operator (or
    remainder operator) ensures we loop back to the *beginning of the list* index
    when the `_waypointsCurrentIndex` value equals the list count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_navMeshAgent.SetDestination`: This is the `NavMeshAgent` method we call to
    tell the agent to start heading toward the passed-in position – the index assigned
    in the preceding line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modulus or remainder operator % (C#)
  prefs: []
  type: TYPE_NORMAL
- en: A typical shorthand way of using the modulus operator is to guarantee a seamless
    infinite loop of a list of items by ensuring that the current item index progresses
    linearly through each list item and only wraps around to **0** upon reaching the
    end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional reading can be found here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve sorted out the update methods to work with the new NavMesh
    system. Next, we’ll still work with methods, but instead of revising, we’ll remove
    ones that are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up unused methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Still working within the `PatrolWaypoints` class, we have some no longer needed
    methods. Instead of just leaving them in the class, let’s clean them up – by removing
    them – so if we ever need to revisit the class later, we won’t be confused by
    methods with zero references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following methods from the `PatrolWaypoints` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UpdateVelocity()`: The velocity is now calculated internally by `NavMeshAgent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetWaypoints(Transform left, Transform right)`: We won’t be spawning the patrolling
    enemy NPC NavMesh agents in this example. Consider this an opportunity to add
    a patrolling enemy spawner to your game later!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oh, and give “update `TickPhysics()`“ a quick fix by removing the now invalid
    call to the removed `UpdateVelocity()` method, leaving simply this expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Methods removed; check! To compare your revisions to the completed `PatrolWaypoints`
    class, you can find it here: [https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs](https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: Updated the behavior interface? Next refactoring item to check!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the behavior interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will be another quick section (very quick). The only changes we need to
    make for the `IBehaviorPatrolWaypoints` interface – you’ve probably already noticed
    the errors from saving the previous changes to the `PatrolWaypoints` class – are
    directly related to the implementing class’s changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `IBehaviorPatrolWaypoints` code to the following to resolve the
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, in addition to the error we just resolved, we have a few additional
    ones to clean up before we can call this process entirely done.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving remaining console errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the last bit of housekeeping on the 2D code refactoring, when we changed
    the behavior `PatrolWaypoints.Init()` method’s signature in the `PatrolWaypoints`
    class, we caused an error in the implementing classes. So, we’ll simply remove
    the unnecessary parameter variables to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `EnemyController.cs` script and update the portion of the `if` block
    body shown to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For the `_behaviorPatrol.Init()` call, the only `config` variables we must pass
    now are the acceleration and speed values. Easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: Completed 2D to 3D refactored code
  prefs: []
  type: TYPE_NORMAL
- en: 'It wasn’t a ton of changes, but it certainly may have seemed that way as we
    stepped through each one at a time and touched multiple scripts. If it left you
    a bit fuzzy on the final state of the code, you can refer to the completed scripts
    in the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, since we’re no longer using a rigid body to move the enemy NPC between
    waypoints, we can remove all references to `Rigidbody2D` in the `EnemyController`
    class, which includes removing the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Whew, we are done! We didn’t even break a sweat with all the 2D to 3D refactoring
    we completed in this section, right!? We are nearly there to test out our game’s
    new NavMesh setup for the 3D FPS enemy patrols. Two steps remain, including configuring
    the patrolling enemy Prefab next, and they’re also no sweat for us to complete
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the enemy NavMesh Agent (Prefab)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up a NavMesh Agent for waypoint patrol requires technical and visual
    setup in the Unity Editor, as well as careful consideration of the bot’s behavior
    for optimal player experience – nothing we haven’t done before. But, because there
    are several steps involved in the process, let’s first break it down into high-level
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Designing the enemy bot**: We’ll select the 3D model to use for the NavMesh
    Agent and create the Prefab asset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding the enemy base type and controller components**: We’ll add the required
    components to give the enemy object properties and state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configuring the patrolling behavior**: We’ll add the behavior component that
    implements patrolling waypoints.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adjusting NavMesh agent for the environment**: We’ll set the NavMesh Agent
    type and properties for the enemy bot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Testing and tweaking settings**: We’ll playtest and adjust values for the
    desired gameplay.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not so bad, only five steps! Here we go; let’s knock out the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the enemy bot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will be super easy because we’ll leverage more Polypix Studios 3D models
    provided for our game’s use. We have a lovely hovering camera drone (armed with
    some type of weaponry) available in the assets we previously added to the 3D FPS
    project in [*Chapter 11*](B18347_11.xhtml#_idTextAnchor212), which will be perfect
    for a patrolling enemy!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Patrol hover bot reporting for duty!](img/B18347_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Patrol hover bot reporting for duty!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps we’ll follow to build out the enemy patrol bot. Use *Figure
    13**.6* as an object hierarchy reference while completing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty GameObject in the Hierarchy, reset its transform, and rename
    it `Enemy Hover` `Bot A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Assets/Polypix 3D Assets/Prefabs` folder, find the `SM_Camera_Drone
    Variant` Prefab and parent it to the new `Enemy Hover Bot A` object – seen in
    *Figure 13**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that it’s always preferred to maintain the graphics as a child of the
    root object to make future changes easily, should you want or need to.
  prefs: []
  type: TYPE_NORMAL
- en: Set the following transform values for the `(0,` `0, 0)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(1.5,` `1.5, 1.5)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, for the child `SM_Camera_Drone` object, set its Y-position value to `0.6`
    so that it’s a good height off the ground – this is a hovering patrol bot! We
    change the child mesh object because we want the parent object anchor to maintain
    its current position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back to the `Enemy Hover Bot A` root object, add the following components to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Enemy`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnemyController`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PatrolWaypoints`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavMeshAgent`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about NavMesh Agent can be found here: [https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, make a Prefab by dragging `Enemy Hover Bot A` from the Hierarchy to the
    `Assets/Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results of these setup steps can be seen in *Figure 13**.6*. Note that for
    assigning the waypoints to the `PatrolWaypoints` component, we’ll add the waypoints
    to the scene in the *Adding waypoints to the level and* *testing* section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Enemy hover bot setup](img/B18347_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Enemy hover bot setup
  prefs: []
  type: TYPE_NORMAL
- en: That was just the first part. The second part of the setup requires the enemy
    configuration data that we’ll assign to the `EnemyController` component’s **Config**
    field, seen as (*A*) in *Figure 13**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the enemy bot properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember, in [*Chapter 7*](B18347_07.xhtml#_idTextAnchor130), we’re using
    a `ScriptableObject` asset to hold varying configurations to have different property
    values (for example, to change the enemy’s difficulty).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following these steps, we’ll create a new enemy configuration asset to assign
    right now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Assets/Data` folder in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While within the new folder, use the **Create** menu and select **ScriptableObjects**
    | **EnemyConfigData**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the newly created file asset `Enemy Bot` `A Config`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the following starting values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`10`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` (correct, we won’t have the patrol bot idle)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Infinity` (yes, **infinity** is a valid float value!)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, assign the `Enemy Bot A Config` asset to the `Enemy Bot A` Prefab’s
    `Enemy` component’s **Config** field and save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: Add a blob shadow projector to the enemy bot and light probes to the scene in
    the area of the level where the bot will be patrolling. This will maintain the
    high-quality visual fidelity of the game. You can refer to [*Chapter 11*](B18347_11.xhtml#_idTextAnchor212)
    as a reminder of how we implemented these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s all there is to creating the NavMesh Agent enemy patrol bot Prefab!
    Only two tasks remain to get the bot on patrol: defining the navigation surface
    and setting the waypoints.'
  prefs: []
  type: TYPE_NORMAL
- en: Baking the NavMesh Surface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our NavMesh Agent enemy bot Prefab is ready and equipped with all the
    necessary components, baking only the desired patrol areas is the next crucial
    step. We accomplish this with a NavMesh Surface component. By selectively defining
    the patrol areas in our game’s level, we can influence our level design for more
    strategic gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the NavMesh Surface can be found here: [https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Using *Figure 13**.7* as a reference, you can see I’ve decided to have the enemy
    hover bot patrol the main corridors, indicated by the blue surfaces, connecting
    the two major sections of the habitat station. We use layers to accomplish selectively
    baking NavMesh surfaces. Comparatively, we’ve previously utilized layers in a
    physics context to identify and limit interactions – so, layers have different
    purposes in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – NavMesh Surface baked and waypoints added](img/B18347_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – NavMesh Surface baked and waypoints added
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first have to add a new layer to select the specific surfaces for NavMesh
    baking. Using the `Floor` in the first available numbered **User** **Layer** fields.
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the contiguous corridor floor sections in the `Floor` layer by
    selecting it from the Inspector’s `NavMeshSurface` component.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the NavMesh Surface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After assigning floor sections to their designated layer, we’re ready to add
    the `NavMeshSurface` component and bake the surfaces – it’s like embedding invisible
    pathways that dictate the agent’s movements. This baking process will empower
    the agents we set up to navigate simple and complex paths with speed and accuracy,
    ensuring seamless AI navigation for our patrolling enemy hover bot!
  prefs: []
  type: TYPE_NORMAL
- en: 'To bake the NavMesh floor surfaces now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new empty GameObject to the `NavMesh Surface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can place this just under an organizational object in the `"----` `ENVIRONMENT
    ----"`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Set the **EditorOnly** tag on organization-only GameObjects in the **Scene**
    Hierarchy so these objects aren’t included in builds, saving some resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `NavMeshSurface` component to the `NavMesh` `Surface` GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that only the floor sections we want the enemy bot to patrol get baked,
    in the **Object Collection** | **Include Layers** dropdown, first select **Nothing**,
    then select **Floor**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the **Bake** button. The selected floor sections should now show a blue
    mesh that represents the baked navigation surface, as shown in *Figure 13.7*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And that’s really all there is to setting up the navigation surfaces for our
    NavMesh agents. Make sure to revisit the `NavMeshSurface` component whenever you
    make changes and re-bake. We’ll now make one final adjustment to the navigation
    setup via **Agent Type** before adding waypoints and testing it all out.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the agent type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An additional consideration we’ll make while baking the NavMesh Surface is to
    adjust the agent’s size to ensure its capabilities align with our needs. I’ve
    arbitrarily decided that we don’t want the bot to come too close to the sides
    of the corridor as it finds its way from waypoint to waypoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'While referring to *Figure 13**.8*, proceed to create a new navigation agent
    type by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Navigation** window by going to **Window** | **AI** | **Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the plus (**+**) icon at the bottom-right of the **Agent Types** list
    to add a new type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Bot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `1` to give the bot more of a margin from the walls of the corridors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `0.75`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Specifying a Bot agent type](img/B18347_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Specifying a Bot agent type
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can also access the **Navigation** window from the **NavMeshSurface** component
    by selecting **Open Agent Settings…** in the **Agent** **Type** dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a specific bot agent type to use with our navigation mesh
    surface, return to both the following components to set `Bot`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NavMeshSurface` component: On the `NavMesh Surface` object in the **Scene**
    Hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NavMeshAgent` component: On the `Enemy Hover Bot A` Prefab (which can
    be seen as (*B*) in *Figure 13**.6*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having `NavMeshSurface` and `NavMeshAgent` use the same agent type is a requirement
    of the AI Navigation system – you’ll receive odd *set destination*-related issues
    in the console if they don’t, and baking just won’t work!
  prefs: []
  type: TYPE_NORMAL
- en: With a different agent type selected, we’ll have to click the **Bake** button
    again to calculate the new navigation mesh surface – make sure you return to re-bake
    as needed when adjustments are made to the **Agent** **Type** values.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only touched the surface
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorry, I couldn’t help the pun! The Unity AI Navigation system is capable of
    a *lot* more than what we’ve touched on here. I encourage you to explore the documentation
    and try implementing additional features into your game to level up the player
    experience even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the navigation surface baked, we can finally add waypoints
    to get the bot performing its patrol duties while walking the beat!
  prefs: []
  type: TYPE_NORMAL
- en: Adding waypoints to the level and testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NPC patrolling enhances gameplay by making environments feel alive, increasing
    player immersion and challenge. While having an NPC patrol a set of waypoints
    may not be considered an **emergent behavior** on its own, encounters can still
    appear unpredictable, keeping gameplay exciting and testing the player’s adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: Emergent behavior
  prefs: []
  type: TYPE_NORMAL
- en: Emergent gameplay refers to complex situations that could arise from the implementation
    of simple game mechanics in both video and tabletop board games.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already configured all the requirements for adding the ability for our
    enemy bot to patrol; we just need to define the specific patrol points now. So,
    follow these steps to add our waypoints to specific locations within the navigation
    mesh surface we made:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty GameObject named `Patrol Waypoints` to the **Scene** Hierarchy
    to parent (group) the waypoint objects under.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t forget to reset the transform position to `(0, 0, 0)` after adding the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Add three GameObjects, one to each end of the corridors – whose transform position
    represents the actual waypoint location; see *Figure 13**.7* as a location reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a waypoint object selected, use the Inspector to assign an icon for quick
    identification in the **Scene** view – *Figure 13**.7* shows a green label icon
    having been selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have waypoints in our scene, we can assign them to the `PatrolWaypoints`
    behavior component’s `Enemy Bot A` object in the **Scene** Hierarchy, then lock
    the Inspector. Now, select all three waypoint objects we just made and drag them
    to the **Waypoints** field to add them all at once. If we didn’t lock the Inspector,
    it would have changed when we multi-selected the waypoint objects in the hierarchy,
    preventing the assignment. Alternatively, without locking the Inspector, you can
    drag each waypoint one at a time to assign them (yuck).
  prefs: []
  type: TYPE_NORMAL
- en: Obligatory saving reminder
  prefs: []
  type: TYPE_NORMAL
- en: You’ve been hitting *Ctrl/Cmd* + *S* to save your scene periodically, right?
    Consider this a reminder to do it now. The waypoints assignment to the **Enemy
    Bot A** Prefab is a scene-level save; they won’t be saved with the file-based
    Prefab asset.
  prefs: []
  type: TYPE_NORMAL
- en: Test out navigating the waypoints. Enter **Play mode**, switch back to the **Scene**
    view, adjust the view, and watch the bot navigate a path to the waypoints in the
    order they appear in the list of waypoints – make any adjustments to the **Config**
    values for acceleration, speed, or the navigation agent type radius, and so on.
    Repeat playtesting as needed to get the initial enemy bot patrolling in a, well,
    good patrolling fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to refactor a 2D patrolling waypoint behavior
    to its 3D equivalent counterpart using Unity’s NavMesh system. Next, let’s make
    the enemy bot have the ability to detect – or sense – the player and respond with
    appropriate behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic enemies with sensors and behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In video games, sensors can play a crucial role in creating interactive and
    dynamic AI behaviors. They enable NPCs to *perceive* their surroundings, allowing
    them to react to not only the player but also other environmental things in a
    *more realistic* manner. For example, in stealth games such as **Metal Gear Solid**,
    enemies are often equipped with a **field of view** (**FOV**) sensor that detects
    the player when they enter their line of sight. Similarly, games such as **The
    Last of Us** incorporate audio sensors that enable enemies to detect the player
    based on noises they make. These types of sensors add depth to the gameplay by
    having players change the strategy of their movement and actions more carefully.
  prefs: []
  type: TYPE_NORMAL
- en: In short, sensors are abilities added to our objects that make them aware of
    their surroundings and other objects – especially true concerning an enemy NPC
    and the player!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at some code that can be used to implement the
    two types of sensors we just identified: detecting the player based on an FOV
    and the player based on audio – such as the player’s footsteps.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating sensory behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first sensor code we’ll look at is for detecting the player within an FOV
    of the patrolling enemy NPC. We’ll make this an event-based class that does not
    inherit from `MonoBehaviour`. That way, we can use it directly in the implementing
    class, `EnemyController`, by simply creating a new instance. It will be very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, look at the code template for our sensor classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SensorTemplate`: Note that we’re not a derived class, and there is no
    inheritance from `MonoBehaviour` since we won’t be using this class as a component
    in the Inspector. We’ll create an instance of the sensor class in the implementing
    class using the `new` keyword (remember, too, that we can’t use `new` with `MonoBehaviour`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonoBehaviour _context`: Speaking of `MonoBehaviour`… we may still need access
    to it for running a coroutine or getting the `Transform` values or GameObject
    of the implementing class. We’ll use the class constructor to assign this variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time an instance of a class or struct is created, its constructor is
    called. More information can be found here: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors).'
  prefs: []
  type: TYPE_NORMAL
- en: '`event UnityAction OnSensorDetected`: I mentioned the sensor class will be
    event-based, so here it is. This is the event, `UnityAction`, that we’ll invoke
    when the sensor detects, well, what we design it to detect. The `event` keyword
    enforces that only the declaring class can invoke it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SensorTemplate(MonoBehaviour context)`: We have our class’s constructor here.
    The method that shares the same name as the class is the constructor. We’ve added
    a parameter to set the `_context` member variable when creating the class instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Tick()`: This is where the magic happens. Typically, `Tick()` will be
    called from the implementing class’s `Update()` method to perform the detection
    work required for each sensor’s purpose. We’ll invoke the `OnSensorDetected` event
    only when the detection occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, before continuing onto the two sensor examples I’ve provided, let’s see
    how the sensor class is used in the implementing class. We’ll use `EnemyController`
    for this example, where we previously just used a simple member method, `IsPlayerInRange()`.
    You can see how we can instead use a sensor class as a way to construct an NPC’s
    abilities in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another quick breakdown of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private SensorTemplate _sensor`: This variable will hold the instance of the
    sensor class we create to refer to throughout its implementation in this class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_sensor = new SensorTemplate(this)`: Using the `new` keyword, we create a
    new instance of the sensor class for its use, passing in the `this` keyword, which
    represents the `EnemyController` class (derived from the `MonoBehaviour` base
    class).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'The **this** keyword refers to the current instance of a class. More information
    can be found here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this).'
  prefs: []
  type: TYPE_NORMAL
- en: '`_sensor.OnSensorDetected += HandleSensor_Detected`: Adding the handler method
    for listening when the sensor detects something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this template example, the `HandleSensor_Detected()` method simply changes
    to a different state where the controller will take action based on the sensor
    detection. Don’t forget that we can also pass parameters to the handler method
    via the event; simply change the event type declaration to something like `UnityAction<float>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`void Update()`: We’ll run the `Update()` method every frame in the sensor
    class for it to perform its detecting workload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s all there is to implementing custom class instances for the purpose of
    adding sensing abilities to your NPCs. If you want to further solidify the sensor
    class’s architecture, you could use a base abstract class or an interface. Consider
    this your challenge to refactor the sensor template code with either of these
    patterns in mind!
  prefs: []
  type: TYPE_NORMAL
- en: Abstract class or interface?
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can provide a starting point with some predefined ways to
    do things, whereas an interface simply states requirements that must be followed.
    Imagine you have a box of crayons with some colors already defined – that’s the
    abstract class. And a coloring book with outlines of pictures where you have to
    stay within the lines – that’s the interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, I’ve provided two code examples for sensor
    classes that can be added to any controller class to detect a target within an
    FOV and detect any nearby player’s audio source that is playing.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the player within an FOV sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine having a pair of glasses that can assist you in finding your friends
    in a game of hide and seek. These glasses work similarly to the *player within
    the FOV sensor* in a video game, where you have a limited seeing distance and
    area of view and need to look in the correct direction to identify your friends.
    If the player is within the viewing angle and distance while not hidden behind
    anything, the sensor detects them and triggers an alert. By using this type of
    sensor in a video game, NPCs can detect, or sense, the player, similar to how
    the glasses help during the game of hide and seek.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve provided the complete example `SensorTargetInFOV` class in the 3D FPS
    game project code available for download and its initial implementation in the
    `EnemyController` class. The script is located here: `Assets/Scripts/Sensors/SensorTargetInFOV.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: Download the complete sensor code
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for all the example sensors can be found on the GitHub repository
    here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class constructor has additional parameters added for specifying the FOV
    angle and the visual range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These additional values are then used for the sensor’s detection calculation
    within its `IsTargetInsideFOV()` method called every frame tick, which does the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the direction of the specified target object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target object is set with a call to `SetTarget()` just before calling `Tick()`.
  prefs: []
  type: TYPE_NORMAL
- en: If the direction to the target angle is within the specified `fovAngle`, it
    then calculates the distance to the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the distance to the target is within `fovRange`, we finally do a physics
    **raycast** to detect the target object as the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: In game development, a *raycast* is a common way of detecting objects. It involves
    projecting an invisible laser beam in a specified direction to report on any objects
    that it intersects with.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about **Physics.Raycast** can be found here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: If the hit object of the raycast is the player – determined by comparing its
    tag – we invoke the *target* *detected* event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explore and discover the sensor code and its implementation to further solidify
    your understanding of the different ways in which we can create code architecture.
    We’ll now look at the second sensor example, the hearing sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the player’s audio sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a video game, a hearing sensor gives your NPCs the ability to identify sounds
    from the surrounding environment with super-sensitive ears. This type of sensor
    can help the NPC locate and identify objects based on the sounds they make, even
    if the object is not visible to the NPC. My favorite example of this is the horrifying
    game **Alien: Isolation**, in which the alien NPC uses a sophisticated hearing
    sensor to not only hear noises made by the player but also recognize their severity
    – sound plays a crucial role in the survival-horror experience.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a hearing-type sensor in your game may or may not be so frightening,
    but it will elevate the gameplay experience nonetheless. I’ve provided the complete
    example `SensorHearing` class in the 3D FPS game project code available for download
    and its initial implementation in the `EnemyController` class. The script is located
    here: `Assets/Scripts/Sensors/SensorHearing.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class constructor has additional parameters added for specifying the hearing
    range and update frequency (how often to check for audio sources):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These additional values are then used for the sensor’s detection calculation
    within its `IsAudioDetected()` method called every frame tick. Additionally, we’re
    using the passed-in `MonoBehaviour` context to start a coroutine: coroutines require
    a `MonoBehaviour` object to run – to periodically update the list of audio sources
    in the scene (not particularly useful for our 3D FPS game but especially relevant
    for multiplayer games where players will drop in and out of gameplay).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The audio detection method, `IsAudioDetected()`, does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll simply start by iterating through a list of audio sources found in the
    scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an audio source is playing and we can hear the audio source, invoke the *target*
    *detected* event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CanHearAudioSource()` is used to determine whether the currently playing audio
    source is within `hearingRange`, adjusted for its playing volume.'
  prefs: []
  type: TYPE_NORMAL
- en: Player footsteps 3D audio source
  prefs: []
  type: TYPE_NORMAL
- en: Note that for our player footsteps audio, we implemented it as a 2D sound using
    the **AudioPlayerSFX** component. For the enemy NPC to sense the player’s footstep
    sounds, with the **SensorHearing** class, we’d need to use the **AudioPlayerSFX3D**
    component instead. Refer to [*Chapter 12*](B18347_12.xhtml#_idTextAnchor232) if
    you’d like to refactor the player footsteps to support audio-sensing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for this sensor, explore and discover the sensor code and its implementation
    to further solidify your understanding of the different ways in which we can create
    code architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what a sensor is in game development terms and how
    to use a class that does not derive from `MonoBehaviour` to implement sensory
    abilities for our NPCs. Next, we’ll see how a behavior tree can help to manage
    the complexity of AI for NPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Wrangling behaviors with a behavior tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **behavior tree** (**BT**) is a powerful and flexible tool for implementing
    diverse AI-driven NPCs because it enables more complex hierarchical decision-making
    compared to a more traditional **finite state machine** (**FSM**) that would simply
    hold the current state. BTs work really well with predefined sensors, such as
    our *player within FOV sensor* and *hearing player audio* sensors we’ve discussed,
    since these sensors could be integrated into the BT as custom nodes in the graph.
    This sensor integration would allow NPCs to make decisions based on sensory input
    conditions, favorably enhancing enemy NPC behavior for the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Because BTs are graph-based, with sequences, actions, and other nodes, they
    offer a more manageable way to visualize the relationship of the AI behavior being
    implemented. However, BTs are not visual scripting (although some BT frameworks
    do provide functionality that crosses over into what might be considered visual
    scripting). Conditional nodes are what allow the BT-driven NPC to react dynamically
    to the player’s actions, such as changing the NPC’s behavior from patrolling to
    investigating a noise or spotting the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example UML diagram of a BT for a patrolling NPC that can
    sense the player’s position within its FOV or hear the player, with the child
    nodes representing the resulting state of the triggered sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – A simple BT graph](img/B18347_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – A simple BT graph
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the hierarchical structure of BTs offers a clear and manageable
    way to design AI behaviors. Tools such as **Behavior Designer**, **Node Canvas**,
    and **Schema** in the Unity Asset Store provide frameworks for creating BTs, mostly
    without the need to write any code. They offer intuitive editors, many pre-built
    nodes, plus their own custom actions and actions specific to the Unity Scripting
    API, too.
  prefs: []
  type: TYPE_NORMAL
- en: BT tools are designed to make it easier for Unity developers to implement complex
    behaviors for their NPCs. They’re also more accessible for integrating custom
    conditional nodes (e.g., sensors), allowing for rapid iteration of configurations
    to attain the desired behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Free behavior tree asset | Unity Asset Store
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema** is described as “*A fast, easy platform to build artificial intelligence
    with Behavior Trees. Create complex and intelligent behaviors for your game without
    writing a single line of code. Behavior trees are used extensively by AAA studios
    to bring lifelike behaviors into* *their AI.*”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is its Asset Store link: [https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876](https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876).'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already gone ahead and added the Schema BT asset to the 3D FPS project
    files in the book’s GitHub repo (link in the *Technical requirements* section)
    for you to explore and experiment with. You can use the Schema graph editor to
    create custom nodes for the sensors we made in the previous *Creating sensory
    behaviors* section and apply them to the enemy hover bot NPC.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Muse AI tools – Behavior
  prefs: []
  type: TYPE_NORMAL
- en: '**Muse Behavior** is a new Unity built-in graph-based BT tool with an intuitive
    flow graph and action node stories for AI designers. It is currently in pre-release
    but looks to be an up-and-coming full-featured BT solution for AI NPC design –
    including the ability to use text-input generative AI to create node actions rapidly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the link to a Muse Behavior tutorial project: [https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570](https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570).'
  prefs: []
  type: TYPE_NORMAL
- en: As a game developer, you’ll gravitate toward certain technologies over others
    and favor either a code-only approach or adding some visual tools to your skill
    set over time. At the end of the day, remember, it’s about overcoming challenges
    effectively to implement all the features in the scope of your project, and especially
    to finish the game!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned the value of creating sensors for adding detecting
    abilities to our NPCs and using a BT as a visual tool for creating, managing,
    and setting up dynamic AI-driven NPC behaviors. Next, we’ll look at AI-driven
    behavior further by investigating Unity’s ML tools.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ML with ML-Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many parts of developing a video game touch on technologies that could fill
    entire books all on their own, and ML is definitely one of them! Unity has its
    own tooling for ML that is particularly suited for games, and it’s called **ML-Agents**.
  prefs: []
  type: TYPE_NORMAL
- en: ML-Agents is an **AI toolkit** for Unity developers that helps them create advanced
    and complex behaviors in their games and simulations using ML techniques. Unlike
    BTs, which rely on hand-crafted sets of rules, ML-Agents leverages ML to enable
    NPCs to *learn* and adapt their behavior by interacting with their surroundings.
    This is accomplished by training an agent using ML techniques such as **reinforcement
    learning**, **imitation learning**, or other custom methods. The process enables
    trained agent NPCs to determine the best course of action, all on their own, constantly
    changing and surprising you with dynamic and, hopefully, unpredictable gameplay.
    I briefly noted **emergent gameplay** before, and this is it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity ML-Agents applies to various scenarios, from simple games to much more
    complex simulations. Here is a summarized list of what the ML-Agents toolkit offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Different training environments**: You can create environments as simple
    or complex as the real world to train agents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variety of training algorithms**: Also relatable to the toolkit’s flexibility,
    it supports various cutting-edge ML algorithms customizable for the agent training
    task at hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity integration**: ML-Agents is designed to work specifically with Unity,
    which makes it very accessible to Unity game developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity also provides a breadth of resources to learn ML-Agents, including the
    **ML-Agents: Hummingbirds** project, a comprehensive example project with approximately
    10 hours of content!'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about ML-Agents can be found here: [https://unity.com/products/machine-learning-agents](https://unity.com/products/machine-learning-agents).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the ML-Agents toolkit can be found here: [https://github.com/Unity-Technologies/ml-agents/tree/latest_release](https://github.com/Unity-Technologies/ml-agents/tree/latest_release).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about ML-Agents: Hummingbirds can be found here: [https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview](https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three basic steps to how ML-Agents can work for Unity games:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrating**: This step involves integrating the Unity ML-Agents package
    into a Unity project designed for training.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Training agents**: This step involves connecting the Unity project to train
    the agents to learn the desired behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Embedding**: This final step involves embedding the trained agent model into
    your game project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s keep this simplified, high-level, three-step process in mind and build
    on our previous work with the Unity AI Navigation package. In this way, we can
    use a NavMesh Agent to optimize the efficiency of the ML-Agents agent training
    by having it focus on behavior training and not navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating training efficiency with NavMesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing a game using ML-Agents, we can use the `NavMeshAgent` component
    to handle the task of agent navigation while leaving the ML-Agents training to
    focus on the higher-level decision-making processes such as patrolling, investigating,
    and attacking the player character.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach of blending intelligent AI behavior with an established navigation
    setup results in a more streamlined and effective training result. The following
    figure shows a simple training scene with a NavMesh Surface setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Example ML-Agents training scene](img/B18347_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Example ML-Agents training scene
  prefs: []
  type: TYPE_NORMAL
- en: Having noted this efficiency, let’s see what a general ML-Agents training setup
    looks like next.
  prefs: []
  type: TYPE_NORMAL
- en: Examining an ML-Agents setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a more detailed breakdown of the steps we’d typically see setting up
    ML-Agents training and implementation within Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: The ML-Agents package and dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The latest installation instructions can be found in the ML-Agents GitHub repo
    at [https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md](https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md):'
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend installing the latest version using the GitHub URL via the Package
    Manager: git+[https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21](https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dependencies include ML-Agents extensions, `mlagents` Python package, **PyTorch**
    (Windows), **Visual C++ Redistributable**, and **Unity Sentis**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unity project setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Unity project, selecting a **3D** **Core** template.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Design the environment with a baked NavMesh Surface and add objects to the scene
    representing the player character and the NPC that should observe the player.
    Refer to *Figure 13**.10* for a simple training scene representation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setting up the agents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach both the `NavMeshAgent` and ML-Agents `Agent` components to the NPC object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `NavMeshAgent` properties such as speed, angular speed, and acceleration.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the agent methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class that inherits from `Unity.MLAgents.Agent`, named, for example,
    `AgentController`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `Agent.CollectObservations()` method to inform the agent with
    sensor information concerning the environment or player data:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `Agent.OnActionReceived()` method to apply NPC actions such as
    setting the destination for the NavMesh Agent or turning to face the player:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the rewards and training:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define rewards within the `OnActionReceived()` method:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetReward()` method and pass in a positive float value for successfully reaching
    a patrol point or facing the player, for example. Note that this function replaces
    any rewards given to the agent during the current step. You can also use `AddReward()`
    to incrementally change rewards instead of overriding.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetReward()` method and pass in a negative float value for undesirable behaviors
    such as running into walls or losing sight of the player:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a training configuration file (i.e., `trainer_config.yaml`) where the
    specified training algorithm will be defined (e.g., reinforcement learning algorithm)
    along with its configuration.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure both a `BehaviorParameters` and `DecisionRequestor` component on the
    player object agent for the observation and decision-making settings.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the training process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Command Prompt or Terminal, navigate to your Unity project folder, run
    the training command (e.g., `mlagents-learn trainer_config.yaml --run-id=firstNPCPatrol`
    – here, `run-id` is any unique name for the session), and use **TensorBoard**
    to monitor the training process of the agent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Integrate the training results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After finishing training, the inference model is saved as a `.nn` file. Import
    it into a folder in your Unity project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the agent, assign the model to the `BehaviorParameters` component’s **Model**
    property and set **Behavior Type** to **Inference Only** to test the behavior
    in your scene.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Playtest and iterate on the design:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, play the scene and observe the NPC agent’s behavior (for example,
    as it patrols, senses, or detects the player).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust rewards and rerun the training as needed to refine the NPC behavior incrementally.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By following these steps, you can set up a training environment that uses a
    NavMesh Agent for pathfinding. At the same time, ML-Agents is left to train only
    the complex NPC behavior, such as patrolling and player detection in our example.
  prefs: []
  type: TYPE_NORMAL
- en: ML-Agents sample environments
  prefs: []
  type: TYPE_NORMAL
- en: The **ML-Agents Toolkit** GitHub repository contains a set of example environments
    that demonstrate the various features of the toolkit. These environments can also
    be used as a starting basis for new environments or a predefined setup for testing
    new ML algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some example learning environments can be found here: [https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md](https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md).'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking to create a truly exceptional gaming experience for your players,
    consider using ML with ML-Agents. It’s a powerful tool that can help you achieve
    remarkable results!
  prefs: []
  type: TYPE_NORMAL
- en: Unity Muse | Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: During the course of the Unity 2022 tech stream releases, Unity has released
    new AI tools for developers under the moniker **Unity Muse**. The tools are currently
    offered as a subscription service, starting with a free trial period.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about Unity Muse AI tools for developers can be found here:
    [https://unity.com/products/muse](https://unity.com/products/muse).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored how Unity’s ML-Agents toolkit can be used to train
    NPCs with ML algorithms. The result is an NPC with adaptable behaviors that go
    beyond what we can pre-script for an AI (for example, with a BT). We further understood
    the required knowledge to use ML-Agents in a Unity project to elevate the player
    experience with adaptive NPC behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we refactored our game’s enemy NPCs from 2D to 3D environments
    while still using waypoints but also leveraging Unity’s NavMesh system for AI
    navigation. We also improved our NPCs’ behavior complexity by enabling them to
    interact with the player and the environment more realistically by using sensors
    – the effect of which is to challenge players more engagingly.
  prefs: []
  type: TYPE_NORMAL
- en: We continued discussing dynamic enemy behavior by incorporating our sensors
    as conditions within BTs. We completed our advanced AI discussion with an introduction
    to ML by using Unity’s ML-Agents, enabling NPCs that can learn and evolve, allowing
    us to integrate advanced AI-based gameplay into our games for remarkable player
    experiences.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll finish things up with the 3D FPS game by creating
    a classic boss room battle in **mixed reality** (**MR**). Additionally, you will
    learn how to design a challenging boss room and its mechanics quickly by applying
    all the previous lessons learned for developing game systems.
  prefs: []
  type: TYPE_NORMAL
