- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: 'Next-Gen UI: Creating Dynamic Interfaces with UI Toolkit'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新一代 UI：使用 UI Toolkit 创建动态界面
- en: In the previous chapter, we discussed how to create user interfaces using **uGUI**
    (also known as **Canvas**), one of the most common Unity UI systems, but as we
    already mentioned, this is not the only one. While, so far, uGUI has been the
    most preferred option, Unity is working on a replacement called **UI Toolkit**,
    and even if it doesn’t have feature parity with uGUI yet, we thought it is worth
    covering it in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何使用 **uGUI**（也称为 **Canvas**），这是最常用的 Unity UI 系统之一，但正如我们已经提到的，这并不是唯一的选择。虽然到目前为止，uGUI
    一直是首选选项，但 Unity 正在开发一个名为 **UI Toolkit** 的替代品，即使它还没有与 uGUI 具有相同的功能性，我们认为在本书中介绍它也是值得的。
- en: The idea of this chapter is to create the same UI we created previously but
    with UI Toolkit, so you can get an idea of how creating a UI in Unity will look
    soon.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是创建我们之前创建的相同 UI，但使用 UI Toolkit，这样你就可以了解在 Unity 中创建 UI 将会是什么样子。
- en: 'In this chapter, we will examine the following UI concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下 UI 概念：
- en: Why learn how to use UI Toolkit?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么学习如何使用 UI 工具包？
- en: Creating a UI with UI Toolkit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 创建 UI
- en: Making a responsive UI with UI Toolkit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 制作响应式 UI
- en: 'By the end of the chapter, you will learn how to use UI Toolkit to create basic
    UIs for our game, redoing the UI we did in the last chapter as a point of reference.
    So, let’s start by answering the following question first: why learn how to use
    UI Toolkit?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学习如何使用 UI Toolkit 为我们的游戏创建基本的 UI，作为参考重新制作上一章中的 UI。所以，让我们首先回答以下问题：为什么学习如何使用
    UI Toolkit？
- en: Why learn how to use UI Toolkit?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么学习如何使用 UI Toolkit？
- en: I know the topic of this chapter might sound a little bit confusing; we just
    learned how to use a whole Unity system to create our UI, and now we are learning
    how to use another one! Why do we have to learn about this new one?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道本章的主题可能听起来有点令人困惑；我们刚刚学习了如何使用整个 Unity 系统来创建我们的 UI，现在我们正在学习如何使用另一个！为什么我们必须学习这个新系统？
- en: One reason for learning both systems is that UI Toolkit, while promising, doesn’t
    yet match uGUI in feature completeness, which is crucial for real-world production.
    Another thing to take into account is that even if UI Toolkit is stable enough,
    it’s still a relatively new system, and there are still lots of games in development
    that were created on older Unity versions that don’t support it. This means that
    in order to land a job in this industry, we need to get a decent amount of exposure
    to uGUI, due to most games being created with this technology.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这两个系统的其中一个原因是因为 UI Toolkit 虽然很有前途，但在功能完整性方面还没有达到 uGUI 的水平，这对于现实世界的生产至关重要。另一个需要考虑的事情是，即使
    UI Toolkit 已经足够稳定，它仍然是一个相对较新的系统，还有很多游戏是在不支持它的旧 Unity 版本上创建的。这意味着为了在这个行业中找到工作，我们需要对
    uGUI 有足够的了解，因为大多数游戏都是使用这项技术制作的。
- en: This happens because it’s not safe or practical to update an already-tested
    and working game with new technologies; such changes could lead to a major rework
    of the game to make it compatible with the new versions. Also, this could potentially
    introduce tons of bugs that could delay the release of new versions—not to mention
    the time it would take to remake a full app with a new system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为用新技术更新已经测试并正常工作的游戏并不安全或不切实际；这些更改可能会导致游戏进行大规模的重做以兼容新版本。此外，这可能会引入大量的错误，从而延迟新版本的发布——更不用说重新用新系统制作整个应用所需的时间了。
- en: That being said, we believe it’s still worth learning the basic concepts of
    UI Toolkit to be prepared to use it in newer Unity versions, so let’s dive into
    it now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们认为学习 UI Toolkit 的基本概念仍然值得，以便为在新版 Unity 中使用它做好准备，所以现在让我们深入探讨。
- en: Creating a UI with UI Toolkit
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 创建 UI
- en: 'In this section, we are going to learn about UI documents, a cornerstone of
    UI Toolkit. These assets are crucial for defining your UI’s structure and components,
    and we’ll learn how to create and utilize them effectively. To do this, we are
    going to discuss the following concepts:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 UI 文档，这是 UI Toolkit 的基石。这些资产对于定义你的 UI 结构和组件至关重要，我们将学习如何有效地创建和使用它们。为此，我们将讨论以下概念：
- en: Creating UI Documents
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI 文档
- en: Editing UI Documents
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 UI 文档
- en: Creating UI Stylesheets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI 样式表
- en: Let’s start by seeing how we can create our first UI Document.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何创建我们的第一个 UI 文档。
- en: Creating UI Documents
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 UI 文档
- en: When creating a UI with uGUI, we need to create GameObjects and attach components
    like **Button**, **Image**, or **Text**, but with UI Toolkit, we need to create
    a **UI Document** instead. A UI Document is a special kind of asset that will
    contain the definition of the elements our UI will have and its hierarchy. We
    will have a GameObject with a **UI Document** component (yes, it’s called the
    same, so pay attention here) that will reference this **UI Document** asset and
    render its contents. It’s like a mesh asset that contains information about the
    mesh and the `MeshRenderer` component that will render it. In this case, the elements
    to render are contained in an asset, and we have a component that reads the asset
    and renders its content (the UI in this case).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 uGUI 创建 UI 时，我们需要创建 GameObject 并附加**按钮**、**图像**或**文本**等组件，但使用 UI Toolkit，我们需要创建一个**UI
    文档**。UI 文档是一种特殊的资产，它将包含我们 UI 将有的元素及其层次结构。我们将有一个具有**UI 文档**组件的 GameObject（是的，它叫法相同，所以请注意这里）将引用此**UI
    文档**资产并渲染其内容。它就像一个包含有关网格和将要渲染它的 `MeshRenderer` 组件信息的网格资产。在这种情况下，要渲染的元素包含在一个资产中，我们有一个读取资产并渲染其内容（在这种情况下是
    UI）的组件。
- en: 'Interestingly, UI Documents are plain text files at their core. This means
    you can open and inspect them with any standard text editor, offering a straightforward
    way to understand their structure. If you do that and you are familiar with HTML,
    you will recognize the XML-like format used to define the elements our UI will
    be composed of; Unity calls this format UXML. With UI Toolkit, Unity is attempting
    to make it easy for web developers to jump into Unity and create UIs. In the following
    code, you can see the typical look of a UXML document’s file contents:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，UI 文档在其核心是纯文本文件。这意味着您可以使用任何标准文本编辑器打开和检查它们，这提供了一种简单的方法来理解它们的结构。如果您这样做并且您熟悉
    HTML，您将识别出用于定义我们 UI 将由其组成的元素的 XML 类似格式；Unity 将此格式称为 UXML。使用 UI Toolkit，Unity 正在尝试让网页开发者更容易地进入
    Unity 并创建 UI。在以下代码中，您可以看到 UXML 文档文件内容的典型外观：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don’t worry if you don’t know XML; we will explain the core concepts in this
    chapter. Also, don’t worry about the UXML format; later in this chapter, we will
    use a visual editor called **UI Builder** to edit our UI without writing UXML
    at all, but it is worth knowing how it actually works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道 XML，我们将在本章中解释核心概念。另外，不要担心 UXML 格式；在本章的后面部分，我们将使用一个名为**UI Builder**的视觉编辑器来编辑我们的
    UI，而无需编写任何 UXML，但了解它是如何实际工作的仍然很有价值。
- en: 'In order to create a UI Document and add it to the scene, we need to do the
    following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 UI 文档并将其添加到场景中，我们需要执行以下操作：
- en: 'Click the **+** | **UI Toolkit** | **UI Document** option in the **Project**
    view to create a **UI Document** asset, and name it `GameHUD`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中点击**+** | **UI Toolkit** | **UI 文档**选项来创建一个**UI 文档**资产，并将其命名为 `GameHUD`：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_01_PE.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B21361_16_01_PE.png)'
- en: 'Figure 16.1: Creating the UI Document asset'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：创建 UI 文档资产
- en: Click the **Game Object** | **UI Toolkit** | **UI Document** option to create
    a GameObject in your scene with the **UI Document** component, which is capable
    of rendering the UI Document.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**游戏对象** | **UI Toolkit** | **UI 文档**选项在您的场景中创建一个具有**UI 文档**组件的 GameObject，该组件能够渲染
    UI 文档。
- en: 'Select it, and drag the **GameHUD** **UI Document** asset (the one created
    in *Step 1*) to the **Source Asset** property of the **UI Document** GameObject
    (the one created in *Step 2*):'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它，并将**GameHUD** **UI 文档**资产（在*步骤 1*中创建的）拖动到**UI 文档**GameObject（在*步骤 2*中创建的）的**源资产**属性：
- en: '![](img/B21361_16_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_02.png)'
- en: 'Figure 16.2: Making the UI Document component to render our UI Document asset'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：使 UI 文档组件渲染我们的 UI 文档资产
- en: And that’s it! Of course, we won’t see anything yet on our screen as the UI
    Document is blank, so let’s start adding elements to it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！当然，由于 UI 文档是空的，我们屏幕上目前不会显示任何内容，所以让我们开始向其中添加元素。
- en: Editing UI Documents
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑 UI 文档
- en: 'As our goal is to recreate the same UI we created in the last chapter, let’s
    start with the simplest part: adding the player avatar to the top-left corner.
    One option would be to open the **UI Document** asset with any text editor and
    start writing the UXML code, but luckily, we have an easier way, which is using
    the **UI Builder** editor. This editor allows us to generate the UXML code visually
    by dragging and dropping elements.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是重新创建我们在上一章中创建的相同UI，让我们从最简单的一部分开始：将玩家头像添加到左上角。一个选择是使用任何文本编辑器打开**UI文档**资产并开始编写UXML代码，但幸运的是，我们有一个更简单的方法，那就是使用**UI构建器**编辑器。这个编辑器允许我们通过拖放元素来可视地生成UXML代码。
- en: 'Before we jump in, let’s take a quick tour of the UI **Builder** window to
    see what we’re working with:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们快速浏览一下UI **构建器**窗口，看看我们正在处理什么：
- en: 'Double-click the **GameHUD** asset in the **Project** view to make **UI Builder**
    open it:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中双击**GameHUD**资产以使**UI构建器**打开它：
- en: '![](img/B21361_16_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_16_03.png]'
- en: 'Figure 16.3: The UI Builder editor'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：UI构建器编辑器
- en: In the **Hierarchy** panel inside UI Builder (*not* the **Hierarchy** panel
    we’ve used so far in previous chapters), select `GameHUD.uxml`, which is the container
    element of the UI.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI构建器内部的**层次结构**面板中（**不是**我们在前几章中使用的那个**层次结构**面板），选择`GameHUD.uxml`，这是UI的容器元素。
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_04_PE.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度低](img/B21361_16_04_PE.png)'
- en: 'Figure 16.4: Selecting the asset name in Hierarchy to edit the general UI settings'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：在层次结构中选择资产名称以编辑通用UI设置
- en: 'Look at the **Inspector** panel at the right of the UI Builder window (*not*
    the **Inspector** we’ve used so far to modify GameObjects). Set the **Size** property
    to a **Width** of `1920` and a **Height** of `1080`. This will allow us to view
    how our UI will look in this resolution. You can later change this value to see
    how it adapts to different sizes, but more on that later:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看UI构建器窗口右侧的**检查器**面板（**不是**我们之前用来修改GameObject的**检查器**）。将**大小**属性设置为**宽度**为`1920`和**高度**为`1080`。这将允许我们查看我们的UI在这个分辨率下的外观。您稍后可以更改此值以查看它如何适应不同的大小，但关于这一点稍后再说：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_05_PE.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_16_05_PE.png)'
- en: 'Figure 16.5: Setting the preview UI resolution'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：设置预览UI分辨率
- en: You can pan the viewport to navigate the UI by pressing the *mouse wheel button*
    (also known as the *middle button*) and moving the mouse. On a Mac, you can also
    press *Option* *+* *Command* and click and drag any free area of the viewport
    (places without our UI) to do the same.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过按住**鼠标滚轮按钮**（也称为**中间按钮**）并移动鼠标来平移视口以在UI中导航。在Mac上，您还可以按住*Option* *+* *Command*并点击并拖动视口的任何空闲区域（没有我们的UI的地方）来完成相同的操作。
- en: 'You can also use the *mouse scroll wheel* to zoom in and out. Finally, you
    can use the zoom percentage selection at the top-left part of the viewport and
    the **Fit Canvas** button to automatically fit the entire UI in your viewport:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用**鼠标滚轮**来放大和缩小。最后，您可以使用视口左上角的缩放百分比选择和**适应画布**按钮来自动将整个UI适应到您的视口中：
- en: '![](img/B21361_16_06_PE.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_16_06_PE.png]'
- en: 'Figure 16.6: Setting the preview zoom'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：设置预览缩放
- en: 'Now that we know the basics of UI Builder, let’s add our image to the UI:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了UI构建器的基础知识，让我们将我们的图像添加到UI中：
- en: 'Drag the **VisualElement** icon from **Library** at the bottom left to the
    **Hierarchy** section on the left. This will create a basic UI element capable
    of rendering an image and much more:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**VisualElement**图标从底部的**库**拖到左侧的**层次结构**部分。这将创建一个基本的UI元素，能够渲染图像以及更多内容：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_07_PE.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_16_07_PE.png)'
- en: 'Figure 16.7: Creating a visual element'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：创建视觉元素
- en: Select **VisualElement** in **Hierarchy** (under `GameHUD.uxml`) and look at
    the **Inspector** at the right part of the UI Builder window (again, not the regular
    Unity **Inspector** panel) in the **Position** section. Expand it if not already
    expanded (using the arrow on the left).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**VisualElement**（在`GameHUD.uxml`下）并查看UI构建器窗口右侧的**检查器**（再次，不是常规的Unity
    **检查器**面板）中的**位置**部分。如果尚未展开，请展开它（使用左侧的箭头）。
- en: 'Set **Position** to **Absolute** in order to allow us to move our element freely
    around the UI. Later in this chapter, in the *Using relative positions* section,
    we will explain how the **Relative** mode works:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**位置**设置为**绝对**，以便我们可以自由地在UI中移动我们的元素。在本章的*使用相对位置*部分，我们将解释**相对**模式的工作原理：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_16_08_PE.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行的图片，自动生成描述](img/B21361_16_08_PE.png)'
- en: 'Figure 16.8: Setting our UI element to be freely moved around'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：设置我们的UI元素可以自由移动
- en: 'Open the **Size** section, and set **Width** and **Height** to `100` to make
    our UI element have a non-zero size. This way, we can see its area in the viewport:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**大小**部分，将**宽度**和**高度**设置为`100`，使我们的UI元素具有非零大小。这样，我们就可以在视口中看到其区域：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_09_PE.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述，置信度低](img/B21361_16_09_PE.png)'
- en: 'Figure 16.9: Setting our UI element size'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：设置我们的UI元素大小
- en: 'In the **Viewport** pane, you can drag your element around and use the blue
    rectangles in the corners to change its size. Position your element at the top-left
    corner of the UI. If you don’t see your element in the viewport, select it in
    **Hierarchy** (the one for UI Builder):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**视口**面板中，您可以拖动您的元素，并使用角落的蓝色矩形来更改其大小。将您的元素放置在UI的左上角。如果您在视口中看不到您的元素，请在**层次结构**（UI
    Builder的那个）中选择它：
- en: '![](img/B21361_16_10.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_10.png)'
- en: 'Figure 16.10: Moving VisualElement'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：移动VisualElement
- en: 'In order to set an exact position, you can set the **Left** and **Top** values
    of the **Position** section in the **Inspector** to specify the exact *x* and
    *y* coordinates, respectively, expressed in pixels:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了设置精确的位置，您可以将**检查器**中**位置**部分的**左**和**顶**值设置为分别指定精确的*x*和*y*坐标，以像素为单位：
- en: '![](img/B21361_16_11.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_11.png)'
- en: 'Figure 16.11: Setting the position'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：设置位置
- en: In the **Background** section of the **Inspector**, set the **Image** mode to
    **Sprite** using the combo box at the right of the **Image** property. This allows
    us to apply a sprite as the background of our element.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**的**背景**部分，使用**图像**属性右侧的组合框将**图像**模式设置为**精灵**。这允许我们将精灵作为我们元素的背景应用。
- en: 'Drag the sprite asset (the image) of our player avatar we imported in *Chapter
    15*, *Interface Brilliance: Designing a User-Friendly UI*, from the **Project**
    panel to the **Image** property in order to set it. Also, you can use the target
    button (the circle button with the dot in the middle) to select the sprite asset
    from the picker window:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在*第15章*中导入的玩家头像的精灵资产（图像）从**项目**面板拖动到**图像**属性以设置它。您还可以使用目标按钮（中间有点的圆形按钮）从拾取窗口中选择精灵资产：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_12_PE.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述，置信度中等](img/B21361_16_12_PE.png)'
- en: 'Figure 16.12: Setting the Background image of the element'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：设置元素的背景图像
- en: Return to the regular **Game** panel to see the results. If you don’t see a
    change, you can turn off and on the GameObject that renders our UI (the one we
    created with the UI Document).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到常规**游戏**面板查看结果。如果您没有看到变化，您可以关闭并重新打开渲染我们UI（即我们使用UI文档创建的那个）的GameObject。
- en: 'Now that we have created the player avatar, we can create the player health
    bar by doing the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了玩家头像，我们可以通过以下步骤创建玩家生命值条：
- en: Repeat the previous *steps* *1* to *6* to create a new element that will serve
    as the player health bar container. It won’t have an image, as it will just be
    the container for the rest of the elements that will compose the health bar.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复之前的**步骤**1到**6**，创建一个新的元素，该元素将作为玩家生命值条的容器。它将没有图像，因为它只是其他将组成生命值条的元素的容器。
- en: Position it right next to the player avatar, and set a width and height to resemble
    a classic health bar. Remember that you can do this by dragging the image and
    the squares at the corners or through the **Size** and **Position** properties
    as we did before.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在玩家头像旁边，并设置宽度和高度以类似于经典的生命值条。请记住，您可以通过拖动图像和角落的方块或通过**大小**和**位置**属性来完成此操作，就像我们之前做的那样。
- en: 'Drag a new VisualElement to the Hierarchy, as we did in *step 1*, but this
    time, drop it over the element created in *step 1*. This will make this new element
    a child of it, which will make that element’s position and size depend on its
    parent, the same as what happened when we parented Canvas objects in *Chapter
    15*, *Interface Brilliance: Designing a User-Friendly UI*.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动一个新的VisualElement到层次结构中，就像我们在*步骤1*中做的那样，但这次，将其拖放到*步骤1*中创建的元素上。这将使这个新元素成为它的子元素，这将使该元素的位置和大小依赖于其父元素，就像我们在*第15章*，*界面光辉：设计用户友好的UI*中为Canvas对象设置父元素时发生的情况一样。
- en: 'Select the parent VisualElement, and in the **Inspector**, set the **Name**
    property to `PlayerHealth` to easily identify it. Do the same with the child element,
    calling it `Filling`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择父VisualElement，并在**检查器**中设置**名称**属性为`PlayerHealth`以方便识别。对子元素也进行相同的操作，将其命名为`Filling`：
- en: '![A picture containing text, font, screenshot, white  Description automatically
    generated](img/B21361_16_13_PE.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、截图、白色，描述自动生成](img/B21361_16_13_PE.png)'
- en: 'Figure 16.13: Parenting and naming visual elements'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：设置视觉元素的父级和命名
- en: Select the **Filling** element in the **Hierarchy** and look at the **Inspector**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**填充**元素，并查看**检查器**。
- en: 'In the **Background** section, set the **Color** property to red, clicking
    on the color box and using the **Color Picker**. This will fill our UI element
    background with plain red instead of using an image:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**背景**部分，将**颜色**属性设置为红色，点击颜色框并使用**颜色选择器**。这将用纯红色填充我们的UI元素背景，而不是使用图像：
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21361_16_14_PE.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、数字的图片，描述自动生成](img/B21361_16_14_PE.png)'
- en: 'Figure 16.14: Setting a pure red background for our element'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：为我们的元素设置纯红色背景
- en: As usual, set **Position** to **Absolute**, and also the **Left** and **Top**
    properties to `0`. As this is a child of another element, the position will be
    relative to its parent position, so by specifying a **Left** and **Top** value
    of `0`, we are saying that we will be at 0 pixels from the left and top sides
    of our parent. This means that if our parent moves, this child element will move
    along with it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，将**位置**设置为**绝对**，并将**左**和**顶**属性设置为`0`。由于这是一个元素的子元素，位置将相对于其父元素的位置，因此通过指定**左**和**顶**值为`0`，我们表示我们将位于父元素的左侧和顶部0像素处。这意味着如果父元素移动，此子元素将随之一同移动。
- en: 'Set the **Size** **Width** and **Height** to `100`, and change the unit of
    measurement from **px** (pixels) to **%** (percentage) by clicking on the **px**
    button and selecting **%**. This will make the **Filling** element size the same
    as its parent (100 percent of the parent size):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**宽度**和**高度**设置为`100`，并通过点击**px**按钮并选择**%**来更改度量单位。这将使**填充**元素的大小与其父元素相同（父元素大小的100%）：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_15_PE.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，中等置信度](img/B21361_16_15_PE.png)'
- en: 'Figure 16.15: Setting our size as the same size as our parent element'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：将我们的尺寸设置为与父元素相同的尺寸
- en: Add a new **VisualElement** as a child of **PlayerHealth** (a sibling of **Filling**)
    and call it `Border`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的**VisualElement**作为**PlayerHealth**（**填充**的兄弟元素）的子元素添加，并将其命名为`Border`。
- en: Set **Position** and **Size** as we did in *steps* *7* and *8* for the **Filling**
    element, but don’t set the background color.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**填充**元素在*步骤7*和*步骤8*中设置的**位置**和**大小**应用于**填充**元素，但不要设置背景颜色。
- en: Set the **Background** section’s **Image** property to be the same border image
    we used in the previous chapter. Remember to set the **Image** mode to **Sprite**
    instead of **Texture**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**背景**部分的**图像**属性设置为我们在上一章中使用的相同边框图像。请记住将**图像**模式设置为**精灵**而不是**纹理**。
- en: 'Set the **Slice** property in the **Background** section to `15`. This applies
    the nine-slices technique we used in *Chapter 15*, *Interface Brilliance: Designing
    a User-Friendly UI*, to expand an object without stretching it. In this case,
    we are giving the slice a size of 15 pixels from the outer borders of the UI element.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**背景**部分将**切片**属性设置为`15`。这应用了我们在*第15章*，*界面光辉：设计用户友好的UI*中使用的九宫格技术，在不拉伸对象的情况下扩展对象。在这种情况下，我们给切片从UI元素的外边框提供15像素的大小。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_16_PE.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，中等置信度](img/B21361_16_16_PE.png)'
- en: 'Figure 16.16: Setting the nine-slice sizes in the element directly'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.16：在元素中直接设置九宫格大小
- en: 'Select the **Filling** visual element in the **Hierarchy** and set its **Size**
    section’s **Width** property to simulate the **Fill Amount** property of the images
    we used in *Chapter 11*, *Captivating Visual Effects: Harnessing Particle Systems
    and VFX Graph*. Later, we will change the size to be directly proportional to
    the player’s health number via code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中选择 **Filling** 视觉元素，并将其 **Size** 部分的 **Width** 属性设置为模拟我们在 *第
    11 章*，*迷人的视觉效果：利用粒子系统和 VFX 图* 中使用的图像的 **Fill Amount** 属性。稍后，我们将通过代码将大小直接与玩家的生命值数字成比例：
- en: '![A picture containing screenshot, design  Description automatically generated](img/B21361_16_17_PE.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图和设计的图片，自动生成描述](img/B21361_16_17_PE.png)'
- en: 'Figure 16.17: Health bar result'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.17：生命条结果
- en: Repeat *steps* *1* to *12* to create the bottom of the **Base Health** bar.
    Remember that the filling must be green this time. Alternatively, you can just
    copy and paste the **PlayerHealth** container, but I recommend you repeat the
    steps for learning purposes.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤* *1* 到 *12* 来创建 **Base Health** 条的底部。记住，这次填充必须是绿色的。或者，你也可以直接复制和粘贴 **PlayerHealth**
    容器，但我建议你为了学习目的重复这些步骤。
- en: In previous steps, we basically saw how to compose several UI elements to create
    a complex object. We needed a parent container element to drive the size of our
    children so that the inner elements adapt to it, especially the filling, which
    requires a percentage value to represent the current player’s health.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤中，我们基本上看到了如何组合几个 UI 元素来创建一个复杂对象。我们需要一个父容器元素来驱动我们子元素的大小，以便内部元素适应它，特别是填充，它需要一个百分比值来表示当前玩家的生命值。
- en: Now, we have our life bar! Well, not quite yet; those red corners from the filling
    that our border doesn’t cover are pretty rough! We will improve that later in
    this chapter when discussing how to make our UI responsive, so for now, let’s
    keep it as is.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了生命条！嗯，还不完全是这样；那些填充中未被边框覆盖的红角看起来相当粗糙！我们将在本章后面讨论如何使我们的 UI 响应时改进这一点，所以现在让我们保持原样。
- en: 'Finally, let’s add text elements to the UI. But first, we will need to think
    about fonts. If you download a TTF font, you will need to create a font asset,
    as we did in *Chapter 15*, *Interface Brilliance: Designing a User-Friendly UI*,
    for it to be used in UI Toolkit. However, with the current release of UI Toolkit,
    the font asset we created in the last chapter is not compatible.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们向 UI 添加文本元素。但首先，我们需要考虑字体。如果你下载了 TTF 字体，你需要创建一个字体资产，就像我们在 *第 15 章*，*界面辉煌：设计用户友好的
    UI* 中所做的那样，以便在 UI Toolkit 中使用。然而，根据 UI Toolkit 的当前版本，我们在上一章中创建的字体资产不兼容。
- en: We will need to create a font asset using the UI Toolkit Font Asset Creator
    instead of the TextMesh Pro one. The reason behind the existence of duplicated
    tools is that Unity is integrating the Text Mesh Pro package into a new, improved
    one called TextCore, one of those improvements being compatibility with UI Toolkit
    and other Unity systems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 UI Toolkit 字体资产创建器而不是 TextMesh Pro 创建器来创建字体资产。存在重复工具的原因是 Unity 正在将 Text
    Mesh Pro 包集成到一个新的、改进的包中，称为 TextCore，其中一项改进是与 UI Toolkit 和其他 Unity 系统的兼容性。
- en: Considering this, in order to convert the TTF to a font asset compatible with
    UI Toolkit, you can just right-click the TTF asset in the **Project** panel and
    select **Create** | **Text** | **Font Asset**. This will create a new asset that
    will be the one we will use to define the font of our UI Toolkit text.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，为了将 TTF 转换为与 UI Toolkit 兼容的字体资产，你只需在 **Project** 面板中右键单击 TTF 资产，然后选择
    **Create** | **Text** | **Font Asset**。这将创建一个新的资产，我们将使用它来定义 UI Toolkit 文本的字体。
- en: 'Having solved this, let’s create the UI element for text, that is, **Label**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个问题后，让我们创建文本 UI 元素，即 **Label**：
- en: Drag the **Label** icon from the **Library** pane of the UI Builder window to
    its **Hierarchy** panel. This will add a UI element capable of rendering not only
    an image in its background but also text (yes, you can add a background to the
    text if you want to).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 UI Builder 窗口的 **Library** 面板中的 **Label** 图标拖动到其 **Hierarchy** 面板。这将添加一个 UI
    元素，它不仅能够在其背景中渲染图像，还可以显示文本（是的，如果你想的话，你还可以为文本添加背景）。
- en: As usual, set its **Position** and **Size**, this time putting it in the top-right
    corner of the screen. Remember, you can simply drag the element; you don’t need
    to set the specific coordinates by hand (although you can if you want to).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，设置其 **位置** 和 **大小**，这次将其放置在屏幕的右上角。记住，你可以简单地拖动元素；你不需要手动设置特定的坐标（尽管如果你愿意，你也可以这样做）。
- en: 'Change the **Text** property in the **Label** section of the **Inspector**
    to the needed text; in our case, this will be `Score: 0`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Inspector** 中 **标签** 部分的 **文本** 属性更改为所需的文本；在我们的例子中，这将变为 `得分：0`：
- en: '![](img/B21361_16_18.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_18.png)'
- en: 'Figure 16.18: Setting the text to display'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18：设置要显示的文本
- en: Drag the **Font** asset created just before these steps to the **Font Asset**
    property in the **Text** section of the **Inspector**. Don’t confuse it with the
    **Font** property (the one above **Font Asset**). That one allows you to drag
    TTF assets directly, but that will be deprecated soon, so let’s stick with the
    Unity-recommended approach.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些步骤之前创建的 **字体** 资产拖动到 **Inspector** 中 **文本** 部分的 **字体资产** 属性。不要将其与 **字体**
    属性（位于 **字体资产** 上方）混淆。那个属性允许你直接拖动 TTF 资产，但这个功能很快就会被弃用，所以让我们坚持使用 Unity 推荐的方法。
- en: If you notice that your **Font** asset doesn’t work, try putting it in the **UI
    Toolkit** | **Resources** | **Fonts & Materials** folder in the **Project** panel.
    While this shouldn’t be necessary in the latest Unity versions, I’ve noticed that
    this has solved these sorts of issues in the past. Also, there’s a bug that makes
    the font not recognized sometimes, which can be fixed by deleting and recreating
    the **Label**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注意到你的 **字体** 资产不起作用，请尝试将其放入 **UI Toolkit** | **资源** | **字体与材质** 文件夹中的 **项目**
    面板。虽然这不应该在最新的 Unity 版本中是必要的，但我注意到这过去已经解决了这类问题。此外，还有一个错误有时会导致字体无法识别，可以通过删除并重新创建
    **标签** 来修复。
- en: 'Set the **Size** property of the **Text** section to any size that seems appropriate:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **文本** 部分的 **大小** 属性设置为任何看起来合适的大小：
- en: '![](img/B21361_16_19.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_19.png)'
- en: 'Figure 16.19: Setting the Text Font and Size of a label'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.19：设置标签的文本字体和大小
- en: Repeat *steps* *1* to *6* to add all the remaining **labels** to the UI.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤* *1* 到 *6* 以将所有剩余的 **标签** 添加到 UI 中。
- en: One last thing we need to do is save, which can be simply done by pressing *Ctrl*
    *+* *S* (*Command* *+* *S* on a Mac) or using the **File** | **Save** menu in
    the top-left part of the **Viewport** section in the **UI Builder** window. Note
    that previous versions of UI Toolkit had a bug where this could make the viewport
    corrupt. Please close it and reopen UI Builder again if this happens.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的一件事是保存，这可以通过按 *Ctrl* *+* *S* （在 Mac 上为 *Command* *+* *S*）或使用 **UI Builder**
    窗口 **视口** 部分的右上角 **文件** | **保存** 菜单来完成。请注意，UI Toolkit 的早期版本中有一个错误，这可能会使视口损坏。如果发生这种情况，请关闭它并重新打开
    UI Builder。
- en: Now that we have created our UI, you probably noticed the need to repeat several
    settings to make several objects look the same, like our health bars and labels.
    While this is perfectly viable, we could improve our workflow greatly by reusing
    styles, and **Stylesheets** are the exact feature we need to accomplish that,
    so let’s see them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的 UI，你可能已经注意到需要重复设置几个参数来使多个对象看起来相同，比如我们的生命条和标签。虽然这是完全可行的，但通过重用样式，我们可以极大地提高我们的工作流程，而
    **样式表** 正是我们需要完成这一目标的精确功能，所以让我们来看看它们。
- en: Creating UI Stylesheets
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 UI 样式表
- en: 'Imagine you’re designing various game elements, like buttons and menus, that
    all share a common look – the same background, font, size, and borders. This is
    a common scenario in UI design, where consistency is key. When creating the UI
    with uGUI, one way to avoid repeat configurations for each element would be to
    create a Prefab for the button and create instances (and Prefab variants where
    necessary). Unlike uGUI, UI Toolkit doesn’t use GameObjects, so we can’t rely
    on Prefabs for styling. But no worries, we have a powerful alternative: **Stylesheets**.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在设计各种游戏元素，如按钮和菜单，它们都具有相同的样式——相同的背景、字体、大小和边框。这在 UI 设计中是一个常见的场景，其中一致性是关键。当使用
    uGUI 创建 UI 时，避免为每个元素重复配置的一种方法是为按钮创建 Prefab 并创建实例（以及必要时创建 Prefab 变体）。与 uGUI 不同，UI
    Toolkit 不使用 GameObject，因此我们无法依赖 Prefab 进行样式设置。但不用担心，我们有一个强大的替代方案：**样式表**。
- en: '**Stylesheets** are separate assets that contain a series of styling presets
    for our UI elements. We can define a set of styles (for example, background, borders,
    font, size, etc.) and apply those to several elements across different UI elements.
    This way, if we change a style in a Stylesheet asset, all UI elements using that
    style will change in a similar way to how materials work.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式表**是包含一系列针对我们UI元素样式预设的独立资源。我们可以定义一组样式（例如，背景、边框、字体、大小等），并将这些样式应用到不同UI元素中的多个元素上。这样，如果我们更改样式表资源中的样式，使用该样式的所有UI元素将以类似材料工作的方式发生类似变化。'
- en: There are several ways to create styles in a Stylesheet. The selector system
    in Stylesheets works a bit like filters – you set rules to decide which UI elements
    get certain styles, much like CSS in web design. A class is basically a style
    we can apply to any element via its name. For example, we can create a class called
    `Button` and add that class to every button in the UI that we want to have that
    style. Please note that, here, the concept of class doesn’t refer to a programming
    class. A class is a way to label UI elements that must have specific styling.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式表中创建样式有几种方法。样式表的选择器系统有点像过滤器 - 你设置规则来决定哪些UI元素获得某些样式，就像网页设计中的CSS一样。类基本上是我们可以通过其名称应用到任何元素上的样式。例如，我们可以创建一个名为`Button`的类，并将其添加到我们想要应用该样式的UI中的每个按钮上。请注意，在这里，类的概念并不指编程类。类是一种对必须具有特定样式的UI元素进行标记的方式。
- en: 'For advanced tips on USS, please check out this link: [https://docs.unity3d.com/2023.1/Documentation/Manual/UIE-USS.html](https://docs.unity3d.com/2023.1/Documentation/Manual/UIE-USS.html)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于USS的高级技巧，请参阅此链接：[https://docs.unity3d.com/2023.1/Documentation/Manual/UIE-USS.html](https://docs.unity3d.com/2023.1/Documentation/Manual/UIE-USS.html)
- en: 'So, in this case, let’s create a class for all the labels in our UI so that
    the appearance of all of them can be modified by simply changing the style:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，让我们为我们的UI中的所有标签创建一个类，这样只需更改样式，就可以修改所有标签的外观：
- en: 'In the **StyleSheets** panel of **UI Builder**, click Add (**+**) button and
    click **Create New USS** (Unity StyleSheet). If that doesn’t work, try restarting
    Unity; there’s a bug in the current version of UI Toolkit that could cause this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**UI Builder**的**样式表**面板中，点击**添加（+**）按钮，然后点击**创建新USS**（Unity StyleSheet）。如果不起作用，请尝试重新启动Unity；当前版本的UI
    Toolkit中存在一个可能导致此问题的错误：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_20_PE.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由低置信度自动生成](img/B21361_16_20_PE.png)'
- en: 'Figure 16.20: Creating a Unity StyleSheet'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20：创建Unity样式表
- en: Name the USS as you like (`GameUSS` in my case) and save the file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的喜好命名USS（例如，我的情况是`GameUSS`）并保存文件。
- en: Select one of the label elements we have in our UI Document and look at the
    **Inspector**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的UI文档中选择一个标签元素，并查看**检查器**。
- en: In the **StyleSheet** pane of the **Inspector**, type `HUDText` in the **Style
    Class List** input field, but don’t press *Enter* yet.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**的**样式表**面板中，在**样式类列表**输入字段中输入`HUDText`，但不要按*Enter*键。
- en: 'Click the **Extract Inlined Styles to New Class** button. This will take all
    the style modifications we applied to our label (position, size, font, etc.) and
    save them into a new style class called `HUDText`. You can observe that it was
    added to the list of classes applied to the element (those labels at the bottom
    of the **StyleSheet** section in the **Inspector**):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**将内联样式提取到新类**按钮。这将把我们应用到标签（位置、大小、字体等）的所有样式修改保存到一个名为`HUDText`的新样式类中。您可以观察到它被添加到应用到元素的类列表中（那些在**检查器**中**样式表**部分底部的标签）：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_21_PE.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由低置信度自动生成](img/B21361_16_21_PE.png)'
- en: 'Figure 16.21: Extracting settings into a style class'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21：将设置提取到样式类中
- en: With these steps, we have taken a label with the style we need to apply to others
    and extracted it into a class named **HUDText**. This way, we can simply add the
    **HUDText** class to other elements in our UI, and we can even add the same USS
    asset to other UI Documents (click the **+** button on the **StyleSheets** pane
    | **Add Existing USS**) to add this class to the elements in it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们已经将需要应用到其他元素上的样式标签提取到一个名为**HUDText**的类中。这样，我们只需将**HUDText**类添加到UI中的其他元素，甚至可以将相同的USS资源添加到其他UI文档中（在**样式表**面板的**+**按钮上点击
    | **添加现有USS**）以将此类添加到其中的元素。
- en: Also, if you select the label again, you will notice how properties that previously
    were in bold have now become normal again; that’s because properties in bold represent
    changed properties, and we have extracted them, so the default values became whatever
    the style classes define. Luckily, not everything is extracted to the new USS
    class; for example, the **Text** field still has our specific desired text, as
    it is highly unlikely you would want to put the same text in other objects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你再次选择标签，你会注意到之前加粗的属性现在又变回了正常；这是因为加粗的属性代表已更改的属性，我们已经提取了它们，所以默认值变成了样式类定义的值。幸运的是，并不是所有内容都被提取到新的USS类中；例如，**Text**字段仍然有我们特定的所需文本，因为你不太可能想要在其他对象中放入相同的文本。
- en: '![](img/B21361_16_22_PE.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_22_PE.png)'
- en: 'Figure 16.22: The Text property is bold, indicating it is different from the
    default values. On the other hand, Enable Rich Text is not bold, meaning it follows
    the default values and the class’s ones'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22：文本属性加粗，表示它与默认值不同。另一方面，启用富文本没有加粗，意味着它遵循默认值和类的值
- en: If you miss a style detail while extracting the class, don’t worry. You can
    easily adjust it afterward by selecting the class in the **StyleSheets** section
    and making your edits. Then, select the **HUDText** class in the list. If you
    don’t see it, try expanding the **GameUSS.uss** section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提取类时遗漏了样式细节，不要担心。你可以轻松地在之后通过在**StyleSheets**部分选择类并做出编辑来调整它。然后，在列表中选择**HUDText**类。如果你看不到它，尝试展开**GameUSS.uss**部分。
- en: 'Once selected, you can change it in the **Inspector** panel, similar to when
    we change the properties of a UI element:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选中，你可以在**Inspector**面板中修改它，类似于我们更改UI元素的属性：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_16_23_PE.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图  描述自动生成，置信度低](img/B21361_16_23_PE.png)'
- en: 'Figure 16.23: Selecting a style class for modification'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23：选择要修改的样式类
- en: 'This way, we have edited our `HUDText` class. If other elements had this class
    applied, they would also have these changes applied. Consider that another option
    would be to create the class first, typing the name in the **StyleSheets** input
    field, pressing *Enter*, and then applying it to UI elements. This way, you will
    avoid needing to revert to unwanted changes, but if you created the element first,
    it’s convenient to have the option to revert:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就编辑了我们的`HUDText`类。如果其他元素应用了此类，它们也会应用这些更改。考虑另一种选择是首先创建类，在**StyleSheets**输入字段中键入名称，按*Enter*键，然后将它应用到UI元素上。这样，你将避免需要撤销不希望的变化，但如果首先创建了元素，那么有撤销选项会方便一些：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_24_PE.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_16_24_PE.png)'
- en: 'Figure 16.24: Creating a style class from scratch'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24：从头创建样式类
- en: 'Now that we have our style class, let’s apply it to other elements by doing
    the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的样式类，让我们通过以下步骤将其应用到其他元素上：
- en: Select another label of our UI.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的UI中的另一个标签。
- en: 'Drag the **HUDText** style from the **Stylesheet** pane at the top-left part
    of the UI Builder window all the way to our element in the viewport. You can also
    drag it to the **Hierarchy** element if you prefer:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**HUDText**样式从UI Builder窗口左上角的**Stylesheet**面板拖动到视口中的我们的元素上。你也可以选择将其拖动到**Hierarchy**元素上：
- en: '![A screen shot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_25_PE.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_16_25_PE.png)'
- en: 'Figure 16.25: Applying a class to an element'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25：将类应用于元素
- en: Select the **Label**, and check how the **HUDText** class has been added to
    the **StyleSheet** section of the **Inspector**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Label**，查看**HUDText**类是如何添加到**Inspector**的**StyleSheet**部分的。
- en: Now, note that even if the element now has the class applied, the element itself
    has the changes to the text we made in the previous steps, overriding the style
    in our class. You can easily check this by selecting the class again (in the **StyleSheets**
    section at the top-left part of the **UI Builder** window), changing any setting,
    like the size, and seeing how not all the elements have changed. This shows how
    the override system works; the changes on the element take precedence over the
    ones in the classes it has applied.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，即使元素现在应用了类，元素本身也有我们在上一步中做的文本更改，覆盖了类中的样式。你可以通过再次选择类（在**样式表**部分，位于**UI
    Builder**窗口的左上角）来轻松检查这一点，更改任何设置，如大小，然后看看不是所有元素都发生了变化。这显示了覆盖系统的工作原理；元素上的更改优先于它所应用的类中的更改。
- en: If you want to remove these overrides, you can simply select the element (not
    the class), right-click on the overridden properties, and unset the changes by
    right-clicking and then selecting **Unset**. In the case of our label, we can
    unset the entire **Text** section and probably the **Absolute** position (as the
    desired values are already contained in the class).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想移除这些覆盖，你可以简单地选择元素（不是类），在覆盖的属性上右键单击，并通过右键单击然后选择**取消设置**来撤销更改。在我们的标签情况下，我们可以取消整个**文本**部分的设置，以及可能取消**绝对**位置（因为期望的值已经包含在类中）。
- en: '![](img/B21361_16_26.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_26.png)'
- en: 'Figure 16.26: Reverting an override to use the default values of the classes
    applied to the element'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26：撤销覆盖以使用应用于元素的类的默认值
- en: So, with these steps, we created a new **StyleSheet** asset and added it to
    the UI Document for it to use. We have created a new style class in it, extracting
    the changes of an existing UI element from it, and then adjusted which changes
    we wanted to keep. Finally, we applied that style to another element. With this,
    we just scratched the surface of the real power of StyleSheets. We can start doing
    things like combining different classes from different StyleSheets or using selectors
    to dynamically set styles, but that’s outside the scope of this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这些步骤，我们创建了一个新的**样式表**资产，并将其添加到UI文档中以便使用。我们在其中创建了一个新的样式类，从中提取了现有UI元素的更改，然后调整了我们想要保留的更改。最后，我们将该样式应用于另一个元素。通过这种方式，我们只是触及了StyleSheets真正力量的表面。我们可以开始做一些事情，比如从不同的样式表中组合不同的类，或者使用选择器动态设置样式，但这超出了本章的范围。
- en: While UI Toolkit’s documentation is still evolving, you can get a jump start
    on these advanced concepts by delving into CSS literature. The fundamentals and
    best practices of CSS offer valuable insights applicable to UI Toolkit. It won’t
    be exactly the same, but the basic idea and best practices still apply.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UI Toolkit的文档仍在不断发展，但你可以通过深入研究CSS文献来提前掌握这些高级概念。CSS的基本原理和最佳实践为UI Toolkit提供了有价值的见解。它不会完全相同，但基本思想和最佳实践仍然适用。
- en: 'Now, the UI looks almost exactly the same as it does in *Chapter 15*, *Interface
    Brilliance: Designing a User-Friendly UI*, but it won’t behave in the same way.
    If you try changing the size of the viewport (by selecting **GameHUD.uxml** in
    the Hierarchy and changing **Width** and **Height** as we did at the beginning
    of the chapter), you will see that the UI won’t adapt properly, so let’s fix this.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，UI看起来几乎与*第15章*中的样子完全相同，*界面辉煌：设计用户友好的UI*，但它不会以相同的方式表现。如果你尝试更改视口的大小（通过在层次结构中选择**GameHUD.uxml**并更改**宽度**和**高度**，就像我们在本章开头所做的那样），你会看到UI不会正确适应，所以让我们修复这个问题。
- en: Making a responsive UI
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作响应式UI
- en: 'In this section, we are going to learn how to make the UI we created previously
    adapt to different screen sizes. We are going to discuss the following concepts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使之前创建的UI适应不同的屏幕尺寸。我们将讨论以下概念：
- en: Dynamic positioning and sizing
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态定位和大小
- en: Dynamic scaling
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态缩放
- en: Using relative positions
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相对位置
- en: Let’s start by discussing how we can make the position and size of our objects
    adapt to the screen size.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何使我们的对象的位置和大小适应屏幕尺寸。
- en: Dynamic positioning and sizing
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态定位和大小
- en: So far, we have used the **Left** and **Top** position attributes in order to
    specify the *x* and *y* positions of our elements, with respect to the top-left
    corner of the screen, and then **Width** and **Height** to define the size. While,
    essentially, that’s all that’s needed to define an object’s position and size,
    it is not very useful in all cases, especially when we need to adapt to different
    screen sizes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 **Left** 和 **Top** 位置属性来指定元素相对于屏幕左上角的 *x* 和 *y* 位置，然后使用 **Width**
    和 **Height** 来定义大小。虽然本质上，这已经足够定义一个对象的位置和大小，但在所有情况下都很有用，尤其是在我们需要适应不同屏幕大小的情况下。
- en: For example, if you need to place an object in the top-right corner of the screen,
    knowing its size is `100x100` pixels and the screen size is `1920x1080` pixels,
    we can put the **Left** and **Right** position attributes as `1820x980` pixels,
    and this will work, but only for that specific resolution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要将一个对象放置在屏幕的右上角，知道其大小为 `100x100` 像素，而屏幕大小为 `1920x1080` 像素，我们可以将 **Left**
    和 **Right** 位置属性设置为 `1820x980` 像素，这样会有效，但仅适用于该特定分辨率。
- en: So, what happens if the user runs the game at `1280x720` pixels? The object
    will be outside the screen. In uGUI, we used anchors to solve this issue, but
    we don’t have them here. Luckily, we have **Right** and **Bottom** to help.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果用户以 `1280x720` 像素运行游戏会发生什么？对象将超出屏幕。在 uGUI 中，我们使用了锚点来解决这个问题，但这里我们没有。幸运的是，我们有
    **Right** 和 **Bottom** 来帮助。
- en: 'Like the **Left** and **Top** attributes, **Right** and **Bottom** define distances
    from the parent element’s sides (if there is no parent, then just from the entire
    screen). Right now, we have both set to **auto**, meaning that the position will
    be driven by **Left** and **Right** exclusively, but interesting things can happen
    by changing those values, so let’s use them to make our **Score** and **Bullet**
    labels stick to the top-right corner of the screen instead by doing the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **Left** 和 **Top** 属性类似，**Right** 和 **Bottom** 定义了从父元素边界的距离（如果没有父元素，则直接从整个屏幕）。目前，这两个都设置为
    **auto**，意味着位置将由 **Left** 和 **Right** 独立驱动，但通过改变这些值可以发生有趣的事情，所以让我们通过以下方式使用它们，使我们的
    **Score** 和 **Bullet** 标签粘附到屏幕的右上角：
- en: Put the cursor in the bottom part of the UI in the viewport until a white bar
    appears.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移至视口 UI 的底部，直到出现一个白色条。
- en: Drag that bar to resize the screen, and see how our UI adapts (or not) to the
    different size.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动那个条来调整屏幕大小，并查看我们的 UI 如何适应（或不适应）不同的大小。
- en: 'Do the same on the laterals to also see how it adapts to different screen widths:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边也做同样的操作，看看它如何适应不同的屏幕宽度：
- en: '![](img/B21361_16_27.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_27.png)'
- en: 'Figure 16.27: UI not adapting to different screen sizes'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.27：UI 无法适应不同的屏幕大小
- en: Select the score label on the viewport and look at the **Inspector**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中选择 **Score** 标签，并查看 **Inspector**。
- en: Set the **Top** and **Right** values in the **Position** section to `30`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Position** 部分将 **Top** 和 **Right** 的值设置为 `30`。
- en: 'Set the **Left** and **Bottom** values to **auto** by clicking the **px** button
    at the right of each attribute and selecting **auto**:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击每个属性右侧的 **px** 按钮并将 **Left** 和 **Bottom** 的值设置为 **auto**：
- en: '![](img/B21361_16_28.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_28.png)'
- en: 'Figure 16.28: Changing the unit type of the Position attributes to auto mode'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.28：将位置属性的单元类型更改为自动模式
- en: 'Notice the **Right** and **Top** golden-colored squares at the sides of the
    label became filled, while the **Left** and **Bottom** squares are hollow. This
    means that the **Left** and **Bottom** squares are in **auto** mode. You can also
    toggle **auto** mode by clicking those boxes if needed:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意标签两侧的 **Right** 和 **Top** 金色方块已填充，而 **Left** 和 **Bottom** 方块是空心的。这意味着 **Left**
    和 **Bottom** 方块处于 **auto** 模式。如果需要，您也可以通过点击这些方块来切换 **auto** 模式：
- en: '![](img/B21361_16_29.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_29.png)'
- en: 'Figure 16.29: Toggling auto mode of our element position attributes'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.29：切换元素位置属性自动模式
- en: Try changing the size of the UI container again, as we did in *steps* *1* and
    *2*, to see how our **Score** label is always aligned to the top-right corner.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次更改 UI 容器的尺寸，就像我们在 *步骤* *1* 和 *2* 中做的那样，看看我们的 **Score** 标签是如何始终对齐到右上角的。
- en: Repeat *steps* *4* to *6* for the **Bullets** label, this time setting the **Top**
    property to `140`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤* *4* 到 *6* 为 **Bullets** 标签，这次将 **Top** 属性设置为 `140`。
- en: What we did with these steps was essentially make the position of the object
    expressed as a distance in pixels against the **Top** and **Right** sides of the
    UI or the top-right corner of the screen. We needed to set the other sides to
    **auto** mode so that they wouldn’t participate in the position calculations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过这些步骤所做的实际上是使对象的位置以像素为单位相对于UI的**Top**和**Right**边或屏幕的右上角来表示。我们需要将其他边设置为**自动**模式，这样它们就不会参与位置计算。
- en: Now, we can use the **Position** attributes in other ways as well. As you might
    imagine by now, we can start combining **Left** and **Right** and **Top** and
    **Bottom** if we wish. In such cases, **Left** and **Top** will take precedence
    in defining the position, but then, what do **Right** and **Bottom** do? They
    define the size of the element.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以以其他方式使用**Position**属性。正如你现在可能想象的那样，如果我们愿意，我们可以开始组合**Left**和**Right**以及**Top**和**Bottom**。在这种情况下，**Left**和**Top**将优先定义位置，但然后，**Right**和**Bottom**做什么呢？它们定义元素的大小。
- en: For example, if we have an element with **Left** and **Right** attributes set
    to `100px` each and we see our UI on a screen with a width of `1920` pixels, the
    final width of our element will be `1720` (`1920` minus `100` from **Left** and
    minus `100` from **Right**). This way, the **Position** attributes represent the
    distances of the sides of our element from the sides of the screen (or the parent
    element).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果我们有一个元素，其**Left**和**Right**属性都设置为`100px`，并且我们在一个宽度为`1920`像素的屏幕上查看我们的UI，那么我们元素的最终宽度将是`1720`（从**Left**减去`100`，从**Right**减去`100`）。这样，**Position**属性表示我们的元素边框与屏幕边框（或父元素）的距离。 '
- en: 'Let’s see this in action by making the bottom health bar adapt to the screen
    width while preserving its position relative to the bottom of the screen by doing
    the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来观察其效果，使底部健康条适应屏幕宽度，同时通过以下方式保持其相对于屏幕底部的位置：
- en: Select the bottom health bar parent in the **Hierarchy**. Don’t select it in
    the viewport, as you will only be selecting its filling or border.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择底部健康条的父元素。不要在视图中选择它，因为你只会选择其填充或边框。
- en: Set **Left**, **Right**, and **Bottom** to `50px`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Left**、**Right**和**Bottom**设置为`50px`。
- en: Set **Top** to **auto** (click on the **px** button at the right and select
    **auto**).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Top**设置为**自动**（点击右侧的**px**按钮并选择**自动**）。
- en: In the **Size** section, set **Width** to **auto** also.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Size**部分，也将**Width**设置为**自动**。
- en: 'Set **Height** to `35px`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Height**设置为`35px`：
- en: '![](img/B21361_16_30.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_30.png)'
- en: 'Figure 16.30: Making the player’s base health bar adapt to the screen width'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.30：使玩家的基础生命条适应屏幕宽度
- en: Change the size of the UI to see how it adapts.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变UI的大小以查看其如何适应。
- en: With these steps, we defined the bar distance from the sides of the screen as
    `50` pixels for it to adapt to any screen width while keeping the distance from
    the border and height fixed. We basically achieved the same behavior as split
    anchors in uGUI! Note that we needed to set **Size** **Width** attributes to **auto**
    to let the **Left** and **Right** attributes drive the position; if you don’t
    do that, the **Width** attributes take precedence, and **Right** won’t have any
    effect. I invite you to experiment with other combinations of **px**/**auto**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们定义了条与屏幕边框的距离为`50`像素，以便它适应任何屏幕宽度，同时保持与边框和高度的固定距离。我们基本上实现了与uGUI中的分割锚点相同的行为！请注意，我们需要将**Size**
    **Width**属性设置为**自动**，以便**Left**和**Right**属性驱动位置；如果不这样做，**Width**属性将优先，**Right**将没有任何效果。我邀请您尝试其他**px**/**auto**的组合。
- en: 'One last trick we can do here is to use negative values in the **Left**, **Top**,
    **Right**, and **Bottom** **Position** attributes of the health bar borders to
    make the borders slightly bigger than the container and cover the filling borders.
    Just set **Left**, **Top**, **Right**, and **Bottom** to `-15px` in this case,
    and remember to set both the **Size** **Width** and **Height** attributes to **auto**.
    You might want to reduce the height of the bar container (not the border) a little
    bit, as now it will look thicker due to this change:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以做的最后一个技巧是，在健康条边框的**Left**、**Top**、**Right**和**Bottom** **Position**属性中使用负值，使边框略大于容器并覆盖填充边框。在这种情况下，将**Left**、**Top**、**Right**和**Bottom**设置为`-15px`，并记住将**Size**
    **Width**和**Height**属性设置为**自动**。你可能想稍微降低条容器的宽度（不是边框），因为现在它将因为这种变化而看起来更厚：
- en: '![](img/B21361_16_31.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_31.png)'
- en: 'Figure 16.31: Using negative Position attributes to cover the filling'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.31：使用负的Position属性来覆盖填充
- en: Another mode aside from **px** (pixels) or **auto** mode is the percentual (**%**)
    mode, which allows us to represent values as percentages relative to the screen
    (or parent element if present) size. For example, if we set **Top** and **Bottom**
    to `25%`, this means that our element will be vertically centered with a size
    of 50% of the screen height (remember to set **Height** to **auto** here). We
    could achieve the same result if we set **Top** to `25%`, **Bottom** to **Auto**,
    and **Height** to `50%`; as you can see, we can achieve a clever combination of
    those values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**px**（像素）或**auto**模式之外，还有一种百分比（**%**）模式，它允许我们以相对于屏幕（或如果存在则相对于父元素）的大小表示值。例如，如果我们设置**顶部**和**底部**为`25%`，这意味着我们的元素将在垂直居中，大小为屏幕高度的50%（请记住在此处将**高度**设置为**auto**）。如果我们设置**顶部**为`25%`，**底部**为**Auto**，**高度**为`50%`，我们也可以达到相同的结果；正如你所看到的，我们可以巧妙地组合这些值。
- en: In our case, we will use percentual values in our **Life Bar** fillings so that
    we can express their size in percentages. We need this so, later in the code,
    we can specify the width of the bar as a percentage of the player’s life (for
    example, a player with `25` life points and a max of `100` points has `25%` life).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用百分比值在我们的**生命条**填充中，这样我们就可以用百分比来表示它们的大小。我们需要这样做，以便在代码中稍后可以指定条的宽度为玩家生命值的百分比（例如，一个有`25`生命值和最大`100`点的玩家有`25%`的生命）。
- en: Now, while we solved adapting positioning to the screen size with the usage
    of the **Left**, **Top**, **Right**, and **Bottom** properties, we still didn’t
    solve the dynamic sizing of the elements. With sizing this time, we refer to screens
    with a different number of **DPI** (**dots per inch**), so let’s discuss how we
    can achieve that with the **Panel Settings** asset.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然我们通过使用**左**、**顶**、**右**和**底**属性解决了适应屏幕尺寸的问题，但我们还没有解决元素的动态尺寸问题。这次，我们指的是具有不同**DPI**（**每英寸点数**）的屏幕，因此让我们讨论如何使用**面板设置**资产来实现这一点。
- en: Dynamic scaling
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态缩放
- en: We used `1920x1080` as the UI base resolution to position and size our elements
    so that they look nice in that resolution. While resizing the UI helped us understand
    how elements adapt their position, you might have observed a notable change in
    the size of the elements, appearing larger or smaller. This is an important aspect
    to consider in dynamic UI scaling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`1920x1080`作为UI基本分辨率来定位和调整我们的元素，以便在该分辨率下看起来很漂亮。在调整UI时，我们了解了元素如何适应其位置，你可能已经观察到元素大小发生了显著变化，看起来更大或更小。这是动态UI缩放中需要考虑的重要方面。
- en: While having a base reference resolution is good for designing our UI, we should
    consider the sizing of elements on different resolutions, especially on screens
    with high DPI. Sometimes, you can have screens with higher resolution but the
    same physical size in centimeters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个基本的参考分辨率对于设计我们的UI是有益的，但我们应考虑不同分辨率下元素的大小，尤其是在高DPI的屏幕上。有时，你可能会有分辨率更高但物理尺寸相同的厘米数屏幕。
- en: This means pixels are smaller in the ones with higher resolution; hence, they
    have a larger DPI, so elements can seem smaller if not scaled properly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着高分辨率下的像素更小；因此，它们具有更高的DPI，如果未正确缩放，元素可能会显得更小。
- en: 'Scaling in UI design ensures that your interface looks great on any screen
    size. Previously, in traditional Unity UI, we relied on the Canvas Scaler for
    this. Now, in UI Toolkit, we use a similar approach but through the **Panel Settings**
    asset. Let’s see how this is configured to maintain consistent UI elements across
    different resolutions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI设计中缩放确保你的界面在任何屏幕尺寸上看起来都很棒。以前，在传统的Unity UI中，我们依赖于Canvas Scaler来实现这一点。现在，在UI
    Toolkit中，我们使用类似的方法，但通过**面板设置**资产来实现。让我们看看这是如何配置的，以在不同分辨率之间保持一致的UI元素：
- en: 'Look for the **Panel Settings** asset in the **Project** panel and select it.
    Another option would be to select the `UI Document` GameObject in the Main Editor
    Hierarchy and click the asset referenced in the **Panel Settings** property:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中查找**面板设置**资产并选择它。另一个选项是选择主编辑器层次结构中的`UI Document` GameObject，并点击**面板设置**属性中引用的资产：
- en: '![](img/B21361_16_32_PE.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_32_PE.png)'
- en: 'Figure 16.32: Panel Settings being referenced in the UI Document component'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.32：UI文档组件中引用的面板设置
- en: Set **Scale Mode** to **Scale With Screen Size**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**缩放模式**设置为**随屏幕尺寸缩放**。
- en: Set **Screen Match Mode** to **Match** **Width Or Height**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**屏幕匹配模式**设置为**匹配** **宽度或高度**。
- en: Set the **Reference Resolution X** value to `1920` and the **Y** value to `1080`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**参考分辨率X**值设置为`1920`，将**Y**值设置为`1080`。
- en: 'Move the **Match** slider all the way to the right, toward the end labeled
    **Height**:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**匹配**滑块完全向右移动，直到标记为**高度**的末端：
- en: '![](img/B21361_16_33.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_33.png)'
- en: 'Figure 16.33: Setting the scaling of our UI'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.33：设置我们的UI缩放
- en: Observe how changing the height of the **Game** panel of the Unity Editor will
    make the UI adapt its element sizes accordingly (i.e., change the whole Unity
    Editor window height).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察如何改变Unity编辑器的**游戏**面板的高度，将使UI相应地调整元素大小（即，改变整个Unity编辑器窗口的高度）。
- en: What we did with those changes was first set **Reference Resolution** to whatever
    resolution we designed our UI for – in our case, `1920x1080`. Then, we set **Screen
    Match Mode** to allow us to scale our elements according to one of the sides,
    **Width**, **Height**, or a combination of the two if we prefer. We’re focusing
    on **Height** for scaling, as PCs typically have wider screens. This choice ensures
    that our UI elements maintain their visual consistency across various screen heights.
    This means that on different screen widths, the elements will look the same size,
    but on different heights, the elements will be bigger or smaller.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的这些更改首先是将**参考分辨率**设置为我们的UI设计的分辨率——在我们的案例中，是`1920x1080`。然后，我们将**屏幕匹配模式**设置为允许我们根据一边、**宽度**、**高度**或两者的组合来缩放我们的元素，如果我们更喜欢的话。我们专注于**高度**进行缩放，因为PC通常有更宽的屏幕。这个选择确保了我们的UI元素在各种屏幕高度上保持视觉一致性。这意味着在不同的屏幕宽度上，元素看起来大小相同，但在不同的高度上，元素会更大或更小。
- en: With these settings, we can do some math to understand the values. If our screen
    is the same as the reference resolution (`1920x1080`), the element sizes will
    be the same as we specified in the size of our elements in pixels, so for the
    case of our player avatar, it will be `150x150` pixels. Remember that the physical
    size in centimeters depends on the DPI of the screen.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，我们可以做一些数学计算来理解这些值。如果我们的屏幕与参考分辨率（`1920x1080`）相同，元素大小将与我们在像素大小中指定的元素大小相同，所以对于我们的玩家头像，它将是`150x150`像素。记住，物理大小以厘米为单位取决于屏幕的DPI。
- en: With this understanding of how UI elements scale on a 4K screen, let’s put this
    knowledge into practice. We’ll now adjust our UI settings to effectively accommodate
    such high-resolution displays. Follow along with these steps to see how our UI
    elements respond and adapt to a 4K resolution setup.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对如何在4K屏幕上缩放UI元素的理解，让我们将这一知识付诸实践。现在，我们将调整我们的UI设置以有效地适应这种高分辨率显示器。按照以下步骤操作，看看我们的UI元素如何响应和适应4K分辨率的设置。
- en: Now, imagine that we have a 4K screen, meaning a resolution of `3840x2160`.
    As we specified that our UI matches via **Height**, we can determine that our
    elements will double in size because our screen has a height that is double the
    reference resolution (`2160` divided by `1080`). Our player avatar, at `300x300`
    pixels, will maintain its physical size on a 4K screen; this is achieved by the
    screen’s double size coupled with its double pixel density. Finally, consider
    an ultra-wide standard resolution of `2560×1080` (yes, very wide screens), in
    which case the elements will be the same size, as the only change is the width;
    the only difference is that the elements will have more horizontal separation
    due to the screen size. I know these calculations can be confusing, but keep experimenting
    with the values of the **Panel Settings** and **Game** view sizes to understand
    them better.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个4K屏幕，意味着分辨率为`3840x2160`。因为我们指定我们的UI通过**高度**匹配，我们可以确定我们的元素大小将加倍，因为我们的屏幕高度是参考分辨率的两倍（`2160`除以`1080`）。我们的玩家头像，大小为`300x300`像素，在4K屏幕上将保持其物理大小；这是通过屏幕的双倍大小和双倍像素密度实现的。最后，考虑一个超宽标准分辨率`2560×1080`（是的，非常宽的屏幕），在这种情况下，元素大小将保持不变，因为唯一的变化是宽度；唯一的不同是，由于屏幕尺寸，元素将因屏幕尺寸而具有更多的水平间隔。我知道这些计算可能很复杂，但请继续实验**面板设置**和**游戏**视图大小中的值，以更好地理解它们。
- en: Great, now we really have the same HUD. We could start applying the concepts
    seen so far to the **Options** menu, but let’s take the opportunity to do it in
    a different way, using **relative** **positions**, a way to create a flow of elements
    where the elements’ positions depend on each other.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们真的有了相同的HUD。我们可以开始将迄今为止看到的概念应用到**选项**菜单中，但让我们抓住机会以不同的方式来做，使用**相对**的**位置**，这是一种创建元素流动的方法，其中元素的位置相互依赖。
- en: Using relative positions
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用相对位置
- en: In the HUD of our game, each element requires its own **Position** and **Size**,
    and the different elements’ positions can be resized and repositioned without
    affecting others. We might observe the case of the player health bar and the avatar,
    but the changes would be trivial in this case. There are other cases where this
    is not that trivial, as in the case of a list of elements (for example, a list
    of matches to join in a multiplayer game) that needs to adapt vertically or horizontally,
    and here is where relative positions help us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们游戏的HUD中，每个元素都需要自己的**位置**和**大小**，并且不同元素的位置可以调整大小和重新定位，而不会影响其他元素。我们可能会观察到玩家生命条和角色的例子，但在这个情况下变化将是微不足道的。还有其他情况，这种情况并不那么简单，例如在需要垂直或水平调整的元素列表（例如，在多人游戏中加入的匹配列表）中，这时相对位置就帮到了我们。
- en: Relative positions allow us to make the positions of the elements relative to
    each other; in a way, the position of one element will depend on the position
    of the previous one, and that one to its previous, and so on, forming a chain
    or **flow**. This works like vertical and horizontal layouts on uGUI. In our case,
    we will make the **Pause** label and the **Options** and **Exit** buttons of our
    options menu vertically aligned and centered along their parent using those.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 相对位置允许我们将元素的位置相对于彼此进行调整；从某种意义上说，一个元素的位置将取决于前一个元素的位置，前一个元素的位置又取决于它的前一个元素，以此类推，形成一个链或**流程**。这在uGUI的垂直和水平布局中是类似的。在我们的案例中，我们将使用这些方法使**暂停**标签以及**选项**和**退出**按钮在它们的父元素中垂直居中。
- en: 'Let’s start creating the menu by doing the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建菜单，按照以下步骤操作：
- en: Create a new UI Document (click the **+** button after going to **Project View**
    | **UI Toolkit** | **UI Document**) and call it `OptionsMenu`. We can work on
    the previous UI Document, but let’s keep those pieces of UI separated for easy
    activation and deactivation as well as general asset organization.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的UI Document（在**Project View** | **UI Toolkit** | **UI Document**后点击**+**按钮），并将其命名为`OptionsMenu`。我们可以继续在之前的UI
    Document上工作，但让我们将这些UI组件分开，以便于激活和停用以及一般的资产组织。
- en: Double-click the asset to set it as the current UI being edited by the **UI
    Builder**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击资产以将其设置为当前由**UI Builder**编辑的UI。
- en: Select the root object (**OptionsMenu.uxml** in the **Hierarchy**) and set the
    **Width** and **Height** **Inspector** properties to `1920x1080` pixels.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择根对象（**OptionsMenu.uxml**在**Hierarchy**中）并设置**Inspector**中的**Width**和**Height**属性为`1920x1080`像素。
- en: Create a new GameObject with the **UI Document** component (**GameObject** |
    **UI Toolkit** | **UI Document**) and drag the asset for this object to render
    it (as we did with the HUD created earlier in the chapter).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的具有**UI Document**组件的GameObject（**GameObject** | **UI Toolkit** | **UI
    Document**），并将该对象的资产拖动以渲染它（就像我们在本章早期创建的HUD一样）。
- en: Double-click the **UI Document** asset to open the **UI Builder** window to
    edit it, and in that window, drag a new **VisualElement** to the **Hierarchy**
    or viewport and call it `Container` (the **Name** property in the **Inspector**
    in **UI Builder**).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**UI Document**资产以打开**UI Builder**窗口进行编辑，并在该窗口中，将一个新的**VisualElement**拖动到**Hierarchy**或视图中，并将其命名为`Container`（在**UI
    Builder**的**Inspector**中的**Name**属性）。
- en: Set the **Left**, **Right**, **Top**, and **Right** **Position** attributes
    to `0px`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**左**、**右**、**上**和**右**的**位置**属性设置为`0px`。
- en: Set **Position** to **Absolute**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**位置**设置为**绝对**。
- en: Set **Width** and **Height** in the **Size** section to **auto**. This will
    make the container fit the entire screen.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**大小**部分将**宽度**和**高度**设置为**自动**。这将使容器适应整个屏幕。
- en: Drag a new **VisualElement** to be a child of the container and call it `Background`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的**VisualElement**拖动到容器中作为子元素，并将其命名为`Background`。
- en: Leave **Position** as **Relative** this time.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次将**位置**设置为**相对**。
- en: Set **Size** **Width** and **Height** to `500px`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**大小**的**宽度**和**高度**设置为`500px`。
- en: Set **Background Image** of the **Background** object to use the same background
    sprite used in the previous chapter.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Background**对象的**背景图像**设置为使用上一章中使用的相同的背景精灵。
- en: Select the **Container** parent object (not **Background**).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Container**父对象（不是**Background**）。
- en: In the **Inspector**, set the **Align Items** property of the **Align** section
    to `center`, which is the third button. If you hover the mouse over the icons,
    they will show their names in a tooltip.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**中，将**Align**部分的**Align Items**属性设置为`center`，即第三个按钮。如果将鼠标悬停在图标上，它们将在工具提示中显示其名称。
- en: 'Set **Justify Content** to **Center** (second button):'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Justify Content**设置为**居中**（第二个按钮）：
- en: '![](img/B21361_16_34.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_34.png)'
- en: 'Figure 16.34: Preparing the UI background to host elements inside'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.34：准备 UI 背景以容纳内部元素
- en: Change the size of the UI using the white bars at the sides to see how the background
    is always centered.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用侧面的白色条来更改 UI 的大小，以查看背景始终居中。
- en: With just a single element in place, this is a great chance to observe how relative
    positioning functions in a practical setting. First, we created an empty object
    that will always adapt to the screen size, allowing us to make the children’s
    elements depend on the full-screen size. Then, we created an image element with
    a fixed size but with a relative position, meaning its position will be calculated
    by the parent container. Finally, we told the container to make its child objects
    aligned to its horizontal and vertical center, so the background immediately became
    centered, regardless of the screen size. When working with absolute positions,
    the **Align** properties didn’t work, so this is one of the first benefits of
    relativepositioning.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 只需放置一个元素，这就是观察相对定位在实际环境中如何工作的绝佳机会。首先，我们创建了一个空对象，它将始终适应屏幕大小，使我们能够使子元素依赖于全屏大小。然后，我们创建了一个具有固定大小但具有相对位置的图像元素，这意味着其位置将由父容器计算。最后，我们告诉容器使其子对象与其水平和垂直中心对齐，因此背景立即居中，无论屏幕大小如何。当使用绝对位置时，**Align**
    属性不起作用，因此这是相对定位的第一个好处。
- en: 'But relative positioning becomes more powerful with multiple elements, so let’s
    add the **Label** and buttons to our **Background** element to explore this concept
    further by doing the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但相对定位在多个元素中变得更加强大，因此让我们将 **Label** 和按钮添加到我们的 **Background** 元素中，通过以下方式进一步探索这个概念：
- en: 'From the **Library** pane at the bottom left of **UI Builder**, drag a **Label**
    and two **Button** elements inside **Background** in **Hierarchy**. Note that
    there’s a bug where, sometimes, even if you drag and drop a new element inside
    the desired object, it won’t be its child. Just drag the one created in the Hierarchy
    this time:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **UI Builder** 左下角的 **Library** 面板中，将一个 **Label** 元素和两个 **Button** 元素拖放到 **Hierarchy**
    中的 **Background** 内。请注意，有时即使你将新元素拖放到所需对象内，它也不会成为其子元素。这次请只拖动在 **Hierarchy** 中创建的元素：
- en: '![](img/B21361_16_35_PE.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_35_PE.png)'
- en: 'Figure 16.35: Adding elements inside the menu background'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.35：在菜单背景中添加元素
- en: 'Observe how, by default, the elements became vertically aligned, one on top
    of the other, due to the relative position’s default settings:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察默认情况下，元素如何由于相对位置的默认设置而垂直对齐，一个叠在另一个上面：
- en: '![A close-up of a button  Description automatically generated with low confidence](img/B21361_16_36_PE.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![按钮的特写  描述由低置信度自动生成](img/B21361_16_36_PE.png)'
- en: 'Figure 16.36: Automatic relative vertical positioning'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.36：自动相对垂直定位
- en: Select the **Background** element and set **Justify Content** to `space-around`
    (the fifth button). This will spread the elements along the background.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Background** 元素，并将 **Justify Content** 设置为 `space-around`（第五个按钮）。这将沿背景分布元素。
- en: Set **Align Items** to center (the third option) to center elements horizontally:![A
    screenshot of a computer screen  Description automatically generated with low
    confidence](img/B21361_16_37_PE.png)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Align Items** 设置为居中（第三个选项）以水平居中元素：![计算机屏幕截图  描述由低置信度自动生成](img/B21361_16_37_PE.png)
- en: 'Figure 16.37: Automatic relative vertical positioning'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 16.37：自动相对垂直定位
- en: There is a similar mode for **Justify Content** called space-between (the fourth
    button in **Justify Content**) that will also spread the elements along the vertical
    axis, but it won’t leave space on top of the first element or at the bottom of
    the last one. Also, **Align Items** has an option called **Stretch** (the fifth
    option) that, like **center**, will not only center elements horizontally but
    also stretch them instead of respecting each element’s width. I recommend experimenting
    with the different aligning modes to discover all opportunities.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 **Justify Content** 有一个类似的模式，称为 space-between（**Justify Content** 中的第四个按钮），它也会沿垂直轴分布元素，但不会在第一个元素顶部或最后一个元素底部留下空间。此外，**Align
    Items** 有一个名为 **Stretch**（第五个选项）的选项，与 **center** 类似，它不仅会在水平方向上居中元素，还会拉伸它们而不是尊重每个元素的宽度。我建议尝试不同的对齐模式，以发现所有机会。
- en: Set the **Label** **Text**’s **Font** and **Size** attributes to whatever seems
    fit. In my case, I used the imported font and a size of `60px`. Remember to also
    set **Text** to `Pause`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Label** 的 **Text** 的 **Font** 和 **Size** 属性设置为适合的任何值。在我的情况下，我使用了导入的字体和 `60px`
    的大小。记住也要将 **Text** 设置为 `Pause`。
- en: Set the **Button** **Background Image** to use the same as was used for the
    button in the last chapter.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**按钮****背景图像**设置为与上一章中使用的按钮相同的图像。
- en: Set the **Color** property of the **Background** section to a color with no
    alpha. You can achieve this by clicking the color rectangle and reducing the **A**
    channel in the color picker to `0`. The idea of this color is to act as a background
    for our image, but we don’t need it, so we made it completely transparent.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**背景**部分的**颜色**属性设置为没有alpha的颜色。您可以通过单击颜色矩形并将颜色选择器中的**A**通道减少到`0`来实现这一点。这种颜色的想法是作为我们图像的背景，但我们不需要它，所以我们使其完全透明。
- en: Set the Button **Text** **Font**, **Size**, and **Color** to whatever seems
    fit to you. In my case, I’m using `50` and a gray color.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮**文本****字体**、**大小**和**颜色**设置为适合您的任何内容。在我的情况下，我使用`50`和灰色。
- en: 'In the **Margin and Padding** section, set **Padding** to have some spacing
    between the text and the borders of the button. In my case, `30px` did the trick:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**边距和填充**部分，将**填充**设置为在文本和按钮边框之间留出一些空间。在我的情况下，`30px`就做到了这一点：
- en: '![](img/B21361_16_38.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_38.png)'
- en: 'Figure 16.38: Adding inner padding to the button contents (the text in this
    case)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.38：向按钮内容添加内部填充（在这种情况下是文本）
- en: Also, set the **Top** and **Bottom** **Padding** of **Background** to allow
    some space between the borders of the window and its elements. In my case, it
    is `40px` each.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将**背景**的**顶部**和**底部****填充**设置为在窗口边框和其元素之间留出一些空间。在我的情况下，每个都是`40px`。
- en: As you can see, we changed different settings to set the size of the elements
    dynamically, like font sizes and paddings, and the relative system, along with
    the align settings, took the role of determining the position of the elements
    automatically. We can rearrange the order of the elements by dragging them in
    the Hierarchy, and they will be accommodated automatically. We could have also
    set the size of the elements with the **Size** property, and we can also apply
    some offsets if desired using the **Position** properties, but I encourage you
    to see how these properties behave in **Relative** mode on your own.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们更改了不同的设置来动态设置元素的大小，例如字体大小和填充，以及相对系统，同时对齐设置自动确定元素的位置。我们可以通过在层级中拖动元素来重新排列元素顺序，它们将自动适应。我们也可以使用**大小**属性来设置元素的大小，并且如果需要，可以使用**位置**属性应用一些偏移，但我鼓励您自己查看这些属性在**相对**模式下的行为。
- en: One last setting I want you to explore is the **Direction** attribute of the
    **Flex** section, which, as you can imagine, will determine the orientation the
    elements will follow, vertically from top to bottom or bottom to top and horizontally
    from left to right or right to left. For example, you could set **Direction**
    to distribute the elements from left to right using the **Row** mode (the third
    button) and make the background wider to have a horizontal options menu if you
    wish.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想让您探索的最后一个设置是**Flex**部分的**方向**属性，正如您所想象的，这将确定元素将遵循的定位方向，垂直从上到下或从下到上，以及水平从左到右或从右到左。例如，您可以将**方向**设置为使用**行**模式（第三个按钮）从左到右分配元素，如果您愿意，可以使背景更宽以创建一个水平选项菜单。
- en: '![](img/B21361_16_39.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_16_39.png)'
- en: 'Figure 16.39: Changing to a vertical orientation of elements'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.39：更改元素为垂直方向
- en: As a side note, you might have noticed that the images for the background and
    buttons will look bigger than the options menu created in the last chapter. That’s
    because the **Pixels per Unit** setting that we changed on the **Texture** assets
    to control the scaling of the textures won’t take effect in UI Toolkit; you will
    need to manually change the texture file size in any image editor to give it its
    proper size. The best practice here would be to always create the images with
    a size that will look fine in our maximum supported resolution. Usually, this
    is `1920x1080` on a PC, but note that 4K resolutions are becoming more popular
    every day.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，您可能已经注意到背景和按钮的图像看起来比上一章创建的选项菜单要大。这是因为我们在**纹理**资产上更改的**每单位像素**设置，用于控制纹理的缩放，在UI工具包中不会生效；您需要手动在任何图像编辑器中更改纹理文件大小，以给它适当的大小。这里的最佳实践是始终创建大小适合我们最大支持分辨率的图像。通常，在PC上这是`1920x1080`，但请注意，4K分辨率每天都在变得越来越流行。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we were introduced to the key concepts of UI Toolkit and how
    to create UI Documents and Stylesheets. Regarding UI Documents, we learned how
    to create different elements like images, text, and buttons and how to position
    and size them using different methods, like absolute and relative positioning
    and pixel or percentual units. Also, we saw how to make the UI adapt to different
    sizes using different combinations of **Position** attributes. Finally, we learned
    how to use USS Stylesheets to share styles between different elements to easily
    manage our whole UI skinning.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 UI 工具包的关键概念以及如何创建 UI 文档和样式表。关于 UI 文档，我们学习了如何创建不同的元素，如图片、文本和按钮，以及如何使用不同的方法（如绝对定位和相对定位以及像素或百分比单位）来定位和调整它们的大小。此外，我们还看到了如何使用不同的
    **Position** 属性组合使 UI 适应不同的尺寸。最后，我们学习了如何使用 USS 样式表在不同元素之间共享样式，以便轻松管理整个 UI 皮肤。
- en: 'Essentially, we learned again how to make UIs with a different system. Again,
    please note that this system is still in the experimental phase and is not recommended
    for real production projects. We used all these concepts to recreate the same
    UI created in *Chapter 15*, *Interface Brilliance: Designing a User-Friendly UI*.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们再次学习了如何使用不同的系统来制作 UI。再次提醒，这个系统仍然处于实验阶段，不建议用于实际生产项目。我们使用所有这些概念来重新创建在 *第
    15 章* 中创建的相同 UI，即 *界面辉煌：设计用户友好的 UI*。
- en: In the next chapter, we are going to see how to add animations to our game to
    make our characters move. We will also see how to create cut-scenes and dynamic
    cameras.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何为我们的游戏添加动画，使我们的角色移动。我们还将看到如何创建过场场景和动态摄像机。
- en: Learn more on Discord
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天，等等。扫描二维码或访问链接以加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
