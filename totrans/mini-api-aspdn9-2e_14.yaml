- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Unit Testing, Compatibility, and Deployment of Minimal APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小 API 的单元测试、兼容性和部署
- en: It’s an exciting time when you’re preparing to deploy an application to production.
    Before that can happen, there are many questions to be answered, namely, “Is this
    quality code?”, “Is everything going to work as intended?”, and “Will it be sustainable
    over a long period of time?”.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备将应用程序部署到生产环境时，这是一个令人兴奋的时刻。在那之前，有许多问题需要回答，主要是：“这是高质量的代码吗？”“一切都会按预期工作吗？”“它将在长时间内保持可持续性吗？”
- en: To help set our minimal APIs up for success, testing is required before they
    go into the hands of users or become responsible for any critical business operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们的最小 API 成功，在它们进入用户手中或负责任何关键业务操作之前，需要进行测试。
- en: This statement is *really* obvious. Of course we need to test, but in some cases,
    what is less obvious is *how* we will be testing. Unit and integration testing
    can help us in this area, offering an automated solution to testing our acceptance
    criteria, checking for new bugs introduced by code changes, often referred to
    as **regression** , and giving us (in some IDEs literally) a red or green light
    for deployment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明*非常*明显。当然我们需要测试，但在某些情况下，不那么明显的是*我们将如何测试*。单元和集成测试可以帮助我们在这方面，为我们提供自动化的解决方案来测试我们的验收标准，检查代码更改引入的新错误，通常被称为**回归**，并在某些
    IDE 中（字面上）为我们提供部署的红绿灯。
- en: There is also compatibility to consider before deployment. What operating system
    are we deploying to? What kind of web server will be in use? Are we hosting in
    the cloud or on-premises?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署之前，也需要考虑兼容性问题。我们将部署到哪个操作系统？将使用哪种类型的 Web 服务器？我们是托管在云端还是本地？
- en: Finally, the appropriate method of deployment can be dictated by all of the
    preceding considerations. It seems like a lot, but it will be worth it when we
    inevitably deploy our minimal APIs with confidence that they will bring the intended
    value, and hopefully more.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，适当的部署方法可以由所有前面的考虑因素决定。虽然看起来很多，但当我们不可避免地自信地部署我们的最小 API，并希望它们带来预期的价值，甚至更多时，这一切都是值得的。
- en: 'In this chapter, we will cover the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Unit testing and integration testing for minimal APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小 API 的单元测试和集成测试
- en: Compatibility and migrating minimal APIs to . NET 9
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性和将最小 API 迁移到 .NET 9
- en: Deploying minimal APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署最小 API
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Visual Studio 2022 or the latest version of Visual Studio code is recommended
    in order to run the code from this chapter. The code examples for this chapter
    are available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中的代码，建议使用 Visual Studio 2022 或最新版本的 Visual Studio Code。本章的代码示例可在 GitHub
    仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)。
- en: To follow along with all deployment methods in this chapter, you will need to
    have access to an Azure subscription and be able to install Docker.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中所有部署方法，您需要能够访问 Azure 订阅并安装 Docker。
- en: Unit testing and integration testing for minimal APIs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小 API 的单元测试和集成测试
- en: It’s highly likely that you’ve come across the terms unit testing and integration
    testing, but by way of a refresher, let’s briefly define them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你已经遇到过单元测试和集成测试这两个术语，但为了复习，让我们简要地定义它们。
- en: '**Unit testing** involves testing individual components of functions of a code
    base in isolation, whereas integration testing checks how different components
    of modules of a system interact. In a minimal API, a unit test may simply test
    that a service does what it should, while an integration test would confirm that
    an HTTP request to the endpoint uses the services and other components together
    correctly.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**涉及在隔离状态下测试代码库中函数的各个组件，而集成测试则检查系统模块的不同组件之间的交互。在最小 API 中，单元测试可能只是测试一个服务是否按预期工作，而集成测试将确认对端点的
    HTTP 请求是否正确地一起使用了服务和其它组件。'
- en: In short, you’re either testing a single unit of code, or you’re testing how
    different units interact with each other.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你要么在测试单个代码单元，要么在测试不同的单元如何相互交互。
- en: 'Let’s create a unit test for a service that does something very simple: calculate
    the sum of given numerical values. Here is the service as it looks in **Program.cs**
    , where it is registered for dependency injection and used as part of a POST endpoint:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为执行非常简单的操作的服务创建一个单元测试：计算给定数值的总和。以下是它在 **Program.cs** 中的样子，其中它被注册为依赖注入并用作
    POST 端点的一部分：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are several testing frameworks we can implement, but to keep things simple,
    I’m going to use xUnit:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现几个测试框架，但为了保持简单，我将使用 xUnit：
- en: Right-click your solution in Visual Studio and select **Add** | **New Project…**
    .
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中右键单击您的解决方案，然后选择 **添加** | **新建项目…** 。
- en: '![Figure 14.1: Add a new project from within Solution Explorer](img/B20968_14_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1：在解决方案资源管理器中添加新项目](img/B20968_14_01.jpg)'
- en: 'Figure 14.1: Add a new project from within Solution Explorer'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：在解决方案资源管理器中添加新项目
- en: Then search for **xUnit** (or your preferred testing framework if you don’t
    wish to follow along exactly).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后搜索 **xUnit**（或者如果您不想完全跟随，您首选的测试框架）。
- en: '![Figure 14.2: Creating a new xUnit project](img/B20968_14_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2：创建一个新的 xUnit 项目](img/B20968_14_02.jpg)'
- en: 'Figure 14.2: Creating a new xUnit project'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：创建一个新的 xUnit 项目
- en: If the **Do not use top-level statements** option is shown, I recommend unchecking
    it so that you can clearly see the namespaces you’re using in each class. It is
    a personal preference but it will make it easier for you to follow along with
    this example.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果显示 **不使用顶级语句** 选项，我建议取消选中它，这样您可以清楚地看到每个类中使用的命名空间。这是一个个人偏好，但它会使您更容易跟随这个示例。
- en: '![Figure 14.3: Unchecking the Do not use top-level statements box](img/B20968_14_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3：取消选中“不使用顶级语句”复选框](img/B20968_14_03.jpg)'
- en: 'Figure 14.3: Unchecking the Do not use top-level statements box'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：取消选中“不使用顶级语句”复选框
- en: Once you’ve created your test project within the solution, right-click **Dependencies**
    for the test project and add a project reference to your API project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在解决方案中创建了您的测试项目，右键单击测试项目的 **依赖项**，然后添加对 API 项目的项目引用。
- en: '![Figure 14.4: Adding a reference to another project](img/B20968_14_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4：将引用添加到另一个项目](img/B20968_14_04.jpg)'
- en: 'Figure 14.4: Adding a reference to another project'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.4：将引用添加到另一个项目](img/B20968_14_04.jpg)'
- en: You now have two projects in your solution. One is a minimal API project and
    the other is a testing project linked to the former.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在在解决方案中有两个项目。一个是最小化的 API 项目，另一个是与前者链接的测试项目。
- en: We can now start writing some tests. Let’s start with a simple unit test against
    **CalculatorService**
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写一些测试了。让我们从一个针对 **CalculatorService** 的简单单元测试开始。
- en: 'In our test project, create a new class called **CalculatorTests** . Then,
    update the code so that a method called **Sum_Test()** exists, with an attribute
    above the method signature, **[Fact]** :'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试项目中，创建一个名为 **CalculatorTests** 的新类。然后，更新代码，使得一个名为 **Sum_Test()** 的方法存在，并在方法签名上方有一个属性
    **[Fact]** ：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The **[Fact]** attribute is what xUnit uses to mark a method as a test. I like
    to think of it in the sense that we are stating that the method represents something
    that should be fact; it should be objective. In this case, we want a test that
    proves the fact that the sum of a given collection of integers is equal to the
    value we are expecting it to be. Let’s explore this in more detail by writing
    the test logic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**[Fact]** 属性是 xUnit 用于标记方法为测试的属性。我喜欢这样想：我们是在声明该方法代表的是事实；它应该是客观的。在这种情况下，我们想要一个测试来证明给定整数集合的总和等于我们期望它等于的值。让我们通过编写测试逻辑来更详细地探讨这一点。'
- en: 'In the body of **Sum_Test()** , instantiate a new instance of **CalculatorService**
    and create an array of integers that we can use during our test:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Sum_Test()** 的主体中，实例化一个新的 **CalculatorService** 实例，并创建一个整数数组，我们可以在测试中使用它：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because we kept this simple, it is easy to see at a glance that the expected
    result for the sum of the values in **integers** must be **10** .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们保持了简单性，因此可以一眼看出，**integers** 中值的总和的预期结果必须是 **10** 。
- en: 'Add a call to the **Sum()** function within **CalculatorService** and store
    it in a variable. Also, add a hardcoded variable of **10** for the expected result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **CalculatorService** 中添加对 **Sum()** 函数的调用，并将其存储在一个变量中。同时，添加一个硬编码的变量 **10**
    作为预期结果：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In unit testing, there is a principle known as the *three As* , which stands
    for arrange, act, and assert:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，有一个被称为 *三 A* 原则的原则，代表 arrange（准备）、act（执行）和 assert（断言）：
- en: The first step, arrange, forces us to gather data and resources in a particular
    state so that testing is possible. We have achieved this by creating an instance
    of **CalculatorService** , an array of integers we know should add up to 10, which
    we have also hardcoded into a variable for reference. Finally, we make the call
    to the **Sum()** function to obtain the actual result.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，安排，强迫我们收集数据和资源到特定的状态，以便进行测试。我们通过创建**CalculatorService**的一个实例，一个我们知道应该加起来等于10的整数数组，我们还将它硬编码到一个变量中作为参考，实现了这一点。最后，我们调用**Sum()**函数以获得实际结果。
- en: The second step is act. This simply means that action is taken to enable the
    test to be evaluated. For example, if you’re testing a calculation between two
    integer values, the actual calculation would take place at this point.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是行动。这仅仅意味着采取行动以使测试可以被评估。例如，如果你正在测试两个整数值之间的计算，实际的计算将在这一点上进行。
- en: The final step is assert. An assertion is the test itself. In this, we will
    assert that our **[Fact]** is true. If the assertion is correct, **[Fact]** is
    true and the test will pass. If the assertion is incorrect, the test will fail.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是断言。断言就是测试本身。在这里，我们将断言我们的**[Fact]**是真实的。如果断言是正确的，**[Fact]**就是真实的，测试将通过。如果断言是错误的，测试将失败。
- en: Different testing frameworks have their own implementation of an assertion,
    but the principle remains the same. In xUnit, a static class, **Assert** , holds
    various types of assertions that can be used during testing. For example, an assertion
    that something is null or not null is represented via **Assert.Null()** and **Assert.NotNull()**
    , respectively. Likewise, we can assert that a statement is true with **Assert.True()**
    .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的测试框架都有自己的断言实现，但原则是相同的。在xUnit中，一个静态类**Assert**包含各种类型的断言，可以在测试期间使用。例如，一个断言某物为null或非null是通过**Assert.Null()**和**Assert.NotNull()**分别表示的。同样，我们可以使用**Assert.True()**来断言一个语句为真。
- en: 'We want to assert that the expected result of **Sum()** is equal to the actual
    result. For this, we can use **Assert.Equal()** :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要断言**Sum()**的预期结果与实际结果相等。为此，我们可以使用**Assert.Equal()**：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running this test is as simple as right-clicking the method signature and selecting
    **Run Tests** . The test will run, and the test result will be shown by Visual
    Studio in Test Explorer. You should see a green circle next to the test to indicate
    success.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试就像在方法签名上右键单击并选择**运行测试**一样简单。测试将运行，并且测试结果将通过Visual Studio在测试资源管理器中显示。你应该在测试旁边看到一个绿色圆圈，表示成功。
- en: '![Figure 14.5: The Test Explorer screen, showing available tests and their
    results](img/B20968_14_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5：测试资源管理器屏幕，显示可用的测试及其结果](img/B20968_14_05.jpg)'
- en: 'Figure 14.5: The Test Explorer screen, showing available tests and their results'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：测试资源管理器屏幕，显示可用的测试及其结果
- en: A similar approach to writing tests can be taken for integration tests, the
    main difference being the scope of the test. For this example, a minimal API,
    a simple integration test’s scope could cover a whole endpoint. Let’s put this
    into practice by writing an integration test for the **/sumintegers** API endpoint
    that checks the resulting status code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试，可以采用与编写测试类似的方法，主要区别在于测试的作用域。在这个例子中，一个最小API，一个简单的集成测试的作用域可以覆盖整个端点。让我们通过编写一个针对**/sumintegers**
    API端点的集成测试来检查结果状态码，将其付诸实践。
- en: To run this test, we will need to be able to access an **HttpClient** object
    and run **WebApplication** in the test project, because the test needs to make
    a request against an endpoint. To make this possible, you can make your test class
    implement **IClassFixture** of type **WebApplicationFactory** .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此测试，我们需要能够访问**HttpClient**对象并在测试项目中运行**WebApplication**，因为测试需要针对端点发出请求。为此，你可以让你的测试类实现**WebApplicationFactory**类型的**IClassFixture**。
- en: IClassFixture usage in a test class
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类中使用IClassFixture
- en: '**IClassFixture** is an interface that allows objects to share scope across
    a class. In this case, we want to share the scope of a **WebApplicationFactory**
    object so that an **HttpClient** instance can be created for tests within the
    class.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**IClassFixture**是一个接口，允许对象在类级别上共享作用域。在这种情况下，我们想要共享**WebApplicationFactory**对象的作用域，以便在类内部为测试创建**HttpClient**实例。'
- en: 'Because **WebApplicationFactory** needs **Microsoft.AspNetCore.Mvc.Testing**
    to be installed, use the NuGet package manager console to install this package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为**WebApplicationFactory**需要安装**Microsoft.AspNetCore.Mvc.Testing**，所以使用NuGet包管理器控制台安装此包：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Update the **CalculatorTests** class so that it implements **IClassFixture**
    :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更新**CalculatorTests**类，使其实现**IClassFixture**：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will require you to add a constructor for the class, in which you can
    inject **WebApplicationFactory** . You can also use this **WebApplicationFactory**
    to create a new **HttpClient** for use during tests. Let’s store this in a **readonly**
    field so that we can keep things clean by not reinitializing it after the constructor
    has run:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要你为类添加一个构造函数，在其中你可以注入**WebApplicationFactory**。你还可以使用这个**WebApplicationFactory**在测试期间创建一个新的**HttpClient**。让我们将其存储在一个**readonly**字段中，这样我们就可以通过在构造函数运行后不重新初始化它来保持事物的整洁：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can write our tests. Let’s *arrange* our test data by creating
    the required parameters as an array of integers and then serializing them to a
    JSON string so that they can be added to the body of the request:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写我们的测试。让我们通过创建一个整数数组作为所需的参数并序列化为JSON字符串来*安排*测试数据，以便它们可以添加到请求体中：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we can *act* by making the POST request to the target endpoint:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过向目标端点发送POST请求来*执行*操作：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we can *assert* that the response code is the one we were expecting,
    in this case, **200 OK** :'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以*断言*响应代码是我们预期的，在这种情况下，**200 OK**：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You could also assert that the result is the expected one by checking the response
    content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过检查响应内容来断言结果是预期的：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This integration test may look pretty similar to the original unit test we wrote
    earlier in this chapter, but it differs in the sense that it has a wider scope.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集成测试可能看起来与我们在本章早期编写的原始单元测试非常相似，但它有所不同，因为它具有更广泛的范围。
- en: By calling this test, we not only make a request to the target endpoint, but
    we also cover the testing of the encapsulated **CalculatorService** .
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用这个测试，我们不仅向目标端点发送请求，还覆盖了对封装的**CalculatorService**的测试。
- en: In both of these examples, integration and unit testing were conducted on pre-existing
    logic. If we were to adopt **Test-Driven Development** ( **TDD** ), we would augment
    our practices by writing the tests before any logic. Obviously, we expect the
    tests to fail initially, but our goal is to write code that allows the tests to
    pass. Assuming your tests make the same assertions as your acceptance criteria
    from an API requirements perspective, TDD is widely considered the optimal way
    to apply automated testing to a code base.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，对现有的逻辑进行了集成和单元测试。如果我们采用**测试驱动开发**（**TDD**），我们会在任何逻辑之前编写测试来增强我们的实践。显然，我们预计测试最初会失败，但我们的目标是编写允许测试通过的代码。假设你的测试与API需求方面的验收标准具有相同的断言，TDD通常被认为是将自动化测试应用于代码库的最佳方式。
- en: TDD or not, however you approach unit and integration testing, having test coverage
    will help to increase the quality of your minimal API code, and hopefully reduce
    the number of reported bugs post-release.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是TDD还是其他方式，在单元和集成测试中，拥有测试覆盖率将有助于提高你的最小API代码质量，并有望减少发布后报告的bug数量。
- en: 'When it comes to the quality and stability of an API, testing the code’s logic
    is one aspect; but before moving to deployment, there is another aspect to be
    considered: that of compatibility. Let’s explore compatibility, with a particular
    focus on the latest version of .NET at the time of writing – . NET 9.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到API的质量和稳定性时，测试代码的逻辑是一个方面；但在迁移到部署之前，还有一个方面需要考虑：兼容性。让我们探讨兼容性，特别是关注撰写本书时的最新.NET版本——.NET
    9。
- en: Compatibility and migrating minimal APIs to .NET 9
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兼容性和将最小API迁移到.NET 9
- en: Let’s assume that you have already created a minimal API project, but the .NET
    version is not the latest. You wish to deploy the API, but before you do so, you
    intend to bring the code base to the latest .NET version, which at the time of
    writing this book is 9. What factors do we need to consider to be confident that
    our application will run efficiently on this new version, and how can we migrate
    to it?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经创建了一个最小化的API项目，但.NET版本不是最新的。你希望部署API，但在这样做之前，你打算将代码库升级到最新的.NET版本，在撰写本书时是9.我们需要考虑哪些因素才能有信心确保我们的应用程序在新版本上运行高效，以及我们如何迁移到它？
- en: Before any .NET migration, it is critical that you consult Microsoft’s documentation,
    where any known breaking changes are outlined.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何.NET迁移之前，咨询微软的文档至关重要，其中概述了任何已知的破坏性更改。
- en: '.NET breaking changes fall into three categories:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .NET破坏性更改分为三类：
- en: '**Binary incompatible** : Existing binaries may fail to load and may need to
    be recompiled.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制不兼容**：现有的二进制文件可能无法加载，可能需要重新编译。'
- en: '**Source incompatible** : Code may require change in order to compile.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源不兼容**：代码可能需要更改才能编译。'
- en: '**Behavioral change** : Code and binaries may behave differently after update,
    meaning code changes would be required.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为变化**：更新后，代码和二进制文件可能表现不同，这意味着需要代码更改。'
- en: While Microsoft is usually pretty effective in avoiding major breaking changes,
    checking the documentation at [https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0](https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0)
    ahead of time will provide valuable insight into any potential issues you may
    face. On top of this, if a breaking change does find its way into the minimal
    API post-update, unit and integration tests will increase the chances of the breaking
    changes being caught.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微软通常在避免重大破坏性变化方面相当有效，但在更新之前查看[https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0](https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0)的文档将为你提供关于可能遇到的问题的宝贵见解。除此之外，如果破坏性变化确实出现在最小API更新后，单元和集成测试将增加发现破坏性变化的机会。
- en: Microsoft outlines breaking changes for different areas of .NET. For minimal
    APIs, you will be most concerned with changes in the area of ASP.NET, but ensure
    you review other areas, such as core .NET libraries, deployment, networking, SDK,
    MSBuild, and serialization, as these are secondary areas that are all relevant
    to minimal APIs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微软概述了.NET不同领域的破坏性变化。对于最小API，你将最关注ASP.NET领域的更改，但确保你审查其他领域，例如核心.NET库、部署、网络、SDK、MSBuild和序列化，因为这些是所有与最小API相关的次要领域。
- en: 'At the time of writing, there are only two breaking changes outlined in ASP.NET
    for .NET 9, which are summarized here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，ASP.NET为.NET 9概述了两个破坏性变化，这里简要总结如下：
- en: '**DefaultKeyResolution.ShouldGenerateNewKey** : There is a different meaning
    behind Boolean (true/false) result returned in previous versions. This breaking
    change is caused by a redefinition of the **true/false** result returned by **ShouldGenerateNewKey**
    . Let’s delve into this in more detail:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefaultKeyResolution.ShouldGenerateNewKey**：在先前版本中返回的布尔值（true/false）结果背后有不同的含义。这种破坏性变化是由**ShouldGenerateNewKey**返回的**true/false**结果的重定义引起的。让我们更详细地探讨这个问题：'
- en: When managing keys in your minimal API, if you’re using ASP.NET’s default implementation
    to generate the key, there is a Boolean that is provided to tell you whether a
    new key should be generated.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在最小API中管理密钥时，如果你使用ASP.NET的默认实现来生成密钥，会提供一个布尔值来告诉你是否应该生成新的密钥。
- en: Previously, the result of the Boolean was produced based on whether the default
    key was within two days of expiration.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前，布尔值的结果是基于默认密钥是否在到期前两天。
- en: It was decided that “within two days” of expiration was not appropriate on its
    own, as there are other factors that could influence whether the key should be
    regenerated. Now, the result of **ShouldGenerateNewKey** is based on several factors
    related to **IdefaultKeyResolver** as well as whether or not a default key exists
    in the first place, rather than an arbitrary meaning based on whether the key
    is two days away from expiry.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定“在到期前两天”本身并不合适，因为还有其他因素可能会影响是否需要重新生成密钥。现在，**ShouldGenerateNewKey**的结果基于与**IdefaultKeyResolver**相关的几个因素，以及是否最初存在默认密钥，而不是基于密钥是否在到期前两天的一个任意含义。
- en: 'When a minimal API application starts, you can specify in **UseDefaultServiceProvider**
    whether validation should be run on registered services and service scopes. Previously,
    validation was always turned off by default. Let’s break down this change a little
    further to see whether it affects your existing code:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个最小化API应用程序启动时，你可以在**UseDefaultServiceProvider**中指定是否应该在注册的服务和服务作用域上运行验证。之前，验证默认是关闭的。让我们进一步分析这个变化，看看它是否会影响你的现有代码：
- en: The validation of services ensures that all services can be created at startup.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的验证确保所有服务都可以在启动时创建。
- en: The validation of scopes checks that scoped services are not resolved from the
    root provider, which would violate their scope.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域的验证检查作用域服务是否不是从根提供程序解析的，这会违反其作用域。
- en: Overall, this meant that no validation was performed by default. You had to
    turn on the previous validation for it to be executed when the application is
    loaded. However, validation is now performed by default.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的来说，这意味着默认情况下没有进行验证。你必须打开之前的验证才能在应用程序加载时执行它。然而，现在默认情况下会执行验证。
- en: Based on this, there are no major breaking changes when moving a minimal API
    to .NET 9 (at least where ASP.NET Core is concerned). However, it is still important
    to be prepared for any potential change. With that in mind, how would we mitigate
    these changes?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，将最小化API迁移到.NET 9时没有重大破坏性变化（至少在ASP.NET Core方面是这样）。然而，仍然重要的是要为任何潜在的变化做好准备。考虑到这一点，我们如何减轻这些变化？
- en: For **DefaultKeyResolution.ShouldGenerateNewKey** affecting key resolution,
    you only really need to act if you have written logic that is now redundant thanks
    to the way .NET 9 checks for an expired key.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于影响密钥解析的**DefaultKeyResolution.ShouldGenerateNewKey**，你只有在已经编写了现在由于.NET 9检查过期密钥的方式而变得冗余的逻辑时才真正需要采取行动。
- en: For example, if previously you were checking that a default key exists, you
    no longer need to do this, because .NET 9 does this for you. The impact of this
    change is therefore fairly minimal.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果之前你需要检查是否存在默认密钥，现在你不再需要这样做，因为.NET 9会为你完成这项工作。因此，这种变化的冲击力相对较小。
- en: For **UseDefaultServiceProvider** , the required changes are simple. If by updating
    your minimal API to .NET 9 you start to see errors on startup owing to the fact
    that validation of services and scope is now enabled by default, you must address
    the outputted validation errors.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**UseDefaultServiceProvider**，所需更改很简单。如果你通过将你的最小化API更新到.NET 9开始看到启动时的错误，这可能是由于服务验证和作用域现在默认启用，你必须解决输出的验证错误。
- en: For most basic scenarios, it is unlikely that your minimal API is configured
    in such a way that services could not be resolved or scoped services are being
    incorrectly resolved from the root provider, but it is still important to be aware
    of these factors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数基本场景，你的最小化API不太可能配置得无法解析服务或从根提供程序中错误地解析作用域服务，但仍然重要的是要意识到这些因素。
- en: Accuracy at the time of writing and other affected areas of .NET
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编写时的准确性和.NET的其他受影响区域
- en: It is important to emphasize that these changes were reported before the release
    of .NET 9, during its preview. Developers must consult Microsoft’s documentation
    before any migration to see whether any further breaking changes have been reported.
    Moreover, the summary provided in this book is only targeting ASP.NET Core, which
    is the main area we are concerned with when writing minimal APIs. However, other
    areas mentioned, such as the .NET SDK, networking, and serialization, could all
    affect minimal API projects depending on the use case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，这些变化是在.NET 9发布前，在其预览期间报告的。在迁移之前，开发者必须查阅微软的文档，以查看是否还有进一步的破坏性变化被报告。此外，本书中提供的摘要仅针对ASP.NET
    Core，这是我们编写最小化API时主要关注的领域。然而，提到的其他区域，如.NET SDK、网络和序列化，都可能根据用例影响最小化API项目。
- en: Now that we’ve explored the potential compatibility issues we face when publishing
    a minimal API application to .NET 9, let’s look at the various methods of deployment
    we have at our disposal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了将最小化API应用程序发布到.NET 9时可能遇到的兼容性问题，让我们来看看我们可用的各种部署方法。
- en: Deploying minimal APIs
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署最小化API
- en: There are many different ways to deploy a minimal API project, and exploring
    them all would be way out of the scope of this book. However, we can look at some
    of the most common deployment targets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 部署最小化API项目有众多不同的方式，探索所有这些方式超出了本书的范围。然而，我们可以查看一些最常见的部署目标。
- en: Deploying to Microsoft Azure App Service (cloud deployment)
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用部署到微软Azure App Service（云部署）
- en: Deploying to Azure App Service is very straightforward and can be achieved using
    a publish profile in Visual Studio. A publish profile is a configuration object
    that specifies how a project should be deployed. It contains metadata about the
    type of runtime in play, the target architecture (x86, ARM, etc.), and the target
    host, which in this example will be Azure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用部署到Azure App Service非常简单，可以使用Visual Studio中的发布配置文件来实现。发布配置文件是一个配置对象，它指定了项目应该如何部署。它包含有关正在运行的运行时类型、目标架构（x86、ARM等）和目标主机（在这个例子中是Azure）的元数据。
- en: For the purposes of this example, I’m assuming that an Azure App Service instance
    exists in your Azure subscription, to which you are allowed to deploy. If an App
    Service instance does not exist in Azure, you will need to create one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我假设你的Azure订阅中已经存在一个Azure App Service实例，并且你有权部署。如果Azure中没有App Service实例，你需要创建一个。
- en: The pricing for Azure app services can be calculated via Microsoft’s pricing
    calculator at https://azure.microsoft.com/en-gb/pricing/calculator/. At the time
    of writing, there is a free tier that allows for basic testing which will probably
    be suitable for most people reading this book to practice their deployment. A
    basic tier app service currently costs approx $55-60 per month, but this can increase
    depending on the use case and the required specification.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 应用服务的定价可以通过 Microsoft 的定价计算器在 https://azure.microsoft.com/en-gb/pricing/calculator/
    计算得出。在撰写本文时，有一个免费层允许进行基本测试，这可能适合本书的大多数读者进行部署练习。基本层应用服务的当前费用约为每月 55-60 美元，但根据用例和所需规格，费用可能会增加。
- en: 'The creation of an App Service instance is out of the scope of this book:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 App Service 实例超出了本书的范围：
- en: 'First, right-click on the project you wish to deploy in **Solution Explorer**
    in Visual Studio and then click **Publish…** :'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Visual Studio 的 **解决方案资源管理器** 中右键单击您要部署的项目，然后点击 **发布…**：
- en: '![Figure 14.6: Publishing from Solution Explorer in Visual Studio](img/B20968_14_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6：在 Visual Studio 的解决方案资源管理器中发布](img/B20968_14_06.jpg)'
- en: 'Figure 14.6: Publishing from Solution Explorer in Visual Studio'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：在 Visual Studio 的解决方案资源管理器中发布
- en: If you don’t have any publish profiles already set up, you will see the **Publish**
    dialog. If you don’t see this, it’s because you do already have a publish profile
    for another deployment. You can select **Add a publish profile** to open the **Publish**
    dialog if this is the case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未设置任何发布配置文件，您将看到 **发布** 对话框。如果您没有看到这个对话框，那是因为您已经为另一个部署设置了发布配置文件。如果这种情况发生，您可以选择
    **添加发布配置文件** 来打开 **发布** 对话框。
- en: 'Once you see the **Publish** dialog, select **Azure** :'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您看到 **发布** 对话框，请选择 **Azure**：
- en: '![Figure 14.7: Selecting a publish target in Visual Studio](img/B20968_14_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7：在 Visual Studio 中选择发布目标](img/B20968_14_07.jpg)'
- en: 'Figure 14.7: Selecting a publish target in Visual Studio'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：在 Visual Studio 中选择发布目标
- en: Then select **Azure App Service** , ensuring that you select the correct operating
    system running on the target App Service in Azure (Windows or Linux).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择 **Azure App Service**，确保您选择了在 Azure 目标 App Service 上运行的正确操作系统（Windows 或
    Linux）。
- en: The next screen will then request that you choose your Azure subscription. If
    you’re not already logged in to Azure, you can connect using the option at the
    top right of the dialog.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个屏幕将要求您选择您的 Azure 订阅。如果您尚未登录 Azure，可以使用对话框右上角的选项进行连接。
- en: 'Once connected, you should see your Azure subscription in the dropdown, along
    with the available App Service instances to deploy to. Select the service you
    wish to target and click **Next** :'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接成功后，您应该在下拉菜单中看到您的 Azure 订阅，以及可部署到的可用 App Service 实例。选择您希望针对的服务，然后点击 **下一步**：
- en: '![Figure 14.8: Choosing the target Azure App Service resource](img/B20968_14_08.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8：选择目标 Azure App Service 资源](img/B20968_14_08.jpg)'
- en: 'Figure 14.8: Choosing the target Azure App Service resource'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：选择目标 Azure App Service 资源
- en: Finally, you will be asked whether you wish to publish using a **.pubxml** file
    or via GitHub Actions. We won’t be covering continuous integration/continuous
    delivery pipelines such as GitHub Actions in this book, so select **Publish**
    .
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，系统会询问您是否希望使用 **.pubxml** 文件或通过 GitHub Actions 进行发布。本书不会涵盖像 GitHub Actions
    这样的持续集成/持续交付管道，因此请选择 **发布**。
- en: '![Figure 14.9: Choosing the publish output type](img/B20968_14_09.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9：选择发布输出类型](img/B20968_14_09.jpg)'
- en: 'Figure 14.9: Choosing the publish output type'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：选择发布输出类型
- en: Once this is complete, the dialog will close and your new publish profile is
    created. From there you can see and change the publish settings, such as what
    configuration you will be publishing (almost always **Release** ), the framework
    which in our example is .NET9, the deployment mode, which is either **Framework
    - dependent** or **Self - contained** (More on that below) and the target runtime
    which in my example is **64bit Linux** .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，对话框将关闭，并创建新的发布配置文件。从那里，您可以查看和更改发布设置，例如您将发布什么配置（几乎总是 **发布**），框架（在我们的示例中是
    .NET9），部署模式，是 **框架依赖** 还是 **自包含**（关于这一点将在下面详细介绍），以及目标运行时，在我的示例中是 **64位 Linux**。
- en: '![Figure 14.10: The newly created publish profile](img/B20968_14_10.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10：新创建的发布配置文件](img/B20968_14_10.jpg)'
- en: 'Figure 14.10: The newly created publish profile'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：新创建的发布配置文件
- en: Do this and your application will be built before being deployed to the target
    App Service. Once completed, Visual Studio will automatically open a browser window
    and navigate to the minimal API’s URL.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，你的应用程序将在部署到目标 App Service 之前构建。完成后，Visual Studio 将自动打开浏览器窗口并导航到最小 API
    的 URL。
- en: Framework-dependent versus self-contained deployment modes
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 框架依赖与自包含部署模式
- en: You have two choices of deployment mode. **Framework-dependent** requires that
    .NET 9 (or whichever version you are using) is installed on the target machine.
    **Self-contained** will package the runtime with the application. The former produces
    a smaller set of output files but has the drawback of requiring the specific .NET
    version to be installed on the target machine, whereas the latter has a larger
    output but has fewer prerequisites for the target machine for the application
    to run, making it more portable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种部署模式选择。**框架依赖**要求在目标机器上安装 .NET 9（或你正在使用的任何版本）。**自包含**将运行时与应用程序打包在一起。前者生成更小的输出文件集，但缺点是需要在目标机器上安装特定的
    .NET 版本，而后者输出文件更大，但目标机器对应用程序运行的要求更少，使其更便携。
- en: Next, let’s move on to deploying to a Docker container.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续部署到 Docker 容器。
- en: Deploying to a Docker container
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 Docker 容器
- en: ASP.NET and .NET Core are already well positioned to offer cross-platform functionality,
    but there are still subtle differences in configuration depending on the host
    operating system. Containerizing your minimal API application with Docker can
    make it agnostic, meaning that it doesn’t care what operating system it’s running
    on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 和 .NET Core 已经很好地定位了提供跨平台功能，但根据主机操作系统，配置上仍有细微的差异。使用 Docker 容器化你的最小 API
    应用程序可以使它变得无差别，这意味着它不关心它在哪个操作系统上运行。
- en: Firstly, you must ensure that Docker is installed on your system. Documentation
    outlining this is available at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    . For Windows, you will need to install Docker Desktop, documentation for which
    can be found here at [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)
    , whereas for Linux, simply running Docker Engine should suffice.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须确保 Docker 已安装在你的系统上。有关此内容的文档可在[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)找到。对于
    Windows，你需要安装 Docker Desktop，相关文档可在此处找到[https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)，而对于
    Linux，只需运行 Docker Engine 就足够了。
- en: Once you have completed the install, you need to create a Dockerfile, which
    will describe how your minimal API project should be packaged into a Docker container
    as well as how it should run on the host machine.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你需要创建一个 Dockerfile，该文件将描述你的最小 API 项目应该如何打包到 Docker 容器中，以及它应该如何在主机机器上运行。
- en: 'You can create this file within your project as a new item in Visual Studio:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Visual Studio 中创建此文件，作为项目中的新项目：
- en: 'Select the button at the top left of **Solution Explorer** to change the view:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **解决方案资源管理器**左上角的按钮以更改视图：
- en: '![Figure 14.11: Changing view options in Solution Explorer](img/B20968_14_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11：在解决方案资源管理器中更改视图选项](img/B20968_14_11.jpg)'
- en: 'Figure 14.11: Changing view options in Solution Explorer'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：在解决方案资源管理器中更改视图选项
- en: 'Select **Folder View** :'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件夹视图**：
- en: '![Figure 14.12: Switching to Folder View](img/B20968_14_12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12：切换到文件夹视图](img/B20968_14_12.jpg)'
- en: 'Figure 14.12: Switching to Folder View'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：切换到文件夹视图
- en: Then, right-click your project folder and select **Add** | **New File** .
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击你的项目文件夹，选择 **添加** | **新建文件**。
- en: '![Figure 14.13: Creating a new file in the project within Folder View](img/B20968_14_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13：在文件夹视图中创建项目中的新文件](img/B20968_14_13.jpg)'
- en: 'Figure 14.13: Creating a new file in the project within Folder View'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：在文件夹视图中创建项目中的新文件
- en: A Docker file has no name, just an extension of **.dockerfile** . Create this
    file. It should then open as a tab in Visual Studio. (There are reports of issues
    with Docker files not working unless they are called **Dockerfile** , so you can
    try this if you are having similar issues.)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 文件没有名称，只有一个 **.dockerfile** 扩展名。创建此文件。然后它应该作为选项卡在 Visual Studio 中打开。（有报道称，如果
    Docker 文件不命名为 **Dockerfile**，则可能无法正常工作，所以如果你遇到类似问题，可以尝试这样做。）
- en: Now we can write the Docker file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写 Docker 文件。
- en: 'First, we need to specify a base image to be used for the runtime environment
    of the minimal API application. We can pull the official .NET 9 ASP.NET runtime
    image from Microsoft’s container registry like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指定用于最小 API 应用程序运行时环境的基本镜像。我们可以像这样从微软的容器注册库拉取官方 .NET 9 ASP.NET 运行时镜像：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can tell Docker that we want to set the working directory inside the
    container to **/app** , so that any subsequent commands will be executed relative
    to this directory. We will also specify that we wish to expose port **80** on
    the container:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以告诉 Docker 我们想要将容器内的工作目录设置为**/app**，这样任何后续命令都将相对于此目录执行。我们还将指定我们希望容器上暴露端口**80**：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we add a section that downloads the .NET 9 SDK, which will be required
    as the full runtime necessary for compiling the minimal API application. We then
    set the working directory again, this time to a folder of our choice; we’ll choose
    **/src** .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个部分，下载所需的 .NET 9 SDK，这是编译最小 API 应用程序所需的全局运行时。然后我们再次设置工作目录，这次选择一个我们选择的文件夹；我们将选择**/src**。
- en: 'Following this, the entire content of the current directory is copied into
    the **/src** directory inside the container so that it can be built, **dotnet
    restore** is executed to add any NuGet packages required as dependencies, and
    the app is compiled in release mode to the **/** **app** folder:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当前目录的整个内容被复制到容器内的**/src**目录中，以便进行构建，执行**dotnet restore**以添加所需的任何 NuGet 包作为依赖项，并将应用程序以发布模式编译到**/**
    **app**文件夹中：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point in the execution, the container will have been built. Finally,
    we can add a section to the Docker file that runs the built container by copying
    the container assemblies and running from the DLL output by .NET after compilation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行的这个阶段，容器已经被构建。最后，我们可以在 Dockerfile 中添加一个部分，通过复制容器组件并在编译后的 .NET 生成的 DLL 上运行来运行构建的容器：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So far, we have specified how the image for the container should be built,
    but we haven’t yet triggered the build. To do this, open a terminal or command
    prompt window running from your project directory and run the following command,
    replacing **MYAPINAME** with a suitable image name:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经指定了容器镜像应该如何构建，但我们还没有触发构建。为此，打开从您的项目目录运行的控制台或命令提示符窗口，并运行以下命令，将**MYAPINAME**替换为合适的镜像名称：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this command, we are creating a tag for the image being built with the given
    name, and then we use **.** to indicate that the build context for the image is
    the current directory where the Docker file is located.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们正在为正在构建的镜像创建一个带有给定名称的标签，然后我们使用**.**来表示镜像的构建上下文是 Dockerfile 所在的当前目录。
- en: 'Once built, you can run the container to start the app, which should be available
    to receive requests on a port of your choosing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，您可以运行容器以启动应用程序，该应用程序应该可以在您选择的端口上接收请求：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this command, we have told Docker Engine to run the container with **-d**
    (detached mode), which allows it to run in the background. We then used **-p**
    to specify that port **80** on the container should be mapped to port **8080**
    on the host machine. This means your minimal API will be available at **http://localhost:8080**
    .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们已告诉 Docker 引擎以**-d**（分离模式）运行容器，这允许它在后台运行。然后我们使用**-p**指定容器上的端口**80**应映射到主机机器上的端口**8080**。这意味着您的最小API将在**http://localhost:8080**上可用。
- en: 'Finally, there is one other method you can use that is extremely simple: deploying
    to the built-in Kestrel web server.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一种非常简单的方法可以使用：部署到内置的 Kestrel 网络服务器。
- en: Deploying on-premises with Kestrel
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kestrel 在本地部署
- en: If you simply want to host your minimal API as an ASP.NET Core application on
    a Windows machine, you can create a new publish profile and then follow the publish
    profile wizard in Visual Studio outlined earlier in this chapter. However, instead
    of choosing Azure as the target, choose **Folder** .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想在 Windows 机器上将您的最小 API 作为 ASP.NET Core 应用程序托管，您可以创建一个新的发布配置文件，然后按照本章前面概述的
    Visual Studio 中的发布配置文件向导进行操作。然而，不要选择 Azure 作为目标，而是选择**文件夹**。
- en: '![Figure 14.14: Choosing Folder as the publish target](img/B20968_14_14.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图14.14：选择文件夹作为发布目标](img/B20968_14_14.jpg)'
- en: 'Figure 14.14: Choosing Folder as the publish target'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：选择文件夹作为发布目标
- en: On selection, the wizard will ask you to specify a target folder to deploy to.
    This folder can be local, or it can be a network path on a remote server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选择后，向导将要求您指定要部署到的目标文件夹。这个文件夹可以是本地的，也可以是远程服务器上的网络路径。
- en: Once published, the resulting **.EXE** file can be double-clicked and the application
    will run using the Kestrel web server, which listens on port **5000** by default.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布，生成的**.EXE**文件可以双击运行，应用程序将使用默认监听端口**5000**的Kestrel网络服务器运行。
- en: 'If you wish to change the port, you can do so via the **appsettings.json**
    file in your project by adding the following (e.g., change to port **8080** ):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更改端口，您可以通过项目中的**appsettings.json**文件进行更改，添加以下内容（例如，更改为端口**8080**）：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve explored a high-level overview of how we can prepare our minimal APIs
    for their inevitable deployment and consumption by end users. Now, we’re nearing
    the end of our journey. Let’s summarize what we’ve learned in this final chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何为我们的最小API准备部署和最终用户消费的高级概述。现在，我们即将结束这次旅程。让我们总结一下在本章中我们学到了什么。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve navigated through the crucial steps required to prepare
    minimal APIs for production, focusing on testing, compatibility with .NET 9, and
    deployment strategies. Each of these aspects plays a pivotal role in ensuring
    that your APIs are robust, compatible, and seamlessly delivered to end users.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了准备最小API投入生产所需的必要步骤，重点关注测试、与.NET 9的兼容性和部署策略。这些方面的每一个都在确保您的API健壮、兼容并无缝交付给最终用户中发挥着关键作用。
- en: We explored unit testing, which isolates and validates individual components,
    and integration testing, which ensures that different parts of the system work
    together correctly. Through practical examples with xUnit, we demonstrated how
    to set up and execute these tests to validate functionality and performance. The
    key takeaway is that thorough testing—whether through unit tests or integration
    tests—helps catch potential issues early, reducing the likelihood of bugs slipping
    into production and ensuring that your API meets its acceptance criteria.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了单元测试，它隔离和验证单个组件，以及集成测试，它确保系统的不同部分能正确协同工作。通过xUnit的实际示例，我们展示了如何设置和执行这些测试以验证功能和性能。关键要点是，彻底的测试——无论是通过单元测试还是集成测试——都有助于早期发现潜在问题，降低错误滑入生产的可能性，并确保您的API满足其验收标准。
- en: Compatibility with .NET 9 is crucial for maintaining the longevity and efficiency
    of your minimal APIs. We discussed the importance of understanding breaking changes
    and adapting your code base accordingly. By keeping abreast of Microsoft’s documentation
    on .NET 9 changes, and leveraging unit and integration tests, you can mitigate
    the impact of any breaking changes. This proactive approach ensures that your
    APIs continue to function correctly with the latest .NET version and provides
    a smoother transition during migrations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET 9的兼容性对于保持最小API的长期性和效率至关重要。我们讨论了理解破坏性变化并相应调整代码库的重要性。通过关注Microsoft关于.NET
    9变化的文档，并利用单元和集成测试，您可以减轻任何破坏性变化的影响。这种主动方法确保您的API能够与最新的.NET版本正确运行，并在迁移期间提供更平滑的过渡。
- en: Deployment encompasses several methods tailored to different environments and
    needs. We covered deployment to Microsoft Azure App Service, which offers a straightforward,
    scalable solution for cloud environments. We also explored containerization with
    Docker, providing a portable, cross-platform deployment option. For on-premises
    deployments, running minimal APIs directly with Kestrel offers a simple and effective
    approach. Each deployment method has its own set of configurations and considerations,
    such as choosing between framework-dependent and self-contained deployments or
    managing container ports and environment settings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 部署包括针对不同环境和需求定制的方法。我们介绍了部署到Microsoft Azure App Service，它为云环境提供了一个简单、可扩展的解决方案。我们还探讨了使用Docker的容器化，提供了一种便携、跨平台的部署选项。对于本地部署，直接使用Kestrel运行最小API提供了一种简单有效的方法。每种部署方法都有自己的配置和考虑因素，例如在框架依赖和自包含部署之间进行选择，或管理容器端口和环境设置。
- en: Ensuring that your minimal APIs are well tested, compatible with the latest
    .NET versions, and deployed using the most suitable method empowers you to deliver
    high-quality, reliable software. By applying the practices outlined in this chapter,
    you set a solid foundation for successful deployment and long-term maintenance
    of your APIs, contributing to both immediate operational success and future scalability.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的最小API经过良好的测试，与最新的.NET版本兼容，并使用最合适的方法部署，这将使你能够交付高质量、可靠的软件。通过应用本章中概述的实践，你为API的成功部署和长期维护奠定了坚实的基础，这有助于即时的运营成功和未来的可扩展性。
- en: We’re now at the end of our minimal API journey, and as the book ends, I hope
    you’ve gained a solid understanding of how to create minimal APIs in various use
    cases and that you’ve found the experience enjoyable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了最小API之旅的终点，随着本书的结束，我希望你已经对如何在各种用例中创建最小API有了坚实的理解，并且你发现这个过程是愉快的。
- en: The book has been a joy for me to write as someone who is passionate about the
    use of minimal APIs in varying use cases and contexts. APIs are critical to nearly
    all modern software systems, and I think a good knowledge of minimal APIs and
    their advantages will give any .NET developer an edge in their programming career.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个热衷于在不同用例和环境中使用最小API的人来说，写作这本书是一种乐趣。API对于几乎所有现代软件系统都至关重要，我认为对最小API及其优势的良好了解将使任何.NET开发者在他们的编程生涯中占据优势。
- en: Thanks for reading. Now go and build some more minimal APIs!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。现在去构建更多最小API吧！
