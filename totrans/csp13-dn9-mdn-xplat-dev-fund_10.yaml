- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Working with Data Using Entity Framework Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core处理数据
- en: This chapter is about reading from and writing to relational data stores, such
    as SQLite and SQL Server, by using the object-to-data store mapping technology
    named **Entity Framework Core** (**EF Core**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何通过使用名为**Entity Framework Core**（**EF Core**）的对象到数据存储映射技术，从关系型数据存储（如SQLite和SQL
    Server）中读取和写入数据。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding modern databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现代数据库
- en: Setting up EF Core in a .NET project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET项目中设置EF Core
- en: Defining EF Core models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义EF Core模型
- en: Querying EF Core models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询EF Core模型
- en: Understanding modern databases
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解现代数据库
- en: Two of the most common places to store data are in a **relational database management
    system** (**RDBMS**), such as SQL Server, PostgreSQL, MySQL, and SQLite, or a
    **NoSQL** database, such as Azure Cosmos DB, Redis, MongoDB, and Apache Cassandra.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据最常见的两个地方是在**关系型数据库管理系统**（**RDBMS**）中，例如SQL Server、PostgreSQL、MySQL和SQLite，或者是在**NoSQL**数据库中，例如Azure
    Cosmos DB、Redis、MongoDB和Apache Cassandra。
- en: Relational databases were invented in the 1970s. They are queried with **Structured
    Query Language** (**SQL**). At the time, data storage costs were high, so they
    reduced data duplication as much as possible. Data is stored in tabular structures
    with rows and columns that are tricky to refactor once in production. They can
    be difficult and expensive to scale.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是在20世纪70年代发明的。它们使用**结构化查询语言**（**SQL**）进行查询。当时，数据存储成本很高，因此它们尽可能地减少了数据冗余。数据存储在具有行和列的表格结构中，一旦在生产中重构，这些行和列就变得难以重构。它们可能难以扩展且成本高昂。
- en: NoSQL databases do not just mean “no SQL”; they can also mean “not only SQL.”
    They were invented in the 2000s, after the internet and the web had become popular,
    and adopted many of the learnings from that era of software. They are designed
    for massive scalability, high performance, and making programming easier by providing
    maximum flexibility and allowing schema changes at any time because they do not
    enforce a structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库不仅仅意味着“没有SQL”；它们也可以意味着“不仅限于SQL”。它们是在21世纪初互联网和万维网变得流行之后发明的，并采纳了那个软件时代的许多经验教训。它们被设计用于大规模可扩展性、高性能，并通过提供最大灵活性和允许随时更改模式来简化编程，因为它们不强制执行结构。
- en: 'If you know nothing about relational databases, then you should read the database
    primer that I wrote at the following link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对关系型数据库一无所知，那么你应该阅读我以下链接中写的数据库入门指南：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-database-primer.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-database-primer.md)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-database-primer.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-database-primer.md)'
- en: Understanding legacy Entity Framework
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解遗留的Entity Framework
- en: '**Entity Framework** (**EF**) was first released as part of .NET Framework
    3.5 with Service Pack 1 back in late 2008\. Since then, EF has evolved, as Microsoft
    has observed how programmers use **object-relational mapping** (**ORM**) tools
    in the real world.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Entity Framework**（**EF**）最初于2008年底作为.NET Framework 3.5 Service Pack 1的一部分发布。从那时起，随着微软观察到程序员在实际世界中如何使用**对象关系映射**（**ORM**）工具，EF已经发展演变。'
- en: ORMs use a mapping definition to associate columns in tables with properties
    in classes. Then, a programmer can interact with objects of different types in
    a way that they are familiar with, instead of having to deal with knowing how
    to store the values in a relational table or another structure provided by a NoSQL
    data store.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ORMs使用映射定义将表中的列与类中的属性关联起来。然后，程序员可以以他们熟悉的方式与不同类型的对象进行交互，而无需知道如何将值存储在关系型表或其他NoSQL数据存储提供的数据结构中。
- en: The version of EF included with .NET Framework is **Entity Framework 6** (**EF6**).
    It is mature and stable and supports an EDMX (XML file) way of defining the model,
    as well as complex inheritance models and a few other advanced features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随.NET Framework一起提供的EF版本是**Entity Framework 6**（**EF6**）。它成熟稳定，支持使用EDMX（XML文件）定义模型的方式，以及复杂的继承模型和其他一些高级功能。
- en: EF 6.3 and later versions have been extracted from .NET Framework as a separate
    package, so they can be supported on .NET Core 3 and later. This enables existing
    projects like web applications and services to be ported and run cross-platform.
    However, EF6 should be considered legacy technology because it has some limitations
    when running cross-platform and no new features will be added to it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: EF 6.3 及更高版本已从 .NET Framework 中提取为单独的包，因此可以在 .NET Core 3 及更高版本上支持。这使得像 Web 应用程序和服务这样的现有项目可以移植并在跨平台上运行。然而，EF6
    应被视为旧技术，因为它在跨平台运行时有一些限制，并且不会为其添加新功能。
- en: Using the legacy Entity Framework 6.3 or later
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用旧版 Entity Framework 6.3 或更高版本
- en: 'To use the legacy Entity Framework in a .NET Core 3 or later project, you must
    add a package reference to it in your project file, as shown in the following
    markup:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 .NET Core 3 或更高版本的项目中使用旧版 Entity Framework，你必须在你项目文件中添加对其的包引用，如下所示标记：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Good Practice**: Only use legacy EF6 if you must; for example, you might
    use it to migrate a **Windows Presentation Foundation** (**WPF**) app that uses
    EF6 on .NET Framework to modern .NET. This book is about modern cross-platform
    development, so in the rest of this chapter, I will only cover the modern EF Core.
    You will not need to reference the legacy EF6 package as shown above in the projects
    for this chapter.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：只有在你必须使用旧版 EF6 的情况下才使用它；例如，你可能使用它将使用 EF6 在 .NET Framework 上运行的 **Windows
    Presentation Foundation**（WPF）应用程序迁移到现代 .NET。这本书是关于现代跨平台开发的，因此在本章的其余部分，我将只介绍现代
    EF Core。你不需要在项目文件中引用上述所示的旧版 EF6 包。'
- en: Understanding Entity Framework Core
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Entity Framework Core
- en: The truly cross-platform version, **EF Core**, is different from the legacy
    Entity Framework. Although EF Core has a similar name, you should be aware of
    how it varies from EF6\. The latest EF Core is version 9, to match .NET 9.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的跨平台版本，**EF Core**，与旧版 Entity Framework 不同。尽管 EF Core 有一个类似的名字，但你应该意识到它与 EF6
    的不同之处。最新的 EF Core 版本是 9，以匹配 .NET 9。
- en: EF Core 9 targets .NET 8 or later because the EF Core team wants as many developers
    as possible to benefit from new features in future releases even if you must target
    only long-term support releases of .NET. This means that you can use all the new
    features of EF Core 9 with either .NET 8 or .NET 9\. But when EF Core 10 is released
    in November 2025, your projects will need to target .NET 10 to use it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 9 面向 .NET 8 或更高版本，因为 EF Core 团队希望尽可能多的开发者能够从未来版本的新功能中受益，即使你只需要针对 .NET
    的长期支持版本。这意味着你可以使用 .NET 8 或 .NET 9 中的所有 EF Core 9 的新功能。但是，当 2025 年 11 月发布 EF Core
    10 时，你的项目将需要针对 .NET 10 才能使用它。
- en: EF Core 3 and later only work with platforms that support .NET Standard 2.1,
    meaning .NET Core 3 and later. EF Core 3 and later do not support .NET Standard
    2.0 platforms like .NET Framework 4.8.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 3 及更高版本仅与支持 .NET Standard 2.1 的平台一起工作，这意味着 .NET Core 3 及更高版本。EF Core
    3 及更高版本不支持 .NET Standard 2.0 平台，如 .NET Framework 4.8。
- en: As well as traditional RDBMSs, EF Core supports modern cloud-based, non-relational,
    schema-less data stores, such as Azure Cosmos DB and MongoDB, sometimes with third-party
    providers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的 RDBMS 外，EF Core 还支持现代基于云的、非关系型、无模式的数据库存储，如 Azure Cosmos DB 和 MongoDB，有时需要第三方提供程序。
- en: 'EF Core has so many improvements in each release that this chapter cannot cover
    them all. In this chapter, I will focus on the fundamentals that all .NET developers
    should know and some of the most useful new features. You can learn more about
    EF Core and how to use it with SQL Server in my companion book, *Apps and Services
    with .NET 8*, or by reading the official documentation, found at the following
    link:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 在每个版本中都进行了许多改进，以至于本章无法涵盖所有内容。在本章中，我将重点介绍所有 .NET 开发者都应该了解的基本知识以及一些最有用的新功能。你可以在我的配套书籍《.NET
    8 应用和服务》中了解更多关于 EF Core 的信息以及如何使用 SQL Server，或者通过阅读以下链接中的官方文档：
- en: '[https://learn.microsoft.com/en-us/ef/core/](https://learn.microsoft.com/en-us/ef/core/)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/ef/core/](https://learn.microsoft.com/en-us/ef/core/)'
- en: 'You can keep up with the latest EF Core news at the following link:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解最新的 EF Core 新闻：
- en: '[https://aka.ms/efnews](https://aka.ms/efnews)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aka.ms/efnews](https://aka.ms/efnews)'
- en: Understanding Database First and Code First
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数据库优先和代码优先
- en: 'There are two approaches to working with EF Core:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与 EF Core 一起工作的有两种方法：
- en: '**Database First**: A database already exists, so you build a model that matches
    its structure and features. This is the most common scenario in real life. You
    will see an example of this throughout this chapter.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库优先**：已经存在一个数据库，因此你将构建一个与其结构和功能相匹配的模型。这在现实生活中是最常见的场景。你将在本章中看到这个示例。'
- en: '**Code First**: No database exists, so you build a model and then use EF Core
    to create a database that matches its structure and features. You will see an
    example of this if you complete the online-only section linked to in one of the
    exercises at the end of this chapter.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码优先**：不存在数据库，因此你构建一个模型，然后使用EF Core创建一个与其结构和功能相匹配的数据库。如果你完成了本章末尾练习中链接的在线部分，你将看到这个示例。'
- en: Performance improvements in EF Core
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EF Core的性能改进
- en: The EF Core team continues to work hard on improving the performance of EF Core.
    For example, if EF Core identifies that only a single statement will be executed
    against the database when `SaveChanges` is called, then it does not create an
    explicit transaction as earlier versions do. That gives a 25% performance improvement
    to a common scenario.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core团队继续努力提高EF Core的性能。例如，如果EF Core在调用`SaveChanges`时确定数据库将只执行一条语句，那么它就不会像早期版本那样创建显式事务。这为常见场景提供了25%的性能提升。
- en: 'There is too much information about all the recent performance improvements
    to cover in this chapter, and you get all the benefits without needing to know
    how they work anyway. If you are interested (and it is fascinating what they looked
    at and how they took advantage of some cool SQL Server features in particular),
    then I recommend that you read the following posts from the EF Core team:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中关于所有最近性能改进的信息太多，无法涵盖，而且你无需了解它们是如何工作的就可以获得所有好处。如果你感兴趣（而且他们研究的内容以及如何特别利用一些酷的SQL
    Server功能是非常迷人的），那么我建议你阅读EF Core团队发布的以下帖子：
- en: 'Announcing Entity Framework Core 7 Preview 6: Performance Edition: [https://devblogs.microsoft.com/dotnet/announcing-ef-core-7-preview6-performance-optimizations/](https://devblogs.microsoft.com/dotnet/announcing-ef-core-7-preview6-performance-optimizations/)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宣布Entity Framework Core 7预览版6：性能优化版：[https://devblogs.microsoft.com/dotnet/announcing-ef-core-7-preview6-performance-optimizations/](https://devblogs.microsoft.com/dotnet/announcing-ef-core-7-preview6-performance-optimizations/)
- en: 'Announcing Entity Framework Core 6.0 Preview 4: Performance Edition: [https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宣布Entity Framework Core 6.0预览版4：性能版：[https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/)
- en: Using a sample relational database
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用示例关系型数据库
- en: To learn how to manage an RDBMS using .NET, it would be useful to have a sample
    one so that you can practice on one that has a medium complexity and a decent
    number of sample records. Microsoft offers several sample databases, most of which
    are too complex for our needs, so instead, we will use a database that was first
    created in the early 1990s known as `Northwind`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用.NET管理RDBMS，拥有一个示例数据库会很有用，这样你就可以在一个具有中等复杂度和相当数量的示例记录的数据库上练习。微软提供了几个示例数据库，其中大多数对于我们来说过于复杂，因此，我们将使用一个最初在20世纪90年代初创建的数据库，称为`Northwind`。
- en: 'Let’s take a minute to look at a diagram of the `Northwind` database. You can
    use the diagram in *Figure 10.1* to refer to as we write code and queries throughout
    this book:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间看看`Northwind`数据库的图示。你可以使用*图10.1*中的图示来参考我们在本书编写代码和查询时的内容：
- en: '![](img/B22322_10_01.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_10_01.png)'
- en: 'Figure 10.1: The Northwind database tables and relationships'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：`Northwind`数据库表和关系
- en: 'You will write code to work with the `Categories` and `Products` tables later
    in this chapter, and other tables in later chapters. But before we do, note the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章后面编写与`Categories`和`Products`表交互的代码，以及后续章节中的其他表。但在我们这样做之前，请注意以下内容：
- en: Each category has a unique identifier, name, description, and picture.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类别都有一个唯一的标识符、名称、描述和图片。
- en: Each product has a unique identifier, name, unit price, units in stock, and
    other fields.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个产品都有一个唯一的标识符、名称、单价、库存单位和其他字段。
- en: Each product is associated with a category by storing the category’s unique
    identifier.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个产品都与一个类别相关联，通过存储该类别的唯一标识符。
- en: The relationship between `Categories` and `Products` is one-to-many, meaning
    each category can have zero or more products. This is indicated in *Figure 10.1*
    by an infinity symbol at one end (meaning many) and a yellow key at the other
    end (meaning one).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Categories`和`Products`之间的关系是一对多，这意味着每个类别可以有零个或多个产品。这在*图10.1*中通过一端的一个无穷符号（表示多个）和另一端的一个黄色钥匙（表示一个）来表示。'
- en: Using SQLite
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQLite
- en: SQLite is a small, fast, cross-platform, self-contained RDBMS that is available
    in the public domain. It’s the most common RDBMS for mobile platforms such as
    iOS (iPhone and iPad) and Android. SQLite is the most used database engine in
    the world and there are more than one trillion SQLite databases in active use.
    You can read more about this at [https://www.sqlite.org/mostdeployed.html](https://www.sqlite.org/mostdeployed.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个小型、快速、跨平台、自包含的关系型数据库管理系统，可在公共领域获得。它是iOS（iPhone和iPad）和Android等移动平台最常见的RDBMS。SQLite是世界上使用最广泛的数据库引擎，有超过一千亿个SQLite数据库正在使用中。您可以在[https://www.sqlite.org/mostdeployed.html](https://www.sqlite.org/mostdeployed.html)了解更多信息。
- en: I decided to demonstrate databases using SQLite in this book since its important
    themes are cross-platform development and fundamental skills that only need basic
    database capabilities. I recommend that you initially complete the book code tasks
    using SQLite. If you also want to try the code tasks using SQL Server, then I
    provide documentation to do so in the online-only sections in the GitHub repository
    for this book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定在这本书中使用SQLite来演示数据库，因为其重要主题是跨平台开发和只需要基本数据库功能的基本技能。我建议您最初使用SQLite完成本书的代码任务。如果您也想尝试使用SQL
    Server的代码任务，那么我在GitHub存储库的在线部分提供了相应的文档。
- en: Using SQL Server or other SQL systems
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL Server或其他SQL系统
- en: 'Enterprises that standardize on Windows tend to also use SQL Server as their
    database. If you would prefer to use SQL Server, please see the online instructions
    at the following link:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于使用Windows的企业通常也会使用SQL Server作为其数据库。如果您希望使用SQL Server，请参阅以下链接中的在线说明：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md)'
- en: If you would prefer to use a different SQL system, then the SQL scripts that
    I provide should work with most SQL systems, for example, PostgreSQL or MySQL.
    However, I have not written step-by-step instructions for them and I make no guarantees
    they will work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用不同的SQL系统，那么我提供的SQL脚本应该适用于大多数SQL系统，例如PostgreSQL或MySQL。然而，我并没有为它们编写逐步说明，也不保证它们会工作。
- en: My recommendation is to complete this book using SQLite, so you focus on learning
    what’s taught in the book about EF Core rather than adding the complication of
    trying to use a different database system. Learning is hard enough; don’t bite
    off more than you can chew, and don’t make it harder on yourself. Once you’ve
    learned what’s in the book, you can always repeat it with a different database
    system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是使用SQLite完成这本书，这样您可以专注于学习书中关于EF Core的内容，而不是尝试使用不同的数据库系统带来的复杂性。学习本身就很难；不要贪多，也不要给自己增加不必要的难度。一旦您学到了书中的内容，您总是可以用不同的数据库系统重复学习。
- en: Setting up SQLite CLI tools for Windows
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Windows的SQLite CLI工具
- en: 'On Windows, we need to download SQLite CLI tools and add the folder for SQLite
    to the system path so it will be found when we enter commands at a command prompt
    or terminal:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们需要下载SQLite CLI工具并将SQLite文件夹添加到系统路径中，这样在命令提示符或终端中输入命令时就可以找到它：
- en: Start your favorite browser and navigate to [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器并导航到[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)。
- en: Scroll down the page to the **Precompiled Binaries for Windows** section.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面向下滚动到**Windows的预编译二进制文件**部分。
- en: 'Click **sqlite-tools-win32-x86-3460100.zip** (the file might have a higher
    version number), as shown in the following screenshot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**sqlite-tools-win32-x86-3460100.zip**（文件可能具有更高的版本号），如下面的截图所示：
- en: '![](img/B22322_10_02.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_10_02.png)'
- en: 'Figure 10.2: Downloading SQLite for Windows'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：下载Windows版的SQLite
- en: Extract the ZIP file into a folder named `C:\Sqlite\`. Make sure that the three
    extracted files, including `sqlite3.exe`, are directly inside the `C:\SQLite`
    folder or the executable will not be found later when you try to use it.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ZIP文件解压到名为`C:\Sqlite\`的文件夹中。请确保包括`sqlite3.exe`在内的三个解压文件直接位于`C:\SQLite`文件夹内，否则在您尝试使用它时可能会找不到可执行文件。
- en: In the Windows **Start** menu, navigate to **Settings**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows的**开始**菜单中，导航到**设置**。
- en: Search for `environment` and choose **Edit the system environment variables**.
    On non-English versions of Windows, please search for the equivalent word in your
    local language to find the setting.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中搜索`环境`并选择**编辑系统环境变量**。在非英文版本的Windows中，请搜索您当地语言中的等效词汇以找到设置。
- en: Click the **Environment Variables** button.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **环境变量** 按钮。
- en: In **System variables**, select **Path** in the list, and then click **Edit…**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **系统变量** 中，从列表中选择 **Path**，然后点击 **编辑…**。
- en: If `C:\SQLite` is not already in the path, then click **New**, enter `C:\Sqlite`,
    and press *Enter*.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `C:\SQLite` 还未在路径中，则点击 **新建**，输入 `C:\Sqlite`，然后按 *Enter*。
- en: Click **OK**, then **OK**, then **OK** again, and then close **Settings**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定**，然后 **确定**，再次点击 **确定**，最后关闭 **设置**。
- en: 'To confirm that the path to SQLite has been configured correctly, at any command
    prompt or terminal, enter the following command to start SQLite:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认 SQLite 的路径已正确配置，在任何命令提示符或终端中，输入以下命令以启动 SQLite：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the result, as shown in the following output:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意结果，如下所示：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To exit the SQLite command prompt, do the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出 SQLite 命令提示符，请执行以下操作：
- en: On Windows, press *Ctrl* + *C* twice.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，按 *Ctrl* + *C* 两次。
- en: On macOS, press *Ctrl* + *D*.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，按 *Ctrl* + *D*。
- en: Setting up SQLite for macOS and Linux
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 macOS 和 Linux 设置 SQLite
- en: On macOS, SQLite is included in the `/usr/bin/` directory as a command-line
    application named `sqlite3`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，SQLite 包含在 `/usr/bin/` 目录中，作为名为 `sqlite3` 的命令行应用程序。
- en: 'On Linux, you can get set up with SQLite using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，您可以使用以下命令设置 SQLite：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'SQLite can be downloaded and installed for other OSs from the following link:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 可以从以下链接下载和安装到其他操作系统：
- en: '[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)'
- en: Setting up EF Core in a .NET project
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 .NET 项目中设置 EF Core
- en: Now that we have a database system set up, we can create a database and .NET
    project that uses it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个数据库系统，我们可以创建一个使用它的数据库和 .NET 项目。
- en: Creating a console app for working with EF Core
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于处理 EF Core 的控制台应用程序
- en: First, we will create a console app project for this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为本章创建一个控制台应用程序项目。
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下列所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `WorkingWithEFCore`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithEFCore`
- en: 'Solution file and folder: `Chapter10`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter10`
- en: Creating the Northwind sample database for SQLite
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 SQLite 创建 Northwind 示例数据库
- en: 'Now we can create the `Northwind` sample database for SQLite using an SQL script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 SQL 脚本创建 SQLite 的 `Northwind` 示例数据库：
- en: 'If you have not previously cloned or downloaded the ZIP for the GitHub repository
    for this book, then do so now using the following link: [https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9).'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您之前尚未克隆或下载此书的 GitHub 仓库的 ZIP 文件，请现在使用以下链接进行操作：[https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9)。
- en: 'Copy the script to create the `Northwind` database for SQLite from the following
    path in your local Git repository or where you extracted the ZIP: `/scripts/sql-scripts/Northwind4SQLite.sql`
    into the `WorkingWithEFCore` folder.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建 `Northwind` 数据库的脚本从您本地 Git 仓库或解压 ZIP 文件的位置复制到 `WorkingWithEFCore` 文件夹中：`/scripts/sql-scripts/Northwind4SQLite.sql`。
- en: 'Start a command prompt or terminal in the `WorkingWithEFCore` project folder:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithEFCore` 项目文件夹中启动一个命令提示符或终端：
- en: On Windows, start **File Explorer**, right-click the `WorkingWithEFCore` folder,
    and select **New Command Prompt at Folder** or **Open in Windows Terminal**.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，启动 **文件资源管理器**，右键单击 `WorkingWithEFCore` 文件夹，然后选择 **在此文件夹中新建命令提示符**
    或 **在 Windows 终端中打开**。
- en: On macOS, start **Finder**, right-click the `WorkingWithEFCore` folder, and
    select **New Terminal at Folder**.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，启动 **Finder**，右键单击 `WorkingWithEFCore` 文件夹，然后选择 **在此文件夹中新建终端**。
- en: 'Enter the command to execute the SQL script using SQLite to create the `Northwind.db`
    database, as shown here:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令以使用 SQLite 执行 SQL 脚本并创建 `Northwind.db` 数据库，如下所示：
- en: '[PRE4]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually, you will see the SQLite command prompt, as shown in the following
    output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请耐心等待，因为此命令可能需要一段时间来创建数据库结构。最终，您将看到 SQLite 命令提示符，如下所示：
- en: '[PRE5]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To exit the SQLite command prompt, do the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出 SQLite 命令提示符，请执行以下操作：
- en: On Windows, press *Ctrl* + *C* twice.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，按 *Ctrl* + *C* 两次。
- en: On macOS or Linux, press *Ctrl* + *D*.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 或 Linux 上，按 *Ctrl* + *D*。
- en: You can leave the command prompt or terminal window open because you will use
    it again soon.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以保持命令提示符或终端窗口打开，因为您很快还会再次使用它。
- en: If you are using Visual Studio
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio
- en: If you are using VS Code and the `dotnet run` command, the compiled application
    executes in the `WorkingWithEFCore` folder, allowing it to locate the database
    file stored therein. But if you are using Visual Studio or Rider, then the compiled
    application executes in the `WorkingWithEFCore\bin\Debug\net9.0` folder, so it
    will not find the database file because it is not in that directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code 和 `dotnet run` 命令，编译的应用程序将在 `WorkingWithEFCore` 文件夹中执行，允许它找到存储在该文件夹中的数据库文件。但如果你使用
    Visual Studio 或 Rider，则编译的应用程序将在 `WorkingWithEFCore\bin\Debug\net9.0` 文件夹中执行，因此它将找不到数据库文件，因为它不在该目录中。
- en: 'Let’s tell Visual Studio to copy the database file to the directory that it
    runs the code in so that it can find the file, but only if the database file is
    newer or is missing so it will not overwrite any database changes we make during
    runtime:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们告诉 Visual Studio 将数据库文件复制到它运行代码的目录中，以便它可以找到该文件，但只有当数据库文件较新或缺失时，它才不会覆盖我们在运行时所做的任何数据库更改：
- en: In **Solution Explorer**, right-click the `Northwind.db` file and select **Properties**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，右键单击 `Northwind.db` 文件并选择 **属性**。
- en: In **Properties**, set **Copy to Output Directory** to **Copy if newer**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **属性** 中，将 **复制到输出目录** 设置为 **如果较新则复制**。
- en: 'In `WorkingWithEFCore.csproj`, note the new elements, as shown in the following
    markup:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithEFCore.csproj` 中，注意以下标记中的新元素：
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you prefer to overwrite the data changes every time you start the project,
    then set **CopyToOutputDirectory** to **Always**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢每次启动项目时覆盖数据更改，则将 **CopyToOutputDirectory** 设置为 **始终**。
- en: You could make the preceding changes to the project file manually instead of
    using the **Properties** window. In fact, any change made to the project file
    by any tool can also be made manually just by editing the XML. Tools like the
    **Properties** window just read the files in a project and show an alternative
    view. This is why in *Chapter 1*, I stressed using multiple code editors when
    learning .NET. The danger is that if you only use Visual Studio, then you may
    start to think that Visual Studio *is* .NET development. It is not.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动修改项目文件，而不是使用 **属性** 窗口进行上述更改。实际上，任何工具对项目文件所做的更改都可以通过编辑 XML 来手动完成。像 **属性**
    窗口这样的工具只是读取项目中的文件并显示一个替代视图。这就是为什么在 *第一章* 中，我强调在学习 .NET 时使用多个代码编辑器。危险在于，如果你只使用
    Visual Studio，那么你可能会开始认为 Visual Studio *就是* .NET 开发。事实并非如此。
- en: The real .NET development is the contents of the source code files, like `.cs`,
    and the project file `.csproj`, which are then compiled by the command-line interface
    `dotnet`. Any other tool you use is just an additional layer on top of that.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的 .NET 开发是源代码文件的内容，如 `.cs` 文件和项目文件 `.csproj`，然后通过命令行界面 `dotnet` 进行编译。你使用的任何其他工具都只是在这个基础上添加的一个额外层。
- en: Interestingly, a future feature in .NET that Microsoft is actively looking at
    is “implicit project files.” This would mean having a folder that contains only
    one or more `.cs` files and the `.csproj` file would not need to exist because
    its content could be implied using defaults. For example, it might default to
    the current SDK and its target .NET version, and so on. But it gets complicated,
    so we will have to wait and see if this ever happens.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，.NET 的一个未来特性，微软正在积极考虑的是“隐式项目文件”。这意味着有一个只包含一个或多个 `.cs` 文件和 `.csproj` 文件的文件夹，而
    `.csproj` 文件不需要存在，因为其内容可以通过默认值隐式表示。例如，它可能默认为当前的 SDK 和目标 .NET 版本等。但这很复杂，所以我们将不得不等待并看看这是否会真的发生。
- en: Managing the Northwind sample database with SQLiteStudio
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SQLiteStudio 管理 Northwind 示例数据库
- en: 'You can use a cross-platform graphical database manager named **SQLiteStudio**
    to easily manage SQLite databases:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个名为 **SQLiteStudio** 的跨平台图形数据库管理器轻松管理 SQLite 数据库：
- en: Navigate to [https://sqlitestudio.pl](https://sqlitestudio.pl), and then download
    and install the application.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 [https://sqlitestudio.pl](https://sqlitestudio.pl)，然后下载并安装应用程序。
- en: Start **SQLiteStudio**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 **SQLiteStudio**。
- en: Navigate to **Database** | **Add a database**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **数据库** | **添加数据库**。
- en: 'In the **Database** dialog, in the **File** section, click on the yellow folder
    button to browse for an existing database file on the local computer, select the
    `Northwind.db` file in the `WorkingWithEFCore` project folder, and then click
    **OK**, as shown in *Figure 10.3*:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **数据库** 对话框中，在 **文件** 部分，单击黄色文件夹按钮以在本地计算机上浏览现有的数据库文件，在 `WorkingWithEFCore`
    项目文件夹中选择 `Northwind.db` 文件，然后单击 **确定**，如图 10.3 所示：
- en: '![](img/B22322_10_03.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_10_03.png)'
- en: 'Figure 10.3: Adding the Northwind.db database file to SQLiteStudio'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：将 Northwind.db 数据库文件添加到 SQLiteStudio
- en: If you cannot see the database, then navigate to **View** | **Databases**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您看不到数据库，请转到**视图** | **数据库**。
- en: In the **Databases** window, right-click on the `Northwind` database and choose
    **Connect to the database** (or just double-click `Northwind`). You will see the
    10 tables that were created by the script. (The script for SQLite is simpler than
    the one for SQL Server; it does not create as many tables or other database objects.)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**数据库**窗口中，右键单击`Northwind`数据库并选择**连接到数据库**（或直接双击`Northwind`）。您将看到由脚本创建的10个表。（SQLite的脚本比SQL
    Server的简单；它不会创建那么多表或其他数据库对象。）
- en: Right-click on the **Products** table and choose **Edit the table**, or just
    double-click the table.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**产品**表并选择**编辑表**，或直接双击表。
- en: 'In the table editor window, note the structure of the `Products` table, including
    column names, data types, keys, and constraints, as shown in *Figure 10.4*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表编辑器窗口中，注意`Products`表的结构，包括列名、数据类型、键和约束，如图10.4所示：
- en: '![](img/B22322_10_04.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_10_04.png)'
- en: 'Figure 10.4: The table editor in SQLiteStudio showing the structure of the
    Products table'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：SQLiteStudio中的表编辑器显示产品表的结构
- en: 'In the table editor window, click the **Data** tab, and you will see 77 products,
    as shown in *Figure 10.5*:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表编辑器窗口中，单击**数据**标签，您将看到77个产品，如图10.5所示：
- en: '![](img/B22322_10_05.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_10_05.png)'
- en: 'Figure 10.5: The Data tab showing the 77 rows in the Products table'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：显示产品表中77行的数据标签
- en: In the **Database** window, right-click `Northwind` and select **Disconnect
    from the database**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**数据库**窗口中，右键单击`Northwind`并选择**从数据库断开连接**。
- en: Quit SQLiteStudio.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出SQLiteStudio。
- en: Using the lightweight ADO.NET database providers
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用轻量级ADO.NET数据库提供程序
- en: Before Entity Framework, there was **ADO.NET**. Compared to EF, this is a simpler
    and more efficient API for working with databases. It provides abstract classes
    like `DbConnection`, `DbCommand`, and `DbReader`, and provider-specific implementations
    of them like `SqlConnection` and `SqlCommand`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Entity Framework之前，有**ADO.NET**。与EF相比，这是一个更简单、更高效的数据库操作API。它提供了如`DbConnection`、`DbCommand`和`DbReader`之类的抽象类，以及特定提供程序的实现，如`SqlConnection`和`SqlCommand`。
- en: In this chapter, if you choose to use SQL Server, then you should use the `SqlConnectionStringBuilder`
    class to help write a valid connection string. This is because it has properties
    for all possible parts of a database connection string that you set individually
    and then it returns the complete string. You should also get sensitive secrets
    like passwords from an environment variable or a secret management system instead
    of writing them in your source code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果您选择使用SQL Server，那么您应该使用`SqlConnectionStringBuilder`类来帮助编写有效的连接字符串。这是因为它具有所有可能数据库连接字符串部分的属性，您可以单独设置它们，然后它返回完整的字符串。您还应该从环境变量或秘密管理系统获取敏感信息，如密码，而不是将它们写入源代码。
- en: For SQLite, the connection string is so simple that you do not need to use the
    `SqliteConnectionStringBuilder` class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLite，连接字符串非常简单，您不需要使用`SqliteConnectionStringBuilder`类。
- en: The EF Core database providers for SQLite and SQL Server are built on top of
    the ADO.NET libraries, so EF Core is always inherently slower than ADO.NET.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core的SQLite和SQL Server数据库提供程序建立在ADO.NET库之上，因此EF Core始终比ADO.NET本身慢。
- en: If you want to use native **ahead-of-time** (**AOT**) publishing, be aware that
    EF Core does not yet support it. This means you can only use the ADO.NET libraries
    if you plan to compile to native code. The EF Core team is investigating how they
    can support native AOT, but it is challenging so it has not happened with EF Core
    9 this year. Hopefully, it will happen for EF Core 10 in 2025.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用原生的**提前编译**（**AOT**）发布，请注意EF Core目前还不支持它。这意味着如果您计划编译为原生代码，则只能使用ADO.NET库。EF
    Core团队正在调查他们如何支持原生AOT，但这很具挑战性，因此今年EF Core 9没有实现。希望它将在2025年的EF Core 10中实现。
- en: Apart from `SqlConnectionStringBuilder`, this book does not cover using the
    ADO.NET library, but I do cover examples of how to publish native AOT minimal
    API web services using the ADO.NET for SQL Server library in the companion book,
    *Apps and Services with .NET 8*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`SqlConnectionStringBuilder`之外，本书不涵盖使用ADO.NET库，但在配套书籍《.NET 8中的应用程序和服务》中，我涵盖了如何使用ADO.NET
    for SQL Server库发布原生AOT最小API Web服务的示例。
- en: 'You can learn more about the ADO.NET for SQLite library at the following link:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于ADO.NET for SQLite库的信息：
- en: '[https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/](https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/](https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/)'
- en: 'You can learn more about the ADO.NET for SQL Server library at the following
    link:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于 SQL Server 的 ADO.NET 库信息：
- en: '[https://learn.microsoft.com/en-us/sql/connect/ado-net/microsoft-ado-net-sql-server](https://learn.microsoft.com/en-us/sql/connect/ado-net/microsoft-ado-net-sql-server)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/sql/connect/ado-net/microsoft-ado-net-sql-server](https://learn.microsoft.com/en-us/sql/connect/ado-net/microsoft-ado-net-sql-server)'
- en: '**Warning!** All `System.Data.SqlClient` users are encouraged to transition
    to `Microsoft.Data.SqlClient`. You can read the announcement about how `System.Data.SqlClient`
    package is now deprecated at the following link:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 所有 `System.Data.SqlClient` 用户都鼓励过渡到 `Microsoft.Data.SqlClient`。您可以在以下链接中阅读有关
    `System.Data.SqlClient` 包现在已弃用的公告：'
- en: '[https://techcommunity.microsoft.com/t5/sql-server-blog/announcement-system-data-sqlclient-package-is-now-deprecated/ba-p/4227205](https://techcommunity.microsoft.com/t5/sql-server-blog/announcement-system-data-sqlclient-package-is-now-deprecated/ba-p/4227205)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://techcommunity.microsoft.com/t5/sql-server-blog/announcement-system-data-sqlclient-package-is-now-deprecated/ba-p/4227205](https://techcommunity.microsoft.com/t5/sql-server-blog/announcement-system-data-sqlclient-package-is-now-deprecated/ba-p/4227205)'
- en: Choosing an EF Core database provider
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 EF Core 数据库提供者
- en: Before we dive into the practicalities of managing data using EF Core, let’s
    briefly talk about choosing between EF Core database providers. To manage data
    in a specific database, we need classes that know how to efficiently talk to that
    database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨使用 EF Core 管理数据的实际操作之前，让我们简要地谈谈选择 EF Core 数据库提供者。为了管理特定数据库中的数据，我们需要知道如何高效地与该数据库通信的类。
- en: EF Core database providers are sets of classes that are optimized for a specific
    data store. There is even a provider for storing the data in the memory of the
    current process, which can be useful for high-performance unit testing since it
    avoids hitting an external system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 数据库提供者是一组针对特定数据存储进行优化的类。甚至还有一个提供者可以将数据存储在当前进程的内存中，这对于高性能单元测试非常有用，因为它避免了访问外部系统。
- en: 'They are distributed as NuGet packages, as shown in *Table 10.1*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它们作为 NuGet 包分发，如 *表 10.1* 所示：
- en: '| **To manage this data store** | **Reference this NuGet package** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **管理此数据存储** | **参考此 NuGet 包** |'
- en: '| SQL Server 2012 or later | `Microsoft.EntityFrameworkCore.SqlServer` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| SQL Server 2012 或更高版本 | `Microsoft.EntityFrameworkCore.SqlServer` |'
- en: '| SQLite 3.7 or later | `Microsoft.EntityFrameworkCore.SQLite` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| SQLite 3.7 或更高版本 | `Microsoft.EntityFrameworkCore.SQLite` |'
- en: '| In-memory | `Microsoft.EntityFrameworkCore.InMemory` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 内存中存储 | `Microsoft.EntityFrameworkCore.InMemory` |'
- en: '| Azure Cosmos DB SQL API | `Microsoft.EntityFrameworkCore.Cosmos` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| Azure Cosmos DB SQL API | `Microsoft.EntityFrameworkCore.Cosmos` |'
- en: '| MySQL | `MySQL.EntityFrameworkCore` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | `MySQL.EntityFrameworkCore` |'
- en: '| Oracle DB 11.2 | `Oracle.EntityFrameworkCore` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| Oracle 数据库 11.2 | `Oracle.EntityFrameworkCore` |'
- en: '| PostgreSQL | `Npgsql.EntityFrameworkCore.PostgreSQL` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | `Npgsql.EntityFrameworkCore.PostgreSQL` |'
- en: 'Table 10.1: NuGet packages for common EF Core database providers'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1：常见 EF Core 数据库提供者的 NuGet 包
- en: You can reference as many EF Core database providers in the same project as
    you need. Each package includes the common shared types, as well as provider-specific
    types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在同一个项目中引用您需要的任何 EF Core 数据库提供者。每个包都包括常见的共享类型，以及特定提供者的类型。
- en: Connecting to a named SQLite database
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到命名的 SQLite 数据库
- en: To connect to an SQLite database, we just need to know the database path and
    filename, set using the legacy parameter `Filename` or the modern equivalent,
    `Data Source`. The path can be relative to the current directory or an absolute
    path. We specify this information in a **connection string**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 SQLite 数据库，我们只需要知道数据库路径和文件名，可以使用传统的参数 `Filename` 或现代的等效参数 `Data Source`
    来设置。路径可以是相对于当前目录的相对路径或绝对路径。我们将在 **连接字符串** 中指定这些信息。
- en: Defining the Northwind database context class
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Northwind 数据库上下文类
- en: A class named `Northwind` will be used to represent the database. To use EF
    Core, the class must inherit from `DbContext`. The `DbContext` class understands
    how to communicate with databases and dynamically generate SQL statements to query
    and manipulate data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用名为 `Northwind` 的类来表示数据库。要使用 EF Core，该类必须从 `DbContext` 继承。`DbContext` 类了解如何与数据库通信并动态生成
    SQL 语句以查询和操作数据。
- en: Your `DbContext`-derived class should have an overridden method named `OnConfiguring`,
    which will set the database connection string.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `DbContext` 派生类应该有一个重写的方法名为 `OnConfiguring`，该方法将设置数据库连接字符串。
- en: 'We will create a project that uses SQLite, but feel free to use SQL Server
    or some other database system if you feel comfortable doing so instead:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个使用 SQLite 的项目，但如果你更熟悉 SQL Server 或其他数据库系统，也可以使用：
- en: 'In the `WorkingWithEFCore` project, add a package reference to the EF Core
    provider for SQLite and globally and statically import the `System.Console` class
    for all C# files, as shown in the following markup:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithEFCore` 项目中，添加对 SQLite EF Core 提供程序的包引用，并在所有 C# 文件中全局和静态导入 `System.Console`
    类，如下面的标记所示：
- en: '[PRE7]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build the `WorkingWithEFCore` project to restore packages.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `WorkingWithEFCore` 项目以恢复包。
- en: After February 2025, you will be able to try out previews of EF Core 10 by specifying
    version `10.0-*`, so you must also install a preview of .NET 10 SDK. The target
    framework for your project must be `net10.0`. By using a wildcard, you will automatically
    download the latest monthly preview when you restore the packages for the project.
    Once the EF Core 10 GA version is released in November 2025, change the package
    version to `10.0.0`. After February 2026, you will be able to do the same with
    EF Core 11 and that will continue to require a project targeting `net10.0`.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 2025 年 2 月之后，你可以通过指定版本 `10.0-*` 来尝试 EF Core 10 的预览版，因此你也必须安装 .NET 10 SDK 的预览版。你的项目目标框架必须是
    `net10.0`。通过使用通配符，当你恢复项目的包时，将自动下载最新的月度预览版。一旦 2025 年 11 月发布 EF Core 10 GA 版本，将包版本更改为
    `10.0.0`。在 2026 年 2 月之后，你将能够以相同的方式使用 EF Core 11，并且这将继续需要以 `net10.0` 为目标的项目。
- en: In the project folder, add a new class file named `NorthwindDb.cs`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中，添加一个名为 `NorthwindDb.cs` 的新类文件。
- en: 'In `NorthwindDb.cs`, import the main namespace for EF Core, define a class
    named `NorthwindDb`, and make the class inherit from `DbContext`. Then, in an
    `OnConfiguring` method, configure the options builder to use SQLite with an appropriate
    database connection string, as shown in the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NorthwindDb.cs` 文件中，导入 EF Core 的主命名空间，定义一个名为 `NorthwindDb` 的类，并使该类继承自 `DbContext`。然后，在
    `OnConfiguring` 方法中，配置选项构建器以使用 SQLite 和适当的数据库连接字符串，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Good Practice**: Some code editors like Visual Studio will automatically
    add a call to the base class member when you override a member. Although this
    is generally good practice, it is unnecessary in this case because the base implementation
    does nothing. To decide if you need to keep the call or not, view the tooltip
    or definition of the member. If you hover over the `OnConfiguring` method name,
    its tooltip tells you “The base implementation does nothing.” If you **Go To Definition**
    (*F12*) of the method, you will see that it does nothing, as shown in the following
    code:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：一些代码编辑器，如 Visual Studio，会在你重写成员时自动添加对基类成员的调用。尽管这通常是良好实践，但在这种情况下是不必要的，因为基实现没有任何作用。要决定是否需要保留调用，请查看成员的提示或定义。如果你将鼠标悬停在
    `OnConfiguring` 方法名称上，其提示会告诉你“基实现没有任何作用。”如果你 **转到定义** (*F12*) 该方法，你会看到它没有任何作用，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method only exists in the base class so that subclasses can override it
    and then EF Core can call your code when it needs to configure the data context.
    It would be a waste for your overridden method implementation to call the base
    implementation. If your code editor adds the call to the base class automatically,
    then you should delete the statement to make your code match the code in the book.
    The same applies later in the book when you override the `OnModelCreating` method.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法仅存在于基类中，以便子类可以重写它，然后 EF Core 在需要配置数据上下文时调用你的代码。如果你的重写方法实现调用了基实现，那将是一种浪费。如果你的代码编辑器自动添加了对基类的调用，那么你应该删除该语句以使你的代码与书中的代码匹配。在书中稍后重写
    `OnModelCreating` 方法时，这也适用。
- en: 'In `Program.cs`, delete the existing statements. Then, import the `Northwind.EntityModels`
    namespace and output the database provider, as shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句。然后，导入 `Northwind.EntityModels` 命名空间，并输出数据库提供程序，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the console app and note the output showing the database connection string
    and which database provider you are using, as shown in the following output:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意显示数据库连接字符串和所使用的数据库提供程序的输出，如下面的输出所示：
- en: '[PRE11]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You now know how to connect to a database by defining the EF Core data context.
    Next, we need to define a model that represents the tables in the database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何通过定义 EF Core 数据上下文来连接数据库。接下来，我们需要定义一个表示数据库中表的模型。
- en: Defining EF Core models
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 EF Core 模型
- en: EF Core uses a combination of **conventions**, **annotation attributes**, and
    **Fluent API** statements to build an **entity model** at runtime, which enables
    any actions performed on the classes to later be automatically translated into
    actions performed on the actual database. An **entity class** represents the structure
    of a table, and an instance of the class represents a row in that table.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 使用 **约定**、**注解属性** 和 **Fluent API** 语句的组合在运行时构建 **实体模型**，这使得对类执行的操作可以自动转换为对实际数据库执行的操作。一个
    **实体类** 代表表的结构，该类的实例代表表中的一行。
- en: First, we will review the three ways to define a model, with code examples,
    and then we will create some classes that implement those techniques.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾定义模型的三种方法，并附上代码示例，然后我们将创建一些实现这些技术的类。
- en: Using EF Core conventions to define the model
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 EF Core 约定定义模型
- en: 'The code we will write will use the following conventions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的代码将使用以下约定：
- en: The name of a table is assumed to match the name of a `DbSet<T>` property in
    the `DbContext` class, for example, `Products`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表的名称假定与 `DbContext` 类中 `DbSet<T>` 属性的名称匹配，例如，`Products`。
- en: The names of the columns are assumed to match the names of properties in the
    entity model class, for example, `ProductId`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列的名称假定与实体模型类中的属性名称匹配，例如，`ProductId`。
- en: The `string` .NET type is assumed to be a `nvarchar` type in the database.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NET` 中的 `string` 类型在数据库中假定是 `nvarchar` 类型。'
- en: The `int` .NET type is assumed to be an `int` type in the database.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NET` 中的 `int` 类型在数据库中假定是 `int` 类型。'
- en: The primary key is assumed to be a property that is named `Id` or `ID`, or when
    the entity model class is named `Product`, then the property can be named `ProductId`
    or `ProductID`. If this property is an integer type or the `Guid` type, then it
    is also assumed to be an `IDENTITY` column (a column type that automatically assigns
    a value when inserting).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键假定是一个名为 `Id` 或 `ID` 的属性，或者当实体模型类名为 `Product` 时，该属性可以命名为 `ProductId` 或 `ProductID`。如果此属性是整数类型或
    `Guid` 类型，则它也被假定为 `IDENTITY` 列（一种在插入时自动分配值的列类型）。
- en: '**Good Practice**: There are many other conventions that you should know, and
    you can even define your own, but that is beyond the scope of this book. You can
    read about them at the following link:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：还有许多其他约定您应该了解，您甚至可以定义自己的约定，但这超出了本书的范围。您可以在以下链接中了解它们：'
- en: '[https://learn.microsoft.com/en-us/ef/core/modeling/](https://learn.microsoft.com/en-us/ef/core/modeling/)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/ef/core/modeling/](https://learn.microsoft.com/en-us/ef/core/modeling/)'
- en: Using EF Core annotation attributes to define the model
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 EF Core 注解属性定义模型
- en: 'Conventions often aren’t enough to completely map the classes to the database
    objects. A simple way of making your model smarter is to apply annotation attributes.
    Some common attributes recognized by EF Core are shown in *Table 10.2*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 约定通常不足以完全将类映射到数据库对象。使您的模型更智能的一种简单方法是应用注解属性。EF Core 识别的一些常见属性在 *表 10.2* 中显示：
- en: '| **Attribute** | **Description** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `[Required]` | This ensures the value is not null. In .NET 8, it has a `DisallowAllDefaultValues`
    parameter to prevent value types from having their default value. For example,
    an `int` cannot be `0`. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `[Required]` | 这确保值不是 null。在 .NET 8 中，它有一个 `DisallowAllDefaultValues` 参数，以防止值类型具有其默认值。例如，`int`
    不能是 `0`。|'
- en: '| `[StringLength(50)]` | This ensures the value is up to 50 characters in length.
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `[StringLength(50)]` | 这确保值长度不超过 50 个字符。|'
- en: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | This specifies the column
    type and column name used in the table. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | 这指定了表中使用的列类型和列名。|'
- en: 'Table 10.2: Common EF Core annotation attributes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2：常见的 EF Core 注解属性
- en: '**Warning!** `[StringLength]` is not honored by all EF Core data providers.
    For example, although SQL Server honors it, SQLite does not. For SQLite, use `[Column(TypeName
    = "text(50)")]` instead.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** `[StringLength]` 并不是所有 EF Core 数据提供程序都支持的。例如，虽然 SQL Server 支持，但 SQLite
    不支持。对于 SQLite，请使用 `[Column(TypeName = "text(50)")]` 代替。'
- en: 'Some additional attributes that can be used to validate entities and are recognized
    by platforms like ASP.NET Core and Blazor for validation are shown in *Table 10.3*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以用于验证实体并受 ASP.NET Core 和 Blazor 等平台认可的附加属性在 *表 10.3* 中显示：
- en: '| **Attribute** | **Description** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `[RegularExpression(expression)]` | This ensures the value matches the specified
    regular expression. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `[RegularExpression(expression)]` | 这确保值与指定的正则表达式匹配。|'
- en: '| `[EmailAddress]` | This ensures the value contains one `@` symbol, but not
    as the first or last character. It does not use a regular expression. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `[EmailAddress]` | 这确保值包含一个`@`符号，但不能作为第一个或最后一个字符。它不使用正则表达式。|'
- en: '| `[Range(1, 10)]` | This ensures a `double`, `int`, or `string` value within
    a specified range. New in .NET 8 are the parameters `MinimumIsExclusive` and `MaximumIsExclusive`.
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `[Range(1, 10)]` | 这确保`double`、`int`或`string`值在指定的范围内。在.NET 8中新增了`MinimumIsExclusive`和`MaximumIsExclusive`参数。|'
- en: '| `[Length(10, 20)]` | This ensures a string or collection is within a specified
    length range, for example, a minimum of 10 characters or items, and a a maximum
    of 20 characters or items. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `[Length(10, 20)]` | 这确保字符串或集合在指定的长度范围内，例如，至少10个字符或项目，最多20个字符或项目。|'
- en: '| `[Base64String]` | This ensures the value is a well-formed Base64 string.
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `[Base64String]` | 这确保值是一个格式良好的Base64字符串。|'
- en: '| `[AllowedValues]` | This ensures the value is one of the items in the `params`
    array of objects. For example, `"alpha"`, `"beta"`, `"gamma"`, or `1`, `2`, `3`.
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `[AllowedValues]` | 这确保值是对象`params`数组中的其中一个项。例如，`"alpha"`、`"beta"`、`"gamma"`或`1`、`2`、`3`。|'
- en: '| `[DeniedValues]` | Ensures value is not one of the items in the `params`
    array of objects. For example, `"alpha"`, `"beta"`, `"gamma"`, or `1`, `2`, `3`.
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `[DeniedValues]` | 确保值不是对象`params`数组中的任何一个项。例如，`"alpha"`、`"beta"`、`"gamma"`或`1`、`2`、`3`。|'
- en: 'Table 10.3: Validation annotation attributes'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.3：验证注解属性
- en: 'Why does the `EmailAddress` attribute seem so basic? According to a comment
    by ajcvickers, who also closed the GitHub issue, “*The check is intentionally
    naive because doing something infallible is very hard. The email really should
    be validated in some other way, such as through an email confirmation flow where
    an email is actually sent. The validation attribute is designed only to catch
    egregiously wrong values such as for a U.I.*” You can read the debate at the following
    link:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`EmailAddress`属性看起来如此基础？根据ajcvickers的评论，他也是GitHub问题的关闭者，“*检查是有意为之的简单，因为做到无误是非常困难的。电子邮件实际上应该通过其他方式验证，例如通过发送电子邮件的确认流程。验证属性仅设计用于捕获像U.I.这样的明显错误值。*”您可以在以下链接中阅读辩论：
- en: '[https://github.com/dotnet/runtime/issues/27592](https://github.com/dotnet/runtime/issues/27592)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/runtime/issues/27592](https://github.com/dotnet/runtime/issues/27592)'
- en: 'For example, in the database, the maximum length of a product name is 40, and
    the value cannot be null, as shown highlighted in the following **data definition
    language** (**DDL**) code from the `Northwind4SQLite.sql` script file, which defines
    how to create a table named `Products` with its columns, data types, keys, and
    other constraints:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在数据库中，产品名称的最大长度为40，且值不能为空，如下面从`Northwind4SQLite.sql`脚本文件中高亮显示的**数据定义语言**（**DDL**）代码所示，该代码定义了如何创建名为`Products`的表及其列、数据类型、键和其他约束：
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a `Product` class, we could apply attributes to specify this, as shown in
    the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`Product`类中，我们可以通过属性来指定这一点，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When there isn’t an obvious map between .NET types and database types, an attribute
    can be used.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET类型和数据库类型之间没有明显的映射时，可以使用属性。
- en: 'For example, in the database, the column type of `UnitPrice` for the `Products`
    table is `money`. .NET does not have a `money` type, so it should use `decimal`
    instead, as shown in the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在数据库中，`Products`表的`UnitPrice`列的类型是`money`。.NET没有`money`类型，因此应使用`decimal`代替，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the EF Core Fluent API to define the model
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EF Core Fluent API定义模型
- en: 'The last way that the model can be defined is by using the Fluent API. This
    API can be used instead of attributes, as well as in addition to them. For example,
    to define the `ProductName` property, instead of decorating the property with
    two attributes, an equivalent Fluent API statement could be written in the `OnModelCreating`
    method of the database context class, as shown in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以定义的最后一种方式是使用Fluent API。此API可以用作属性替代，也可以与属性一起使用。例如，要定义`ProductName`属性，而不是用两个属性装饰该属性，可以在数据库上下文类的`OnModelCreating`方法中编写等效的Fluent
    API语句，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This keeps the entity model class simpler.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得实体模型类更加简单。
- en: Understanding data seeding with the Fluent API
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Fluent API理解数据初始化
- en: Another benefit of the Fluent API is to provide initial data to populate a database.
    EF Core automatically works out which insert, update, or delete operations must
    be executed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent API的另一个好处是提供初始数据以填充数据库。EF Core会自动确定必须执行哪些插入、更新或删除操作。
- en: 'For example, if we wanted to make sure that a new database had at least one
    row in the `Products` table, then we would call the `HasData` method, as shown
    in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想确保新数据库在 `Products` 表中至少有一行，那么我们会调用 `HasData` 方法，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Calls to `HasData` take effect either during a data migration executed by the
    command `dotnet ef database update` or when you call the `Database.EnsureCreated`
    method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasData` 方法的调用在执行 `dotnet ef database update` 命令进行的数据迁移期间生效，或者当您调用 `Database.EnsureCreated`
    方法时。'
- en: Our model will map to an existing database that is already populated with data,
    so we will not need to use this technique in our code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式将映射到一个已经填充了数据的现有数据库，因此我们不需要在我们的代码中使用此技术。
- en: Building EF Core models for the Northwind tables
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Northwind 表的 EF Core 模型
- en: Now that you’ve learned about the ways to define EF Core models, let’s build
    models to represent two of the tables in the `Northwind` database. For reuse,
    we will do this in a separate class library project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了定义 EF Core 模型的方法，让我们构建模型来表示 `Northwind` 数据库中的两个表。为了重用，我们将在一个单独的类库项目中完成此操作。
- en: 'The two entity classes will refer to each other, so to avoid compiler errors,
    we will create the classes without any members first:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实体类将相互引用，为了避免编译错误，我们首先创建没有任何成员的类：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下面的列表所示：
- en: '**Project template**: **Class Library** / `classlib`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目模板**：**类库** / `classlib`'
- en: '**Project file and folder**: `Northwind.EntityModels`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目文件和文件夹**：`Northwind.EntityModels`'
- en: '**Solution file and folder**: `Chapter10`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案文件和文件夹**：`Chapter10`'
- en: In the `Northwind.EntityModels` project, delete the file named `Class1.cs` and
    then add two class files named `Category.cs` and `Product.cs`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.EntityModels` 项目中，删除名为 `Class1.cs` 的文件，然后添加两个名为 `Category.cs` 和
    `Product.cs` 的类文件。
- en: 'In `Category.cs`, define a class named `Category`, as shown in the following
    code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Category.cs` 文件中，定义一个名为 `Category` 的类，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `Product.cs`, define a class named `Product`, as shown in the following
    code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Product.cs` 文件中，定义一个名为 `Product` 的类，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `WorkingWithEFCore` project, add a project reference to the `Northwind.EntityModels`
    project, as shown in the following markup:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithEFCore` 项目中，将 `Northwind.EntityModels` 项目添加为项目引用，如下面的标记所示：
- en: '[PRE19]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The project reference path and filename must all go on one line.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 项目引用路径和文件名必须都在一行上。
- en: Build the `WorkingWithEFCore` project.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建名为 `WorkingWithEFCore` 的项目。
- en: Defining the Category and Product entity classes
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类别和产品实体类
- en: 'The `Category` class, also known as an entity model, will be used to represent
    a row in the `Categories` table. This table has four columns, as shown in the
    following DDL taken from the `Northwind4SQLite.sql` script file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category` 类，也称为实体模型，将用于表示 `Categories` 表中的一行。该表有四个列，如下面的 DDL 所示，该 DDL 来自 `Northwind4SQLite.sql`
    脚本文件：'
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will use conventions to define the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用约定来定义以下内容：
- en: Three of the four properties (we will not map the `Picture` column)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个属性中的三个（我们不会映射 `Picture` 列）
- en: The primary key
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键
- en: The one-to-many relationship to the `Products` table
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `Products` 表的一对多关系
- en: To map the `Description` column to the correct database type, we will need to
    decorate the `string` property with the `Column` attribute.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `Description` 列映射到正确的数据库类型，我们需要用 `Column` 属性装饰 `string` 属性。
- en: Later in this chapter, we will use the Fluent API to define that `CategoryName`
    cannot be null and is limited to a maximum of 15 characters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将使用 Fluent API 定义 `CategoryName` 不能为空且最多为 15 个字符的限制。
- en: 'Let’s go:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'In the `Northwind.EntityModels` project, modify the `Category` entity model
    class, as shown highlighted in the following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.EntityModels` 项目中，修改 `Category` 实体模型类，如下面的代码所示（已突出显示）：
- en: '[PRE21]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The `Category` class will be in the `Northwind.EntityModels` namespace.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category` 类将位于 `Northwind.EntityModels` 命名空间中。'
- en: The `CategoryId` property follows the primary key naming convention, so it will
    be mapped to a column marked as the primary key with an index.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryId` 属性遵循主键命名约定，因此它将被映射到一个标记为主键并带有索引的列。'
- en: The `CategoryName` property maps to a column that does not allow database NULL
    values, so it is a non-nullable string. To disable nullability warnings, we have
    assigned the null-forgiving operator.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryName` 属性映射到一个不允许数据库 NULL 值的列，因此它是一个不可为空的字符串。为了禁用可空性警告，我们已分配了 null-forgiving
    操作符。'
- en: The `Description` property maps to a column with the `ntext` data type instead
    of the default mapping for `string` values to `nvarchar`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`属性映射到一个具有`ntext`数据类型的列，而不是默认将`string`值映射到`nvarchar`。'
- en: We initialize the collection of `Product` objects to a new, empty `HashSet`.
    A hash set is more efficient than a list because it is unordered. If you do not
    initialize `Products`, then it will be null and if you try to get its `Count`,
    then you will get an exception.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`Product`对象集合初始化为一个新的空`HashSet`。哈希集比列表更有效，因为它是无序的。如果你不初始化`Products`，那么它将是null，如果你尝试获取它的`Count`，那么你会得到一个异常。
- en: 'Modify the `Product` class, as shown highlighted in the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Product`类，如下所示：
- en: '[PRE22]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The `Product` class will be used to represent a row in the `Products` table,
    which has 10 columns.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`类将用于表示`Products`表中的一行，该表有10列。'
- en: 'You do not need to include all columns from a table as properties of a class.
    We will only map six properties: `ProductId`, `ProductName`, `UnitPrice`, `UnitsInStock`,
    `Discontinued`, and `CategoryId`.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要将表中的所有列都作为类的属性。我们将只映射六个属性：`ProductId`、`ProductName`、`UnitPrice`、`UnitsInStock`、`Discontinued`和`CategoryId`。
- en: Columns that are not mapped to properties cannot be read or set using the class
    instances. If you use the class to create a new object, then the new row in the
    table will have `NULL` or some other default value for the unmapped column values
    in that row. You must make sure that those missing columns are optional or have
    default values set by the database, or else an exception will be thrown at runtime.
    In this scenario, the rows already have data values and I have decided that I
    do not need to read those values in this application.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有映射到属性的列无法使用类实例进行读取或设置。如果你使用该类创建一个新对象，那么表中的新行将为未映射的列值设置`NULL`或其他默认值。你必须确保那些缺失的列是可选的或者数据库已经设置了默认值，否则在运行时将抛出异常。在这种情况下，行已经存在数据值，我决定在这个应用程序中不需要读取这些值。
- en: We can rename a column by defining a property with a different name, like `Cost`,
    and then decorating the property with the `[Column]` attribute and specifying
    its column name, like `UnitPrice`.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个具有不同名称的属性来重命名一个列，例如`Cost`，然后使用`[Column]`属性装饰该属性并指定其列名，例如`UnitPrice`。
- en: The final property, `CategoryId`, is associated with a `Category` property that
    will be used to map each product to its parent category.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个属性`CategoryId`与一个`Category`属性相关联，该属性将用于将每个产品映射到其父类别。
- en: The two properties that relate to the two entities, `Category.Products` and
    `Product.Category`, are both marked as `virtual`. This allows EF Core to inherit
    and override the properties to provide extra features, such as lazy loading.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与两个实体相关的两个属性，`Category.Products`和`Product.Category`，都被标记为`virtual`。这允许EF Core继承并重写属性以提供额外功能，例如懒加载。
- en: Adding tables to the Northwind database context class
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Northwind数据库上下文类添加表
- en: Inside your `DbContext`-derived class, you must define at least one property
    of the `DbSet<T>` type. These properties represent the tables. To tell EF Core
    what columns each table has, the `DbSet<T>` properties use generics to specify
    a class that represents a row in the table. That entity model class has properties
    that represent its columns.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`DbContext`派生类中，你必须定义至少一个`DbSet<T>`类型的属性。这些属性代表表。为了告诉EF Core每个表有哪些列，`DbSet<T>`属性使用泛型来指定一个代表表中行的类。这个实体模型类具有代表其列的属性。
- en: The `DbContext`-derived class can optionally have an overridden method named
    `OnModelCreating`. This is where you can write Fluent API statements as an alternative
    to decorating your entity classes with attributes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从`DbContext`派生的类可以有一个可选的名为`OnModelCreating`的重写方法。在这里，你可以编写Fluent API语句，作为用属性装饰你的实体类的替代方案。
- en: 'Let’s write the code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码：
- en: 'In the `WorkingWithEFCore` project, modify the `NorthwindDb` class to add statements
    to define two properties for the two tables and an `OnModelCreating` method, as
    shown highlighted in the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithEFCore`项目中，修改`NorthwindDb`类以添加定义两个表属性和一个`OnModelCreating`方法的语句，如下所示：
- en: '[PRE23]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `decimal` type is not supported by the SQLite database provider for sorting
    and other operations. We can fix this by telling the model that `decimal` values
    can be treated as `double` values when using the SQLite database provider. This
    does not actually perform any conversion at runtime.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal`类型不支持SQLite数据库提供程序进行排序和其他操作。我们可以通过告诉模型在使用SQLite数据库提供程序时可以将`decimal`值视为`double`值来修复这个问题。这实际上在运行时不会执行任何转换。'
- en: Now that you have seen some examples of defining an entity model manually, let’s
    look at a tool that can do some of the work for you.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些手动定义实体模型的示例，让我们看看一个可以为你做些工作的工具。
- en: Setting up the dotnet-ef tool
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置dotnet-ef工具
- en: The .NET CLI tool named `dotnet` can be extended with capabilities useful for
    working with EF Core. It can perform design-time tasks like creating and applying
    migrations from an older model to a newer model and generating code for a model
    from an existing database.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`dotnet`的.NET CLI工具可以扩展用于与EF Core一起使用的功能。它可以执行设计时任务，如从旧模型创建并应用迁移到新模型，以及从现有数据库生成模型代码。
- en: 'The `dotnet-ef` command-line tool is not automatically installed. You must
    install this package as either a **global** or **local tool**. If you have already
    installed an older version of the tool, then you should update it to the latest
    version:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet-ef`命令行工具不是自动安装的。你必须将其作为**全局**或**本地**工具安装。如果你已经安装了该工具的旧版本，那么你应该将其更新到最新版本：'
- en: 'At a command prompt or terminal, check if you have already installed `dotnet-ef`
    as a global tool, as shown in the following command:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，检查你是否已经安装了`dotnet-ef`作为全局工具，如下所示命令：
- en: '[PRE24]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check in the list if an older version of the tool has been installed, like
    the one for .NET 7, as shown in the following output:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中检查是否已安装该工具的旧版本，例如.NET 7的版本，如下所示输出：
- en: '[PRE25]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If an old version is already installed, then update the tool, as shown in the
    following command:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经安装了旧版本，请按照以下命令更新工具：
- en: '[PRE26]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If it is not already installed, then install the latest version, as shown in
    the following command:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未安装，请按照以下命令安装最新版本：
- en: '[PRE27]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If necessary, follow any OS-specific instructions to add the `dotnet tools`
    directory to your `PATH` environment variable, as described in the output of installing
    the `dotnet-ef` tool.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，遵循任何特定于操作系统的说明将`dotnet tools`目录添加到你的`PATH`环境变量中，如安装`dotnet-ef`工具的输出所述。
- en: 'By default, the latest GA release of .NET will be used to install the tool.
    To explicitly set a version, for example, to use a preview, add the `--version`
    switch. As another example, to update to the latest .NET 9 preview version available
    from February 2024 to October 2024, use the following command with a version wildcard:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，将使用最新的GA版本安装工具。要显式设置版本，例如，使用预览版，请添加`--version`开关。作为另一个例子，要更新到2024年2月至10月可用的最新.NET
    9预览版本，请使用以下带有版本通配符的命令：
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once the .NET 9 GA release happens in November 2024, you can just use the command
    without the `--version` switch to upgrade.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在2024年11月.NET 9 GA版本发布，你只需使用不带`--version`开关的命令即可升级。
- en: 'You can also remove the tool, as shown in the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按照以下命令删除工具：
- en: '[PRE29]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Scaffolding models using an existing database
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有数据库构建模型框架
- en: Scaffolding is the process of using a tool to create classes that represent
    the model of an existing database using reverse engineering. A good scaffolding
    tool allows you to extend the automatically generated classes because they are
    `partial` and then regenerate those classes without losing your `partial` classes.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是使用工具通过逆向工程创建表示现有数据库模型的类的过程。一个好的框架工具允许你扩展自动生成的类，因为它们是`partial`的，然后在不丢失你的`partial`类的情况下重新生成这些类。
- en: If you know that you will never regenerate the classes using the tool, then
    feel free to change the code for the automatically generated classes as much as
    you want. The code generated by the tool is just the best approximation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定永远不会使用该工具重新生成类，那么你可以随意修改自动生成的类的代码，想改多少就改多少。工具生成的代码只是最佳近似。
- en: '**Good Practice**: Do not be afraid to overrule a tool when you know better.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当你知道得更多时，不要害怕推翻工具。'
- en: The instructions in this section apply to any data provider, not just SQLite.
    Whatever data provider you use, you will need to add a reference to the `Microsoft.EntityFrameworkCore.Design`
    package.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的说明适用于任何数据提供者，而不仅仅是 SQLite。无论您使用哪种数据提供者，您都需要添加对 `Microsoft.EntityFrameworkCore.Design`
    包的引用。
- en: 'Let’s see if the tool generates the same model as we did manually:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看工具生成的模型是否与我们手动生成的相同：
- en: 'Add the latest version of the `Microsoft.EntityFrameworkCore.Design` package
    to the `WorkingWithEFCore` project, as shown highlighted in the following markup:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Microsoft.EntityFrameworkCore.Design` 包的最新版本添加到 `WorkingWithEFCore` 项目中，如下所示高亮显示的标记：
- en: '[PRE30]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**More Information**: If you are unfamiliar with how packages like `Microsoft.EntityFrameworkCore.Design`
    can manage their assets, then you can learn more at the following link:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：如果您不熟悉像 `Microsoft.EntityFrameworkCore.Design` 这样的包如何管理其资产，您可以在以下链接中了解更多信息：'
- en: '[https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)'
- en: Build the `WorkingWithEFCore` project to restore packages.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `WorkingWithEFCore` 项目以还原包。
- en: 'Start a command prompt or terminal in the `WorkingWithEFCore` project folder.
    Here is an example:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithEFCore` 项目文件夹中启动命令提示符或终端。以下是一个示例：
- en: If you are using Visual Studio, in **Solution Explorer**, right-click the `WorkingWithEFCore`
    project and select **Open in Terminal**.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Visual Studio，在 **解决方案资源管理器** 中，右键单击 `WorkingWithEFCore` 项目，然后选择 **在终端中打开**。
- en: On Windows, start **File Explorer**, right-click the `WorkingWithEFCore` folder,
    and select **New Command Prompt at Folder** or **Open in Windows Terminal**.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，启动 **文件资源管理器**，右键单击 `WorkingWithEFCore` 文件夹，然后选择 **在此文件夹中新建命令提示符**
    或 **在 Windows 终端中打开**。
- en: On macOS, start **Finder**, right-click the `WorkingWithEFCore` folder, and
    select **New Terminal at Folder**.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，启动 **Finder**，右键单击 `WorkingWithEFCore` 文件夹，然后选择 **在文件夹中新建终端**。
- en: If you are using Rider, in **Solution Explorer**, right-click the `WorkingWithEFCore`
    project and select **Open In** | **Terminal**.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Rider，在 **解决方案资源管理器** 中，右键单击 `WorkingWithEFCore` 项目，然后选择 **在** | **终端**
    中打开。
- en: '**Warning!** When I say the `WorkingWithEFCore` project folder, I mean the
    folder that contains the `WorkingWithEFCore.csproj` project file. If you enter
    the command in a folder that does not contain a project file, then you will see
    the following error: `No project was found. Change the current working directory
    or use the --project option`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 当我说 `WorkingWithEFCore` 项目文件夹时，我指的是包含 `WorkingWithEFCore.csproj` 项目文件的文件夹。如果您在不含项目文件的文件夹中输入命令，则会看到以下错误：`未找到项目。更改当前工作目录或使用
    --project 选项`。'
- en: '**Good Practice**: You are about to enter a long command. I recommend that
    you type from the print book or copy and paste long commands like this from the
    eBook into a plain text editor like Notepad. Then make sure that the whole command
    is properly formatted as a single line with correct spacing. Only then should
    you copy and paste it into the command prompt or terminal. Copying and pasting
    directly from the eBook is likely to include newline characters and missing spaces
    that break the command if you aren’t careful. Also, remember that all commands
    are available to copy at [https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md](https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md).
    **Warning!** If you copy from a PDF, double-dashes in a command link are sometimes
    lost, so be careful!'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您即将输入一个长命令。我建议您从打印书籍中输入，或者从电子书复制并粘贴此类长命令到纯文本编辑器（如记事本）。然后确保整个命令作为一个单行正确格式化，并具有正确的间距。只有在这种情况下，您才应该将其复制并粘贴到命令提示符或终端。如果直接从电子书复制粘贴，很可能会包含换行符和缺失的空格，这可能会破坏命令，如果您不小心的话。另外，请记住，所有命令都可以在
    [https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md](https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md)
    复制。**警告！** 如果您从 PDF 中复制，命令链接中的双短横线有时会丢失，所以请小心！'
- en: 'At a command prompt or terminal, use the `dotnet-ef` tool to generate a model
    for the `Categories` and `Products` tables in a new folder named `AutoGenModels`,
    as shown in the following command:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，使用 `dotnet-ef` 工具在名为 `AutoGenModels` 的新文件夹中为 `Categories` 和 `Products`
    表生成模型，如下所示命令：
- en: '[PRE31]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: 'The command action: `dbcontext scaffold`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令操作：`dbcontext scaffold`
- en: 'The connection string: `"Data Source=Northwind.db"`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接字符串："Data Source=Northwind.db"
- en: 'The database provider: `Microsoft.EntityFrameworkCore.Sqlite`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库提供程序：`Microsoft.EntityFrameworkCore.Sqlite`
- en: 'The tables to generate models for: `--table Categories --table Products`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要生成模型表的：`--table Categories --table Products`
- en: 'The output folder: `--output-dir AutoGenModels`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出文件夹：`--output-dir AutoGenModels`
- en: 'The namespace: `--namespace WorkingWithEFCore.AutoGen`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：`--namespace WorkingWithEFCore.AutoGen`
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用数据注释以及Fluent API：`--data-annotations`
- en: 'To rename the context from `[database_name]Context`: `--context NorthwindDb`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重命名上下文从`[database_name]Context`：`--context NorthwindDb`
- en: 'If you prefer to use SQL Server, then the equivalent command is found at the
    following link:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用SQL Server，则等效命令可在以下链接中找到：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#scaffolding-models-using-an-existing-database](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#scaffolding-models-using-an-existing-database)'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#scaffolding-models-using-an-existing-database](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#scaffolding-models-using-an-existing-database)'
- en: 'Note the build messages and warnings, as shown in the following output:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下构建信息和警告，如下面的输出所示：
- en: '[PRE32]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reviewing the scaffolded code
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查生成的代码
- en: 'Now let’s review the scaffolded code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来检查生成的代码：
- en: 'In the `AutoGenModels` folder, note the three class files that were automatically
    generated: `Category.cs`, `NorthwindDb.cs`, and `Product.cs`.'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AutoGenModels`文件夹中，注意自动生成的三个类文件：`Category.cs`、`NorthwindDb.cs`和`Product.cs`。
- en: 'In the `AutoGenModels` folder, in `Category.cs`, note the differences compared
    to the one you created manually. I have not included namespace imports to save
    space, as shown in the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AutoGenModels`文件夹中，在`Category.cs`中，注意与您手动创建的版本之间的差异。我没有包含命名空间导入以节省空间，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下：
- en: It decorates the entity class with the `[Index]` attribute, which was introduced
    in EF Core 5\. This indicates properties that should have an index when using
    the Code First approach to generate a database at runtime. Since we are using
    Database First with an existing database, this is not needed. But if we wanted
    to recreate a new, empty database from our code, then this information would be
    needed.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用在EF Core 5中引入的`[Index]`属性装饰实体类，这表示在运行时使用Code First方法生成数据库时应具有索引的属性。由于我们使用的是具有现有数据库的Database
    First，因此这不需要。但如果我们要从我们的代码中重新创建一个新的空数据库，则需要这些信息。
- en: The table name in the database is `Categories` but the `dotnet-ef` tool uses
    the **Humanizer** third-party library to automatically singularize the class name
    to `Category`, which is a more natural name when creating a single entity that
    represents a row in the table.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中的表名为`Categories`，但`dotnet-ef`工具使用**Humanizer**第三方库自动将类名单数化到`Category`，这在创建表示表中行的单个实体时是一个更自然的名称。
- en: The entity class is declared using the `partial` keyword so that you can create
    a matching `partial` class for adding additional code. This allows you to rerun
    the tool and regenerate the entity class without losing that extra code.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体类使用`partial`关键字声明，这样您就可以创建一个匹配的`partial`类来添加额外的代码。这允许您重新运行工具并重新生成实体类，而不会丢失那些额外的代码。
- en: The `CategoryId` property is decorated with the `[Key]` attribute to indicate
    that it is the primary key for this entity. The data type for this property is
    `int` for SQLite and `long` for SQL Server. We did not need to decorate the property
    in our code because we followed the naming primary key convention.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryId`属性被`[Key]`属性装饰，以指示它是此实体的主键。此属性的数据库类型对于SQLite是`int`，对于SQL Server是`long`。我们不需要在我们的代码中装饰属性，因为我们遵循了命名主键约定。'
- en: The `CategoryName` property is decorated with the `[Column(TypeName = "nvarchar
    (15)")]` attribute, which is only needed if you want to generate a database from
    the model.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryName`属性被`[Column(TypeName = "nvarchar (15)")]`属性装饰，这只有在您想从模型生成数据库时才需要。'
- en: We chose not to include the `Picture` column as a property because this is a
    binary object that we will not use in our console app.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择不包含`Picture`列作为属性，因为这是一个二进制对象，我们不会在我们的控制台应用程序中使用。
- en: The `Products` property uses the `[InverseProperty]` attribute to define the
    foreign key relationship to the `Category` property on the `Product` entity class,
    and it initializes the collection to a new empty list.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Products` 属性使用 `[InverseProperty]` 属性来定义与 `Product` 实体类上的 `Category` 属性的外键关系，并将其初始化为一个新的空列表。'
- en: In the `AutoGenModels` folder, in `Product.cs`, note the differences compared
    to the one you created manually.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AutoGenModels` 文件夹中，在 `Product.cs` 中，注意与你自己手动创建的版本相比的不同之处。
- en: 'In the `AutoGenModels` folder, in `NorthwindDb.cs`, note the differences compared
    to the one you created manually, as shown in the following edited-for-space code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AutoGenModels` 文件夹中，在 `NorthwindDb.cs` 中，注意与你自己手动创建的版本相比的不同之处，如下面的编辑后的代码所示：
- en: '[PRE34]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The `NorthwindDb` data context class is `partial` to allow you to extend it
    and regenerate it in the future.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NorthwindDb` 数据上下文类是 `partial` 的，以便你可以扩展它并在将来重新生成它。'
- en: 'It has two constructors: a default parameter-less one and one that allows options
    to be passed in. This is useful in apps where you want to specify the connection
    string at runtime.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有两个构造函数：一个默认的无参数构造函数和一个允许传递选项的构造函数。这在需要运行时指定连接字符串的应用程序中很有用。
- en: In the `OnConfiguring` method, if options have not been specified in the constructor,
    then it defaults to using a connection string that looks for the database file
    in the current folder. It has a compiler warning to remind you that you should
    not hardcode security information in this connection string.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `OnConfiguring` 方法中，如果构造函数中没有指定选项，则默认使用一个连接字符串，该字符串在当前文件夹中查找数据库文件。它有一个编译器警告来提醒你，你不应该在连接字符串中硬编码安全信息。
- en: In the `OnModelCreating` method, the Fluent API is used to configure the two
    entity classes, and then a `partial` method named `OnModelCreatingPartial` is
    invoked. This allows you to implement that `partial` method in your own `partial`
    `Northwind` class to add your own Fluent API configuration that will not be lost
    if you regenerate the model classes.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `OnModelCreating` 方法中，使用 Fluent API 配置两个实体类，然后调用一个名为 `OnModelCreatingPartial`
    的 `partial` 方法。这允许你在自己的 `partial` `Northwind` 类中实现该 `partial` 方法，以便添加你自己的 Fluent
    API 配置，这样在重新生成模型类时就不会丢失。
- en: Close the automatically generated class files.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭自动生成的类文件。
- en: Customizing the reverse engineering templates
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制反向工程模板
- en: One of the features introduced with EF Core 7 was the ability to customize the
    code that is automatically generated by the `dotnet-ef` scaffolding tool. This
    is an advanced technique, so I do not cover it in this book. Usually, it is easier
    to just modify the code that is generated by default anyway.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 7 引入的一个特性是能够自定义由 `dotnet-ef` 框架工具自动生成的代码。这是一个高级技术，所以我在这本书中没有涵盖它。通常，直接修改默认生成的代码会更简单。
- en: 'If you would like to learn how to modify the T4 templates used by the `dotnet-ef`
    scaffolding tool, then you can find that information at the following link:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解如何修改 `dotnet-ef` 框架工具使用的 T4 模板，那么你可以在此链接中找到相关信息：
- en: '[https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/templates](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/templates)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/templates](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/templates)'
- en: Configuring preconvention models
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置预约定模型
- en: Along with support for the `DateOnly` and `TimeOnly` types for use with the
    SQLite database provider, one of the features introduced with EF Core 6 was configuring
    preconvention models.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持与 SQLite 数据库提供程序一起使用的 `DateOnly` 和 `TimeOnly` 类型外，EF Core 6 引入的一个特性是配置预约定模型。
- en: As models become more complex, relying on conventions to discover entity types
    and their properties and successfully map them to tables and columns becomes harder.
    It would be useful if you could configure the conventions themselves before they
    are used to analyze and build a model.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模型变得更加复杂，依赖于约定来发现实体类型及其属性并将它们成功映射到表和列变得更加困难。如果在它们被用于分析和构建模型之前配置这些约定，将会很有用。
- en: 'For example, you might want to define a convention to say that all `string`
    properties should have a maximum length of 50 characters as a default, or any
    property types that implement a custom interface should not be mapped, as shown
    in the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想定义一个约定，即所有 `string` 属性默认最大长度为50个字符，或者任何实现自定义接口的属性类型不应进行映射，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the rest of this chapter, we will use the classes that you manually created.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用你手动创建的类。
- en: Querying EF Core models
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 EF Core 模型
- en: Now that we have a model that maps to the `Northwind` database and two of its
    tables, we can write some simple **Language-Integrated Query** (**LINQ**) queries
    to fetch data. You will learn much more about writing LINQ queries in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个映射到 `Northwind` 数据库及其两个表的模型，我们可以编写一些简单的 **语言集成查询**（**LINQ**）查询来获取数据。你将在
    *第 11 章*，*使用 LINQ 查询和操作数据* 中学习更多关于编写 LINQ 查询的内容。
- en: '**LINQ to Entities** (a.k.a. **LINQ to EF Core**) is a LINQ provider that converts
    a LINQ query into SQL to execute against the database. You can write a LINQ query
    built up over many C# statements.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**LINQ to Entities**（即 **LINQ to EF Core**）是一个 LINQ 提供程序，它将 LINQ 查询转换为 SQL
    以在数据库上执行。你可以编写一个由多个 C# 语句构建的 LINQ 查询。'
- en: You can discover the equivalent SQL statement without executing the query against
    the database by calling `ToQueryString`. This is known as deferred execution.
    Only when the query is enumerated using `foreach`, or when you call a method like
    `ToArray` or `ToList` on the LINQ query, will you trigger the execution of the
    query against the database and the results are returned to your code. This is
    known as **materialization**.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `ToQueryString` 来发现等效的 SQL 语句，而无需在数据库上执行查询。这被称为延迟执行。只有当使用 `foreach`
    枚举查询，或者当你在 LINQ 查询上调用 `ToArray` 或 `ToList` 等方法时，才会触发对数据库的查询执行，并将结果返回到你的代码中。这被称为
    **实体化**。
- en: 'For now, just write the code and view the results:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需编写代码并查看结果：
- en: In the `WorkingWithEFCore` project, add a new class file named `Program.Helpers.cs`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithEFCore` 项目中，添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with some methods, as
    shown in the following code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，添加一个部分 `Program` 类和一些方法，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Add a new class file named `Program.Queries.cs`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Queries.cs` 的新类文件。
- en: 'In `Program.Queries.cs`, define a partial `Program` class with a `QueryingCategories`
    method, and add statements to do these tasks, as shown in the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Queries.cs` 中，定义一个部分 `Program` 类和一个 `QueryingCategories` 方法，并添加执行这些任务的语句，如下面的代码所示：
- en: Create an instance of the `Northwind` class that will manage the database. Database
    context instances are designed for short lifetimes in a unit of work. They should
    be disposed of as soon as possible. So, we will wrap our instance in a `using`
    statement. In *Chapter 13*, *Building Websites Using ASP.NET Core*, you will learn
    how to get database context using dependency injection.
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Northwind` 类的实例来管理数据库。数据库上下文实例是为工作单元中的短生命周期设计的。它们应该尽快被销毁。因此，我们将我们的实例包裹在一个
    `using` 语句中。在 *第 13 章*，*使用 ASP.NET Core 构建网站* 中，你将学习如何使用依赖注入获取数据库上下文。
- en: Create a query for all categories that include their related products. `Include`
    is an extension method that requires you to import the `Microsoft.EntityFrameworkCore`
    namespace.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个查询，包括所有相关产品的所有类别。`Include` 是一个扩展方法，需要你导入 `Microsoft.EntityFrameworkCore`
    命名空间。
- en: 'Enumerate through the categories, outputting the name and number of products
    for each one:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历类别，输出每个类别的名称和产品数量：
- en: '[PRE37]'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the order of the clauses in the `if` statement is important. We must
    check that `categories` is `null` first. If this is `true`, then the code will
    never execute the second clause and, therefore, won’t throw a `NullReferenceException`
    when accessing the `Any()` member.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `if` 语句中子句的顺序很重要。我们必须首先检查 `categories` 是否为 `null`。如果是 `true`，则代码将永远不会执行第二个子句，因此，在访问
    `Any()` 成员时不会抛出 `NullReferenceException`。
- en: 'In `Program.cs`, comment out the two statements that create a `Northwind` instance
    and output the database provider name, and then call the `ConfigureConsole` and
    `QueryingCategories` methods, as shown in the following code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉创建 `Northwind` 实例并输出数据库提供程序名称的两个语句，然后调用 `ConfigureConsole`
    和 `QueryingCategories` 方法，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的部分输出所示：
- en: '[PRE39]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Warning!** If you see the following exception, the most likely problem is
    that the `Northwind.db` file is not being copied to the output directory: `Unhandled
    exception. Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1:
    ''no such table: Categories''`. Make sure that **Copy to Output Directory** is
    set, but even when it is, some code editors do not always copy the file when they
    should. You might need to manually copy the `Northwind.db` file to the appropriate
    directory.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**如果你看到以下异常，最可能的问题是`Northwind.db`文件没有被复制到输出目录：`未处理的异常。Microsoft.Data.Sqlite.SqliteException
    (0x80004005)：SQLite错误1：''没有这样的表：Categories''`。请确保已设置**复制到输出目录**，即使如此，一些代码编辑器也不总是应该在复制文件时复制文件。你可能需要手动将`Northwind.db`文件复制到适当的目录。'
- en: Filtering included entities
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤包含的实体
- en: 'EF Core 5 introduced **filtered includes**, which means you can specify a lambda
    expression in the `Include` method call to filter which entities are returned
    in the results:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 5引入了**过滤包含**，这意味着你可以在`Include`方法调用中指定一个lambda表达式，以过滤返回结果中的哪些实体：
- en: 'In `Program.Queries.cs`, define a `FilteredIncludes` method and add statements
    to do these tasks, as shown in the following code:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Queries.cs`中定义一个`FilteredIncludes`方法，并添加执行以下任务的语句，如下所示代码：
- en: Create an instance of the `Northwind` class that will manage the database.
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Northwind`类的实例，该实例将管理数据库。
- en: Prompt the user to enter a minimum value for units in stock.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示用户输入库存单位的最小值。
- en: Create a query for categories that have products with that minimum number of
    units in stock.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个查询，用于查找具有该最小库存单位数量的产品的类别。
- en: 'Enumerate through the categories and products, outputting the name and units
    in stock for each one:'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历类别和产品，输出每个产品的名称和库存单位：
- en: '[PRE40]'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `Program.cs`, call the `FilteredIncludes` method, as shown in the following
    code:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中调用`FilteredIncludes`方法，如下所示代码：
- en: '[PRE41]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the code, enter a minimum value for units in stock, like `100`, and view
    the result, as shown in the following partial output:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入库存单位的最小值，例如`100`，并查看以下部分输出结果：
- en: '[PRE42]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Unicode characters in the Windows console**: There is a limitation with the
    console provided by Microsoft on versions of Windows before the Windows 10 Fall
    Creators Update. By default, the console cannot display Unicode characters, for
    example, the ones in the name Rhönbräu.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows控制台中的Unicode字符**：在Windows 10 Fall Creators Update之前的Windows版本中，Microsoft提供的控制台存在一个限制。默认情况下，控制台无法显示Unicode字符，例如在名称Rhönbräu中的字符。'
- en: 'If you have this issue, then you can temporarily change the code page (also
    known as the character set) in a console to Unicode UTF-8 by entering the following
    command at the prompt before running the app:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有这个问题，那么你可以在运行应用程序之前，在提示符下输入以下命令临时更改代码页（也称为字符集）为Unicode UTF-8：
- en: '[PRE43]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Filtering and sorting products
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和排序产品
- en: 'Let’s explore a more complex query that will filter and sort data:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个更复杂的查询，该查询将过滤和排序数据：
- en: 'In `Program.Queries.cs`, define a `QueryingProducts` method, and add statements
    to do the following, as shown in the following code:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Queries.cs`中定义一个`QueryingProducts`方法，并添加执行以下任务的语句，如下所示代码：
- en: Create an instance of the `Northwind` class that will manage the database.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Northwind`类的实例，该实例将管理数据库。
- en: Prompt the user for a price for products.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示用户输入产品的价格。
- en: Create a query for products that cost more than the price using LINQ.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ创建一个查询，以查找价格高于指定价格的产品。
- en: 'Loop through the results, outputting the ID, name, cost (formatted in US dollars),
    and number of units in stock:'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历结果，输出ID、名称、成本（以美元格式化）和库存单位数量：
- en: '[PRE44]'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `Program.cs`, call the `QueryingProducts` method.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中调用`QueryingProducts`方法。
- en: 'Run the code, enter `50` when prompted to enter a product price, view the result,
    and note the descending order by cost, as shown in the following partial output:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，当提示输入产品价格时，输入`50`，查看结果，并注意成本的降序排列，如下所示部分输出结果：
- en: '[PRE45]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the code, enter `500` when prompted to enter a product price, and view
    the result, as shown in the following output:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，当提示输入产品价格时，输入`500`，并查看以下输出结果：
- en: '[PRE46]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Getting the generated SQL
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取生成的SQL
- en: 'You might be wondering how well written the SQL statements are that are generated
    from the C# queries we write. EF Core 5 introduced a quick and easy way to see
    the SQL generated:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们编写的C#查询生成的SQL语句编写得如何。EF Core 5引入了一种快速简单的方法来查看生成的SQL：
- en: 'In the `QueryingProducts` method, before using the `foreach` statement to enumerate
    the query, add a statement to output the generated SQL, as shown in the following
    code:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QueryingProducts`方法中，在使用`foreach`语句枚举查询之前，添加一个输出生成的SQL的语句，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Warning!** The `ToQueryString` method can only work on objects that implement
    `IQueryable`. This means that if you write a LINQ query using deferred methods
    like `Where`, `GroupBy`, `Select`, `OrderBy`, `Join`, `Take`, `Skip`, `Reverse`,
    and so on, then `ToQueryString` can show you the SQL before you run the query.
    But methods that return a non-`IQueryable` value and immediately execute the query,
    like a single scalar result like `Count()` or `First()`, do not support `ToQueryString`.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** `ToQueryString`方法只能用于实现`IQueryable`的对象。这意味着如果您使用`Where`、`GroupBy`、`Select`、`OrderBy`、`Join`、`Take`、`Skip`、`Reverse`等延迟方法编写LINQ查询，那么`ToQueryString`可以在您运行查询之前显示SQL。但是，返回非`IQueryable`值并立即执行查询的方法，如单个标量结果`Count()`或`First()`，不支持`ToQueryString`。'
- en: 'Run the code, enter a minimum value for units in stock, like `95`, and view
    the result, as shown in the following partial output:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入库存单位的最低值，例如`95`，并查看结果，如下面的部分输出所示：
- en: '[PRE48]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the SQL parameter named `@__stock_0` has been set to a minimum stock
    value of `95`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SQL参数`@__stock_0`已被设置为最低库存值`95`。
- en: 'If you used SQL Server, the generated SQL will be slightly different. For example,
    it uses square brackets instead of double quotes around object names, as shown
    in the following output:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用SQL Server，生成的SQL将略有不同。例如，它使用方括号而不是双引号来包围对象名称，如下面的输出所示：
- en: '[PRE49]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Logging EF Core
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录 EF Core
- en: To monitor the interaction between EF Core and the database, we can enable logging.
    Logging could be to the console, to `Debug` or `Trace`, or to a file. Enabling
    logging for EF Core shows all of the SQL commands that are actually executed against
    the database. `ToQueryString` does not execute against the database.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要监控EF Core与数据库之间的交互，我们可以启用日志记录。日志记录可以是到控制台、到`Debug`或`Trace`，或到文件。启用EF Core的日志记录将显示实际针对数据库执行的SQL命令。`ToQueryString`不会针对数据库执行。
- en: '**Good Practice**: By default, EF Core logging will exclude any data that is
    sensitive. You can include this data by calling the `EnableSensitiveDataLogging`
    method, especially during development. You should disable it before deploying
    to production. You can also call `EnableDetailedErrors`.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：默认情况下，EF Core日志将排除任何敏感数据。您可以通过调用`EnableSensitiveDataLogging`方法包括此数据，尤其是在开发期间。您应该在部署到生产之前禁用它。您还可以调用`EnableDetailedErrors`。'
- en: 'Let’s see an example of this in action:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动作的例子：
- en: 'In `NorthwindDb.cs`, at the bottom of the `OnConfiguring` method, add statements
    to log to the console and to include sensitive data like parameter values for
    commands being sent to the database if we compile the debug configuration, as
    shown in the following code:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NorthwindDb.cs`中，在`OnConfiguring`方法的底部添加语句以记录到控制台，并在编译调试配置时包括敏感数据，如发送到数据库的命令的参数值，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`LogTo` requires an `Action<string>` delegate. EF Core will call this delegate,
    passing a `string` value for each log message. Passing the `Console` class `WriteLine`
    method, therefore, tells the logger to write each method to the console.'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LogTo`需要一个`Action<string>`委托。EF Core将调用此委托，为每个日志消息传递一个`string`值。因此，传递`Console`类的`WriteLine`方法，因此，告诉记录器将每个方法写入控制台。'
- en: 'Note that when the solution configuration is **Debug**, the calls to the `EnableSensitiveDataLogging`
    and `EnableDetailedErrors` methods are included in the compilation, but if you
    change the solution configuration to **Release**, the method calls are grayed
    out to indicate that they are not compiled, as shown in *Figure 10.6*:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，当解决方案配置为**调试**时，对`EnableSensitiveDataLogging`和`EnableDetailedErrors`方法的调用包含在编译中，但如果将解决方案配置更改为**发布**，则方法调用将以灰色显示，表示它们未编译，如图*图10.6*所示：
- en: '![](img/B22322_10_06.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_10_06.png)'
- en: 'Figure 10.6: Including SQL parameters in logging for debug configuration'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：在调试配置中记录日志时包括SQL参数
- en: 'Run the code and view the log messages, which are shown in the following partial
    output:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看日志消息，如下面的部分输出所示：
- en: '[PRE51]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Your logs might vary from those shown above based on your chosen database provider
    and code editor, as well as future improvements to EF Core. For now, note that
    different events, like opening a connection or executing a command, have different
    event IDs, as shown in the following list:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你的日志可能与上面显示的日志不同，这取决于你选择的数据库提供程序和代码编辑器，以及 EF Core 的未来改进。目前请注意，不同的事件，如打开连接或执行命令，有不同的事件
    ID，如下面的列表所示：
- en: '`20000` `RelationalEventId.ConnectionOpening`: Includes the database file path'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`20000` `RelationalEventId.ConnectionOpening`：包括数据库文件路径'
- en: '`20001` `RelationalEventId.ConnectionOpened`: Includes the database file path'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`20001` `RelationalEventId.ConnectionOpened`：包括数据库文件路径'
- en: '`20100` `RelationalEventId.CommandExecuting`: Includes the SQL statement'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`20100` `RelationalEventId.CommandExecuting`：包括 SQL 语句'
- en: Filtering logs by provider-specific values
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过提供程序特定的值过滤日志
- en: 'The event ID values and what they mean will be specific to the EF Core provider.
    If we want to know how the LINQ query has been translated into SQL statements
    and is executing, then the event ID to output has an `Id` value of `20100`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 事件 ID 值及其含义将特定于 EF Core 提供程序。如果我们想了解 LINQ 查询是如何被转换为 SQL 语句并执行的，那么输出的事件 ID 应具有
    `Id` 值为 `20100`：
- en: 'At the top of `NorthwindDb.cs`, import the namespace for working for EF Core
    diagnostics, as shown in the following code:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NorthwindDb.cs` 的顶部，导入用于 EF Core 诊断工作的命名空间，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Modify the `LogTo` method call to only output events with an `Id` of `20100`,
    as shown highlighted in the following code:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LogTo` 方法调用修改为仅输出具有 `Id` 为 `20100` 的事件，如下面的代码中突出显示所示：
- en: '[PRE53]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the code and note the following SQL statements that were logged, as shown
    in the following output, which has been edited for space:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意以下已记录的 SQL 语句，如下面的输出所示，其中已编辑以节省空间：
- en: '[PRE54]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Logging with query tags
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询标签进行日志记录
- en: When logging LINQ queries, it can be tricky to correlate log messages in complex
    scenarios. EF Core 2.2 introduced the query tags feature to help by allowing you
    to add SQL comments to the log.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录 LINQ 查询时，在复杂场景中关联日志消息可能会很棘手。EF Core 2.2 引入了查询标签功能，通过允许你向日志添加 SQL 注释来提供帮助。
- en: 'You can annotate a LINQ query using the `TagWith` method, as shown in the following
    code:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `TagWith` 方法对 LINQ 查询进行注释，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will add an SQL comment to the log, as shown in the following output:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在日志中添加一个 SQL 注释，如下面的输出所示：
- en: '[PRE56]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Getting a single entity
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取单个实体
- en: 'There are two LINQ methods to get a single entity: `First` and `Single`. It
    is important to understand the difference between them when using an EF Core database
    provider. Let’s see an example:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种 LINQ 方法可以获取单个实体：`First` 和 `Single`。在使用 EF Core 数据库提供程序时，理解它们之间的区别非常重要。让我们看一个例子：
- en: 'In `Program.Queries.cs`, define a `GettingOneProduct` method, and add statements
    to do the following, as shown in the following code:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Queries.cs` 中定义一个 `GettingOneProduct` 方法，并添加以下语句，如下面的代码所示：
- en: Create an instance of the `Northwind` class that will manage the database.
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Northwind` 类的实例，该实例将管理数据库。
- en: Prompt the user for a product ID.
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示用户输入产品 ID。
- en: Create a query for products with that product ID using the `First` and `Single`
    methods.
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `First` 和 `Single` 方法创建一个具有该产品 ID 的产品查询。
- en: 'Write an SQL statement for each query to the console:'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个查询向控制台编写一个 SQL 语句：
- en: '[PRE57]'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: LINQ methods that fetch a single entity (`First`, `FirstOrDefault`, `Single`,
    `SingleOrDefault`, `ElementAt`, and `ElementAtOrDefault`) or return a single scalar
    value or entity like the aggregate methods (`Count`, `Sum`, `Max`, `Min`, `Average`,
    `All`, `Any`, and so on) are not deferred. When using the LINQ to Entities provider,
    any LINQ query that ends with a call to one of these methods is immediately converted
    to an SQL statement and executed against the database.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 获取单个实体（`First`、`FirstOrDefault`、`Single`、`SingleOrDefault`、`ElementAt` 和 `ElementAtOrDefault`）或返回单个标量值或实体的
    LINQ 方法（如聚合方法 `Count`、`Sum`、`Max`、`Min`、`Average`、`All`、`Any` 等）不是延迟执行的。当使用 LINQ
    to Entities 提供程序时，任何以调用这些方法之一结束的 LINQ 查询将立即转换为 SQL 语句并在数据库上执行。
- en: In `Program.cs`, call the `GettingOneProduct` method.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中调用 `GettingOneProduct` 方法。
- en: 'Run the code, enter `1` when prompted to enter a product ID, view the result,
    and note the SQL statements used by `First` and `Single`, as shown in the following
    output:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，当提示输入产品 ID 时输入 `1`，查看结果，并注意 `First` 和 `Single` 使用的 SQL 语句，如下面的输出所示：
- en: '[PRE58]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that both methods execute the same SQL statement except for the `LIMIT`
    clauses highlighted in the preceding code. For `First`, it sets `LIMIT 1` but
    for `Single`, it sets `LIMIT 2`. Why?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两种方法执行相同的 SQL 语句，除了前面代码中突出显示的 `LIMIT` 子句。对于 `First`，它设置 `LIMIT 1`，而对于 `Single`，它设置
    `LIMIT 2`。为什么？
- en: For `First`, the query can match one or more entities and only the first will
    be returned. If there are no matches, an exception is thrown, but you can call
    `FirstOrDefault` to return `null` if there are no matches.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `First`，查询可以匹配一个或多个实体，并且只返回第一个。如果没有匹配项，将抛出异常，但你可以在没有匹配项时调用 `FirstOrDefault`
    返回 `null`。
- en: For `Single`, the query must match only one entity and it will be returned.
    If there is more than one match, an exception must be thrown. But the only way
    for EF Core to know if there is more than one match is to request more than one
    and check. So, it has to set `LIMIT 2` and check if there is a second entity match.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Single`，查询必须仅匹配一个实体，并将返回。如果有多个匹配项，必须抛出异常。但 EF Core 知道是否有多个匹配项的唯一方法就是请求多个并检查。因此，它必须设置
    `LIMIT 2` 并检查是否有第二个实体匹配。
- en: '**Good Practice**: If you do not need to make sure that only one entity matches,
    use `First` instead of `Single` to avoid retrieving two records.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果你不需要确保只有一个实体匹配，请使用 `First` 而不是 `Single`，以避免检索两个记录。'
- en: Pattern matching with Like
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Like` 进行模式匹配
- en: 'EF Core supports common SQL statements, including `Like` for pattern matching:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 支持常见的 SQL 语句，包括用于模式匹配的 `Like`。
- en: 'In `Program.Queries.cs`, add a method named `QueryingWithLike`, as shown in
    the following code, and note the following:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Queries.cs` 中添加一个名为 `QueryingWithLike` 的方法，如下面的代码所示，并注意以下内容：
- en: We have enabled logging.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已启用日志记录。
- en: We prompt the user to enter part of a product name and then use the `EF.Functions.Like`
    method to search anywhere in the `ProductName` property.
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提示用户输入产品名称的一部分，然后使用 `EF.Functions.Like` 方法在 `ProductName` 属性中的任何位置进行搜索。
- en: 'For each matching product, we output its name, stock, and if it is discontinued:'
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个匹配的产品，我们输出其名称、库存以及是否已停售：
- en: '[PRE59]'
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In `Program.cs`, comment out the existing methods and call `QueryingWithLike`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉现有的方法并调用 `QueryingWithLike`。
- en: 'Run the code, enter a partial product name, such as `che`, and view the result,
    as shown in the following edited output:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入部分产品名称，例如 `che`，查看结果，如下面的编辑输出所示：
- en: '[PRE60]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**More Information**: You can learn more about wildcards with `Like` at [https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/like-entity-sql](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/like-entity-sql).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在 [https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/like-entity-sql](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/like-entity-sql)
    了解有关 `Like` 通配符的更多信息。'
- en: Generating a random number in queries
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在查询中生成随机数
- en: EF Core 6 introduced a useful function, `EF.Functions.Random`, that maps to
    a database function returning a pseudo-random real number between `0.0` and `1.0`,
    exclusive.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 6 引入了一个有用的函数，`EF.Functions.Random`，它映射到返回介于 `0.0` 和 `1.0` 之间（不包括 `1.0`）的伪随机实数的数据库函数。
- en: 'For example, suppose you’re developing a quiz or survey app that needs to display
    questions in a random order each time a user takes it. You can use `EF.Functions.Random()`
    to fetch a random selection of questions directly from the database, as shown
    in the following code:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在开发一个需要每次用户参与时显示随机顺序问题的测验或调查应用。你可以使用 `EF.Functions.Random()` 直接从数据库中获取随机选择的问题，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'During the development and testing phase, generating random data can be useful
    for simulating various scenarios. For example, creating randomized datasets for
    performance testing or generating random sets of rows for unit tests by selecting
    about half of the products randomly, as shown in the following code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和测试阶段，生成随机数据可以用于模拟各种场景。例如，创建用于性能测试的随机数据集或通过随机选择大约一半的产品来生成用于单元测试的随机行集，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Defining global filters
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义全局过滤器
- en: '`Northwind` products can be discontinued, so it might be useful to ensure that
    discontinued products are never returned in results, even if the programmer does
    not use `Where` to filter them out in their queries:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`Northwind` 产品可能会停售，因此确保停售的产品永远不会在结果中返回，即使程序员在查询中未使用 `Where` 过滤它们，可能也是有用的：'
- en: 'In `NorthwindDb.cs`, at the bottom of the `OnModelCreating` method, add a global
    filter to remove discontinued products, as shown in the following code:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NorthwindDb.cs` 文件中，在 `OnModelCreating` 方法的底部，添加一个全局过滤器以移除已停售的产品，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In `Program.cs`, uncomment the call to `QueryingWithLike`, and comment out all
    the other method calls.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，取消注释对 `QueryingWithLike` 的调用，并注释掉所有其他方法调用。
- en: 'Run the code, enter the partial product name `che`, view the result, and note
    that `Chef Anton''s Gumbo Mix` is now missing. This is because the SQL statement
    generated includes a filter for the `Discontinued` column, as shown highlighted
    in the following output:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入部分产品名称 `che`，查看结果，并注意 `Chef Anton's Gumbo Mix` 现在已缺失。这是因为生成的 SQL 语句包含一个针对
    `Discontinued` 列的过滤器，如下面的输出所示（已突出显示）：
- en: '[PRE64]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: SQL SELECT queries
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL SELECT 查询
- en: Usually, you can express all the queries you need to using LINQ. But for times
    when you cannot, you can use `FromSql` and its related methods.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以使用 LINQ 表达所有需要的查询。但在无法使用 LINQ 的情况下，你可以使用 `FromSql` 及其相关方法。
- en: '`FromSql` was introduced with EF Core 7\. If you need to execute raw SQL with
    EF Core 6 or earlier, then you must use the `FromSqlInterpolated` method.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromSql` 方法是在 EF Core 7 中引入的。如果你需要使用 EF Core 6 或更早版本执行原始 SQL，则必须使用 `FromSqlInterpolated`
    方法。'
- en: The `FromSql` method allows you to execute raw SQL queries against the database
    and map the results to your entity classes. `FromSql` can be used to perform `SELECT`
    queries that return entity types or types that are not part of the EF Core model.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromSql` 方法允许你在数据库上执行原始 SQL 查询并将结果映射到你的实体类。`FromSql` 可以用于执行返回实体类型或不是 EF Core
    模型一部分的类型的选择查询。'
- en: 'The `FromSql` method is particularly useful in the following situations:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromSql` 方法在以下情况下特别有用：'
- en: It allows you to run complex SQL queries that might not be feasible with LINQ.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你运行可能无法使用 LINQ 实现的复杂 SQL 查询。
- en: Sometimes, raw SQL can be more performant than LINQ for certain types of queries.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，对于某些类型的查询，原始 SQL 可能比 LINQ 更高效。
- en: If you are working with a legacy system where specific SQL queries need to be
    executed.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用需要执行特定 SQL 查询的遗留系统。
- en: You can execute stored procedures that return entities.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以执行返回实体的存储过程。
- en: The parameter to `FromSql` must be a `FormattableString`, not just a regular
    `string` value. This is to enforce safe parameterization. Pass parameter values
    using the interpolated `string` format.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromSql` 的参数必须是 `FormattableString`，而不仅仅是普通的 `string` 值。这是为了强制执行安全的参数化。使用插值
    `string` 格式传递参数值。'
- en: 'Let’s see some examples:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例：
- en: 'In `Program.Queries.cs`, add a method named `GetProductUsingSql`, as shown
    in the following code:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Queries.cs` 文件中，添加一个名为 `GetProductUsingSql` 的方法，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In `Program.cs`, add a call to `GetProductUsingSql`.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加对 `GetProductUsingSql` 的调用。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看输出，如下所示：
- en: '[PRE66]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`FromSql` can only be called on a `DbSet<T>`, not on a LINQ query.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromSql` 只能在 `DbSet<T>` 上调用，不能在 LINQ 查询上调用。'
- en: You can make the SQL even more dynamic for scenarios that need it. For example,
    if the name of a column might change, as well as the value, then you can use `FromSqlRaw`.
    But beware! You are responsible for ensuring this `string` value is secure, especially
    if it originates from an untrusted source. This involves identifying special characters
    like semicolons, comments, and other SQL constructs, and then properly escaping
    or rejecting these inputs to prevent potential security risks.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使 SQL 更加动态，以满足需要这种情况。例如，如果列的名称可能会改变，以及值，那么你可以使用 `FromSqlRaw`。但请注意！你必须确保这个
    `string` 值是安全的，特别是如果它来自不受信任的来源。这涉及到识别特殊字符，如分号、注释和其他 SQL 构造，然后正确地转义或拒绝这些输入，以防止潜在的安全风险。
- en: '**More Information**: You can learn more about dynamic SQL and parameters at
    [https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters](https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters).'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在 [https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters](https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters)
    了解更多关于动态 SQL 和参数的信息。'
- en: You’ve now seen many common ways to query data using EF Core. In some online
    sections, you can look at how data is loaded and tracked and why you might want
    to control how EF Core does that.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了使用 EF Core 查询数据的许多常见方法。在某些在线部分，你可以查看数据是如何加载和跟踪的，以及为什么你可能想要控制 EF Core
    如何执行这些操作。
- en: Practicing and exploring
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践以及更深入地研究本章主题来测试你的知识和理解。
- en: Exercise 10.1 – online materials
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.1 – 在线材料
- en: Online materials can be extra content written by me for this book, or they can
    be references to content created by Microsoft or third parties.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是专为这本书编写的额外内容，也可以是引用 Microsoft 或第三方创建的内容。
- en: Loading and tracking patterns with EF Core
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 EF Core 加载和跟踪模式
- en: 'Learn how data is loaded and tracked with EF Core at the following link:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中了解如何使用 EF Core 加载数据和跟踪：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-loading-tracking.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-loading-tracking.md)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-loading-tracking.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-loading-tracking.md)'
- en: Modifying data with EF Core
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 EF Core 修改数据
- en: 'Learn how data can be modified with EF Core at the following link:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中了解如何使用 EF Core 修改数据：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-modifying.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-modifying.md)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-modifying.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-modifying.md)'
- en: Working with transactions
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事务
- en: 'Add transactions to the modification code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改代码中添加事务：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-transactions.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-transactions.md)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-transactions.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-transactions.md)'
- en: Exploring a Code First EF Core model
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 Code First EF Core 模型
- en: 'Work through an example of a Code First model that generates an empty database,
    seeds it with sample data, and then queries the data:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个示例 Code First 模型来操作，该模型生成一个空数据库，用示例数据填充它，然后查询数据：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-code-first.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-code-first.md)'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-code-first.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-code-first.md)'
- en: Exploring app secrets
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索应用程序密钥
- en: When connecting to a database, you often need to include sensitive secret values
    like a username or password. These values should never be stored in source code
    or even in a separate file that might be added to a code repository.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到数据库时，你通常需要包括敏感的密钥值，如用户名或密码。这些值绝不应该存储在源代码中，甚至不应该存储在可能被添加到代码库的单独文件中。
- en: 'Secrets should be stored locally during development and in secure systems for
    production. You can use **Secret Manager** during local development and **Azure
    Key Vault** for cloud production systems. To learn more about app secrets, I have
    written an online-only section that you can read at the following link:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间，密钥应存储在本地，在生产环境中存储在安全系统中。在本地开发期间，你可以使用 **Secret Manager**，而在云生产系统中使用 **Azure
    Key Vault**。有关应用程序密钥的更多信息，我已编写了一个仅在以下链接中可读的在线部分：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-app-secrets.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-app-secrets.md)'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-app-secrets.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-app-secrets.md)'
- en: NoSQL databases
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NoSQL 数据库
- en: 'This chapter focused on RDBMSs such as SQL Server and SQLite. If you wish to
    learn more about NoSQL databases, such as Cosmos DB and MongoDB, and how to use
    them with EF Core, then I recommend the following links:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了如 SQL Server 和 SQLite 之类的 RDBMS。如果你希望了解更多关于 NoSQL 数据库（如 Cosmos DB 和 MongoDB）以及如何使用
    EF Core 与它们一起使用的信息，那么我推荐以下链接：
- en: '**Welcome to Azure Cosmos DB**: [https://learn.microsoft.com/en-us/azure/cosmos-db/introduction](https://learn.microsoft.com/en-us/azure/cosmos-db/introduction)'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欢迎使用 Azure Cosmos DB**：[https://learn.microsoft.com/en-us/azure/cosmos-db/introduction](https://learn.microsoft.com/en-us/azure/cosmos-db/introduction)'
- en: '**Use NoSQL databases as a persistence infrastructure**: [https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure](https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure)'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 NoSQL 数据库用作持久化基础设施**：[https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure](https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure)'
- en: '**Document database providers for Entity Framework Core**: [https://github.com/BlueshiftSoftware/EntityFrameworkCore](https://github.com/BlueshiftSoftware/EntityFrameworkCore)'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Entity Framework Core 数据库提供程序文档**：[https://github.com/BlueshiftSoftware/EntityFrameworkCore](https://github.com/BlueshiftSoftware/EntityFrameworkCore)'
- en: Exercise 10.2 – practice exercises
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.2 – 实践练习
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 实践练习深入探讨了本章的主题。
- en: Exporting data using different serialization formats
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不同的序列化格式导出数据
- en: In the `Chapter10` solution, create a console app named `Exercise_DataSerialization`
    that queries the `Northwind` database for all the categories and products, and
    then serializes the data using at least three formats of serialization available
    to .NET. Which format of serialization uses the least number of bytes?
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter10` 解决方案中，创建一个名为 `Exercise_DataSerialization` 的控制台应用程序，查询 `Northwind`
    数据库中的所有类别和产品，然后使用至少三种 .NET 可用的序列化格式进行数据序列化。哪种序列化格式使用的字节数最少？
- en: Exercise 10.3 – test your knowledge
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What type would you use for the property that represents a table, for example,
    the `Products` property of a database context?
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于表示表的属性的类型是什么，例如数据库上下文的 `Products` 属性？
- en: What type would you use for a property that represents a one-to-many relationship,
    for example, the `Products` property of a `Category` entity?
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于表示一对一关系的属性的类型是什么，例如 `Category` 实体的 `Products` 属性？
- en: What is the EF Core convention for primary keys?
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EF Core 的主键约定是什么？
- en: When might you use an annotation attribute in an entity class?
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实体类中何时可能使用注解属性？
- en: Why might you choose the Fluent API in preference to annotation attributes?
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你可能会选择 Fluent API 而不是注解属性？
- en: What does a transaction isolation level of `Serializable` mean?
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Serializable` 事务隔离级别意味着什么？'
- en: What does the `DbContext.SaveChanges()` method return?
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DbContext.SaveChanges()` 方法返回什么？'
- en: What is the difference between eager loading and explicit loading?
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预加载和显式加载之间有什么区别？
- en: How should you define an EF Core entity class to match the following table?
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义一个 EF Core 实体类以匹配以下表？
- en: '[PRE67]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: What benefit do you get from declaring entity navigation properties as `virtual`?
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明实体导航属性为 `virtual` 有什么好处？
- en: Exercise 10.4 – explore topics
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.4 – 探索主题
- en: 'Use this link to learn more about the topics covered in this chapter:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此链接了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-10---working-with-data-using-entity-framework-core](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-10---working-with-data-using-entity-framework-core)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-10---working-with-data-using-entity-framework-core](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-10---working-with-data-using-entity-framework-core)'
- en: Summary
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to do the following:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: Connect to and build entity data models for an existing database.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到现有数据库并构建实体数据模型。
- en: Execute a simple LINQ query and process the results.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个简单的 LINQ 查询并处理结果。
- en: Use filtered includes.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤的包含。
- en: Execute SQL queries directly.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接执行 SQL 查询。
- en: In the next chapter, you will learn how to write more advanced LINQ queries
    to select, filter, sort, join, and group.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何编写更高级的 LINQ 查询以选择、过滤、排序、连接和分组。
