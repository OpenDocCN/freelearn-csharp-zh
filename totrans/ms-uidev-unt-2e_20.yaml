- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Utilizing World Space UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用世界空间UI
- en: In [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), we discussed the three different
    Render Modes you can assign to a Canvas. We’ve used Screen Space-Overlay and Screen
    Space-Camera but haven’t used World Space yet. As described in [*Chapter 2*](B18327_02.xhtml#_idTextAnchor024),
    UI rendered in World Space is placed directly in the scene. We’ve already discussed
    the properties of World Space Canvas rendering, so this chapter will just look
    at when to use it and examples of implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18327_06.xhtml#_idTextAnchor085)中，我们讨论了您可以分配给画布的三个不同的渲染模式。我们已经使用了屏幕空间叠加和屏幕空间相机，但尚未使用世界空间。正如[*第2章*](B18327_02.xhtml#_idTextAnchor024)中所述，在世界空间中渲染的UI将直接放置在场景中。我们已经讨论了世界空间画布渲染的特性，因此本章将仅探讨何时使用它以及实现示例。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: When to use World Space UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用世界空间UI
- en: General techniques to consider when working with World Space UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理世界空间UI时需要考虑的一般技术
- en: Using World Space Canvases in a 2D game to create status indicators positioned
    relative to characters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2D游戏中使用世界空间画布创建相对于角色定位的状态指示器
- en: Using World Space Canvases to create health bars that hover over enemies’ heads
    in a 3D game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用世界空间画布在3D游戏中创建悬停在敌人头顶上的生命条
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2016](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2016)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2016](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2016)
- en: When to use World Space UI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用世界空间UI
- en: 'There are many reasons you may want to use a World Space Canvas. The most common
    reasons for using this render mode are the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想使用世界空间画布的许多原因。使用此渲染模式最常见的原因如下：
- en: To have better control of individual UI objects’ positions in relation to objects
    in the scene
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更好地控制单个UI对象相对于场景中对象的定位
- en: To rotate or curve UI elements
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了旋转或弯曲UI元素
- en: 'For example, the game *Mojikara: Japanese Trainer* uses World Space Canvases
    to have rotated Panels and keep UI objects, such as Text, attached to 3D objects.
    As you can see from the following screenshot, the Panel on the left is rotated
    just slightly in 3D space, because it is on a World Space Canvas:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，游戏*Mojikara: Japanese Trainer*使用世界空间画布来旋转面板并保持UI对象，如文本，附加到3D对象上。正如以下截图所示，左侧的面板在3D空间中略微旋转，因为它位于世界空间画布上：'
- en: '![Figure 16.1: Mojikara: Japanese Trainer (image provided by Lisa Walkosz-Migliacio,
    Intropy Games)](img/B18327_16_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1：Mojikara: Japanese Trainer（由Lisa Walkosz-Migliacio，Intropy Games提供）](img/B18327_16_01.jpg)'
- en: 'Figure 16.1: Mojikara: Japanese Trainer (image provided by Lisa Walkosz-Migliacio,
    Intropy Games)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '图16.1：Mojikara: Japanese Trainer（由Lisa Walkosz-Migliacio，Intropy Games提供）'
- en: Another example of rotated UI can be found in the game *Cloudbase Prime*, as
    shown in the following screenshot. It also used World Space rendering to create
    indicators that hover over objects and characters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个旋转UI的例子可以在游戏*Cloudbase Prime*中找到，如下面的截图所示。它也使用了世界空间渲染来创建悬停在对象和角色上的指示器。
- en: '![Figure 16.2: Cloudbase Prime (image provided by Tyrus Peace, Floating Island
    Games)](img/B18327_16_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2：Cloudbase Prime（由Tyrus Peace，Floating Island Games提供）](img/B18327_16_02.jpg)'
- en: 'Figure 16.2: Cloudbase Prime (image provided by Tyrus Peace, Floating Island
    Games)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：Cloudbase Prime（由Tyrus Peace，Floating Island Games提供）
- en: 'All the UI in *Cloudbase Prime* was done on World Space Canvases. This allowed
    the developer to create cool curving UI, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Cloudbase Prime*中的所有UI都是在世界空间画布上完成的。这使得开发者能够创建酷炫的弯曲UI，如下所示：
- en: '![Figure 16.3: Cloudbase Prime (image provided by Tyrus Peace, Floating Island
    Games)](img/B18327_16_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3：Cloudbase Prime（由Tyrus Peace，Floating Island Games提供）](img/B18327_16_03.jpg)'
- en: 'Figure 16.3: Cloudbase Prime (image provided by Tyrus Peace, Floating Island
    Games)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：Cloudbase Prime（由Tyrus Peace，Floating Island Games提供）
- en: 'Here, you can see how the UI looks in the Editor versus how it looks to the
    player. This gives a nice peek at how the UI was built:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到编辑器中的UI与玩家看到的UI之间的区别。这提供了一个很好的视角，了解UI是如何构建的：
- en: '![Figure 16.4: Cloudbase Prime (image provided by Tyrus Peace, Floating Island
    Games)](img/B18327_16_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4：Cloudbase Prime（由Tyrus Peace，Floating Island Games提供）](img/B18327_16_04.jpg)'
- en: 'Figure 16.4: Cloudbase Prime (image provided by Tyrus Peace, Floating Island
    Games)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4： Cloudbase Prime（由Tyrus Peace，Floating Island Games提供）
- en: 'I recommend checking out the following site to see more ways in which *Cloudbase
    Prime* has implemented World Space UI, as they are truly beautiful: [https://imgur.com/a/hxNgL](https://imgur.com/a/hxNgL).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您查看以下网站，以了解*Cloudbase Prime*如何实现世界空间UI的更多方式，因为它们确实很美：[https://imgur.com/a/hxNgL](https://imgur.com/a/hxNgL)。
- en: Another common usage of World Space UI is simulating computer screens and monitors
    within a scene. For example, I built the following UI for a friend’s VR game named
    *Cloud Rise*. The monitor was simulated by placing a World Space Canvas right
    on top of the in-game screen. I was then able to easily anchor and animate the
    UI; in the same way, I rendered the UI in Screen Space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 世界空间UI的另一种常见用法是在场景中模拟计算机屏幕和显示器。例如，我为朋友名为*Cloud Rise*的VR游戏构建了以下UI。显示器是通过将世界空间画布直接放置在游戏屏幕上方来模拟的。然后我能够轻松地锚定和动画化UI；同样，我在屏幕空间中渲染了UI。
- en: '![Figure 16.5: Cloud Rise (image provided by Meredith Wilson, Bedhouse Games)](img/B18327_16_05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5： Cloud Rise（由Meredith Wilson，Bedhouse Games提供）](img/B18327_16_05.jpg)'
- en: 'Figure 16.5: Cloud Rise (image provided by Meredith Wilson, Bedhouse Games)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5： Cloud Rise（由Meredith Wilson，Bedhouse Games提供）
- en: In general, the interactive UIs of VR games are on World Space Canvases since
    the player cannot interact with *the screen*. Common usages of VR UI are flat
    floating Panels or wrapping Panels.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，VR游戏的交互式UI位于世界空间画布上，因为玩家不能与*屏幕*进行交互。VR UI的常见用法是扁平的浮动面板或包裹面板。
- en: 'Hovering indicators are by far the most common use of World Space UI; they
    are specifically used for health bars over the heads of in-game characters, as
    shown in the following screenshot of *Iris Burning*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停指示器到目前为止是世界空间UI最常见的使用；它们专门用于游戏角色头顶上的生命条，如下面的*Iris Burning*截图所示：
- en: '![Figure 16.6: Iris Burning (image provided by William Preston, DCM Studios)](img/B18327_16_06.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6： Iris Burning（由William Preston，DCM Studios提供）](img/B18327_16_06.jpg)'
- en: 'Figure 16.6: Iris Burning (image provided by William Preston, DCM Studios)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6： Iris Burning（由William Preston，DCM Studios提供）
- en: Most people think of 3D games when they think of World Space UI because they
    think of UI that appears *far away*, but it is commonly used in 2D games as well!
    Management and RTS games use UI quite frequently to create buttons and progress
    bars, and other UI elements maintain their position with the object they interact
    with. The World Space UI can be on one Canvas that encompasses all items on the
    screen, with individual UI items matching the 2D World Space coordinates of the
    items they represent, or they can be on individual Canvases of their respective
    items. We will cover how to create a 2D game using World Space UI in an example
    at the end of the chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们想到世界空间UI时，通常会想到3D游戏，因为他们认为UI看起来*很远*，但它在2D游戏中也很常见！管理和RTS游戏经常使用UI来创建按钮和进度条，以及其他UI元素与它们交互的对象保持位置。世界空间UI可以位于一个包含屏幕上所有项目的画布上，单个UI项目与它们所代表的项目的2D世界空间坐标相匹配，或者它们可以位于各自项目的单个画布上。我们将在本章末尾的示例中介绍如何使用世界空间UI创建2D游戏。
- en: Now, let’s explore how to use World Space UI.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何使用世界空间UI。
- en: Appropriately scaling text in the Canvas
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中适当地缩放文本
- en: Whenever a Canvas is created, it is initialized with **Screen Space - Overlay**
    as its **Render Mode**. Therefore, when you change the **Render Mode** property
    to **World Space**, the Canvas will be huge in your scene.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建画布时，它都会以**屏幕空间 - 叠加**作为其**渲染模式**进行初始化。因此，当您将**渲染模式**属性更改为**世界空间**时，画布在场景中会变得很大。
- en: 'When you scale down the Canvas to the appropriate size in the scene, the text
    will likely be super blurry or not visible at all. Let’s say we created the following
    Canvas in **Screen Space - Overlay** but decided to put it in **World Space**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将画布在场景中缩放到适当的大小时，文本可能会非常模糊或根本不可见。假设我们在**屏幕空间 - 叠加**中创建了以下画布，但决定将其放置在**世界空间**中：
- en: '![Figure 16.7: A Canvas in Screen Space - Overlay](img/B18327_16_07.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7：屏幕空间中的画布 - 叠加](img/B18327_16_07.jpg)'
- en: 'Figure 16.7: A Canvas in Screen Space - Overlay'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：屏幕空间中的画布 - 叠加
- en: Converting it to `4` and `3` (since it was initially created with a 4:3 aspect
    ratio screen), the text will disappear!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为`4`和`3`（因为它最初是以4:3的屏幕宽高比创建的），文本将消失！
- en: '![Figure 16.8: A Canvas in Screen Space - Overlay](img/B18327_16_08.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8：屏幕空间中的画布 - 叠加](img/B18327_16_08.jpg)'
- en: 'Figure 16.8: A Canvas in Screen Space - Overlay'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：屏幕空间中的画布 - 叠加
- en: 'If I set the **Text** to allow **Horizontal Overflow** and **Vertical Overflow**
    you’ll see that it is huge when compared to the Canvas! In the following screenshot,
    the tiny rectangle in the middle is the Canvas:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将**文本**设置为允许**水平溢出**和**垂直溢出**，您会看到它与画布相比非常大。在下面的屏幕截图中的中间的小矩形是画布：
- en: '![Figure 16.9: World Space Canvas with huge overflowing text example](img/B18327_16_09.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9：带有大量溢出文本的世界空间画布示例](img/B18327_16_09.jpg)'
- en: 'Figure 16.9: World Space Canvas with huge overflowing text example'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：带有大量溢出文本的世界空间画布示例
- en: To fix this, and to get it looking the way we want, we need to adjust the `1`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，并使其看起来像我们想要的样子，我们需要调整`1`。
- en: Usually, to determine the new `905`, divide it by the new `4`, and enter that
    division in my `905/4` in the box will perform the calculation.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了确定新的`905`，将其除以新的`4`，然后在框中输入这个除法`905/4`将执行计算。）
- en: '![Figure 16.10: Dynamic Pixels Per Unit property adjusted](img/B18327_16_10.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10：动态每单位像素属性调整](img/B18327_16_10.jpg)'
- en: 'Figure 16.10: Dynamic Pixels Per Unit property adjusted'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：动态每单位像素属性调整
- en: 'However, that calculation didn’t get the exact look I was looking for. So,
    I increased the size until it looked right:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那个计算并没有得到我想要的精确外观。因此，我增加了大小，直到它看起来正确：
- en: '![Figure 16.11: Dynamic Pixels Per Unit property example in the Chapter16 scene](img/B18327_16_11.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11：第16章场景中动态每单位像素属性示例](img/B18327_16_11.jpg)'
- en: 'Figure 16.11: Dynamic Pixels Per Unit property example in the Chapter16 scene'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：第16章场景中动态每单位像素属性示例
- en: Every time you change the **Width** and **Height** of the Canvas, you will have
    to adjust the **Dynamic Pixels Per Unit** property. Decreasing the size of the
    Canvas will mean increasing the **Dynamic Pixels Per Unit** property, and increasing
    the size of the Canvas will mean decreasing the size of the **Dynamic Pixels Per**
    **Unit** property.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您更改画布的**宽度**和**高度**时，您都必须调整**动态每单位像素**属性。减小画布的大小意味着增加**动态每单位像素**属性，而增加画布的大小意味着减小**动态每单位**的**像素**属性。
- en: 'Here are two Canvases, both one-fourth the size of the one from the previous
    figure. In the top Canvas, I changed the `1` and `.75`. In the bottom Canvas,
    I changed the `0.25`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个画布，它们的大小都是前一个图中的四分之一。在上面的画布中，我改变了`1`和`.75`。在下面的画布中，我改变了`0.25`：
- en: '![Figure 16.12: Width and Height change examples](img/B18327_16_12.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12：宽度和高度更改示例](img/B18327_16_12.jpg)'
- en: 'Figure 16.12: Width and Height change examples'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：宽度和高度更改示例
- en: In the first example, since I changed the `350*4` in the `1400` for me (I love
    that Unity performs calculations in the boxes).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，因为我已经为我改变了`350*4`在`1400`（我喜欢Unity在框中进行计算）。
- en: However, in the second Canvas, I did not have to change the **Dynamic Pixels
    Per Unit** size, because scaling with the **Scale** property in this way does
    not require me to change it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第二个画布中，我并不需要改变**动态每单位像素**的大小，因为以这种方式使用**缩放**属性进行缩放不需要我改变它。
- en: The takeaway from this is that if your text isn’t displaying or looks incredibly
    blurry, adjust the **Dynamic Pixels Per Unit** property until it looks the way
    it should, or scale your Canvas by adjusting its **Scale** and not its **Width**
    and **Height**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看出，如果您的文本没有显示或看起来非常模糊，请调整**动态每单位像素**属性，直到它看起来应该是的样子，或者通过调整其**缩放**而不是**宽度**和**高度**来缩放您的画布。
- en: Text scaling will be the most important consideration with using World Space
    UI, but let’s review some other important topics.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用世界空间UI时，文本缩放将是最重要的考虑因素，但让我们回顾一些其他重要主题。
- en: Other considerations when working in World Space
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在世界空间中工作时需要考虑的其他因素
- en: For the most part, working with UI in World Space isn’t much different than
    working with UI in Screen or Camera Space. There are a few things you have to
    keep in mind, though.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，在世界空间中处理UI与在屏幕或相机空间中处理UI没有太大区别。尽管如此，您仍需注意一些事项。
- en: 'When working with 3D scenes, you may want your UI to always face the player,
    regardless of how the player turns the camera—this is known as a *billboard effect*.
    You can achieve this with a simple `LookAt()` function on the transform of the
    object in the `Update()` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理3D场景时，您可能希望UI始终面向玩家，无论玩家如何转动摄像头——这被称为**广告牌效果**。您可以通过在`Update()`函数中对对象的变换执行简单的`LookAt()`函数来实现这一点：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use a variation of the preceding code, depending on how you want the
    rotation to behave.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用前面代码的变体，具体取决于您希望旋转如何表现。
- en: Another consideration with 3D World Space UI is the distance it is away from
    the camera. You may want to have UI only render when it is a specific distance
    from the camera as it may be difficult to see when it is too far away.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D世界空间UI中，另一个需要考虑的是它与相机的距离。你可能希望UI仅在它距离相机特定距离时渲染，因为当它太远时可能难以看到。
- en: Depending on your project, using World Space Canvases may cause difficulties
    with Raycasting, making interacting with UI a problem. Tyrus Peace of Floating
    Island Games recommends creating your own physics layer if you end up having to
    create your own Raycasting system, as he did with *Cloudbase Prime*, shown earlier
    in the chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的项目，使用世界空间Canvas可能会导致与Raycasting的困难，使得与UI交互成为问题。Floating Island Games的Tyrus
    Peace建议，如果你最终需要创建自己的Raycasting系统，就像他在本章前面展示的*Cloudbase Prime*一样，创建自己的物理层。
- en: Examples
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'Working with World Space Canvases isn’t significantly different than working
    with Canvases in Screen and Camera Space. World Space Canvases offer many benefits.
    If you have an object that exists within your scene that has UI specifically tied
    to its location, it is helpful to use a World Space Canvas so that the UI follows
    it wherever it is. This removes the necessity of trying to convert the object’s
    World Space coordinates to Screen coordinates to ensure that the UI always lines
    up with the object. It also guarantees that the UI object will always display
    correctly with respect to the object’s location, even when the screen’s resolution
    changes. In this chapter, I will cover two common uses of World Space Canvases:
    one in 2D space and another in 3D space. Let’s begin with 2D space.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与世界空间Canvas一起工作与在屏幕和相机空间中与Canvas一起工作没有显著区别。世界空间Canvas提供了许多好处。如果你有一个存在于场景中的对象，并且UI专门与其位置相关联，使用世界空间Canvas非常有帮助，这样UI就可以跟随它无论它在哪里。这消除了尝试将对象的World
    Space坐标转换为Screen坐标以确保UI始终与对象对齐的需要。它还保证了UI对象将始终根据对象的位置正确显示，即使屏幕的分辨率发生变化。在本章中，我将介绍世界空间Canvas的两个常见用途：一个在2D空间中，另一个在3D空间中。让我们从2D空间开始。
- en: 2D World Space status indicators
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D世界空间状态指示器
- en: For this example, we will start a new scene. For you to not have to build out
    the scene, we will start with an Asset package that includes all the required
    items.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将开始一个新的场景。为了让你不必构建场景，我们将从一个包含所有必需项目的资产包开始。
- en: We’ll create UI that allows a character to have a status indicator pop up above
    his head. After the scene has played for 3 seconds, a status-indicating button
    will appear over the character’s head. Once the player clicks on the status indicator,
    a dialog will appear. After 5 seconds, the dialog will disappear. The status indicator
    will re-appear 10 seconds later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个UI，允许角色在其头顶上方弹出状态指示器。场景播放3秒后，将在角色头顶上方出现状态指示按钮。一旦玩家点击状态指示器，将出现一个对话框。5秒后，对话框将消失。状态指示器将在10秒后再次出现。
- en: '![Figure 16.13: 2D World Space UI example](img/B18327_16_13.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13：2D世界空间UI示例](img/B18327_16_13.jpg)'
- en: 'Figure 16.13: 2D World Space UI example'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：2D世界空间UI示例
- en: The art used in this example was accessed from [https://opengameart.org/content/medieval-rts-120](https://opengameart.org/content/medieval-rts-120).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中使用的艺术作品来自[https://opengameart.org/content/medieval-rts-120](https://opengameart.org/content/medieval-rts-120)。
- en: 'To create the status-indicating UI demonstrated by the previous example, complete
    the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建前一个示例中展示的状态指示UI，请完成以下步骤：
- en: Import the `Chapter 16` `- Example 1-Start.unitypackage` package. This package
    contains a scene with a background image and a 2D sprite named `Mage`. The `Assets/Scripts/MageInteractions.cs`
    script included with the package controls the timers on the appearance of the
    status indicator. This script requires two Canvas Group items—`theExclamationPoint`
    and `theDialogBox`—and contains a function, `ShowTheDialogBox()`, that can be
    called via a button’s `On` `Click()` event.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入“第16章”的`- Example 1-Start.unitypackage`包。此包包含一个带有背景图像和名为`Mage`的2D精灵的场景。包中包含的`Assets/Scripts/MageInteractions.cs`脚本控制状态指示器出现的计时器。此脚本需要两个Canvas
    Group项目——`theExclamationPoint`和`theDialogBox`——并包含一个名为`ShowTheDialogBox()`的函数，该函数可以通过按钮的`On`
    `Click()`事件调用。
- en: We want the status indicator and the dialog to be tied to the position of the
    `Mage` within the scene. Therefore, we will create a Canvas that is a child of
    the `Mage` in `Mage` in the Hierarchy and add a UI Canvas as a child of the `Mage`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望状态指示器和对话框与场景中“法师”的位置相关联。因此，我们将在“法师”的层级中创建一个Canvas，并将其作为“法师”的子Canvas添加UI
    Canvas。
- en: Select the newly created `Canvas`. Change the **Render Mode** on the **Canvas**
    component to **World Space**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新创建的`Canvas`。将**Canvas**组件上的**渲染模式**更改为**世界空间**。
- en: Assign the `Main Camera` to the **Event** **Camera** slot.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main Camera`分配到**事件** **相机**槽位。
- en: Since this `Canvas` is a child of `Mage`, its coordinate system is relative
    to the `Mage`. To have it perfectly positioned over the `Mage`, change the `0`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个`Canvas`是`Mage`的子对象，其坐标系相对于`Mage`。为了使其完美地位于`Mage`上方，将`0`更改为。
- en: The `Canvas` is significantly bigger than the `Mage`. Make the size more reasonable
    by changing the `1`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Canvas`比`Mage`大得多。通过将`1`更改为更合理的尺寸。'
- en: Now that we have the `Canvas` scaled and positioned in the scene around the
    `Mage`, we can add UI elements to it. Right-click on `Canvas` in the Hierarchy
    and create a UI Button. Name the new Button `Alert`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将`Canvas`缩放并定位在`Mage`周围的场景中，我们可以在其上添加UI元素。在层次结构中右键单击`Canvas`，创建一个UI按钮。将新按钮命名为`Alert`。
- en: Resize `Alert` to match the `Canvas` by setting its **Rect Transform** component’s
    stretch and anchor to stretch fully across the Canvas.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置其**Rect Transform**组件的拉伸和锚点来调整`Alert`的大小，使其与`Canvas`匹配。
- en: 'Change the `Alert` Button’s `Knob` image. It looks better as a circle than
    as the default button sprite:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Alert`按钮的`Knob`图像。它作为一个圆形比默认按钮精灵看起来更好：
- en: '![Figure 16.14: Selecting the UI Knob image](img/B18327_16_14.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图16.14：选择UI旋钮图像](img/B18327_16_14.jpg)'
- en: 'Figure 16.14: Selecting the UI Knob image'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：选择UI旋钮图像
- en: Change the `Text` child of `Alert` to display an exclamation point instead of
    `Button`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Alert`的`Text`子对象更改为显示感叹号而不是`Button`。
- en: The Button’s text is not currently visible. To fix this, change the `1000`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮的文本目前不可见。为了修复这个问题，将`1000`更改为。
- en: Move the `Alert` Button so that it is positioned over the `Mage`’s head.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Alert`按钮移动到位于Mage头部的位置。
- en: '![Figure 16.15: Moving the exclamation point over the Mage’s head](img/B18327_16_15.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图16.15：将感叹号移动到Mage的头上](img/B18327_16_15.jpg)'
- en: 'Figure 16.15: Moving the exclamation point over the Mage’s head'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：将感叹号移动到Mage的头上
- en: Add a `Alert` Button.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Alert`按钮。
- en: Set the `0` and set both the `False`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0`设置为`False`，并将两个都设置为`False`。
- en: 'Give the `Alert` Button an `ShowTheDialogBox()` function on the `MageInteractions`
    script attached to the `Mage`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`Mage`上附加的`MageInteractions`脚本中的`Alert`按钮一个`ShowTheDialogBox()`函数：
- en: '![Figure 16.16: The On Click() event of the Alert Button](img/B18327_16_16.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16：Alert按钮的OnClick()事件](img/B18327_16_16.jpg)'
- en: 'Figure 16.16: The On Click() event of the Alert Button'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：Alert按钮的OnClick()事件
- en: Right-click on `Canvas` in the Hierarchy and create a UI Text object. Name the
    new Text object `Dialog`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中右键单击`Canvas`，创建一个UI文本对象。将新文本对象命名为`Dialog`。
- en: Resize the `Dialog` object to match the `Canvas` by setting its `Canvas`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置其`Canvas`来调整`Dialog`对象的大小，使其与`Canvas`匹配。
- en: Change the `Dialog` object to say `Thanks!!!`. Also, center-align the text and
    set the **Horizontal Overflow** property to **Overflow**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Dialog`对象更改为显示`Thanks!!!`。同时，将文本居中对齐，并将**水平溢出**属性设置为**溢出**。
- en: 'Move the `Dialog` object so that it is positioned above the head of the `Mage`,
    like so:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Dialog`对象移动到位于Mage头部上方，如下所示：
- en: '![Figure 16.17: The Dialog box](img/B18327_16_17.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图16.17：对话框](img/B18327_16_17.jpg)'
- en: 'Figure 16.17: The Dialog box'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：对话框
- en: Add a `Dialog` Text object.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Dialog`文本对象。
- en: Set the `0` and set both the `False`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0`设置为`False`，并将两个都设置为`False`。
- en: Select the `Mage` and add `Alert` to the `Dialog` to the **The Dialog** **Box**
    property.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Mage`并将`Alert`添加到**对话框** **框**属性中的`Dialog`。
- en: If you play the game, you’ll see the exclamation point Button appear after 3
    seconds. Clicking on the Button will make the Text appear. Try moving the Mage
    character around in the scene. You’ll see that no matter where he is, the exclamation
    point Button and Text appear over his head. This is a really helpful technique
    for creating UI elements that stay with moving characters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩游戏，你会看到3秒后出现感叹号按钮。点击按钮会使文本出现。尝试在场景中移动Mage角色。你会发现无论他在哪里，感叹号按钮和文本都会出现在他的头上。这是一个非常有用的技术，用于创建始终跟随移动角色的UI元素。
- en: I know that the example is a bit boring the way it is now, but I recommend using
    some of the techniques discussed in the previous two chapters to add a nice bouncy
    animation to the exclamation point and have the Text fade in and out.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道现在的例子有点无聊，但我建议使用前两章中讨论的一些技术，为感叹号添加一个漂亮的弹跳动画，并使文本淡入淡出。
- en: 3D hovering health bars
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D悬停生命条
- en: Making World Space UI in a 3D scene takes a little more work than making World
    Space UI in a 2D scene if the camera can be rotated and moved throughout the 3D
    space. If the camera can move and rotate, the UI likely needs to constantly *face*
    the camera. Otherwise, the player will not be able to see the UI elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D场景中创建世界空间UI比在2D场景中创建世界空间UI需要更多的工作，如果相机可以在整个3D空间中旋转和移动。如果相机可以移动和旋转，UI可能需要不断
    *面向* 相机。否则，玩家将无法看到UI元素。
- en: For this example, we will once again create a new scene. For you to not have
    to build the scene from scratch, we will start with an Asset package that includes
    all the required items.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将再次创建一个新的场景。为了您不必从头开始构建场景，我们将从一个包含所有必需项目的资产包开始。
- en: 'We’ll create a simple hovering health bar that constantly faces the camera.
    It will also receive clicks so that we can watch the health bar reduce:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的悬停生命条，它始终面向相机。它还将接收点击，以便我们可以观察生命条减少：
- en: '![Figure 16.18: Astronaut with a hovering health bar](img/B18327_16_18.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图16.18：带有悬停生命条的宇航员](img/B18327_16_18.jpg)'
- en: 'Figure 16.18: Astronaut with a hovering health bar'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：带有悬停生命条的宇航员
- en: The art used in this example was accessed from [https://opengameart.org/content/space-kit](https://opengameart.org/content/space-kit).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的艺术作品来自 [https://opengameart.org/content/space-kit](https://opengameart.org/content/space-kit)。
- en: 'To create a health bar that always faces the camera and receives player-click
    input, complete the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个始终面向相机并接收玩家点击输入的生命条，请完成以下步骤：
- en: Import the `Chapter 16` `– Example 2 - Start.unitypackage` package. This package
    contains a scene with a 3D character facing the camera. The camera has a simple
    `RotatingCamera` script attached to it that rotates the camera around the astronaut
    with the mouse. The package also contains a `ReduceHealth` script that is attached
    to the `astronaut` character. This script has a function, `ReduceHealthBar`, that
    we will call when the health bar above the character’s head is clicked on.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `第16章` `– 示例2 - Start.unitypackage` 包。此包包含一个场景，其中有一个面向相机的3D角色。相机附有一个简单的 `RotatingCamera`
    脚本，该脚本使用鼠标围绕宇航员旋转相机。该包还包含一个附加到 `astronaut` 角色的 `ReduceHealth` 脚本。此脚本有一个 `ReduceHealthBar`
    函数，当点击角色头部的生命条时，我们将调用此函数。
- en: We want the health bar to be tied to the position of the astronaut within the
    scene. Therefore, we will create a Canvas that is a child of the astronaut in
    World Space.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望生命条与场景中宇航员的位置相关联。因此，我们将创建一个作为世界空间中宇航员子项的 `Canvas`。
- en: Right-click on the `astronaut` in the Hierarchy and add a UI Canvas as a child
    of the `astronaut`.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在层次结构中右键单击 `astronaut` 并添加一个 UI Canvas 作为 `astronaut` 的子项。
- en: Select the newly created `Canvas` and change the **Render Mode** on the **Canvas**
    component to **World Space**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新创建的 `Canvas` 并将 **Canvas** 组件上的 **渲染模式** 改为 **世界空间**。
- en: Assign the `Camera` to the **Event** **Camera** slot.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Camera` 分配到 **事件** **相机** 插槽。
- en: Since this `Canvas` is a child of `astronaut`, its coordinate system is relative
    to `astronaut`. To have it perfectly positioned over the `astronaut`, change the
    `0`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个 `Canvas` 是 `astronaut` 的子项，其坐标系相对于 `astronaut`。为了使其完美地位于 `astronaut` 上方，请更改
    `0`。
- en: The `Canvas` is significantly bigger than the `astronaut`. Make the size more
    reasonable by changing the `10` and the `1`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Canvas` 的尺寸比 `astronaut` 大得多。通过更改 `10` 和 `1` 使其尺寸更合理。'
- en: 'Position the Canvas so that it is above the head of the astronaut:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Canvas` 定位在宇航员头部上方：
- en: '![Figure 16.19: Scaling the Canvas over the astronaut](img/B18327_16_19.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图16.19：在宇航员上缩放Canvas](img/B18327_16_19.jpg)'
- en: 'Figure 16.19: Scaling the Canvas over the astronaut'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19：在宇航员上缩放Canvas
- en: Now that we have the `Canvas` scaled and positioned in the scene around the
    astronaut, we can add UI elements to it. Right-click on `Canvas` in the Hierarchy
    and create a UI Button. Name the new button `Health Bar`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将 `Canvas` 缩放并定位在宇航员周围的场景中，我们可以在其上添加 UI 元素。在层次结构中右键单击 `Canvas` 并创建一个 UI
    按钮。将新按钮命名为 `Health Bar`。
- en: Resize the `Health Bar` to match the `Canvas` by setting its `Canvas`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置其 `Canvas` 使 `Health Bar` 的大小与 `Canvas` 匹配。
- en: Change the `Health Bar` to **None** to give it a white rectangle as an image.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Health Bar` 改为 **None** 以使其显示为白色矩形图像。
- en: '![Figure 16.20: Adding a blank image to the Button](img/B18327_16_20.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图16.20：向按钮添加空白图像](img/B18327_16_20.jpg)'
- en: 'Figure 16.20: Adding a blank image to the Button'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20：向按钮添加空白图像
- en: Change the `Text` child of `Health Bar` to say `Click to reduce` `my health`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Health Bar` 的 `Text` 子项更改为显示 `点击以减少` `我的生命`。
- en: 'Set both the `Text` child to **Overflow**. This will allow you to see the size
    the text is currently rendering at in the scene:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Text` 子项设置为 **溢出**。这将允许你在场景中看到文本当前渲染的大小：
- en: '![Figure 16.21: The oversized text of the Health Bar](img/B18327_16_21.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21：健康条的放大文本](img/B18327_16_21.jpg)'
- en: 'Figure 16.21: The oversized text of the Health Bar'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21：健康条的放大文本
- en: Set the `10` and deselect **Raycast Target** on the **Text** component.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Text** 组件上设置 `10` 并取消选择 **射线投射目标**。
- en: 'Select the `Canvas` and hover over the **Dynamic Pixels Per Unit** property
    in the **Canvas Scaler** component until you see two arrows appear around your
    mouse cursor. Once you see those arrows, click, and drag to the right. This makes
    the property work like a slider, allowing you to see how increasing the **Dynamic
    Pixels Per Unit** property continuously changes the way the text renders in the
    scene. Do this until the text fits within the Canvas:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Canvas` 并将鼠标悬停在 **Canvas Scaler** 组件中的 **动态每单位像素** 属性上，直到你看到鼠标光标周围出现两个箭头。一旦看到这些箭头，点击并拖动到右侧。这使得属性像滑块一样工作，允许你看到增加
    **动态每单位像素** 属性如何连续改变场景中文本的渲染方式。这样做，直到文本适合画布：
- en: '![Figure 16.22: The oversized text of the Health Bar](img/B18327_16_22.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图16.22：健康条的放大文本](img/B18327_16_22.jpg)'
- en: 'Figure 16.22: The oversized text of the Health Bar'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22：健康条的放大文本
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When trying to get the text to look nice in 3D space, if only changing the **Dynamic
    Pixels Per Unit Size** results in *choppy* text, change the property until the
    text looks perfectly crisp in the scene. Then, use a combination of changing the
    **Rect Transform** component’s **Scale** and **Font Size** of the Text object
    to find the *sweet spot*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试在3D空间中使文本看起来很漂亮时，如果只更改 **动态每单位像素大小** 导致文本出现 *锯齿状*，则更改属性，直到文本在场景中看起来非常清晰。然后，通过改变文本对象的
    **Rect Transform** 组件的 **缩放** 和 **字体大小** 来找到 *最佳点*。
- en: Right-click on the `Health Bar` Button and add a UI Image as a child. Name the
    new Image `Health Fill`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Health Bar` 按钮并添加一个 UI Image 作为子项。将新图像命名为 `Health Fill`。
- en: Resize `Health Fill` to match the Canvas `Health Bar` by setting its `Health
    Bar`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Health Fill` 调整到与画布 `Health Bar` 相匹配的大小，通过设置其 `Health Bar`。
- en: Now, change the anchor and pivot to **left** **stretch** so that it will scale
    *leftward*.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将锚点和枢轴更改为 **左扩展**，使其将向 **左侧** 缩放。
- en: '![Figure 16.23: Left-stretching anchor](img/B18327_16_23.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图16.23：左扩展锚点](img/B18327_16_23.jpg)'
- en: 'Figure 16.23: Left-stretching anchor'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23：左扩展锚点
- en: Reposition the `Health Bar` in the Hierarchy so that it is above `Text`. This
    will have the fill render behind the `Text` object.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中重新定位 `Health Bar`，使其位于 `Text` 上方。这将使填充渲染在 `Text` 对象的后面。
- en: '![Figure 16.24: The Hierarchy of GameObjects](img/B18327_16_24.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图16.24：GameObject的层次结构](img/B18327_16_24.jpg)'
- en: 'Figure 16.24: The Hierarchy of GameObjects'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24：GameObject的层次结构
- en: On the `Health Fill`, change the **Color** property to red and deselect the
    **Raycast** **Target** property.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Health Fill` 上，将 **颜色** 属性更改为红色，并取消选择 **射线投射** **目标** 属性。
- en: Select the astronaut and assign the `Health Fill` object to the `ReduceHealth`
    component.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择宇航员并将 `Health Fill` 对象分配给 `ReduceHealth` 组件。
- en: 'Add an `Health Bar` Button that calls the `ReduceHealthBar` function of the
    `ReduceHealth` script on the astronaut:![Figure 16.25: The OnClick() event of
    the Health Bar](img/B18327_16_25.jpg)'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Health Bar` 按钮，该按钮在宇航员上调用 `ReduceHealth` 脚本的 `ReduceHealthBar` 函数：![图16.25：健康条的OnClick()事件](img/B18327_16_25.jpg)
- en: 'Figure 16.25: The OnClick() event of the Health Bar'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.25：健康条的OnClick()事件
- en: 'Playing the game now should result in the `Health Fill` reducing its fill value
    when you click on the `Health` `Bar` Button:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在玩游戏应该会导致点击 `Health` `Bar` 按钮时 `Health Fill` 减少其填充值：
- en: '![Figure 16.26: The Health Bar button reducing](img/B18327_16_26.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图16.26：健康条按钮减少](img/B18327_16_26.jpg)'
- en: 'Figure 16.26: The Health Bar button reducing'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.26：健康条按钮减少
- en: Now, we just need to add a billboard effect to the `Canvas`. Create a new script
    called `BillboardPlane` in the `Assets/Scripts` folder.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要向 `Canvas` 添加一个横幅效果。在 `Assets/Scripts` 文件夹中创建一个新的脚本，命名为 `BillboardPlane`。
- en: 'Change the script of the `BillboardPlane` class to the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BillboardPlane` 类的脚本更改为以下内容：
- en: '[PRE1]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Attach the `BillboardPlane` script to the Canvas.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BillboardPlane` 脚本附加到画布上。
- en: Assign the `Camera` to the `BillboardPlane` component.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Camera` 分配给 `BillboardPlane` 组件。
- en: If you play the game now, you’ll see that as you move the camera around, the
    health bar always faces the `Camera`. Try changing the `LookAt()` function work
    more drastically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在玩游戏，您会看到当您移动相机时，生命条总是面向`Camera`。尝试更改`LookAt()`函数以产生更剧烈的效果。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '**World Space** UI is not significantly different in its implementation than
    UI that renders in the Camera or Screen Space. Adding UI to your World Space gives
    you the ability to create cool effects and gives you more control over your UI’s
    position relative to objects in the scene.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**世界空间** UI在实现上与在相机或屏幕空间中渲染的UI没有显著区别。将UI添加到世界空间中，您将能够创建酷炫的效果，并让您对UI相对于场景中对象的定位有更多控制。'
- en: In the next chapter, we will discuss how to optimize Unity UI.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何优化Unity UI。
