- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Getting Started with UI Toolkit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UI 工具包入门
- en: 'Up to this point, the focus of this book has been on **Unity UI** (**uGUI**).
    However, Unity has been developing another system in which you can develop UI
    for your game: the **UI Toolkit**. It is based on the principles of web design
    and is meant to allow you to create UI in a more flexible and extensible way than
    the uGUI. It accomplishes this by divorcing the design and development of UI from
    scenes and GameObjects and instead creates UI via code and style sheets—just like
    in web design.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书的重点一直是 **Unity UI** （**uGUI**）。然而，Unity 一直在开发另一个系统，你可以用它为你的游戏开发 UI：**UI
    工具包**。它基于网页设计的原理，旨在允许你以比 uGUI 更灵活和可扩展的方式创建 UI。它是通过将 UI 的设计和开发从场景和 GameObject 中分离出来，并通过代码和样式表创建
    UI 来实现这一点的——就像在网页设计中一样。
- en: The UI Toolkit is an entirely different system, so beginning development with
    it may feel jarring at first if you are used to developing UI with uGUI. However,
    if you have experience with `.xhtml` and `.css` or developing Android or iOS interfaces
    using `XML`, this should all feel very familiar.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: UI 工具包是一个完全不同的系统，因此如果你习惯于使用 uGUI 开发 UI，那么一开始使用它可能会感到有些不适应。然而，如果你有 `.xhtml` 和
    `.css` 的经验，或者使用 `XML` 开发 Android 或 iOS 接口，那么这些都应该非常熟悉。
- en: Since the UI Toolkit is an entirely different system using entirely different
    principles than the rest of the chapters in this book, to fully explain all that
    you could do with it would merit a whole other textbook devoted purely to it.
    Therefore, this chapter will give you the basic information you need to get started
    with using the system, but not fully discuss every aspect of it. I will give you
    additional resources throughout this chapter to review if you’d like to go even
    further with your study of the UI Toolkit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UI 工具包是一个完全不同的系统，它使用与本书其他章节完全不同的原则，要完全解释你可以用它做什么，可能需要一本完全致力于它的教科书。因此，本章将提供你开始使用该系统所需的基本信息，但不会全面讨论其各个方面。如果想要进一步学习
    UI 工具包，我将在本章中提供额外的资源供你回顾。
- en: 'In this chapter, I will discuss the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论以下内容：
- en: An overview of the UI Toolkit and how to install it if it’s not already in your
    version of Unity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 工具包概述以及如何安装它（如果它尚未包含在你的 Unity 版本中）
- en: The various parts of the UI Toolkit that work together to create and style an
    interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 工具包的各个部分如何协同工作以创建和样式化界面
- en: What are Visual Elements and how does the UI Toolkit Hierarchy work?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉元素是什么？UI 工具包层次结构是如何工作的？
- en: How to use the UI Builder to design and layout UI Toolkit interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 UI 构建器设计和布局 UI 工具包界面
- en: How to access UI Toolkit-built UI in C#
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 C# 中访问 UI 工具包构建的 UI
- en: Creating a virtual pet that hangs out with you in your Unity Editor and encourages
    you
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个与你一起在 Unity 编辑器中玩耍的虚拟宠物，并鼓励你
- en: Using the UI Builder to create style sheets and animation transitions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI 构建器创建样式表和动画过渡
- en: Using web requests to randomly generate your UI’s images and text
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络请求随机生成你的 UI 的图像和文本
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter assumes you have a cursory knowledge of HTML and CSS. However,
    having more extensive experience with HTML and CSS will make adopting the UI Toolkit
    system significantly easier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你具有 HTML 和 CSS 的基本知识。然而，拥有更广泛的 HTML 和 CSS 经验将使采用 UI 工具包系统变得更加容易。
- en: Before we jump into the inner workings of the UI Toolkit, let’s review its use
    cases and when you will use it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 UI 工具包的内部工作原理之前，让我们回顾一下它的用例以及你将在何时使用它。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2018](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2018)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2018](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2018)
- en: Overview of UI Toolkit
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 工具包概述
- en: As you may recall from [*Chapter 5*](B18327_05.xhtml#_idTextAnchor072), there
    are three total UI systems that can be used within Unity. Up to this point, the
    focus of this book has been on Unity UI (uGUI), which can be used to make in-game
    (aka runtime) UI. However, if you want to make UI that can be viewed in your Editor,
    you will have to use a different system. The two systems that can be used to create
    Editor UI are **IMGUI**, which we will discuss in the next chapter, and the UI
    Toolkit. However, while IMGUI can only be used to make Editor UI, the UI Toolkit
    can be used to make both runtime and Editor UI.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，从 [*第 5 章*](B18327_05.xhtml#_idTextAnchor072) 中，Unity 中可以使用总共三个 UI 系统。到目前为止，这本书的重点一直是
    Unity UI (uGUI)，它可以用来制作游戏中的 UI（即运行时 UI）。然而，如果你想制作可以在你的编辑器中查看的 UI，你必须使用不同的系统。可以用来创建编辑器
    UI 的两个系统是 **IMGUI**，我们将在下一章中讨论，以及 UI Toolkit。然而，虽然 IMGUI 只能用来制作编辑器 UI，但 UI Toolkit
    可以用来制作运行时和编辑器 UI。
- en: '![Figure 18.1: Comparing the three UI systems](img/B18327_18_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.1：比较三个 UI 系统](img/B18327_18_01.jpg)'
- en: 'Figure 18.1: Comparing the three UI systems'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1：比较三个 UI 系统
- en: Unity’s goal is to replace the uGUI system entirely with the new UI Toolkit.
    However, it is still in development and does not have all the functionalities
    that uGUI does. For example, the UI Toolkit cannot make UI that is positioned
    in the 3D world, like what we discussed in [*Chapter 16*](B18327_16.xhtml#_idTextAnchor447).
    It can only make UI that overlays on top of the screen. Additionally, it cannot
    use custom materials and shaders and is not easily referenced from MonoBehaviours.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的目标是完全用新的 UI Toolkit 替换 uGUI 系统。然而，它仍在开发中，并不具备 uGUI 所有的功能。例如，UI Toolkit
    无法创建位于 3D 世界中的 UI，就像我们在 [*第 16 章*](B18327_16.xhtml#_idTextAnchor447) 中讨论的那样。它只能创建覆盖在屏幕上的
    UI。此外，它无法使用自定义材质和着色器，并且不容易从 MonoBehaviours 中引用。
- en: So, when would you want to use the UI Toolkit? The UI Toolkit is extremely helpful
    if you want to create stylistic UI without dealing with the bloat that comes along
    with prefabs and prefab variants. You can change the design of UI through code
    instead of altering a GameObject’s Inspector properties. This makes UI more easily
    sharable across multiple projects and quickly customizable. Additionally, if you
    have experience with web development, you may be more comfortable with the workflow
    of the UI Toolkit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你何时会想使用 UI Toolkit 呢？如果你想要创建风格化的 UI 而不处理与预制件和预制件变体一起出现的冗余，UI Toolkit 非常有用。你可以通过代码更改
    UI 的设计，而不是修改 GameObject 的检查器属性。这使得 UI 更容易在多个项目中共享，并且可以快速自定义。此外，如果你有网页开发经验，你可能对
    UI Toolkit 的工作流程更舒适。
- en: 'Odds are, if you are working on an older project, you will need the information
    discussed in this book that concentrates on uGUI as it is still the most widely
    used UI system. However, if you are creating a new project and would like to consider
    using the UI Toolkit for your project, I recommend you review the following documentation
    to ensure your needs will be met by this system: [https://docs.unity3d.com/Manual/UI-system-compare.xhtml](https://docs.unity3d.com/Manual/UI-system-compare.xhtml)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理一个较旧的项目，你将需要这本书中讨论的信息，这些信息集中在 uGUI 上，因为它仍然是使用最广泛的 UI 系统。然而，如果你正在创建一个新项目，并希望考虑为你的项目使用
    UI Toolkit，我建议你查看以下文档，以确保你的需求能够得到满足：[https://docs.unity3d.com/Manual/UI-system-compare.xhtml](https://docs.unity3d.com/Manual/UI-system-compare.xhtml)
- en: Now that we’ve reviewed when you can use the UI Toolkit, let’s get started with
    it by installing it in our project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了何时可以使用 UI Toolkit，让我们开始在我们的项目中安装它。
- en: Installing the UI Toolkit package
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 UI Toolkit 包
- en: Depending on which version of Unity you are using, the necessary UI Toolkit
    packages may not be installed. The version of the UI Toolkit that allows you to
    develop Editor UI comes packaged with all relatively recent versions of Unity;
    however, the version that allows you to also make runtime UI only comes with the
    most recent versions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的 Unity 版本，可能没有安装必要的 UI Toolkit 包。允许你开发编辑器 UI 的 UI Toolkit 版本包含在所有相对较新的
    Unity 版本中；然而，允许你创建运行时 UI 的版本只包含最新的版本。
- en: You can determine if you already have all necessary versions of the UI Toolkit
    package installed by going to **Window** | **UI Toolkit**. If the **UI Builder**
    submenu is not present or the UI Toolkit menu item is completely missing, you
    will need to import the package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过转到 **窗口** | **UI Toolkit** 来确定你是否已经安装了所有必要的 UI Toolkit 包版本。如果 **UI Builder**
    子菜单不存在或 UI Toolkit 菜单项完全缺失，你需要导入该包。
- en: '![Figure 18.2: Determining if you have the UI Toolkit package installed](img/B18327_18_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: Determining if you have the UI Toolkit package installed'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to install the UI Toolkit, you can do so by importing the package
    from the `git` URL. To do so, complete the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Open the package manager with **Window** | **Package Manager**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **+** button, then choose **Add package from** **git URL…**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.3: Adding a package via the git URL](img/B18327_18_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.3: Adding a package via the git URL'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Type `com.unity.ui` into the text field that appears. Make sure not to add a
    space after the address. If you do, you will receive an error message.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the import finishes, you should see the following toolkit in your package
    window.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 18.4: The UI Toolkit package](img/B18327_18_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.4: The UI Toolkit package'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to import the examples into your project, select the **Import**
    button to download them.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may notice that the UI Toolkit description says that the UI Builder is not
    included in this package. So, you must import that package separately. To do so,
    select the **+** button, then choose **Add package from git** **URL…** again.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, enter `com.unity.ui.builder` into the textbox that appears.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the import finishes, you should see the following package.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 18.5: The UI Builder package](img/B18327_18_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.5: The UI Builder package'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: As with the other package, there are samples you can import into your project
    with the **Import** buttons.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the appropriate packages installed, let’s look at the various
    parts of the UI Toolkit system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Parts of the UI Toolkit system
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UI Toolkit uses a set of assets and a GameObject component to create UI.
    The primary assets used to create UI are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: UI Document (UXML)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style Sheet (USS)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panel Settings
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme Style Sheet (TSS)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 18.6: Assets used when making UI Toolkit interfaces](img/B18327_18_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.6: Assets used when making UI Toolkit interfaces'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: A `.uxml` extension). This file uses **Unity Extensible Markup Language** (**UXML**)
    to define the layout and structure of the UI. While UXML is a unity-specific markup
    language, it works similarly to other markup languages like HTML and XML. You
    can create UXML files by right-clicking in an Asset folder and selecting **Create**
    | **UI Toolkit** | **UI Document**, then naming the file appropriately.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: A `.uss` extension). This file is used to designate style properties that can
    be referenced in a UXML file. This works very similarly to a CSS file when working
    with HTML. You can create USS files by right-clicking in an Asset folder and selecting
    **Create** | **UI Toolkit** | **Style Sheet**, then naming the file appropriately.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: A `.asset` extension) defines the collection of properties that the UI will
    have.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.7: A default Panel Settings asset’s properties](img/B18327_18_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.7: A default Panel Settings asset’s properties'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.7：默认面板设置资源的属性
- en: A `.tss` extension). It determines which Panel Settings will be used with which
    TSS and USS files, by maintaining a collection of them, as shown in the following
    figure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: （.tss 扩展名）。它通过维护一个集合，确定哪些面板设置将与哪些 TSS 和 USS 文件一起使用，如下图所示。
- en: '![Figure 18.8: The Inspector of a TSS file](img/B18327_18_08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.8：TSS 文件检查器](img/B18327_18_08.jpg)'
- en: 'Figure 18.8: The Inspector of a TSS file'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.8：TSS 文件检查器
- en: When you create a Panel Settings asset, a folder called `Unity Themes` is automatically
    created in the same folder. Within it, a single TSS file called `UnityDefaultRuntimeTheme.tss`
    will be created for you. However, you can create more TSS files by right-clicking
    in an Asset folder and selecting **Create** | **UI Toolkit** | **TSS** **Theme
    File**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建面板设置资源时，将在同一文件夹中自动创建一个名为 `Unity Themes` 的文件夹。在其中，将为您创建一个名为 `UnityDefaultRuntimeTheme.tss`
    的单个 TSS 文件。但是，您可以通过在资源文件夹中右键单击并选择 **创建** | **UI 工具包** | **TSS 主题文件** 来创建更多 TSS
    文件。
- en: The final piece of the UI Toolkit system is the **UI Document** component, shown
    in the following screenshot.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: UI 工具包系统的最后一部分是 **UI 文档** 组件，如下截图所示。
- en: '![Figure 18.9: The UI Document component](img/B18327_18_09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.9：UI 文档组件](img/B18327_18_09.jpg)'
- en: 'Figure 18.9: The UI Document component'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9：UI 文档组件
- en: 'This component is added to a GameObject in your scene and allows your UI created
    with the UI Toolkit to be rendered. It has three properties: **Panel Settings**,
    **Source Asset**, and **Sort Order**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件添加到场景中的 GameObject，并允许使用 UI 工具包创建的 UI 进行渲染。它有三个属性：**面板设置**、**源资源** 和 **排序顺序**。
- en: You assign a Panel Setting asset to the **Panel Settings** property to signify
    which settings the UI rendered by this component will have. The **Source Asset**
    property is where you assign the UI Document (UXML) file. The **Sort Order** property
    determines what order the UI defined by the UXML file will render relative to
    any other UXML files you are rendering in the scene that use the same Panel Settings.
    You can add this component to a GameObject by using **Add Component** in the **Inspector**
    and searching for **UI Document**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个面板设置资源分配给 **面板设置** 属性，以表示由该组件渲染的 UI 将具有哪些设置。**源资源** 属性是您分配 UI 文档（UXML）文件的地方。**排序顺序**
    属性确定由 UXML 文件定义的 UI 相对于场景中任何其他使用相同面板设置的 UXML 文件将渲染的顺序。您可以通过在 **检查器** 中使用 **添加组件**
    并搜索 **UI 文档** 来将此组件添加到 GameObject。
- en: Now that we know all the required assets and components, let’s review how to
    actually build these assets using the UI Builder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了所有必需的资源和组件，让我们回顾一下如何使用 UI 构建器实际构建这些资源。
- en: Visual Elements and UI Hierarchy
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉元素和 UI 层级
- en: In the same way that a uGUI-built UI is comprised of multiple GameObjects, a
    UI Toolkit-built UI is comprised of **Visual Elements**. There are multiple UI
    elements available to you in the UI Toolkit system (buttons, labels, sliders,
    etc.), but the Visual Element is the base class for all of them, so they all derive
    many of their properties from it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与 uGUI 构建的 UI 由多个 GameObject 组成的方式相同，UI 工具包构建的 UI 由 **视觉元素** 组成。在 UI 工具包系统中，您有多种
    UI 元素可供选择（按钮、标签、滑块等），但视觉元素是所有这些元素的基础类，因此它们都从它那里继承了许多属性。
- en: Just as GameObjects are organized in the Unity Editor Hierarchy, UI Toolkit
    organizes its Visual Elements in something called a **UI Hierarchy**. For example,
    let’s say I’d like to create a UI similar to the one displayed in *Figure 18**.10*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 GameObject 在 Unity 编辑器层级中组织一样，UI 工具包通过称为 **UI 层级** 的东西来组织其视觉元素。例如，假设我想创建一个类似于
    *图 18.10* 中显示的 UI。
- en: '![Figure 18.10: Simple sample UI](img/B18327_18_10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.10：简单示例 UI](img/B18327_18_10.jpg)'
- en: 'Figure 18.10: Simple sample UI'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.10：简单示例 UI
- en: The Scene Hierarchy in the Editor, if it were built with uGUI, is quite similar
    to the UI Hierarchy, if it were created with UI Builder, as shown in *Figure 18**.11*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 uGUI 构建，编辑器中的场景层级与使用 UI 构建器创建的 UI 层级非常相似，如图 *18.11* 所示。
- en: '![Figure 18.11: Scene Hierarchy for uGUI versus UI Hierarchy for UI Toolkit](img/B18327_18_11.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.11：uGUI 与 UI 工具包 UI 层级的场景层级](img/B18327_18_11.jpg)'
- en: 'Figure 18.11: Scene Hierarchy for uGUI versus UI Hierarchy for UI Toolkit'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.11：uGUI 与 UI 工具包 UI 层级的场景层级
- en: Except for some slight changes in naming and nesting, they are almost the same.
    Where you can consider the UI Document, represented by `Chapter18.uxml` in the
    UI Hierarchy acting with a similar function to the Canvas in the Scene Hierarchy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命名和嵌套的一些细微变化外，它们几乎相同。你可以将UI文档视为在UI层次结构中以`Chapter18.uxml`表示，它在UI层次结构中具有与场景层次结构中的画布类似的功能。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The UI Hierarchy screenshot was obtained from the UI Builder tool, which we
    will discuss in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: UI层次结构截图是从UI构建器工具中获取的，我们将在下一节中讨论。
- en: When working with uGUI, the alignment and position of each GameObject is based
    on the parent object it is nested under. This is true also for Visual Elements
    created with the UI Toolkit system. So, having a sense of how items should be
    nested is important for developing UI with the UI Toolkit system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用uGUI时，每个GameObject的对齐和位置基于它嵌套的父对象。这对于使用UI工具箱系统创建的视觉元素也是如此。因此，对项目嵌套有感觉对于使用UI工具箱系统开发UI很重要。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the example UI that was developed for *Figure 18**.10* and *Figure
    18**.11* within the Unity project provided in the code bundle. They can be found
    within the scene labeled **Chapter18.asset**. In the Scene Hierarchy, the **Canvas**
    GameObject holds the uGUI version and the the **UIDocument** GameObject holds
    the UI Toolkit version.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在提供的代码包中的Unity项目中找到为*图18.10*和*图18.11*开发的示例UI。它们可以在标记为**Chapter18.asset**的场景中找到。在场景层次结构中，**Canvas**游戏对象包含uGUI版本，而**UIDocument**游戏对象包含UI工具箱版本。
- en: Now that we’ve reviewed some basic concepts of the UI Toolkit system, let’s
    look at how we can actually build UI with it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了UI工具箱系统的一些基本概念，让我们看看如何实际使用它来构建UI。
- en: Creating UI with the UI Builder
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI构建器创建UI
- en: 'To create UI with the UI Toolkit, you have to create a UI Document to describe
    what Visual Elements you will render as well as their layout and other properties.
    There are two ways to create UI Documents within the UI Toolkit system:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用UI工具箱创建UI，你必须创建一个UI文档来描述你将渲染的视觉元素以及它们的布局和其他属性。在UI工具箱系统中创建UI文档有两种方式：
- en: Write the code that will lay out the Visual Elements
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写布局视觉元素的代码
- en: Lay the elements in UI Builder and have it write the code for you
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI构建器中排列元素，并让它为你编写代码
- en: You can also do a combination of both and bounce between editing your UI via
    code or the UI Builder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以结合两者，在通过代码或UI构建器编辑UI之间切换。
- en: To access the UI Builder, select **Window** | **UI Toolkit** | **UI Builder**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问UI构建器，请选择**窗口** | **UI工具箱** | **UI构建器**。
- en: '![Figure 18.12: The UI Builder window](img/B18327_18_12.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图18.12：UI构建器窗口](img/B18327_18_12.jpg)'
- en: 'Figure 18.12: The UI Builder window'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12：UI构建器窗口
- en: In this window, you can drag and drop various Visual Elements from the **Library**
    (bottom left) into the **Viewport** (center). You can resize and move the Visual
    Elements around in this Viewport, as well. You can change the parenting, thus
    changing how the Visual Element is aligned via the **Hierarchy** (left center).
    Additionally, you can also view the code file that is generated from your layout
    in the **UXML Review** Panel and the code files that represent your styles in
    the **USS Preview** Panel (both are in the bottom center). An example of walking
    through how to build a UI with the UI Builder is in the *Examples* section at
    the end of this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口中，你可以从**库**（左下角）拖放各种视觉元素到**视口**（中央）。你还可以在这个视口中调整视觉元素的大小和位置。你可以通过**层次**（左中）更改父级，从而改变视觉元素的排列方式。此外，你还可以在**UXML审查**面板中查看从布局生成的代码文件，以及在**USS预览**面板中查看代表你样式的代码文件（两者都在底部中央）。本章末尾的*示例*部分提供了一个如何使用UI构建器构建UI的示例。
- en: To be able to use the UI layout you’ve created with the UI Builder, you must
    save the UI Document as a .`uxml` file. Pressing *Ctrl* + *S* will save the file
    for you in a location of your choosing. I recommend you save them in a folder
    called `UI Toolkit` within `Assets`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你用UI构建器创建的UI布局，你必须将UI文档保存为`.uxml`文件。按下*Ctrl* + *S*将为你将文件保存到您选择的位置。我建议你将它们保存在`Assets`中的`UI
    Toolkit`文件夹内。
- en: Now that we’ve reviewed how to create a UI Document, let’s review how to tie
    the document to your game’s scene.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何创建UI文档，让我们回顾一下如何将文档与你的游戏场景关联起来。
- en: You can rename any of your Visual Elements by double-clicking on them in the
    Hierarchy and typing a new name. When using the UI Builder, the names of the Visual
    Elements will act as variables if you need to reference them by C# code. So, it’s
    important to give the Visual Elements distinct names if you plan to access them
    via C# code (see the *Making the UI Interactable with Events* section for further
    information).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Using the UI Document component
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Parts of the UI Toolkit System* section of this chapter,
    the UI Document component must be added to a GameObject in your scene so that
    the UI you’ve created can be rendered. You can do this by either adding the UI
    Document component to an existing GameObject or selecting **+** | **UI Toolkit**
    | **UI Document**. This GameObject will have a **Transform** component and a **UI**
    **Document** component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.13: The Inspector of a UIDocument GameObject](img/B18327_18_13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.13: The Inspector of a UIDocument GameObject'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: If you do not already have a folder called `UI Toolkit` within your projects’s
    `Assets` folder, one will automatically be created for you. Within it, you will
    find a `PanelSettings` asset, and a folder called `UnityThemes`. Within `UnityThemes`,
    you will find a TSS file called `UnityDefaultRuntimeTheme.tss`. Your `UIDocument`
    GameObject’s `PanelSettings` asset assigned to the `.umxl` file you created into
    the **Source Asset** property to view the UI you created in your scene.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of building and rendering our UI, let’s look at
    how to code the interactions of UI created with the UI Toolkit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Making The UI interactable with C#
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI Builder and your UXML document only handle the visual properties of your
    UI. While you can assign some basic responses (like changing visuals on hover)
    through the use of style sheets, you will need to create C# scripts to handle
    any logic or events related to your UI.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The UIElements namespaces
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to write code that interfaces with UI Documents, you must use the
    `UnityEngine.UIElements` namespace. If you are using the UI Toolkit to make editor
    UI, you may also need the `UnityEditor.UIElements` namespace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the **UnityEngine.UIElements** and **UnityEditor.UIElements**
    namespaces, see the following resource: [https://docs.unity3d.com/Packages/com.unity.ui@1.0/api/UnityEditor.UIElements.xhtml](https://docs.unity3d.com/Packages/com.unity.ui@1.0/api/UnityEditor.UIElements.xhtml).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Getting a reference to UI Documents variables
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within your C# script, you can create a reference variable to a `UIDocument`
    type. You can assign this variable in the same way you would generally assign
    a variable of another class: assigning it in the `GetComponent`, passing a reference
    to it from another script, and so on.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: While you can use **FindObjectOfType**, this is not recommended for finding
    a reference to a **UIDocument**, as you will very likely have multiple UI Documents
    in your scene.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: After you get a reference to the `UIDocument` you want to work with, you can
    get a reference to the Visual Elements within it (e.g., the buttons, labels, etc.)
    by getting a reference to the root Visual Element on the UI Document, then `Querying`
    that element for the Visual Element type by its name.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到您想要与之工作的 `UIDocument` 引用后，您可以通过获取 UI 文档上的根视觉元素引用，然后通过其名称查询该元素的视觉元素类型，来获取其中的视觉元素引用（例如，按钮、标签等）。
- en: 'For example, in the UI shown earlier in the chapter, I have renamed the `Label`
    to `DogLabel` and the `Button` to `CatButton`, as shown in the following figure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在章节中前面显示的 UI 中，我将 `Label` 重命名为 `DogLabel`，将 `Button` 重命名为 `CatButton`，如下所示：
- en: '![Figure 18.14: New names for Label and Button](img/B18327_18_14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.14：标签和按钮的新名称](img/B18327_18_14.jpg)'
- en: 'Figure 18.14: New names for Label and Button'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.14：标签和按钮的新名称
- en: 'To create a reference to these variables in a C# script, I first created reference
    variables for the `UIDocument`, the `Label`, and the `Button`, with the following
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C# 脚本中创建这些变量的引用，我首先创建了 `UIDocument`、`Label` 和 `Button` 的引用变量，如下所示：
- en: '[PRE0]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `uiDocument` variable will be assigned in the Inspector. As with all `MonoBehaviour`
    scripts, this script needed to be attached to a GameObject in the scene. I attached
    this script to the `UIDocument` GameObject and then dragged the `UIDocument` GameObject
    into the **Ui** **Document** property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`uiDocument` 变量将在检查器中分配。与所有 `MonoBehaviour` 脚本一样，此脚本需要附加到场景中的 GameObject 上。我将此脚本附加到
    `UIDocument` GameObject 上，然后将 `UIDocument` GameObject 拖动到 **Ui** **文档**属性。'
- en: '![Figure 18.15: Assigning the UIDocument to the script](img/B18327_18_15.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.15：将 UIDocument 分配给脚本](img/B18327_18_15.jpg)'
- en: 'Figure 18.15: Assigning the UIDocument to the script'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.15：将 UIDocument 分配给脚本
- en: It’s important to note that when you reference a `UIDocument` in C#, you are
    referencing the `UIDocument` component, not a UI Document source file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当您在 C# 中引用 `UIDocument` 时，您引用的是 `UIDocument` 组件，而不是 UI 文档源文件。
- en: To initialize `dogLabel` and `catButton`, I got a reference to the `rootVisualElement`
    on the `uiDocument`, then used the `Query` method to find each Visual Element.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化 `dogLabel` 和 `catButton`，我获取了 `uiDocument` 上的 `rootVisualElement` 引用，然后使用
    `Query` 方法找到每个视觉元素。
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how I used `root.Q` to find the `Label` and `root.Query` to find the
    `Button`. You can use either one, and I only did this so you can see that there
    are two different ways to do it. It is up to your preference which one you use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何使用 `root.Q` 来查找 `Label`，以及使用 `root.Query` 来查找 `Button`。您可以使用任一方法，我这样做只是为了让您知道有两种不同的方法。您可以使用您喜欢的任何一种。
- en: Managing Visual Element events
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理视觉元素事件
- en: Since the UXML document does not manage events, you can find out if the UI defined
    in the UXML document is interacted with by either subscribing to an event or registering
    a callback method when the event is triggered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UXML 文档不管理事件，您可以通过订阅事件或注册回调方法来在事件触发时找出在 UXML 文档中定义的 UI 是否被交互。
- en: For example, if I want to log a message in the Console when the `catButton`
    is clicked, I need to create a method that is subscribed to the `catButton`’s
    `clicked` event.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想在点击 `catButton` 时在控制台记录一条消息，我需要创建一个订阅 `catButton` 的 `clicked` 事件的函数。
- en: 'First, I add the following method to my script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我在我的脚本中添加了以下方法：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, I need to subscribe to the `catButton`’s `clicked` event, with the following
    in the `Start()` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我需要在 `Start()` 方法中订阅 `catButton` 的 `clicked` 事件，如下所示。
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To avoid any errors with the event subscription when the GameObject is disabled
    or destroyed, I unsubscribe from the event in the `OnDisable()` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在 GameObject 禁用或销毁时事件订阅出现错误，我在 `OnDisable()` 方法中取消订阅事件。
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This causes the `OnCatButtonClicked` message to display in the Console whenever
    you click the button.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致每次点击按钮时，`OnCatButtonClicked` 消息都会在控制台中显示。
- en: Accessing Visual Element properties
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问视觉元素属性
- en: Similar to the way uGUI GameObjects can have their properties changed via C#
    code, a Visual Element can have its properties adjusted via C# code, as well.
    For example, changing the `OnCatButtonClicked()` method to the following will
    make the word `Text` change to `Meow!`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与 uGUI GameObject 可以通过 C# 代码更改其属性的方式类似，视觉元素也可以通过 C# 代码调整其属性。例如，将 `OnCatButtonClicked()`
    方法更改为以下内容将使 `Text` 字段变为 `Meow!`
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code causes the UI to appear as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导致 UI 如下显示：
- en: '![Figure 18.16: The UI after the text changes via a button click](img/B18327_18_16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.16: The UI after the text changes via a button click'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more I could say about working with the UI Toolkit, but as I
    said at the beginning of this chapter, I could only give a general overview—otherwise,
    I’d have to write a whole separate book just on the UI Toolkit! However, I believe
    I’ve given enough of an overview of the important concepts so that you can dive
    into working with the examples in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the basic building blocks we need to get started with actually
    creating some UI with UI Toolkit. I didn’t dive deep into style sheets or the
    properties of the various Visual Elements, but I’ll show some examples that will
    expand upon that here. If after completing these examples, you want to learn more,
    see the *Resources* section for a bunch of examples and documentation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the UI Toolkit to develop UI, there are two main parts to the work:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the UI with the UI Builder (or by editing the UXML document)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing C# code to add functionality to the UI
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, each of these examples will be broken into two parts: one for building
    the UI and the other for writing the functionality.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Because the UI Toolkit can be used for both Editor and runtime UI, I’ll show
    you one example of both. Let’s start with the Editor example!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Using the UI Toolkit to make an Editor virtual pet
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the primary focus of this book is on runtime UI, I would be remiss to
    show you how to use the UI Toolkit to make some Editor UI, since that’s one of
    its main benefits. Editor UI is usually used for tools to facilitate development,
    improve productivity, streamline your workflow, and so on. Originally, I planned
    to show you how to make some generic Editor tools that you could expand to improve
    your workflow. However, I decided instead to make an Editor tool that can improve
    your mood. Self-care is essential to productivity, after all! While this example
    might not have any practical purposes in the traditional sense, it’s fun and it
    shows you how to use lots of Editor UI features, so it’s a win-win.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This example covers how to make a virtual pet that hangs out with you in a window
    in your Editor and compliments you when you click on it. This also demonstrates
    how to create animated sprite sheets within the Unity Editor.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.17: The Editor virtual pet created in this example](img/B18327_18_17.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.17: The Editor virtual pet created in this example'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The cat sprite used in this example is derived from the public domain art asset
    provided here: [https://opengameart.org/content/a-cat](https://opengameart.org/content/a-cat).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: For this example, since we are making an Editor Tool that is not related to
    any of the work we’ve done so far, you might want to create a new Unity project
    to complete this work in. If you do, you will need to reimport any 2D UI packages.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with laying out the UI with the UI Builder!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using the UI Builder to make our Editor Window’s UI
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the virtual pet shown in *Figure 18**.17*, complete the following
    steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: When writing code for your Editor, you should put all your editor code within
    an `Editor` folder. This signifies to Unity that any code within it is only to
    be used for the Editor and not at runtime. Create a folder in `Assets` called
    `Editor` and a folder within it called `Resource`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `idleCat.png` sprite sheet found in the book’s source files into your
    newly created `Assets/Editor/Resources` folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Import Settings** so that its **Texture Type** is **Sprite (2D and
    UI)** and **Sprite Mode** is **Multiple**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Sprite Editor** and you’ll notice that the images are extremely blurry.
    We need to edit the import settings further to fix this.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.18: The blurry sprite sheet](img/B18327_18_18.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.18: The blurry sprite sheet'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Return to the sprite’s `64` and **Compression** to **None**. Also, change the
    **Filter Mode** to **Point (****no filter)**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Apply** and the sprites should now be crisp pixel art cats.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, return to the `16` x `16`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.19: The sliced sprite sheet](img/B18327_18_19.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.19: The sliced sprite sheet'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Slice** button to confirm the changes, then select **Apply** to
    commit the changes. You can now close the **Sprite Editor**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our sprite imported properly, we’re ready to build out the
    Editor UI in the UI Builder. Open the UI Builder with **Window** | **UI Toolkit**
    | **UI Builder**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `<unsaved file>.uxml` UI Document in the **Hierarchy** to bring up
    its properties in the **Inspector**.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.20: The UXML file’s Inspector](img/B18327_18_20.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.20: The UXML file’s Inspector'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Now change `100` x `100`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the UI Document by selecting `Assets/Editor/Resources` folder and name
    the file `IdleCat.uxml` (the `.uxml` extension is automatically added for you).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s add the cat to the **Viewport**. Because we want to make the cat
    clickable, the easiest way to achieve this is to use a Button. Drag the icon from
    the **Controls Panel** to the **Viewport**. Note once you do so the Button will
    be positioned at the top of the container.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.21: Adding a Button](img/B18327_18_21.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.21: Adding a Button'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Button` in the **Hierarchy** to open its Inspector.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Background** property so that you can change the look of the button.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Sprite** from the dropdown menu next to the **Image** property. This
    will allow you to select images of **Sprite** type.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.22: Changing the Background Image type to Sprite](img/B18327_18_22.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.22: Changing the Background Image type to Sprite'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the circle in the `idleCat_0`. You should see the following in your
    **Viewport** once you do so:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.23: The Button with the cat image applied](img/B18327_18_23.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.23: The Button with the cat image applied'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.23：应用了猫图像的按钮
- en: Let’s get that text out of the way. At the top of the `Button` from the **Text**
    property.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先将文本移开。在`Button`的**文本**属性顶部。
- en: '![Figure 18.24: Removing the Text from the button](img/B18327_18_24.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图18.24：从按钮中移除文本](img/B18327_18_24.jpg)'
- en: 'Figure 18.24: Removing the Text from the button'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.24：从按钮中移除文本
- en: Now, let’s make it the appropriate dimensions. Expand the `auto` x `auto` to
    `64` x `64`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调整它到适当的尺寸。将`auto` x `auto`更改为`64` x `64`。
- en: '![Figure 18.25: Changing the button size](img/B18327_18_25.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图18.25：更改按钮大小](img/B18327_18_25.jpg)'
- en: 'Figure 18.25: Changing the button size'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.25：更改按钮大小
- en: Visual Elements always initialize in the UI Document root container at the top-left
    corner. If you want to be able to position them within the container, you have
    to create a high-level Visual Element that acts as the “shell” in which all the
    other items can be positioned within. So, to make this `Button` centered within
    the window, we will need to add a Visual Element to contain it. Drag `VisualElement`
    from the **Library** into the **Hierarchy**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Elements始终在UI文档根容器中初始化，位于左上角。如果您想要能够在容器内定位它们，您必须创建一个高级Visual Element，它充当“外壳”，其中所有其他项目都可以定位在其中。因此，为了使这个`Button`在窗口中居中，我们需要添加一个Visual
    Element来包含它。从**库**中将`VisualElement`拖动到**层次结构**中。
- en: '![Figure 18.26: Adding a Visual Element to the Hierarchy](img/B18327_18_26.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图18.26：将VisualElement添加到层次结构中](img/B18327_18_26.jpg)'
- en: 'Figure 18.26: Adding a Visual Element to the Hierarchy'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.26：将VisualElement添加到层次结构中
- en: Within the `Button` onto the `VisualElement`. This will cause the `Button` to
    be a child of the `VisualElement`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Button`上到`VisualElement`。这将使`Button`成为`VisualElement`的子元素。
- en: '![Figure 18.27: Making the Button a child of VisualElement](img/B18327_18_27.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图18.27：将按钮设置为VisualElement的子元素](img/B18327_18_27.jpg)'
- en: 'Figure 18.27: Making the Button a child of VisualElement'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.27：将按钮设置为VisualElement的子元素
- en: Select `VisualElement` from the **Hierarchy** to open its **Inspector**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中选择`VisualElement`以打开其**检查器**。
- en: You may notice that the `VisualElement` does not fully fit within the root container.
    Expand the `1`. This will cause the `VisualElement` to fill the whole root container.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能会注意到`VisualElement`并没有完全填充根容器。展开`1`。这将使`VisualElement`填充整个根容器。
- en: '![Figure 18.28: Updating the Grow property](img/B18327_18_28.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图18.28：更新Grow属性](img/B18327_18_28.jpg)'
- en: 'Figure 18.28: Updating the Grow property'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.28：更新Grow属性
- en: Now, let’s center the cat within the `VisualElement`. Expand the `VisualElement`
    and center for both the **Align Items** and **Justify** **Content** properties.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将猫在`VisualElement`内居中。展开`VisualElement`并为中心的**对齐项**和**对齐内容**属性。
- en: '![Figure 18.29: Adjusting the Align properties of the VisualElement](img/B18327_18_29.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图18.29：调整VisualElement的对齐属性](img/B18327_18_29.jpg)'
- en: 'Figure 18.29: Adjusting the Align properties of the VisualElement'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.29：调整VisualElement的对齐属性
- en: Let’s change the background color of the `VisualElement`. In the `BE8D8D` by
    selecting the color block and typing `BE8D8D` into the **Hexidecimal** property.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更改`VisualElement`的背景颜色。在`BE8D8D`中，通过选择颜色块并将`BE8D8D`输入到**十六进制**属性中。
- en: '![Figure 18.30: Adjusting the VisualElement’s background color](img/B18327_18_30.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图18.30：调整VisualElement的背景颜色](img/B18327_18_30.jpg)'
- en: 'Figure 18.30: Adjusting the VisualElement’s background color'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.30：调整VisualElement的背景颜色
- en: Now, it’s easy to see there’s some background and border around our cat `Button`
    that we don’t want. To remove this, select the `Button` and change its background
    color so that the alpha is `0`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，很容易看出我们的猫`Button`周围有一些我们不想要的背景和边框。为了移除它，选择`Button`并更改其背景颜色，使alpha值为`0`。
- en: '![Figure 18.31: Removing the Button’s background color](img/B18327_18_31.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图18.31：移除按钮的背景颜色](img/B18327_18_31.jpg)'
- en: 'Figure 18.31: Removing the Button’s background color'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.31：移除按钮的背景颜色
- en: 'There is still a border around the `Button` that we don’t want. Expand the
    `0`. You should now have the following:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮周围仍然有一个我们不想要的边框。展开`0`。你现在应该有以下内容：
- en: '![Figure 18.32: The final UI look](img/B18327_18_32.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图18.32：最终的UI外观](img/B18327_18_32.jpg)'
- en: 'Figure 18.32: The final UI look'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.32：最终的UI外观
- en: We’re almost done with the UI Builder. The last thing we need to do is rename
    `Button` so that it will be easily accessible in our C# code. Double-click on
    `Button` in the `CatButton`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了UI构建器。我们需要做的最后一件事是将`Button`重命名，以便在C#代码中易于访问。在`CatButton`中双击`Button`。
- en: 'Save your work by pressing *Ctrl* + *S* and we’re done! You should have the
    following:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *Ctrl* + *S* 保存你的工作，我们就完成了！你应该会有以下内容：
- en: '![Figure 18.33: The IdleCat.uxml Hierarchy with appropriate names](img/B18327_18_33.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.33：IdleCat.uxml 层级结构及其适当的名称](img/B18327_18_33.jpg)'
- en: 'Figure 18.33: The IdleCat.uxml Hierarchy with appropriate names'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.33：IdleCat.uxml 层级结构及其适当的名称](img/B18327_18_33.jpg)'
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a **UIDocument** GameObject was added to your currently open scene, you may
    see a warning about a Panel Setting missing in your **Console**. You can just
    delete this GameObject and dismiss the error message.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在当前打开的场景中添加了一个 **UIDocument** 游戏对象，你可能会在 **控制台** 中看到一个关于缺少面板设置的警告。你可以直接删除这个游戏对象并忽略错误信息。
- en: Now that our UI is fully laid out, we can write the code to start adding in
    the functionality!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在UI已经完全布局，我们可以编写代码来开始添加功能！
- en: Writing C# code to make our Editor Window and add functionality
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 C# 代码以创建我们的编辑器窗口并添加功能
- en: 'To get our cat to appear as a window in our Unity Editor and have functionality,
    we need to write some C# Editor code. There are a few things we want the cat to
    do:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的猫在 Unity 编辑器中以窗口的形式出现并具有功能，我们需要编写一些 C# 编辑器代码。我们希望猫能做几件事情：
- en: Appear in a floating window when you use a **Tools** menu or use pre-defined
    hotkeys
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用 **工具** 菜单或使用预定义的热键时，出现在浮动窗口中
- en: Say “meow” when you hover over it
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你悬停在它上面时说“喵”
- en: Compliment you in the **Console** when you click on it
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你点击它时在 **控制台** 中赞美你
- en: Sit with a looping idle animation
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐着循环的空闲动画
- en: Play a standing animation when you click on it (aka pet it)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你点击它时播放站立动画（即抚摸它）
- en: 'We can achieve all of this in one C# script. To have your virtual pet appear
    in a window within your Unity Editor, complete the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个 C# 脚本中实现所有这些。为了让你的虚拟宠物在 Unity 编辑器中的窗口内出现并具有功能，请完成以下步骤：
- en: Within your `Editor` folder, create a C# script called `IdleCat.cs` and open
    it.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Editor` 文件夹中，创建一个名为 `IdleCat.cs` 的 C# 脚本并打开它。
- en: 'The first thing we need to do is change our script from a `MonoBehaviour` to
    an `EditorWindow`. Change the class definition to the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将脚本从 `MonoBehaviour` 改为 `EditorWindow`。将类定义改为以下内容：
- en: '[PRE6]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will automatically add the `UnityEditor` namespace.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将自动添加 `UnityEditor` 命名空间。
- en: 'We will have the window appear by selecting `IdleCat.cs` script:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过选择 `IdleCat.cs` 脚本来使窗口出现：
- en: '[PRE7]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, the `[MenuItem("Tools/I'm Lonely _%#K")]` line creates
    the `ShowIdleCat()` method when it is selected. `_%#K` signifies that this can
    also be achieved with the *Ctrl* + *Shift* + *K* shortcut.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`[MenuItem("Tools/I'm Lonely _%#K")]` 行在选中时创建 `ShowIdleCat()` 方法。`_%#K`
    表示这也可以通过 *Ctrl* + *Shift* + *K* 快捷键实现。
- en: 'The following lines instantiate the window and set its title to **Kitty**:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下行实例化了窗口并将其标题设置为 **Kitty**：
- en: '[PRE8]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save your code and you should see the menu item in your Editor. Clicking it
    or typing *Ctrl* + *Shift* + *K* should bring up a window named **Kitty**.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存你的代码，你应该能在编辑器中看到菜单项。点击它或按 *Ctrl* + *Shift* + *K* 应该会弹出一个名为 **Kitty** 的窗口。
- en: '![Figure 18.34: The Tools menu and the Kitty window](img/B18327_18_34.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.34：工具菜单和 Kitty 窗口](img/B18327_18_34.jpg)'
- en: 'Figure 18.34: The Tools menu and the Kitty window'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.34：工具菜单和 Kitty 窗口](img/B18327_18_34.jpg)'
- en: 'Your window may be a different size than mine. Don’t worry. Let’s set the size
    via code. Add the following two lines of code to your `ShowIdleCat()` method:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的窗口可能和我的大小不同。不用担心。让我们通过代码设置大小。将以下两行代码添加到你的 `ShowIdleCat()` 方法中：
- en: '[PRE9]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will not automatically change the size of your currently open window, because
    this function only runs when you use the menu item or the shortcut keys. You can
    now resize your window by doing one of those actions now. You do not need to close
    the window. You can do this while it is still open.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不会自动改变你当前打开窗口的大小，因为这个函数只在你使用菜单项或快捷键时运行。你现在可以通过执行这些操作之一来调整窗口大小。你不需要关闭窗口。你可以在它仍然打开时这样做。
- en: One thing to note is that Editor Windows can be docked throughout the Unity
    Editor. So, the size of your window can change based on where the user docks it.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，编辑器窗口可以在 Unity 编辑器中停靠。因此，你的窗口大小可以根据用户停靠的位置而改变。
- en: Now, we need to reference the UI Document we created with the UI Builder in
    this script. Since this is an Editor script, it can’t be attached to a GameObject.
    That means we can’t assign the variable via drag and drop or using `GetComponent`.
    Instead, we will have to load it via from our `Editor/Resources` folder.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要引用在这个脚本中用UI Builder创建的UI文档。由于这是一个编辑器脚本，它不能附加到GameObject上。这意味着我们无法通过拖放或使用`GetComponent`来分配变量。相反，我们必须通过从我们的`Editor/Resources`文件夹中加载它。
- en: When working with Editor UI, the `CreateGUI()` method is an Event Function used
    to initialize the UI.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用编辑器UI时，`CreateGUI()`方法是一个用于初始化UI的事件函数。
- en: 'Write the following code, making sure to add the `UnityEngine.UIElements` namespace
    to the top of the script:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写以下代码，确保将`UnityEngine.UIElements`命名空间添加到脚本顶部：
- en: '[PRE10]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code block does a few things. First, it gets the `rootVisualElement` of
    the Editor Window we have created. Then, it finds the `IdleCat.uxml` file by searching
    for a `VisualTreeAsset` named `IdleCat` within the `Editor/Resources` folder.
    Then, it clones the `IdleCat.uxml` UI Document and places it within the window’s
    root.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码块执行了几件事。首先，它获取我们创建的编辑器窗口的`rootVisualElement`。然后，它通过在`Editor/Resources`文件夹中搜索名为`IdleCat`的`VisualTreeAsset`来找到`IdleCat.uxml`文件。然后，它克隆`IdleCat.uxml`
    UI文档并将其放置在窗口的根目录中。
- en: If you return to the Editor, you should now see your Kitty on the pink background
    in your open window.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您返回到编辑器，现在您应该能够在打开的窗口中看到您的Kitty在粉红色的背景上。
- en: '![Figure 18.35: The window with the appropriate size and UI Document](img/B18327_18_35.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图18.35：具有适当大小和UI文档的窗口](img/B18327_18_35.jpg)'
- en: 'Figure 18.35: The window with the appropriate size and UI Document'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.35：具有适当大小和UI文档的窗口
- en: 'Now, we need to get access to the button. Add the following variable declaration
    to your script:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要获取按钮的访问权限。将以下变量声明添加到您的脚本中：
- en: '[PRE11]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To assign the `catButton`, we need to `Query` the `root` object. Add the following
    line to your `CreateGUI()` method:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了分配`catButton`，我们需要`Query``root`对象。将以下行添加到您的`CreateGUI()`方法中：
- en: '[PRE12]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, let’s have the tooltip appear when we hover over the button. Add the
    following line of code to the `CreateGUI()` method:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在悬停在按钮上时显示提示。将以下行代码添加到`CreateGUI()`方法中：
- en: '[PRE13]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After you save the script, you should be able to immediately see these changes
    reflected in your Editor. (Note that my screenshot tool doesn’t capture the mouse
    cursor, so it is not shown in the following figure.)
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存脚本后，您应该能够立即在编辑器中看到这些更改的反映。（注意，我的截图工具没有捕获鼠标光标，所以它没有显示在下面的图中。）
- en: '![Figure 18.36: The meow tooltip](img/B18327_18_36.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图18.36：喵喵提示](img/B18327_18_36.jpg)'
- en: 'Figure 18.36: The meow tooltip'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.36：喵喵提示
- en: 'Now, we can have the cat compliment you when you click on it. First, let’s
    create a new method called `OnCatButtonClicked()` that shows the `"You''re doing
    great!"` message in the Console. Add the following code to your script:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您点击猫时，我们可以让它赞美您。首先，让我们创建一个名为`OnCatButtonClicked()`的新方法，该方法在控制台中显示`"You're
    doing great!"`消息。将以下代码添加到您的脚本中：
- en: '[PRE14]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to have the `OnCatButtonClicked()` method subscribe and unsubscribe
    to the click event on `catButton`. Add the following line to your `CreateGUI()`
    method:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要让`OnCatButtonClicked()`方法订阅和取消订阅`catButton`上的点击事件。将以下行添加到您的`CreateGUI()`方法中：
- en: '[PRE15]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, create the following `OnDisable()` method:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，创建以下`OnDisable()`方法：
- en: '[PRE16]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once you save, you can already see the cat compliment you in the Console when
    you click on it.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存后，您可以在点击它时在控制台中看到猫在赞美您。
- en: '![Figure 18.37: The complimenting cat](img/B18327_18_37.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图18.37：赞美的猫](img/B18327_18_37.jpg)'
- en: 'Figure 18.37: The complimenting cat'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.37：赞美的猫
- en: Our last two goals for our virtual pet involve animating it. This takes a bit
    of effort. We can’t use a Unity animation to achieve it because we’re in the Editor.
    So, we have to write code that will swap out the background on our `catButton`
    with the appropriate image via code on some kind of timer.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对虚拟宠物的最后两个目标涉及动画。这需要一些努力。我们不能使用Unity动画来实现它，因为我们处于编辑器中。因此，我们必须编写代码，通过某种定时器在代码中用适当的图像替换`catButton`的背景。
- en: One way to do this is with **coroutines**, but unfortunately, coroutines do
    not work by default in the Editor. However, we can use coroutines in our Editor
    by importing the Editor Coroutines package from Unity.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是用**协程**，但不幸的是，默认情况下协程在编辑器中不工作。然而，我们可以通过从Unity导入编辑器协程包在我们的编辑器中使用协程。
- en: To do that, select **Window** | **Package Manager** to open the **Package Manager**.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要做到这一点，选择**窗口** | **包管理器**以打开**包管理器**。
- en: 'Select **Package: Unity Registry** from the dropdown to view all available
    Unity packages.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从下拉菜单中选择 **Package: Unity Registry** 以查看所有可用的 Unity 包。'
- en: '![Figure 18.38: Changing which packages appear in the Package Manager](img/B18327_18_38.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.38：更改 Package Manager 中显示的包](img/B18327_18_38.jpg)'
- en: 'Figure 18.38: Changing which packages appear in the Package Manager'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.38：更改 Package Manager 中显示的包
- en: Now, scroll until you see **Editor Coroutines**. It will likely be locked. If
    it is, select **Unlock**.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，滚动直到您看到 **Editor Coroutines**。它可能被锁定。如果是这样，请选择 **解锁**。
- en: '![Figure 18.39: Unlocking the Editor Coroutines package](img/B18327_18_39.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.39：解锁 Editor Coroutines 包](img/B18327_18_39.jpg)'
- en: 'Figure 18.39: Unlocking the Editor Coroutines package'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.39：解锁 Editor Coroutines 包
- en: 'Now that you’ve unlocked the Editor Coroutines package, you can add the following
    namespace to the top of your `IdleCat.cs` script:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经解锁了 Editor Coroutines 包，您可以将以下命名空间添加到您的 `IdleCat.cs` 脚本顶部：
- en: '[PRE17]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we can use `EditorCoroutines` in our code! They work pretty similarly to
    regular coroutines. But, before we write our first Editor coroutine to control
    our animations, let’s get access to the images we’ll want to use in our animation
    and write some helper functions.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的代码中使用 `EditorCoroutines`！它们的工作方式与常规协程非常相似。但在我们编写第一个用于控制动画的 Editor
    协程之前，让我们获取我们将在动画中使用的图像，并编写一些辅助函数。
- en: 'I want the cat to have two animations: an idle animation and a petting animation
    (which will be triggered by the mouse click). I’ll store the images for these
    animations in two separate Lists. To use them as background images, I’ll need
    to store them in lists of `StyleBackgrounds`. Add the following to your class:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想猫有两个动画：一个空闲动画和一个抚摸动画（将由鼠标点击触发）。我将将这些动画的图像存储在两个单独的列表中。为了将它们用作背景图像，我需要将它们存储在
    `StyleBackgrounds` 列表中。将以下内容添加到您的类中：
- en: '[PRE18]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before we can store the appropriate sprites in those Lists, we need to get
    a reference to all of the sprites from the sprite sheet. We’ll do this similarly
    to how we found the UI Document file earlier. Add the following line of code to
    your `CreateGUI()` method:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以将这些适当的精灵存储到这些列表中之前，我们需要获取精灵表中的所有精灵的引用。我们将这样做，类似于我们之前找到 UI 文档文件的方式。将以下代码行添加到您的
    `CreateGUI()` 方法中：
- en: '[PRE19]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will look in the `Editor/Resources` folder and store all of the sprites
    with the name `idleCat` to the `allSprites` array.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在 `Editor/Resources` 文件夹中查找，并将所有名为 `idleCat` 的精灵存储到 `allSprites` 数组中。
- en: 'The following frames will represent the specific animations:![Figure 18.40:
    Which sprites go to which animation](img/B18327_18_40.jpg)'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下帧将代表特定的动画：![图 18.40：哪些精灵属于哪个动画](img/B18327_18_40.jpg)
- en: 'Figure 18.40: Which sprites go to which animation'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.40：哪些精灵属于哪个动画
- en: 'Now, we need to loop through the `allSprites` array and divvy those sprites
    up into the correct list. We can do so by adding the following code to the `CreateGUI()`
    method:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要遍历 `allSprites` 数组，并将这些精灵分配到正确的列表中。我们可以通过将以下代码添加到 `CreateGUI()` 方法中来实现这一点：
- en: '[PRE20]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before we can write the methods that swap out the background with the correct
    image, we need to add a variable that will keep track of which frame of which
    animation the button is currently displaying. Add the following variable initialization
    to your class:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以编写替换背景的正确图像的方法之前，我们需要添加一个变量来跟踪按钮当前显示的哪个动画的哪个帧。将以下变量初始化添加到您的类中：
- en: '[PRE21]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'OK, now we need to write methods that will increase the `animationIndex` and
    set the `catButton`’s `backgroundImage` to the appropriate sprite. Add the following
    method to your class to control the animation for the idle animation:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们需要编写方法来增加 `animationIndex` 并将 `catButton` 的 `backgroundImage` 设置为适当的精灵。将以下方法添加到您的类中，以控制空闲动画的动画：
- en: '[PRE22]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that when the index is out of range, it loops back around to `0`.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当索引超出范围时，它会循环回到 `0`。
- en: 'Add a similar method to control the petting animation:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类似的方法来控制抚摸动画：
- en: '[PRE23]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **IdleAnimation()** and **PettingAnimation()** methods have some reusable
    code and could be refactored for brevity; however, for clarity, I will keep it
    the way it is.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**IdleAnimation()** 和 **PettingAnimation()** 方法有一些可重用的代码，可以为了简洁而重构；然而，为了清晰起见，我将保持原样。'
- en: 'Now, we’re ready to use an `EditorCortoutine` to call these methods and get
    the animations playing. Let’s start by creating the following Editor coroutine:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用 `EditorCortoutine` 来调用这些方法并播放动画。让我们先创建以下 Editor 协程：
- en: '[PRE24]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will create an infinite loop that runs the `IdleAnimation()` method every
    second.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个无限循环，每秒运行一次 `IdleAnimation()` 方法。
- en: 'We need to start the Editor coroutine that we wrote in the previous step. Add
    the following code to your `CreateGUI()` method:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要启动我们在上一步中编写的编辑器协程。在你的`CreateGUI()`方法中添加以下代码：
- en: '[PRE25]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you return to your Editor, you should be able to see the cat flicking its
    tail while it loops through its idle animation. Now, we need to write some code
    that will make the petting animation play when you click on the cat. To do this,
    we need another variable. Add the following to your class:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你回到你的编辑器，你应该能看到猫在循环空闲动画时摇尾巴。现在，我们需要编写一些代码，以便当你点击猫时播放抚摸动画。为此，我们需要另一个变量。在你的类中添加以下内容：
- en: '[PRE26]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This variable will keep track of whether or not the cat should be idling.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个变量将跟踪猫是否应该处于空闲状态。
- en: 'Add the following to the `OnCatButtonClicked()` method to signify cat should
    no longer be idle once it is clicked:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCatButtonClicked()`方法中添加以下内容，以表示点击后猫不再空闲：
- en: '[PRE27]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update the `NextAnimationFrame()` Editor coroutine so that it switches between
    the idle and petting animations based on the `idle` variable. The code in bold
    is new:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`NextAnimationFrame()`编辑器协程，使其根据`idle`变量在空闲和抚摸动画之间切换。粗体的代码是新的：
- en: '[PRE28]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Currently, if you click on the cat, it will enter the petting animation, but
    it will keep looping through that animation indefinitely. We need it to go back
    to the idle animation once the petting animation completes. Update the `PettingAnimation()`
    method to include `idle = true` inside the `if` statement. This will reset the
    `idle` variable to `true` when the animation is complete.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，如果你点击猫，它将进入抚摸动画，但会无限循环该动画。我们需要它在抚摸动画完成后回到空闲动画。更新`PettingAnimation()`方法，在`if`语句中包含`idle
    = true`。这将使动画完成后将`idle`变量重置为`true`。
- en: 'We’ve officially completed everything we set out to do, but there is one problem
    with our code. If you put a `Debug.Log` in the coroutine’s `while` loop and then
    close the `Debug.Log` keeps printing in the Console! We need to stop that coroutine’s
    `while` loop when the window closes. To do that, add another variable to your
    class:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经正式完成了我们设定的所有任务，但我们的代码中有一个问题。如果你在协程的`while`循环中放置一个`Debug.Log`，然后关闭它，`Debug.Log`仍然会在控制台中打印！我们需要在窗口关闭时停止该协程的`while`循环。为此，在你的类中添加另一个变量：
- en: '[PRE29]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change the `while` loop within the `NextAnimationFrame()` coroutine to the
    following:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NextAnimationFrame()`协程中的`while`循环更改为以下内容：
- en: '[PRE30]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we just need to set `windowOpen` to `false` when the window closes. So,
    add the following to the `OnDisable()` method:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要在窗口关闭时将`windowOpen`设置为`false`。所以，在`OnDisable()`方法中添加以下内容：
- en: '[PRE31]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That’s it! You should now have a little kitty friend that hangs out with you
    while you work. Click on her whenever you need a little pick-me-up.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在应该有一个小猫咪朋友，它会陪伴你工作。当你需要一点提神的时候，随时点击她。
- en: Using the UI Toolkit to make a menu with style sheets and animation transitions
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UI工具包制作具有样式表和动画过渡的菜单
- en: We’ll look at how to use the UI Builder to create a basic menu that uses style
    sheets and transition animations, then we’ll hook up buttons within the menu to
    access web data and randomly generate content in this example.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看如何使用UI Builder创建一个使用样式表和过渡动画的基本菜单，然后在这个例子中我们将连接菜单内的按钮以访问网络数据和随机生成内容。
- en: Since the last example was a virtual pet meant to bring you happiness, I decided
    to stick with the theme of “self-care” for this example, as well. The following
    figure is a screenshot of the UI we will make with a randomly generated image
    of a cat and a quote retrieved from the web.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一个例子是一个旨在带给你快乐的虚拟宠物，我决定在这个例子中也坚持“自我关怀”的主题。以下图是我们将使用随机生成的猫的图片和从网络上检索到的引言制作的UI截图。
- en: '![Figure 18.41: The UI menu with randomly generated content](img/B18327_18_41.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图18.41：带有随机生成内容的UI菜单](img/B18327_18_41.jpg)'
- en: 'Figure 18.41: The UI menu with randomly generated content'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.41：带有随机生成内容的UI菜单
- en: Pressing the **Charm Me** button will randomly generate a cat picture and pressing
    the **Inspire Me** button will randomly generate an inspirational quote. Additionally,
    the buttons change color when hovered over and clicked on while animating to a
    slightly bigger shape.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**Charm Me**按钮将随机生成一张猫的图片，按下**Inspire Me**按钮将随机生成一句励志的引言。此外，当鼠标悬停或点击按钮时，按钮会改变颜色，并在动画过程中略微变大。
- en: As with the previous example, we will start by laying out the UI with the UI
    Builder.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个例子一样，我们将首先使用UI Builder来布局UI。
- en: Using the UI Builder to lay out a menu, make style sheets, and make animation
    transitions
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 UI Builder 布局菜单、制作样式表和制作动画过渡
- en: 'To create the UI shown in *Figure 18**.41*, complete the following steps:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建如图 *图 18**.41* 所示的 UI，请完成以下步骤：
- en: Create a new scene called `Chapter18-Examples`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter18-Examples` 的新场景。
- en: Right-click in the Scene Hierarchy and select `Assets` folder called `UI Toolkit`.
    It will contain a `PanelSettings` asset and a `Unity` `Themes` folder.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景层次结构中右键单击并选择名为 `UI Toolkit` 的 `Assets` 文件夹。它将包含一个 `PanelSettings` 资产和一个 `Unity`
    `Themes` 文件夹。
- en: Within the `UI Toolkit` folder, right-click and select `InspirationalMenu.uxml`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UI Toolkit` 文件夹中，右键单击并选择 `InspirationalMenu.uxml`。
- en: Drag the new UXML file into the `UIDocument` GameObject.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 UXML 文件拖入 `UIDocument` 游戏对象。
- en: Just so that we have the same Game view resolution, set your Game scene view
    to **840x630**.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们有相同的游戏视图分辨率，将你的游戏场景视图设置为 **840x630**。
- en: '![Figure 18.42: Setting your Game view resolution](img/B18327_18_42.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.42：设置你的游戏视图分辨率](img/B18327_18_42.jpg)'
- en: 'Figure 18.42: Setting your Game view resolution'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.42：设置你的游戏视图分辨率
- en: Double-click on the `InspirationalMenu.uxml` file to open the UI Builder.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `InspirationalMenu.uxml` 文件以打开 UI Builder。
- en: Select `InspirationalMenu.uxml` from the **Hierarchy** to view its **Inspector**.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中选择 `InspirationalMenu.uxml` 以查看其**检查器**。
- en: Change the **Canvas Size** to **Match Game View**. This will cause the container
    in the **Viewport** to be the same size as your Game view.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**画布大小**调整为**匹配游戏视图**。这将导致**视口**中的容器大小与你的游戏视图相同。
- en: '![Figure 18.43: Setting the Canvas Size to Match Game View](img/B18327_18_43.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.43：设置画布大小以匹配游戏视图](img/B18327_18_43.jpg)'
- en: 'Figure 18.43: Setting the Canvas Size to Match Game View'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.43：设置画布大小以匹配游戏视图
- en: Drag a **Button** from the **Controls** window into the **Viewport**. It should
    stretch all the way across the container.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控件**窗口中将 **Button** 拖入 **视口**。它应该延伸到容器整个宽度。
- en: The `Button` should have a blue outline around it and a handle in its bottom-right
    corner. Select that handle to resize the button to a pleasing “button-like” size.
    It’s up to you what size.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Button` 应该有一个蓝色轮廓围绕它，并在其右下角有一个把手。选择该把手以调整按钮到令人愉悦的“按钮”大小。大小由你决定。'
- en: '![Figure 18.44: The Button element resized in the Viewport](img/B18327_18_44.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.44：视口中的按钮元素调整大小](img/B18327_18_44.jpg)'
- en: 'Figure 18.44: The Button element resized in the Viewport'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.44：视口中的按钮元素调整大小
- en: Change the text on `Button` to `Charm Me` by adjusting the **Text** property.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调整**文本**属性，将 `Button` 上的文本更改为 `Charm Me`。
- en: '![Figure 18.45: How to change the text that displays on the button](img/B18327_18_45.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.45：如何更改按钮上显示的文本](img/B18327_18_45.jpg)'
- en: 'Figure 18.45: How to change the text that displays on the button'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.45：如何更改按钮上显示的文本
- en: Expand the `22`, and the **Alignment** to center vertically and horizontally.
    Drag the handle of the button to make it a bit bigger or smaller as needed to
    fit the new text size.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `22` 和**对齐**以垂直和水平居中。根据需要拖动按钮的把手以使其稍微大一点或小一点以适应新的文本大小。
- en: '![Figure 18.46: The Text settings of Button](img/B18327_18_46.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.46：按钮的文本设置](img/B18327_18_46.jpg)'
- en: 'Figure 18.46: The Text settings of Button'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.46：按钮的文本设置
- en: Expand the `FF9BC8`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `FF9BC8`。
- en: '![Figure 18.47: Changing the background color of the button](img/B18327_18_47.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.47：更改按钮的背景颜色](img/B18327_18_47.jpg)'
- en: 'Figure 18.47: Changing the background color of the button'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.47：更改按钮的背景颜色
- en: Expand the `5`, and the `10`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `5` 和 `10`。
- en: '![Figure 18.48: Adjusting the Border properties](img/B18327_18_48.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.48：调整边框属性](img/B18327_18_48.jpg)'
- en: 'Figure 18.48: Adjusting the Border properties'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.48：调整边框属性
- en: 'If you go to your **Game** view, you’ll notice that the colors aren’t exactly
    the same as they are in the UI Builder.![Figure 18.49: The difference between
    the UI Builder Viewport and Editor Game View](img/B18327_18_49.jpg)'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你转到你的**游戏**视图，你会注意到颜色与 UI Builder 中的颜色不完全相同。![图 18.49：UI Builder 视口和编辑器游戏视图之间的差异](img/B18327_18_49.jpg)
- en: 'Figure 18.49: The difference between the UI Builder Viewport and Editor Game
    View'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.49：UI Builder 视口和编辑器游戏视图之间的差异
- en: To make sure what you are seeing in the UI Builder matches your **Game** view,
    select **Unity Default Runtime Theme** from the dropdown in the top-right corner
    of the UI Builder Viewport.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要确保你在 UI Builder 中看到的内容与你的**游戏**视图相匹配，请从 UI Builder 视口右上角的下拉菜单中选择**Unity 默认运行时主题**。
- en: '![Figure 18.50: Setting the Viewport to Unity Default Runtime Theme](img/B18327_18_50.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 18.50：将视口设置为 Unity 默认运行时主题](img/B18327_18_50.jpg)'
- en: 'Figure 18.50: Setting the Viewport to Unity Default Runtime Theme'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.50：将视口设置为 Unity 默认运行时主题
- en: Change the color of the `Button`’s **Text** to white.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Button` 的 **文本** 颜色更改为白色。
- en: '![Figure 18.51: Changing the Text color](img/B18327_18_51.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.51：更改文本颜色](img/B18327_18_51.jpg)'
- en: 'Figure 18.51: Changing the Text color'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.51：更改文本颜色
- en: Now, let’s create a Panel that will hold the `Button`. We will create the second
    button momentarily. Drag a **VisualElement** from the **Containers** **Library**
    to the **Viewport**.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个将包含 `Button` 的面板。我们将稍后创建第二个按钮。从 **容器** **库** 中拖动一个 **VisualElement**
    到 **视口**。
- en: In the same way that you resized the `Button`, resize the `ViusalElement` to
    a reasonable Panel size.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与你调整 `Button` 大小的方式相同，将 `VisualElement` 调整到合理的面板大小。
- en: '![Figure 18.52: Resizing the VisualElement](img/B18327_18_52.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.52：调整 VisualElement 的大小](img/B18327_18_52.jpg)'
- en: 'Figure 18.52: Resizing the VisualElement'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.52：调整 VisualElement 的大小
- en: Set the background color of the `VisualElement` to `FFEFEF`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `VisualElement` 的背景颜色设置为 `FFEFEF`。
- en: 'Set the `5` and a `6`. You should see the following in your Viewport:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `5` 和 `6`。你应该在你的视图中看到以下内容：
- en: '![Figure 18.53: The Panel with its new settings](img/B18327_18_53.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.53：具有新设置的 Panel](img/B18327_18_53.jpg)'
- en: 'Figure 18.53: The Panel with its new settings'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.53：具有新设置的 Panel
- en: Now, let’s make the `Button` a child of the `VisualElement` Panel. In the `Button`
    onto `VisualElement`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将 `Button` 设置为 `VisualElement` 面板的子元素。在 `Button` 上点击并拖动到 `VisualElement`。
- en: '![Figure 18.54: Parenting the Button to the VisualElement](img/B18327_18_54.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.54：将 Button 添加到 VisualElement 中](img/B18327_18_54.jpg)'
- en: 'Figure 18.54: Parenting the Button to the VisualElement'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.54：将 Button 添加到 VisualElement 中
- en: 'I want to have two sections of the Panel: the left section that holds the buttons
    and the right section that holds the image of the cat and the inspirational quote.
    Add a `VisualElement` as a child of the `VisualElement` that represents the Panel.
    You’ll notice that it automatically stacks under the `Button` in the Viewport.'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想在面板中有两个部分：左侧部分包含按钮，右侧部分包含猫的图片和励志引言。将一个 `VisualElement` 添加到表示面板的 `VisualElement`
    中作为子元素。你会注意到它自动堆叠在视口中的 `Button` 下方。
- en: '![Figure 18.55: Adding in a new VisualElement](img/B18327_18_55.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.55：添加一个新的 VisualElement](img/B18327_18_55.jpg)'
- en: 'Figure 18.55: Adding in a new VisualElement'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.55：添加一个新的 VisualElement
- en: Make the `Button` a child of the new `VisualElement`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Button` 设置为新 `VisualElement` 的子元素。
- en: 'Now, resize the `VisualElement` so that it takes up a portion of the left side
    of the Panel by clicking and dragging its blue handle. You should have something
    that looks like the following:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调整 `VisualElement` 的大小，使其占据面板左侧的一部分，通过点击并拖动其蓝色手柄。你应该得到以下类似的内容：
- en: '![Figure 18.56: Resizing the VisualElement](img/B18327_18_56.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.56：调整 VisualElement 的大小](img/B18327_18_56.jpg)'
- en: 'Figure 18.56: Resizing the VisualElement'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.56：调整 VisualElement 的大小
- en: 'Now, add another `VisualElement` as a child of the highest-level `VisualElement`.
    You will see something like the following:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加另一个 `VisualElement` 作为最高级 `VisualElement` 的子元素。你将看到以下内容：
- en: '![Figure 18.57: Adding another VisualElement to the Hierarchy](img/B18327_18_57.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.57：向层次结构中添加另一个 VisualElement](img/B18327_18_57.jpg)'
- en: 'Figure 18.57: Adding another VisualElement to the Hierarchy'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.57：向层次结构中添加另一个 VisualElement
- en: 'Select the top-most `VisualElement` and change the `VisualElement` or in the
    Inspector.![Figure 18.58: Setting the Flex Direction to row](img/B18327_18_58.jpg)'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最顶层的 `VisualElement` 并更改 `VisualElement` 或在检查器中。![图 18.58：设置 Flex 方向为行](img/B18327_18_58.jpg)
- en: 'Figure 18.58: Setting the Flex Direction to row'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.58：设置 Flex 方向为行
- en: Doing this will cause its two `VisualElement` children to line up left to right
    rather than top to bottom.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做将导致其两个 `VisualElement` 子元素从左到右排列，而不是从上到下。
- en: Select the bottom-most `VisualElement` from the Hierarchy. In its `1`. This
    will cause the `VisualElement` to fill up the available space within its parent.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择最底层的 `VisualElement`。在其 `1` 中。这将导致 `VisualElement` 填充其父元素内的可用空间。
- en: Now, we want to make the Panel centered on the screen. To do this, we need to
    create another `VisualElement` that will hold it so that we can center it within
    its parent. Add another `VisualElement` to the Hierarchy.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望将面板居中显示在屏幕上。为此，我们需要创建另一个 `VisualElement` 来容纳它，这样我们就可以在其父元素内居中。向层次结构中添加另一个
    `VisualElement`。
- en: Drag the `VisualElement` that represents the Panel in the Hierarchy so that
    it is a child of the new `VisualElement`. In the following figure, the elements
    encircled by the red rectangle in the Hierarchy are the elements that represent
    the Panel and its children.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表示面板的 `VisualElement` 在层次结构中拖动，使其成为新 `VisualElement` 的子元素。在下面的图中，层次结构中用红色矩形圈出的元素代表面板及其子元素。
- en: '![Figure 18.59: The Hierarchy of our current layout](img/B18327_18_59.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.59：我们当前布局的层次结构](img/B18327_18_59.jpg)'
- en: 'Figure 18.59: The Hierarchy of our current layout'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.59：我们当前布局的层次结构
- en: Select the top-most `VisualElement` in the Hierarchy. You’ll see it doesn’t
    fill the entire root container. Set its `1` so it will fill the available space.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择层次结构中最顶层的 `VisualElement`。你会看到它没有填充整个根容器。将其设置为 `1` 以填充可用空间。
- en: Expand the **Align** property and select center for both the **Align Items**
    and **Justify Content** properties. The Panel should now be centered in the container.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 **Align** 属性，并选择 **Align Items** 和 **Justify Content** 属性的中心。现在面板应该居中在容器中。
- en: 'With the top-most `VisualElement` still selected, change the background image
    by expanding the `pinkBackground` to the **Image**. You should see the following
    at this point:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择最顶层的 `VisualElement` 的情况下，通过将 `pinkBackground` 展开到 **Image** 来更改背景图像。此时你应该会看到以下内容：
- en: '![Figure 18.60: Setting the background image on the background](img/B18327_18_60.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.60：在背景上设置背景图像](img/B18327_18_60.jpg)'
- en: 'Figure 18.60: Setting the background image on the background'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.60：在背景上设置背景图像
- en: 'Let’s add the second button to the Panel. Drag a `Button`. You should see something
    like the following:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向面板添加第二个按钮。拖动一个 `Button`。你应该会看到以下内容：
- en: '![Figure 18.61: Adding a new Button](img/B18327_18_61.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.61：添加新的按钮](img/B18327_18_61.jpg)'
- en: 'Figure 18.61: Adding a new Button'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.61：添加新的按钮
- en: Instead of manually setting all the properties of the new `Button` to match
    the other, we can use a style sheet applied to both. This will make sure they
    both always have the same properties. Select the first `Button` (the one with
    the properties we want) and expand its `button-class` into the textbox and then
    press the **Extract Inlined Styles to New** **Class** button.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不必手动设置新 `Button` 的所有属性以匹配其他按钮，我们可以使用应用于两者的样式表。这将确保它们始终具有相同的属性。选择第一个 `Button`（具有我们想要的属性），将其
    `button-class` 展开到文本框中，然后按下 **Extract Inlined Styles to New Class** 按钮。
- en: '![Figure 18.62: Creating a style sheet with Extract Inlined Styles to New Class](img/B18327_18_62.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.62：使用提取内联样式到新类创建样式表](img/B18327_18_62.jpg)'
- en: 'Figure 18.62: Creating a style sheet with Extract Inlined Styles to New Class'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.62：使用提取内联样式到新类创建样式表
- en: Select **Add to New USS** from the popup that appears.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的弹出菜单中选择**添加到新 USS**。
- en: Save the file in `Asset/UI Toolkit` as `ButtonStyle.uss`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存在 `Asset/UI Toolkit` 中，命名为 `ButtonStyle.uss`。
- en: 'The `ButtonStyle.uss` style sheet should appear in the **StyleSheets** Panel
    now.![Figure 18.63: The new style sheet](img/B18327_18_63.jpg)'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ButtonStyle.uss` 样式表现在应该出现在 **Stylesheets** 面板中。![图 18.63：新的样式表](img/B18327_18_63.jpg)'
- en: 'Figure 18.63: The new style sheet'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.63：新的样式表
- en: You can now apply this style to the unstyled button by dragging `ButtonStyle.uss`
    from the `Button`. Now, the two Buttons will have the same properties.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您可以通过从 `Button` 拖动 `ButtonStyle.uss` 来将此样式应用到未设置样式的按钮上。现在，两个按钮将具有相同的属性。
- en: '![Figure 18.64: The two buttons with the same style sheet](img/B18327_18_64.jpg)'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 18.64：具有相同样式表的两个按钮](img/B18327_18_64.jpg)'
- en: 'Figure 18.64: The two buttons with the same style sheet'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 18.64：具有相同样式表的两个按钮
- en: Change the text on the bottom `Button` to `Inspire Me`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将底部 `Button` 上的文本更改为 `Inspire Me`。
- en: Now, let’s align these buttons in their `VisualElement` parent. Select their
    `VIsualElement` parent and set its `VisualElement` in the Viewport or from the
    **Align** property in the Inspector.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这些按钮在其 `VisualElement` 父元素中对齐。选择它们的 `VisualElement` 父元素，并在视图中设置其 `VisualElement`
    或从检查器中的 **Align** 属性设置。
- en: 'Your UI Builder should look like the following:'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 UI 构建器应该看起来像以下这样：
- en: '![Figure 18.65: The Buttons centered in their VisualElement parent](img/B18327_18_65.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.65：按钮在其 VisualElement 父元素中居中](img/B18327_18_65.jpg)'
- en: 'Figure 18.65: The Buttons centered in their VisualElement parent'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.65：按钮在其 VisualElement 父元素中居中
- en: Now, let’s add in the holders for the cat pictures and the quotes that will
    be generated from the internet. Add a `VisualElement` so that it is a child of
    the bottom-most `VisualElement`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加用于存放猫的图片和从互联网生成的引语的容器。添加一个 `VisualElement`，使其成为最底层的 `VisualElement`
    的子元素。
- en: Resize it so that it is smaller than its `VisualElement` parent.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其调整大小，使其小于其`VisualElement`父元素。
- en: 'Expand the **Position** property on its Inspector and change the position from
    **Relative** to **Absolute**. This will allow you to position it manually by either
    entering the numbers or dragging it into position in the Viewport. Position it
    like so:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其检查器中展开**位置**属性，并将位置从**相对**更改为**绝对**。这将允许您通过输入数字或将其拖动到视口中的位置来手动定位它。定位如下：
- en: '![Figure 18.66: Manually positioning the VIsualElement](img/B18327_18_66.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图18.66：手动定位`VisualElement`](img/B18327_18_66.jpg)'
- en: 'Figure 18.66: Manually positioning the VIsualElement'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.66：手动定位`VisualElement`
- en: Add a `Label` as a sibling of the `VisualElement` we just created.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Label`添加为我们刚刚创建的`VisualElement`的兄弟元素。
- en: Change its **Position** property to **Absolute**, then scale and position it
    as follows.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**位置**属性更改为**绝对**，然后按以下方式缩放和定位。
- en: '![Figure 18.67: Adding a Label to the UI](img/B18327_18_67.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图18.67：向UI添加标签](img/B18327_18_67.jpg)'
- en: 'Figure 18.67: Adding a Label to the UI'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.67：向UI添加标签
- en: Change the `FF9BC8`.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FF9BC8`进行更改。
- en: '![Figure 18.68: The Text property of the Label](img/B18327_18_68.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图18.68：标签的文本属性](img/B18327_18_68.jpg)'
- en: 'Figure 18.68: The Text property of the Label'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.68：标签的文本属性
- en: Delete the text so that there is nothing displayed there.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除文本，以便那里不显示任何内容。
- en: Currently, when you click on the buttons, there is not much of a reaction. This
    makes it difficult for the user to tell if they are clicking the buttons. So,
    let’s give the buttons hover and active states.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，当您点击按钮时，反应不大。这使得用户难以判断他们是否点击了按钮。所以，让我们给按钮添加悬停和活动状态。
- en: Select the `.button-class` in the **StyleSheets** Panel. Right-click on it and
    select **Duplicate**.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**样式表**面板中选择`.button-class`。右键单击它并选择**复制**。
- en: Right-click on the duplicate and rename it to `.button-class:hover`. This naming
    convention indicates that this style will be applied to the button’s hover state.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击副本并重命名为`.button-class:hover`。这种命名约定表示此样式将应用于按钮的悬停状态。
- en: Duplicate it again and rename the new duplicate to `.button-class:active`. This
    naming convention indicates that this style will be applied to the button’s click
    state.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次复制它，并将新副本重命名为`.button-class:active`。这种命名约定表示此样式将应用于按钮的点击状态。
- en: Select the `.button-class:hover` style. In the Inspector, change the `E96FA6`
    and change its size to `200` x `90`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`.button-class:hover`样式。在检查器中，将`E96FA6`更改为`200` x `90`。
- en: Select the `.button-class:active` style. In the Inspector, change the `C35D8B`
    and change its size to `200` x `90`.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`.button-class:active`样式。在检查器中，将`C35D8B`更改为`200` x `90`。
- en: 'You can now preview the changes you made by either playing your game or by
    using the **Viewport** **Preview**. This will show you the hover and active state
    changes.![Figure 18.69: Using Preview in the Viewport to see the Buttons style
    changes](img/B18327_18_69.jpg)'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以通过播放您的游戏或使用**视口****预览**来预览您所做的更改。这将显示悬停和活动状态的变化。![图18.69：在视口中使用预览查看按钮样式更改](img/B18327_18_69.jpg)
- en: 'Figure 18.69: Using Preview in the Viewport to see the Buttons style changes'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图18.69：在视口中使用预览查看按钮样式更改
- en: The buttons now get darker and larger when you hover and click on them.
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您悬停和点击按钮时，按钮现在会变暗并变大。
- en: These style changes on the buttons are fine, but the transition from its standard
    state to the others is a bit drastic. We can add transition animations to the
    `.button-class` style, so when it transitions to the other styles, it will animate
    more smoothly.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些按钮上的样式更改很好，但从一个标准状态到其他状态的变化有点剧烈。我们可以在`.button-class`样式中添加过渡动画，这样当它过渡到其他样式时，它将更加平滑地动画化。
- en: Select the `.button-class` style from the `0.5` and the `EaseIn`. This indicates
    that when the button changes width, it will do so over 0.5 seconds and will ease
    into it.
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从`0.5`和`EaseIn`中选择`.button-class`样式。这表示当按钮更改宽度时，它将在0.5秒内完成，并且会平滑过渡。
- en: '![Figure 18.70: The width transition animation](img/B18327_18_70.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图18.70：宽度过渡动画](img/B18327_18_70.jpg)'
- en: 'Figure 18.70: The width transition animation'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.70：宽度过渡动画
- en: 'Select the `0.5`, and **EaseIn**. Your **Transition Animations** should now
    look like the following. This will ensure that when the width and height of the
    buttons change, it will do so smoothly over 0.5 seconds.![Figure 18.71: The Buttons’
    transition animations](img/B18327_18_71.jpg)'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`0.5`，**EaseIn**。您的**过渡动画**现在应该看起来像以下内容。这将确保当按钮的宽度和高度发生变化时，它将在0.5秒内平滑过渡。![图18.71：按钮的过渡动画](img/B18327_18_71.jpg)
- en: 'Figure 18.71: The Buttons’ transition animations'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图18.71：按钮的过渡动画
- en: Play the Preview to watch the buttons grow gradually as you hover over them.
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 播放预览以查看当您悬停在按钮上时按钮逐渐增长。
- en: 'The last thing we need to do in the UI Builder is give variable names for each
    of these Visual Elements so that we can find them via code. Change the names of
    the various Visual Elements to the following:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI Builder中，我们最后需要做的就是在这些视觉元素上为每个变量命名，这样我们就可以通过代码找到它们。将以下各种视觉元素的名称更改为以下内容：
- en: '![Figure 18.72: Renaming the Visual Elements we’ll want to access via code](img/B18327_18_72.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图18.72：重命名我们想要通过代码访问的视觉元素](img/B18327_18_72.jpg)'
- en: 'Figure 18.72: Renaming the Visual Elements we’ll want to access via code'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.72：重命名我们想要通过代码访问的视觉元素
- en: Whew. That was a lot of steps! But we are officially done with the UI Builder.
    We can now work on our C# scripts to get the functionality we want.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁。这一步真的很多！但我们正式完成了UI Builder。现在我们可以开始编写我们的C#脚本，以获得我们想要的功能。
- en: Using C# code to set VisualElement and Label properties with web data
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用C#代码设置VisualElement和Label属性与网络数据
- en: 'Currently, our Buttons do not do anything but animate when we hover over them
    or click them. We now need to hook them up to some functionality. Our goals for
    the two Buttons when clicked are as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的按钮除了在我们悬停或点击它们时进行动画外，没有任何功能。我们现在需要将它们连接到一些功能。当点击这两个按钮时，我们的目标如下：
- en: '`CharmButton`: This should get cute cat pictures from the internet and replace
    the background of the `CatPic` Visual Element with the cute cat picture.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharmButton`：这个按钮应该从互联网上获取可爱的小猫图片，并用可爱的小猫图片替换`CatPic`视觉元素的背景。'
- en: '`InspireButton`: This should get inspirational quotes from the web, format
    the text, and place it in the `InspirationalQuote` Label.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InspireButton`：这个按钮应该从网络上获取励志名言，格式化文本，并将其放置在`InspirationalQuote`标签中。'
- en: Honestly, what we’ve done up to this point for this example was all I wanted
    to cover when I initially started planning it. However, I got a bit excited about
    randomly generating the `VisualElements` properties and I possibly made the example
    a bit too complicated. We engineers love to over-engineer, after all. This example
    uses concepts of web requests and JSON manipulation. Since web development is
    not a focus of this book, I won’t belabor the code that performs these functions.
    I want the focus of this example to be on the UI-specific code, not the web requests.
    I will explain what each section of code does, but I will not necessarily explain
    it line-by-line.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，到目前为止，为了这个例子，我所想要涵盖的内容就是我在最初开始规划时想要做的所有内容。然而，我对随机生成`VisualElements`属性变得有些兴奋，我可能使这个例子变得有些复杂。毕竟，我们工程师喜欢过度设计。这个例子使用了网络请求和JSON操作的概念。由于网络开发不是本书的重点，我不会详细解释执行这些功能的代码。我想这个例子关注的重点是UI特定的代码，而不是网络请求。我会解释每个代码部分的作用，但我不一定会逐行解释。
- en: 'Before we get to the actual code, I do want to give a brief rundown of the
    two sources we will be getting our data from. We will use the following resources
    to get cat pictures and inspirational quotes, respectively:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入实际代码之前，我想简要介绍一下我们将从其中获取数据的两个来源。我们将使用以下资源分别获取猫图片和励志名言：
- en: '[https://placekitten.com/](https://placekitten.com/)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://placekitten.com/](https://placekitten.com/)'
- en: '[https://zenquotes.io/](https://zenquotes.io/)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://zenquotes.io/](https://zenquotes.io/)'
- en: The Place Kitten website allows you to get a picture of a kitten with a specific
    dimension by simply adding the dimension to the end of the URL. For example, [https://placekitten.com/300/300](https://placekitten.com/300/300)
    displays an image of a kitten that is 300 x 300\. This website is great for adding
    placeholder images when you are developing websites and just need something to
    fill a specific place. Plus, it’s cute!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Place Kitten网站允许您通过简单地将尺寸添加到URL的末尾来获取具有特定尺寸的小猫图片。例如，[https://placekitten.com/300/300](https://placekitten.com/300/300)显示了一个300
    x 300像素的小猫图片。这个网站在您开发网站并只需要填充特定位置时非常有用。而且，它很可爱！
- en: 'The Zen Quotes website hosts an API that allows you to get inspirational quotes.
    An API is a collection of functions that let you interact with its data. What
    types of functions the API has will depend on the use of the API and the design
    paradigm the engineers chose to create it. But generally, an API will have the
    ability to GET data. Zen Quotes allows you to GET inspirational quotes. You can
    GET a single quote or a whole set of them. Visit their site to see what other
    options it has for retrieving data from its database. Zen Quotes returns the data
    you request from it in JSON format. JSON is a format standardization that provides
    information. It will look like the following when you get it:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Zen Quotes 网站提供了一个 API，允许你获取励志名言。API 是一组函数的集合，允许你与其数据交互。API 具有哪些类型的函数将取决于 API
    的使用以及工程师选择创建它的设计范式。但通常，API 将具有获取数据的能力。Zen Quotes 允许你获取励志名言。你可以获取单个名言或一组名言。访问他们的网站以查看它提供的数据检索选项。Zen
    Quotes 以 JSON 格式返回你请求的数据。JSON 是一种信息标准化格式。当你获取它时，它看起来如下：
- en: '[PRE32]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But it can be formatted to look like the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 但它可以格式化为以下样子：
- en: '[PRE33]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I won’t get into the specifics of what the preceding code means, but I will
    point out the important details of the example we cover. If you’d like to learn
    more about JSON format, see the following resource: [https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入解释前面代码的具体含义，但我会指出我们覆盖的示例中的重要细节。如果你想了解更多关于 JSON 格式的信息，请参阅以下资源：[https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp)
- en: 'To finish out this example and have the buttons generate cat pictures and inspirational
    quotes, complete the following steps:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个示例，并让按钮生成猫图片和励志名言，请完成以下步骤：
- en: Create a new C# script in your `Scripts` folder and call it `InspriationalPanel.cs`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Scripts` 文件夹中创建一个新的 C# 脚本，并将其命名为 `InspriationalPanel.cs`。
- en: 'Let’s start with getting a reference to the `UIDocument` we created in the
    previous section. Add the following code to your class, making sure to import
    the `UnityEngine.UIElements` namespace:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从获取到我们在上一节中创建的 `UIDocument` 的引用开始。将以下代码添加到你的类中，确保导入 `UnityEngine.UIElements`
    命名空间：
- en: '[PRE34]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code should look familiar after our Editor code example; the main difference
    is we got the reference to the `UIDocument` by using `GetComponent`. So, we’ll
    need to put this script on the same GameObject that contains our UI Document component.
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码在我们之前的编辑器代码示例之后应该看起来很熟悉；主要区别是我们通过使用 `GetComponent` 获取了 `UIDocument` 的引用。因此，我们需要将此脚本放在包含我们的
    UI 文档组件的同一 GameObject 上。
- en: Go ahead and drag this script onto our `UIDocument` GameObject.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本拖放到我们的 `UIDocument` GameObject 上。
- en: 'Now, create an instance variable for the root Visual Element on the UI Documents
    with the following code in the `Start()` method:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Start()` 方法中使用以下代码创建 UI 文档根 Visual Element 的实例变量：
- en: '[PRE35]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let’s hook up our charm button. Add the following variable declaration:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们连接我们的魅力按钮。添加以下变量声明：
- en: '[PRE36]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following code to the `Start()` method to initialize it:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Start()` 方法中以初始化它：
- en: '[PRE37]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need a method that will run when the `charmButton` is clicked. Update your
    code to appear as follows. The new code is bold. This should all look familiar
    after our previous example:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个在点击 `charmButton` 时运行的方法。更新你的代码如下。新的代码是粗体的。在我们之前的示例之后，这应该看起来都很熟悉：
- en: '[PRE38]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I wanted to add the preceding large block of code because it can essentially
    act as a template for how you will code buttons with the UI Toolkit.
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我想添加前面的代码块，因为它基本上可以作为你使用 UI 工具包编写按钮的模板。
- en: 'Now, we need a reference to the Visual Element called `CatPic` so that we can
    change its background. Add the following code to the `Start()` method:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个名为 `CatPic` 的 Visual Element 的引用，以便我们可以更改其背景。将以下代码添加到 `Start()` 方法中：
- en: '[PRE39]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You may notice that I didn’t make `catPic` a class variable but instead made
    it an instance variable within the `Start()` method. This is because the thing
    we will need to reference the most in this code is the `CatPic`’s style, not the
    `CatPic` itself. So, add the following variable to your class:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会注意到我没有将 `catPic` 设置为类变量，而是在 `Start()` 方法中将其作为实例变量。这是因为在这段代码中我们需要引用最多的不是
    `CatPic` 本身，而是 `CatPic` 的样式。因此，请将以下变量添加到你的类中：
- en: '[PRE40]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, add the following to the `Start()` method:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到 `Start()` 方法中：
- en: '[PRE41]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To get the image for the `catPic` background, we’ll use [https://placekitten.com/](https://placekitten.com/).
    We’ll randomly pick a width and height between 150 and 300, then get a picture
    from [placekitten.com](http://placekitten.com) that fits those dimensions. To
    do so, we will need to use a coroutine since web requests require coroutines.
    Start by creating the following method:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取`catPic`背景的图像，我们将使用[https://placekitten.com/](https://placekitten.com/)。我们将随机选择150到300之间的宽度和高度，然后从[placekitten.com](http://placekitten.com)获取适合这些尺寸的图片。为此，我们需要使用协程，因为网络请求需要协程。首先创建以下方法：
- en: '[PRE42]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is going to show an error in your IDE until you put in the web request.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将在您输入网络请求之前在您的IDE中显示错误。
- en: 'Make sure to add the following namespace to your code so it recognizes what
    an `IEnumerator` is:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将以下命名空间添加到您的代码中，以便它能够识别`IEnumerator`：
- en: '[PRE43]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let’s randomly generate the width and height of the image we will request.
    Add the following to your `GetCatPic()` coroutine to get random numbers and then
    change the `catPic`’s dimensions to match it:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们随机生成我们将请求的图像的宽度和高度。将以下代码添加到您的`GetCatPic()`协程中，以获取随机数字，然后更改`catPic`的尺寸以匹配它：
- en: '[PRE44]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Remember, the format of the URL for a placekitten image is `https://placekitten.com/300/300`.
    So, we need to create a string that replaces the two `300` values with `randomWidth`
    and `randomHeight`. Add the following line of code to your `GetCatPic()` coroutine:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，地点猫图片的URL格式是`https://placekitten.com/300/300`。因此，我们需要创建一个字符串，将两个`300`值替换为`randomWidth`和`randomHeight`。将以下代码行添加到您的`GetCatPic()`协程中：
- en: '[PRE45]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let’s send a web request to the `uri`. Add the following code to your
    `GetCatPic()` coroutine:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向`uri`发送网络请求。将以下代码添加到您的`GetCatPic()`协程中：
- en: '[PRE46]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code tries to get a texture from a website. The `if` prints an
    error if the request fails. Make sure to import the following namespace so your
    script understands what a `UnityWebRequest` is:'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码尝试从网站获取纹理。如果请求失败，`if`将打印错误。确保导入以下命名空间，以便您的脚本理解`UnityWebRequest`：
- en: '[PRE47]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s replace the `// Do stuff here with returned data` part with the
    following code:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`// Do stuff here with returned data`部分替换为以下代码：
- en: '[PRE48]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code will take the picture returned by the web request and store it as
    a `Texture2D`. It then sets the background image of `catPicStyle` to that `Texture2D`
    image.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将网络请求返回的图片存储为`Texture2D`。然后，它将`catPicStyle`的背景图像设置为该`Texture2D`图像。
- en: 'Now, we need to have our button to actually call the `GetCatPic()` coroutine.
    Update the `OnCharmClicked()` method to call the `GetCatPic()` coroutine:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要让我们的按钮实际调用`GetCatPic()`协程。更新`OnCharmClicked()`方法以调用`GetCatPic()`协程：
- en: '[PRE49]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you play the game, you can now click the **Charm Me** button to get random
    cat pictures.
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您玩游戏，现在您可以点击**Charm Me**按钮来获取随机的猫图片。
- en: '![Figure 18.73: Random cat pictures appearing in our UI](img/B18327_18_73.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![图18.73：随机猫图片出现在我们的UI中](img/B18327_18_73.jpg)'
- en: 'Figure 18.73: Random cat pictures appearing in our UI'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.73：随机猫图片出现在我们的UI中
- en: You may notice a little funkiness with the image if you click the button a second
    time. Because the `GetCatPic()` method contains a web request, it takes a moment
    to fetch the image and then turn it into a texture, so whatever image is currently
    in its place will resize, becoming distorted, before the new image loads in.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您第二次点击按钮，可能会注意到图像有一点奇怪。因为`GetCatPic()`方法包含网络请求，它需要一段时间来获取图像并将其转换为纹理，所以当前占位图像将调整大小，变得扭曲，直到新图像加载完成。
- en: 'Instead of letting this happen, let’s remove the original image while the new
    image loads in. Add the following code as the first line of your `GetCatPic()`
    coroutine:'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是让这种情况发生，让我们在加载新图像时移除原始图像。将以下代码作为`GetCatPic()`协程的第一行添加：
- en: '[PRE50]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let’s set up the functionality of the **Inspire Me** button. Add the following
    variable declarations to your class:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置**Inspire Me**按钮的功能。将以下变量声明添加到您的类中：
- en: '[PRE51]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the following method that will be called when the `inspireButton` is clicked:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法，该方法将在点击`inspireButton`时被调用：
- en: '[PRE52]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following code to the `Start()` method. This should all look familiar
    to you by now:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Start()`方法中。现在，这一切都应该对您来说都很熟悉了：
- en: '[PRE53]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s move on to filling in the data for the inspirational quote. We will
    use the [https://zenquotes.io/api/random](https://zenquotes.io/api/random) request
    to retrieve a random quote. If you navigate to that URL in your web browser, you
    can see how the data it returns is formatted. Add the following code to your `InspriationalPanel.cs`
    script:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续填充励志引言的数据。我们将使用[https://zenquotes.io/api/random](https://zenquotes.io/api/random)请求来检索一个随机引言。如果你在网页浏览器中导航到该URL，你可以看到它返回的数据是如何格式化的。将以下代码添加到你的`InspriationalPanel.cs`脚本中：
- en: '[PRE54]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You’ll notice this is structured similarly to the web request we used to get
    our cat image. Before we proceed, let’s explore how the data is returned.
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到这的结构与我们用来获取猫图片的Web请求类似。在我们继续之前，让我们探索一下数据是如何返回的。
- en: 'Update your `OnInspireClicked()` method with the following code:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新你的`OnInspireClicked()`方法：
- en: '[PRE55]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Play the game and click the **Inspire Me** button. You will see something like
    the following in the console:![Figure 18.74: The API request response](img/B18327_18_74.jpg)'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并点击**Inspire Me**按钮。你将在控制台看到如下内容：![图18.74：API请求响应](img/B18327_18_74.jpg)
- en: 'Figure 18.74: The API request response'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图18.74：API请求响应
- en: As you can see, we can’t exactly put the full result into our Label’s text field.
    We need to format this into something usable and get only the information we want.
    To do this most simply, we’ll need another package.
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们无法将完整的结果放入Label的文本字段中。我们需要将其格式化为可用的格式，并只获取我们想要的信息。为此，我们还需要另一个包。
- en: Open the Package Manager with **Window** | **Package Manager**.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用**窗口** | **包管理器**打开包管理器。
- en: Select the plus sign and select **Add package from** **git URL…**.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择加号，然后选择**从git URL添加包…**。
- en: Type `com.unity.nuget.newtonsoft-json` into the textbox and select **Add**.
    After some loading, you should see **Newtonsoft Json** in your packages list.
    This will allow you to easily manipulate JSON data.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中输入`com.unity.nuget.newtonsoft-json`并选择**添加**。经过一些加载后，你应该能在你的包列表中看到**Newtonsoft
    Json**。这将允许你轻松地操作JSON数据。
- en: 'Return to your script and add the following namespace:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的脚本，并添加以下命名空间：
- en: '[PRE56]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If `Newtonsoft` is not recognized by your IDE, close the IDE and Unity and reopen
    it.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的IDE不识别`Newtonsoft`，请关闭IDE和Unity，然后重新打开它。
- en: 'Now, we can parse the data we receive from our API call and get just the information
    we want. The data that is returned by the API call starts with `[`. This means
    that the data we are receiving is coming to us in an array format. So, we need
    to convert the data to an array. Replace `// more code will go here` with the
    following:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以解析我们从API调用中接收到的数据，并获取我们想要的信息。API调用返回的数据以`[`开头。这意味着我们接收到的数据是以数组格式发送的。因此，我们需要将数据转换为数组。将`//
    more code will go here`替换为以下内容：
- en: '[PRE57]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We only want the strings assigned to the `"q"` property and the `"a"` property,
    as these represent the quote and the author respectively. To get this data, we
    need our data to be in an object format. The array that is returned to us only
    has a single array item, so use the following code to convert the array item to
    an object:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只想获取分配给`"q"`属性和`"a"`属性的字符串，因为这些分别代表引言和作者。为了获取这些数据，我们需要我们的数据以对象格式存在。返回给我们的数组只有一个数组项，所以使用以下代码将数组项转换为对象：
- en: '[PRE58]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can get the strings we want. Add the following lines to get the quote
    and the author:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以获取我们想要的字符串。添加以下行以获取引言和作者：
- en: '[PRE59]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last thing to do is change the label’s text to the information we want
    and make sure it’s formatted correctly. I want the quote to appear in quotes.
    Then, on the next line, I want to see something like `~ Author''s Name`. The following
    line of code will do that:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是将标签的文本更改为我们想要的信息，并确保其格式正确。我想引言以引号显示。然后，在下一行，我想看到类似`~ 作者的名字`的内容。以下代码行将做到这一点：
- en: '[PRE60]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Play the game and you should now be able to get pictures of kittens and inspirational
    quotes!
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 玩游戏，你现在应该能够获取到小猫图片和励志引言！
- en: '![Figure 18.75: The final version of our example](img/B18327_18_75.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图18.75：我们示例的最终版本](img/B18327_18_75.jpg)'
- en: 'Figure 18.75: The final version of our example'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.75：我们示例的最终版本
- en: Because zenquotes is an API, the developers have put a limit of 5 calls per
    30 seconds. So, that means if you try clicking the button more than 5 times in
    30 seconds, you will get an error message.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 因为zenquotes是一个API，开发者已经将每30秒的调用次数限制为5次。所以，这意味着如果你在30秒内尝试点击按钮超过5次，你会收到一个错误信息。
- en: You could expand on this example by getting a set of the data at the start and
    storing it locally. This could reduce some of the load times of the images and
    reduce the number of API calls needed.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for the examples that I will cover for the UI Toolkit. As I said
    previously, this is a big topic and a whole new way of thinking about developing
    UI. I wasn’t able to cover even half of what I would have liked to. If you enjoy
    working with the UI Toolkit, I recommend viewing the resources section for suggested
    further reading and tutorials.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re looking for more documentation, I recommend the following resources
    provided by Unity:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[https://unity.com/resources/user-interface-design-and-implementation-in-unity](https://unity.com/resources/user-interface-design-and-implementation-in-unity)'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/UIE-Transitioning-From-UGUI.xhtml](https://docs.unity3d.com/Manual/UIE-Transitioning-From-UGUI.xhtml)'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re interested in tutorials, here are some great resources. It’s important
    to note that most of the tutorials at this point are for using the UI Toolkit
    for Editor UI since the runtime support is still new:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/UIE-examples.xhtml](https://docs.unity3d.com/Manual/UIE-examples.xhtml)'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/2021.2/Documentation/Manual/UIE-HowTo-CreateRuntimeUI.xhtml](https://docs.unity3d.com/2021.2/Documentation/Manual/UIE-HowTo-CreateRuntimeUI.xhtml)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/2023.3/Documentation/Manual/UIE-simple-ui-toolkit-workflow.xhtml](https://docs.unity3d.com/2023.3/Documentation/Manual/UIE-simple-ui-toolkit-workflow.xhtml)'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.unity.com/tutorial/ui-toolkit-first-steps#61df0f23edbc2a2bf49579a2](https://learn.unity.com/tutorial/ui-toolkit-first-steps#61df0f23edbc2a2bf49579a2)'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/UIE-HowTo-CreateCustomInspector.xhtml](https://docs.unity3d.com/Manual/UIE-HowTo-CreateCustomInspector.xhtml)'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/UIE-HowTo-CreateEditorWindow.xhtml](https://docs.unity3d.com/Manual/UIE-HowTo-CreateEditorWindow.xhtml)'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://youtu.be/J2KNj3bw0Bw?feature=shared](https://youtu.be/J2KNj3bw0Bw?feature=shared)'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, Unity has provided some excellent pre-made projects that use the UI
    Toolkit. You can find these projects on the asset store here:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[https://assetstore.unity.com/packages/essentials/tutorial-projects/quizu-a-ui-toolkit-sample-268492](https://assetstore.unity.com/packages/essentials/tutorial-projects/quizu-a-ui-toolkit-sample-268492)'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://assetstore.unity.com/packages/essentials/tutorial-projects/ui-toolkit-sample-dragon-crashers-231178](https://assetstore.unity.com/packages/essentials/tutorial-projects/ui-toolkit-sample-dragon-crashers-231178)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI Toolkit is still in development, but Unity is actively working on it
    as a system to replace the current uGUI system (that the rest of this book has
    focused on up to this point). It uses the concepts of web development to develop
    UI and can provide a cleaner, more performant UI than uGUI. However, since it
    is still in development, it doesn’t do everything uGUI does … yet. While you might
    not be able to fully transition over to the UI Toolkit system for your UI needs,
    it is helpful to have an idea of how it works, since one day, it will be your
    only option.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: UI工具包仍在开发中，但Unity正在积极开发它，作为替换当前uGUI系统（本书到目前为止一直关注）的系统。它使用Web开发的理念来开发UI，可以提供比uGUI更干净、性能更好的UI。然而，由于它仍在开发中，它还不能做到uGUI所做的一切……目前还不能。虽然您可能无法完全过渡到UI工具包系统来满足您的UI需求，但了解它是如何工作的还是有帮助的，因为总有一天，它将成为您唯一的选项。
- en: To help introduce the concepts of the UI Toolkit to you, we discussed the general
    concepts of the system as well as how to use it to make UI in the Editor and Runtime
    UI.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您了解UI工具包的概念，我们讨论了系统的通用概念以及如何使用它来在编辑器和运行时UI中创建UI。
- en: 'In the next chapter, we will discuss yet another UI system used within Unity:
    IMGUI.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Unity中使用的另一个UI系统：IMGUI。
