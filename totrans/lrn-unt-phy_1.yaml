- en: Chapter 1. Introduction to Physics in Unity3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physics has been used for a long time in different sectors such as scientific,
    study, and software. The use of Physics in interactive development and software
    is not new, but its use has been the focus of special attention in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, Physics gives the impression that it's all about long, webbed
    equations and calculations. However, the contributions of Physics are tremendous
    and have made developer's life easy. The idea of gaming was possible only because
    of Physics. All of us remember our childhood games, which were facilitated by
    the use of Physics; for example, the Ping Pong game. Isn't it amazing how much
    Physics has touched our lives and how we cannot escape its influence? There are
    many games that possess primitive Physics, used to calculate the movement and
    trajectory of a bouncing ball. If you look into the structure of Physics used
    for one of the earliest games, Pong, you get a brief insight into how Physics
    was used in these games. Game behavior, motion trajectory, and paddle movement
    were all handled by primitive Physics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Physics is used in interactive development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic components of Physics for interactive development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical simulation in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In today's interactive world, the use of Physics is changing day by day. In
    recent years, the use of Physics in games, software, and interactive development
    has increased drastically. Now, we are able to make games and other applications
    using Physics in different ways. In the modern era, the importance of in-game
    Physics and interactive development has increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the way Physics was used in older interactive applications or
    games, you will find that they were all based on some specific scenarios. The
    Physics code was written according to the scenario of interactive development.
    For example, if the Physics code is written for a ball to handle its trajectory
    motion, it only handles the trajectory motion and nothing else; this means that
    every time a developer has to write a new code for a new effect. Also, with the
    passage of time, if an update is required, the developer has to modify or even
    rewrite the code. Based on such cases, development became very complicated and
    time-consuming. Conditions became worse when the number of scenarios increased.
    As mentioned earlier, the way Physics is used is changing day by day, and it is
    required in various sectors. Let''s take a look at the areas where Physics is
    widely used these days:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Physics in Unity3D](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Physics is useful in the following areas of interactive development:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time programming where we need knowledge of electronics, which is much
    related to Physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Physics engine for graphics software or games, where Physics is heavily used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating 3D programs for various software and game engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics-based simulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common component of Physics used in interactive development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rigidbody dynamics** is the most common component used in interactive development.
    For Physics-based simulation development, we use algorithms of Rigidbody dynamics.
    Rigidbody dynamics is based on the Newtonian principle of movement and mass.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the question that arises here is what is a Rigidbody? An idealized solid
    whose size and shape is fixed and remains unaltered when some external forces
    are applied and is used in Newtonian mechanics to model real objects is known
    as a Rigidbody. For example, a box, wall, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The use of accurate Physics in interactive development is not feasible as it
    has its own natural constraints. In interactive development, we cannot use accurate
    Physics due to the standard frame rate restrictions, but the physical accuracy
    of a simulation only needs to be believable.
  prefs: []
  type: TYPE_NORMAL
- en: Use of Physics in simulation and frame rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use Physics for interactive development, there are many things that
    need to be taken care of. Physics simulations are related to the frame rate. The
    frame rate can be described as the number of frames that are displayed per second.
    This is relevant to animation, in which many images are displayed quickly to give
    the impression of movement. The standard frame rate for most PCs and console games
    is 60 fps.
  prefs: []
  type: TYPE_NORMAL
- en: The interval of moving objects with their trajectories is called Physics simulation.
    Almost every Physics simulation equation involves time, and the time required
    for solving this is determined by interactive development.
  prefs: []
  type: TYPE_NORMAL
- en: Basic components of Physics for interactive development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few basic components that can be used for interactive development.
    Let''s take a look at them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic components of Physics for interactive development](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple factors that have to be considered when we are talking about
    the integration of Physics. How we track objects that participate in simulation
    is of paramount importance in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: To implement Physics in interactive development, we normally track all the objects
    that are simulating in a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: To implement Physics for each object, we need to know some important information
    such as the object's physical properties, that is, mass, current velocity, current
    position, orientation, the external forces acting on the object, and the future
    time of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is future time?**'
  prefs: []
  type: TYPE_NORMAL
- en: Future time = the current time + the time slice for the frame
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no collision detection if only one object is moving in a vacuum. However,
    most interactive developments involve more than one object and these objects move
    in an environment. Therefore, a situation arises where two objects are moving
    towards each other.
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if no action is taken? These objects will just pass through
    each other. In most interactive developments, however, we don't want the objects
    to pass through each other.
  prefs: []
  type: TYPE_NORMAL
- en: In order to handle those scenarios where collision occurs, the interactive development
    needs to know that two objects are colliding. One of Physics' most important tasks
    is to identify these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The collision detection code has to determine all such pairs of overlapping
    objects, collect some additional data such as how far they overlap and in which
    orientation, and provide this data to the interactive development for further
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the later chapters, we will see how we can handle collision detection in
    Unity3D.
  prefs: []
  type: TYPE_NORMAL
- en: Collision resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What will happen after the collision? Let's take a look at one such scenario
    where two or more objects overlap and see what can we do in this case. In many
    cases, some specific rules are added to the interactive development.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a shooting game, when a bullet hits the player's ship, the game
    might decide to show an explosion animation. Following this, before removing the
    player's ship, the game might start the level again and reduce the number of lives
    of the player. These effects of the collision are driven by the game itself and
    not by Physics because they are very specific to the game.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are certain cases where the game doesn't have to be involved.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered the basics of all Physics components. Every simulation suitable
    for interactive development will have these components. Other than the covered
    topics, there are many more features to be included, such as joints, cloth simulations,
    Physics-based animations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Physical simulation in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now look at the physical simulations already available in Physics and
    how Unity uses them. This section will also give you an overview of the built-in
    Physics components in Unity3D. Let''s take a look at the Physics simulation in
    Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Unity is a powerful tool. It is able to take care of many problems involved
    with interactive physical simulations. It embeds a state-of-the-art Physics engine
    called PhysX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's Rigidbody is mostly targeted at rigid objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Unity we can make Physics approximations based on an object's parameter
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Physics in Unity3D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned earlier, Unity is a powerful engine that has a number of built-in
    Physics components. It handles physical simulations. By adjusting a few parameter
    settings, we can create an object that behaves in a realistic way.
  prefs: []
  type: TYPE_NORMAL
- en: By controlling Physics from scripts, we can give an object the dynamics of a
    vehicle, machine, cloth, and so on. The built-in components are very useful in
    fast development. In most interactive developments, these simulations are required.
    By making Physics a built-in component, Unity3D has made developers' lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unity has two separate Physics engines: one for 3D Physics and one for 2D Physics.'
  prefs: []
  type: TYPE_NORMAL
- en: As such, there is a separate Rigidbody component for 3D Physics and an analogous
    Rigidbody2D component for 2D Physics.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore the built-in components in Unity3D.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Physics components in Unity3D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure depicts the basic built-in Physics components in Unity3D,
    which help us in interactive development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Built-in Physics components in Unity3D](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rigidbodies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already discussed that in simulation or interactive development, the
    most important component is a Rigidbody. It enables the physical behavior of an
    object. The object to which a Rigidbody is attached can be made to respond to
    gravity. If we want to create a ball and want it to respond to gravity, we need
    to add a Rigidbody component to the object and gravity will be enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: A Rigidbody component takes the movement of the object to which it is attached;
    therefore, we shouldn't try to move it using a script by changing the position
    and rotation. Instead, we can apply forces to push the object and let the Physics
    engine calculate the results.
  prefs: []
  type: TYPE_NORMAL
- en: Kinematic motion and Rigidbodies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it is desirable for a Rigidbody object's motion to not be controlled
    by the Physics engine but by the script code instead. This type of motion produced
    from a script is known as kinematic motion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is Kinematic** is one of the properties of a Rigidbody that will remove it
    from the control of the Physics engine and allow it to be moved using a script.
    We can change the value of Is Kinematic from a script to switch this property
    on and off for an object by using both the script and the inspector.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is Kinematic is useful, but we should keep in mind that enabling it will affect
    performance. If enabled, the object will not be driven by the Physics engine and
    can only be manipulated by its transform, which is more performance consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Colliders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's one of the most important built-in components of Unity3D. A collider component
    is used to define the shape for the physical collision. We use different colliders
    according to the shape of the objects. A collider, which is invisible, need not
    be matched exactly to the shape of the object's mesh.
  prefs: []
  type: TYPE_NORMAL
- en: In the later chapters, we will see how to use different colliders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 3D, the following are the basic colliders:'
  prefs: []
  type: TYPE_NORMAL
- en: Box Collider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphere Collider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capsule Collider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh Collider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Colliders](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are differences between 3D colliders and 2D colliders. In 2D, the following
    are the basic colliders:'
  prefs: []
  type: TYPE_NORMAL
- en: Box Collider 2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circle Collider 2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polygon Collider 2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Colliders](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Apart from the aforementioned core colliders, there are a few important terms
    about the colliders that you need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Static colliders
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Colliders can be added to an object without a Rigidbody component in order to
    create floors, walls, and so on. These are referred to as static colliders. Repositioning
    static colliders by changing the transform position will impact the performance
    of the Physics engine heavily.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve the performance, we should not reposition static colliders by changing
    the transformation position.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic colliders
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Colliders attached to a Rigidbody object are known as dynamic colliders. Static
    colliders do not respond to collisions with dynamic colliders with any movement.
    In the later chapters, we will learn about the aforementioned colliders and how
    to implement these colliders in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Physic Materials
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Different materials are used for different objects. As the colliders interact,
    their surfaces need to simulate the properties of the material that they are supposed
    to represent. We can configure the friction and bounce using Physic Materials.
  prefs: []
  type: TYPE_NORMAL
- en: Again, Physic Materials for 2D and 3D are different; they are called Physic
    Materials 3D and Physic Materials 2D.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In scripting, we can detect when the collisions are going to occur and then
    we can initiate taking actions using the `OnCollisionEnter` function. We can configure
    a collider, which does not behave as a solid object, as a trigger using the `Is
    Trigger` property of Unity3D, and we will simply allow other colliders to pass
    through. When a collision occurs, a trigger will call the `OnTriggerEnter` function
    on the trigger object's scripts. Using these functions, we can handle a number
    of scenarios where an action after the collision is required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following points will give you sources where you can find more details
    on this particular topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collider.OnCollisionEnter(Collision)` at [http://docs.unity3d.com/ScriptReference/Collider.OnCollisionEnter.html](http://docs.unity3d.com/ScriptReference/Collider.OnCollisionEnter.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collider.OnCollisionStay(Collision)` at [http://docs.unity3d.com/ScriptReference/Collider.OnCollisionStay.html](http://docs.unity3d.com/ScriptReference/Collider.OnCollisionStay.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collider.OnCollisionExit(Collision)` at [http://docs.unity3d.com/ScriptReference/Collider.OnCollisionExit.html](http://docs.unity3d.com/ScriptReference/Collider.OnCollisionExit.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collider.OnTriggerEnter(Collider)` at [http://docs.unity3d.com/ScriptReference/Collider.OnTriggerEnter.html](http://docs.unity3d.com/ScriptReference/Collider.OnTriggerEnter.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collider.OnTriggerStay(Collider)` at [http://docs.unity3d.com/ScriptReference/Collider.OnTriggerStay.html](http://docs.unity3d.com/ScriptReference/Collider.OnTriggerStay.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collider.OnTriggerExit(Collider)` at [http://docs.unity3d.com/ScriptReference/Collider.OnTriggerExit.html](http://docs.unity3d.com/ScriptReference/Collider.OnTriggerExit.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, one Rigidbody object is attached to another using joints. Unity provides
    different joints to help us in different scenarios. We can attach one Rigidbody
    object to another or to a fixed point in space using a joint component. If we
    want a joint to allow at least some freedom of motion and so on, then Unity provides
    different joint components that enforce different restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts the types of joints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joints](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Joints also have other options that enable specific effects; for example, we
    can set a joint to break when the force applied to it exceeds a decided limit.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about joints in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Character controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In game development, often a character is required, and for this, a controller
    is always required. A character in a first- or third-person game will often need
    some collision-based Physics so that character doesn't fall on the floor or walk
    over the walls.
  prefs: []
  type: TYPE_NORMAL
- en: Unity3D provides a component to create this behavior, which is called **CharacterController**.
    This component uses a Capsule Collider. The controller has functions to set the
    object's speed and direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more details at [http://docs.unity3d.com/ScriptReference/CharacterController.html](http://docs.unity3d.com/ScriptReference/CharacterController.html).
  prefs: []
  type: TYPE_NORMAL
- en: Scripting based on collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see how we can handle collision and an after-collision effects with scripting.
    Scripts are attached to the objects in order to call some functions on collision.
    We can write any code in these functions to respond to the collision event. For
    example, we might play a sound effect when a ball hits an obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnCollisionEnter`: This function indicates that the collision is detected
    in the first update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCollisionStay`: This function indicates that during the updates, the contact
    is maintained'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCollisionExit`: This function indicates that the contact has been broken'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, for Trigger Colliders, these functions are called `OnTriggerEnter`,
    `OnTriggerStay`, and `OnTriggerExit`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For 2D Physics, there are equivalent functions with 2D appended to the name;
    for example, `OnCollisionEnter2D`.
  prefs: []
  type: TYPE_NORMAL
- en: With normal nontrigger collisions, there is an additional requirement that at
    least one of the objects involved must have a nonkinematic Rigidbody. To create
    a nonkinematic Rigidbody, we must set Is Kinematic to `off`.
  prefs: []
  type: TYPE_NORMAL
- en: Frictionless Physic Materials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, during the development, we require frictionless Physic Materials.
    Let''s try to create a frictionless material. In Unity3D, to create a completely
    frictionless material, we need to create a new Physic Materials asset in the **Project**
    view and set its properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Frictionless Physic Materials](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous image, we can see various parameters, using which we can fulfil
    our frictionless game requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a quick introduction to Physics in Unity3D. In this chapter,
    we learned the use of Physics in an interactive world, built-in components of
    Unity3D, and frictionless material. In the next chapter, we will learn about colliders
    and their types, with examples. The chapter will also teach us how we can use
    different colliders for interaction.
  prefs: []
  type: TYPE_NORMAL
