<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Textures, Maps, and Materials</h1>
                
            
            
                
<p>In this chapter, we will cover:</p>
<ul>
<li>Creating a basic material with Standard Shader (Specular setup)</li>
<li>Adapting a basic material from Specular setup to Metallic</li>
<li>Applying Normal maps to a Material</li>
<li>Adding Transparency and Emission maps to a material</li>
<li>Highlighting materials at mouse-over</li>
<li>Adding Detail maps to a material</li>
<li>Fading the transparency of a material</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>There is a close relationship between <strong>Textures</strong>, <strong>Materials</strong>, and <strong>Shaders</strong>, and their relationships are important:</p>
<ul>
<li>Textures are two-dimensional images. The surface of 2D and 3D objects in Unity games are defined by meshes. The <strong>Texture</strong> images are mapped onto meshes by <strong>Materials</strong> – each point (vertex) on a mesh has to be mapped to some value in the <strong>Texture</strong>. A <strong>Texture</strong> may indicate colors, but may indicate bumps/wrinkles or transparency – all of which can contribute to determining what is finally rendered for the user to see.</li>
<li><strong>Materials</strong> specify which <strong>Shader</strong> should be used to render the images onto the meshes, plus values for the <strong>Shader's</strong> parameters (such as which textures/parts of a texture map, colors, other values). Learn more at the Unity documentation page about Materials: <a href="https://docs.unity3d.com/Manual/Materials.html">https://docs.unity3d.com/Manual/Materials.html</a>.</li>
<li><strong>Shaders</strong> define the method to render an object. <strong>Shaders</strong> can use multiple textures for more sophisticated results, and specify which parameters may be customized in the Material Inspector. At the end of the day, <strong>Shaders</strong> are code and mathematics, but Unity provides a set of <strong>Shaders</strong> for us. We can also use the new <strong>Shader Graph</strong> package, which allows the creation of sophisticated <strong>Shaders</strong> using a visual, drag-and-drop graphing interface. In addition, custom shaders can be written in the <strong>ShaderLab</strong> language.</li>
</ul>
<p>Unity offers physically-based Shaders. <strong>Physically-Based Rendering</strong> (<strong>PBR</strong>) is a technique that simulates the appearance of <strong>Materials</strong> based on how the light reacts with that <strong>Material</strong> (more specifically, the matter from which that material is made) in the real world. Such a technique allows for more realistic and consistent materials. So, your creations in Unity should look better than ever. Creating <strong>Materials</strong> in Unity has also become more efficient now. Once you have chosen between the available workflows (<strong>Metallic</strong> or <strong>Specular</strong> setup; we'll get back to that later), there is no longer a need to browse the drop-down menus in search of specific features, as Unity optimizes the shader for the created <strong>Material</strong>, removing unnecessary code for unused properties once the material has been set up and the texture maps have been assigned.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and saving texture maps</h1>
                
            
            
                
<p>The visual aspects of a material can be modified through the use of textures. In order to create and edit image files, you will need an image editor, such as Adobe Photoshop (the industry standard, and has its native format supported by Unity) or GIMP. In order to follow the recipes in this chapter, it's strongly recommended that you have access to a few pieces of software such as these.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When saving <strong>Texture Maps</strong>, especially the ones that have an <strong>Alpha Channel</strong>, you might want to choose an adequate file format. PSD, Photoshop's native format, is practical for preserving the original artwork in many layers. The PNG format is also a great option, but please note that Photoshop doesn't handle PNG's <strong>Alpha Channel</strong> independently of the transparency, possibly compromising the material's appearance. Also, PNG files don't support layers. For this chapter, we will often use the TIF format for three main reasons:</p>
<ul>
<li>It's open to those not using Photoshop</li>
<li>It uses layers</li>
<li>It preserves the <strong>Alpha Channel</strong> information</li>
</ul>
<p>The file size is significantly greater than in PSDs and PNGs, so feel free to save your work as PSDs (if you have Photoshop) or PNGs (if you don't need layers and, if using Photoshop, <strong>Alpha Channels</strong>).</p>
<p>Finally, a word of advice: although it's possible to manually create <strong>Texture Maps</strong> for our materials by using the traditional image-editing software, new tools such as Allegorthmic's Substance Painter and Bitmap2Material make this work much more efficient, complete, and intuitive, complementing the traditional <strong>Texture</strong>-making process or replacing it altogether. These tools provide Texture work support in a similar way to what zBrush and Mudbox did for 3D modeling. For design professionals, we strongly recommend at least trying such tools. Note, however, that products from Allegorithmic won't make use of Unity's Standard Shader, relying on the substance files (which are natively supported by Unity).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>To understand the <strong>Standard Shaders</strong>, it's a good idea to know the workflows, their properties, and how they affect the material's appearance. There are, however, many possible ways to work with <strong>Materials</strong> – texture map requirements, for instance, might change from engine to engine, or from one tool to another. Presently, Unity supports two different workflows: one based on <strong>Specular</strong>, and another based on Metallic values. Although both workflows share similar properties (such as <strong>Normal</strong>, <strong>Height</strong>, <strong>Occlusion</strong>, and <strong>Emission</strong>), they differ in the way the diffuse color and reflectance properties are set up.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard Shader (Specular workflow)</h1>
                
            
            
                
<p>Unity's Standard <strong>Shader</strong> (<strong>Specular</strong> setup) uses <strong>Albedo</strong> and <strong>Specular/Smoothness</strong> maps, combining them to create some of the material's aspect – mainly its color and reflectance qualities. The following shows the difference between the <strong>Albedo</strong> and <strong>Smoothness</strong> maps:</p>
<ul>
<li><strong>Albedo</strong>: This is the material's diffused color. Plainly and simply, this is how you usually describe the appearance of the <strong>Material</strong> (the British flag is red, white and blue; Ferrari's logo is a black horse in a yellow setting; some sunglasses' lenses are semi-transparent gradients). This description, however, can be deceptive. Purely metallic objects (such as aluminum, chrome, and gold) should have black as their diffuse color. Their colors, as we perceive them, have originated from their specular channel. Non-metallic objects (plastic, wood, and even painted or rusted metal), on the other hand, have very distinct diffuse colors. <strong>Texture Maps</strong> for the <strong>Albedo</strong> property feature RGB channels for colors and (optionally) an Alpha Channel for transparency.</li>
<li><strong>Specular/Smoothness</strong>: This refers to the shininess of the material. <strong>Texture</strong> maps make use of RGB channels for specular color (which inform hue and intensity), and <strong>Alpha Channel</strong> for smoothness/gloss (dark values for less shiny surfaces and blurred reflections; light/white values for shiny, mirror-like appearance). It is important to note that non-metallic objects feature neutral, very dark specular colors (with plastic, for instance, you should work with a grey value around 59). Metallic objects, on the other hand, feature very light values, and are also a bit yellowish in hue.</li>
</ul>
<p>To illustrate such concepts, we have created a battery object, featuring brushed metal caps and a plastic body. Observe how each map contributes to the final result:</p>
<div><img src="img/0be3aaf1-343d-4ed6-b6a6-ec64080ec85e.png" style="width:33.08em;height:23.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard Shader (Metallic workflow)</h1>
                
            
            
                
<p>Unity's default <strong>Standard Shader</strong> combines <strong>Albedo</strong> and <strong>Metallic</strong>/<strong>Glossiness</strong> maps to create the color and reflectance qualities of the material. The following are the differences:</p>
<ul>
<li><strong>Albedo</strong>: As in the <strong>Specular</strong> workflow, this is the <strong>Material's</strong> diffuse color; how you would describe the <strong>Material</strong>. However, <strong>Albedo</strong> maps for the Metallic workflow should be configured in a slightly different way than ones for <strong>Specular</strong> workflow. This time around, the perceived diffuse color of metallic materials (grey for iron, yellow/orange for golden, and so on) have to be present in the Albedo map. Again, Albedo maps feature RGB channels for the colors and (optionally) an Alpha Channel for transparency.</li>
<li><strong>Metallic/Smoothness</strong>: This refers to how metallic the <strong>Material</strong> looks. <strong>Metallic Texture Maps</strong> make use of the Red channel for the <strong>Metallic</strong> value (black for non-metallic and white for metallic <strong>Materials</strong> that are not painted or rusted) and the <strong>Alpha Channel</strong> for smoothness (in a similar way to the <strong>Specular</strong> workflow). Please note that <strong>Metallic</strong> maps do not include any information on hue, and in these cases the yellow-ish nature of the metallic gloss should be applied to the <strong>Albedo</strong> map.</li>
</ul>
<p>To reproduce the battery that illustrated the <strong>Specular</strong> workflow by using the Metallic workflow, maps would have to be recreated as follows:</p>
<div><img src="img/10084c58-6e08-4a11-85dd-4886cdcedbc6.png" style="width:37.75em;height:26.75em;"/></div>
<p>You might have noticed that we've used white to convey a metallic object. Technically, since only the Red channel is relevant, we could have used red (R: 255, G: 0, B: 0), yellow (R: 255, G: 255, B: 0), or, for that matter, any color that has a red value of 255.</p>
<p>The Unity documentation pages provide two very useful charts giving examples of common properties for the <strong>Standard Shader</strong> <strong>Metallic</strong> and <strong>Specular</strong> workflows (<a href="https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html">https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html</a>):</p>
<div><img src="img/5e14f4b7-f16c-4aa3-82a1-cb0b6bfefee4.png" style="width:63.92em;height:33.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Other material properties</h1>
                
            
            
                
<p>It's also worth mentioning that Unity's <strong>Standard Shaders</strong> support other maps such as:</p>
<ul>
<li><strong>Normal Maps</strong>: The normal map adds detailed bumpiness into the <strong>Material</strong>, simulating a more complex geometry. For instance, the internal ring on the positive (top) node of the battery that illustrated shader workflows is not modeled in the 3D object's geometry, but rather created through a simple <strong>Normal Map</strong>.</li>
<li><strong>Occlusion Maps</strong>: A greyscale map is used to simulate the dark sections of an object under ambient light. Usually, it is used to emphasize joints, creases, and other details of geometry.</li>
<li><strong>Height Maps</strong>: These add a displacement effect, giving the impression of depth without the need for complex geometry.</li>
<li><strong>Emission Maps</strong>: These add color emitted by the <strong>Material</strong>, as if self-illuminated, such as fluorescent surfaces or LCDs. <strong>Texture</strong> maps for Emission maps feature RGB channels for color.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Resources</h1>
                
            
            
                
<p><strong>Physically-Based Rendering</strong> (<strong>PBR</strong>) is a complex (and current) topic, so it's a good idea to study it a bit by familiarizing yourself with the tools and concepts behind it. To help you with this task, we have included a non-exhaustive list of resources that you should take a look at.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity samples and documentation</h1>
                
            
            
                
<p>Before you start, it might be a good idea to read Unity's documentation on <strong>Textures</strong>, <strong>Materials</strong>, and <strong>Shaders</strong>. They can be found online:</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/Textures.html" target="_blank">https://docs.unity3d.com/Manual/Textures.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/Materials.html" target="_blank">https://docs.unity3d.com/Manual/Materials.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/shader-StandardShader.html" target="_blank">https://docs.unity3d.com/Manual/shader-StandardShader.html</a></li>
</ul>
<p>This chapter covers a number of techniques used to create, often manually and sometimes automatically, texture maps that are capable of giving distinctive features to materials. Hopefully, you will become confident working with Unity's <strong>Physically-Based Shading</strong>, which is capable of understanding differences between available workflows, is aware of the role of each material property, and is ready to make better-looking materials for your games. We have also explored ways of changing the properties of materials during runtime by accessing an object's <strong>Material</strong> via script.</p>
<p>Unity has put together a great resource for those looking for some pointers regarding how to set up maps for a variety of materials:</p>
<ul>
<li>The <strong>Shader Calibration</strong> <strong>Scene</strong>, which can be downloaded (for free) from the Unity Asset Store. It is a fantastic collection, featuring sample materials (both <strong>Metallic</strong> and <strong>Specular</strong> setup) for wood, metal, rubber, plastic, glass, skin, mud, and much more: <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/shader-calibration-scene-25422">https://assetstore.unity.com/packages/essentials/tutorial-projects/shader-calibration-scene-25422</a>.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">References</h1>
                
            
            
                
<p>Here's a list of interesting, detailed material on <strong>Physically-Based Rendering</strong> (within and outside Unity):</p>
<ul>
<li>For a deep understanding of <strong>Physically-Based</strong> <strong>Rendering</strong>, we recommend you to take a look at The Comprehensive PBR Guide, written by Wes McDermott from Allegorithmic. Allegorithmic's guide takes an in-depth look at the practical and theoretical aspects of PBR, including a great analysis of possible workflows. The guide is freely available in two volumes at <a href="http://www.allegorithmic.com/pbr-guide" target="_blank">http://www.allegorithmic.com/pbr-guide</a>.</li>
<li>Mastering Physically Based Shading in Unity 5 by Renaldas Zioma (Unity), Erland Körner (Unity), and Wes McDermott (Allegorithmic), is available at <a href="http://www.slideshare.net/RenaldasZioma/unite2014-mastering-physically-based-shading-in-unity-5" target="_blank">http://www.slideshare.net/RenaldasZioma/unite2014-mastering-physically-based-shading-in-unity-5</a>. This is a detailed presentation about using PBS in Unity. Originally presented at the Unite 2014 conference, it contains some out-of-date information, but it is still worth taking a look at.</li>
<li>Physically Based Shading in Unity 5 by Aras Pranckevičius, from Unity, is available at <a href="http://aras-p.info/texts/talks.html" target="_blank">http://aras-p.info/texts/talks.html</a>. Slides and notes from a presentation on the subject are given at the GDC.</li>
<li>Tutorial: Physically Based Rendering, And You Can Too! by Joe "EarthQuake" Wilson is available at <a href="http://www.marmoset.co/toolbag/learn/pbr-practice" target="_blank">http://www.marmoset.co/toolbag/learn/pbr-practice</a>. It is a great overview from the makers of Marmoset Toolbag and Skyshop.</li>
<li>Polycount PBR Wiki, available at http://wiki.polycount.com/wiki/PBR, is a list of resources compiled by the Polycount community.</li>
<li>Lots of general 3D graphics articles and tutorials from Jeremy Brin of Pixar: <a href="http://3drender.com/">http://3drender.com/</a>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Tools</h1>
                
            
            
                
<p>This is a new generation of texturing software for you to check out, in case you haven't yet:</p>
<ul>
<li>Substance Painter is a 3D painting application from Allegorithmic. It is available at <a href="http://www.allegorithmic.com/products/substance-painter" target="_blank">http://www.allegorithmic.com/products/substance-painter</a>. Again, it's worth mentioning that Allegorithmic products won't make use of Unity's Standard Shader, relying instead on substance files that are natively supported by Unity.</li>
<li>Bitmap2Material creates full-featured materials (including normal maps and specular maps) from a single bitmap image. Also, it is from Allegorithmic, and it is available at <a href="http://www.allegorithmic.com/products/bitmap2material" target="_blank">http://www.allegorithmic.com/products/bitmap2material</a>.<a href="http://www.allegorithmic.com/products/bitmap2material" target="_blank"/></li>
<li>Quixel DDO is a plugin for creating PBR-ready textures in Adobe Photoshop. From Quixel, it is available at <a href="http://www.quixel.se/ddo" target="_blank">http://www.quixel.se/ddo</a>.</li>
<li>Quixel NDO is a plugin for creating Normal maps in Adobe Photoshop. From Quixel, it is available at <a href="http://www.quixel.se/ndo" target="_blank">http://www.quixel.se/ndo</a>.</li>
<li>Mari is a 3D painting tool from The Foundry. It is available at <a href="http://www.thefoundry.co.uk/products/mari/">http://www.thefoundry.co.uk/products/mari/</a>.</li>
<li>CrazyBump is a standalone tool for Windows and Mac, which is available at <a href="http://www.crazybump.com" target="_blank">http://www.crazybump.com</a>.<a href="http://www.crazybump.com" target="_blank"/></li>
<li>The GIMP normalmap plugin, available for Windows only, is available at <a href="http://code.google.com/p/gimp-normalmap/" target="_blank">http://code.google.com/p/gimp-normalmap/</a>.</li>
<li>NVIDIA Texture Tools for Adobe Photoshop, available for Windows only, is available at <a href="http://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop" target="_blank">http://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop</a>.</li>
<li>The <strong>NormalMap Online</strong> free online tool, developed by Christian Petry, can be used to generate <strong>Normal</strong> maps, regardless of your computers <strong>Operating System</strong>. This tool can be accessed at <a href="http://cpetry.github.io/NormalMap-Online/" target="_blank">http://cpetry.github.io/NormalMap-Online/</a>.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional reading</h1>
                
            
            
                
<p>Two new Unity features relating to <strong>Materials</strong> and <strong>Textures</strong> are the <strong>Shader Graph</strong> tool, and the <strong>Video Player</strong> component. Learn more about these in their own chapter: <em>Shader</em> Graphs and <em>Video Players</em><em>.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a basic material with Standard Shader (Specular setup)</h1>
                
            
            
                
<p>In this recipe, we will learn how to create a basic <strong>Material</strong> using the new <strong>Standard Shader</strong> (<strong>Specular Setup</strong>), an Albedo map, and a <strong>Specular</strong>/<strong>Smoothness</strong> map. The <strong>Material</strong> will feature both metallic and non-metallic parts, with various smoothness levels.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Two files have been prepared to support this recipe: a 3D model (in FBX format) of a battery, and an UVW template texture (in PNG format) to guide us when creating the diffuse texture map. 3D models and UVW templates can be made with 3D modeling software, such as 3DS MAX, Maya, or Blender. All necessary files are available in the <kbd>05_01</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a basic material, follow these steps:</p>
<ol>
<li>Create a new Unity 3D project and import the <strong>battery.fbx</strong> and <strong>uvw_template.png</strong> files to your project.</li>
<li>Place the battery model in the scene by dragging it from the <kbd>Assets</kbd> folder, in the <strong>Project</strong> panel, to the <strong>Hierarchy</strong> panel. Select it on the <strong>Hierarchy</strong> panel and make sure, via the Transform component on the <strong>Inspector</strong> panel, that it is positioned at X: 0, Y: 0, Z: 0.</li>
<li>Let's create a <strong>Specular</strong>/<strong>Smoothness</strong> map for our object. Open the image file called <strong>uvw_template.png</strong> in your image editor (we'll use Adobe Photoshop to illustrate the next steps). Note that the image file has only a single layer, mostly transparent, containing the UVW mapping templates that we will use as guidelines for our specular map.</li>
</ol>
<ol start="4">
<li>Create a new layer and place it beneath the one with the guidelines. Fill the new layer with dark gray (R: 56, G: 56, B: 56). The guidelines will be visible at the top of the solid black fill:</li>
</ol>
<div><img src="img/94875c40-4411-4dd3-a97d-9bd3502eebb9.png"/></div>
<ol start="5">
<li>Create a new layer and select the upper section of the image (the one with the circles). Fill that area with a slightly-hued light gray (R: 196, G: 199, B: 199):</li>
</ol>
<p>The RGB values for our specular map are not arbitrary: <strong>Physically-Based Shading</strong> takes out most of the guesswork from the mapping process, replacing it with the research for references. In our case, we have used colors based on the reflectance values of iron (the slightly-hued light gray) and plastic (the dark gray). Check out the chapter's conclusion for a list of references.</p>
<ol start="6">
<li>Use the text elements in white to add a brand, size, and positive/negative indicators to the battery body. Then, hide the guidelines layer:</li>
</ol>
<div><img src="img/b693e9a1-92e7-4749-8155-5a5cdb75f150.png"/></div>
<p class="mce-root"/>
<ol start="7">
<li>Select all your layers and organize them into a group (in Photoshop, this can be done by clicking on the drop-down menu in the <strong>Layers</strong> window and navigating to Window | New Group from Layers...). Name the new group Specular:</li>
</ol>
<div><img src="img/12a9d148-88a6-4b71-bbff-0789d609a3b8.png" style="width:37.67em;height:29.25em;"/></div>
<ol start="8">
<li>Duplicate the Specular group (in the Layers window, right-click on the group's name and select Duplicate Group...). Name the duplicated group Smoothness.</li>
</ol>
<ol start="9">
<li>Hide the Smoothness group. Expand the Specular group and hide all text layers:</li>
</ol>
<div><img src="img/9b6c0e71-e9f3-497f-a268-ceb6e80870d3.png" style="width:56.17em;height:36.42em;"/></div>
<ol start="10">
<li>Unhide the Smoothness group, and hide the Specular group. Select the dark gray layer. Make an area selection around the upper region of the battery body, and fill it with light gray (R: 220, G: 220, B: 220). Rescale and rearrange the Text layers if needed:</li>
</ol>
<div><img src="img/5d02084e-2625-446a-bba2-87643d57670d.png" style="width:56.50em;height:38.92em;"/></div>
<ol start="11">
<li>Duplicate the layer that contains the gray fill for the upper section of the image (the one that went over the circles).</li>
<li>To add a brushed quality to this material, add a Noise filter to the duplicated layer (in Photoshop, this can be done by navigating to Filter | Noise | Add Noise...). Use 50% as the Amount and set Monochromatic to true. Then, apply a Motion Blur filter (Filter | Blur | Motion Blur...) using 30 pixels as the Distance.</li>
</ol>
<ol start="13">
<li>Duplicate the Smoothness group. Select the duplicated group and merge it into a single layer (on the Layers window, right-click on the group's name and select Merge Group).</li>
<li>Select the merged layer, use the <em>Ctrl</em> + a key combination to select the entire image, and copy it using the <em>Ctrl + c </em>keys:</li>
</ol>
<div><img src="img/aed12078-d495-485c-8852-92a9b3e904a2.png"/></div>
<ol start="15">
<li>Hide the merged layer and the Smoothness group. Unhide the Specular group.</li>
<li>In your image editor, access the image channels window (in Photoshop, this can be done by navigating to Window | Channels). Create a New Channel. This will be our Alpha Channel.</li>
</ol>
<ol start="17">
<li>Paste the image that you previously copied (from the merged layer) in to the <strong>Alpha</strong> <strong>Channel</strong>. Set all channels as visible:</li>
</ol>
<div><img src="img/f03bb096-e393-4582-916c-7b9862c0e471.png"/></div>
<ol start="18">
<li>Save your image in the project's <kbd>Assets</kbd> folder as Battery_specular, either in Photoshop format (PSD) or TIF format.</li>
<li>Let's work on the Albedo map. Save a copy of <strong>Battery_specular</strong> as <strong>Battery_albedo</strong>. From the <strong>Channels</strong> window, delete the <strong>Alpha Channel</strong>.</li>
</ol>
<ol start="20">
<li>From the <strong>Layers</strong> window, hide the <strong>Smoothness</strong> copy merged layer, and unhide the <strong>Smoothness</strong> group. Expand the <strong>Smoothness</strong> group, and hide the layer where the Noise filter was applied:</li>
</ol>
<div><img src="img/aab26a45-d8e7-4668-b161-3ab75f3d3aea.png"/></div>
<p class="mce-root"/>
<ol start="21">
<li>Change the color of the upper rectangle to black. Change the light gray area to dark red (R: 204, G: 0, B: 0), and the dark gray to red (R: 255, G: 0, B: 0). Rename the group Albedo and save the file:</li>
</ol>
<div><img src="img/7fb820d5-5ca1-41f7-bd85-456f769ed60c.png"/></div>
<ol start="22">
<li>Go back to Unity and make sure that both files were imported. From the <strong>Project</strong> panel, create a new <strong>Material</strong> (menu: Create | Material). Name it Battery_MAT.</li>
<li>Select Battery_MAT. From the Inspector panel, change the Shader to Standard (Specular setup), make sure that the rendering mode is set to Opaque, and that the Smoothness slider is at the maximum value of 1:</li>
</ol>
<div><img src="img/6d15cd6f-0f24-4943-8181-21e63b2b3e1a.png"/></div>
<ol start="24">
<li>Set Battery_specular as the Specular map, and Battery_albedo as the Albedo map for Battery_MAT.</li>
<li>Drag the Battery_MAT Material from the <strong>Project</strong> project and drop it into the <strong>battery</strong> object in the Hierarchy:</li>
</ol>
<div><img src="img/fb634eaa-f24c-4196-8816-beb37fd43291.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Ultimately, the visual aspect of the battery is a combination of three properties of its material: <strong>Specular</strong>, <strong>Smoothness,</strong> and <strong>Albedo</strong>.</p>
<p>To compose the dark red part of the plastic body, for instance, we have mixed the following:</p>
<ul>
<li><strong>The Specular map (RGB)</strong>: Very dark grey specularity (for non-metallic appearance)</li>
<li><strong>The Smoothness (the Alpha Channel of the Specular map)</strong>: Light gray (for a glossy aspect)</li>
<li><strong>The Albedo map</strong>: Dark red (for a dark-red color)</li>
</ul>
<p>The light red portion, on the other hand, combines the following:</p>
<ul>
<li><strong>The Specular map (RGB)</strong>: That same dark grey specular</li>
<li><strong>The Smoothness (the Alpha Channel of the Specular map)</strong>: Dark gray (for a matte aspect)</li>
<li><strong>The Albedo map</strong>: Red (for a red color)</li>
</ul>
<p>Finally, the brushed metal used for the top and bottom covers combines the following:</p>
<ul>
<li><strong>The Specular map (RGB)</strong>: Light grey (for a metallic aspect)</li>
<li><strong>The Smoothness (the Alpha Channel of the Specular map)</strong>: A blurred grey noise pattern (for a brushed aspect)</li>
<li><strong>The Albedo map</strong>: Black (for a red color)</li>
</ul>
<p>Regarding how the image layers are structured, it's good practice to organize your layers into groups named after the property that they are related to. As texture maps get more diversified, it can be a good idea to keep a file that contains all the maps for quick reference and consistency.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The following are some things you should have in mind when working with Albedo maps.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting the texture type for an image file</h1>
                
            
            
                
<p>Since image files can be used for several purposes within Unity (<strong>Texture Maps</strong>, UI textures, cursors, and more), it's a good idea to check whether the right <strong>Texture Type</strong> is assigned to your file. This can be done by selecting the image file in the <strong>Project</strong> panel, and in the <strong>Inspector</strong> panel by using the drop-down menu to select the right <strong>Texture Type</strong> (in this case, Texture). Please note that other settings can be adjusted, such as Wrap Mode, Filter Mode, and Maximum Size. This last parameter is very useful if you want to keep your Texture maps small in size for your game, while still being able to edit them in full size.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining the map with color</h1>
                
            
            
                
<p>When editing a <strong>Material</strong>, the color picker to the right of the Albedo map slot, on the Inspector panel, can be used to select the <strong>Material's</strong> color, in case there is no <strong>Texture</strong> map. If a <strong>Texture</strong> map is being used, the selected color will be multiplied to the image, allowing variations on the <strong>Material's</strong> color hue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adapting a basic material from Specular setup to Metallic</h1>
                
            
            
                
<p>For a better understanding of the differences between <strong>Metallic</strong> and <strong>Specular</strong> workflows, we will modify the Albedo and Specular/Smoothness maps that are used on a Specular setup Material, in order to adapt them to the Metallic workflow. The material to be generated will feature both metallic and non-metallic parts, with various smoothness levels.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds on the previous one, so make a copy of that project and use the copy for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a basic Material using the Metallic workflow, follow these steps:</p>
<ol>
<li>From the <strong>Project</strong> panel, select the battery_prefab element. From the Inspector, access its <strong>Material</strong> (named Battery_MAT) and change its <strong>Shader</strong> to Standard (as opposed to its current shader – Standard (Specular setup):</li>
</ol>
<div><img src="img/58465255-8446-4383-ac80-f175f9d232ca.png"/></div>
<ol start="2">
<li>In the <strong>Project</strong> panel, find the Battery_specular map and rename it Battery_metallic. Open it in your image editor (we'll use Adobe Photoshop to illustrate the following steps).</li>
<li>Find the layer group named Specular and rename it Metallic. Fill the light gray layer (named Layer 2, in the Metallic group) with white (R: 255, G: 255, B: 255), and the dark gray layer (named Layer 1, in the Metallic group) with black (R: 0, G: 0, B: 0). Save the file:</li>
</ol>
<div><img src="img/cc125bc5-64bd-497a-b5f0-5b99a40f02f5.png" style="width:37.00em;height:23.83em;"/></div>
<ol start="4">
<li>Go back to Unity. From the <strong>Inspector</strong>, set the modified Battery_metallic map as the Metallic map of the Battery_MAT material. Also, set None as the Albedo map for that <strong>Material</strong>. This will give you an idea of how the <strong>Material</strong> is coming along:</li>
</ol>
<div><img src="img/5b4d871f-8cc3-4ec0-a18e-eb7f695a9b5c.png" style="width:27.33em;height:23.08em;"/></div>
<p class="mce-root"/>
<ol start="5">
<li>Let's adjust the <strong>Albedo</strong> texture map. From the <strong>Project</strong> panel, locate the <strong>Battery_albedo</strong> map and open it in your image editor. Use the <strong>Paint Bucket</strong> tool to fill the black area of <strong>Layer</strong> <strong>2</strong>, in the <strong>Albedo</strong> group, with light gray (R: 196, G: 199, B: 199). Save the file:</li>
</ol>
<div><img src="img/4c69eb38-ff86-46c1-b9b0-e93878eba73e.png" style="width:37.67em;height:20.67em;"/></div>
<ol start="6">
<li>Go back to Unity. From the <strong>Inspector</strong>, set the modified Battery_albedo map as the Albedo map of the Battery_MAT material.</li>
<li>Your <strong>Material</strong> is ready, combining visual properties based on the different maps that you have edited and assigned:</li>
</ol>
<div><img src="img/6319067e-0c98-4a98-a5b5-a2324ccdd440.png" style="width:23.58em;height:18.75em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The visual aspect of the battery is a combination of three properties of its material: Metallic, Smoothness, and Albedo.</p>
<p>To compose the dark-red part of the plastic body, for instance, we have mixed the following:</p>
<ul>
<li><strong>The Metallic map (RGB)</strong>: Black (for a non-metallic appearance)</li>
<li><strong>The Smoothness (the Alpha Channel of a Metallic map)</strong>: Light gray (for a glossy appearance)</li>
<li><strong>The Albedo map</strong>: Dark red (for a dark-red color)</li>
</ul>
<p>The light-red portion, on the other hand, combines the following:</p>
<ul>
<li><strong>The Metallic map (RGB)</strong>: Black</li>
<li><strong>The Smoothness (the Alpha Channel of the Metallic map)</strong>: Dark gray (for a matte appearance)</li>
<li><strong>The Albedo map</strong>: Red (for a red color)</li>
</ul>
<p>Finally, the brushed metal used for the top and bottom covers combines the following:</p>
<ul>
<li><strong>The Metallic map (RGB)</strong>: White (for a metallic aspect)</li>
<li><strong>The Smoothness (the Alpha Channel of the Metallic map)</strong>: Blurred grey noise pattern (for a brushed appearance);</li>
<li><strong>The Albedo map</strong>: Light grey (for an iron-like appearance)</li>
</ul>
<p>Remember to organize your layers into groups named after the property that they are related to.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying Normal maps to a Material</h1>
                
            
            
                
<p><strong>Normal Maps</strong> are generally used to simulate complex geometry that would be too expensive, in terms of computer processing, to be actually represented by the 3D polygons during the game's runtime. To oversimplify: <strong>Normal Maps</strong> fake complex geometry on low-definition 3D meshes. These maps can be generated either by projecting high-definition 3D meshes onto low-poly ones (a technique usually referred to as baking), or, as will be the case for this recipe, from another <strong>Texture</strong> map:</p>
<div><img src="img/aca76bb4-a20e-4950-8cb4-17c64dcb8cf6.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we will prepare two <strong>Texture</strong> maps: the <strong>Heightmap</strong> and the <strong>Normal</strong> map. The former will be made from simple shapes in an image editor. The latter will be automatically processed from the Heightmap. Although there are a number of tools that can be used to generate <strong>Normal</strong> maps, we will use the free, online NormalMap tool: <a href="http://cpetry.github.io/NormalMap-Online/">http://cpetry.github.io/NormalMap-Online/</a>.</p>
<p>To help you with this recipe, we've provided an FBX 3D model of the battery (battery.fbx), and its Albedo and Specular <strong>Textures</strong> (Battery_albedo.tif <strong>and</strong> Battery_specular.tif).</p>
<p>We've also included the UVW template texture (in PNG format) to guide you when creating the diffuse <strong>Texture</strong> map. All the files are in the <kbd>05_03</kbd> folder.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To apply a <strong>Normal Map</strong> to a <strong>Material</strong>, follow these steps:</p>
<ol>
<li>Import battery.fbx and its Albedo and Specular <strong>Textures</strong> to your project.</li>
<li>Add an instance of your 3D model in the Scene by dragging asset <strong>battery</strong> from the Project panel into the Scene (or Hierarchy) panel.</li>
<li>In the <strong>Project</strong> panel, select model asset battery. In the <strong>Inspector</strong>, click the <strong>Materials</strong> button and then click Extract Materials... You should now have a <strong>Material</strong> asset file in the <strong>Project</strong> panel named BatteryMaterial.</li>
<li>Select BatteryMaterial, and change the Shader to Standard (Specular setup). Drag the Battery_albedo <strong>Texture</strong> from the <strong>Project</strong> panel into the Albedo Texture slot in the Inspector. Drag the Battery_specular <strong>Texture</strong> from the <strong>Project</strong> panel into the Specular Texture slot.</li>
<li>After comparing the <strong>battery</strong> model in your project with some reference photos, inform yourself about the features that should be reproduced by the Normal map: (A) a bumpy ring at the top, and (B) some circular creases at the bottom:</li>
</ol>
<div><img src="img/6d9f90e0-76cf-40e4-836d-50fb396187df.png" style="width:17.58em;height:17.58em;"/></div>
<ol start="6">
<li>In an image editor, open uvw_template.png. Create a new layer, fill it with grey (RGB: 128), and position it below the pre-existing layer:</li>
</ol>
<div><img src="img/08eba0a7-00fd-4d8e-a032-c5aba36e676b.png" style="width:39.25em;height:24.33em;"/></div>
<ol start="7">
<li>On a separate layer, draw a white circle centered on the battery's top. Then, on another layer, draw a black circle, centered on the battery's bottom:</li>
</ol>
<div><img src="img/04ed61fd-9a39-44e7-93e9-74343d5d1cf4.png" style="width:22.08em;height:22.08em;"/></div>
<ol start="8">
<li>If you have used vector shapes to make the circles, rasterize their layers (in Adobe Photoshop, right-click on the layer's name and select the Rasterize Layer option from the context menu).</li>
<li>Blur the white circle (in Photoshop, this can be done by navigating to Filter | Blur | Gaussian Blur...). Use 4,0 pixels as the Radius.</li>
<li>Hide the UVW template layer and save the image as Battery_height.png.</li>
<li>If you want to convert the Heightmap directly from Unity, import it into your project. Select it from the Project panel and, from the Inspector panel, change its Texture Type to Normal map. Check the Create from Grayscale option, adjust Bumpiness and Filtering as you like, and click on Apply to save the changes:</li>
</ol>
<div><img src="img/21de53a3-6a0d-4693-a6fd-a764855171e5.png"/></div>
<p class="mce-root"/>
<ol start="12">
<li>To convert your Heightmap externally, go to <a href="http://cpetry.github.io/NormalMap-Online/" target="_blank">http://cpetry.github.io/NormalMap-Online/</a>. Drag the Battery_height.png file to the appropriate image slot. Feel free to play with the Strength, Level, and Blur/Sharp parameters:</li>
</ol>
<div><img src="img/696f8e0f-fb80-444c-a70b-19f56bccd227.png"/></div>
<ol start="13">
<li>Save the resulting <strong>Normal</strong> map as Battery_normal.jpg and add it to your Unity project.</li>
<li>In Unity, select Battery_normal from the <strong>Project</strong> panel. Then, in the Inspector, change its Texture Type to Normal, leaving the Create from Grayscale box unchecked. Click on Apply to save the changes.</li>
</ol>
<ol start="15">
<li>In the <strong>Project</strong> panel, select the BatteryMaterial asset. In the Inspector for the Material component, assign Battery_normal to the Normal Map slot. To adjust its intensity and direction, change its value to -0.35:</li>
</ol>
<div><img src="img/6852b8d9-a6d2-4190-8128-94d87727ccc0.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Normal Map was calculated from the grey values on the Heightmap, where the lighter tones were interpreted as recesses (applied to the top of the battery), and the darker tones as bulges (applied to the bottom). Since the desired output was actually the opposite, it was necessary to adjust the <strong>Normal Map</strong> to a negative value (-0.35). Another possible solution to the issue would have been to redraw the Heightmap and switch the colors for the white and black circles.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Transparency and Emission maps to a material</h1>
                
            
            
                
<p>The Emission property can be used to simulate a variety of self-illuminated objects, from the LEDs of mobile displays to futuristic Tron suits. Transparency, on the other hand, can make the diffuse color of a <strong>Material</strong> more or less visible. In this recipe, you will learn how to configure these properties to produce a toy's cardboard packaging that features a partially-transparent plastic case, cutouts (totally transparent), and glow-in-the-dark text:</p>
<div><img src="img/d7c3c7b3-f5d3-435c-8d23-351c6d377f57.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared two files in the <kbd>05_04</kbd> folder:</p>
<ul>
<li>package.fbx: A 3D object of a package (FBX format)</li>
<li>card_diffuse_start.png: The diffused texture map for the packaging (PNG format)</li>
</ul>
<p class="mce-root"/>
<p>Also provided are the two final, image-edited files you'll create in the project:</p>
<ul>
<li>card_diffuse.png: The Albedo texture map for the packaging with cutouts (PNG format)</li>
<li>card_emission.png: The Emission <strong>Texture</strong> map for the emission glow text (PNG format)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To add transparency and color emission maps to materials, follow these steps:</p>
<ol start="1">
<li>Import the provided files.</li>
<li>Duplicate the card_diffuse_start <strong>Texture</strong>, naming the copy card_diffuse.</li>
<li>From the <strong>Project</strong> panel, drag the FBX model package into the <strong>Hierarchy</strong> to create a GameObject in the <strong>Scene</strong>.</li>
<li>Create a new <strong>Material</strong> named m_card. Choose <strong>Project</strong> menu: Create | Material. Drag the card_diffuse <strong>Texture</strong> into the <strong>Albedo</strong> property of m_card.</li>
<li>In the <strong>Hierarchy</strong>, select PackageCard (child of package), and assign it your new m_card Material.</li>
<li>Create a new <strong>Material</strong> named m_plastic. Choose <strong>Project</strong> menu: Create | Material. Change its Rendering Mode to Transparent. Use the Diffuse color picker to change the color's RGB values to 56/56/56, and Alpha to 25. Change the Smoothness level to 0.9:</li>
</ol>
<div><img src="img/67bf2148-5a0f-4bf8-bb50-690b74dc99f5.png"/></div>
<ol start="7">
<li>In the <strong>Hierarchy</strong>, select PackagePlastic (child of package), and assign it your new m_plastic <strong>Material</strong>. The plastic portion of the 3D model should now appear partially transparent, as if made of plastic.</li>
</ol>
<ol start="8">
<li>To create the cutouts around the package and hang hole, we need to first prepare the diffuse image in an image editor (such as Photoshop). Open the card_diffuse <strong>Texture</strong> in your image editor.</li>
<li>We will add transparency to the image by deleting the white areas around the package (and the hang hole). Make a selection of those areas (in Photoshop, this can be done with the Magic Wand Tool).</li>
<li>Make sure you unlock the Background layer by clicking on the lock icon, to the left of the layer's name:</li>
</ol>
<div><img src="img/3193dd7a-0d15-4c7e-acef-b047d6fd03c6.png"/></div>
<ol start="11">
<li>Delete the previously-made selection (this can be done in Photoshop by pressing the Delete key). The background of the image should be transparent:</li>
</ol>
<div><img src="img/9f5d88fc-5756-4257-983b-557600be7199.png"/></div>
<ol start="12">
<li>Save your file in your image editor, and return to Unity.</li>
<li>Select the m_card <strong>Material</strong> in the Project panel. In the Inspector, change its Rendering Mode to Cutout, and adjust its Alpha Cutoff to 0.9:</li>
</ol>
<div><img src="img/94e20698-938e-4418-b2b3-f0e074a5dce2.png"/></div>
<p>Choosing Cutout means that your material can be either invisible or fully visible, not allowing for semi-transparency. The <strong>Alpha Cutoff</strong> is used to get rid of unwanted pixels around the transparent borders.</p>
<ol start="14">
<li>Let's work on the Emission map for the bright lettering. From the <strong>Assets</strong> folder, duplicate the card_diffuse.png <strong>Texture</strong>, rename it card_emission.png, and open it in your image editor.</li>
<li>Select all the characters from the Ms. Laser inscription and the green star (in Photoshop, this can be done with the <strong>Magic Wand</strong> tool, keeping the <em>Shift</em> key pressed while selecting multiple areas).</li>
<li>Copy and paste your selection into a new layer. Then, select it and apply a Noise filter to it (in Photoshop, this can be done by navigating to Filter | Noise | Add Noise...). Use 50% as the value.</li>
<li>Create a new layer and, using a tool such as the Paint Bucket, fill it with black (R: 0, G: 0, B: 0). Place this black layer beneath the one with the colored elements.</li>
</ol>
<ol start="18">
<li>Flatten your image (in Photoshop this can be done by navigating to Layer | Flatten Image):</li>
</ol>
<div><img src="img/cfdc4c40-4740-45f2-8c94-8336c3c562cd.png" style="width:34.42em;height:34.42em;"/></div>
<ol start="19">
<li>Save your file in your image editor, and return to Unity.</li>
<li>Select the m_card <strong>Material</strong> in the <strong>Project</strong> panel. Check the Emission property – three new properties should appear:
<ul>
<li><strong>A Texture slot</strong>: Set this to Texture card_emission (drag asset file from the Project panel)</li>
<li><strong>A Color slot</strong>: Set this to white (R: 255; G: 255; B: 255)</li>
<li><strong>A Global Illumination</strong> <strong>drop-down menu</strong>: Ensure this is set to Baked (so that its glow won't be added to the Lightmaps or influence the illumination in Real-Time):</li>
</ul>
</li>
</ol>
<div><img src="img/66b98314-62e5-4de4-bd8c-7123d7e32e5b.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unity is able to read four channels of a texture map: R (Red), G (Green), B (Blue), and A (Alpha). When set to Transparent or Cutout, the <strong>Alpha Channel</strong> of the diffuse texture map sets the transparency of the material according to each pixel's brightness level (the Cutout mode will not render semi-transparency – only fully visible or invisible pixels).</p>
<p>We didn't add an Alpha Channel – this is because Photoshop exports the PNG's Alpha map based on its transparency. To help you visualize the Alpha map, the provided folder also contains the package_diffuse.tif (TIF format) Texture file; an image file featuring an Alpha map that works in exactly the same way as the PNG file that we have generated:</p>
<div><img src="img/7fa82fa6-c7d3-4810-befb-b3e8c7eae32f.png"/></div>
<p>Regarding the Emission texture map, Unity assigns its RGB colors to the Material, combining them with the appropriate color selection slot, and allows adjustments to the intensity of that Emission.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Let's look at a little more information on Transparency and Emission.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using texture maps with the Transparent Mode</h1>
                
            
            
                
<p>Please note that you can use a bitmap texture for the Diffuse map in the Transparent render mode. In this case, RGB values will be interpreted as the Diffuse color, while the Alpha will be used to determine that pixel's transparency (in this case, semi-transparent materials are allowed).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding issues with the semi-transparent objects</h1>
                
            
            
                
<p>You might have noticed that the plastic case was made from two objects (PackagePlastic and innerPlastic). This was done to avoid z-sorting problems, where faces are rendered in front of other geometry when they should be behind it. Having multiple meshes instead of a single one allows these faces to be correctly sorted for rendering. <strong>Materials</strong> in the Cutout mode are not affected by this problem, though.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Emitting light over other objects</h1>
                
            
            
                
<p>The Emission value can be used to calculate the <strong>Material's</strong> light projection over other objects when using Lightmaps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Highlighting materials at mouse-over</h1>
                
            
            
                
<p>Changing the color of an object at runtime can be a very effective way of letting players know that they can interact with it. This is very useful in a number of game genres, such as puzzles and point-and-click adventures, and it can also be used to create 3D user interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To highlight a material at mouse-over, follow these steps:</p>
<ol>
<li>Create a new 3D project.</li>
<li>Create <strong>3D Cube</strong> in the scene (Hierarchy menu: <strong>Create | 3D Object | Cube</strong>).</li>
<li>In the Project panel, create a new <strong>Material</strong> aaset named m_cube. Set its Albedo Color to red.</li>
<li>In the <strong>Hierarchy</strong>, select the <strong>Cube</strong> GameObject, and assign it the m_cube <strong>Material</strong> (drag the asset from the Project panel).</li>
<li>Create a new C# script-class named MouseOverHighlighter, and add an instance object as a component to the Cube:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>         public class MouseOverHighlighter : MonoBehaviour {<br/>         public Color mouseOverColor = Color.yellow;<br/> <br/>         private Material originalMaterial;<br/>         private Material mouseOverMaterial;<br/>         private MeshRenderer meshRenderer;<br/> <br/>         void Start() {<br/>             meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br/>             originalMaterial = meshRenderer.material;<br/>             mouseOverMaterial = new <br/>             Material(meshRenderer.sharedMaterial);<br/>             mouseOverMaterial.color = mouseOverColor;<br/>         }<br/> <br/>         void OnMouseOver() {<br/>             meshRenderer.material = mouseOverMaterial;<br/>         }<br/> <br/>         void OnMouseExit() {<br/>             meshRenderer.material = originalMaterial;<br/>         }<br/>     } </pre>
<ol start="6">
<li>With the Cube selected, in the Mouse Over Highlighter (Script) component in the Inspector, you'll see the mouse-over color is yellow. You may wish to change this.</li>
</ol>
<ol start="7">
<li>Test the scene. The Cube will be highlighted red when the mouse is over it (and green when clicked on).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Start()</kbd> method does four things:</p>
<ul>
<li>Stores a reference to the MeshRenderer component in the <kbd>meshRenderer</kbd> variable</li>
<li>Stores a reference to the original Material of the GameObject in the <kbd>originalMaterial</kbd> variable</li>
<li>Creates a new Material named mouseOverMaterial</li>
<li>Sets the color of <kbd>mouseOverMaterial</kbd> to the color in the mouseOverColor public variable</li>
</ul>
<p>The cube is automatically sent the mouse enter/exit events as the user moves the mouse pointer over and away from the part of the screen where the cube is visible. Our code adds a behavior to the cube when these events are detected.</p>
<p>When the <kbd>OnMouseOver</kbd> message is received, the method with that name is invoked, and the GameObject's material is set to <kbd>mouseOverMaterial</kbd>. When the <kbd>OnMouseExit</kbd> message is received, the GameObject's material is returned to <kbd>originalMaterial</kbd>.</p>
<p>The material property of the Renderer is a copy of the </p>
<p>If the Material of a GameObject is shared by several objects, we must be careful when changing Material properties to only change those we want to. If we wish to only change values for a particular GameObject, use the <kbd>.material</kbd> property of <kbd>Renderer</kbd> – since a separate clone is created if more than one object uses the same Material. If we want all GameObjects using the same Material to be affected by changes, use the <kbd>.sharedMaterial</kbd> property of <kbd>Renderer</kbd>. Since there was only one GameObject in this recipe, either could have been used.<br/>
Read more at<a href="https://docs.unity3d.com/ScriptReference/Renderer-material.html"> https://docs.unity3d.com/ScriptReference/Renderer-material.html</a></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to enhance this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Collider needed for custom meshes</h1>
                
            
            
                
<p>We created a primitive 3D Cube – this automatically has a Box Collider component. If you were to use the preceding script with a custom 3D mesh object, ensure the GameObject has a Physics | Collider component, so that it will respond to mouse events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mouse Down/Up events – for clicking color</h1>
                
            
            
                
<p>We can extend our code to also display a different color when an object is clicked on (mouse down/up events).</p>
<p>Do the following:</p>
<ol>
<li>Remove the scripted <kbd>MouseOverHighlighter</kbd> from the Cube <kbd>GameObject</kbd>.</li>
<li>Create a new C# script-class named <kbd>MouseOverDownHighlighter</kbd>, and add an instance object as a component to the Cube:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class MouseOverDownHighlighter : MonoBehaviour {<br/>         public Color mouseOverColor = Color.yellow;<br/>         public Color mouseDownColor = Color.green;<br/> <br/>         private Material originalMaterial;<br/>         private Material mouseOverMaterial;<br/>         private Material mouseDownMaterial;<br/>         private MeshRenderer meshRenderer;<br/> <br/>         private bool mouseOver = false;<br/> <br/>         void Start() {<br/>             meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br/>             originalMaterial = meshRenderer.sharedMaterial;<br/>             mouseOverMaterial = NewMaterialWithColor(mouseOverColor);<br/>             mouseDownMaterial = NewMaterialWithColor(mouseDownColor);<br/> <br/>         }<br/> <br/>         void OnMouseEnter() {<br/>             mouseOver = true;<br/>             meshRenderer.sharedMaterial = mouseOverMaterial;<br/>         }<br/> <br/>         void OnMouseDown() {<br/>             meshRenderer.sharedMaterial = mouseDownMaterial;<br/>         }<br/> <br/>         void OnMouseUp() {<br/>             if (mouseOver)<br/>                 OnMouseEnter();<br/>             else<br/>                 OnMouseExit();<br/>         }<br/> <br/>         void OnMouseExit() {<br/>             mouseOver = false;<br/>             meshRenderer.sharedMaterial = originalMaterial;<br/>         }<br/> <br/>         private Material NewMaterialWithColor(Color newColor) {<br/>             Material material = new Material(meshRenderer.sharedMaterial);<br/>             material.color = newColor;<br/> <br/>             return material;<br/>         }<br/>     } </pre>
<ol start="3">
<li>There are two public Colors: one for mouse-over and one for mouse-down (click) highlighting.</li>
<li>Run the Scene. You should now see different highlight colors when the mouse pointer is over the Cube, and when you click the mouse button when the mouse pointer is over the Cube.</li>
</ol>
<p>Since we are creating two new Materials, the reusable <kbd>NewMaterialWithColor(...)</kbd> C# method is included above, to simplify the content of the <kbd>Start()</kbd> method. A Boolean (true/false) variable has been introduced, so that the correct behavior occurs after the mouse button is released, depending on whether the mouse pointer is still over the object (<kbd>mouseOver = true</kbd>) or has moved away from the object (<kbd>mouseOver = false</kbd>).</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Detail maps to a material</h1>
                
            
            
                
<p>When creating a large object, there is not only the desire to <strong>Texture</strong> it as a whole, but also to add details that can make it look better when viewed up close. To overcome the need for large, memory-hogging, highly-detailed texture maps, the use of Detail maps can make a real difference.</p>
<p>In this recipe, we will add <strong>Detail maps</strong> to a rocket toy by applying a <strong>Detail mask</strong> and a <strong>Detail Normal</strong> map. In our case, we want to add a textured quality (and a stripe pattern) to the green plastic, except in the region where there is a battery compartment and the toy's logo:</p>
<div><img src="img/0992c355-f09f-42d9-bbc9-a91bca56df54.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared three files in the <kbd>05_06</kbd> folder:</p>
<ul>
<li>rocketToy.fbx: A 3D object of a package (FBX format)</li>
<li>ship_diffuse.png: The diffused texture map for the rocket ship toy (PNG format)</li>
<li>ship_height.png: The heightmap to be used to create a normal map (PNG format)</li>
</ul>
<p>Also provided are the four final, image-edited files you'll create in the project:</p>
<ul>
<li>detail_diffuse.png: The Albedo texture map for the packaging with cutouts (PNG format)</li>
<li>detail_height.png: The greyscale gradient circle – for the dimpled surface detail effect (PNG format)</li>
<li>ship_mask.tif: The detail mask – indicating how much the text and battery holder appear raised up (TIF format)</li>
<li>ship_mask2.tif: The detail mask – where the Alpha for the battery holder is greater, so no dimples will appear from <kbd>detail_height</kbd> (TIF format)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To add the Detail maps to your object, follow these steps:</p>
<ol>
<li>Import the provided files.</li>
<li>In the Project panel, select the rocketToy model asset. In the Inspector, click the <kbd>Materials</kbd> button and then click Extract Materials... Extract the model's Materials into a new folder named <kbd>Materials</kbd>. You should now have five Materials for each part of the rocketToy model (<kbd>MAT_base/end/level1/2/3</kbd>):</li>
</ol>
<div><img src="img/f3705b1e-91b8-4d41-b41c-8d3ccce5f1fb.png" style="width:40.33em;height:20.83em;"/></div>
<p class="mce-root"/>
<ol start="3">
<li>Select <strong>Mater</strong><strong>ial</strong> MAT_rocketLevel1, and change the Shader to Standard (Specular setup). Drag the <kbd>ship_diffuse</kbd> Texture from the Project panel into the <strong>Albedo</strong> Texture slot in the Inspector properties for MAT_rocketLevel1.</li>
<li>Drag the <kbd>rocketToy</kbd> model asset from the Project panel into the Scene panel (or Hierarchy) to add an instance of the model as a <kbd>GameObject</kbd> in the Scene. You should be able to see the image of the text of the toy's logo ("Rocket") and the battery compartment in level 1 (above the base).</li>
<li>Duplicate the ship_diffuse Texture, naming the copy ship_mask.</li>
<li>Open ship_mask in your image editor. Select all the solid green pixels around the logo and battery compartment (in Photoshop, this can be done with the Magic Wand tool, keeping the <em>Shift</em> key pressed while selecting multiple areas):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2bd99e7e-351b-4815-8909-b43d6d25d6f9.png"/></p>
<ol start="7">
<li>Keeping your selection active, access the image Channels window (in Photoshop, this can be done by navigating to Window | Channels). Click on New Channel. This will be our Alpha Channel:</li>
</ol>
<div><img src="img/2d7a5008-c9f3-4627-bd0e-b0bcc735dfc0.png"/></div>
<ol start="8">
<li>Hide the Red, Green, and Blue channels. Select the Alpha Channel and paint the selection white. Select the area of the battery compartment and paint it grey (R, G, and B: 100):</li>
</ol>
<div><img src="img/587ea264-1e9e-41bd-82b9-bbf9241713b2.png"/></div>
<ol start="9">
<li>Save it in the TIF format as ship_mask.tif, in the <kbd>Assets</kbd> folder. Make sure that you include Alpha Channels:</li>
</ol>
<div><img src="img/e25e7cd6-5d2f-4853-9c87-3f2755c6cc8b.png"/></div>
<ol start="10">
<li>Now that we have the mask, let's create a diffuse map for our detail. In your image editor, create a new image with the following dimensions: width: 64, and height: 64:</li>
</ol>
<div><img src="img/6d4ef0c4-490e-4bc0-bd1c-3413ebbbcbce.png"/></div>
<ol start="11">
<li>Fill the new image with grey (R, G, and B: 128). Use shapes or rectangular fills to create a dark grey (R, G, and B: 100) horizontal line that is about 16 pixels tall:</li>
<li>Save the image as detail_diff.png in the Assets folder.</li>
<li>Create a new 64 x 64 image. Use a Gradient tool to create a black and white Radial Gradient (in Photoshop, this can be done with the Gradient Tool in Radial mode):</li>
</ol>
<div><img src="img/ef807d3f-147d-4412-aaf7-5fbc1448224b.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="14">
<li>Save the image as detail_height.png in the <kbd>Assets</kbd> folder. Return to the Unity editor.</li>
<li>From the <kbd>Assets</kbd> folder, select detail_height. In the Inspector, change its Texture Type to Normal map, check the Create from Grayscale option, adjust Bumpiness to 0.25, and set Filtering to smooth. Click on Apply to save the changes:</li>
</ol>
<div><img src="img/2bce8852-1024-4696-82e0-e8698b83827d.png"/></div>
<ol start="16">
<li>Do the same for the ship_height Texture – in the Inspector, change its Texture Type to Normal map, check the Create from Grayscale option, adjust Bumpiness to <kbd>0.25</kbd>, and set Filtering to smooth. Click on Apply to save the changes.</li>
<li>Select the <kbd>MAT_rocketLevel1</kbd> Material and view its properties in the Inspector. Set the following properties:
<ul>
<li>Assign the ship_height <strong>Texture</strong> to the Normal Map slot, and set its intensity to <kbd>0.3</kbd>.</li>
<li>Assign the ship_mask <strong>Texture</strong> to the Detail Mask slot.</li>
<li>Assign the detail_diff <strong>Texture</strong> to Secondary Maps | Detail Albedo x 2.</li>
<li>Assign the detail_height <strong>Texture</strong> as Secondary Maps | Normal Map, and set its intensity to <kbd>0.6</kbd>.</li>
</ul>
</li>
<li>In the Secondary Maps section, change the Tiling values as follows:
<ul>
<li>Set Tiling X to <kbd>200</kbd> and Y to <kbd>50</kbd>.</li>
<li>Set UV Set to UV1.</li>
</ul>
</li>
</ol>
<p>Until we set UV Set to UV1, you might have noticed that the pattern was not seamless. This was because we were using the same UV Set from our Diffuse Texture. However, the object has been assigned to two different UV channels (back when it was being modelled). While UV channel 1 contains the mapping for our Diffuse map, UV channel 2 uses a basic cylindrical mapping. We need to change the <strong>Secondary Maps</strong> section's UV Set from UV0 to UV1.</p>
<ol start="19">
<li>The Detail map for your Material is ready:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/00c84fc3-bc56-46f6-b4aa-be14a4a837bc.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When in use, Secondary Maps are blended onto the Material's primary Diffuse and Normal maps – that's why our object is green even after the Diffuse Detail is applied: the grey tones are superimposed on the original Diffuse Texture. By using a Detail Mask, the artist defines which areas of the object should be affected by Secondary Maps. This is great for customization, and also for creating nuances (such as the semi-bumped battery compartment in our example).</p>
<p class="mce-root"/>
<p>Another helpful feature is the possibility of using a separate UV channel for Details maps and Tiling. Besides adding variation to Texture mapping, this allows us to paint the details that can be perceived even at a very close distance by dramatically enhancing the visual quality of our objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fading the transparency of a material</h1>
                
            
            
                
<p>A feature of many games is for objects to fade away to invisible, or appear gradually from invisible to fully visible. Unity provides the special Rendering Mode of Fade for exactly this purpose.</p>
<p>In this recipe, we will create an object that, once clicked, fades out and disappears. We'll also look at how to enahnce the code, to take account of the GameObject's own initial alpha value, to self-destruct when fading has finished and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps:</p>
<ol>
<li>Create a new <strong>3D Sphere</strong>, named Sphere-Game. Choose menu: 3D Object | Sphere.</li>
<li>Select Sphere-Game and ensure it has a Collider (if you are using a custom 3D object, you might have to add a collider through menu: Add Component | Physics | Box (or Mesh) Collider).</li>
<li>Create a new Material named m_fade.</li>
<li>With the m_fade <strong>Material</strong> selected, change its Rendering Mode to Fade in the Inspector:</li>
</ol>
<div><img src="img/6c51d7b1-d92d-4c4f-95fd-a3447b3906d7.png"/></div>
<p>The <strong>Fade</strong> rendering mode is specifically designed for situations such as this. Other rendering modes, such as Transparent, will turn the Albedo color transparent, but not the specular highlights nor the reflections, in which case the object will still be visible.</p>
<ol start="5">
<li>Apply the m_fade <strong>Material</strong> to Sphere-Game by dragging it from the Project panel into the Sphere-Game GameObject.</li>
<li>Create a new C# script-class named FadeAway and add an instance object as a component to Sphere-Game:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>     public class FadeObject: MonoBehaviour {<br/>         public float fadeDurationSeconds = 1.0f;<br/>         public float alphaStart = 1.0f;<br/>         public float alphaEnd = 0.0f;<br/>         private float startTime;<br/>         private MeshRenderer meshRenderer;<br/>         private Color fadeColor;<br/>         private bool isFading = false;<br/> <br/>         void Start () {<br/>             meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br/>             fadeColor = meshRenderer.material.color;<br/>             UpdateMaterialAlpha(alphaStart);<br/>         }<br/> <br/>         void Update() {<br/>             if (isFading)<br/>                 FadeAlpha();<br/>         }<br/> <br/>         void OnMouseUp() {<br/>             StartFading();<br/>         }<br/> <br/>         private void StartFading()<br/>         {<br/>             startTime = Time.time;<br/>             isFading = true;<br/>         }<br/> <br/>         private void FadeAlpha()<br/>         {<br/>             float timeFading = Time.time - startTime;<br/>             float fadePercentage = timeFading / <br/>             fadeDurationSeconds;<br/>             float alpha = Mathf.Lerp(alphaStart, alphaEnd, <br/>            fadePercentage);<br/>             UpdateMaterialAlpha(alpha);<br/> <br/>             if (fadePercentage &gt;= 1)<br/>                 isFading = false;<br/>         }<br/> <br/>         private void UpdateMaterialAlpha(float newAlpha) {<br/>             fadeColor.a = newAlpha;<br/>             meshRenderer.material.color = fadeColor;<br/>         }<br/>     } </pre>
<ol start="7">
<li>Play your Scene and click on the Sphere to see it fade away and self-destruct.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The opaqueness of the material using a transparent <strong>Shader</strong> is determined by the <strong>alpha</strong> value of its main <strong>color</strong>. This recipe is based around changing the Alpha value of the <strong>Color</strong> of the <strong>MeshRenderer</strong>.</p>
<p>There are three public variables:</p>
<ul>
<li><kbd>fadeDurationSeconds</kbd>: The time in seconds we want our fading to take</li>
<li><kbd>alphaStart</kbd>: The initial alpha (transparency) we want the GameObject to start with (1 = fully visible, 0 = invisible)</li>
<li><kbd>alphaEnd</kbd>: The alpha value we want to fade the GameObject into</li>
</ul>
<p>The <kbd>UpdateMaterialAlpha(...)</kbd> method updates the alpha value of the GameObject's Color object with the given value by updating the alpha value of the <kbd>fadeColor</kbd> Color variable, and then forcing the MeshRenderer Material to update its Color value to match those in fadeColor.</p>
<p>When the Scene begins, the <kbd>Start()</kbd> method caches a reference to the MeshRenderer component (the <kbd>meshRenderer</kbd> variable), and also the Color object of the Material of the MeshRenderer (the <kbd>fadeColor</kbd> variable). Finally, the GameObject's alpha is set to match the value of variable alphaStart, by invoking the <kbd>UpdateMaterialAlpha(...)</kbd> method.</p>
<p class="mce-root"/>
<p>The <kbd>OnMouseUp()</kbd> method is invoked when the user clicks the GameObject with their mouse. This invokes the <kbd>StartFading()</kbd> method.</p>
<p>The actions to start fading weren't simply put in this method, since we may also wish to start fading due to some other events (such as keyboard clicks, a timer hitting some value, or an NPC changing into some mode such as dying). So we separate the logic that detects that event that we are interested has taken place, with the actions we wish to perform, in this case to start the fading process.</p>
<p>The <kbd>StartFading()</kbd> method records the current <strong>Time</strong>, since we need that to know when to finish fading (time when we started fading + fadeDurationSeconds). Also the isFading Boolean flag is set to true, so logic elsewhere relating to fading will know it's time to do things.</p>
<p>The <kbd>Update()</kbd> method, called each frame, tests whether the <kbd>isFading</kbd> flag is true. If it is, the <kbd>FadeAlpha()</kbd> method is invoked for each frame.</p>
<p>The <kbd>FadeAlpha()</kbd> method is where the majority of our alpha-fading logic is based:</p>
<ul>
<li><kbd>timeFading</kbd> is calculated: The time since we started fading</li>
<li><kbd>fadePercentage</kbd> is calculated: How far we are from start (0) to finish (1) of our fading</li>
<li>alpha is calculated: The appropriate alpha value for our fade percentage, using the <kbd>Lerp(...)</kbd> method to choose an <kbd>intermedia</kbd> value based on a <kbd>0..1</kbd> percentage</li>
<li>The <kbd>UpdateMaterialAlpha(...)</kbd> method with the new alpha value</li>
<li>If fading has finished (<kbd>fadePercentage</kbd> &gt;= 1), we set the <kbd>isFading</kbd> Boolean flag to false to indicate this</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to enhance our fading features.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Start with keypress and fade in from invisible</h1>
                
            
            
                
<p>The preceding code can fade in from invisible (<kbd>alphaStart</kbd> = 0) to fully visible (<kbd>alphaEnd</kbd> = 1). However, if we can't see the object initially, then it's a bit much to ask the player to click an invisible Sphere! So let's add code to the <kbd>Update()</kbd> method (checked each frame) to detect when the <em>F</em> key is pressed, as an alternative way to start our fading process:</p>
<pre class="SourceCode">void Update()<br/> {<br/> if (Input.GetKeyDown(KeyCode.F))<br/> StartFading();<br/> <br/> if (isFading)<br/> FadeAlpha();<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Destroy object when fading complete</h1>
                
            
            
                
<p>If fading to invisible is how a GameObject communicates to the player that it is leaving the scene (completed/dying), then we may want that GameObject to be Destroyed after the fading process is completed. Let's add this feature to our code.</p>
<p>Do the following:</p>
<ol>
<li>Add a new public Boolean variable to our script (default to false):</li>
</ol>
<pre style="padding-left: 60px">public bool destroyWhenFadingComplete = true; </pre>
<ol start="2">
<li>Add a new <kbd>EndFade()</kbd> method, which sets <kbd>isFading</kbd> to <kbd>false</kbd>, and then tests whether the public <kbd>destroyWhenFadingComplete</kbd> variable was set to true, and if so, Destroys the GameObject:</li>
</ol>
<pre style="padding-left: 90px">private void EndFade() {<br/>         isFading = false;<br/> <br/>         if(destroyWhenFadingComplete)<br/>             Destroy (gameObject);<br/>     } </pre>
<p class="mce-root"/>
<ol start="3">
<li>Refactor the <kbd>FadeAlpha()</kbd> method so that it invokes <kbd>EndFade()</kbd> when the fading is completed (<kbd>fadeProgress &gt;= fadeDurationSeconds</kbd>):</li>
</ol>
<pre style="padding-left: 60px">    private void FadeAlpha()<br/>     {<br/>         float fadeProgress = Time.time - startTime;<br/>         float alpha = Mathf.Lerp(alphaStart, alphaEnd, fadeProgress <br/>          / fadeDurationSeconds);<br/>         UpdateMaterialAlpha(alpha);<br/> <br/>         if (fadeProgress &gt;= fadeDurationSeconds)<br/>             EndFade();<br/>     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using GameObect's alpha as our starting alpha value</h1>
                
            
            
                
<p>It may be that the game designer has set the alpha value of a GameObject in the Inspector to the initial value they want. So let's enhance our code to allow this to be indicated by checking a public Boolean flag variable in the <strong>Inspector</strong>, and adding code to read and use the GameObject's alpha if that option is chosen.</p>
<p>Do the following:</p>
<ol>
<li>In the <strong>Inspector</strong>, click the Color picker for the Material Albedo, and set the <kbd>Alpha</kbd> value to something other than 255 (for example, set to 32, which is mostly transparent):</li>
</ol>
<div><img src="img/44bd6cbf-10ea-4cab-84c3-f3a4e6dc1862.png"/></div>
<ol start="2">
<li>Add a new public Boolean variable to our script (default to false):</li>
</ol>
<pre style="padding-left: 60px">public bool useMaterialAlpha = false; </pre>
<ol start="3">
<li>Add logic to the <kbd>Start()</kbd> method so that if this flag is true, we use the alpha value of the Color read from the GameObject's Material as the Scene begins (<kbd>fadeColor.a</kbd>):</li>
</ol>
<pre style="padding-left: 60px">void Start () {<br/>         meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br/> <br/>         // set object material's original color as fadeColor<br/>         fadeColor = meshRenderer.material.color;<br/> <br/>         // IF using material's original alpha value, THEN use <br/>             //material's alpha value for alphaStart<br/>         if (useMaterialAlpha)<br/>             alphaStart = fadeColor.a;<br/> <br/>         // start object's alpha at our alphaStart value<br/>         UpdateMaterialAlpha(alphaStart);<br/>     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a coroutine for our fading loop</h1>
                
            
            
                
<p>Where possible, we should avoid adding code in the <kbd>Update()</kbd> method, since this is invoked every frame, and so can reduce the performance of our games, especially if many objects have scripted components with <kbd>Update()</kbd> methods, all testing flags every frame.</p>
<p>One very effective solution is to invoke a coroutine when we want some actions performed over several frames, since a coroutine can perform some actions, then yield control back to the rest of the Scene, and then resume its actions from the point it left off previously, and so on until its logic is completed.</p>
<p>Do the following:</p>
<ol>
<li>Remove the <kbd>Update()</kbd> method.</li>
<li>Add a new using statement at the top of the script class, since coroutines return an <kbd>IEnumerator</kbd> value, which is part of the <kbd>System.Collections</kbd> package:</li>
</ol>
<pre style="padding-left: 60px">using System.Collections; </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Add a new method:</li>
</ol>
<pre style="padding-left: 60px">private IEnumerator FadeFunction() {<br/>         while (isFading)<br/>         {<br/>             yield return new WaitForEndOfFrame();<br/>             FadeAlpha();<br/>         }<br/>     } </pre>
<ol start="4">
<li>Refactor the <kbd>StartFading()</kbd> method, so that is starts our coroutine:</li>
</ol>
<pre style="padding-left: 60px">private void StartFading() {<br/>         startTime = Time.time;<br/>         isFading = true;<br/>         StartCoroutine(FadeFunction());<br/>     } </pre>
<p>That's it – once the coroutine has been started, it will be called each frame until it completes its logic, temporarily suspending its execution each time a yield statement is executed.</p>


            

            
        
    </body></html>