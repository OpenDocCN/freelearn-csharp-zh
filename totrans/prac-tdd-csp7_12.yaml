- en: The Legacy Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about legacy code. If you have never had to deal with legacy
    code, count yourself lucky and know that it is coming. Some of you may be permanently
    stuck in maintenance development. Your life is legacy code. Whatever the situation,
    this chapter is all about dealing with legacy code. We want to either prevent
    legacy code from happening, or fight it back to the depths from which it came.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: What makes code legacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issues that legacy code can create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How legacy code can inhibit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we can do to deal with and fight back against the legacy problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is legacy code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of you have probably had to work on a dreaded legacy project. Working on
    that project is no fun; the code is a mess, and you want to find whoever wrote
    it and find out what they were thinking when they wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: At some point in your career, you have been or will be that person to someone
    else. We all write code that we will not be proud of later. But why does the code
    get so bad? When does a project become legacy? Lastly, what can be done to prevent
    this?
  prefs: []
  type: TYPE_NORMAL
- en: Why does code go bad?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, code goes bad because we are afraid to change it. Why would the code
    not changing cause it to be bad? You would hope that, when the code was written,
    it was the best code that developer was capable of producing at the time. So,
    that code should have been good, right? This is a complicated answer, but assume,
    for the moment, that the code was something to be proud of when it was originally
    written. That still begs the question, how did it go bad?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is staring you in the face. The only reason you are seeing this code
    is because it needs to change. Chances are, you are not the first person that
    has needed to make a change in this code. So, this is not the code that was written
    by a developer doing his or her best to write good code. This code was written
    by many developers. Still, each of those developers should have been doing their
    best to write good code. So, again, how did this code go bad?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the fear comes in, because we are afraid to change the code. When
    we have to change it, we generally try to change the code as little as possible
    to get the requested update working. After all, we don't want to force ourselves
    or QA to do a full regression test because we refactored the whole thing, do we?
    So, we modify the code; we change the way it is expected to work. But we can't
    change the structure, and we can't modify the decisions of the developer who originally
    wrote the code.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, making these small changes and being afraid to modify the structure
    and architectural decisions of the original developer causes severe code rot.
    Soon, the code will have massive conditional statements and methods that no longer
    fit on the page. The class containing the code will grow to tens of methods and
    the file will be thousands of lines long.
  prefs: []
  type: TYPE_NORMAL
- en: When does a project become legacy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a question that is answered by many people in many different ways. Generally,
    an application has become legacy when no one wants to work on it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, applications are built with a small and defined purpose. Over
    time, the scope and breadth of a system may grow beyond its original intent. When
    any change to the application causes the developer to work against what the application
    was designed for, it will cause friction.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the application design is not simply changed because
    of the fear a developer might have that the application will break. So, more and
    more cruft is added to the system. Okay, so how long does it take for this to
    happen? When do we stop hacking new modifications into the existing application
    and just rewrite it?
  prefs: []
  type: TYPE_NORMAL
- en: Honestly, the cruft starts getting added by the original developer as he or
    she is writing the application for the first time. When you start to work on a
    new application, or even just a new feature in an existing application, you start
    with a preliminary design in mind. Everyone does this. Some developers whiteboard
    the design or make complete **UML** (**Unified Modeling Language**) diagrams.
    Other developers just have an idea in their head to guide decisions. Either way,
    you have a design you want when you sit down to develop an application.
  prefs: []
  type: TYPE_NORMAL
- en: How long is it before you discover an issue with your design and have to start
    modifying it? You might get one line of code in before you have to change your
    design, or you might get 75% of the way through before you discover an issue.
    This is largely determined by the complexity of the problem you are solving and
    how detailed your planning was. Regardless of the thoroughness of your planning,
    you will find an issue and have to start changing your design before the first
    QA review.
  prefs: []
  type: TYPE_NORMAL
- en: The second you make that change, you are adding cruft, so almost all of the
    time, you are working in a system that was not designed for the code that is being
    forced into it. In other words, you will probably be writing legacy code the next
    time you are at work, even if you are working on a new application.
  prefs: []
  type: TYPE_NORMAL
- en: Cruft, in software, is any code that is unnecessary or needlessly complex.
  prefs: []
  type: TYPE_NORMAL
- en: What can be done to prevent legacy decay?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There must be something that can be done to prevent this decay, right? The
    answer is probably predictable, given the topic of this book. But let me answer
    with a quote from Michael Feathers on the definition of legacy code:'
  prefs: []
  type: TYPE_NORMAL
- en: To me, legacy code is simply code without tests.
  prefs: []
  type: TYPE_NORMAL
- en: '- Michael Feathers, Working Effectively with Legacy Code'
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in earlier chapters, tests allow you to refactor. The ability
    to change the structure of the code is precisely what can prevent the rot and
    decay that is legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: While tests can allow you to prevent legacy code from forming, be aware that
    they themselves do not prevent the legacy problem. It takes the dedication of
    every person on the team understanding that building cruft into a system is a
    negative behavior and must be avoided. If you feel yourself working against the
    design of the system, then it is your responsibility to refactor the application
    into a design that works for today's needs and is flexible enough for tomorrow's
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Making a system flexible is not as hard as you might think. Following the SOLID
    principles (discussed in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195),  *Setting
    up a JavaScript Environment*) will help to produce a maintainable and flexible
    system. Even with a flexible system, it takes discipline and determination to
    maintain a standard of recognizing and fixing friction in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The process of finding that friction could be considered **PDD** (**Pain Driven
    Development**). This concept means to do the simplest thing to solve your existing
    problem and actively recognize any friction that arises during future modifications
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: PDD can be applied to any system, including the application, your team, and
    your personal life. Following this strategy, you will become obsessed with removing
    friction in all things, and can get a little carried away. So, it is important
    to keep in mind that you might be the only one looking for this friction, and
    the rest of the world might be ignorant to the pain they are causing themselves.
    Also, keep in mind that people do not, generally, enjoy having their ignorance
    pointed out.
  prefs: []
  type: TYPE_NORMAL
- en: Typical issues resulting from legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a reason we fear working on legacy code. But, what is it that we fear
    when working on legacy code? It's not the code itself; the code cannot harm us.
    Instead, what we fear is hearing that we have introduced a bug. The most dreaded
    word that a developer can hear. A bug means that we have failed and that we will
    have to work on the legacy code again.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the types of issues we might run into while working on legacy code,
    we find several. Firstly, because we don't know the code, a change to one part
    might cause unintended side effects in a different part of the application. Another
    issue is the code could be over-optimized or written by someone who was trying
    to be clever when they wrote it. Lastly, tight coupling can make updating the
    code difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Unintended side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the changes that push an application towards the legacy realm, often
    the methods or functions in the application will be used in unexpected places,
    far away from the code that you are changing.
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary violations of the SOLID principles that have led to this
    issue, and the same two can help you to avoid it going forward. The first is the
    **OCP** (**Open Closed Principle**), and the second is the **LSP** (**Liskov Substitution
    Principle**).
  prefs: []
  type: TYPE_NORMAL
- en: Open Closed Principle and legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, the Open Closed Principle states that code should be
    open for extension yet closed for modification. This principle is designed to
    prevent the issues with legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: If the modification that has been requested of you is one that will change the
    behavior of a specific piece of the application, then try to instead clone the
    method in question and modify the clone. Then the part of the application that
    needs the change can call the clone instead. This will prevent the change from
    affecting any parts of the application except the parts you are intending to affect.
  prefs: []
  type: TYPE_NORMAL
- en: Until we know for sure that the code we just avoided is not being used elsewhere
    in the application, we can't delete it. Eventually, once we are sure that the
    old code is truly orphaned and not used, we want to clean up and delete the unused
    method to maintain a code base with just a little less cruft.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the change is for a bug, then the fix is a little more
    complicated. You must first determine whether the bug should be fixed everywhere
    that this code might be used, or whether the bug is relative only to a specific
    portion of the application. When in doubt, fall back to cloning the method and
    only affecting intentional parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle and legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you determine whether change should affect the entire application or
    just a slice? One way is to employ the LSP. Simply put, LSP says that a class
    should do what it sounds like it does. Any behavior change that would change that
    should be a different dependency.
  prefs: []
  type: TYPE_NORMAL
- en: That is, any change that changes behavior should probably be a new method or
    a new class with the appropriate method in it. This will prevent accidental side
    effects in the rest of the application and keep your code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Over-optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been said that premature optimization is a bad thing. What is optimization,
    though? Generally, to optimize is to reduce the number of steps from point A to
    point B. In a computer program, that means to reduce the number of cycles required
    to compute a result.
  prefs: []
  type: TYPE_NORMAL
- en: An unfortunate side effect of optimizing code is that the code usually becomes
    much more difficult to read and comprehend. Optimizations tend to obfuscate the
    code in such a way that the only person who can understand it is the person who
    wrote it, and after some time, they may not be able to understand it either.
  prefs: []
  type: TYPE_NORMAL
- en: It is a fact that hard to understand code is code that is hard to change. This
    is the reason why optimizations that happen before they are needed are a bad thing.
  prefs: []
  type: TYPE_NORMAL
- en: So, when is an optimization needed? An optimization is needed when it is clear
    that the current implementation will not be able to meet the demands on the system
    within a reasonable timeframe in the future.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a timeframe reasonable depends on the complexity of the needed optimization
    and the speed of the business. When a business is growing quickly, demand will
    follow along the same curve.
  prefs: []
  type: TYPE_NORMAL
- en: A slower moving company may require several months of planning and preparation
    before assigning work to a developer. In this situation, it is reasonable to plan
    for optimizations several months before they are needed. It is important to monitor
    the performance of an application so that these needs can be predicted.
  prefs: []
  type: TYPE_NORMAL
- en: Overly clever code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers start writing code because they enjoy it. It is not common to
    find a developer that came into the field simply because they heard they could
    make lots of money. Working for a company writing the same boring code all the
    time can cause developers to want to have some fun once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: When developers get bored, they come up with interesting and often overly complicated
    solutions that are simply not required. Sometimes, developers will come up with
    the cleverest solution they can figure out to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with clever solutions is that to fix a problem, you have to be more
    skilled than the person who fixed it. So, if you write the cleverest code you
    can write, then you are no longer qualified to debug the code, and you bring your
    own, and everyone else's, progress to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: Tight coupling to third-party software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone uses some third-party plugin or library. In the software community,
    it is inevitable that you will have to depend on someone else's code. What you
    don't know when you use that code is the quality, stability, and ability to meet
    your future needs.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, it is a bad idea to rely directly on the classes and interfaces
    presented to you by that third-party. Instead, use a hexagonal architecture, also
    known as ports and adapters. For anyone doing C#, this includes abstracting the
    .NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that you and your team did not write should be abstracted to protect
    your code from the potential external changes. This includes code written at your
    company but by a different team. If it is outside your control, put it behind
    an abstraction. The preferred abstraction is one or more interfaces that provide
    the desired functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Issues that prevent adding tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deadlines are tight. The scope is ever changing. We just don't have time to
    write tests. It's more important to get functionality out the door. We've all
    been there. Whatever the case may be, sometimes you will find yourself working
    on a project that was not written with testing in mind.
  prefs: []
  type: TYPE_NORMAL
- en: There never seems to be enough time to do it right, but there's always time
    to do it over.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are the issues you might face that would prevent you from adding tests
    to a legacy application?
  prefs: []
  type: TYPE_NORMAL
- en: When a system wasn't written with testing in mind, it can be quite difficult
    to go back and add tests at a later date. Classes with concrete dependencies and
    tight coupling make software applications difficult to test. Things such as large
    classes and functions, Law of Demeter violations, global state, and static methods
    can also make for a system that can be very difficult to test.
  prefs: []
  type: TYPE_NORMAL
- en: Much like building a house by starting with a shaky foundation, untestable code
    begets untestable code. Unless pieces of the system can be decoupled from the
    rest of the application, the untestable trend will likely continue, and often
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Direct dependence on framework and third-party code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As was covered in a previous chapter, dependency on framework and third-party
    code makes for a tightly coupled system. Any time that the *new* operator in C#,
    for example, is invoked, then a direct dependency is made to that particular class.
    We want to minimize those dependencies as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that even framework dependencies should be avoided, or, at the very
    least, abstracted as much as possible. Think back to the `DateTime` example, where
    we were able to supply our own `DateTime` value for testing purposes in the sample
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Any `using` or `import` statement at the top of a class or file should be carefully
    considered and avoided if at all possible. Instead, ensure that your code is dependent
    on an *interface* whose definition is directly under your control. That way, you
    can minimize the coupling and isolate the functionality within your own classes
    and methods. This will help you write cleaner, more testable code.
  prefs: []
  type: TYPE_NORMAL
- en: Law of Demeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Law of Demeter, in its simplest form, states that, *Each unit should have
    only limited knowledge about other units: only units "closely" related to the
    current unit*. Further, *Each unit should only talk to its friends; don''t talk
    to strangers*. Simply put, *Only talk to your immediate friends*.'
  prefs: []
  type: TYPE_NORMAL
- en: When a class or function has knowledge of the inner workings of something outside
    its immediate control, then there is some tight coupling happening there. In order
    to test a method that has one or more Law of Demeter violations, the amount of
    setup involved is often fairly substantial. In order to test a method of one class
    that violates the Law of Demeter, you must set up the other class or method, or
    provide a reasonable fake implementation in order to test effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, keep your test methods small and nimble so that they run quickly and
    are easy to understand. If you follow this rule, your production code will likely
    also be similarly simple and easy to follow. This will pay off in the long run,
    as it will be easier to maintain in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Work in the constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a new instance of a class is created that has logic in the constructor,
    it is often very difficult to test that class. If, for some reason, you need to
    set up a test scenario that requires different values or behavior than that which
    is set up in the constructor, it will be quite difficult to proceed. It would
    be best to minimize the work done in the constructor and extract helper methods
    or some other scenario more easily tested and better implemented elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that particular patterns may prove to be better alternatives to
    setting up a specific class or function. You should familiarize yourself with
    common software patterns and how to best implement them. This will help you grow
    an application by working to solve similar problems that have been resolved by
    others before you. By utilizing known software patterns, you can more easily communicate
    your intent with the code within the system.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern, for example, might be employed to construct an object with
    the proper values set that would otherwise be added to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example of the `Car` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You could easily write a builder class to construct a specific type of car,
    such as a `ToyotaCamryBuilder` or `FordMustangBuilder`. Creating a new instance
    of either a Toyota Camry or a Ford Mustang would be quite easy, simple, and clean.
    Not to mention, it would be quite easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: Global state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global state is prone to the side effects from parts of the application far
    away. These side effects will change the results of the code you run. Functional
    programming has caught on in recent years, as one of the tenants is to reduce
    side effects, as they can cause unpredictable and undesirable behavior in a system.
    Instead, you should strive to break down your code into what are known as pure
    functions. Pure functions take an input and produce an output. For any given input,
    the output will always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static methods are not in and of themselves bad, but they do hint at a misplaced
    responsibility code smell. Static anything tells you that you have put the code
    in the wrong place. It doesn't share anything in common with the rest of the code
    in the scope and should probably be removed and put somewhere with its friends.
  prefs: []
  type: TYPE_NORMAL
- en: Large classes and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does class size really matter? What's the problem with having a large method
    or function? Large classes and functions often scream complexity. Remember the
    SOLID principles and what each letter in the acronym represents. A large class
    or method is likely violating one or more of the principles.
  prefs: []
  type: TYPE_NORMAL
- en: We want our classes and functions to be small and have only one reason to change
    (*Single Responsibility Principle*). A large class is likely hiding logic that
    can and should be broken into two or more separate and distinct classes. A large
    method or function likewise often hides two or more methods. Look for ways to
    keep your methods simple and keep an eye out for possible logical boundaries with
    which to break out smaller helpers, classes, and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and functions should be divided and grouped logically. The purpose of
    a system should be easily understood by the names and groupings of the files associated
    with the application. The structure of the system should be simple and make sense
    to those in charge of enhancing and maintaining the application.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with legacy problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been discussing all the issues with legacy code. Now it is time to tackle
    solving those issues. The first thing we must do is bring sanity to the targeted
    legacy code, and then we can begin testing and eventually fix the code and bring
    it back from death.
  prefs: []
  type: TYPE_NORMAL
- en: Safe refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term refactoring is often used incorrectly. When refactoring, you are merely
    changing the structure of the code. If the logic and/or signature of the code
    in question changes, then this does not qualify as refactoring. This is a change;
    most likely a breaking change.
  prefs: []
  type: TYPE_NORMAL
- en: If I'm changing the structure of the code (refactoring), then I don't ever change
    its behavior at the same time. If I'm changing the interface by which some logic
    is invoked, I never change the logic itself at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: – Kent Beck
  prefs: []
  type: TYPE_NORMAL
- en: A safe refactoring is one that is guaranteed to not accidentally break the code.
    Other changes that aren't intended to actually change the behavior of the code
    but could do it accidentally are considered unsafe refactoring. These usually
    involve changes to the private areas of the code that aren't directly exposed
    to consumers of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Converting values to variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first and easiest things that can be done is to extract any hard-coded
    values to be represented by variables. Having a variable allows for a quicker
    and more consistent update. It also helps to convey intent.
  prefs: []
  type: TYPE_NORMAL
- en: When creating the variables, make sure the name is descriptive enough for the
    scope of the variable. Variables with a short scope can have a short name. On
    the other hand, variables with a long scope must have a longer, more descriptive
    name. The further a variable is from its usages, the more descriptive it needs
    to be so that the context it represents isn't lost.
  prefs: []
  type: TYPE_NORMAL
- en: Check the scope of your variables and make sure they do not have a larger scope
    than is necessary. Also, check for variables that should have a larger scope but
    are instead passed between private methods instead of being class members.
  prefs: []
  type: TYPE_NORMAL
- en: It is not recommended at this time to update the private and protected methods
    that depend on variables that could be moved to a class scope. Instead, make note
    of them and move them around after tests have been added.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with legacy code often involves working with very large methods. A large
    method is any method that is longer than twenty lines. Preferably, methods are
    kept as small as possible, even down to just a few lines.
  prefs: []
  type: TYPE_NORMAL
- en: A large method can mean that the code is violating the Single Responsibility
    Principle. What needs to be done is to find the seams in the method. Seams can
    be found by commenting the different sections of the method. Once you have commented
    the sections, you have identified the seams.
  prefs: []
  type: TYPE_NORMAL
- en: Seam
  prefs: []
  type: TYPE_NORMAL
- en: In code, this is the location where two pieces of business logic meet. Normally,
    you might refer to the location where the private method is called by a public
    method as a seam in the public method. The code has been stitched together at
    that location. In this case, there are no private methods, so we are identifying
    where we want the seams to be.
  prefs: []
  type: TYPE_NORMAL
- en: Each one of those seams is probably a lower order method that can be extracted.
    In most editors and IDEs, highlight the code you want and use the extract method
    refactoring provided through either a right-click, context, menu, or via the menu
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like methods, sometimes a large method should really be a class. While
    extracting methods, if you extract three or more methods, then you have probably
    found a class that needs to be extracted.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a class is similar to extracting a method and is likely supported
    by your editor or IDE. Group and highlight the code you want to extract, then
    use the extract class menu option.
  prefs: []
  type: TYPE_NORMAL
- en: If your editor does not support extracting a class, all is not lost. Instead,
    highlight and cut all the methods you extracted that should be in the class. Create
    a new class file and paste those methods into the new class. Lastly, replace the
    calls to those methods in the original method with the instantiation and calling
    of the new class and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting third-party libraries and framework code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have variables, methods, and classes abstracted, it is time to abstract
    third-party libraries, framework code, and those classes we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let's start with framework details. Things like `DateTime`, `Random`,
    and `Console` are best hidden behind classes that you design to fit the needs
    of your application. There are several reasons for this; most importantly, putting
    these in their own classes will allow for testing. Without abstracting these to
    a separate class, it is almost impossible to test with things like `DateTime`
    that change values on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Next up are the third-party libraries. Anywhere the code is calling to create
    a new class from a third-party, you need to abstract that to a new class specifically
    for the purpose of utilizing that third-party library. For the moment, replace
    the call that instantiates the third-party library with a call that instantiates
    your class.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we can now deal with the calls to `new` that are left in the code. Everywhere
    that the code is calling `new` needs to be replaced with dependency injection.
    This will allow for testing and make the code cleaner and more flexible in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the dependency injection without modifying the signature of the class,
    we will be using a pattern called poor man''s dependency injection, also known
    as property injection. Below is an example of property injection in C#. The same
    process can be done in JavaScript with almost no modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using this pattern, it is possible to allow the class to create its dependency
    lazily, when asked for it. It is also possible to set the dependencies value for
    tests or other purposes. Although not shown in this quick example of the pattern,
    it is better to have the property and backing variable be of an interface type.
    This will make the injection of some other value easier.
  prefs: []
  type: TYPE_NORMAL
- en: Early tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an application of any significant size and complexity isn't properly segmented,
    it can be quite a daunting task to know how and where to begin writing tests.
    With a little practice in testing legacy systems it will become easier.
  prefs: []
  type: TYPE_NORMAL
- en: The *when* to write tests within a legacy system can easily be answered with,
    "When it makes sense to." It would be difficult to sell the idea to any business
    owner that time (and money) should be spent going back to write tests to cover
    the existing functionality of a legacy system. It makes much more sense to add
    tests as enhancements are added to the application or when defects are being addressed.
    As you're working in the code and have immediate context surrounding the functionality
    that you wish to test, that is the optimal time to begin to test parts of a legacy
    application.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you begin to write tests against a legacy system? Isolate small functions
    that can be easily tested. Extract methods and smaller classes as needed. Ensure
    that functionality is not being modified, but that code is simply being reorganized
    in order to facilitate testability.
  prefs: []
  type: TYPE_NORMAL
- en: It may be necessary to change a private method to be protected so that it may
    be tested.  Changing the scope of the method does make it more available and can
    reduce the effective abstraction, but if the change is required to aid in testing,
    the trade-off is almost always worth it. You might also consider that private
    methods made public might better belong to a different utility or helper class,
    and so can remain public. It depends on the method in question, but there are
    certainly options available to help you make a legacy system more testable.
  prefs: []
  type: TYPE_NORMAL
- en: Gold standard tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gold standard tests, or characterization tests, are those tests that simply
    define the expected functionality of a method. If you were to add tests to a legacy
    system, you would likely begin by writing gold standard tests to define the "happy
    path" through the system. You might run the application to determine what values
    a given method returns based on a given input, and then write a test to duplicate
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: Gold standard tests are used because they provide a shortcut. Normally, to test
    legacy code, you would have to abstract third-party libraries and set up dependency
    injections of some sort. You may also have to refactor the code significantly
    just to get to the point where you can test anything. By using a gold standard
    test, most of this work can, temporarily, be bypassed. The only abstractions needed
    are screen output, date/time, and random. Just about everything else can be used
    as is.
  prefs: []
  type: TYPE_NORMAL
- en: This would provide a baseline for a suite of tests and help ensure that expected
    functionality does not change with future refactoring or modifications. Gold standard
    tests do not validate correctness; they merely confirm that the system does what
    the system did.
  prefs: []
  type: TYPE_NORMAL
- en: As a basis, gold standard tests provide a certain level of comfort to guard
    against any unwanted behavior changes. These likely will not be enough to provide
    adequate code coverage and should have additional tests added to cover edge cases
    and alternate paths through the system.
  prefs: []
  type: TYPE_NORMAL
- en: As the test suite grows and the coverage becomes more meaningful and complete,
    it may prove wise to remove the original gold standard tests. Again, you want
    your test suite to be able to execute quickly so that it is run always and often.
    Removing tests that may be superfluous will help minimize the feedback cycles
    when running your tests. In other words, you will know if you have broken something
    faster and will be more likely to run the tests if the tests complete faster.
  prefs: []
  type: TYPE_NORMAL
- en: Testing all potential outcomes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not necessarily important to test for all possible values for an individual
    method. As in the example of gold standard tests, you certainly don't want to
    run the application with all possible values in order to write tests for each
    of the possibilities. It is far more important to test for every path of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a method is small enough and its potential outcomes limited in scope, it
    should be quite trivial to write a handful of tests to cover all potential scenarios.
    Take the following method as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What are the potential paths through this method? What tests might you write
    to ensure adequate coverage?
  prefs: []
  type: TYPE_NORMAL
- en: First, you might consider writing a test in the case that the *maximum* input
    parameter is equal to `0`. This should cover the `DivideByZeroException` in this
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you might write a test where the *current* parameter is `0`, ensuring
    that the result of this method is always zero, assuming *maximum* is non-zero.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you would want to write one or more tests to validate that the algorithm
    above is indeed calculating the percentage correctly, based on inputs.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it may be tempting to add tests for things like negative values
    or to check the rounding that C# is doing, but remember that we are working with
    legacy code and, as far as the business is concerned, this code is working as
    is. You don't have a record of the business requirements that spawned this code,
    so it would be unnecessary, and possibly irresponsible, to test more than what
    this code is telling you. So, if you believe the code is flawed in that it doesn't
    cover certain business criteria, or that it could produce incorrect values, discuss
    these things with your business and make a determination together. Any change
    to the code would have to be through either a bug or new work.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the legacy system has been sufficiently refactored and a comprehensive
    suite of tests has been added, you may begin to think of the application as non-legacy,
    current, or a present-day system. It should now be trivial to add new features
    and squash any newly discovered defects. From this point forward, any new feature
    requested should be easily added with the confidence that other parts of the system
    will not be negatively affected.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy application is no longer legacy. With a comprehensive suite of tests,
    you are now safe to proceed in Test-Driven Development fashion and write tests
    as every new feature is added. Remember to keep your tests as clean and well-refactored
    as any part of the production system.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the `GetPercent` example above, how might you modify this in order to
    return two decimal places? Why, by writing new tests, of course! Start by creating
    a test to return two decimal places based on the input value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your test might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, modify the existing method to return only two decimal places. We'll leave
    this as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixing bugs in a legacy system is a dangerous endeavor. Remember that any existing
    behavior may be accounted for in other parts of your system, or by external consumers
    of your application. By fixing a bug, you may be breaking functionality, albeit
    wrong, that someone else is depending on. So, a change to the execution results
    of code should be considered carefully before being done.
  prefs: []
  type: TYPE_NORMAL
- en: Free to do unsafe refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring is, by definition, modifying the structure of the code without modifying
    its behavior. Safe refactoring includes variable injection, method extraction,
    and so on. Unsafe refactoring would affect the architecture of the code, the way
    the code interacts with the rest of the system, and more. By having a fully tested
    section of code, you can now modify the architecture and be assured that this
    section still does what it is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how we define legacy code and the issues that
    legacy code can create. Legacy code can inhibit testing, but now you should know
    how to fight back against the legacy problem.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](part0418.html#CEKB40-d186949d2da74f5c95dd1712efae1195), *Unraveling
    a Mess*, we'll explore a rather extreme example of the types of things you might
    encounter in a legacy system. We'll explore safe refactoring and how to best unravel
    a mess into well structured, testable code.
  prefs: []
  type: TYPE_NORMAL
