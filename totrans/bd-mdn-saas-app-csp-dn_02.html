<html><head></head><body>
		<div><h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor056"/>2</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Building a Simple Demo Application</h1>
			<p>In this chapter, we will build a very simple demo application that will form the basis and framework of the SaaS application that we will build out in subsequent chapters. The purpose of this chapter is to get familiar with all of the tools and techniques that we will leverage later in this book, and in our careers as builders of SaaS applications! Once we have this foundational knowledge and framework app, it will be much easier to start to build more complex functionality.</p>
			<p>Before we start building the framework application, we must first discover and install the tools that we will use. Then, we’ll build out the skeleton application. Once we have that working, then we will start to think about what would be required to flesh this out into a real-world SaaS application!</p>
			<p>This chapter will give you a very brief look at a lot of different technologies. Please don’t feel overwhelmed! We are going to configure a dev environment from scratch, using Docker, and then we are going to initialize a database, API, and UI.</p>
			<p>This chapter uses a lot of different technologies, some of which you may not be familiar with. Don’t worry! Everything in this chapter is written out in detail, and anything that is skipped over quickly in this chapter will be explained fully in subsequent chapters.</p>
			<p>Developing SaaS applications, almost by definition, requires a wide array of different technologies. We will take a quick look at them all in this chapter, and then deepen our knowledge and understanding in subsequent chapters!</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Getting set up – installing the tools</li>
				<li>Building a simple example application</li>
				<li>Where do we go from here?</li>
			</ul>
			<p>By the end of the chapter, you’ll have built, installed, and configured your development environment, and you’ll have initialized all of the components required to build out a SaaS app. Hopefully, you will finish this chapter inspired to understand how we will make the most out of these tools and techniques!</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>All code from this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2</a>.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Setting up</h1>
			<p>In this <a id="_idIndexMarker064"/>section, we’ll cover the tools that I recommend using to work through the examples in this book. Please note that there are not really any specific tools for building a SaaS application – the typical set of developer tools that you are probably accustomed to will do the job. However, I will refer to a specific set of tools in this book, and so I’ll describe them in this section, explain my selection, and cover how to install and configure the tools.</p>
			<p>I am sure that any of the popular tools out there would be perfectly sufficient, so don’t feel like you <em class="italic">must</em> go with my selection, and feel free to use whatever you are most comfortable with! You should be able to adapt the examples to work with your tooling of choice.</p>
			<p>There are only two tools that need to be installed on your machine to follow along with the code that will be supplied in this book:</p>
			<ul>
				<li>Docker Desktop</li>
				<li>Visual Studio Code</li>
			</ul>
			<p>These tools are fairly stable, and it is likely the best choice to use the latest version. For reference, I am using Docker v20.10.17 and VS Code v1.71.2.</p>
			<p>These tools are chosen deliberately as they are available for all operating systems, they are free to use, and they will give us a consistent base on which to work through the code examples. These are the two tools that I find most useful in my day-to-day work as a software developer! They are typically the first two applications that I install when building a new developer machine.</p>
			<p>I’m going to use a neat trick with Docker to containerize the entire developer setup, which is why these two tools are the only ones that you need to install on your machine, and it is also the reason that I am confident that the example provided will work on any operating system.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Visual Studio Code</h2>
			<p>Visual Studio Code has<a id="_idIndexMarker065"/> gone from being a <em class="italic">lite</em> version of the full Visual Studio application to being an absolute workhorse for all manner of development work. With the availability of a massive range of extensions, it can be configured for just about any coding task, and then further modified to suit individual preferences.</p>
			<p>VSCode has <a id="_idIndexMarker066"/>become my IDE of choice for many different projects, but the real strength of a SaaS project is that it can be configured to support all of the different layers that will be built. You can add extensions for database development, API development, and UI development and build a highly customized developer environment that is specifically tailored to your project and your preferred tooling.</p>
			<p>Start by installing Visual Studio Code. This is done simply by clicking this URL and following the instructions for your operating system of choice: <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a></p>
			<p>When VSCode is installed, you will also need to install a couple of extensions.</p>
			<p>You will need three extensions for VS Code:</p>
			<ul>
				<li>Remote containers</li>
				<li>Remote WSL</li>
				<li>Docker</li>
			</ul>
			<p>The tags for the required extensions are as follows:</p>
			<pre class="source-code">
ms-vscode-remote.remote-containers
ms-vscode-remote.remote-wsl
ms-azuretools.vscode-docker</pre>
			<p>When VSCode is correctly configured, the <strong class="bold">EXTENSIONS</strong> pane should look like this:</p>
			<div><div><img src="img/B19343_Figure_2.1.jpg" alt="Figure 2.1 – Visual Studio Code with extensions configured"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Visual Studio Code with extensions configured</p>
			<p>We will use <a id="_idIndexMarker067"/>a number of other <a id="_idIndexMarker068"/>extensions specific to the project, but these will be installed in a dev container for ease of use – more on this later!</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Docker</h2>
			<p>Docker <a id="_idIndexMarker069"/>is a relatively recent<a id="_idIndexMarker070"/> addition to the developer toolbox, but it has quickly become completely invaluable for building and deploying applications. In more recent years, Docker has also become an incredible tool to encapsulate all of the setup required on a developer machine.</p>
			<p>Docker is a containerization tool. The principle at play is derived from shipping containers. Shipping containers are a standard size, which means that the machinery to move them and load them at the port and onto ships is completely standardized around the globe. Of course, what goes into the shipping containers can be anything from cars to cucumbers, but the infrastructure to move the containers is identical regardless.</p>
			<p>This principle is applied to software packaged with Docker. Whatever software tool is to be run is put inside a Docker container – analogous to a shipping container – and the Docker infrastructure is then used to run the container.</p>
			<p>You can<a id="_idIndexMarker071"/> consider a container to be a tiny virtual machine, or maybe an executable of its own. The important thing to keep in mind is that any piece of code, application, service, and so on that has been placed inside a <a id="_idIndexMarker072"/>Docker container will run on any computer with Docker installed. Furthermore, it will run (or not run!) in an identical way regardless of whether or not the host operating system is Windows, Mac, or Linux.</p>
			<p>This concept of containers is fantastic for shipping running software. I can now pull a Docker image for just about any software utility I can think of, and no matter what platform I am working with, I can execute that software.</p>
			<p>From a software provider’s point of view, the huge benefit is that they can be certain that their code will run correctly on my machine because it’s running against a standard platform – Docker!</p>
			<p>You may be wondering why this is important when it comes to setting up a developer environment.</p>
			<p>Dev containers are a relatively new but extremely powerful concept that can take all of the power that Docker has when running applications and apply that to developing applications. It is now possible to configure an entire dev environment – with all of the associated dependencies – and put all of that in a container!</p>
			<p>This may not be of the utmost importance for a more basic project, but a SaaS application is rarely a basic project.</p>
			<p>The nature of a SaaS application typically requires that many project-specific tools are installed on each developer machine. Worse, it is very common that specific versions of the tools will be required, which can often make the initial setup for new team members particularly painful. These tools can include the following:</p>
			<ul>
				<li>A database platform</li>
				<li>A framework, such as .NET – very often with specific version requirements</li>
				<li>Package management, such as NPM or NuGet</li>
				<li>A web server of some kind for the frontend</li>
				<li>A huge number of CLI tools</li>
				<li>And many other dev tools</li>
			</ul>
			<p>If your<a id="_idIndexMarker073"/> dev team supports multiple projects – as is often the case – this can become a real pain point.</p>
			<p>I try to use dev containers as much as I possibly can to wrap up dependencies, and I will use this technique in the examples in this book.</p>
			<p>Please note that <a id="_idIndexMarker074"/>Docker is an enormous topic in itself, and it is out of the scope of this book to cover it in any sort of depth. I will cover just enough to get familiar with the techniques that I am using, and leave it up to the reader to do more of a deep dive into all things Docker!</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Dev containers</h2>
			<p>As<a id="_idIndexMarker075"/> developers, we all have our favorite set of tools that we work with on a day-to-day basis. This will start with our choice of operating system, and from there we will pick IDEs, database platforms, frontend frameworks, and all of the associated tooling.</p>
			<p>This<a id="_idIndexMarker076"/> huge variety of systems, tools, platforms, and frameworks provides a challenge for the author of a book describing how to build a SaaS platform…</p>
			<p>In order for the tutorials in this book to appeal to the broadest range of developers possible, I am going to make use of a relatively new concept known as <strong class="bold">Dev Containers</strong>. This allows us to configure a Docker container to do all of our development. This will give you a consistent platform with which to work and will ensure that all of the examples that are provided will work on literally any machine.</p>
			<p>Making use of dev containers gives us a completely consistent development platform to work with so that we can be sure that all readers of this book will be able to run the example code that is provided, but there is a small configuration overhead to get started.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>What is a dev container?</h2>
			<p>Continuing <a id="_idIndexMarker077"/>with the analogy of a shipping container, a dev container is simply a wrapper around the myriad of developer tools that you will use when working on the code in this book.</p>
			<p>Broadly speaking, the tools and services that will be required are the following:</p>
			<ul>
				<li>A database platform</li>
				<li>The .NET SDK</li>
				<li>Extensions to support database development</li>
				<li>Extensions to support API development</li>
				<li>Extensions to support frontend and Blazor development</li>
			</ul>
			<p>All of the above will be packaged up in a dev container.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Configuring the Docker containers</h2>
			<p>The <a id="_idIndexMarker078"/>code for<a id="_idIndexMarker079"/> this first example is available at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2</a>. Either clone the repo or follow through with this example setup.</p>
			<p>If you are following along, then start by creating a new folder that will form the root of your project, and then open that folder in VSCode. This is a completely blank canvas, but by the end of this chapter, we will have the skeleton framework for a functioning SaaS application.</p>
			<p>Start by creating the following folder and file structure:</p>
			<div><div><img src="img/B19343_Figure_2.2.jpg" alt="Figure 2.2 – Expected folder structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Expected folder structure</p>
			<p>With the folder structure created, we can now start to fill out these files. We’ll start with the Dockerfile in the <code>dev-env</code> folder. This will be used to configure the developer environment and will contain the instructions to install the tools that will be used to build the application.</p>
			<h3>Dockerfile</h3>
			<p>Open<a id="_idIndexMarker080"/> the file:</p>
			<pre class="source-code">
docker/dev-env/Dockerfile</pre>
			<p>And paste in the following:</p>
			<pre class="source-code">
# [Choice] .NET version: 7.0, 6.0, 5.0, 3.1, 6.0-bullseye, 5.0-bullseye, 3.1-bullseye, 6.0-focal, 5.0-focal, 3.1-focal
ARG VARIANT="7.0"
FROM mcr.microsoft.com/vscode/devcontainers/dotnet:0-${VARIANT}
# [Choice] Node.js version: none, lts/*, 16, 14, 12, 10
ARG NODE_VERSION="none"
RUN if [ "${NODE_VERSION}" != "none" ]; then su vscode -c "umask 0002 &amp;&amp; . /usr/local/share/nvm/nvm.sh &amp;&amp; nvm install ${NODE_VERSION} 2&gt;&amp;1"; fi
# [Optional] Uncomment this section to install additional OS packages.
RUN apt-get update &amp;&amp; \
    export DEBIAN_FRONTEND=noninteractive &amp;&amp; \
    apt-get -qy full-upgrade &amp;&amp; \
    apt-get install -qy curl &amp;&amp; \
    apt-get -y install --no-install-recommends vim &amp;&amp; \
    curl -sSL https://get.docker.com/ | sh
RUN dotnet tool install -g dotnet-ef
ENV PATH $PATH:/root/.dotnet/tools
# configure for https
RUN dotnet dev-certs https</pre>
			<p>This<a id="_idIndexMarker081"/> configures the developer environment to facilitate .NET application development. Let’s go through this in detail. The first line determines the version of .NET that will be used:</p>
			<pre class="source-code">
ARG VARIANT="7.0"</pre>
			<p>We are using 7.0, which is the latest version at the time of writing.</p>
			<p>Next, the version of Node is configured:</p>
			<pre class="source-code">
ARG NODE_VERSION="none"</pre>
			<p>No node version is installed. It is often useful to enable node or npm, but they are not needed at present.</p>
			<p>The next command is used to install any packages or tools that you may want to use:</p>
			<pre class="source-code">
RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \
&amp;&amp; apt-get -y install --no-install-recommends vim</pre>
			<p>This command updates the package manager and installs the Vim CLI tool, which we will use later.</p>
			<p>The above has all been a “standard” configuration of the environment. Next, we will add some bespoke customizations that will allow us to make use of Entity Framework:</p>
			<pre class="source-code">
RUN dotnet tool install -g dotnet-ef</pre>
			<p>This command <a id="_idIndexMarker082"/>installs the .NET <strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) tools that we will use to interact with the database.</p>
			<p>Finally, we will add the dot net tools to the <code>path</code> variable so that we are able to make use of them from the command line:</p>
			<pre class="source-code">
ENV PATH $PATH:/root/.dotnet/tools</pre>
			<h3>Sqlserver.env</h3>
			<p>This<a id="_idIndexMarker083"/> file simply sets some environment variables for the SQL Server instance that we will spin up shortly. Copy in the following:</p>
			<pre class="source-code">
ACCEPT_EULA="Y"
SA_PASSWORD="Password1"</pre>
			<p>It should go without saying that passwords should never be used in any environment other than this example! Also, note that checking in passwords is extremely bad practice, and should not be done when working on a production application. We will remedy this when we talk about security in <a href="B19343_08.xhtml#_idTextAnchor200"><em class="italic">Chapter 8</em></a><em class="italic">.</em></p>
			<h3>Docker-compose.yaml</h3>
			<p>This is<a id="_idIndexMarker084"/> where things get interesting. Docker Compose is a tool that lets us use multiple containers at the same time. It is a container orchestration tool!</p>
			<p>Paste the following into the <code>docker-compose</code> file:</p>
			<pre class="source-code">
version: '3.4'
services:
  sql_server:
    container_name: sqlserver
    image: "mcr.microsoft.com/mssql/server:2022-latest"
    ports:
      - "9876:1433"
    volumes:
      - habit-db-volume:/var/lib/mssqlql/data/
    env_file:
      - sqlserver/sqlserver.env
  dev-env:
    container_name: dev-env
    build:
      context: ./dev-env
    volumes:
      - "..:/workspace"
    stdin_open: true # docker run -i
    tty: true # docker run -t
volumes:
  habit-db-volume: null</pre>
			<p>The <a id="_idIndexMarker085"/>preceding commands for Docker Compose tie everything that we have done together. With this script, we can start up a set of Docker containers that allow us to build the API, and the UI, and also interact with a database – all without having to install anything directly on the host machine!</p>
			<p>To recap: we have constructed a container called <code>dev-env</code> that is specific to our requirements. We have also provisioned a container with an instance of SQL Server 2022 running in it that will serve as our database platform.</p>
			<h3>Running the containers</h3>
			<p>That is all of the <a id="_idIndexMarker086"/>Docker-specific configurations. Now we will run the containers and start to interact.</p>
			<p>We have built a Docker-based environment – now it’s time to start it up. To do this, open VSCode, open a new terminal, and enter the following:</p>
			<pre class="source-code">
cd .\docker\
docker compose up</pre>
			<p>Your terminal should look like the following:</p>
			<div><div><img src="img/B19343_Figure_2.3.jpg" alt="Figure 2.3 – Expected output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Expected output</p>
			<p>This can <a id="_idIndexMarker087"/>take a while the first time you run this command, but it is significantly faster in subsequent uses. This command will start up the services that are described in the <code>docker compose</code> file. Namely, a SQL Server instance, and the developer environment that we configured with .NET 6.0 and Entity Framework.</p>
			<p>With the above, we have created a container with .NET and Entity Framework installed. You can convince yourself that we have actually achieved that by trying the following. Open a new terminal in VSCode and enter the following to <code>exec</code> into the dev-env container:</p>
			<pre class="source-code">
docker exec -it dev-env /bin/bash</pre>
			<p>The <code>exec</code> command allows interactions with an already running container through the terminal.</p>
			<p>Running the preceding command will open an interactive terminal in the <code>dev-env</code> Docker container where we can check to see whether the .NET and EF tools are correctly installed by typing the following into the console that was opened by the preceding <code>exec</code> command:</p>
			<pre class="source-code">
dotnet –-version
dotnet-ef --version</pre>
			<p>The preceding commands should return the following:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19343_Figure_2.4.jpg" alt="Figure 2.4 – Expected terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Expected terminal output</p>
			<p>Next, we <a id="_idIndexMarker088"/>can do something similar to ensure the SQL Server container is running. Again, open a new terminal in VSCode and enter the following:</p>
			<pre class="source-code">
docker exec -it sqlserver /bin/bash</pre>
			<p>Again, this will open another interactive terminal in the <code>sqlserver</code> container. You can convince yourself of this by typing the following:</p>
			<pre class="source-code">
/opt/mssql-tools/bin/sqlcmd -S localhost -U SA</pre>
			<p>And when prompted, enter the password from the <code>sqlserver.env</code> file (<code>Password1</code>) to enter the SQL Server command-line interface. You can do simple checks on the database platform, such as checking the version:</p>
			<div><div><img src="img/B19343_Figure_2.5.jpg" alt="Figure 2.5 – Checking the version"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Checking the version</p>
			<p>At this point, we have done all of the Docker container setups, but the only way that we can interact with our environments is to use the command line, and these days, that is not really acceptable! Thankfully, Visual Studio Code has a neat trick up its sleeve!</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Configuring dev containers in VSCode</h2>
			<p>You <a id="_idIndexMarker089"/>will remember that we installed the <code>Remote Containers</code> extension for VSCode. This will allow us to open an instance of VSCode that makes use of the Docker containers that we have set up previously. This will require a little bit of additional configuration, but once set up, it will “just work” for the remainder of the project!</p>
			<p>Start by<a id="_idIndexMarker090"/> creating a folder called <code>dev-env</code> in the project root:</p>
			<pre class="source-code">
.devcontainer</pre>
			<p>This is where VSCode will look to get the configuration.</p>
			<p>In this folder, create a file called <code>devcontainer.json</code>. Your folder structure should look like this:</p>
			<div><div><img src="img/B19343_Figure_2.6.jpg" alt="Figure 2.6 – Folder structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Folder structure</p>
			<p>In the <code>devcontiner.json</code> file, paste the following:</p>
			<pre class="source-code">
{
    "name": "SaaS Book",
    "dockerComposeFile": ["../docker/docker-compose.yaml"],
    "service": "dev-env",
    "workspaceFolder": "/workspace",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-dotnettools.csharp",
                "shardulm94.trailing-spaces",
                "mikestead.dotenv",
                "fernandoescolar.vscode-solution-explorer",
                "jmrog.vscode-nuget-package-manager",
                "patcx.vscode-nuget-gallery",
                "pkief.material-icon-theme",
                "ms-mssql.mssql",
                "humao.rest-client",
                "rangav.vscode-thunder-client",
                "formulahendry.dotnet-test-explorer",
                "kevin-chatham.aspnetcorerazor-html-css-
                  class-completion",
                "syncfusioninc.blazor-vscode-extensions",
                "ms-dotnettools.vscode-dotnet-runtime",
                "ms-dotnettools.blazorwasm-companion"
                ]
          }
    },
    "remoteUser": "root"
}</pre>
			<p>Let’s go through this line by line. The following line of code tells VSCode where to look for the <code>docker compose</code> file. This is the file that we created previously, which configures the two Docker containers:</p>
			<pre class="source-code">
"dockerComposeFile": ["../docker/docker-compose.yaml"],</pre>
			<p>The following line simply tells VSCode that the container named <code>dev-env</code> is the primary container:</p>
			<pre class="source-code">
"service": "dev-env",</pre>
			<p>The next line defines a working folder inside the container – more on this shortly:</p>
			<pre class="source-code">
"workspaceFolder": "/workspace",</pre>
			<p>The<a id="_idIndexMarker091"/> following is quite clever including the dev container configuration. This section allows us to define which extensions we want to have available to us when we start to work in the dev container. I have listed three extensions to get us started, but this list will grow as the project gains complexity:</p>
			<pre class="source-code">
"extensions": [ … ],</pre>
			<p>This is a particularly clever addition from Microsoft because this allows the VSCode configuration to exist as JSON within the project. This file is checked into the repo and moved with the code, meaning that any time a new team member pulls this repo, they will<a id="_idIndexMarker092"/> immediately have a fully configured editor that is specific to the project.</p>
			<p>We have all become familiar with <em class="italic">infrastructure as code</em> in recent years. Using a dev container allows you to configure the <em class="italic">developer environment as code</em>. Doing this makes it incredibly easy to onboard new team members, and also means the end of <em class="italic">well, it works on my machine</em>. Using this technique means that everyone is working on a completely consistent platform, regardless of the physical hardware, the operating system choice, or the specific version of .NET or Node.</p>
			<p>This is a huge win for developing SaaS applications, given the complex and often arduous route to getting a new team member up and running.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Starting the environment</h2>
			<p>That is the <a id="_idIndexMarker093"/>end of the configuration. I hope that we are all now working on a consistent and predictable platform, and will have no trouble following along with the examples in this book!</p>
			<p>To start the environment in Docker, hit <em class="italic">F1</em> to open the command menu, and search for <code>Remote-Containers: Rebuild and Reopen </code><code>in Container</code>.</p>
			<p>You will see the options in <em class="italic">Figure 2</em><em class="italic">.7</em> appear. Select the first one and hi<a id="_idTextAnchor067"/>t <em class="italic">Enter</em> to continue.</p>
			<div><div><img src="img/B19343_Figure_2.7.jpg" alt="Figure 2.7 – Rebuild and Reopen in Container"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Rebuild and Reopen in Container</p>
			<p>This will close the current instance of VSCode, and reopen a new instance that is operating out of the <code>dev-env</code> container that was configured previously. Note that this can take some time the first time you do it, but it is faster in subsequent uses.</p>
			<p>You will notice a few differences! First of all, look in the bottom-left corner, and you will see that you are running in a dev container called <code>SaaS Book</code>:</p>
			<div><div><img src="img/B19343_Icon.jpg" alt=""/>
				</div>
			</div>
			<p>If you click to view the installed extensions, you will see a separate pane that shows the extensions that are installed in this instance of VSCode match the extensions specified in the <code>devcontainers.json</code> file. This list will start to grow significantly as the project takes shape throughout the course of this book.</p>
			<p><em class="italic">Figure 2</em><em class="italic">.8</em> shows some of the extensions that are installed<a id="_idTextAnchor068"/> in the container:</p>
			<div><div><img src="img/B19343_Figure_2.8.jpg" alt="Figure 2.8 – Installed extensions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Installed extensions</p>
			<p>If you <a id="_idIndexMarker094"/>open a terminal, you will also notice that this is a Linux environment. You can convince yourself of that by checking the version by running the following code:</p>
			<pre class="source-code">
cat /etc/os-release</pre>
			<p>You’ll see the following output:</p>
			<div><div><img src="img/B19343_Figure_2.9.jpg" alt="Figure 2.9 – Output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Output</p>
			<p>This<a id="_idIndexMarker095"/> shows that we are in a Debian environment. Notice also that we are working in a folder called <code>workspace</code>, which is what was configured in the <code>devcontainer.json</code> file previously. This is configurable as per your preferences.</p>
			<p>To further convince ourselves that this is indeed the <code>dev-env</code> container that we configured earlier, you can check the .NET, and the Entity Framework versions again in the terminal in VSCode:</p>
			<pre class="source-code">
dotnet –-version
dotnet-ef --version</pre>
			<p>You will see the following output:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19343_Figure_2.10.jpg" alt="Figure 2.10 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Terminal output</p>
			<p>That is the environment configured to the extent that is currently required. Let’s recap:</p>
			<ul>
				<li>We have a container that has the .NET SDK installed, ready to use to build any kind of .NET applications.</li>
				<li>The same container has Entity Framework command-line tools installed so that we can use Entity Framework to build and interact with a database. You will recall that we have installed Entity Framework in the Dockerfile.</li>
				<li>We have a separate container running SQL Server, which hosts the database that we can interact with. It is worth noting that we have not installed SQL Server itself on the host machine. We have access to the database via a Docker container. You will see more of this in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a> and <a href="B19343_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>.</li>
			</ul>
			<p>This is now the basis of a developer machine that can be used to build SaaS applications, and we have achieved this without ever having to install any of these tools directly on the machine that you are working on – everything is packaged up in Docker containers. This configuration exists as code, and as such it moves with the repo. Any developer who clones this repository locally will immediately have access to all of the project-specific tools and configurations.</p>
			<p>As we progress through this project, this setup will become more complex. It will grow as the project grows. But this is sufficient for now, so we will leave it here and start to piece together a very basic application.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Configuring VSCode</h2>
			<p>At this <a id="_idIndexMarker096"/>early stage, there is not much config required, as we do not really have any application-specific code. However, we’ll lay the groundwork here. Open a terminal, and enter the following:</p>
			<pre class="source-code">
<strong class="bold">mkdir .vscode; \</strong>
<strong class="bold">cd .vscode; \</strong>
<strong class="bold">touch launch.json; \</strong>
<strong class="bold">touch settings.json; \</strong>
<strong class="bold">touch tasks.json; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>Add the following into <code>settings.json</code>:</p>
			<pre class="source-code">
{
    "thunder-client.saveToWorkspace": true,
    "thunder-client.workspaceRelativePath": ".thunder-client"
}</pre>
			<p>The preceding <a id="_idIndexMarker097"/>is some config for an HTTP testing tool that we will make use of in <a href="B19343_05.xhtml#_idTextAnchor116"><em class="italic">Chapter 5</em></a>. We don’t need to put anything into <code>launch.json</code> or <code>tasks.json</code> yet.</p>
			<p>That should be all the configuration that is required for the time being, so we can move on.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Exiting the environment</h2>
			<p>Getting <a id="_idIndexMarker098"/>out of the dev container environment and back to your host is straightforward. Simply hit <em class="italic">F1</em> again and search for <code>Reopen </code><code>Folder Locally</code>:</p>
			<div><div><img src="img/B19343_Figure_2.11.jpg" alt="Figure 2.11 – Return to the local workspace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Return to the local workspace</p>
			<p>This will quickly return you to the host. You will no longer see the indicator in the lower-left corner that you are in a dev container, and the terminal will again connect directly to the host machine.</p>
			<p>We have achieved a lot in this section, and we have set ourselves up to start working in a Dockerized environment. This may seem like a bit more work than simply starting to write code on your local machine, but I hope that as we proceed through this book together, you will start to see the value in taking the time to build out this environment right at the start of the project!</p>
			<p>In the next section, we’ll really start to build out the application and start to show the power of the preceding techniques.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Building out a sample application</h1>
			<p>In this section, we’ll use the tools that we have just installed to create a very basic wireframe for a SaaS application. At this point, this will simply be a <a id="_idIndexMarker099"/>skeleton application that we can build out much more fully in subsequent chapters. However, this will introduce us to all of the different tools that we will be using.</p>
			<p>The sample application that we will build as we work through this book will be an application to track a habit – something that you may like to try to do every day – such as learning a new language, or writing a few pages of a book in order to stay up to date with your publishing deadlines! I hope that this is something that you may be able to make use of after you have finished working through this book!</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Database technologies</h2>
			<p>We <a id="_idIndexMarker100"/>will start with the database. We are using SQL Server as the database platform – this is a book based on Microsoft technologies, so we will stick with them as much as possible! However, other database platforms <a id="_idIndexMarker101"/>are available, and can easily be used. The Docker-based setup provided above makes it very easy to experiment with other database platforms. You can replace the SQL Server container with a Postgres container and see if everything still works!</p>
			<p>The database and the database platform are often a source of some pain when getting developers onboarded and up to speed on a project. This is particularly evident in a SaaS project and is only partly mitigated using the Dockerized solution above.</p>
			<p>It is very common these days to <a id="_idIndexMarker102"/>make use of an <strong class="bold">Object Relational Mapper</strong> (<strong class="bold">ORM</strong>) to manage the interactions between the code and the database, and this is a pattern that I will adhere to in this book. I will be using Entity Framework for all interactions initially, but note that when we discuss performance and scaling, I will touch on other techniques that can be used when database performance is paramount.</p>
			<p>I will make use of Entity Framework’s “code-first” approach to define the database and populate it with some initial startup data, and I’ll make use of the migrations to keep the database up to date. This will come in very handy in later chapters when we talk about testing with a database, and also when we look at CI/CD and how to update a production database.</p>
			<h3>Creating the database</h3>
			<p>Make <a id="_idIndexMarker103"/>sure that you are in the dev container (check the bottom left of VSCode) and open a new terminal. Use the terminal to create a new .NET class library called <code>GoodHabits.Database</code> with the following code:</p>
			<pre class="source-code">
dotnet new classlib --name GoodHabits.Database;</pre>
			<p>You should see the folder appear in File Explorer, and the following output in the terminal:</p>
			<div><div><img src="img/B19343_Figure_2.12.jpg" alt="Figure 2.12 – Create the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Create the database</p>
			<p>Before we can use this project to interact with the database, we need to add a few NuGet packages. So, again, in the terminal, enter the following:</p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.Database; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Design; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Analyzers; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Relational; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.SqlServer; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Tools; \</strong>
<strong class="bold">touch GoodHabitsDbContext.cs; \</strong>
<strong class="bold">rm Class1.cs; \</strong>
<strong class="bold">touch SeedData.cs; \</strong>
<strong class="bold">mkdir Entities; \</strong>
<strong class="bold">cd Entities; \</strong>
<strong class="bold">touch Habit.cs; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>With the <a id="_idIndexMarker104"/>preceding, we have instructed the .NET CLI to add all of the required NuGet packages to facilitate interactions with the database. We have also added a <code>GoodHabitsDbContext</code> class, a <code>SeedData</code> class, and a <code>Habit</code> class. We’ll now add some basic setup into these three files that will give us a foundation to work on in later chapters.</p>
			<p>Enter the following code into the <code>Habits.cs</code> file:</p>
			<pre class="source-code">
namespace GoodHabits.Database.Entities;
public class Habit
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
  public string Description { get; set; } = default!;
}</pre>
			<p>The above is a very straightforward entity class representing a habit that a user of the app may want to embed into their day-to-day lives.</p>
			<p>Next, add some dummy data, by adding the following code to the <code>SeedData.cs</code> file:</p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using Microsoft.EntityFrameworkCore;
public static class SeedData
{
    public static void Seed(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;Habit&gt;().HasData(
            new Habit { Id = 100, Name = "Learn French",
              Description = "Become a francophone" },
            new Habit { Id = 101, Name = "Run a marathon",
              Description = "Get really fit" },
            new Habit { Id = 102, Name = "Write every day",
              Description = "Finish your book project"  }
        );
    }
}</pre>
			<p>Now create a <code>DbContext</code> by entering the following code into the <code>GoodHabitsDbContext.cs</code> file:</p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database;
public class GoodHabitsDbContext : DbContext
{
    public DbSet&lt;Habit&gt;? Habits { get; set; }
    protected override void
      OnConfiguring(DbContextOptionsBuilder options)
       =&gt; options.UseSqlServer("Server=
         sqlserver;Database=GoodHabitsDatabase;User
         Id=sa;Password=Password1 ;Integrated
         Security=false;TrustServerCertificate=true;");
    protected override void OnModelCreating(ModelBuilder
      modelBuilder) =&gt; SeedData.Seed(modelBuilder);
}</pre>
			<p>This <a id="_idIndexMarker105"/>does a few things. Firstly, we define a <code>DbSet</code>. This is mapped onto a table in the database.</p>
			<p>Next, we hardcode the database connection string. Of course, it is bad practice to hardcode the connection string, and doubly bad to have the password there in plain text. We will correct these errors in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, but this is sufficient to prove that we are connected to the database.</p>
			<p>With this setup done, we can test this out and see whether we can migrate this information into the SQL Server database that we have running in a second Docker container.</p>
			<p>To do this, let’s start by using Entity Framework to create an initial migration. Enter the following into the terminal to generate the initial migration:</p>
			<pre class="source-code">
<strong class="bold">dotnet-ef migrations add InitialSetup;</strong></pre>
			<p>You will see a <code>Migrations</code> folder has appeared in File Explorer with the <code>InitialSetup</code> migration modeled as a class. You don’t have to worry too much about this at present, but it’s worth taking the time to have a look at this class.</p>
			<p>Then <a id="_idIndexMarker106"/>enter the following to deploy the migration to the SQL Server database:</p>
			<pre class="source-code">
<strong class="bold">dotnet-ef database update;</strong></pre>
			<p>This sends the migration to the database.</p>
			<p>And that is it for now. We have configured a basic database using Entity Framework in “code-first” mode, and have sent the first migration to the database.</p>
			<h3>How do we know that this has worked?</h3>
			<p>It’s one thing<a id="_idIndexMarker107"/> to understand that the command has been executed successfully, but seeing is believing, and we need to dip into the database to really be sure that all of this is actually working as expected.</p>
			<p>You will notice that when we defined the extensions that we wanted to be installed in the dev container, we specified the following extension should be included:</p>
			<pre class="source-code">
"ms-mssql.mssql",</pre>
			<p>This is an extension for VSCode from Microsoft that allows us to query a SQL server database directly from VSCode. Click on the extension and we will add a new connection, with the following information added:</p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Parameter</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Notes</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Hostname</p>
						</td>
						<td class="No-Table-Style">
							<p><code>sqlerver</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic" lang="en-US" xml:lang="en-US">This is the name of the Docker container that we configured to run the SQL Server </em><em class="italic" lang="en-US" xml:lang="en-US">2022 instance</em></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Database to connect</p>
						</td>
						<td class="No-Table-Style">
							<p><code>GoodHabitsDatabase</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic" lang="en-US" xml:lang="en-US">This was defined i</em><em class="italic">n</em><em class="italic" lang="en-US" xml:lang="en-US"> the </em><code>DbContext</code><em class="italic" lang="en-US" xml:lang="en-US"> class on the </em><em class="italic" lang="en-US" xml:lang="en-US">connection string</em></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Authentication Type</p>
						</td>
						<td class="No-Table-Style">
							<p><code>SQL Login</code></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>User name</p>
						</td>
						<td class="No-Table-Style">
							<p><code>sa</code></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Password</p>
						</td>
						<td class="No-Table-Style">
							<p><code>Password1</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic" lang="en-US" xml:lang="en-US">Defined </em><em class="italic" lang="en-US" xml:lang="en-US">in</em> <code>sqlserver.env</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Save Password</p>
						</td>
						<td class="No-Table-Style">
							<p><code>Yes</code></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Display Name</p>
						</td>
						<td class="No-Table-Style">
							<p><code>GoodHabits</code></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
				</tbody>
			</table>
			<p>You may need to okay a security popup.</p>
			<p>With the <a id="_idIndexMarker108"/>above correctly entered, you should now get a view of the database, as follows:</p>
			<div><div><img src="img/B19343_Figure_2.13.jpg" alt="Figure 2.13 – Browse the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Browse the database</p>
			<p>You will note that the <code>Habits</code> table that we have defined as a <code>DbSet</code> in the <code>DbContext</code> file has been successfully migrated to the SQL Server database. You can right-click on the table named <code>dbo.Habits</code> and then click on <strong class="bold">Select to 1000</strong> to see the contents.</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19343_Figure_2.14.jpg" alt="Figure 2.14 – Data stored in the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Data stored in the database</p>
			<p>Again, you <a id="_idIndexMarker109"/>will see that the information that we have added in the <code>DbContext</code> file is present and correct in the database.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>API technology</h2>
			<p>Next, we will<a id="_idIndexMarker110"/> move on to the API. The purpose <a id="_idIndexMarker111"/>of the API is to facilitate the storage and retrieval of information from the database by the users and also to do any required data processing.</p>
			<p>There are many different technologies that are available with which to build an API. This book is focused on Microsoft technologies, so we will use the .NET Web API framework and the C# language. However, the tools and techniques described could easily be adapted to make use of different technologies.</p>
			<p>Additionally, there are many different ideas about how best to structure an API, and there is no <em class="italic">one size fits all</em> approach that will work with every project out there. I have decided that I will use the RESTful paradigm for the examples in this book, but again, the concepts and ideas that are presented should copy over very well if your project is using some other structure, such as GraphQL.</p>
			<p>The nature of a SaaS application is such that there are a huge number of choices to make when the project is getting started. This remains true even when the project is a demo application in a book!</p>
			<h3>Creating the HabitService API</h3>
			<p>Making sure that<a id="_idIndexMarker112"/> you are in the dev container environment, and are in the root of the project (the <code>workspace</code> folder), create a new <code>webapi</code> project with the following:</p>
			<pre class="source-code">
dotnet new webapi --name GoodHabits.HabitService; \
cd GoodHabits.HabitService; \
dotnet add reference ../GoodHabits.Database/GoodHabits.Database.csproj; \
dotnet add package Microsoft.EntityFrameworkCore.Design; \
cd ..;</pre>
			<p>The .NET CLI does a lot of work setting up the API. We need to make a change to the <code>launchSettings.json</code> file. Open the <code>Properties</code> folder and replace the default launch settings with the following:</p>
			<pre class="source-code">
{
  "$schema":
    "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "HabitService": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5100",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}</pre>
			<p>The most important thing to note is that we will be running the <code>HabitService</code> on port <code>5100</code>. This is important to keep track of when we start to look at microservices in <a href="B19343_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>.</p>
			<p>Out of the box, the default web API comes with the Weather API, which you can take a look at to get an idea of how these endpoints are configured. We can test this by entering the following into the terminal:</p>
			<pre class="source-code">
dotnet run</pre>
			<p>This will start the application running on the port that is specified in <code>launchSettings.json</code> – port <code>5100</code> in this case.</p>
			<div><div><img src="img/B19343_Figure_2.15.jpg" alt="Figure 2.15 – Console output indicating success"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Console output indicating success</p>
			<p>You can check to see whether the application is running by going to the following URL in your browser (remember to check the port number!): <a href="http://127.0.0.1:5100/swagger/index.html">http://127.0.0.1:5100/swagger/index.html</a></p>
			<p>Note that you may get some HTTPS warnings from your browser, as follows:</p>
			<div><div><img src="img/B19343_Figure_2.16.jpg" alt="Figure 2.16 – The GoodHabits API"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – The GoodHabits API</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>User interface technology</h2>
			<p>Finally, we <a id="_idIndexMarker113"/>need a user interface <a id="_idIndexMarker114"/>on which to display the information.</p>
			<p>As I have pointed out for both the database and the API, there are many different UI technologies, and the underlying tools and techniques that you will learn in this book can be applied to any one of them. Often, the best technology to use in any given situation is the one that you are most comfortable with.</p>
			<p>This is a Microsoft-centric book aimed at existing .NET developers, so I will use Blazor for the examples that are <a id="_idIndexMarker115"/>provided. If you prefer Angular, React, Vue, or any of the other millions of UI frameworks that are out there, please don’t be put off. In fact, adapting these examples <a id="_idIndexMarker116"/>to work with your UI of choice would be an excellent exercise to further your understanding of the concepts that we will cover in this book.</p>
			<h3>Creating the UI</h3>
			<p>Creating a <a id="_idIndexMarker117"/>simple demo Blazor UI is straightforward with the CLI tools provided by Microsoft. Enter the following commands into the terminal to create the UI:</p>
			<pre class="source-code">
<strong class="bold">dotnet new blazorwasm -o GoodHabits.Client;</strong></pre>
			<p>This follows the same pattern that we used to create the HabitServer project. And, like the HabitServer project, we will need to modify the launch configuration in <code>launchSettings.json</code>. Again, look in the <code>Properties</code> folder, and overwrite the contents with this:</p>
			<pre class="source-code">
{
  "profiles": {
    "GoodHabitsClient": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "inspectUri": "{wsProtocol}://{url.hostname}:
        {url.port}/_framework/debug/ws-
        proxy?browser={browserInspectUri}",
      "applicationUrl": "http://localhost:5900",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}</pre>
			<p>Again, take <a id="_idIndexMarker118"/>note of the port that the client is running on. We will use <code>5900</code> for the client.</p>
			<p>With the config done, you can now start the client by typing <code>dotnet run</code> into the console.</p>
			<p>Again, you will see that the <code>Client</code> app is running on the ports specified in <code>launchSettings.json</code>, which should be port <code>5900</code>:</p>
			<div><div><img src="img/B19343_Figure_2.17.jpg" alt="Figure 2.17 – Console output indicating success"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Console output indicating success</p>
			<p>Again, as per the API, you can follow this link in your browser to see the Blazor app running:</p>
			<div><div><img src="img/B19343_Figure_2.18.jpg" alt="Figure 2.18 – Hello, world!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Hello, world!</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Starting the application</h2>
			<p>Currently, we only <a id="_idIndexMarker119"/>have two projects to run, the HabitService API and the Blazor client. So, we can fairly easily start the whole project by typing <code>dotnet run</code> twice. As we build on this application, it will become more and more complex, and harder to run in this way. So, we’ll create build and launch configurations to tell VSCode how to start the application.</p>
			<p>We have already created the config files for this in the <code>.</code><code>vscode</code> folder.</p>
			<p>Start by opening <code>tasks.json</code>, and copy in the following:</p>
			<pre class="source-code">
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "build-client",
            "type": "shell",
            "command": "dotnet",
            "args": [
                "build",
                "${workspaceFolder}/GoodHabits.Client/
                  GoodHabits.Client.csproj"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "label": "build-habit-service",
            "type": "shell",
            "command": "dotnet",
            "args": [
                "build",
                "${workspaceFolder}/GoodHabits.HabitService
                  /GoodHabits.HabitService.csproj"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
    ]
}</pre>
			<p>You can see in <a id="_idIndexMarker120"/>the above JSON that two tasks are defined to build the client and the habit service.</p>
			<p>Next, modify <code>launch.json</code> by adding<a id="_idIndexMarker121"/> the following JSON config:</p>
			<pre class="source-code">
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "RunClient",
            "type": "blazorwasm",
            "request": "launch",
            "preLaunchTask": "build-client",
            "cwd": "${workspaceFolder}/GoodHabits.Client",
            "url": "https://localhost:5900"
        },
        {
            "name": "RunHabitService",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build-habit-service",
            "program": "${workspaceFolder}/
              GoodHabits.HabitService/bin/Debug/net7.0/
              GoodHabits.HabitService.dll",
            "args": [],
            "cwd":
              "${workspaceFolder}/GoodHabits.HabitService",
            "stopAtEntry": false,
            "console": "integratedTerminal"
        },
    ],
    "compounds": [
        {
            "name": "Run All",
            "configurations": [
                "RunHabitService",
                "RunClient"
            ]
        }
    ]
}</pre>
			<p>Again, you <a id="_idIndexMarker122"/>can see that two configurations are added to run the individual project. You can also see nearer the bottom that there is a <code>compounds launch</code> command set to run all of the projects.</p>
			<p>You can test this out by pressing <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">D</em> to enter the <strong class="bold">Run and Debug</strong> menu, selecting <strong class="bold">Run</strong> All from the dropdown, and pressing the play button.</p>
			<p>You will see that this starts the API and the client at the same time. This will be very handy as the number of projects starts to grow!</p>
			<p>Note that you can also hit <em class="italic">F5</em> to start the application as well.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Adding a solution file</h2>
			<p>There is one<a id="_idIndexMarker123"/> last small piece of setup to do before we move on to really building out the application, and that is to add a solution file. This is not strictly necessary, but it is commonly done when working with .NET projects and will allow us to easily build, clean, and test the projects with a single command.</p>
			<p>To add a solution file, simply navigate to the project root, and run the following:</p>
			<pre class="source-code">
dotnet new sln --name GoodHabits; \
dotnet sln add ./GoodHabits.Client/GoodHabits.Client.csproj; \
dotnet sln add ./GoodHabits.HabitService/GoodHabits.HabitService.csproj; \
dotnet sln add ./GoodHabits.Database/GoodHabits.Database.csproj;</pre>
			<p>This simply <a id="_idIndexMarker124"/>adds a solution file and references the three projects that we have created.</p>
			<p>And that is the final piece of setup work to do – now we can progress to building the application.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>Where do we go from here?</h1>
			<p>We have done a lot of work in this chapter, but we haven’t really started to build the application yet. We have instead focused on choosing the tools that we will use and building a development environment around those tools. We now have the outline of a SaaS application that we can continue to work with as we move through this book.</p>
			<p>Taking the time at the start of the project to select the correct tools is an important step of any SaaS project, and it should not be skipped.</p>
			<p>Being successful in developing any application requires that some thought is put into the technologies and frameworks that will be used, and also the tooling that will be used. In this chapter, we have set ourselves up very well to be able to get our hands dirty and try things out as we explore the concepts that are required to build a SaaS application.</p>
			<p>The following chapters will start to introduce a lot more SaaS-specific considerations, and we will use this outline app to demonstrate them.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Summary</h1>
			<p>In this chapter, we have briefly touched on a lot of different tools, topics, and techniques. This is the nature of developing SaaS applications – please don’t feel overwhelmed! To get started, we installed the tools that we need to work with, namely Docker Desktop and Visual Studio Code. This is quite a light set of tools for a SaaS project. But as you have seen, we used Docker to wrap up the developer environment. We learned about dev containers, and how they significantly streamline project setup for complex projects, such as a SaaS application, and we then configured a dev container and learned how to work in that environment.</p>
			<p>With the core of the environment set up, we set up a database and populated it with some data using Entity Framework, then made the data available through an API, and finally surfaced the data on a Blazor UI!</p>
			<p>With all of the above, we have configured all of the individual parts required to build up a fully featured SaaS application. Read on, and we will do just that!</p>
			<p>In the next chapter, you will learn about a core part of building SaaS applications, and that is multi-tenancy. We will cover what this is and why it is so important, and start to think about how we will implement it in our sample application.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Further reading</h1>
			<ul>
				<li>Developing inside a Container: <a href="https://code.visualstudio.com/docs/devcontainers/containers">https://code.visualstudio.com/docs/devcontainers/containers</a></li>
				<li>Entity Framework Dev Environment in Docker: <a href="https://itnext.io/database-development-in-docker-with-entity-framework-core-95772714626f">https://itnext.io/database-development-in-docker-with-entity-framework-core-95772714626f</a></li>
				<li>.NET Development in Docker with Dev Containers: <a href="https://itnext.io/net-development-in-docker-6509d8a5077b">https://itnext.io/net-development-in-docker-6509d8a5077b</a></li>
				<li>Blazor Tutorial - Build your first Blazor app: <a href="https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro">https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro</a></li>
				<li>Tutorial: Create a web API with ASP.NET Core: <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-7.0&amp;tabs=visual-studio">https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-7.0&amp;tabs=visual-studio</a></li>
			</ul>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/>Questions</h1>
			<ol>
				<li>What are the advantages of using dev containers?</li>
				<li>How were we able to use SQL Server without having to install it on our developer machines?</li>
				<li>What are the HTTP verbs commonly associated with RESTful APIs?</li>
				<li>What are the benefits of using Entity Framework?</li>
			</ol>
			<p>We have covered a lot in this chapter! Don’t worry if the answers to the above questions are not 100% clear at this stage – we will expand on all of them in the coming chapters.</p>
		</div>
	

		<div><h1 id="_idParaDest-80"><a id="_idTextAnchor081"/>Part 2: Building the Backend</h1>
			<p>This section covers all things backend related, starting with the database and building up to the API layer. This section also introduces the topics of multi-tenancy and microservices, both of which are very important for developing SaaS applications.</p>
			<p>This section has the following chapters:</p>
			<ul>
				<li><a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, <em class="italic">What Is Multi-Tenancy, and Why Is It Important in SaaS Applications?</em></li>
				<li><a href="B19343_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>, <em class="italic">Building Databases and Planning for Data-Rich Applications</em></li>
				<li><a href="B19343_05.xhtml#_idTextAnchor116"><em class="italic">Chapter 5</em></a>, <em class="italic">Building R</em><em class="italic">EST</em><em class="italic">ful APIs</em></li>
				<li><a href="B19343_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">Microservices for SaaS Applications</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>