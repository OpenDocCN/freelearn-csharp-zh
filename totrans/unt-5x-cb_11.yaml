- en: Chapter 11. Improving Games with Extra Features and Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing slow motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing your game from running on unknown servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior Do-It-Yourself states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior using the State Design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of objects by destroying objects at a death time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of enabled objects by disabling objects whenever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of active objects by making objects inactive whenever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving efficiency with delegates and events and avoiding SendMessage!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing methods regularly but independent of frame rate with coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreading long computations over several frames with coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating performance by measuring max and min frame rates (FPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying performance bottlenecks with the Unity performance Profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying performance bottlenecks with Do-It-Yourself performance profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache GameObject and component references to avoid expensive lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance with LOD groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance through reduced draw calls by designing for draw call
    batching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first three recipes in this chapter provide some ideas for adding some extra
    features to your game (pausing, slow motion, and securing online games). The next
    two recipes then present ways to manage complexity in your games through managing
    states and their transitions.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the recipes in this chapter provide examples of how to investigate
    and improve the efficiency and performance of your game. Each of these optimization
    recipes begins by stating an optimization principle that it embodies.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before getting on with the recipes, let's step back and think about the different
    parts of Unity games and how their construction and runtime behavior can impact
    on game performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Games are made up of several different kinds of components:'
  prefs: []
  type: TYPE_NORMAL
- en: Audio assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D and 3D graphical assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text and other file assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a game is running, there are many competing processing requirements for
    your CPU and GPU, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Audio processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D physics processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D physics processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPU processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to reduce the complexity of graphical computations and to improve frame
    rates is to use simpler models whenever possible—this is the reduction of the
    **Level Of Detail** (**LOD**). The general strategy is to identify situations
    where a simpler model will not degrade the user's experience. Typically, situations
    include where a model is only taking up a small part of the screen (so less detail
    in the model will not change what the user sees), when objects are moving very
    fast across the screen (so the user is unlikely to have time to notice less detail),
    or where we are sure the users' visual focus is elsewhere (for example, in a car
    racing game, the user is not looking at the quality of the trees but on the road
    ahead). We provide a LOD recipe, *Improving performance with LOD groups*, in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's draw call batching may actually be *more efficient* than you or your
    team's 3D modelers are at reducing the triangle/vertex geometry. So, it may be
    that by manually simplifying a 3D model, you have removed Unity's opportunity
    to apply its highly effective vertex reduction algorithms; then, the geometric
    complexity may be larger for a small model than for a larger model, and so a smaller
    model may lead to a lower game performance! One recipe presents advice collected
    from several sources and the location of tools to assist in different strategies
    to try to reduce draw calls and improve graphical performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will present several recipes allowing you to analyze actual processing times
    and frame rates, so that you can collect data to confirm whether your design decisions
    are having the desired efficiency improvements.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"You have a limited CPU budget and you have to live with it"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Joachim Ante, Unite-07* |'
  prefs: []
  type: TYPE_TB
- en: At the end of the day, the best *balance* of heuristic strategies for your particular
    game project can only be discovered by an investment of time and hard work, and
    some form of profiling investigation. Certain strategies (such as caching to reduce
    component reflection lookups) should perhaps be standard practice in all projects,
    while other strategies may require *tweaking* for each unique game and level,
    to find which approaches work effectively to improve efficiency, frame rates,
    and, most importantly, the user experience when playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Premature Optimization is the root of all evil"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Donald Knuth, "Structured Programming With Go To Statements". Computing Surveys,
    Vol 6, No 4, December 1974*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Perhaps, the core strategy to take away from this chapter is that there are
    many parts of a game that are candidates for possible optimization, and you should
    drive the actual optimizations you finally implement for a particular game based
    on the evidence you gain by profiling its performance.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As compelling as your next game will be, you should always let players pause
    it for a short break. In this recipe, we will implement a simple and effective
    pause screen including controls for changing the display's quality settings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a package named `BallGame` containing a playable
    scene. The package is in the `1362_11_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To pause your game upon pressing the *Esc* key, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BallGame` package into your project and, from the **Project** view,
    open the level named `BallGame_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, create a new tag **Ball**, apply this tag to prefab `ball`
    in `Prefabs` folder, and save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, use the **Create** drop-down menu to add a **Panel**
    to the UI (**Create** | **UI** | **Panel**). Note that it will automatically add
    it to the current **Canvas** in the scene. Rename the panel `QualityPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now use the **Create** drop-down menu to add a **Slider** to the UI (**Create**
    | **UI** | **Slider**). Rename it `QualitySlider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, use the **Create** drop-down menu to add a **Text** to the UI (**Create**
    | **UI** | **Text**). Rename it `QualityLabel`. Also, from the **Inspector** view,
    **Rect Transform**, change its **Pos Y** to **-25**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script **PauseGame** to **First Person Controller**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the **Hierarchy** view, select the **First Person Controller**. Then, from
    the **Inspector**, access the **Pause Game** component and populate the **QPanel**,
    **QSlider**, and **QLabel** fields with the game objects **QualityPanel**, **QualitySlider**,
    and **QualityLabel** respectively, as shown in the following screenshot:![How
    to do it...](img/1362OT_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, select **QualitySlider**. Then, from the **Inspector**
    view, **Slider** component, find the list named **On Value Changed (Single)**,
    and click on the **+** sign to add a command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **First Person Controller** from the **Hierarchy** view into the game
    object field of the new command. Then, use the function selector to find the **SetQuality**
    function under **Dynamic float** (**No Function** | **PauseGame** | **Dynamic
    float** | **SetQuality**), as shown in the following screenshot:![How to do it...](img/1362OT_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play the scene, you should be able to pause/resume the game by pressing
    the *Esc* key, also activating a slider that controls the game's quality settings.![How
    to do it...](img/1362OT_11_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pausing the game is actually an easy, straightforward task in Unity: all we
    need to do is set the game''s **Time Scale** to `0` (and set it back to `1` to
    resume). In our code, we have included such a command within the `SetPause()`
    function, which is called whenever the player presses the *Esc* key, also toggling
    the `isPaused` variable. To make things more functional, we have included a **GUI
    panel** featuring a *QualitySettings* slider that is activated whenever the game
    is paused.'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1362OT_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regarding the behavior for the QualitySettings slider and text, their parameters
    are adjusted at the start based on the game's variety of quality settings, their
    names, and its current state. Then, changes in the slider's value redefine the
    quality settings, also updating the label text accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can always add more functionality to the *pause* screen by displaying sound
    volume controls, save/load buttons, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about QualitySettings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our code for changing quality settings is a slight modification of the example
    given by Unity's documentation. If you want to learn more about the subject, check
    out [http://docs.unity3d.com/ScriptReference/QualitySettings.html](http://docs.unity3d.com/ScriptReference/QualitySettings.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Implementing slow motion* recipe in this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing slow motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Remedy Entertainment's *Max Payne*, slow motion, or bullet time, became
    a popular feature in games. For example, Criterion's *Burnout* series has successfully
    explored the slow motion effect in the racing genre. In this recipe, we will implement
    a slow motion effect triggered by the pressing of the mouse's right button.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same package as the previous recipe, `BallGame`
    in the `1362_11_02` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement slow motion, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BallGame` package into your project and, from the **Project** view,
    open the level named `BallGame_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, create a new tag **Ball**, apply this tag to prefab `ball`
    in the `Prefabs` folder, and save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script **BulletTime** to **First Person Controller**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the **Hierarchy** view, use the **Create** drop-down menu to add a **Slider**
    to the UI (**Create** | **UI** | **Slider**). Please note that it will be created
    as a child of the preexisting **Canvas** object. Rename it `EnergySlider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **EnergySlider** and, from the **Inspector** view, **Rect Transform**
    component, set its position as follows: **Left: 0**; **Pos Y: 0**; **Pos Z: 0**;
    **Right: 0**; **Height: 50**. Then, expand the **Anchors** settings and change
    it to: **Min X: 0**; **Y: 1**; **Max X: 0.5**; **Y: 1**; **Pivot X: 0**; **Y:
    1**, as shown in the following screenshot:![How to do it...](img/1362OT_11_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also select the **Handle Slide Area** child and disable it from the **Inspector**
    view, as shown in the following screenshot:![How to do it...](img/1362OT_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the **First Person Controller** from the **Hierarchy** view,
    find the **Bullet Time** component, and drag the **EnergySlider** from the **Hierarchy**
    view into its **Energy Bar** slot, as shown in the next screenshot:![How to do
    it...](img/1362OT_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your game. You should be able to activate slow motion by holding down the
    right mouse button (or whatever alternative you have set for **Input** axis **Fire2**).
    The slider will act as a progress bar that slowly shrinks, indicating the remaining
    *bullet time* you have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically, all we need to do to have the slow motion effect is decrease the
    `Time.timeScale` variable. In our script, we do that by using the `sloSpeed` variable.
    Please note that we also need to adjust the `Time.fixedDeltaTime` variable, updating
    the physics simulation of our game.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the experience more challenging, we have also implemented a
    sort of *energy bar* to indicate how much bullet time the player has left (the
    initial value is given, in seconds, by the `totalTime` variable). Whenever the
    player is not using bullet time, he has his quota filled according to the `recoveryRate`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the *GUI slider*, we have used the **Rect Transform** settings to
    place it on the top-left corner and set its dimensions to half of the screen's
    width and 50 pixels tall. Also, we have hidden the *handle slide area* to make
    it more similar to a traditional energy bar. Finally, instead of allowing direct
    interaction from the player with the slider, we have used the `BulletTime` script
    to change the slider's value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some suggestions for you to improve your slow motion effect even further are
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the slider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Don''t forget that you can personalize the slider''s appearance by creating
    your own sprites, or even by changing the slider''s *fill* color based on the
    slider''s value. Try adding the following lines of code to the end of the `Update`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding Motion Blur
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Motion Blur** is an image effect frequently identified with slow motion.
    Once attached to the camera, it could be enabled or disabled depending on the
    `speed` float value. For more information on the Motion Blur image effect, refer
    to [http://docs.unity3d.com/Manual/script-MotionBlur.html](http://docs.unity3d.com/Manual/script-MotionBlur.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating sonic ambience
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Max Payne* famously used a strong, heavy heartbeat sound as sonic ambience.
    You could also try lowering the sound effects volume to convey the character focus
    when in slow motion. Plus, using audio filters on the camera could be an interesting
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the recipe *Pausing the game* in this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing your game from running on unknown servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all the hard work you've had to go through to complete your web game project,
    it wouldn't be fair if it ended up generating traffic and income on someone else's
    website. In this recipe, we will create a script that prevents the main game menu
    from showing up unless it's hosted by an authorized server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test this recipe, you will need access to a webspace provider where you can
    host the game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prevent your web game from being pirated, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, use the **Create** drop-down menu to create a **UI
    Text** GameObject (**Create** | **UI** | **Text**). Name it `Text – warning`.
    Then, from the **Text** component in the **Inspector**, change its **text** field
    to `Getting Info. Please wait`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script to the `Text – warning` game object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the **Inspector** view, leave the options **Check Domain** and **Full URL**
    checked, and increase **Size** of **Domain List** to `1` and fill out **Element
    0** with the complete URL for your game. Type in the sentence `This is not a valid
    copy of the game` in the **Message** field, as shown in the following screenshot.
    You might have to change the paragraph's **Horizontal Overflow** to **Overflow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Remember to include the Unity 3D file name and extension in the URL,
    and not the HTML where it is embedded.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_11_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Save your scene as `menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new scene and change its **Main Camera** background color to black.
    Save this scene as `nextLevel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's build the game. Go to the **File | Build Settings…** menu and include
    the scenes **menu** and **nextLevel**, in that order, in the build list (**Scenes**
    in **Build**). Also, select **Web Player** as your platform and click on **Build**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as the scene starts, the script compares the actual URL of the `.unity3d`
    file to the ones listed in the `Block Access` component. If they don't match,
    the next level in the build is not loaded and a message appears on the screen.
    If they do match, the line of code `Application.LoadLevel(Application.loadedLevel
    + 1)` will load the next scene from the build list.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is some information on how to fine tune and customize this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Improving security by using full URLs in your domain list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your game will be more secure if you fill out the domain list with complete
    URLs (such as [http://www.myDomain.com/unitygame/game.unity3d](http://www.myDomain.com/unitygame/game.unity3d)).
    In fact, it's recommended that you leave the **Full URL** option selected so that
    your game won't be stolen and published under a URL such as `www.stolenGames.com/yourgame.html?www.myDomain.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing redistribution with more domains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your game to run from several different domains, increase **Size**
    and fill out more URLs. Also, you can leave your game completely free of protection
    by leaving the **Check Domain** option unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: State-driven behavior Do-It-Yourself states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games as a whole, and individual objects or characters, can often be thought
    of (or modeled as) passing through different *states* or *modes*. Modeling states
    and changes of state (due to *events* or game conditions) is a very common way
    to manage the complexity of games and game components. In this recipe, we create
    a simple three-state game (game playing/game won/game lost) using a single `GameManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use states to manage object behavior, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two UI buttons at the top middle of the screen. Name one **Button-win**
    and edit its text to read **Win Game**. Name the second **Button-lose** and edit
    its text to read **Lose Game**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UI text object at the top left of the screen. Name this **Text-state-messages**,
    and set its **Rect Transform** height property to **300** and its **Text (Script)
    Paragraph Vertical Overflow** property to **Overflow**.![How to do it...](img/1362OT_11_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `GameManager` to **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **Hierarchy**, select the **Button-win** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Button-lose** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Main Camera** GameObject. Next, drag into
    the **Inspector** to ensure that all three **GameManager (Script)** public variables,
    **Text State Messages**, **Button Win Game**, and **Button Lose Game**, have the
    corresponding Canvas GameObjects dragged into them (the two buttons and the UI
    text GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As can be seen in the following state chart figure, this recipe models a simple
    game, which starts in the **GAME PLAYING** state; then, depending on the button
    clicked by the user, the game moves either into the **GAME WON** state or the
    **GAME LOST** state. Also, if the user waits too long to click on a button, the
    game moves into the **GAME LOST** state.
  prefs: []
  type: TYPE_NORMAL
- en: The possible states of the system are defined using the enumerated type `GameStateType`,
    and the current state of the system at any point in time is stored in the `currentState`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1362OT_11_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A fourth state is defined (`Other`) to allow us to explicitly set the desired
    `GamePlaying` state in our `Start()` method. When we wish the game state to be
    changed, we call the `NewGameState(…)`method, passing the new state the game is
    to change into. The `NewGameState(…)`method first calls the `OnMyStateExit(…)`method
    with the current state, since there may be actions to be performed when a particular
    state is exited; for example, when the `GamePlaying` state is exited, it destroys
    the two buttons. Next, the `NewGameState(…)`method sets the `currentState` variable
    to be assigned the new state. Next, the `OnMyStateEnter(…)` method is called,
    since there may be actions to be performed immediately when a new state is entered.
    Finally, a message divider is posted to the UI Text box, with a call to the `PostMessageDivider()`method.
  prefs: []
  type: TYPE_NORMAL
- en: When the `GameManager` object receives messages (for example, every frame for
    `Update()`), its behavior must be appropriate for the current state. So, we see
    in this method a `Switch` statement, which calls state-specific methods. For example,
    if the current state is `GamePlaying`, then when an `Update()` message is received,
    the `UpdateStateGamePlaying()`method will be called.
  prefs: []
  type: TYPE_NORMAL
- en: The `BUTTON_CLICK_ACTION_WIN_GAME()` and `BUTTON_CLICK_ACTION_LOSE_GAME()` methods
    are executed if their corresponding buttons have been clicked. They move the game
    into the corresponding **WIN** or **LOSE** state.
  prefs: []
  type: TYPE_NORMAL
- en: Logic has been written in the `UpdateStateGamePlaying() m`ethod, so once the
    `GameManager` has been in the `GamePlaying` state for more than a certain time
    (defined in variable `timeToPressAButton`), the game will automatically change
    into the `GameLost` state.
  prefs: []
  type: TYPE_NORMAL
- en: So, for each state, we may need to write methods for state exit, state entry,
    and update events, and also a main method for each event with a `Switch` statement
    to determine which state method should be called (or not). As can be imagined,
    the size of our methods and the number of methods in our `GameManager` class will
    grow significantly as more states and a more complex game logic are needed for
    non-trivial games. The next recipe takes a more sophisticated approach to state-driven
    games, where each state has its own class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the next recipe in this chapter for more information on how to manage
    the complexity of states with class inheritance and the State Design Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: State-driven behavior using the State Design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous pattern illustrated not only the usefulness of modeling game states,
    but also how a game manager class can grow in size and become unmanageable. To
    manage the complexity of many states and complex behaviors of states, the State
    pattern has been proposed in the software development community. Design patterns
    are general purpose software component architectures that have been tried and
    tested and found to be good solutions to commonly occurring software system features.
    The key features of the State pattern are that each state is modeled by its own
    class and that all states inherit (are subclassed) from a single parent state
    class. The states need to know about each other in order to tell the game manager
    to change the current state. This is a small price to pay for the division of
    the complexity of the overall game behaviors into separate state classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: Many thanks to the contribution from Bryan Griffiths which has helped
    improve this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe. So, make a copy of that project,
    open it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manage an object''s behavior using the state pattern architecture, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of C# script class `GameManager` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new C# script class called `GameState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateGamePlaying`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateGameWon`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateGameLost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **Hierarchy**, select the **Button-win** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Button-lose** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Main Camera** GameObject. Next, drag into
    the **Inspector** to ensure that all three **GameManager (Script)** public variables,
    **Text State Messages**, **Button Win Game**, and **Button Lose Game**, have the
    corresponding Canvas GameObjects dragged into them (the two buttons and the UI
    text GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scene is very straightforward for this recipe. There is the single **Main
    Camera** GameObject that has the `GameManager` script object component attached
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A C# scripted class is defined for each state that the game needs to manage—for
    this example, the three states `StateGamePlaying`, `StateGameWon`, and `StateGameLost`.
    Each of these state classes is a subclass of `GameState`. `GameState` defines
    properties and methods that all subclass states will possess:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An enumerated type `ButtonType`, which defines the two possible button clicks
    that the game might generate: `ButtonWinGame` and `ButtonLoseGame`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `gameManager` variable: so that each state object has a link to the game
    manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constructor method that accepts a reference to the `GameManager`: that
    automatically makes the `gameManager` variable refer to the passed in `GameManager`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The four abstract methods `OnMyStateEntered()`, `OnMyStateExit()`, `OnButtonClick(…)`,
    and `StateUpdate()`. Note that abstract methods must have their own implementation
    for each subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `GameManager` class'' `Awake()` method is executed, three state objects
    are created, one for each of the playing/win/lose classes. These state objects
    are stored in their corresponding variables: `stateGamePlaying`, `stateGameWon`,
    and `stateGameLost`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `GameManager` class has a variable called `currentState`, which is a reference
    to the current state object at any time while the game runs (initially, it will
    be `null`). Since it is of the `GameState` class (the parent of all state classes),
    it can refer to any of the different state objects.
  prefs: []
  type: TYPE_NORMAL
- en: After `Awake()`, `GameManager` will receive a `Start()` message. This method
    initializes the `currentState` to be the `stateGamePlaying` object.
  prefs: []
  type: TYPE_NORMAL
- en: For each frame, the `GameManager` will receive `Update()`messages. Upon receiving
    these messages, `GameManager` sends a `StateUpdate()`messages to the `currentState`
    object. So, for each frame, the object for the current state of the game will
    execute those methods. For example, when the `currentState` is set to game playing,
    for each frame, the `gamePlayingObject` will calls its (in this case, empty) `StateUpdate()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `StateGamePlaying` class implements statements in its `OnButtonClick()`
    method so that when the user clicks on a button, the `gamePlayingObject` will
    call the `GameManager` instance's `NewState()` method, passing it the object corresponding
    to the new state. So, if the user clicks on **Button-win**, the `NewState()` method
    is passed to `gameManager.stateGameWon`.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of objects by destroying objects at death a time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 1**: Minimize the number of active and enabled objects
    in a scene.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to reduce the number of active objects is to destroy objects when they
    are no longer needed. As soon as an object is no longer needed, we should destroy
    it; this saves both memory and processing resources since Unity no longer needs
    to send the object such messages as `Update()` and `FixedUpdate()`, or consider
    object collisions or physics and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be times when we wish not to destroy an object immediately,
    but at some known point in the future. Examples might include after a sound has
    finished playing (see that recipe *Waiting for audio to finish before auto-destructing
    object* in [Chapter 9](ch09.html "Chapter 9. Playing and Manipulating Sounds"),
    *Playing and Manipulating Sounds*), the player only has a certain time to collect
    a bonus object before it disappears, or perhaps an object displaying a message
    to the player should disappear after a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how objects can be told to *start dying*, and then
    to automatically destroy them after a given delay has passed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reducing the number of objects by destroying objects at death a time](img/1362OT_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To destroy objects after a specified time, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UI **Button** named **Click Me**, and make it stretch to fill the entire
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, set the Button's **Text child** to have left-aligned and
    large text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following script class `DeathTimeExample.cs` to **Button Click Me**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drag the **Text** child of **Button Click Me** into the script's public variable
    **Button Text**, so this script is able to change the button text to show the
    countdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Button Click Me** selected in the **Hierarchy**, add a new **On Click()**
    event for this button, dragging the button itself as the target GameObject and
    selecting public function `BUTTON_ACTION_StartDying(),`as shown in the following
    screenshot:![How to do it...](img/1362OT_11_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run the scene; once the button is clicked, the button's text should show
    the countdown. Once the countdown gets to zero, **Button Click Me** will be destroyed
    (including all its children, in this case, just the GameObject **Text**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The float variable `deathDelay` stores the number of seconds the object waits
    before destroying itself once the decision has been made for the object to start
    dying. The float variable `deathTime` either has a value of `-1` (no death time
    yet set) or it is a non-negative value, which is the time we wish the object to
    destroy itself.
  prefs: []
  type: TYPE_NORMAL
- en: When the button is clicked, the `BUTTON_ACTION_StartDying()` method is called.
    This method sets this `deathTime` variable to the current time plus whatever value
    is set in `deathDelay`. This new value for `deathTime` will be a positive number,
    meaning the `IF`-statement in the `Update()` method will fire from this point
    onward.
  prefs: []
  type: TYPE_NORMAL
- en: Every frame method `Update()` checks if `deathTime` is greater than zero (that
    is, a death time has been set), and, if so, it then calls, the `UpdateTimeDisplay()`
    and `CheckDeath()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateTimeDisplay()` methods creates a string message stating how many
    seconds are left and updates the **Button Text** to show this message.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckDeath()` method tests whether the current time has passed the `deathTime`.
    If the death time has passed, then the parent `gameObject` is immediately destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the scene, you'll see the **Button** removed from the **Hierarchy**
    once its death time has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of enabled objects by disabling objects whenever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of active objects by making objects inactive whenever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of enabled objects by disabling objects whenever possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 1**: Minimize the number of active and enabled objects
    in a scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we may not want to completely remove an object, but we can identify
    times when a scripted component of an object can be safely disabled. If a `MonoBehaviour`
    script is disabled, then Unity no longer needs to send the object messages, such
    as `Update()`and `FixedUpdate()`, for each frame.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a **Non-Player Character** (**NPC**) should only demonstrate
    some behavior when the player can see that character, then we only need to be
    executing the behavior logic when the NPC is visible—the rest of the time, we
    can safely disable the scripted component.
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides the very useful events `OnBecameInvisible()` and `OnBecameVisible()`,
    which inform an object when it moves out of and into the visible area for one
    or more cameras in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe illustrates the following rule of thumb: if an object has no reason
    to be doing actions when it cannot be seen, then we should disable that object
    while it cannot be seen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reducing the number of enabled objects by disabling objects whenever possible](img/1362OT_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a package named `unity4_assets_handyman_goodDirt`
    containing the `3rdPersonController` handyman and Terrain material `goodDirt`.
    The package is in the `1362_11_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To disable objects to reduce computer processing workload requirements, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity project, importing the provided Unity package `unity4_assets_handyman_goodDirt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Terrain** (size **20 x 20**, located at **-10, 0, -10**) and
    texture-paint it with **GoodDirt** (which you'll find in the **Standard Assets**
    folder from your import of the **Terrain Assets** package).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **3rdPersonController** at (**0, 1, 0**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Cube** just in front of your **3rdPersonController** (so it is
    visible in the **Game** panel when you start running the game).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `DisableWhenNotVisible` to your **Cube**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When visible, the scripted `DisableWhenNotVisible` component of **Cube** recalculates
    and displays the distance from itself to the **3rdPersonController** object's
    transform, via the variable `player` in the `Update()` method for each frame.
    However, when this object receives the message `OnBecameInvisible()`, the object
    sets its `enabled` property to `false`. This results in Unity no longer sending
    `Update()`messages to the `GameObject`, so the distance calculation in `Update()`
    is no longer performed; thus, reducing the game's processing workload. Upon receiving
    the message `OnBecameVisible()`, the `enabled` property is set back to `true`,
    and the object will then receive `Update()` messages for each frame. Note that
    you can see the scripted component become disabled by seeing the blue *tick* in
    its **Inspector** checkbox disappear if you have the **Cube** selected in the
    **Hierarchy** when running the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1362OT_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows our **Console** text output, logging how the
    user must have turned away from the cube at 6.9 seconds after starting the game
    (and so the cube was no longer visible); then, at 9.4 seconds, the user turned
    so that they could see the cube again, causing it to be re-enabled.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Note – viewable in Scene panel still counts as visible!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that even if the **Game** panel is not showing (rendering) an object, if
    the object is visible in a **Scene** panel, then it will still be considered visible.
    Therefore, it is recommended that you hide/close the **Scene** panel when testing
    this recipe, otherwise it may be that the object does only becomes non-visible
    when the game stops running.
  prefs: []
  type: TYPE_NORMAL
- en: Another common case – only enable after OnTrigger()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common situation is that we only want a scripted component to be active
    if the player''s character is nearby (within some minimum distance). In these
    situations, a sphere collider (with **Is Trigger** checked) can be set up on the
    object to be disabled/enabled (continuing our example, this would be on our **Cube**),
    and the scripted component can be enabled only when the player''s character enters
    that sphere. This can be implemented by replacing the `OnBecameInvisible()` and
    `OnBecameVisible()` methods with the `OnTriggerEnter()` and `OnTriggerExit()`
    methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates a large sphere collider having been created
    around the cube, with its **Trigger** enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Another common case – only enable after OnTrigger()](img/1362OT_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Many computer games (such as *Half Life*) use environmental design such as
    corridors to optimize memory usage by loading and unloading different parts of
    the environment. For example, when a player hits a corridor trigger, environment
    objects load and unload. See the following for more information about such techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gamearchitect.net/Articles/StreamingBestiary.html](http://gamearchitect.net/Articles/StreamingBestiary.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/](http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big](http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reducing the number of objects by destroying objects at a death time*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reducing the number of active objects by making objects inactive whenever
    possible*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of active objects by making objects inactive whenever possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 1**: Minimize the number of active and enabled objects
    in a scene.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we may not want to completely remove an object, but it is possible
    to go one step further than disabling a scripted component by making the parent
    `GameObject` that contains the scripted component `inactive`. This is just like
    deselecting the checkbox next to the `GameObject` in the **Inspector**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reducing the number of active objects by making objects inactive whenever
    possible](img/1362OT_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To reduce computer processing *workload* requirements by making an object inactive
    when it becomes invisible, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the scripted component `DisableWhenNotVisible` from your **Cube**, and
    instead, add the following C# script class `InactiveWhenNotVisible` to **Cube**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new **Button**, containing the text `Make Cube Active Again`, and position
    the button so that it is at the top of the **Game** panel and stretches the entire
    width of the **Game** panel, as shown in the following screenshot:![How to do
    it...](img/1362OT_11_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Button** selected in the **Hierarchy**, add a new **On Click()**
    event for this button, dragging the **Cube** as the target GameObject and selecting
    public function `BUTTON_ACTION_makeCubeActiveAgain()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the active checkbox next to the **Button** name in the **Inspector**
    (in other words, manually deactivate this **Button** so that we don't see the
    **Button** when the scene first runs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Cube** in the **Inspector** and drag the **Button** into the `MakeActiveAgainButton`
    variable slot of its script class `InactiveWhenNotVisible` component, as shown
    in the following screenshot:![How to do it...](img/1362OT_11_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initially, the **Cube** is visible and the **Button** is inactive (so not visible
    to the user). When the **Cube** receives an `OnBecameInvisible` event message,
    its `OnBecameInvisible()` method will execute. This method performs two actions:'
  prefs: []
  type: TYPE_NORMAL
- en: It first enables (and therefore makes visible) the `Button`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then makes inactive the script's parent `gameObject` (that is, the `Cube`
    GameObject).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **Button** is clicked, it makes the **Cube** object active again and
    makes the **Button** inactive again. So, at any one time, only one of the **Cube**
    and **Button** objects are active, and each makes itself inactive when the other
    is active.
  prefs: []
  type: TYPE_NORMAL
- en: Note that an inactive `GameObject` does not receive *any* messages, so it will
    not receive the `OnBecameVisible()` message, and this may not be appropriate for
    every object that is out of sight of the camera. However, when deactivating objects
    is appropriate, a larger performance saving is made compared to simply disabling
    a single scripted `Monobehaviour` component of a `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to reactivate an inactive object is for another object to set the
    `GameObject` component's active property back to `true`. In this recipe, it is
    the `Button` GameObject, which, when clicked, runs the `BUTTON_ACTION_makeCubeActiveAgain()`
    method, which allows our game to make the **Cube** active again.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reducing the number of objects by destroying objects at a death time*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reducing the number of enabled objects by disabling objects whenever possible*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving efficiency with delegates and events and avoiding SendMessage!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 2**: Minimize actions requiring Unity to perform "reflection"
    over objects and searching of all current scene objects.'
  prefs: []
  type: TYPE_NORMAL
- en: When events can be based on visibility, distance, or collisions, we can use
    such events as `OnTriggerExit` and `OnBecomeInvisible`, as described in some of
    the previous recipes. When events can be based on time periods, we can use coroutines,
    as described in other recipes in this chapter. However, some events are unique
    to each game situation, and C# offers several methods of broadcasting user-defined
    event messages to scripted objects. One approach is the `SendMessage(…)` method,
    which, when sent to a GameObject, will check every `Monobehaviour` scripted component
    and execute the named method if its parameters match. However, this involves an
    inefficient technique known as **reflection**. C# offers another event message
    approach known as **delegates and events**, which we describe and implement in
    this recipe. Delegates and events work in a similar way to `SendMessage(…)`, but
    are much more efficient since Unity maintains a defined list of which objects
    are *listening* to the broadcast events. `SendMessage(…)` should be avoided if
    performance is important, since it means that Unity has to analyze each scripted
    object (*reflect over* the object) to see whether there is a public method corresponding
    to the message that has been sent; this is much slower than using delegates and
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events implement the **publish-subscribe design pattern** (**pubsub**).
    This is also known as the **observer** design pattern. Objects can subscribe one
    of their methods to receive a particular type of event message from a particular
    publisher. In this recipe, we'll have a manager class that will publish new events
    when UI buttons are clicked. We'll create some UI objects, some of which **subscribe**
    to the color change events, so that each time a color change event is published,
    subscribed UI objects receive the event message and change their color accordingly.
    C# publisher objects don't have to worry about how many objects subscribe to them
    at any point in time (it could be none or 1,000!); this is known as **loose coupling**,
    since it allows different code components to be written (and maintained) independently
    and is a desirable feature of object-oriented code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement delegates and events, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class **ColorManager** to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create two UI **Image** objects and two UI **Text** objects. Position one **Image**
    and **Text** object to the lower left of the screen and position the other to
    the lower right of the screen. Make the text on the lower left read **Not listening**,
    and make the text on the right of the screen read **I am listening**. For good
    measure, add a **Slider** UI object in the top right of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three UI buttons in the top left of the screen, named **Button-GREEN**,
    **Button-BLUE**, and **Button-RED**, with corresponding text reading `make things
    <color=green>GREEN</color>`, `make things <color=blue>BLUE</color>`, and `make
    things <color=red>RED</color>`.![How to do it...](img/1362OT_11_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the following C# script class `ColorChangeListenerImage` to both the
    lower-right **Image** and also the **Slider**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach the following C# script class `ColorChangeListenerText` to the **I am
    listening Text** UI object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With button-**GREEN** selected in the **Hierarchy**, add a new **On Click()**
    event for this button, dragging the **Main Camera** as the target GameObject and
    selecting public function `BUTTON_ACTION_make_green()`. Do the same for the **BLUE**
    and **RED** buttons with functions `BUTTON_ACTION_make_blue()` and `BUTTON_ACTION_make_red()`
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. When you click a change color button, the three UI objects on
    the right of the screen show all changes to the corresponding color, while the
    two UI objects at the bottom left of the screen remain in the default **White**
    color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's consider what we want to happen—we want the right-hand **Image**,
    **Slider**, and **Text** objects to change their color when they receive an event
    message `OnChangeColor()` with a new color argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is achieved by each object having an instance of the appropriate `ColorChangeListener`
    class that subscribes their `OnChangeColor()` method to listen for color change
    events published from the `ColorManager` class. Since both the **Image** and **Slider**
    objects have an image component whose color will change, they have scripted components
    of our C# class `ColorChangeListenerImage`, while the **Text** object needs a
    different class since it is the color of the text component whose color is to
    be changed (so we add an instance of C# scripted component `ColorChangeListenerText`
    to the **Text** UI object). So, as we can see, different objects may respond to
    receiving the same event messages in ways appropriate to each different object.
  prefs: []
  type: TYPE_NORMAL
- en: Since our scripted objects may be disabled and enabled at different times, each
    time a scripted `ColorChangeListener` object is enabled (such as when its GameObject
    parent is instantiated), its `OnChangeColor()` method is added (`+=`) to the list
    of those subscribed to listen for color change events, likewise each time `ColorChangeListenerImage/Text`
    objects are disabled, those methods are removed (`-=`) from the list of event
    subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: When a `ColorChangeListenerImage/Text` object receives a color change message,
    its subscribed `OnChangeColor()` method is executed and the color of the appropriate
    component is changed to the received `Color` value (`green`/`red`/`blue`).
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorManager` class has a public class (static) variable `changeColorEvent`,
    which defines an *event* to which Unity maintains a dynamic list of all the subscribed
    object methods. It is to this event that `ColorChangeListenerImage/Text` objects
    register or deregister their methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ColorManager` class displays three buttons to the user to change all listening
    objects to a specific color: green, red, and blue. When a button is clicked, the
    `changeColorEvent` is told to publish a new event, passing a corresponding `Color`
    argument to all subscribed object methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorManager` class declares a *Delegate* named `ColorChangeHandler`. Delegates
    define the return type (in this case, `void`) and argument *signature* of methods
    that can be delegated (subscribed) to an event. In this case, methods must have
    the argument signature of a single parameter of type `Color`. Our `OnChangeColor()`
    method in classes `ColorChangeListenerImage/Text` match this argument signature
    and so are permitted to subscribe to the `changeColorEvent` in the `ColorManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: An easy to understand video about Unity delegates and events can be found
    at [http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Cache GameObject and component references to avoid expensive lookups*
    recipe in this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Executing methods regularly but independent of frame rate with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 3**: Call methods as few times as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: While it is very simple to put logic into `Update()` and have it regularly executed
    for each frame, we can improve game performance by executing logic as rarely as
    possible. So, if we can get away with only checking for a situation every 5 seconds,
    then great performance savings can be made to move that logic out of `Update()`.
  prefs: []
  type: TYPE_NORMAL
- en: A **coroutine** is a function that can suspend its execution until a `yield`
    action has completed. One kind of yield action simply waits for a given number
    of seconds. In this recipe, we use coroutines and yield to show how a method can
    be only executed every 5 seconds; this could be useful for NPCs to decide whether
    they should randomly *wake up* or perhaps choose a new location to start moving
    toward.
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing methods regularly but independent of frame rate with coroutines](img/1362OT_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement methods at regular intervals independent of the frame rate, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following C# script class `TimedMethod` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `Start()` message is received, the `Tick()` method is started as a
    coroutine. The `Tick()` method sets the delay between executions (variable `delaySeconds`)
    to 5 seconds. An infinite loop is then started, where the method does its actions
    (in this case, just printing out the time); finally, a `yield` instruction is
    executed, which causes the method to suspend execution for the given delay of
    5 seconds. After the yield instruction has completed, the loop will continue executing
    once again and so on. What is important to understand when working with coroutines
    is that the method will *resume executing* from the same state it yielded.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that *there are no* `Update()` *or* `FixedUpdate()` *methods
    at all*. So, although our game has logic being regularly executed, in this example,
    there is no logic that has to be executed every frame—fantastic!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Have different actions happening at different intervals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coroutines can be used to have different kinds of logic being executed at different
    regular intervals. So, logic that needs frame-by-frame execution goes into `Update()`,
    and logic that works fine once or twice a second might go into a coroutine with
    a 0.5-second delay; logic that can get away with less occasional updating can
    go into another coroutine with a 2- or 5-second delay, and so on. Effective and
    noticeable performance improvements can be found by carefully analyzing (and testing)
    different game logic to identify the *least frequent execution* that is still
    acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the next recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading long computations over several frames with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 3**: Call methods as few times as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines allow us to write asynchronous code—we can ask a method to go off
    and calculate something, but the rest of the game can keep on running without
    having to wait for that calculation to end. Or, we can call a coroutine method
    for each frame from `Update()` and organize the method to complete part of a complex
    calculation each time it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note that coroutines are not *threads*, but they are very handy in that each
    can progress each frame further. It also allows us to write code that does not
    have to wait for certain methods to complete before another can begin.
  prefs: []
  type: TYPE_NORMAL
- en: When games start requiring complex computations, such as for artificial intelligence
    reasoning, it may not be possible to maintain acceptable game performance when
    trying to complete all calculations in a single frame—this is where coroutines
    can be an excellent solution.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe illustrates how a complex calculation can be structured into several
    pieces, each to be completed one frame at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: An excellent description of coroutines (and other Unity topics) can be
    found on Ray Pendergraph''s wikidot website [http://raypendergraph.wikidot.com/unity-developer-s-notes#toc6](http://raypendergraph.wikidot.com/unity-developer-s-notes#toc6).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To spread computations over several frames, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following script class `SegmentedCalculation` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game, and you'll see how the search for highest and lowest values in
    the array progresses in steps, avoiding undesirable delays between each new frame.![How
    to do it...](img/1362OT_11_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `randomNumbers` array of random integers is created in `Awake()`. Then,
    the `FindMinMax()` method is started as a coroutine. The size of the array is
    defined by constant `ARRAY_SIZE`, and the number of elements to process each frame
    by `SEGMENT_SIZE`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FindMinMax()` method sets initial values for *min* and *max* and begins
    to loop through the array. If the current index is divisible by the `SEGMENT_SIZE`
    (remainder 0), then we make the method display the current frame number and variable
    values and suspend execution for one frame with a `yield null` statement. For
    every loop, the value for the current array index is compared with `min` and `max`,
    and those values are updated if a new minimum or maximum has been found. When
    the loop is completed, the scripted component disables itself.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the complete Unity log text files from your system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As well as seeing log texts in the **Console** panel, you can also access the
    Unity editor log text file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mac:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/Library/Logs/Unity/Editor.log`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And access through the standard Console app
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Users\username\AppData\Local\Unity\Editor\Editor.log`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile devices (see the Unity documentation for accessing device log data)![Retrieving
    the complete Unity log text files from your system](img/1362OT_11_25.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about Unity logs files, see the online manual at [http://docs.unity3d.com/Manual/LogFiles.html](http://docs.unity3d.com/Manual/LogFiles.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Executing methods regularly but independent of frame rate with
    coroutines* recipe in this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating performance by measuring max and min frame rates (FPS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 4**: Use performance data to drive design and coding
    decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: A useful raw measurement of game performance is the maximum and minimum frame
    rate for a section of a game. In this recipe, we make use of a Creative Commons
    **Frames Per Second** (**FPS**) calculation script to record the maximum and minimum
    frame rates for a game performing mathematics calculations for each frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Evaluating performance by measuring max and min frame rates (FPS)](img/1362OT_11_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have provided C# script `FPSCounter.cs` in the `1362_11_12`
    folder. This file is the one we have modified to include the maximum and minimum
    values based on the **Do-It-Yourself** (**DIY**) frame rate calculation script
    from Annop "Nargus" Prapasapong, kindly published under Creative Commons on the
    Unify wiki at [http://wiki.unity3d.com/index.php?title=FramesPerSecond](http://wiki.unity3d.com/index.php?title=FramesPerSecond).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate and record the maximum and minimum FPS, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project, and import the `FPSCounter.cs` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `FPSCounter` script class to the **Main Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `SomeCalculations` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game for 20 to 30 seconds. On the screen, you should see the current
    average and the maximum and minimum frame rates displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the game running. You should now see in the **Console** a summary message
    stating the max and min frames per second, as shown in the following screenshot:![How
    to do it...](img/1362OT_11_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SomeCalculations` script ensures that we make Unity do something for each
    frame, in that it performs lots of calculations when the `Update()` method is
    called for each frame. There is an outer loop (loop counter `i`) of public variable
    `outerLoopIterations` iterations (which we set to `20`), and an inner loop (loop
    counter `j`), which is a random number of iterations between 2, and the value
    of public variable `innerLoopMaxIterations` (which we set to `100`).
  prefs: []
  type: TYPE_NORMAL
- en: The work for the calculations of average **Frames Per Second** (**FPS**) is
    performed by the `FPSCounter` script, which runs coroutine method `FPS()` at the
    chosen frequency (which we can change in the **Inspector**). Each time the `FPS()`method
    executes, it recalculates the average frames per second, updates the max and minimum
    values if appropriate, and, if the **Display While Running** checkbox was ticked,
    then a **GUIText** object on screen is updated with a message of the average,
    max, and min FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `OnApplicationQuit()` method in script class `FPSCounter` is executed
    when the game is terminated and prints to the console the summary max/min FPS
    message.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn off runtime display to reduce FPS processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have added an option so that you can turn off the runtime display, which
    will reduce the processing required for the FPS calculations. You just have to
    un-check the **Display While Running** checkbox in the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Turn off runtime display to reduce FPS processing](img/1362OT_11_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Identifying performance bottlenecks with the Unity performance Profiler*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identifying performance bottlenecks with Do-It-Yourself. performance profiling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying performance bottlenecks with the Unity performance Profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 4**: Use performance data to drive design and coding
    decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: As well as following general asset and code design principals, which we know
    ought to lead to improved performance, we should be aware that each game is different
    and that, in reality, the only way to know which design decisions affect performance
    the most is to collect and analyze runtime performance data. While a raw **Frames
    Per Second** (**FPS**) measurement is useful, to choose between different decisions
    having detailed information about the processing requirements for rendering and
    code execution for each frame is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity 5 **Profiler** offers a detailed breakdown of code and rendering processing
    requirements, as well as processing required by GPU, audio, and both 2D and 3D
    physics. Perhaps the most useful, it allows programmers to explicitly record data
    for named code segments. We will name our profile `MATT_SomeCalculations` and
    record and examine frame-by-frame processing requirements for our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying performance bottlenecks with the Unity performance Profiler](img/1362OT_11_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To record processing requirements using the Unity **Profiler**, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Profiler** window from the **Window** menu and ensure that the **Record**
    option is selected, and that the **Scripts** performance data is being collected,
    as shown in the following screenshot:![How to do it...](img/1362OT_11_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `ProfileCalculations` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game for 20 to 30 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the game running. You should now see in the **Profiler** panel details
    of the breakdown of processing required for the selected frame—each of the jagged
    lines in the top right of the **Profiler** panel represents the collected data
    for a frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View data for different frames by dragging the white line to a different horizontal
    position—the current frame and the total number of frames are shown at the top
    right in the form **Frame: frame / totalFrames**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have named a code profile sample, prefixed with **MATT**, we can limit
    the display of data to only samples containing that word. In the search text box
    (next to the little magnifying glass,) type `MATT`, and you should now see just
    a single row of profile data for our sample **MATT_calculations**. We can see
    that for frame 83, our code took up 1.2 percent of the processing for that frame.![How
    to do it...](img/1362OT_11_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ProfileCalculations` script ensures that we make Unity do something for
    each frame; it does lots of calculations with an inner and outer loop, just like
    in the previous FPS recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The two important statements are those that mark the beginning and ending of
    a named code sample to be recorded and presented in the **Profiler**. The `Profiler.BeginSample("MATT_calculations")`
    statement starts our named profile and it is ended with the `EndSample()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using an eye-catching prefix allows us to easily isolate our named code profile
    for analysis, using the search text box in the **Profiler** panel.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Evaluating performance by measuring max and min frame rates (FPS)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identifying performance bottlenecks with Do-It-Yourself performance profiling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying performance "bottlenecks" with Do-It-Yourself performance profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 4**: Use performance data to drive design and coding
    decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: The Unity 5 performance profiler is great, but there may be times where we wish
    to have completed control over the code we are running and how it displays or
    logs data. In this recipe, we explore how to use a freely available script for
    DIY performance profiling. While it's not quite as fancy as the graphical and
    detailed profiling of the performance profiler from Unity, it still provides low-level
    data about the time required for each frame by named parts of scripts, which is
    sufficient for making code design decisions to improve game performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying performance "bottlenecks" with Do-It-Yourself performance profiling](img/1362OT_11_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have provided C# script `Profile.cs` in the `1362_11_14`
    folder. This is the DIY profiling script from Michael Garforth, kindly published
    under *Creative Commons* on the Unify Wiki at [http://wiki.unity3d.com/index.php/Profiler](http://wiki.unity3d.com/index.php/Profiler).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To record processing requirements using Do-It-Yourself code profiling, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project, and import the `Profile.cs` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `DIYProfiling` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game for a few seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the game running. You should now see in the **Console** a summary message
    stating total processing time for our named Profile, average time, and number
    of iterations, and also the total time for which the game was run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the script is almost identical to that used with the Unity profiling
    in the previous recipe. Rather than calling the Unity **Profiler**, we call static
    (class) methods of Michael Garforth's `Profile` class.
  prefs: []
  type: TYPE_NORMAL
- en: We call `Profile` class methods `StartProfile(…)` and `EndProfile(…)` with the
    string name for what is to be analyzed (in this example, `MATT_calculations`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `OnApplicationQuit()`method is executed when the game is terminated,
    calling the `PrintResuls()` method of the `Profile` class, which prints to the
    console the summary performance information.
  prefs: []
  type: TYPE_NORMAL
- en: The `Profile` class records how many times, and how long between Start and End,
    each named profile is called, outputting summary information about these executions
    when `PrintResuls()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Evaluating performance by measuring max and min frame rates (FPS)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identifying performance bottlenecks with the Unity performance Profiler*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache GameObject and component references to avoid expensive lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 2**: Minimize actions requiring Unity to perform "reflection"
    over objects and searching of all current scene objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Reflection is when, at run time, Unity has to analyze objects to see whether
    they contain a method corresponding to a "message" that the object has received
    - an example would be `SendMessage()`. An example of making Unity perform a search
    over all active objects in a scene would be the simple and useful, but slow, `FindObjectsByTag()`.
    Another action that slows Unity down is each time we make it look up an object's
    component using `GetComponent()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache GameObject and component references to avoid expensive lookups](img/1362OT_11_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the olden days for many components, Unity offered *quick component property
    getters* such as `.audio` to reference the `AudioSource` component of a script's
    parent **GameObject**, `rigidbody` to reference the **RigidBody** component, and
    so on. However, this wasn't a consistent rule, and in other cases, you had to
    use `GetComponent()`. With Unity 5, all these *quick component property getters*
    have been removed (with the exception of `.transform`, which is automatically
    cached, so has no performance cost to use). To help game developers update their
    scripts to work with Unity 5, they introduced *Automatic Script Updating*, whereby
    (after a suitable warning to have backed up files before going ahead!) Unity will
    go through scripts replacing *quick component property getters* code with the
    standardized `GetComponent<ComponentTyle>()` code pattern, such as `GetComponent<Rigidbody>()`
    and `GetComponent<AudioSource>()`. However, while script updating makes things
    consistent, and also makes explicit all these `GetComponent()` reflection statements,
    each `GetComponent()` execution eats up valuable processing resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about Unity''s reasons for this (and the alternative *Extension
    Methods* approach they rejected; a shame—I think we''ll see them appear in a later
    version of Unity since it''s an elegant way to solve this coding situation) in
    this June 2014 blog post and manual page at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://blogs.unity3d.com/2014/06/23/unity5-api-changes-automatic-script-updating/](http://blogs.unity3d.com/2014/06/23/unity5-api-changes-automatic-script-updating/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://unity3d.com/learn/tutorials/modules/intermediate/scripting/extension-methods](http://unity3d.com/learn/tutorials/modules/intermediate/scripting/extension-methods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we'll incrementally refactor a method, making it more efficient
    at each step by removing reflection and component lookup actions. The method we'll
    improve is to find half the distance from the **GameObject** in the scene tagged
    `Player` (a **3rd Person Controller**) and 1,000 other **GameObjects** in the
    scene tagged `Respawn`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a package named `unity4_assets_handyman_goodDirt`
    containing the 3rdPersonController handyman and Terrain material `goodDirt`. The
    package is in the folder `1362_11_15`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To improve code performance by caching component lookups, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project, importing the provided Unity package `unity4_assets_handyman_goodDirt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Terrain** (size **200 x 200**, located at **-100, 0, -100**)
    and texture-paint it with **GoodDirt**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **3rdPersonController** at the center of the terrain (that is, **0, 1,
    0**). Note that this will already be tagged **Player**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Sphere** and give it the tag **Respawn**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, create a new empty prefab named **prefab_sphere**
    and drag the **Sphere** from the **Hierarchy** panel into your prefab in the **Project**
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, delete the **Sphere** from the **Hierarchy** panel (since all its properties
    have been copied into our prefab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `SphereBuilder` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the **Main Camera** selected in the **Hierarchy**, drag **prefab_sphere**
    from the Project panel in **Inspector** public variable `Sphere Prefab`, for script
    component `SphereBuilder,` as shown in the following screenshot:![How to do it...](img/1362OT_11_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class `SimpleMath` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Method 1 – AverageDistance calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following C# script class `AverageDistance` to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **Profiler** panel and ensure that **record** is selected and and that
    the script processing load is being recorded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game for 10 to 20 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Profiler** panel, restrict the listed results to only samples starting
    with `TEST`. For whichever frame you select, you should see the percentage CPU
    load and milliseconds required for **TESTING_method1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method 2 – Cache array of Respawn object transforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FindGameObjectWithTag()` is slow, so let''s fix that for the search for objects
    tagged `Respawn`. First, in C# script class `AverageDistance`, add a private `Transform`
    array variable named `sphereTransformArrayCache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `Start()` method, the statement that stores in this array references
    to the **Transform** component of all our `Respawn` tagged objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `Update()`method, start a new **Profiler** sample named **TESTING_method2**,
    which uses our cached array of games objects tagged with `Respawn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, run the game for 10 to 20 seconds and set the **Profiler** panel
    to restrict the listed results to only samples starting with `TEST`. For whichever
    frame you select, you should see the percentage CPU load and milliseconds required
    for **TESTING_method1** and **TESTING_method2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method 3 – Cache reference to Player transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That should run faster. But wait! Let''s improve things some more. Let''s make
    use of a cached reference to **Cube-Player** component''s transform, avoiding
    the slow object-tag reflection lookup altogether. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new private variable and a statement in the `Start()`method to
    assign the `Player` object''s transform in this variable `playerTransformCache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in `Update()`, add the following code to start a new **Profiler** sample
    named **TESTING_method3**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to write a new method that calculates the half distance making
    use of the cached player transform variable we have set up. So, add this new method,
    `HalfDistanceCachePlayerTransform( sphereTransformArrayCache[i] )`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Method 4 – Cache Player's Vector3 position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's improve things some more. If, for our particular game, we can make the
    assumption that the player character does not move, we have an opportunity to
    cache the player's **position** once, rather than retrieving it for each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, to find `pos1`, we are making Unity find the position `Vector3`
    value inside `playerTransform` *every time the* `Update()` *method is called.*
    Let''s cache this `Vector3` position with a variable and statement in `Start()`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, write a new half-distance method that makes use of this cached position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `Update()` method, add the following code so that we create a new
    sample for our method 4, and call our new half-distance method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Method 5 – Cache reference to SimpleMath component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That should improve things again. But we can still improve things—you''ll notice
    in our latest half-distance method that we have an explicit `GetComponent()` call
    to get a reference to our `mathObject`; this will be executed *every time the
    method is called.* Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cache this scripted component reference as well to save a `GetComponent()`
    reflection for each iteration. We''ll declare a variable `mathObjectCache`, and
    in `Awake()`, we will set it to refer to our `SimpleMath` scripted component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s write a new half-distance method that uses this cached reference to
    the math component `HalfDistanceCacheMathComponent(i)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `Update()` method, add the following code so that we create a new
    sample for our *method5* and call our new half-distance method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Method 6 – Cache array of sphere Vector3 positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've improved things quite a bit, but there is still a glaring opportunity
    to use caching to improve our code (if we can assume that the spheres do not move,
    which seems reasonable in this example). At present, for every frame and every
    sphere in our half-distance calculation method, we are asking Unity to retrieve
    the value of the `Vector3` position property in the transform of the current sphere
    (this is our variable `pos2`), and this position is used to calculate the distance
    of the current sphere from `Player`. Let's create an array of all those `Vector3`
    positions so that we can pass the current one to our half-distance calculation
    method and save the work of retrieving it so many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new private variable and a statement inside our existing loop
    in the `Start()` method to assign each sphere''s `Vector3` transform position
    in the array `spherePositionArrayCache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s write a new half-distance method that uses this array of cached positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `Update()`method, add the following code so that we create a new
    sample for our *method6* and call our new half-distance method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **Profiler** panel and ensure that **record** is selected and script
    processing load is being recorded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game for 10 to 20 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Profiler** panel, restrict the listed results to only samples starting
    with `TEST`. For whichever frame you select, you should see the percentage CPU
    load and milliseconds required for each method (lower is better for both these
    values!). For almost every frame, you should see how/if each method refined by
    caching has reduced the CPU load.![Method 6 – Cache array of sphere Vector3 positions](img/1362OT_11_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe illustrates how we try to cache references once, before any iteration,
    for variables whose value will not change, such as references to `GameObjects`
    and their components, and, in this example, the `Transform` components and `Vector3`
    positions of objects tagged `Player` and `Respawn`. Of course, as with everything,
    there is a "cost" associated with caching, and that cost is the memory requirements
    to store all those references. This is known as the **Space-Time Tradeoff**. You
    can learn more about this classic computer science speed versus memory tradeoff
    at [https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff](https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff).
  prefs: []
  type: TYPE_NORMAL
- en: In methods that need to be performed many times, this removing of implicit and
    explicit component and object lookups may offer a measurable performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Two good places to learn more about Unity performance optimization techniques
    are from the *Performance Optimization* web page in the Unity script reference
    and from Unity''s Jonas Echterhoff and Kim Steen Riber Unite2012 presentation
    *Performance Optimization Tips and Tricks for Unity*. Many recipes in this chapter
    had their origins from suggestions in the following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/410/Documentation/ScriptReference/index.Performance_Optimization.html](http://docs.unity3d.com/410/Documentation/ScriptReference/index.Performance_Optimization.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://unity3d.com/unite/archive/2012](http://unity3d.com/unite/archive/2012)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Improving efficiency with delegates and events and avoiding SendMessage!*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identifying performance bottlenecks with the Unity performance Profiler*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identifying performance bottlenecks with Do-It-Yourself performance profiling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance with LOD groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 5**: Minimize the number of draw calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Detailed geometry and high-resolution texture maps can be a double-edged sword:
    they can deliver a better visual experience, but they can impact negatively on
    the game''s performance. **LOD groups** address this issue by replacing high-quality
    objects by simplified versions whenever that object takes up a smaller portion
    of the screen than necessary for a high-quality version to make a significant
    difference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will use a **LOD group** to create a game object featuring
    two different levels of detail: a high-quality version for whenever the object
    takes up more than 50 percent of the screen and a low-quality version for the
    times it takes up less than that amount. We would like to thank Carl Callewaert,
    from Unity, for his demonstration of the LOD Group functionality, which has informed
    this recipe in many ways.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving performance with LOD groups](img/1362OT_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared two prefabs for the high- and low-quality
    versions of the game object. They share the same dimensions and transform settings
    (position, rotation, and scale), so that they can replace each other seamlessly.
    Both prefabs are contained within the package named `LODGroup`, available in the
    `1362_11_16` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a LOD group, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the **LODGroup** package into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Project** view, inside the **LOD** folder, drag the **batt-high**
    prefab into the **Hierarchy** view. Then, do the same for the **batt-low** prefab.
    Make sure that they are placed at the same **Position** (**X**: **0**; **Y**:
    **0**; **Z**: **0**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Create** drop-down menu in the **Hierarchy** view, create a new empty
    game object (**Create** | **Create Empty**). Rename it `battLOD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **LODGroup** component to **battLOD** (menu **Component** | **Rendering**
    | **LODGroup**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **battLOD** object, and, from the **Inspector** view, **LODGroup**
    component, right-click on **LOD 2** and delete it (since we''ll have only two
    different LODs: **LOD 0** and **LOD 1**), as shown in the following screnshot:![How
    to do it...](img/1362OT_11_10.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **LOD 0** area, click on the **Add** button, and select the **batt-high**
    game object from the list. A message about reparenting objects will appear. Select
    **Yes, Reparent**.![How to do it...](img/1362OT_11_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **LOD 1** section, click on **Add**, and select the **batt-low**
    object. Again, chose **Yes, Reparent** when prompted.![How to do it...](img/1362OT_11_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the limits of the LOD renderers to set them as: **LOD 0: 100%**, **LOD
    1**: **50%**, **Culled: 1%.** That will make Unity render **bat-high** whenever
    it occupies 51 percent to 100 percent of the screen space, **batt-low** when 2
    percent to 50 percent, and will not render anything if 1 percent or less.![How
    to do it...](img/1362OT_11_13.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the scene's camera toward the **battLOD** object and back. You will notice
    how Unity swaps between the high- and low-definition LOD renderer as it occupies
    more or less than 50 percent of the screen's space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have populated the LOD renderers with the appropriate models, the **LODGroup**
    component will select and display the right renderer based on how much of the
    screen's percentage the object takes up, or even display nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding more LOD renderers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add more LOD renderers by right-clicking on an existing LOD renderer
    and selecting **Insert Before** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: Fading LOD transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you want to minimize the *popping* that occurs when renderers are swapped,
    you can try changing the parameter **Fade Mode** from **None** to **Percentage**
    or **Crossfade**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the next recipe in this chapter for more information
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance through reduced draw calls by designing for draw call
    batching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization principal 5**: Minimize the number of draw calls.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to minimize draw calls is by prioritizing design decisions to qualify
    objects for Unity's *Static* and *Dynamic draw call batching*.
  prefs: []
  type: TYPE_NORMAL
- en: The more CPU-efficient batching method is Unity's **static batching**. It allows
    reduction of draw calls for any sized geometry. If that is not possible, then
    the next best thing is **dynamic batching**, which again allows Unity to process
    together several moving objects in a single draw call.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a cost—batching uses memory, and static batching uses more
    memory than dynamic memory. So, you can improve performance with batching, but
    you'll be increasing the scene's memory "footprint." As always, use memory and
    performance profiling to evaluate which use of techniques is best for your game
    and its intended deployment device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to make possible **static batching** and
    **dynamic batching**.
  prefs: []
  type: TYPE_NORMAL
- en: Static batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make possible Unity **static batching**, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that models share the same material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark models as **Static**, as shown in the following screenshot:![Static batching](img/1362OT_11_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Objects that can be safely marked as **Static** include environment objects
    that won't move or be scaled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many techniques can be used to ensure models share the same material including:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using textures by directly painting vertices of the model (useful links
    for this are provided in the *There's more…* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the number of objects textured with exactly the same texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificially enabling objects to share the same texture by combining multiple
    textures into a single one (texture atlassing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximizing script use of `Renderer.sharedMaterial` rather than `Renderer.material`
    (since use of `Render.material` involves making a copy of the material and, therefore,
    disqualifies that GameObejct for batching)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, both static and dynamic batching only work with objects that use the
    same material, so all methods above apply equally for making dynamic batching
    possible as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make possible Unity **dynamic batching**, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that models share the same material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the number of **vertex attributes** below 900 for each mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the group of objects to quality for dynamic batching to use the same transform
    scale (although non-uniform scaled models can still be batched).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If possible, have dynamic lightmapped objects point to the same lightmap location
    to facilitate dynamic batching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid the use of multi-pass shaders and real-time shadows if possible, since
    both of these prevent dynamic batching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To calculate the number of **vertex attributes**, you need to multiply the number
    of vertices by the number of attributes used by the **Shader**. For example, for
    a **Shader** using three attributes (vertex position, normal, and UV), it would
    mean that a model must have less than 300 vertices to keep the total number of
    attributes below 900 to qualify for dynamic batching.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the need for textures by vertex painting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about this topic, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blender:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.blender.org/index.php/Doc:2.6/Manual/Materials/Special_Effects/Vertex_Paint](http://wiki.blender.org/index.php/Doc:2.6/Manual/Materials/Special_Effects/Vertex_Paint)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3D Studio Max:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://3dmax-tutorials.com/Vertex_Paint_Modifier.html](http://3dmax-tutorials.com/Vertex_Paint_Modifier.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Maya: free Vertex Chameleon plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://renderheads.com/portfolio/VertexChameleon/](http://renderheads.com/portfolio/VertexChameleon/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Information sources about reducing textures and materials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about this topic, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity manual page for Draw Call Batching:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/DrawCallBatching.html](http://docs.unity3d.com/Manual/DrawCallBatching.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Paladin Studios:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/](http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Nvidia white paper on texture atlassing to increase draw call batching opportunities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://http.download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf](http://http.download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Nvidia free texture tools and Photoshop plug-in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.nvidia.com/object/texture_atlas_tools.html](http://www.nvidia.com/object/texture_atlas_tools.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Improving performance with LOD groups* recipe in this chapter
    for more information
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced some extra features and a range of approaches
    to improve game performance and collect performance data for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The first three recipes in this chapter provide some ideas for adding some extra
    features to your game (pausing, slow motion, and securing online games). The rest
    of the recipes in this chapter provide examples of how to investigate and improve
    the efficiency and performance of your game.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as there are many components in a game, there are many parts of a game
    where processing *bottlenecks* may be found and need to be addressed to improve
    overall game performance. Some additional suggestions and further reference sources
    are now provided to provide a launching pad for your further exploration of the
    issues of optimization and performance, since such topics could take up a whole
    book rather than just one chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Game audio optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mobile devices have considerably less memory and processing resources than consoles,
    desktops, or even laptops, and often raise the biggest challenges when it comes
    to game audio. For example, the iPhone can only decompress one audio clip at a
    time, so a game may suffer processing spikes (that is, slow down game frame rate)
    due to audio decompression issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Paladin Studios recommend the following audio file compression strategies for
    mobile games:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Short Clips**: Native (no compression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Longer clips** (or ones that loop): Compressed in memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Music**: Stream from disc'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files which consistently cause CPU spikes**: Decompress on load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information about this topic, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity manual audio:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Paladin Studios:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/](http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apple developers audio page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html](https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Physics engine optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For some strategies relating to physics, you might consider to improve performance
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If possible, use **geometric primitive colliders** (2D box/2D circle/3D box/3D
    sphere/3D cylinder):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have multiple primitive colliders
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also have primitive colliders on child objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as you have a rigid body on the root object in the object hierarchy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid **2D polygon** and **3D mesh** colliders:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are much more processor intensive
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try increasing the delay between each `FixedUpdate()` method call to reduce
    physics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although not to the point where user experience or game behavior is below acceptable
    quality!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wherever possible, start off rigid bodies in sleep mode (so that they don''t
    require physics processing until woken up by code or a collision). See the following
    Unity script reference pages for making objects go to sleep and wake up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html](http://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html](http://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Physics engine optimization](img/1362OT_11_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: More tips for improving script efficiency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some code strategies you might consider to improve performance include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use **Structs** rather than **Classes** to improve speed up processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wherever possible, use simple arrays of primitive types rather than **ArrayLists**,
    **Dictionaries,** or more complex collection classes. A good article about choosing
    the most appropriate collection in Unity can be found at [http://wiki.unity3d.com/index.php/Choosing_the_right_collection_type](http://wiki.unity3d.com/index.php/Choosing_the_right_collection_type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raycasting is slow, so avoid performing it every frame, for example, use coroutines
    to only raycast every 3rd or 10th frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding objects is slow, so avoid finding objects in `Update()` or inner loops,
    and you can have objects set up a `public static` variable to allow quick instance
    retrieval, rather than using a `Find(…)` method. Or you could use the Singleton
    design pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using `OnGUI()`, since it is called every frame just like `Update()`;
    this is much easier to avoid now with the new Unity 5 UI system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sources of more wisdom about optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several other sources that you might want to explore to learn more
    about game optimization topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity general mobile optimization page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/MobileOptimisation.html](http://docs.unity3d.com/Manual/MobileOptimisation.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'X-team Unity best practices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://x-team.com/2014/03/unity-3d-optimisation-and-best-practices-part-1/](http://x-team.com/2014/03/unity-3d-optimisation-and-best-practices-part-1/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Code Project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.codeproject.com/Articles/804021/Unity-and-Csharp-Performance-Optimisation-tips](http://www.codeproject.com/Articles/804021/Unity-and-Csharp-Performance-Optimisation-tips)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'General graphics optimization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Learn more about mobile physics at Unity''s iPhone optimization physics page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html](http://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Published articles that discuss premature optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several articles discussing Donald Knuth''s famous quotation about
    premature optimization being "evil":'
  prefs: []
  type: TYPE_NORMAL
- en: 'Joe Duffy''s blog:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/](http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"When is optimization premature?" Stack Overflow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://stackoverflow.com/questions/385506/when-is-optimisation-premature](http://stackoverflow.com/questions/385506/when-is-optimisation-premature)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*The Fallacy of Premature Optimization*, Randall Hyde (published by ACM), source:
    Ubiquity Volume 10, Issue 3, 2009:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://ubiquity.acm.org/article.cfm?id=1513451](http://ubiquity.acm.org/article.cfm?id=1513451)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sources of more about Game Managers and the State Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learn more about implementing the State Pattern and Game Managers in Unity
    from the following sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://rusticode.com/2013/12/11/creating-game-manager-using-state-machine-and-singleton-pattern-in-unity3d/](http://rusticode.com/2013/12/11/creating-game-manager-using-state-machine-and-singleton-pattern-in-unity3d/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/thefuntastic/Unity3d-Finite-State-Machine](https://github.com/thefuntastic/Unity3d-Finite-State-Machine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
