- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reasoning about Types Using Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered some of the basics of how metaprogramming can benefit
    you, its core concepts, and a real-world example, it’s time to look inside the
    .NET runtime and see how we can leverage its power.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at the implicit metadata provided by the
    compiler and the runtime. We’ll see how we can collect all types in a running
    system and use it for discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly discovery in the running process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging library metadata to get project-referenced assemblies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how you can use the powerful
    APIs of the .NET runtime to reason about the types already in the system. You’ll
    learn how this can then be applied to make a more elastic and dynamic code base
    that can grow and ensure its maintainability is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to this chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4))
    and builds on top of the **Fundamentals** code found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: Assembly discovery in the running process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET, everything we compile ends up inside what is called an **assembly**.
    This is the binary that holds the compiled code in the form of **Intermediate
    Language** (**IL**). Alongside this, there is metadata that goes with it to identify
    types, methods, properties, fields, and any other symbols and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: All of these artifacts are discoverable through APIs, and it all starts with
    the **System.Reflection** namespace. Within this namespace, there are APIs that
    allow you to reflect on what’s running. In other languages, this is often referred
    to as **introspection**.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at any instance of any type you’ll see that there is always a **GetType()**
    method you can call. This is part of the reflection capabilities and is implemented
    in the base type of **Object**, which all types implicitly inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: The **GetType()** method returns a **Type** type that describes the capabilities
    of the particular type – its fields, properties, methods, and more. It also holds
    information about what possible interfaces it implements or a base type it is
    inheriting from. These are very powerful constructs that we will leverage later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of starting with individual types, let’s take a step back and see how,
    from no type, we can discover what we have in our running process.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the types in the **System.Reflection** namespace is **Assembly**. This
    is the type representing an assembly, typically a **.dll** file containing the
    IL code. On the **Assembly** type, there are a few static methods. We want to
    focus on one particular method: **.GetEntryAssembly()**. This method lets us,
    at any time, get the assembly that was the starting point, the entry point that
    the .NET runtime called to start our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a folder called **Chapter4**. For this chapter, we will create
    a few projects, so let’s start by creating another folder called **AssemblyDiscovery**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change into this folder in your command-line interface and create a new console
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will set up the necessary artifacts for the project. Open the **Program.cs**
    file and replace its content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is accessing the **GetEntryAssembly()** static method on **Assembly**
    to get the assembly that serves as the entry point of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this program now, you should get an output that is similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This just prints out the name of the assembly, its version, information about
    the culture the assembly is for, and, if the assembly was signed, its public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the entry assembly, we can now start looking at what assemblies have been
    referenced. Replace the code in **Program.cs** with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code gets the referenced assemblies from the entry assembly and prints
    them out. You should be see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since we haven’t explicitly referenced any assemblies, we only see **System.Runtime**,
    **System.Consol**, and **System.Linq** as the available assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: This is all very basic but demonstrates the starting point of reasoning about
    your applications and what they’re built from. But we can do so much more.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging library metadata to get project referenced assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are going to gather metadata across a running process, chances are that
    you’re only interested in the assemblies that are part of your solution and not
    all the .NET framework libraries or third-party libraries. There is a performance
    impact of looking through all assemblies for metadata, so filtering down might
    be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET projects, we can add package references, typically from sources such
    as **NuGet** or your own package sources, but we can also add local project references.
    These are references to other **.csproj** files representing something that we
    want to package in its own assembly. Inside a **.csproj** file, you can identify
    the different references by their XML tags – **<PackageReference/>** or **<ProjectReference/>**.
    Inside Visual Studio or Rider, you will typically see these tags in the explorer
    view as well.
  prefs: []
  type: TYPE_NORMAL
- en: The **C#** compiler produces additional metadata to distinguish the different
    types of references all projects have. This can be leveraged in code.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s build a reusable library that we can leverage and expand on throughout
    the following chapters. Let’s call this project **Fundamentals**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder at the root of where you started building out the chapters
    and call it **Fundamentals**. Change into this folder and create the new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a new project and adds a file called **Class1.cs**. Remove this
    file as we don’t need it at all.
  prefs: []
  type: TYPE_NORMAL
- en: In order for us to be able to get to the proper metadata enabling us to distinguish
    between package or project references, we need to add a NuGet package reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The package we’re looking for is **Microsoft.Extensions.DependencyModel**.
    In the terminal, you add the reference by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the package, we want to create a system that is capable of
    discovering project references and any additional package references we explicitly
    tell it to load. From these, we want to get all the types so that we can start
    making some serious discoveries about our system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by creating a file called **Types.cs**. Then add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Within this new class, we want to be able to expose all the discovered types.
    Before we can do that, we need to discover them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the **Types.cs** file before the namespace declaration, add the
    following **using** statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a private method called **DiscoverAllTypes()** and start by making it look
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will get the entry assembly and then leverage **DependencyContext**
    from the package you referenced. This model contains more metadata around the
    assemblies (or libraries, as they are called in the **DependencyModel** extension).
    The last thing we do is to load the assemblies we find. For the most part, the
    assemblies are already loaded. But this will guarantee they are loaded and return
    an instance of the assembly. It won’t load it again if it is already loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is that we have all the project-referenced assemblies in
    an array. That might not be all you want. If for instance you’re maintaining a
    set of common packages that are shared within your organization and you want to
    discover from these, a common pattern is to have your organization name as part
    of the assembly name, typically at the beginning. That means it’s easy to add
    something that includes all assemblies that are prefixed with a certain string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the signature for the **DiscoverAllTypes()** method to be able to include
    a collection of assembly prefixes for collecting types for discovery:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **DiscoverAllTypes()**method, add the following at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code looks at the same **RuntimeLibraries**, but this time specifically
    for assemblies that start with the prefixes. There is also error-handling functionality
    here: some assemblies can’t be loaded with the regular **Assembly.Load()** method
    and we just ignore them, as they are not of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we call **.ToList()** at the end of the LINQ query, we can easily combine
    the two collections of assemblies and all the types from all the loaded assemblies
    and return them from the **DiscoverAllTypes()** method. Add the following at the
    end of the **DiscoverAllTypes()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have collected all assemblies and their types and returned them,
    it’s time to expose them to the outside world. We do this by adding a public property
    returning **IEnumerable** of **Type**. We don’t want this to be potentially mutated
    from the outside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last piece of the puzzle for the **Types** class is to add a constructor.
    We want the constructor to take any assembly prefixes for the **DiscoverAllTypes()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now encapsulated a type registry that we can leverage for other use
    cases. Now that we have some basic building blocks. Let’s go ahead and create
    a multi-project application.
  prefs: []
  type: TYPE_NORMAL
- en: Business app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have some basic building blocks. Lets go ahead and create a multi
    project application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the **Chapter4** folder, create a folder called **BusinessApp**. In
    this folder, we’re going to create multiple projects that will make up the application.
    Within the **BusinessApp** folder, create one folder called **Domain** and another
    called **Main**. The **Domain** folder will represent the domain logic of our
    application and should be a class library project. Go ahead and create a new .NET
    project in the **Domain** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the **Class1.cs** file that is generated. Then, in the **Main** folder,
    we want to create a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the **Main** project you should now add references to the **Fundamentals**
    project and also the **Domain** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Program.cs** file, inside the **Main** project, replace the content
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code now leverages the **Types** class we put into **Fundamentals**, which
    will look at all our project reference assemblies and give us all the types. Running
    this should give you an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that some of these types aren’t types you have created at all.
    These are types the C# compiler has put into the projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go and add a folder called **Employees** in the **Domain** project and within
    it, create a file called **RegisterEmployee.cs** and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the **Main** project again, you should now see the added type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have the beginning of a strong foundation for working with types.
    We just need to improve its capabilities to make it even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the **Types** class, we now have a raw approach to get all the types in
    a running system. This can be very helpful on its own as you can now use this
    to perform **Language Integrated Query** (**LINQ**) queries on top of finding
    types that match specific criteria you’d be interested in.
  prefs: []
  type: TYPE_NORMAL
- en: A very common scenario in code in general is that we have base classes or interfaces
    that represent characteristics of known artifact types in our system and we create
    specialized versions that override virtual or abstract methods, or just implement
    a specific interface to represent what it is. This is the power of object-oriented
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are adding additional implicit metadata into our systems that
    we can leverage. For instance, in [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041),
    *Demystifying through Existing Real-World Examples*, we looked at how ASP.NET
    does this by discovering all classes that have **Controller** as their base type.
  prefs: []
  type: TYPE_NORMAL
- en: From my own experience, this is the typical pattern that has been used the most
    on the projects I’ve been doing these things on. In fact, it is so common that
    it is a good idea to optimize the lookup of types on this to avoid the complexity
    when looking up types based on inheritance. An optimized lookup will improve performance
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be a bit too verbose to do a full walkthrough of the full lookup cache
    mechanism as there are quite a few moving parts to it. You can find the full code
    here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface represented by **ContractToImplementorsMap** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the API of **IContractToImplementorsMap** is to give a fast way
    of getting implementations of a specific type, be it a base class or an interface.
    The implementation of **IContractToImplementorsMap** takes all types it is fed
    and maps these correctly in this cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that there is a method called **Feed()**. We will have to call
    this in our **Types** class. In addition, we want to have some methods that make
    discovering different types a lot more helpful; for instance, the following methods
    would be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These methods allow us to find methods that implement a specific interface or
    inherit from a base type. They allow us to find a single instance or multiple
    implementors, based on type either by generic parameter or by passing in the **Type**
    object. Also for convenience, there is a method for finding a type by its name.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full implementation in the **Fundamentals** folder at the link
    specified at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Back to business
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving back to our business sample, let’s add a second class in the **Employee**
    folder within the **Domain** project called **SetSalaryLevelForEmployee.cs**.
    Make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The **RegisterEmployee** and **SetSalaryLevelForEmployee** classes both represent
    the data we need to perform the specific actions in our domain business logic.
    These types of actions are often called commands. If we wanted to discover all
    of our commands, we could create an empty interface that we can use for all our
    commands to implement to make it easy for us to discover them. These types of
    empty interfaces used in this way are often referred to as marker interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Fundamentals** project, add a file called **ICommand.cs** and make
    it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to have a project reference to the **Fundamentals** project from
    the **Domain** project. Run the following from the **Domain** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new **ICommand** interface, we can mark the **RegisterEmployee** and
    **SetSalaryLevelForEmployee** commands with it. Open the files for both **RegisterEmployee**
    and **SetSalaryLevelForEmployee** and add the following **using** statements at
    the top of each of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For both of the class definitions, add **: ICommand** at the end to make them
    implement the **ICommand** interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program.cs** file in the **Main** project and change it with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the **Main** project should now yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Effectively we have now reproduced the necessary infrastructure to mimic what
    ASP.NET is doing for its discovery of items. With this, we have opened our software
    to be more open to expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Domain concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most boring types in most programming languages are the primitives that
    come with the language; typically, your integers, booleans, strings, and such.
    They offer absolutely no interesting or meaningful metadata. They are nothing
    but very primitive.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to fall into the trap of using these and end up with primitive obsession.
    Not only are you losing valuable metadata, but it also creates code that can at
    times be unclear and also potentially be error prone as two properties of the
    same primitive type are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: For applications, there is a great opportunity to move away from primitives
    and bring back meaning to your domain by encapsulating the primitives into meaningful
    types in your domain.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this is that you’ll not only make your code more readable but
    also understandable and less ambiguous. Doing so moves you away from being primitive-obsessed
    to a place where you will get compiler errors if you do something wrong, putting
    developers on the right foot from the start. On top of all this, you’ll also be
    bringing in tons of metadata that can be leveraged.
  prefs: []
  type: TYPE_NORMAL
- en: Key characteristics of primitives are that they are value types. This means
    you can have two instances of the same value and equality checks would indicate
    that they are the same. In **C# 9.0**, we got a new construct called **record**.
    This enables us to create types that are complex types but bare the same characteristics
    as value types. Comparing two complex **record** types with the same values on
    them will be considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce a base type that can be used for concepts. In the **Fundamentals**
    project, add a file called **ConceptAs.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This implementation gives you a way to encapsulate domain concepts. It’s built
    using generics letting you specify the inner type of the value the concept is
    representing. It is strict on not allowing null values within the encapsulation.
    If you want to allow null values in your code, it should not be within the concept
    but rather on the instance of the concept. Further, the implementation provides
    a convenience operator for automatic conversion to the primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when you’re working with databases or you are transferring data across
    the wire in different formats, you want to strip away the concept wrapper and
    just get the primitive. Having the common base type is then a fantastic piece
    of type information that these serializers can work with.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Fundamentals** link that was at the beginning of the chapter, you’ll
    find an example of how to create a **JsonConverter** for **System.Text.Json**
    that will automatically convert any implementations of a concept to the underlying
    value during serialization and back to the concept type when deserializing. With
    the **ConceptAsJsonConverterFactory** implementation in the same location in the
    **Fundamentals** link, you’ll see that it recognizes whether a type can be converted
    if it is a concept based on the **ConceptAs** base type and creates the correct
    converter to serialize and deserialize the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **ConceptAs** construct, we can now go and create domain-specific
    implementations. As you’ll find in the code for this chapter ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp)),
    you can create specific concepts. For instance, for the **RegisterEmployee** command
    we created earlier, instead of just using primitives, you can create specific
    types like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can alter **RegisterEmployee** from before to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will remove any potential mistakes in the code. There is no way you could
    accidentally put **FirstName** into **LastName** or vice versa, as the compiler
    will tell you they’re not of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With something like a concept in place, we are really starting to enrich our
    application code with meaningful metadata. This creates new opportunities. As
    mentioned earlier for serialization, by having the base type that everything uses,
    we can easily handle serialization in one place for concept types. This is what
    we mean when we talk about cross-cutting concerns: creating constructs or behavior
    once that can be applied across multiple things, automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: The possibilities are endless with these things. We could automatically create
    validation rules that are applied for the type whenever it is being used. Or we
    could go ahead and apply authorization policies based on types when they are used.
    For the command pattern and a powerful pipeline-based framework such as ASP.NET,
    this means we can go ahead and create action filters or middleware that can be
    injected into the pipeline that deals with these things automatically – just because
    we now have the metadata we need.
  prefs: []
  type: TYPE_NORMAL
- en: Take security, the one thing you really want to get right. Don’t get us wrong,
    we aim to get everything we do right – but security is the one thing you don’t
    want to mess around with. With the richness of the type system and all the metadata
    that goes with it, you gain access to some great opportunities to make it simpler
    for developers to do the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that could be done, for instance, is creating authorization policies
    based on namespaces. If you have a command coming in and it belongs to a namespace
    that requires a certain role or claim for the user, you could do that check in
    one place, and by convention, just let developers drop commands or other artifacts
    into the correct place and they’d be secure.
  prefs: []
  type: TYPE_NORMAL
- en: Compliance is another area you really want to get right. It can be extremely
    costly if your software is not compliant. Probably the most talked-about compliance
    law over the last few years has been the EU regulation called **GDPR**. If you’re
    not compliant with this, you could end up being fined.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea of the GDPR is to protect the privacy of the end users of computer
    systems. A lot of systems collect what is known as **Personally Identifiable Information**,
    or **PII** for short. Things such as your name, address, birth date, social security
    number, and a lot more are classified as PII. There is also a requirement for
    transparency for the end users to know what data you have on them and also to
    know the reason for collecting the data. If your company gets audited, you have
    to also show what type of data you’re collecting in a report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on what you just learned about concepts, we can take it even further
    and create a specialized version of the base **ConceptAs<>** type. Let’s call
    it **PIIConceptAs<>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it inherits from **ConceptAs<>**, giving us the opportunity
    to create serializers and other tooling around this base type once, but it adds
    metadata saying this is a specialized concept for PII.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime in your application, you can quite easily present to the user all
    this information, as well as to any auditor or law enforcement agency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the **SocialSecurityNumber** type we made into a concept earlier. Change
    that to be **PIIConceptAs<>** instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the code, it doesn’t take much to enrich it with metadata
    that can be leveraged. And with the powerful type discovery you built at the beginning
    of the chapter, you now have the power to quite easily create a simple console
    report of all this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the code does is do a LINQ query collecting all properties in
    the system from all types that are of the **PIIConceptAs<>** type. As you can
    see, it uses an extension method, which is part of the fundamentals ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
    Since it selects all the properties with **.SelectMany()**, we group it together
    based on the declaring type. Then it just loops through all the types and then
    all the properties and printing out the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With a fairly low amount of code, we’ve gone from having no additional metadata
    to a much richer model that opens up the opportunity of applying logic in our
    code across the board. In fact, with it, we’re future-proofing our code to a certain
    extent. We could come back to it at a later stage and decide we want to change
    security. Without changing the actual code at all, we could just apply a new rule
    based on the metadata we already have. This is powerful and makes for flexible,
    extensible, and highly maintainable systems.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle applied
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **open/closed principle** is a principle credited to Bertrand Meyer after
    its appearance in his 1988 book called *Object-Oriented Software Construction*.
    This is a principle regarding types we can apply in our software:'
  prefs: []
  type: TYPE_NORMAL
- en: A type is open if it can be extended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type is closed when it is available to other types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes in C# are open for extension by default. We can inherit from them and
    add new meanings to them. But the base class we’re inheriting from should be closed,
    meaning that there shouldn’t be any need for changes in the base type for the
    new type to work.
  prefs: []
  type: TYPE_NORMAL
- en: This helps us design our code for extensibility and keep responsibilities in
    the right place.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a step back, we can apply some of this same thinking on the system level.
    What if our systems can just be extended with new capabilities without having
    to add configuration at the heart of a type for it to know about the additions?
  prefs: []
  type: TYPE_NORMAL
- en: This type of thinking is what we did earlier with **ICommand** and the implementations.
    The two commands we added were not known by any parts of the system, but by virtue
    of implementing the **ICommand** interface, we could see both types through an
    introspective of our system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the power of looking inward into our
    running process and collecting all the referenced assemblies and all the types
    of these assemblies. We’ve looked at how we can leverage even more metadata to
    gain access to the types of reference the assemblies are, be they package references
    or project references.
  prefs: []
  type: TYPE_NORMAL
- en: From this, we are empowered to start reasoning about types in a more meaningful
    way and really take advantage of the type system. Interfaces can serve as a very
    powerful method to mark types. The interfaces can, of course, enforce implementations
    of members that need to be there, but they can also just act as empty marker interfaces,
    serving as a way to bring explicit metadata into the assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into how we can make full use of custom attributes
    to provide explicit metadata for your applications.
  prefs: []
  type: TYPE_NORMAL
