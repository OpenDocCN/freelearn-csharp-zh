- en: Routing System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由系统
- en: This chapter describes the routing functionalities of ASP.NET Core. The routing
    part of the framework is designed to provide a dynamic routing system that's fully
    customizable and overridable to cover most of the use cases of a web service.
    Here, we will discover how to use *conventional* and *attribute routing* approaches,
    and then we will dig into the use of routing constraints in order to match complex
    rules and provide higher customization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 ASP.NET Core 的路由功能。框架的路由部分旨在提供一个完全可定制和可覆盖大多数网络服务用例的可动态路由系统。在这里，我们将了解如何使用*传统*和*属性路由*方法，然后我们将深入研究使用路由约束来匹配复杂规则和提供更高定制的使用方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A brief overview of the routing system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由系统简要概述
- en: Conventional routing versus attribute routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统路由与属性路由的比较
- en: Binding routing parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定路由参数
- en: Routing constraints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由约束
- en: Custom attribute routing and custom routing constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性路由和自定义路由约束
- en: The topics covered in this chapter provide some basic knowledge around the routing
    system of ASP.NET Core and how to use the routing engine of ASP.NET Core to cover
    all the use cases that are needed by our web service.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题为 ASP.NET Core 的路由系统提供了一些基本知识，以及如何使用 ASP.NET Core 的路由引擎来覆盖我们网络服务所需的所有用例。
- en: Overview of the routing system
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由系统概述
- en: 'The routing system of ASP.NET Core maps an incoming request to a *route handler*.
    In ASP.NET Core, the `Startup` class is responsible for configuring the routes
    that are needed by the application. Furthermore, the routing functionalities of
    ASP.NET Core are implemented using a middleware approach. Let''s take a closer
    look at the `Startup` class and how it initializes the routing system:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的路由系统将传入请求映射到一个*路由处理程序*。在 ASP.NET Core 中，`Startup` 类负责配置应用程序需要的路由。此外，ASP.NET
    Core 的路由功能是通过中间件方法实现的。让我们更详细地看看 `Startup` 类以及它是如何初始化路由系统的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code uses two extension methods: `UseRouting` and `UseEndpoints`.
    These methods were introduced in the latest release of ASP.NET Core. In the previous
    version of the framework, the routing system was initialized with the `UseMvc`
    extension method, which is now deprecated. The `UseRouting` extension method is
    used to define where, in the middleware pipeline, the routing decisions are made.
    On the other side, the `UseEndpoints` extension method declares the mapping of
    effective routes. For example, in the preceding code snippet, the `Startup` class
    uses the `MapControllers()` extension method to map the controller routes and
    declares the default routing convention that''s implemented by ASP.NET Core.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了两个扩展方法：`UseRouting` 和 `UseEndpoints`。这些方法是在 ASP.NET Core 的最新版本中引入的。在框架的先前版本中，路由系统是通过
    `UseMvc` 扩展方法初始化的，现在已弃用。`UseRouting` 扩展方法用于定义在中间件管道中路由决策的位置。另一方面，`UseEndpoints`
    扩展方法声明了有效路由的映射。例如，在前面的代码片段中，`Startup` 类使用 `MapControllers()` 扩展方法映射控制器路由并声明了 ASP.NET
    Core 实现的默认路由约定。
- en: 'To summarize, when the `Startup` class executes the `UseRouting` and `UseEndpoints`
    extension methods, ASP.NET Core adds a new `EndpointRoutingMiddleware` class to
    mark the routing point and `EndpointMiddleware` in the pipeline, which describes
    our routes. The preceding calls can be summarized as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当 `Startup` 类执行 `UseRouting` 和 `UseEndpoints` 扩展方法时，ASP.NET Core 在管道中添加了一个新的
    `EndpointRoutingMiddleware` 类来标记路由点，以及 `EndpointMiddleware` 来描述我们的路由。前面的调用可以总结如下：
- en: '![](img/cf3f48b4-907b-4e22-a636-b9c151f486d6.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf3f48b4-907b-4e22-a636-b9c151f486d6.png)'
- en: 'Furthermore, it is possible to define new *route templates* inside our `Startup`
    class using the following syntax:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用以下语法在 `Startup` 类内部定义新的*路由模板*：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This implementation creates a new *route template* that maps a generic route
    such as `https://myhostname/mycontroller/myaction`with a controller named `MyController`
    and an action named `MyAction`. This way of defining routing is called **conventional
    routing**, in the sense that it establishes a convention between our handlers
    (the controllers) and the URI system. We will discuss conventional routing in
    more detail in the next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现创建了一个新的*路由模板*，将一个通用的路由，如`https://myhostname/mycontroller/myaction`，映射到一个名为`MyController`的控制器和一个名为`MyAction`的操作。这种定义路由的方式被称为**传统路由**，在这种意义上，它在我们处理程序（控制器）和
    URI 系统之间建立了一种约定。我们将在下一节中更详细地讨论传统路由。
- en: Conventional routing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统路由
- en: 'The *conventional* *routing* is the default routing approach in ASP.NET Core*.*
    As we have already seen, this approach uses the `app.UseEndpoints` extension method
    in the `Startup` class to declare routing templates:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*传统* *路由*是ASP.NET Core中的默认路由方法*.* 如我们所见，这种方法使用`Startup`类中的`app.UseEndpoints`扩展方法来声明路由模板：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By default, ASP.NET Core applies the `default` *route template* to the routing
    engine, which maps each segment of our URL with the `controller` name, the `action`
    name, and the `id` name*,* respectively*.* Furthermore, it is possible to define
    multiple routes in our application by adding them to the routing builder in the
    `Startup` class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ASP.NET Core将`default` *路由模板*应用于路由引擎，将我们的URL的每个段映射到`controller`名称、`action`名称和`id`名称，分别对应*.*
    此外，我们可以在`Startup`类中的路由构建器中添加多个路由，以在我们的应用程序中定义多个路由：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, the `https://myhostname/order/givemeorders` route will be mapped
    to the `Get` action of `OrderController`. We should notice that therouting template
    example we defined in the preceding code is not compliant with the REST architectural
    style. Accordingly, it doesn''t respect the 2^(nd) level of the Richardson Maturity
    Model, as mentioned in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml),
    *REST 101 and Getting Started with ASP.NET Core*. Furthermore, if we apply the
    `default` routing template to `OrderController` we discussed in previous chapters,
    the `Get` action method will respond to the following URI: `https://localhost/order/get`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`https://myhostname/order/givemeorders`路由将被映射到`OrderController`的`Get`操作。我们应该注意到，我们在前面代码中定义的路由模板示例不符合REST架构风格。因此，它不尊重理查森成熟度模型的第2级，如[第1章](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml)中提到的，*REST
    101和ASP.NET Core入门*。此外，如果我们将`default`路由模板应用于前面章节中讨论的`OrderController`，`Get`操作方法将响应以下URI：`https://localhost/order/get`。
- en: 'To make our routing template compliant with the Richardson Maturity Model,
    let''s introduce the `Map` method that''s provided by ASP.NET Core. It is possible
    to map different HTTP verbs using *routing templates*, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的路由模板符合理查森成熟度模型，让我们引入ASP.NET Core提供的`Map`方法。可以使用*路由模板*映射不同的HTTP动词，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `MapGet`, `MapPost`, `MapPut`, and `MapDelete` methods accept the *route
    template* as the first parameter and a `RequestDelegate` method, which provides
    a way to handle `HttpContext` of the current request. However, it is not possible
    to call the `OrderController` logic in `RequestDelegate` because there isn't an
    effortless way to access the controllers' instances from the context. Therefore,
    there isn't an easy way to implement a REST-compliant routing system using *conventional
    routing.* In general, conventional routing is mainly designed for web applications
    that serve views and HTML. An alternative solution is to use the *attribute routing*
    technique, which is the most solid way to implement controllers' routing in a
    web services context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapGet`、`MapPost`、`MapPut`和`MapDelete`方法接受*路由模板*作为第一个参数和一个`RequestDelegate`方法，它提供了一种处理当前请求的`HttpContext`的方式。然而，在`RequestDelegate`中调用`OrderController`逻辑是不可能的，因为没有一种轻松访问控制器实例的方法。因此，没有简单的方法来实现符合REST的路由系统*。一般来说，传统路由主要设计用于提供视图和HTML的Web应用程序。一个替代方案是使用*属性路由*技术，这是在Web服务环境中实现控制器路由的最可靠方式。'
- en: Attribute routing
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性路由
- en: 'The *attribute routing* technique is a different way to implement routing in
    ASP.NET Core. It moves the declaration of routing within the controllers'' implementation
    using attributes to describe the routes in a metaprogramming way:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性路由*技术是另一种在ASP.NET Core中实现路由的方法。它通过使用属性以元编程方式描述路由，将路由的声明移动到控制器实现内部：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Route` attribute declares the routing template within the controller or
    the action. The routing attribute is the default approach of the web API template
    in ASP.NET Core. Another critical thing to notice is that this practice doesn't
    need any route definition in the `Startup` class; therefore, `app.MapControllers()`
    is invoked without route parameters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`属性在控制器或操作中声明路由模板。路由属性是ASP.NET Core中Web API模板的默认方法。另一个需要注意的关键点是，这种做法不需要在`Startup`类中定义任何路由定义；因此，`app.MapControllers()`在没有路由参数的情况下被调用。'
- en: 'Furthermore, this kind of approach also provides more flexibility when it comes
    to binding each action method with a specific route:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法在将每个操作方法绑定到特定路由时也提供了更多的灵活性：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding controller uses `HttpVerb` to map each action method to one particular
    HTTP verb. Furthermore, it also uses the `HttpVerb` attribute to define the last
    segment of the URI, which usually contains the parameters of our target resource.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的控制器使用 `HttpVerb` 将每个操作方法映射到特定的 HTTP 动词。此外，它还使用 `HttpVerb` 属性来定义 URI 的最后一个段，这通常包含我们目标资源的参数。
- en: The `Route("api/order")` attribute defines a static route segment. ASP.NET Core
    provides some reserved placeholders, that is, `[controller]`, `[action]`, and
    `[area]`*,* whichare replaced at runtime with the corresponding `controller`,
    `action`, or `area`. For example, we can achieve the same result by using `Route("api/[controller]")`
    because the `OrderController` name will replace the `[controller]` placeholder.
    As I mentioned in the previous chapter, I strongly suggest that you avoid this
    kind of approach because, in a real-world application, you may accidentally change
    the route of your API by merely refactoring a controller's name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route("api/order")` 属性定义了一个静态路由段。ASP.NET Core 提供了一些保留占位符，即 `[controller]`、`[action]`
    和 `[area]`，它们在运行时会被相应的 `controller`、`action` 或 `area` 替换。例如，我们可以通过使用 `Route("api/[controller]")`
    来达到相同的结果，因为 `OrderController` 名称将替换 `[controller]` 占位符。正如我在上一章中提到的，我强烈建议您避免这种做法，因为在实际应用中，您可能仅仅通过重构控制器名称就意外地更改了
    API 的路由。'
- en: Moving forward, let's have a look at custom attribute routing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看自定义属性路由。
- en: Custom attribute routing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义属性路由
- en: 'The routing engine of ASP.NET Core also provides a way for us to create our
    routing attributes. This technique is useful in complex routing systems where
    it is essential to keep a conceptual order between different routes. An example
    of a custom routing definition is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的路由引擎还提供了一种方法，让我们创建自己的路由属性。这种技术在复杂的路由系统中非常有用，因为它对于保持不同路由之间的概念顺序至关重要。一个自定义路由定义的例子如下：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class extends the `Attribute` abstract class, which is to be applied as
    an attribute. It implements `IRouteTemplateProvider` to get the attributes of
    the r*outing template workflow.* As a result, the application of the attribute
    looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该类扩展了 `Attribute` 抽象类，它将被用作属性。它实现了 `IRouteTemplateProvider` 接口以获取 *路由模板工作流程*
    的属性。因此，属性的运用如下所示：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This approach is really useful when we want to implement a more complex routing
    system. Therefore, it is possible to apply concepts such as inheritance to improve
    the reusability of the implemented routing rules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要实现更复杂的路由系统时，这种方法非常有用。因此，我们可以应用诸如继承等概念来提高实现的路由规则的复用性。
- en: 'This section provided an understanding of different routing approaches of ASP.NET
    Core: *conventional routing* and *attribute routing*. In the next section, we
    will discover how to use the *routing constraints* rules provided by the framework.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了对 ASP.NET Core 不同路由方法的理解：*传统路由* 和 *属性路由*。在下一节中，我们将了解如何使用框架提供的 *路由约束* 规则。
- en: Routing constraints
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由约束
- en: '*Routing constraints* are part of the templating routing system of ASP.NET
    Core. They provide a way for us to match a route with a parameter type or a set
    of values, like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由约束* 是 ASP.NET Core 模板路由系统的一部分。它们提供了一种方式，让我们可以匹配一个参数类型或一组值的路由，如下所示：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, our route template will match all the `https://myhostname/mycontroller/myaction`
    calls and all the calls that present a valid `Guid` as an `id` parameter, for
    example, `https://myhostname/mycontroller/myaction/4e10de48-9590-4531-9805-799167d58a44`.
    The `{id:guid?}` expression gives us two pieces of information about constraints:
    first, the parameter must have the `guid` type, and secondly, it is specified
    as optional using the `?` character. ASP.NET Core provides a rich set of built-in
    *routing constraints* such as *min* and *max* *values*, *regular expressions,*
    and *range*. It is also possible to combine them using the colon operator (`:`),
    like so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的路由模板将匹配所有 `https://myhostname/mycontroller/myaction` 调用以及所有呈现有效 `Guid`
    作为 `id` 参数的调用，例如，`https://myhostname/mycontroller/myaction/4e10de48-9590-4531-9805-799167d58a44`。`{id:guid?}`
    表达式给我们提供了关于约束的两条信息：首先，参数必须具有 `guid` 类型，其次，它使用 `?` 字符指定为可选。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, we are combining the `int` constraint with the `min(1)` constraint.
    Therefore, we can cover a large number of use cases and business rules. In addition,
    we can improve our routing matching logic by providing different action methods
    for the same URI that is receiving a different type of data. It is also important
    to note that the same *routing constraints* can also be applied to the attribute
    routing part:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们将 `int` 约束与 `min(1)` 约束相结合。因此，我们可以覆盖大量用例和业务规则。此外，我们可以通过为接收不同类型数据的同一
    URI 提供不同的操作方法来改进我们的路由匹配逻辑。值得注意的是，相同的 *路由约束* 也可以应用于属性路由部分：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'ASP.NET Core provides a rich set of default routing constraints that can be
    used out of the box. The following link lists all the additional default routing
    constraints of ASP.NET Core: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一组丰富的默认路由约束，可以直接使用。以下链接列出了 ASP.NET Core 的所有附加默认路由约束：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference)。
- en: Custom constraints
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义约束
- en: 'If default constraints don''t cover all the business rules of your application,
    ASP.NET Core exposes all the necessary components to extend the behavior of route
    constraints so that you can define your own rules. It is possible to extend routing
    constraints by implementing the `IRouteConstraint` interface provided by `Microsoft.AspNetCore.Routing`,
    like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认约束无法覆盖应用程序的所有业务规则，ASP.NET Core 提供了所有必要的组件来扩展路由约束的行为，以便您可以定义自己的规则。可以通过实现
    `Microsoft.AspNetCore.Routing` 提供的 `IRouteConstraint` 接口来扩展路由约束，如下所示：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code shows an example of the implementation of `IRouteConstraint`.
    The interface exposes the `Match` method, which allows us to match the incoming
    route values with a custom set of values. In this case, the constraint matches
    a set of currencies. In order to use `CurrencyConstraint`, it is necessary to
    configure it in the `ConfigureServices` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了 `IRouteConstraint` 实现的示例。该接口公开了 `Match` 方法，它允许我们将传入的路由值与一组自定义值进行匹配。在这种情况下，约束匹配一组货币。为了使用
    `CurrencyConstraint`，必须在 `ConfigureServices` 方法中对其进行配置：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is possible to use the custom `CurrencyConstraint` routing constraint using
    the regular syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用常规语法使用自定义的 `CurrencyConstraint` 路由约束：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the `default` route will match only the parameter that's using
    the logic that's implemented in the `CurrencyConstraint` class. Therefore, it
    will match the `https://localhost/controller/action/eur`, `https://localhost/controller/action/usd`,
    and `https://localhost/controller/action/gbp` URIs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`default` 路由将仅匹配使用 `CurrencyConstraint` 类中实现的逻辑的参数。因此，它将匹配 `https://localhost/controller/action/eur`、`https://localhost/controller/action/usd`
    和 `https://localhost/controller/action/gbp` URI。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The ASP.NET Core routing system can be extended and used to cover a lot of use
    cases. In general, it provides all the necessary functionalities out of the box.
    It is essential to understand that *conventional routing* is generally used by
    web applications, while web services routing is usually achieved by applying the
    *attribute routing*. This chapter described how to deal with these two approaches,
    how to use the out-of-box constraints provided by ASP.NET Core and how to implement
    our custom routing constraints. In the next chapter, we will look at how to deal
    with the filter pipeline of ASP.NET Core and in which way they differ from the
    implementation of the middleware classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 路由系统可以扩展并用于覆盖大量用例。通常，它提供所有必要的功能。重要的是要理解，*传统路由* 通常用于 Web 应用程序，而
    Web 服务路由通常是通过应用 *属性路由* 来实现的。本章介绍了如何处理这两种方法，如何使用 ASP.NET Core 提供的内置约束，以及如何实现我们自己的路由约束。在下一章中，我们将探讨如何处理
    ASP.NET Core 的过滤器管道以及它们与中间件类实现的区别。
