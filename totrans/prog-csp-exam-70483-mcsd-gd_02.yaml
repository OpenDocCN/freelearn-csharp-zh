- en: Understanding Classes, Structures, and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ccec4122-6067-4279-843b-6123b1eff017.xhtml), *Learning the Basics
    of C#*, we looked at an overview of the very basic components of a C# application.
    All classes in a C# application are composed of attributes and methods. Using
    namespaces and assemblies, we can bundle related classes together.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain structure and to reduce complexity, it's essential that only the
    required classes/functionality are exposed outside the scope of a class. In a
    C# program, this is achieved via access modifiers. While defining the attributes
    present in a class, we also need to be clear about the different data types of
    variables available in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Using a code implementation of struct and class, we will look at how data and
    reference type variables differ in implementation and behavior during program
    execution. We will also be looking at some good practices that we can follow to
    choose the right data type for our variables.
  prefs: []
  type: TYPE_NORMAL
- en: We will then look at interfaces and inheritance and how they are implemented
    in a C# application. Using examples, we will look at the different scenarios in
    which we should use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Different types of access modifiers in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of data types in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between a class and a struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding interfaces and how they are different from inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapters of this book, the programs explained in this chapter
    will be developed in Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All classes, along with their respective attributes and functions, have an access
    modifier associated with them. An access modifier basically indicates how the
    respective element will be accessed in the application, both in its own assembly
    as well as in other assemblies. Collectively, attributes and functions in an application
    are referred to as class members.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, a class and its class members can acquire the following access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: A class or a class member declared as *public* can be accessed
    by all classes in the same assembly as well as by classes in different assemblies
    present in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: A class member declared as *private* can be accessed only in the
    same class but not outside it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: A class or a class member declared as *protected* can be accessed
    inside the class or by classes that inherit from the respective class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: A class or a class member declared as *internal* can only be
    accessed by classes in the same assembly but not by outside assemblies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected internal**: A class or a class member declared as *protected* *internal*
    can only be accessed by classes in the same assembly or by classes present in
    the outside assembly that inherit from the respective class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private protected**: A class or a class member declared as *private protected*
    can only be accessed in the same class or in classes present in the same assembly
    that inherit from the respective class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following image to summarize this knowledge about access
    modifiers. In the following example, we have **Assembly A** and **Assembly B**
    in the application. **Assembly A** has **Class A**, which has different functions,
    each with a separate access modifier. Please refer to the comments against each
    of the functions to understand which classes under which assemblies can access
    the respective functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57e02d6a-4e22-4590-83e2-cfad46d9ca71.png)'
  prefs: []
  type: TYPE_IMG
- en: Based upon the accessibility level and the security that we wish to embed in
    the different class members, we can choose either of the previously mentioned
    access modifiers. To keep some structure and avoid introducing undue complexity,
    it's advisable to only expose class members to classes that require some information
    to be shared with the respective class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the different data types that a class member
    can acquire.
  prefs: []
  type: TYPE_NORMAL
- en: Data types in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, a variable can acquire one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: A value type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# differentiates between these two types in terms of how these values are saved
    and maintained in the **Global Assembly Cache** (**GAC**) during the program execution.
    Value type variables are saved in the stack, while reference type variables are
    saved in a managed heap data structure.
  prefs: []
  type: TYPE_NORMAL
- en: There are other **pointer types** that allow us to access value in the memory
    location of a variable. In [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml),
    *Creating and Using of Types in C#*, we will explore those data types in detail.
    For now, let's look at these two data types and explore them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Value type variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In value types, the variables contain the data or the contents of the variable.
    This implies that if any change is made to a value type variable in a different
    scope of the program, the change will not be reflected back once the control shifts
    to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the different types of value types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Simple types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is the list of simple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int`: For example 1, 2, 4, and -100\. They can be both signed and unsigned.
    A signed `int` type can be both positive and negative. An unsigned `int` type
    cannot be negative; its minimum value is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`: For example, 3.14.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Long`: Unlike `Int`, which is 32-bit, `Long` is a 64-bit integer value. It
    can also be both signed and unsigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decimal`: Like `Float`, decimal data types also represent decimal digit numbers
    with the main difference being in terms of precision. For `Float` data members,
    the precision is 7; however, in the case of decimal data types, the precision
    is 28 digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Char`: Represents a single character sequence. It can acquire values such
    as `C`, `c`, or white-space, any special characters – such as % and # – and even
    a digit such as 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: It can be used to represent variables that acquire a digital value
    such as true or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enum types are used to indicate an attribute that can acquire a constant set
    of values, for example, `enum Day {Sat, Sun, Mon, Tues, Wed, Thurs, Fri}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value of the first enumerator in the declaration starts from
    0\. It then increments the value of the subsequent enumerators by 1\. For the
    preceding example, the following would be the value of the enumerators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sat` – 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sun` – 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mon` – 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tues` – 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wed` – 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thurs` – 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fri` - 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also override the default values of the enumerators by explicitly defining
    the values in the declaration itself. For example, in the preceding example, if
    we do not want the enumerators to start from 0, we can use the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding declaration, the enumerators will acquire the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sat` – 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sun` – 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mon` – 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tues` – 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wed` – 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thurs` – 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fri` – 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each Enumerator attribute also has an underlying data type that, by default,
    is of type `Int`. If required, we can also change the type of the enumerated values
    to long or short. However, it cannot take `char` as an underlying data type. Refer
    to the following `enum` declaration, in which we are setting the type of Enumerator
    value to `short`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Struct types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like classes, structs in C# can be used to group together related data.
    Like classes, they can have constructors, fields, and methods. However, there
    are some differences between the implementation of structs and classes. The following
    are some of the key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Struct** | **Class** |'
  prefs: []
  type: TYPE_TB
- en: '| Type | Structs are managed as value type variables. This implies that the
    value assigned in their objects is not persisted in different scopes of the program.
    | Classes are managed as reference type variables. This implies that the value
    assigned in their objects is persisted across different scopes of the program.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | Unlike classes, no default constructor is managed by C#. When
    we go through [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml), *Creating
    and Using of Types in C#*, we will explore default constructors in detail. | When
    declaring a class, if no constructor is specified for the class, C# automatically
    creates a default constructor for the class. |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance | A struct cannot inherit from another struct. This implies that
    code reuse could become a challenge if we use structs. | A class can inherit from
    other classes. |'
  prefs: []
  type: TYPE_TB
- en: Being value type variables, when a struct object is created, the entire object
    – inclusive of attributes, methods, and so on – is saved in a stack. Therefore,
    from a performance perspective, it's essential that structs should only be used
    for creating lightweight objects with only a few members.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming section, we will go through a code example to show how struct
    implementation is different from a similar implementation in classes.
  prefs: []
  type: TYPE_NORMAL
- en: Reference type variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In reference type variables, the data member contains the exact address of the
    variable in memory. As the variable just contains a reference to the memory address,
    two separate reference type variables can point to the same memory address. Therefore,
    if a change is made to a reference type variable, the change is directly done
    at the memory location of the variable. Due to the change being directly made
    at the memory location of the variable, both variables will reflect the updated
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the reference types available in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: As discussed in [Chapter 1](ccec4122-6067-4279-843b-6123b1eff017.xhtml),
    *Learning the* *Basics of C#*, a class represents a collection of related properties
    and methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: An interface in C# represents a collection of related properties,
    events, and methods, with just a declaration and no definition. In this chapter,
    in upcoming sections, we will deep dive into interfaces and see how they are implemented
    in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic**: A dynamic type variable avoids compile-time type checking. For
    example, if we declare a dynamics variable type and assign a variable to it, its
    type is defined at runtime when a value is assigned to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the following code snippet, we are creating a dynamics type
    variable, assigning different variables to it and evaluating its type at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Object**: When a new instance of a class is created using the `new` keyword,
    an object for the class is created in the memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: A `String` object is a sequence of `Char` objects whose value is
    immutable or read-only. This basically implies that, when we modify a variable
    of type `String`, it creates a new object in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will go through a code example to show how a reference
    type variable such as `Class` and a value type variable such as struct are implemented
    in C# and how their behavior differs.
  prefs: []
  type: TYPE_NORMAL
- en: Structs versus classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter, we created a basic `Hello World` program. In this topic,
    we will extend that program and use it to implement a struct and a class. While
    doing so, we will analyze the difference between the implementation and use of
    reference and value type variables. As you are already aware by now, a struct
    is a value type variable and a class is a reference type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Console` project created in [Chapter 1,](ccec4122-6067-4279-843b-6123b1eff017.xhtml)
    *Learning the Basic Structure of C#*, and declare a `CoordinatePoint` class with
    just two member attributes of `x` and `y` coordinates. Also create two constructors
    – one without any parameters and one with two parameters. Please refer to the
    following code implementation for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Please note that, in the preceding code, the use of the `this` variable is optional.
    It is used to refer to the current instance of the class and can be used to differentiate
    between class members and method parameters if they have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a similar structure. Notice that the compiler gives an error for the
    default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As indicated in the preceding code, we will see a red label on the `struct`
    constructor. This is because, unlike classes, a struct cannot have an implementation
    of a default constructor. To remove the error, we need to remove the default constructor.
    On doing this, we will see that the compiler error goes away. The following would
    be the correct implementation of the struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Main` class, we will now declare two functions, one for each class
    and struct, respectively. In both functions, we will be passing a parameter by
    the name of `obj`, which is an object of type class and struct, respectively.
    In the same function, we will change the values of the `x` and `y` coordinate
    variables in both the struct and the class to a default value of `0.5F`. The following
    is the code implementation for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the main function, declare the objects of both the class and the structure.
    Notice that, during the declaration of the respective objects, we are specifying
    the same values in the `xCoordinate` and `yCoordinate` member attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the sake of explanation, we will write syntax that will output the values
    in the respective member attributes to the console. The following is the code
    implementation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now write syntax to call the respective `ChangeValues` function for each of
    structure and class. After the call to the function, have another statement to
    print the current values in the attributes of the `struct` and `class` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following code implementation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Click on Build | Build Solution and ensure that there are no compile-time errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Debug | Start Debugging. Alternatively, the user can also click on
    the *F5* key or the triangular icon next to Start to launch the debugger. Please
    refer to the following screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c28097a2-2eec-4160-94a0-8a6901ad53e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the console shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71aac2cf-d046-4d12-9d9c-ce9b41ab558a.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that, after calling the change function, the value of the `class` object
    gets modified. However, there is no change to the values in the struct.
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the fact that `struct` is a value type variable. Therefore, any
    change in the object, outside the scope of the function, has no impact as the
    change happens at an entirely different object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `class` being a reference type variable is affected by changes
    happening outside the scope of the function as well. For this reason, changes
    are propagated back to the main object as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the following table illustrates the main differences between
    a `struct` and a `class` type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Class** | **Struct** |'
  prefs: []
  type: TYPE_TB
- en: '| Default Constructor | If a class does not have a constructor, then whenever
    an object is created for the class, the default constructor triggers and sets
    default values against the member variables present in the class. The default
    values are set in accordance with the default values of the type of those member
    variables. | In contrast to a class, a struct cannot have any default constructors.
    This means that the application doesn''t assign a default value to the member
    variables of the struct. |'
  prefs: []
  type: TYPE_TB
- en: '| Memory Implementation | As illustrated in the previous code example, a class
    is implemented as a reference type. This means that the value of an object of
    class is persisted across different scopes of the program execution. | As illustrated
    in the previous code example, a struct is implemented as a value type. This means
    that its value is not persisted across different scopes of the program. |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance | We will be exploring inheritance in detail both in this chapter
    as well as in the next chapter. However, a class in C# can inherit from other
    classes. | In contrast to a class, a struct cannot inherit from other structs
    or classes. This implies that code reuse is slightly difficult in structs compared
    to in classes. |'
  prefs: []
  type: TYPE_TB
- en: Based upon the preceding differences, depending upon the requirements, a developer
    can choose the right data type between a struct and a class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how an interface is implemented in a C#
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface is a collection of properties, methods, and events with just a
    declaration and no definition. We use them in programming to group together a
    set of functionalities that must be implemented in classes that, theoretically,
    are of the same basic type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a car. In a real-world scenario, any implementation
    of the `Car` class must implement certain common basic features such as driving,
    stopping, and accelerating. Along with those, any object that is classified as
    a car will also have certain features specific to the make of the car, such as
    Honda or Nissan.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, an interface could help to promote code reuse and
    maintain structure across all types of `Car`. What we can do in this case is to
    declare `Car` as an interface that all car derivatives, such as Nissan or Honda
    must implement.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to an interface, we can also implement *inheritance* in a C# application.
    In inheritance, we can define classes with certain methods and properties, which
    can then be inherited in a child class. In the next subsections, we will look
    at how interfaces and inheritance are implemented in a C# application.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is one of the main pillars of OOP programming. In [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml),
    *Understanding Object-Oriented Programming*, we will look into more advanced features
    related to inheritance and understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is one of the main principles of any object-oriented programming.
    With inheritance, we can define attributes and functions that can be reused in
    child classes. In short, it helps us to reuse code written in the application
    across multiple modules. Let's go through an example to understand how inheritance
    helps us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider two cars, `CarA` and `CarB`. From a very high-level perspective,
    we can think that both these classes will have similar features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: A brake function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accelerator function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A car type; that is, diesel/petrol and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gear type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we need to implement this in a C# application, one way would be to define
    them as two separate classes: `CarA` and `CarB` . However, the main concern with
    this approach is that both of these classes will need to have their own implementation
    of the shared features listed. Please refer the following code for how a possible
    implementation of `CarA` would look in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, please refer to the following code for what a possible implementation
    of `CarB` would look like in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of implementation could have the following repercussions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No code reuse**: As you will understand from the preceding example, there
    are features that both `CarA` and `CarB` have in common. However, instead of maintaining
    common features separately, we are duplicating the code, which could cause maintenance
    issues as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: From a business/implementation perspective, there could be
    millions of different types of cars. Thus, for every new `Car` or a new common
    feature added to the `Car` implementation, we may face some scalability challenges
    in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As clearly illustrated, change management in such applications would be a nightmare
    and would be very difficult to carry out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will use the concept of inheritance and see how the preceding scenario
    could be implemented in a better way. From an implementation perspective, we will
    be creating a base class, `Car`, which will have all of the common member variables
    across different implementations of `Car`. We will then define individual types
    of `Car`, which will inherit from the base class, `Car`. Let''s look at the following
    code example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a base class, `Car`. The class will have all the member attributes that
    are common across `CarA` and `CarB`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class, `CarA`, which will inherit the base class. In C#, we use the`:`
    syntax to define inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As indicated earlier, the attributes declared inside the parent class are automatically
    available in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the attributes from the base class that will be available in
    the child class depend upon the access modifiers used against the corresponding
    attributes in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have used `public` access modified in the base class. If
    it had been `private` or `protected internal`, its accessibility would have differed
    in the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a scenario wherein, for some reason, we also need to declare
    an attribute by the same name, `bodyType`, in `CarA`. In C#, we can differentiate
    between the attributes present in the base class and in the derived class by using
    the `base` keyword. Refer to the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If `base` is used, it refers to the attribute in the parent class and, if `this`
    is used, it refers to the attribute in the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, declare a class for `CarB`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Please note that, in derived classes, we can also create member variables independent
    of the base classes. As indicated in the preceding screenshots, the `CarA` class
    has an implementation of `FoldableSeat`, which is not present in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `CarB` class has an implementation of `RoofTopExtendable`, which
    is not present in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main method, declare the `CarA` and `CarB` objects and call the respective
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on Build | Build Solution. Notice that there are no compile-time errors.
    Now click on Debug | Start Debugging. Notice that the following output comes up
    in the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e889716e-6f6f-40b2-adca-06de90d89a62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following provides a brief analysis of each of the output line items:'
  prefs: []
  type: TYPE_NORMAL
- en: The first method we call is `ImplementAccelerator`, which is present in the
    base class. As expected, it executes the method in the base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, the next method we call is `ImplementBrake`, which is also present
    in the base class. In this case also, the method in the base class is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next call, we execute a method just present in `CarA`. In this case,
    the control executes the code present in that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same thing applies to B as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, using inheritance, we can promote a greater degree of code reuse, along
    with making the maintenance activity quite scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Once we move on to [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml),
    *Understanding Object-Oriented Programming*, we will cover more features in regard
    to inheritance, such as overriding sealed, abstract classes and so on. However,
    for now, we will go over how an interface helps us in C# code development.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, we illustrated how we can declare a base class with
    some member variables and have them inherited in a derived class. However, there
    could be some scenarios when we need to have a class inherited from two different
    classes. Moreover, if we are using a struct, we will not be able to inherit from
    another struct or class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, using inheritance, we will not be able to achieve this in a
    C# application due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance is not allowed in C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct data type in C# cannot inherit from other structs or class types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In such scenarios, interfaces come in handy. An interface defines a set of related
    methods, attributes which each class implementing the interface must implement.
    Please note that an interface must have just declarations.
  prefs: []
  type: TYPE_NORMAL
- en: In reference to interfaces, a declaration refers to the specification of the
    methods along with their signatures – that is, input and output parameters – while
    a definition refers to the actual implementation of the logic in the method body.
    While discussing the following code example, we will look further into this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example we used for inheritance and see how we can use an
    interface in it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, wherein we created `CarA` and `CarB`, we can deduce
    that it is bound to have several other properties as well, such as color, weight,
    height, brand, logo, manufacturer, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a data model perspective, we can classify them as attributes common to
    any *utility or product* rather than just a car.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, when we are choosing a product, we can say that there are certain actions,
    such as `ImplementBrand`, `ImplementColor`, and so on that will be common across
    all the product implementations and not just for `CarA` and `CarB`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, it means that the two classes must inherit from both `Car` and `Product`
    to function correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try and create another base class of `Product` and try to implement
    multiple inheritance for `CarA`. Here''s the following code implementation for
    the `Product` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we try to implement multiple inheritance for the `CarA` class,
    the compiler gives us an error. The following screenshot shows the error we get
    from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ede8a7f-a14b-4e28-a3c9-66ecb6904c44.png)'
  prefs: []
  type: TYPE_IMG
- en: A solution would be to merge the implementations of `Car` and `Product` together;
    however, it's clear that from a data model perspective, these two entities are
    not related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome the preceding dilemma, we will use an interface. When declaring
    an interface, we need to adhere to the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: To declare an interface, we need to use the `interface` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface cannot have an access modifier for any function declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface must also just have function declarations and no definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code syntax of the `ICar` interface, wherein we are declaring
    the methods that should be in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that, in the preceding example, we have only specified the signature
    that the methods present in the interface should acquire. This is referred to
    as a declaration. The class implementing this interface – in our case, `Car`,
    will be responsible for providing complete implementation for the methods presents
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement an interface, we can use syntax similar to inheritance. The following
    is the screenshot for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7acb08-c14f-42e6-9a75-9efc4f39209c.png)'
  prefs: []
  type: TYPE_IMG
- en: Review the compile-time error. The error indicates that the `Car` class must
    implement all the functions declared in the interface. To overcome the preceding
    error, we must define all the functions in the interface. Similar to `ICar`, we
    can also create an interface for `IProduct`, which each of the `CarA` and `CarB`
    classes can then implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'While inheritance and interfaces can be used in similar scenarios, some of
    the differences between them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Inheritance** | **Interface** |'
  prefs: []
  type: TYPE_TB
- en: '| Multiple derivations | A class can only inherit from one class. | A class
    can implement multiple interfaces. |'
  prefs: []
  type: TYPE_TB
- en: '| Data types | A class can inherit from another class. However, a struct cannot
    inherit from another class or struct. | Both classes and structs can implement
    interfaces. |'
  prefs: []
  type: TYPE_TB
- en: '| Method definitions | In inheritance, a base class can define methods. | An
    interface cannot have any definitions against methods. |'
  prefs: []
  type: TYPE_TB
- en: '| Access modifiers | A base class and its member attributes can assume different
    access modifiers, such as `public`, `private`, `protected`, `protected internal`,
    and `private protected`. | The access modifier of an interface is always public.
    |'
  prefs: []
  type: TYPE_TB
- en: Based on these differences, a programmer can decide the right approach for their
    application and choose between creating an interface or managing through inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topics covered in this chapter are the basics of programming in the C# language.
    Using access modifiers, we can control access to different properties and methods
    in different modules of an application. While writing the code, a very common
    mistake that people make is to declare all the properties and methods as public.
    This is not the recommended way of programming in C#. We must logically evaluate
    the need for different access modifiers for each of the properties and methods
    present in a class.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we should analyze the data types that we need to associate with each
    property used in the class. We must also analyze if we need a reference data type
    variable, or whether we are fine with a value type variable as they have a different
    implementation in the compiler memory and functionality. We should also utilize
    inheritance as it helps us to reuse code and structure our programs in a very
    precise manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter , we will go through OOP concepts, which are the main building
    blocks of any high-level programming language like C#. We will go over polymorphism,
    abstraction, encapsulation, and inheritance and understand each of these concepts
    in detail, and will also go over some code examples to see their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following attributes declared in the `Car` class is not a *value
    type* variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public Decimal fuelCapacity;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public Enum carColor;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public String registrationNumber;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public Int numberOfSeats`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not a reference type variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Struct
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In C#, a child class can inherit from multiple parent classes. Is this statement
    correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements about interfaces and classes is not correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class can implement multiple interfaces.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface can have both function declarations and definitions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A struct data variable cannot inherit from another struct.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In inheritance, if both the base class and the derived class have a function
    with the same name, we can use the *base* keyword to implicitly call the function
    of the base class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements about access modifiers is not correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a member variable is declared as `public`, it can be accessed across the
    entire application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a member variable is declared as `private`, it can only be accessed in the
    same class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a member variable is declared as `protected`, it can be accessed throughout
    the namespace.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a member variable is declared as `protected internal`, it can be accessed
    by classes in the name namespace and the classes that derive from it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`public String registrationNumber;`. String is a reference type variable. All
    others are value type variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Struct** is a value type variable unlike all others which are reference type
    variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**No**, in C# we cannot have multiple inheritance. A class can only inherit
    from one base class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In C#, an interface must only have function declarations and not definitions.
    All other statements are correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a member variable is declared as `protected`, it can only be accessed in
    the classes that inherit from its base parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
