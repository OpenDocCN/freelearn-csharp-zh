<html><head></head><body>
  <div id="_idContainer312" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-89" class="chapterTitle">Dynamic Motion: Implementing Movement and Spawning</h1>
    <p class="normal">In the previous chapter, we learned about the basics of scripting, so now, let’s create the first script for our game. We will see the basics of how to move objects through scripting using the <code class="inlineCode">Transform</code> component, which will be applied to the movement of our player with the keyboard keys, the constant movement of bullets, and other object movements. Also, we will see how to create and destroy objects during the game, such as the bullets our player and enemy shoot and the enemy waves that will be generated during the game (also called enemy spawners). These actions can be used in several other scenarios, so we will explore a few in this chapter.</p>
    <p class="normal">In this chapter, we will examine the following scripting concepts:</p>
    <ul>
      <li class="bulletList">Implementing movement</li>
      <li class="bulletList">Implementing spawning</li>
      <li class="bulletList">Using the new Input System</li>
    </ul>
    <p class="normal">We will start by scripting components to move our character with the keyboard, and then we will make our player shoot bullets. Something to consider is that we are going to first see the C# version and then show the Visual Scripting equivalent in each section.</p>
    <h1 id="_idParaDest-90" class="heading-1">Implementing movement</h1>
    <p class="normal">Almost <a id="_idIndexMarker267"/>every object in a game moves one way or another: the player character with the keyboard, enemies through AI, bullets that simply move forward, and so on. There are several ways of moving objects in Unity, so we will start with the simplest one— that is, using the <code class="inlineCode">Transform</code> component.</p>
    <p class="normal">In this section, we will examine the following movement concepts:</p>
    <ul>
      <li class="bulletList">Moving objects through <code class="inlineCode">Transform</code></li>
      <li class="bulletList">Using input</li>
      <li class="bulletList">Understanding Delta Time</li>
    </ul>
    <p class="normal">First, we will <a id="_idIndexMarker268"/>explore how to access the <code class="inlineCode">Transform</code> component in our script to drive player movement, later applying movement based on the player’s keyboard input. Finally, we will explore the concept of <em class="italic">deltatime</em> to make sure that movement speeds are consistent on every computer. We will start learning about the <code class="inlineCode">Transform</code> API to make a simple movement script.</p>
    <h2 id="_idParaDest-91" class="heading-2">Moving objects through Transform</h2>
    <p class="normal"><code class="inlineCode">Transform</code> is the<a id="_idIndexMarker269"/> component that holds the translation, rotation, and scale of an object, so every movement system such as physics or pathfinding will affect this component. Sometimes, we want to move the object in a specific way according to our game by creating our own script, which will handle the movement calculations we need and modify <code class="inlineCode">Transform</code> to apply them.</p>
    <p class="normal">One concept applicable here is that components can alter other components. The main way of coding in Unity is to create components that interact with other components. Here, the idea is to create one that accesses another and tells it to do something—in this case, to move. To create a script that tells <code class="inlineCode">Transform</code> to move, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create and add a script called <code class="inlineCode">PlayerMovement</code> to our character, as we did in the previous chapter. In this case, it will be the animated 3D model we downloaded previously, named <strong class="screenText">Polyart_Mesh</strong> (drag the 3D asset from the <strong class="screenText">Project</strong> view to the scene). Remember to move the script to the <strong class="screenText">Scripts</strong> folder after creation:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.1: Creating a PlayerMovement script in the character</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Double-click<a id="_idIndexMarker270"/> the created script asset to open an IDE to edit the code.</li>
      <li class="numberedList">The character is moving, and the movement is applied to every frame. So this script will use only the <code class="inlineCode">Update</code> function or method, and we can remove <code class="inlineCode">Start</code> (it is a good practice to remove unused functions):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_02_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.2: A component with just the Update event function</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">To move our object along its local forward axis (the <em class="italic">z</em> axis), add the <code class="inlineCode">transform.Translate(0,0,1);</code> line to the <code class="inlineCode">Update</code> function, as shown in <em class="italic">Figure 6.3</em>:
    <p class="normal">Every <a id="_idIndexMarker271"/>component has access to a <code class="inlineCode">Transform</code> field (to be specific, a <strong class="keyWord">getter</strong>) that is a reference to the <code class="inlineCode">Transform</code> of the GameObject the component is placed in. Through this field, we can access the <code class="inlineCode">Translate</code> function of the <code class="inlineCode">Transform</code>, which will receive the offset to apply to the <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> local coordinates.</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_03_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.3: A simple Move Forward script</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Save the file, and play the game to see the movement. Ensure that the camera points at the character to properly see the effect of the script. To do that, remember that you can select the camera in the hierarchy and move and rotate it until the character falls inside the frustum.</li>
    </ol>
    <p class="normal">Now that we have implemented a simple movement for the player, you will notice that they are moving too fast. That’s because we are using a fixed speed of 1 meter, and because <code class="inlineCode">Update</code> is executing all frames, we are moving 1 meter per frame. In a standard 30 <strong class="keyWord">Frames Per Second</strong> (<strong class="keyWord">FPS</strong>) game, the player would move 30 meters per second, which is too much, but our computer is perhaps running the game with way more FPS than that. We can control the player’s speed by adding a <code class="inlineCode">speed</code> field and using the value set in the editor instead of the fixed value of 1. You can see one way to do this in <em class="italic">Figure 6.4</em>, but remember the other options we discussed in <em class="italic">Chapter 5</em>,<em class="italic"> Unleashing the Power of C# and Visual Scripting</em>:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_04_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.4: Creating a speed field and using it as the z speed of the movement script</p>
    <p class="normal">Now, if you<a id="_idIndexMarker272"/> save the script to apply the changes and set the <strong class="screenText">Speed</strong> of the player in the Editor, you can play the game and see the results. In my case, I used <code class="inlineCode">0.1</code>, but you might need another value (there’s more on this in the <em class="italic">Understanding Delta Time</em> section):</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_05_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.5: Setting a speed of 0.1 meters per frame</p>
    <p class="normal">Now, for the Visual Scripting version, remember not to mix the C# and Visual Scripting versions of our scripts; this is not because it is impossible but because we want to keep things simple for now. So you can either delete the script from the player object and add the Visual Scripting version, or you can create two player objects and enable and disable them to try both versions. I recommend creating one project for the C# version of the scripts and then creating a second project to experiment with the Visual Script version.</p>
    <p class="normal">The Visual Scripting Graph of this script will look like the following image:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_06_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.6: Setting a speed of 0.1 meters per frame</p>
    <p class="normal">As you <a id="_idIndexMarker273"/>can see, we added a <strong class="screenText">Script Machine</strong> component to our <code class="inlineCode">Player</code> GameObject. Then, we pressed the <strong class="screenText">New</strong> button in the <strong class="screenText">Script Machine</strong> component to create a new <strong class="screenText">Graph</strong> called <code class="inlineCode">PlayerMovement</code>. We also created a <strong class="screenText">Float</strong> variable called <code class="inlineCode">speed</code> with the value of <code class="inlineCode">0.1</code>. In the <strong class="screenText">Graph</strong>, we added the <strong class="screenText">On Update</strong> event node and attached it to the <strong class="screenText">Translate </strong>(<strong class="screenText">X,Y,Z</strong>) node of the <strong class="screenText">Transform</strong>, which, similar to the C# version, will move along the local axes of the object. Finally, we connected the <strong class="screenText">Z</strong> parameter pin of <strong class="screenText">Translate</strong> to the <code class="inlineCode">GetVariable</code> node, representing the speed we created in the GameObject. If you compare this <strong class="screenText">Graph</strong> with the code we used in the C# version, they are essentially the same <strong class="screenText">Update</strong> method and <code class="inlineCode">Translate</code> function. If you don’t remember how to create this <strong class="screenText">Graph</strong>, you can go back to <em class="chapterRef">Chapter 5</em>, <em class="italic">Unleashing the Power of C# and Visual Scripting</em>, to recap the process.</p>
    <p class="normal">You will notice that the player will move automatically. Now, let’s see how to execute the movement based on <strong class="screenText">player input</strong> such as the keyboard and mouse.</p>
    <h2 id="_idParaDest-92" class="heading-2">Using Input</h2>
    <p class="normal">Unlike <strong class="keyWord">NPCs</strong> (<strong class="keyWord">non-playable characters</strong>) in a videogame, we want the player’s movement to be driven by the user’s input, based on which keys they press when they play, the mouse<a id="_idIndexMarker274"/> movement, and so on. To know whether a certain key has been pressed, such as the <em class="italic">Up</em> arrow, we can use the <code class="inlineCode">Input.GetKey(KeyCode.W)</code> line, which will return a Boolean, indicating whether the key specified in the <code class="inlineCode">KeyCode</code> enum is pressed, which is <em class="keystroke">W</em> in this case. This is usually the main setup for keyboard controllers in 3D video games. We can combine the <code class="inlineCode">GetKey</code> function with an <code class="inlineCode">If</code> statement to make the translation execute when the key is pressed.</p>
    <p class="normal">Let’s start by<a id="_idIndexMarker275"/> implementing the keyboard movement by following these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Make the forward movement execute only when the <em class="keystroke">W</em> key is pressed using the code, as shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"> <img src="../Images/B21361_06_07_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.7: Conditioning the movement until the W key is pressed</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">We can add other movement directions, using more <code class="inlineCode">If</code> statements to move backward and <em class="keystroke">A</em> and <em class="keystroke">D</em> to move left and right, as shown in the following screenshot. Notice how we use the minus sign to inverse the speed when we need to move in the opposite axis direction:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_08_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.8: Checking the W, S, A, and D key pressure</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">If you also<a id="_idIndexMarker276"/> want to consider the arrow keys, you can use an <code class="inlineCode">OR</code> inside <code class="inlineCode">if</code>, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_09_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.9: Checking the W, S, A, D, and arrow key pressure</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Save the changes, and test the movement in <strong class="screenText">Play</strong> mode.</li>
    </ol>
    <p class="normal">With these lines of code, we <a id="_idIndexMarker277"/>have implemented basic movement using the <em class="keystroke">WASD</em> keys. Something to take into account is that, first, we have another way to map several keys to a single action by configuring the Input Manager—a place where action mappings can be created. Second, at the time of writing, Unity has released a new Input System that is more extensible than this one.</p>
    <p class="normal">For now, we will use this one because it is simple enough to make our introduction to scripting with Unity easier, but in games with complex input, it is recommended that we look for more advanced tools.</p>
    <p class="normal">Now, for the Visual Scripting version, the Graph will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_10_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.10: Input movement in Visual Scripting</p>
    <p class="normal">As you can see, the <a id="_idIndexMarker278"/>graph has grown in size considerably <a id="_idIndexMarker279"/>compared to the C# version, which serves as an example of why developers prefer to code instead of using visual tools. Of course, we have several ways to split this graph into smaller chunks and make it more readable. Also, I needed to squeeze the nodes together for them to be in the same image.</p>
    <p class="normal">In the preceding screenshot, we can only see an example graph to move forward and backward, but you can easily extrapolate the necessary steps for lateral movement based on this graph. As usual, you can also check the GitHub repository of the project to see the completed files.</p>
    <p class="normal">Notice all the similarities to the C# version; we chained <code class="inlineCode">If</code> nodes to the <strong class="screenText">On Update </strong>event node in a way that if the first <code class="inlineCode">If</code> node condition is <code class="inlineCode">true</code>, it will execute the <strong class="screenText">Translate</strong> in the player’s forward direction. If that condition is <code class="inlineCode">false</code>, we chain the <strong class="screenText">False</strong> output node to another <strong class="screenText">If</strong> that checks the pressure of the other keys, and then, we move backward using the <strong class="screenText">Multiply (Scalar)</strong> node to inverse the speed. You can see nodes like <code class="inlineCode">If</code> that have more than one <strong class="screenText">Flow Output </strong>pin to branch the execution of the code.</p>
    <p class="normal">Also note the <a id="_idIndexMarker280"/>usage of the <strong class="screenText">GetKey (Key)</strong> node, the <a id="_idIndexMarker281"/>Visual Scripting version of the same <strong class="screenText">GetKey</strong> function we used previously. When looking at this node in the <strong class="screenText">Search</strong> box, you will see all the versions of the function, and in this case, we selected the <strong class="screenText">GetKey(Key) </strong>version; the one that receives a name (string) works differently, so we are not covering that one:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_11_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.11: All versions of Input GetKey</p>
    <p class="normal">We also used the <code class="inlineCode">Or</code> node to combine the two <strong class="screenText">GetKey (Key)</strong> functions into one condition to give to the <code class="inlineCode">If</code>. These conditional operators can be found in the <strong class="screenText">Logic</strong> category of the <strong class="screenText">Search</strong> box:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_12_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.12: The Boolean Logic operators</p>
    <p class="normal">One thing to <a id="_idIndexMarker282"/>highlight is the usage of the <strong class="screenText">Multiply</strong> node to multiply the value of the speed variable by –1. We needed to create a <strong class="screenText">Float Literal</strong> node to represent the –1 value. Then, surely, all programmers will <a id="_idIndexMarker283"/>notice some limitations regarding how we used the <code class="inlineCode">If</code> node’s <code class="inlineCode">True</code> and <code class="inlineCode">False</code> output pins, but we will address that in a moment. Finally, consider that this implementation has the problem of blocking the second input read if the first is successful; we will discuss a way to fix this when we add rotation to our character later in this section.</p>
    <p class="normal">Now, let’s implement the <a id="_idIndexMarker284"/>mouse controls. In this section, we will only cover rotation with mouse movement; we will shoot bullets in the next section, <em class="italic">Implementing spawning</em>. In the case of mouse movement, we can get a value saying how much the mouse has moved both horizontally and vertically. This value isn’t a Boolean but a number: a type of input usually known as an <strong class="screenText">axis</strong>.<strong class="screenText"> </strong>The value of an axis will indicate the intensity of the movement, and the sign of that number will indicate the direction. For example, if Unity’s <code class="inlineCode">“Mouse X”</code> axis says <code class="inlineCode">0.5</code>, it means that the mouse moved to the right with a moderate speed, but if it says <code class="inlineCode">-1</code>, it moved quickly to the left, and if there is no movement, it will say <code class="inlineCode">0</code>. The same goes for sticks on gamepads; the axis named <strong class="screenText">Horizontal</strong> represents the horizontal movement of the left stick in common joysticks, so if the player pulls the stick fully to the left, it will say <code class="inlineCode">-1</code>.</p>
    <p class="normal">We can create our own axes to map other common joystick pressure-based controls, but for our game, the default ones are enough. To detect mouse movement, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Use the <code class="inlineCode">Input.GetAxis</code> function inside <code class="inlineCode">Update</code>, next to the movement <code class="inlineCode">if</code> statements, as shown in the following screenshot, to store the value of this frame’s mouse movement in a variable:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_13_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.13: Getting the horizontal movement of the mouse</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Use the <code class="inlineCode">transform.Rotate</code> function to rotate the character. This function receives the degrees<a id="_idIndexMarker285"/> to rotate in the x, y, and z axes. In this case, we need to rotate horizontally, so we will use <a id="_idIndexMarker286"/>the mouse movement value as the y-axis rotation, as shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_14_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.14: Rotating the object horizontally based on mouse movement</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">If you save and test this, you will notice that the character will rotate but very quickly or slowly, depending on your computer. Remember, this kind of value needs to be configurable, so let’s create a <code class="inlineCode">rotationSpeed</code> field to configure the speed of the player in the Editor:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_15_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.15: The speed and rotation speed fields</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Now, we need to multiply the mouse movement value by the speed, so, depending on the <code class="inlineCode">rotationSpeed</code>, we can increase or reduce the rotation amount. As <a id="_idIndexMarker287"/>an example, if we set a value of <code class="inlineCode">0.5</code> in the rotation speed, multiplying that value by the mouse movement will make the object rotate at half the previous speed, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_16_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.16: Multiplying the mouse movement by the rotation speed</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Save the code, and go <a id="_idIndexMarker288"/>back to the editor to set the rotation speed value. If you don’t do this, the object won’t rotate because the default value of the float type fields is <code class="inlineCode">0</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_17_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.17: Setting the rotation speed</p>
    <p class="normal">The Visual Scripting additions to achieve rotation will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_18_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.18: Rotating in Visual Scripting</p>
    <p class="normal">The first thing <a id="_idIndexMarker289"/>to note here is the usage of the <strong class="screenText">Sequence</strong> node. An output pin can only be attached to one other node, but in this case, <strong class="screenText">On Update</strong> needs to do two different things: rotate and move, each one being independent of the other. <strong class="screenText">Sequence</strong> is a node that will execute all its output pins one after the other, regardless of the results of each one. You can specify the number of output pins in the <strong class="screenText">Steps</strong> input box; in this example, two is enough.</p>
    <p class="normal">In the <a id="_idIndexMarker290"/>output pin <code class="inlineCode">0</code>, the first one, we added the rotation code, which is pretty self-explanatory, given that it is essentially the same as the movement code with slightly different nodes (<strong class="screenText">Rotate </strong>(<strong class="screenText">X, Y, Z</strong>) and <strong class="screenText">GetAxis</strong>). Then, to output pin 1, we attached the <code class="inlineCode">If</code> that checks the movement input—the one we did at the beginning of this section. This will cause the rotation to be executed first and the movement second.</p>
    <p class="normal">Regarding the limitation we mentioned before, it’s basically the fact that we cannot execute both <strong class="screenText">forward</strong> and <strong class="screenText">backward</strong> movements, given that if the forward movement keys are pressed, the first <code class="inlineCode">If</code> will be true. Because the backward key movement is checked in the false output pin, they won’t be checked in such cases. Of course, as our first movement script, it might be enough, but consider the lateral movement. If we continue the <code class="inlineCode">If</code> chaining using <code class="inlineCode">True</code> and <code class="inlineCode">False</code> output pins, we will have a scenario where we can only move in one direction. So we cannot combine, for example, <code class="inlineCode">Forward</code> and <code class="inlineCode">Right</code> to move diagonally.</p>
    <p class="normal">A simple solution <a id="_idIndexMarker291"/>to this issue is to put the <code class="inlineCode">If</code> nodes in the sequence instead of chaining them, so all the <code class="inlineCode">If</code> nodes are checked, which we did in the original C#. You can see an example of this in the next image:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_19_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.19: Sequencing Ifs</p>
    <p class="normal">Something to <a id="_idIndexMarker292"/>consider here is that the connection of the <code class="inlineCode">If</code> nodes and any kind of node can be removed by right-clicking the circle pins on both ends of the line that connects them.</p>
    <div class="note">
      <p class="normal">Making basic input scripting tends to be easy, but the most difficult thing to do is to make intuitive and engaging input. Aside from adhering to the standards for the user to quickly adapt to your game, like jumping with the <em class="keystroke">Space</em> key or the A button in a gamepad, I recommend experimenting with the full expressivity of controls. That will allow us to better understand when it feels natural to use things like drag-and-drop, charging a punch when holding the key and executing the punch when releasing it, or using the triggers to control progressive things like the acceleration/braking of a car. This is even more interesting when talking about AR/VR experiences, where the possibilities are endless.</p>
    </div>
    <p class="normal">Now that we<a id="_idIndexMarker293"/> have completed our movement script, we need to refine it to work on every machine by exploring the concept of Delta Time.</p>
    <h2 id="_idParaDest-93" class="heading-2">Understanding Delta Time</h2>
    <p class="normal">Unity’s <strong class="screenText">Update</strong> loop <a id="_idIndexMarker294"/>executes as fast as the computer can. While you can set in Unity the desired frame rate, achieving it depends exclusively on <a id="_idIndexMarker295"/>your computer’s capabilities, which are influenced by various factors, not just hardware. This means you can’t always guarantee a consistent FPS. You must code your scripts to handle every possible scenario. Our current script moves at a certain speed per frame, and the <em class="italic">per frame</em> part is important here.</p>
    <p class="normal">We have set the movement speed to 0.1, so if my computer runs the game at 120 FPS, the player will move 12 meters per second. Now, what happens on a computer where the game runs at 60 FPS? As you can guess, it will move only 6 meters per second, making our game have inconsistent behavior across different computers. This is where Delta Time saves the day.</p>
    <p class="normal"><strong class="screenText">Delta Time</strong> is a value that tells us how much time has passed since the previous frame. This time depends a lot on our game’s graphics, number of entities, physics bodies, audio, and countless aspects that will dictate how fast your computer can process a frame. As an example, if your game runs at 10 FPS, it means that, in a second, your computer can process the <code class="inlineCode">Update</code> loop 10 times, meaning that each loop takes approximately <code class="inlineCode">0.1</code> seconds; in the frame, Delta Time will provide that value.</p>
    <p class="normal">In the following diagram, you can see an example of four frames taking different times to process, which can happen in real-life cases:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_20_PRE_Book.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.20: Delta Time values varying in different frames of the game</p>
    <p class="normal">Here, we<a id="_idIndexMarker296"/> need to code in such a way as to change the <em class="italic">per frame</em> part of the movement to <em class="italic">per second</em>; we need to have consistent movement per <a id="_idIndexMarker297"/>second across different computers. One way to do that is to move proportionally to the Delta Time; the higher the Delta Time value, the longer that frame is, and the further the movement should be to match the real time that has passed since the last update. We can think about our <code class="inlineCode">speed</code> field’s current value in terms of <code class="inlineCode">0.1</code> meters per second; our Delta Time saying <code class="inlineCode">0.5</code> means that half a second has passed, so we should move half the speed, <code class="inlineCode">0.05</code>.</p>
    <p class="normal">After two frames a second have passed, the sum of the movements of the frames (2 x 0.05) matches the target speed, <code class="inlineCode">0.1</code>. Delta Time can be interpreted as the percentage of a second that has passed.</p>
    <p class="normal">To make the Delta Time affect our movement, we should simply multiply our speed by Delta Time every frame because it can be different every frame. So let’s do that:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">We access Delta Time using <code class="inlineCode">Time.deltaTime</code>. We can start affecting the movement by multiplying the Delta Time in every <code class="inlineCode">Translate</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_21_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.21: Multiplying speed by Delta Time</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">We can <a id="_idIndexMarker298"/>do the same with the rotation <a id="_idIndexMarker299"/>speed by chaining the mouse and speed multiplications:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_22_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.22: Applying Delta Time to the rotation code</p>
    <p class="normal">If you save and play the game, you will notice that the movement will be slower than before. That’s because now <code class="inlineCode">0.1</code> is the movement per second, meaning <code class="inlineCode">10</code> centimeters per second, which is pretty slow; try raising those values. In my case, <code class="inlineCode">10</code> for speed and <code class="inlineCode">180</code> for rotation speed were enough, but the rotation speed depends on the player’s preferred sensibility, which can be configurable, but let’s keep that for another time.</p>
    <p class="normal">The Visual Scripting change for the rotation will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_23_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.23: Applying Delta Time to the Rotate Visual Script</p>
    <p class="normal">For <a id="_idIndexMarker300"/>movement, you<a id="_idIndexMarker301"/> can easily extrapolate from this example or check the project on GitHub. We simply chained another <strong class="screenText">Multiply</strong> node with <strong class="screenText">Get Delta Time</strong>.</p>
    <p class="normal">We just learned how to mix the Input System of Unity, which tells us about the state of the keyboard, mouse, and other input devices, with the basic <code class="inlineCode">Transform</code> movement functions. This way, we can start making our game feel more dynamic.</p>
    <p class="normal">Now that we have finished the player’s movement, let’s discuss how to make the player shoot bullets using <code class="inlineCode">Instantiate</code> functions.</p>
    <h1 id="_idParaDest-94" class="heading-1">Implementing spawning</h1>
    <p class="normal">We have<a id="_idIndexMarker302"/> created lots of objects in the editor that define our level, but once the game begins, and according to the player’s actions, new objects must be created to better fit the scenarios generated by player interaction. Enemies might need to appear after a while, or bullets must be created according to the player’s input; even when enemies die, there’s a chance of spawning a power-up. This means that we cannot create all the necessary objects beforehand but should create them dynamically, and that’s done through scripting.</p>
    <p class="normal">In this section, we will examine the following spawning concepts:</p>
    <ul>
      <li class="bulletList">Spawning objects</li>
      <li class="bulletList">Timing actions</li>
      <li class="bulletList">Destroying objects</li>
    </ul>
    <p class="normal">We will start<a id="_idIndexMarker303"/> seeing the Unity <code class="inlineCode">Instantiate</code> function, which allows us to create instances of Prefabs at runtime, such as when pressing a key, or in a time-based fashion, such as making our enemy spawn bullets once every so often. Also, we will learn how to destroy these objects to prevent our scene from starting to perform badly due to too many objects being processed.</p>
    <p class="normal">Let’s start with how to shoot bullets according to the player’s input.</p>
    <h2 id="_idParaDest-95" class="heading-2">Spawning objects</h2>
    <p class="normal">To spawn<a id="_idIndexMarker304"/> an object in runtime or <strong class="screenText">Play</strong> mode, we need a description of the object, which components it has, its settings, and its possible sub-objects. You might be thinking about Prefabs here, and you are right; we will use an instruction that will tell Unity to create an instance of a Prefab via scripting. Remember that an instance of a Prefab is an object created based on the Prefab—basically a clone of the original one.</p>
    <p class="normal">We will start by shooting the player’s bullets, so first, let’s create the bullet Prefab by following these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create a sphere in <strong class="screenText">GameObject | 3D Object | Sphere</strong>. You can replace the sphere mesh with another bullet model if you want, but we will keep the sphere in this example for now.</li>
      <li class="numberedList">Rename the sphere <code class="inlineCode">Bullet</code>.</li>
      <li class="numberedList">Create a material by clicking on the <strong class="screenText">+</strong> button of the <strong class="screenText">Project</strong> window, choosing the option <strong class="screenText">Material</strong>, and calling it <code class="inlineCode">Bullet</code>. Remember to place it inside the <code class="inlineCode">Materials</code> folder.</li>
      <li class="numberedList">Check the <strong class="screenText">Emission</strong> checkbox in the material, and set the <strong class="screenText">Emission Map</strong> and <strong class="screenText">Base Map</strong> colors to red:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_24.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.24: Creating a red bullet material with an emission color</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Apply<a id="_idIndexMarker305"/> the <strong class="screenText">Material</strong> to the <strong class="screenText">Sphere</strong> by dragging the material to it.</li>
      <li class="numberedList">Set the <strong class="screenText">Scale</strong> to a smaller value—<code class="inlineCode">0.3, 0.3, 0.3</code> worked in my case.</li>
      <li class="numberedList">Create a script called <code class="inlineCode">ForwardMovement</code> to make the bullet constantly move forward at a fixed speed. You can create it both with C# and Visual Scripting, but for simplicity, we are only going to use C# in this case.<div class="note">
          <p class="normal">I suggest you try to solve this by yourself first and look at the screenshot in the next step with the solution later as a little challenge, recapping the movement concepts we saw previously. If you don’t recall how to create a script, please refer to <em class="chapterRef">Chapter 5</em>, <em class="italic">Unleashing the Power of C# and Visual Scripting</em>, and check the previous section to see how to move objects.</p>
        </div>
      </li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">The next <a id="_idIndexMarker306"/>screenshot shows you what the script should look like:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_25_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.25: A simple ForwardMovement script</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">Add the script (if not already there) to the bullet, and set the speed to a value you see fit. Usually, bullets are faster than the player, but that depends on the game experience you want to get. In my case, <code class="inlineCode">20</code> worked fine. Test it by placing the bullet near the player and playing the game:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_26.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.26: A ForwardMovement script in the bullet</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="10">Drag the <a id="_idIndexMarker307"/>bullet <code class="inlineCode">GameObject</code> instance to the <code class="inlineCode">Prefabs</code> folder to create a <strong class="screenText">Bullet </strong>Prefab. Remember that the Prefab is an asset that has a description of the created bullet, like a blueprint of how to create a bullet:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_27_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.27: Creating a Prefab</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="11">Remove the original bullet from the scene; we will use the Prefab to create bullets when the player presses a key (if ever).</li>
    </ol>
    <p class="normal">Now that we have our bullet Prefab, it is time to instantiate it (clone it) when the player presses a key. To do that, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create and add a script to the player’s <code class="inlineCode">GameObject</code> called <code class="inlineCode">PlayerShooting</code>, and open it.</li>
      <li class="numberedList">We need <a id="_idIndexMarker308"/>a way for the script to have access to the Prefab to know which Prefab to use from probably the dozens we will have in our project. All of the data that our script needs, which depends on the desired game experience, is in the form of a field, such as the <strong class="screenText">speed</strong> field used previously. So, in this case, we need a field of the <code class="inlineCode">GameObject</code> type—a field that can reference or point to a specific Prefab, which can be set using the editor.</li>
      <li class="numberedList">Adding the field code would look like this:
    <figure class="mediaobject"><img src="../Images/B21361_06_28_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.28: The Prefab reference field</p>
    <p class="normal">As you might have guessed, we can use the <code class="inlineCode">GameObject</code> type to reference not only Prefabs but also other objects. Imagine an enemy AI needing a reference to the player object to get its position, using <code class="inlineCode">GameObject</code> to link the two objects. The trick here is considering that Prefabs are just regular GameObjects that live outside the scene; you cannot see them, but they are in memory, ready to be copied or instantiated. You will only see them through copies or instances that are placed in the scene with scripting or via the editor, as we have done so far.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In the editor, click on the circle toward the right of the property and select the <code class="inlineCode">Bullet</code> Prefab. Another option is to just drag the <code class="inlineCode">Bullet</code> Prefab to the property. This way, we tell our script that the bullet to shoot will be that particular one. Remember to drag the Prefab and not the bullet in the scene (the one in the scene should have been deleted by now):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_29_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.29: Setting the Prefab reference to point the bullet</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">We will shoot<a id="_idIndexMarker309"/> the bullet when the player presses the left mouse button, so place the appropriate <code class="inlineCode">if</code> statement to handle that in the <code class="inlineCode">Update</code> event function, like the one shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_30_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.30: Detecting the pressure of the left mouse button</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">You will notice that this time, we used <code class="inlineCode">GetKeyDown</code> instead of <code class="inlineCode">GetKey</code>, the former being a way to detect the exact frame the pressure of the key started; this <code class="inlineCode">if</code> statement executes its code only in that frame and until the key is released and re-pressed, it won’t enter again. This is one way to prevent bullets from spawning in every frame, but just for fun, you can try using <code class="inlineCode">GetKey</code> instead to check how it would behave. Also, <code class="inlineCode">KeyCode.Mouse0</code> is the mouse button number that belongs to the left-click, <code class="inlineCode">KeyCode.Mouse1</code> is the right-click, and <code class="inlineCode">KeyCode.Mouse2</code> is the middle click.</li>
      <li class="numberedList">Use the <code class="inlineCode">Instantiate</code> function to clone the Prefab, passing the reference to it as the first parameter. This will create a clone of the aforementioned Prefab that will be placed in the scene:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_31_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.31: Instantiating the Prefab</p>
    <p class="normal">If you save the <a id="_idIndexMarker310"/>script and play the game, you will notice that when you press the mouse, a bullet will spawn, but probably not in the place you expect. If you don’t see it, check the Hierarchy for new objects; it will be there. The problem here is that we didn’t specify the desired spawn position, and we have two ways of setting that, which we will see in the next steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">The first way is to use the <code class="inlineCode">transform.position</code> and <code class="inlineCode">transform.rotation</code> inherited fields from <code class="inlineCode">MonoBehaviour</code>, which will tell us our current position and rotation, respectively. We can pass them as the second and third parameters of the <code class="inlineCode">Instantiate</code> function, which will understand that this is the place we want our bullet to appear. Remember that it is important to set the rotation to make the bullet face the same direction as the player so that it will move that way:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_32_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.32: Instantiating the Prefab in our position and rotation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">The second way is by using the previous version of <code class="inlineCode">Instantiate</code> but saving the reference returned by the function, which will point to the clone of the Prefab. This allows us to change whatever we want from it. In this case, we will need the following three lines: the first will instantiate and capture the clone reference, the second will set the position, and the third will set the rotation. We will also use the <code class="inlineCode">transform.position</code> field of the clone, but this time to change its value by using the <code class="inlineCode">=</code> (assignment) operator:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_33_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.33: The longer version of instantiating a Prefab in a specific position</p>
    <p class="normal">Remember that <a id="_idIndexMarker311"/>you can check the project’s GitHub repository linked in the <em class="italic">Preface</em> to see the full script finished. Now, you can save the file with one of the versions and try to shoot.</p>
    <p class="normal">If you try the script so far, you should see the bullet spawn in the player’s position, but in our case, it will probably be the floor. The problem here is that the player’s character pivot is there, and usually, every humanoid character has the pivot in their feet. We have several ways to fix that. The most flexible method is to create a <strong class="screenText">Shoot Point</strong>, an empty GameObject child of the player, placed in the position we want the bullet to spawn. We can use the position of that object instead of the player’s position by following these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an empty <code class="inlineCode">GameObject</code> in <strong class="screenText">GameObject | Create Empty</strong>. Name it <code class="inlineCode">ShootPoint</code>.</li>
      <li class="numberedList">Make it a child of the player’s GameObject, and place it where you want the bullet to appear, probably a little higher and further forward:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_34_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.34: An empty ShootPoint object placed inside the character</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">As usual, to access the data of another object, we need a reference to it, such as the Prefab <a id="_idIndexMarker312"/>reference, but this time, it needs to point to our <code class="inlineCode">ShootPoint</code>. We can create another <code class="inlineCode">GameObject</code> type field, but this time, drag <code class="inlineCode">ShootPoint</code> instead of the Prefab. The script and the object set would look as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_35_%26_36_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.35: The Prefab and Shoot Point fields and how they are set in the editor</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">We can access the position of the <code class="inlineCode">ShootPoint</code> by using its <code class="inlineCode">transform.position</code> field again, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_37_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.36: Positioning the bullet clone in the shooting spawn point</p>
    <p class="normal">The Visual Scripting version of <strong class="screenText">ForwardMovement</strong> will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_38_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.37: ForwardMovement with Visual Scripting</p>
    <p class="normal">And <code class="inlineCode">PlayerShooting</code> will <a id="_idIndexMarker313"/>look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_39_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.38: Instantiating in the PlayerShooting Visual Script</p>
    <p class="normal">As you can see, we<a id="_idIndexMarker314"/> added a second <strong class="screenText">Script Machine</strong> component with a new graph called <strong class="screenText">Player Shooting</strong>. We also added a new variable, <code class="inlineCode">bulletPrefab</code>, of type <code class="inlineCode">GameObject</code> and dragged the <strong class="screenText">Bullet</strong> Prefab to it, and a second <code class="inlineCode">GameObject</code> type variable called <code class="inlineCode">shootPoint</code>, to have a reference to the bullet’s spawn position. The rest of the script is essentially the counterpart of the C# version without any major differences.</p>
    <p class="normal">Something to highlight here is how we connected the <code class="inlineCode">Transform GetPosition</code> and <code class="inlineCode">Transform GetRotation</code> nodes to the <code class="inlineCode">GetVariable</code> node belonging to the <code class="inlineCode">shootPoint</code>; this way, we access the position and rotation of the shooting point. If you don’t specify that, it will use the player’s position and rotation, which, in the case of our model, is in the player’s character’s feet.</p>
    <p class="normal">You will notice that, now, shooting and rotating with the mouse has a problem; when moving the mouse to rotate, the pointer will fall outside the <strong class="screenText">Game</strong> view, and when clicking, you will accidentally click the editor, losing the focus on the <strong class="screenText">Game</strong> view, so you will need to click the <strong class="screenText">Game</strong> View again to regain focus and use input again. A way to prevent this is to disable <a id="_idIndexMarker315"/>the cursor while playing. To do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add a <code class="inlineCode">Start</code> event function to our <code class="inlineCode">Player Movement</code> script.</li>
      <li class="numberedList">Add the two lines you can see in the following screenshot to your script. The first one will make the cursor visible, and the second one will lock it in the middle of the screen so that it will never abandon the <strong class="screenText">Game</strong> View. Consider the latter; you will need to reenable the cursor when you switch back to the main menu or the pause menu, allowing the mouse to click the UI buttons:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_40_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.39: Disabling the mouse cursor</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Save and test this. If you want to stop the game, you could press either <em class="keystroke">Ctrl</em> + <em class="keystroke">Shift</em> + <em class="keystroke">P</em> (<em class="keystroke">Command</em> + <em class="keystroke">Shift</em> + <em class="keystroke">P</em> on a Mac) or the <em class="keystroke">Esc</em> key to reenable the mouse. Both options only work in the editor; in the real game, you will need to reset <code class="inlineCode">Cursor.visible</code> to <code class="inlineCode">true</code> and <code class="inlineCode">Cursor.lockState</code> to <code class="inlineCode">CursorLockMode.None</code>.</li>
      <li class="numberedList">The Visual Scripting equivalent will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_41_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.40: Disabling the mouse cursor in Visual Scripting</p>
    <p class="normal">Now that we have<a id="_idIndexMarker316"/> covered the basics of object spawning, let’s see an advanced example by combining it with timers.</p>
    <h2 id="_idParaDest-96" class="heading-2">Timing actions</h2>
    <p class="normal">Not entirely <a id="_idIndexMarker317"/>related to spawning but usually used together, timing actions are common tasks in video games. The idea is to schedule something to happen later; maybe we want a bullet to be destroyed after a while to prevent memory overflow, or we want to control the spawn rate of enemies or when they should spawn. That’s exactly what we are going to do in this section, starting with implementing <strong class="screenText">enemy waves</strong>.</p>
    <p class="normal">The idea is that we want to spawn enemies at a certain rate in different moments of the game; maybe we want to spawn enemies from the beggining during 5 seconds at a rate of 2 per second, getting 10 enemies and giving the player up to 20 seconds to finish them, programming another wave, starting at 25 seconds. Of course, this depends a lot on the exact game you want, and you can start with an idea like this one and modify it after some testing to find the exact way you want the wave system to work. In our case, we will apply timing by implementing a simple wave system.</p>
    <p class="normal">First of all, we need an enemy, and for now, we will simply use the same 3D model we used for the player but add a <code class="inlineCode">Forward Movement</code> script to simply make it move forward; later in this book, we will add AI behavior to our enemies. I suggest you try creating this Prefab on your own first. After you have done so, refer to the following steps to compare your work with the recommended approach and confirm if you’ve done it correctly:</p>
    <p class="normal">Drag the downloaded Character FBX model to the scene to create another instance of it, but name it <code class="inlineCode">Enemy</code> this time:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add the <code class="inlineCode">ForwardMovement</code> script created for the bullets, but this time as <code class="inlineCode">Enemy</code>, and set it at a speed of <code class="inlineCode">10</code> for now.</li>
      <li class="numberedList">Drag the <code class="inlineCode">Enemy</code> GameObject to the <strong class="screenText">Project</strong> panel to create its Prefab; we will need to spawn it later. Remember to select <strong class="screenText">Prefab Variant</strong> to keep this Prefab linked with the original model, allowing any changes to the model to automatically update the Prefab.</li>
      <li class="numberedList">Remember <a id="_idIndexMarker318"/>also to destroy the original <code class="inlineCode">Enemy</code> from the scene.
    <p class="normal">Now, to schedule actions, we will use the <code class="inlineCode">Invoke</code> functions to create timers. They are basic but enough for our requirements. Let’s use them by following these steps:</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Create an empty GameObject at one end of the base and call it <code class="inlineCode">Wave1a</code>.</li>
      <li class="numberedList">Create and add a script called <code class="inlineCode">WaveSpawner</code> to it.</li>
      <li class="numberedList">Our spawner will need four fields: the <code class="inlineCode">Enemy</code> <code class="inlineCode">Prefab</code> to spawn, the <code class="inlineCode">startTime</code> of the wave, the <code class="inlineCode">endTime</code>, and the spawn rate of the enemies (how much time should be between each spawn). The script and the settings will look like the following screenshot:
    <figure class="mediaobject"><img src="../Images/B21361_06_42_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.41: The fields of the wave spawner script</p>
    <p class="normal">We will use the <code class="inlineCode">InvokeRepeating</code> function to schedule a custom function to repeat periodically. You will need to schedule the repetition just once; Unity will remember that, so don’t do it for every frame. This is a good reason to use the <code class="inlineCode">Start</code> event function instead. The first argument of the function is a string (text between the quotation marks) with the name of the other function to execute periodically, and unlike <code class="inlineCode">Start</code> or <code class="inlineCode">Update</code>, you can name the function whatever you want. The second argument is the time to start repeating—our <code class="inlineCode">startTime</code> field, in this case. Finally, the third argument is the repetition rate of the function—how much time needs to pass between each repetition—this being the <code class="inlineCode">spawnRate</code> field. </p>
    <p class="normal">You can find how to call that function<a id="_idIndexMarker319"/> in the next screenshot, along with the custom <code class="inlineCode">Spawn</code> function:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_43_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.42: Scheduling a Spawn function to repeat</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Inside the <code class="inlineCode">Spawn</code> function, we can add the spawning code using the <code class="inlineCode">Instantiate</code> function. The idea is to call this function at a certain rate to spawn one enemy per call. This time, the spawn position will be in the same position as the spawner, so place it carefully:
    <figure class="mediaobject"><img src="../Images/B21361_06_44_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.43: Instantiating in the Spawn function</p>
    <p class="normal">If you test this script by setting the Prefab <code class="inlineCode">startTime</code> and <code class="inlineCode">spawnRate</code> fields to some values greater than 0, you will notice that the enemies will start spawning but never stop, and you can see that we haven’t used the <code class="inlineCode">endTime</code> field so far. The idea is to call the <code class="inlineCode">CancelInvoke</code> function, the one function that will cancel all the <code class="inlineCode">InvokeRepeating</code> calls we made, but after a while. We will delay the execution of <code class="inlineCode">CancelInvoke</code> using the <code class="inlineCode">Invoke</code> function, which works similarly to <code class="inlineCode">InvokeRepeating</code>, but this one executes just once. In the next screenshot, you can see how we added an <code class="inlineCode">Invoke</code> call to the <code class="inlineCode">CancelInvoke</code> function in <code class="inlineCode">Start</code>, using the <code class="inlineCode">endTime</code> field as the time to execute <code class="inlineCode">CancelInvoke</code>. This will execute <code class="inlineCode">CancelInvoke</code> after a while, canceling the first <code class="inlineCode">InvokeRepeating</code> call that spawns the Prefab:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_45_PRE_BOOk.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.44: Scheduling a Spawn repetition but canceling after a while with CancelInvoke</p>
    <p class="normal">This<a id="_idIndexMarker320"/> time, we used <code class="inlineCode">Invoke</code> to delay the call to <code class="inlineCode">CancelInvoke</code>. We didn’t create a custom function because <code class="inlineCode">CancelInvoke</code> doesn’t receive arguments. If you need to schedule a function with arguments, you will need to create a wrapper function; this function should have no parameters itself but is used to call your target function (the one you originally intend to use) with the necessary arguments. This approach is similar to what we did with the <code class="inlineCode">Spawn</code> function, where the wrapper’s sole purpose is to call the <code class="inlineCode">Instantiate</code> method with specific arguments.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Now, you can save and set some real values to your spawner. In my case, I used the ones shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_46_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.45: Spawning enemies from the beggining during 5 seconds of the gameplay every 0.5 seconds, and 2 per second</p>
    <p class="normal">You should see <a id="_idIndexMarker321"/>the enemies being spawned next to each other, and because they move forward, they will form a row. This behavior will change later when we make use of the AI features of Unity in a future chapter. Now, the Visual Scripting version will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_47_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.46: Spawning enemies in Visual Scripting</p>
    <p class="normal">While we <a id="_idIndexMarker322"/>could use the <code class="inlineCode">InvokeRepeating</code> approach in Visual Scripting, here we can see some benefits of the visual approach, given that it sometimes has more flexibility than coding. In this case, we used the <code class="inlineCode">Wait For Seconds</code> node at the beginning of the <code class="inlineCode">Start</code>, a node that basically will hold the execution of the flow for a couple of seconds. This will create the initial delay we had in the original script; that’s why we used the <code class="inlineCode">startTime</code> as the amount of <code class="inlineCode">Delay</code>.</p>
    <p class="normal">Now, after the wait, we used a <code class="inlineCode">For</code> loop; for this example, we changed the concept of the script, as we want to spawn a specific number of enemies instead of spawning during a set time. The <code class="inlineCode">For</code> loop is essentially a classic <code class="inlineCode">For</code> that will repeat whatever is connected to the <code class="inlineCode">Body</code> output pin the number of times specified by the <code class="inlineCode">Last</code> input pin.</p>
    <p class="normal">We connected <a id="_idIndexMarker323"/>that pin to a variable to control the number of enemies we wanted to spawn. Then, we connected an <code class="inlineCode">Instantiate</code> to the <code class="inlineCode">Body</code> output pin of the <code class="inlineCode">For</code> loop to instantiate our enemies and then a <code class="inlineCode">Wait For Seconds</code> node to stop the flow for a set time before the loop can continue spawning enemies.</p>
    <p class="normal">What is interesting is that if you play the game now, you will receive an error in the console that looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_48_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.47: Error when using Wait nodes</p>
    <p class="normal">You can even go back to the Graph Editor and see that the conflicting node will be highlighted in red:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_49_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.48: Node causing the error</p>
    <p class="normal">The issue here<a id="_idIndexMarker324"/> is that in order for the <code class="inlineCode">Wait For Seconds</code> nodes to work, you need to mark the <code class="inlineCode">Start</code> event as a <strong class="screenText">Coroutine</strong>. This will basically allow the event to be paused for an amount of time and be resumed later.</p>
    <div class="note">
      <p class="normal">The concept of coroutines exists in C#, but as it is simpler to implement here in Visual Scripting than in C#, we decided to go with this approach here. If you want more info about them, please check out this documentation: <a href="https://docs.unity3d.com/Manual/Coroutines.html"><span class="url">https://docs.unity3d.com/Manual/Coroutines.html</span></a></p>
    </div>
    <p class="normal">To solve this error, just select the <code class="inlineCode">On Start</code> event node and check the <strong class="screenText">Coroutine</strong> checkbox in the <strong class="screenText">Graph Inspector</strong> pane on the left of the <strong class="screenText">Script Graph</strong> Editor. If you don’t see it, try clicking the <strong class="screenText">Info</strong> button (the circle with <em class="italic">i</em>) in the top-left part of the editor.</p>
    <p class="normal">A coroutine is a function that can be paused and resumed later, and that’s exactly what the <code class="inlineCode">Wait</code> node does. Coroutines <a id="_idIndexMarker325"/>also exist in <code class="inlineCode">MonoBehaviours</code>, but let’s keep things simple for now.</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_50_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.49: Marking Start as a coroutine</p>
    <p class="normal">Now that we have discussed timing and spawn, let’s discuss timing and <code class="inlineCode">Destroy</code> to prevent our bullets from living forever in the memory.</p>
    <h2 id="_idParaDest-97" class="heading-2">Destroying objects</h2>
    <p class="normal">We <a id="_idIndexMarker326"/>can use the <code class="inlineCode">Destroy</code> function to destroy object instances. The idea is to make bullets have a script that schedules their own auto-destruction after a while to prevent them from living forever. We will create the script by following these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the Prefab of <code class="inlineCode">Bullet</code>, and add a script called <code class="inlineCode">Autodestroy</code> to it, as you did with other objects using the <strong class="screenText">Add Component</strong> | <strong class="screenText">New Script</strong> option. This time, the script will be added to the Prefab, and each instance of the Prefab you spawn will have it.</li>
      <li class="numberedList">You can use the <code class="inlineCode">Destroy</code> function, as shown in the next screenshot, to destroy the object just once in <code class="inlineCode">Start</code>:
    <figure class="mediaobject"><img src="../Images/B21361_06_51_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.50: Destroying an object when it starts</p>
    <p class="normal">The <code class="inlineCode">Destroy</code> function<a id="_idIndexMarker327"/> expects the object to destroy as the first argument, and here, we use the <code class="inlineCode">gameObject</code> reference—a way to point to the GameObject that our script is placed into to destroy it. If you use the <code class="inlineCode">this</code> pointer instead of <code class="inlineCode">GameObject</code>, we will destroy only the <code class="inlineCode">Autodestroy</code> component we are creating.</p>
    <p class="normal">Of course, we don’t want the bullet to be destroyed as soon as it is spawned, so we need to delay the destruction. You may be thinking about using <code class="inlineCode">Invoke</code>, but unlike most functions in Unity, <code class="inlineCode">Destroy</code> can receive a second argument, which is the time to wait until destruction.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Create a delay field to use as the second argument of <code class="inlineCode">Destroy</code>, as shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_52_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.51: Using a field to configure the delay to destroy the object</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Set the <code class="inlineCode">delay</code> field to a proper value; in my case, 5 was enough. Now, check how the bullets despawn (i.e., are removed) after a while by looking at them being removed from the Hierarchy.</li>
      <li class="numberedList">The<a id="_idIndexMarker328"/> Visual Scripting equivalent will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_06_53_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.52: Destroying in Visual Scripting</p>
    <p class="normal">Regarding this version, note how we use the <strong class="screenText">Component Destroy </strong>(<strong class="screenText">Obj</strong> and <strong class="screenText">T</strong>)<strong class="screenText"> </strong>version of the <code class="inlineCode">Destroy</code> node, which includes the delay time. Additionally, look for the <code class="inlineCode">Object Pool</code><strong class="screenText"> </strong>concept, which is a way to recycle objects instead of creating them constantly; you will learn that sometimes creating and destroying objects is not that performant.</p>
    <p class="normal">Now, we can create and destroy objects at will, which is something very common in Unity scripting. In the next section, we will discuss how to modify the scripts we have created so far to support the new Unity Input System.</p>
    <h1 id="_idParaDest-98" class="heading-1">Using the new Input System</h1>
    <p class="normal">We have <a id="_idIndexMarker329"/>been using the <strong class="screenText">Input</strong> class to detect the buttons and axes being pressed, and for our simple usage, that is more than enough. However, the default Unity Input System has its limitations regarding extensibility to support new input hardware and mappings.</p>
    <p class="normal">In this section, we will explore the following concepts:</p>
    <ul>
      <li class="bulletList">Installing the new Input System</li>
      <li class="bulletList">Creating Input Mappings</li>
      <li class="bulletList">Using mappings in scripts</li>
    </ul>
    <p class="normal">Let’s start exploring how to install the new Input System.</p>
    <h2 id="_idParaDest-99" class="heading-2">Installing the new Input System</h2>
    <p class="normal">To start<a id="_idIndexMarker330"/> using the new Input System, it needs to be installed like any other package we have installed so far, using the <strong class="screenText">Package Manager</strong>. The package is just called <strong class="screenText">Input System</strong>, so go ahead and install it as usual. In this case, we are using version 1.7.0, but a newer one may be available by the time you read this chapter.</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_54.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.53: Installing the new Input System package</p>
    <p class="normal">By default, when you install the Input System, it will prompt you to enable the new Input System, with a window like the one in the following image. If that appears, just click <strong class="screenText">Yes</strong> and wait for Unity to restart:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_55_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.54: Switching the active Input System</p>
    <p class="normal">If, for some<a id="_idIndexMarker331"/> reason, that doesn’t appear, the alternative is going to <strong class="screenText">Edit | Project Settings</strong> and then <strong class="screenText">Player | Other Settings | Configuration</strong>, and setting the <strong class="screenText">Active Input Handling</strong> property to <strong class="screenText">Input System Package (New)</strong>.</p>
    <p class="normal">There’s an option called <strong class="screenText">Both</strong> to keep both the old input system and the new one enabled, but let’s stick with just one.</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_56.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.55: Switching the active Input System</p>
    <p class="normal">Now that we<a id="_idIndexMarker332"/> have the system installed and set up, let’s explore how to create the Input Mappings needed.</p>
    <h2 id="_idParaDest-100" class="heading-2">Creating Input Mappings</h2>
    <p class="normal">The new <a id="_idIndexMarker333"/>system has a way to directly request the current state of a button or thumbstick to the gamepad, mouse, keyboard, or whatever other device we have, like what we have done so far with the previous Input System. However, using this method would prevent us from using one of the best features of the system, Input Mappings.</p>
    <p class="normal">The idea of an<a id="_idIndexMarker334"/> Input Mapping is to abstract input actions from the physical input. Instead of thinking about the space bar, the left thumbstick of a gamepad, or the right click of a mouse, you think in terms of actions, like moving, shooting, or jumping. In code, you ask if the <code class="inlineCode">Shoot</code> button has been pressed, or the current value of the <code class="inlineCode">Move</code> axes, as we did with the mouse axes rotation. While the previous system supported a certain degree of Input Mapping, the one in the new Input System is way more powerful and easier to configure.</p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Action</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Mappings</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Shoot</p>
          </td>
          <td class="table-cell">
            <p class="normal">Left mouse button, Left Control, and the <em class="keystroke">X</em> button of the gamepad</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Jump</p>
          </td>
          <td class="table-cell">
            <p class="normal">Space, <em class="keystroke">Y</em> button of gamepad</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Horizontal movement</p>
          </td>
          <td class="table-cell">
            <p class="normal"><em class="keystroke">A</em> and <em class="keystroke">D</em> keys, Left and Right arrows, and the gamepad Left Stick</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.01: Example of the Input Mapping table</p>
    <p class="normal">The <a id="_idIndexMarker335"/>power of this idea is that the actual keys or buttons that will trigger these actions are configurable in the Unity editor, allowing any game designed to alter the exact keys to control the entire game without changing the code.</p>
    <p class="normal">We can <a id="_idIndexMarker336"/>even map more than one button to the same action, even from different devices, so we can make the mouse, keyboard, and gamepad trigger the same action, greatly simplifying our code. Another benefit is that the user can also rebind the keys with some custom UI that we can add to our game, which is very common in PC games.</p>
    <p class="normal">The easiest way to start creating an Input Mapping is through the <strong class="screenText">Player Input </strong>component. This component, as the name suggests, represents the input of a particular player, allowing us to have one of those on each player in our game to support split-screen multiplayer, but let’s focus on single-player. Adding this script to our player will allow us to use the <strong class="screenText">Create Actions</strong> button to create a default Input Mapping asset. This asset, as a material, can be used by several players, so we will modify it so that it will affect all of them (for example, by the addition of the <code class="inlineCode">Jump</code> Input Mapping):</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_57_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.56: Creating input action assets using the Player Input component</p>
    <p class="normal">After clicking the <strong class="screenText">Create Actions</strong> button and saving the asset location in the save prompt, you will see the following screen:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_58_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.57: The default Input Mapping file</p>
    <p class="normal">The<a id="_idIndexMarker337"/> first part to understand from this asset is the <strong class="screenText">Action Maps</strong> section (the left panel). This allows us to create separate Action Maps for different situations, for example, for driving and on-foot controls in games like Grand Theft Auto (<strong class="keyWord">GTA</strong><em class="italic">)</em>. By default, <strong class="screenText">Player</strong> and <strong class="screenText">UI</strong> mappings are created to separate the mappings for the player controlling and navigating through the UI. If you check the <strong class="screenText">Player Input</strong> component again, you will see that the <strong class="screenText">Default Map </strong>property is set to <strong class="screenText">Player</strong>, which means that we will only concern ourselves with the player controlling the Input Mappings in this GameObject; any UI action pressed won’t be considered. We can switch the active map in runtime at will, for example, to disable the character controller input when we are in the pause menu or switch to the driving mappings while in a car, using the same buttons but for other purposes.</p>
    <p class="normal">If you select an Action Map in the left panel, you will see all the actions it contains in the <strong class="screenText">Actions</strong> list in the middle panel. In the case of the <strong class="screenText">Player</strong>, we have the <strong class="screenText">Move</strong>, <strong class="screenText">Look</strong>, and <strong class="screenText">Fire</strong> mappings, which are exactly the inputs we will use in our game. Bear in mind you can add more if you need to use the <strong class="screenText">+</strong> button, but for now, let’s stick with the default ones. When you select any action from the list, you will see their configurations in the <strong class="screenText">Action Properties </strong>panel shown on the right:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_59_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.59: The Move (left) and Fire (right) action configurations</p>
    <p class="normal">As you <a id="_idIndexMarker338"/>can see, there’s a property called <strong class="screenText">Action Type</strong> that will dictate which kind of input we are talking about. If you select <strong class="screenText">Move</strong> in the middle panel, you can see that it’s a <strong class="screenText">Value</strong> action type, with <strong class="screenText">Control Type</strong> being <code class="inlineCode">Vector2</code>, meaning it will return the x and y axis values, the horizontal and vertical values—the kind we expect from any thumbstick in a gamepad. In the previous system, we got those values from separate 1D axes, like the <code class="inlineCode">Mouse X</code> and <code class="inlineCode">Mouse Y</code> axes, but here, they are combined into a single variable for convenience. On the other hand, the <strong class="screenText">Fire</strong> action is of type <strong class="screenText">Button</strong>, which has the capacity not only to check its current state (pressed or released) but also do checks for things such as whether it has just been pressed or just released, the equivalents to <code class="inlineCode">GetKey</code>, <code class="inlineCode">GetKeyDown</code>, and <code class="inlineCode">GetKeyUp</code> from the previous system.</p>
    <p class="normal">Now that we understand which actions we have and of which type each one is, let’s discuss how the physical input will trigger them. You can click the arrow on the left of each action in the middle panel to see its physical mappings. Let’s start exploring the <strong class="screenText">Move</strong> action mappings.</p>
    <p class="normal">In this case, we have four mappings:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Left Stick</strong> [<strong class="keyWord">Gamepad</strong>]: The left stick of the gamepad</li>
      <li class="bulletList"><strong class="keyWord">Primary 2D Axis</strong> [<strong class="keyWord">XR Controller</strong>]: The main stick of the VR controllers</li>
      <li class="bulletList"><strong class="keyWord">Stick</strong> [<strong class="keyWord">Joystick</strong>]: The main stick for arcade-like joysticks or even flight sticks</li>
      <li class="bulletList"><strong class="keyWord">WASD</strong>: A composite input simulating a stick through the <em class="keystroke">W</em>, <em class="keystroke">A</em>, <em class="keystroke">S</em>, and <em class="keystroke">D</em> keys</li>
    </ul>
    <p class="normal">If you select any of them, you can check their configurations; let’s compare the left stick and WASD as an example:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_60_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.59: The left stick mapping (left) and the WASD key mapping (right)</p>
    <p class="normal">In the <a id="_idIndexMarker339"/>case of the <strong class="screenText">Left Stick</strong>, you can see the <strong class="screenText">Path</strong> property that allows you to pick all the possible hardware physical controls that provide <code class="inlineCode">Vector2</code> values (the x and y axes). In the case of the <strong class="screenText">WASD</strong> key mapping, you can see it is a composite binding of type <strong class="screenText">2D Vector</strong>, which, as stated previously, allows us to simulate a 2D axis with other inputs—keys in this case. If you expand the <strong class="screenText">WASD</strong> Input Mappings in the middle panel, you can see all inputs that are composited for this 2D axis and their configurations by selecting them:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_61_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.60: The inputs considered for the WASD composite 2D axis</p>
    <p class="normal">In the preceding case, it maps not only the <em class="keystroke">W</em>, <em class="keystroke">A</em>, <em class="keystroke">S</em>, and <em class="keystroke">D</em> buttons but also the four keyboard arrows. Each one of those mappings has not only a path to select the physical button but also the <strong class="screenText">Composite Part</strong> setting, allowing us to specify which direction this input will pull the simulated stick.</p>
    <p class="normal">And with<a id="_idIndexMarker340"/> this, we have just scratched the surface of what this system is capable of, but for now, let’s keep things simple and use these settings as they are. Remember that a new asset was created with the same name as our game (<em class="italic">SuperShooter</em>, in our case) in the root folder of the project. You can reopen this Action Mapping window by double-clicking it whenever you want. Now let’s see how we can use these inputs in our code.</p>
    <div class="note">
      <p class="normal">There’s much more this system can do for us. One example is Interactions, which allow us to do things like making the input trigger the action if it’s pressed for <em class="italic">X</em> amount of time. Another is Composite, which triggers the action if a combination of keys is pressed. Check the Input System package documentation here for more information: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6"><span class="url">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6</span></a></p>
    </div>
    <h2 id="_idParaDest-101" class="heading-2">Using Mappings in our scripts</h2>
    <p class="normal">This<a id="_idIndexMarker341"/> Input System provides several ways to detect the input state. The <strong class="screenText">Player Input</strong> component has a <strong class="screenText">Behavior</strong> property to switch between some of the available modes. The simplest one is the one called <strong class="screenText">Send Messages</strong>, which is the one that we will use to execute methods in our code when the keys are pressed. In this mode, each action in the mappings will have its own event, and you can see all of them in the tooltip at the bottom of the component. As you add mappings, more will appear.</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_62_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.61: All the input events for the default mapping</p>
    <div class="note">
      <p class="normal">For more information about the other PlayerInput behavior modes, check out its documentation here: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/PlayerInput.html#notification-behaviors"><span class="url">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/PlayerInput.html#notification-behaviors</span></a></p>
    </div>
    <p class="normal">From the <a id="_idIndexMarker342"/>list, we will need <code class="inlineCode">OnMove</code>, <code class="inlineCode">OnLook</code>, and <code class="inlineCode">OnFire</code>. We can modify our <code class="inlineCode">PlayerMovement</code> script to use them, like in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_63_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.62: PlayerMovement with the new Input System</p>
    <p class="normal">The first <a id="_idIndexMarker343"/>difference you will notice is that we don’t request the status of the input in the <code class="inlineCode">Update</code> method as we did before. Instead, we listen to the <code class="inlineCode">OnMove</code> and <code class="inlineCode">OnLook</code> events, which provide us with an <code class="inlineCode">InputValue</code> parameter containing the current state of those axes. The idea is that every time these axes change value, these events will execute, and if the values don’t change, like when the player keeps pushing the stick all the way to the right, they won’t be executed. That’s why we need to store the current value in the <code class="inlineCode">movementValue</code> and <code class="inlineCode">lookValue</code> variables—to use the latest value of the axis later in the <code class="inlineCode">Update</code> and apply the movement in every frame. Consider those as private, meaning they won’t appear in the editor, but that’s fine for our purposes. Also, observe that we added the <code class="inlineCode">using UnityEngine.InputSystem</code> line at the top of the file to enable the usage of the new Input System in our script.</p>
    <p class="normal">In this version of the <code class="inlineCode">PlayerMovement</code> script, we used the axis input type like we did with the mouse before but also for movement, unlike the previous version that used buttons. This is the preferred option most of the time, so we will stick with that version. Observe how we use a single <code class="inlineCode">transform.Translate</code> to move; we need to use the x axis of <code class="inlineCode">movementValue</code> to move the x axis of our player, but we use the y axis of <code class="inlineCode">movementValue</code> to move the z axis of our player. We don’t want to move our player vertically, so that’s why we needed to split the axis this way.</p>
    <p class="normal">The <code class="inlineCode">InputValue</code> parameter has the <code class="inlineCode">Get&lt;Vector2&gt;()</code> method, which will give us the current value of both axes, given that <code class="inlineCode">Vector2</code> is a variable that contains the x and y properties. Then, we multiply the vector by the movement or rotation speed according to the case. You will notice that we don’t multiply by <code class="inlineCode">Time.deltaTime</code> in the axis events, but we do that in the <code class="inlineCode">Update</code>. That’s because <code class="inlineCode">Time.deltaTime</code> can change between frames, so storing the movement value while considering the <code class="inlineCode">Time.deltaTime</code> of the last time we moved the stick won’t be useful for us. Also, notice how <code class="inlineCode">movementValue</code> is a <code class="inlineCode">Vector2</code>, just a combination of the x and y axes, while <code class="inlineCode">lookValue</code> is a simple float. We did it this way because we will rotate our character only by following the lateral movement of the mouse; we don’t want to rotate it up and down. Check that we extract <code class="inlineCode">value.Get&lt;Vector2&gt;().x</code>, with emphasis on the <code class="inlineCode">.x</code> part, where we extract just the horizontal part of the axis for our calculations.</p>
    <p class="normal">Regarding the <code class="inlineCode">PlayerShooting</code> component, we need to change it to this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_64_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.63: PlayerShooting script using the new Input System</p>
    <p class="normal">This<a id="_idIndexMarker344"/> case is simpler, as we don’t need to execute the shooting behavior for each frame; we only need to execute something at the very same moment the input is pressed, which is exactly when the <code class="inlineCode">OnFire</code> event will be executed. If you also need to detect when the key was released, you can add the <code class="inlineCode">InputValue</code> parameter, as we did with <code class="inlineCode">OnMove</code> and <code class="inlineCode">OnLook</code>, and consult the <code class="inlineCode">isPressed</code> property:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_65_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.64: Getting the state of the button</p>
    <p class="normal">Regarding the Visual Script Machine version of our scripts, first, you will need to refresh the <strong class="screenText">Visual Script Node Library </strong>by going to <strong class="screenText">Edit | Project Settings | Visual Scripting</strong> and clicking<a id="_idIndexMarker345"/> the <strong class="screenText">Regenerate Nodes</strong> button. If you don’t do this, you won’t see the new Input System nodes:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_66_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.65: Regenerating Visual Scripting nodes to support the new Input System</p>
    <p class="normal">Now, the <code class="inlineCode">PlayerShooting</code> visual script should look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_67_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.66: Instantiating bullets with the new Input System</p>
    <p class="normal">The new <strong class="screenText">On Input System Event Button</strong> node allows us to detect when an action button has been pressed and react accordingly. You can pick the specific action in the <strong class="screenText">Input Action</strong> parameter, and you can even make the node react to the pressure, release, or hold states <a id="_idIndexMarker346"/>of the button with the option right below the node’s title. There is a bug where the <strong class="screenText">Input Action</strong> property might not show any option; in such cases, try removing and adding the node again in the graph and check that you added the <code class="inlineCode">ScriptMachine</code> component to the same GameObject that has the <code class="inlineCode">PlayerInput</code> component. Also, ensure that you selected the Player GameObject in the Hierarchy.</p>
    <p class="normal">Regarding movement, it can be achieved this way:</p>
    <figure class="mediaobject"><img src="../Images/B21361_06_68_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.67: Moving with the new Input System</p>
    <p class="normal">In this case, we used the <strong class="screenText">On Input System Event Vector2</strong> node. This time, we used the <code class="inlineCode">OnHold</code> mode, which means that, unlike the C# version, it won’t execute just when the axis changes, but all the frames when the axis is pressed act like an <code class="inlineCode">Update</code>; that, however, will only execute when the user presses the stick. The output pin of the node is the <code class="inlineCode">Vector2</code> value, so we multiply it by the <code class="inlineCode">speed</code> variable (declared in the <code class="inlineCode">Variables</code> component of our player) and by <code class="inlineCode">DeltaTime</code>. Finally, we use the <code class="inlineCode">Vector2</code> <code class="inlineCode">GetX</code> and <code class="inlineCode">Vector2</code> <code class="inlineCode">GetY</code> nodes to translate over the x and z axes. You may have trouble when rewiring the <strong class="screenText">Multiply</strong> nodes with the new <strong class="screenText">Input System</strong> node, given that the return type is different compared to the previously used node (a <code class="inlineCode">Vector2</code> instead of a single float). I recommend just deleting all nodes in this graph and redoing them to make sure everything <a id="_idIndexMarker347"/>is fine. This way, we make our scripts react to the input messages from Unity’s new Input System.</p>
    <h1 id="_idParaDest-102" class="heading-1">Summary</h1>
    <p class="normal">We created our first real scripts in this chapter, which provide useful behavior. We discussed how to move a GameObject based on input and instantiate Prefabs via scripting, creating objects at will according to the game situation. Also, we saw how to schedule actions—in this case, spawning—but this can be used to schedule anything. We saw how to destroy created objects to avoid increasing the number of objects to an unmanageable level. Finally, we explored the new Input System to provide maximum flexibility to customize our game’s input. We will use these actions to create other kinds of objects, such as sounds and effects, later in this book.</p>
    <p class="normal">Now, you are able to create any type of movement or spawning logic that your objects will need, and you can make sure those objects are destroyed when needed. You might think that all games move and create shooting systems in the same way, and while they are similar, being able to create your own movement and shooting scripts allows you to customize those aspects of the game to behave as you intend, creating the exact experience you are looking for.</p>
    <p class="normal">In the next chapter, we will discuss how to detect collisions to prevent the player and bullets from passing through walls and much more.</p>
    <h1 id="_idParaDest-103" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev"><span class="url">https://packt.link/unitydev</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>