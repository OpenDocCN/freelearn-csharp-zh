- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going Deeper into WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go deeper into technologies that are only relevant
    for Blazor **WebAssembly**.
  prefs: []
  type: TYPE_NORMAL
- en: Most things in Blazor can be applied to Blazor Server and Blazor WebAssembly.
    Still, since Blazor WebAssembly runs inside the web browser, we can do some things
    to optimize the code and use other libraries that we can’t use server-side.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at some common problems and how to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the WebAssembly template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET WebAssembly build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOT compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebAssembly **Single Instruction, Multiple Data** (**SIMD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive web apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some parts of this chapter are a great opportunity to follow along, while other
    parts are for reference so that you can find the right information when you need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a reference chapter and is not connected with the book’s other
    chapters. You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the WebAssembly template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WebAssembly template looks slightly different from the templates we looked
    at in *Chapter 2*, Creating Your First Blazor App. In the Blazor Web App template,
    our entry point is the `app.razor` file. It contains the HTML tags we need to
    get started. The WebAssembly template had an `Index.html` file. Let’s create a
    project so we can take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project and use the `Blazor WebAssembly Standalone App` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `BlazorWebAssembly`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the defaults as is and press **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, in the `wwwroot` folder, we have a `Index.html` that has all the CSS,
    JavaScript, and so on. This is the same content as the `App.razor` file in the
    Blazor Web App template. We have an `app.razor` file in the WebAssembly project
    as well, but that contains the same things as the `Routes.razor` file. So it is
    a bit confusing if we work with both templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at each file but only focus on the things that are specific
    to WebAssembly. In `Index.html`, we have some interesting code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a `div`, and the content is a progress bar showing the WebAssembly
    loading progress. In the `css/app.css` file, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are just some of the CSS classes for the loading progress, but what is
    interesting is that Blazor will give us two CSS values, `--blazor-load-percentage-text`
    and `--blazor-load-percentage`. This gives us some indication of how much time
    is left when loading our WebAssembly app. This is a great way to customize our
    progress indicator. The content of the `div` will be replaced by the WebAssembly
    app once it has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at `Program.cs`, it contains a bit more now when we are running
    WebAssembly standalone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set up our WebAssembly project and tell .NET that we want to render
    the `app.razor` component in the `HTML` tag with the `id` app. We also tell .NET
    to render the `HeadOutlet` as the last child of the `head` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project and explore it for a bit. The components inside of the project
    are the same as the ones we have already looked at in *Chapter 4*, *Understanding
    Basic Blazor Components*, so there is nothing new going on there.
  prefs: []
  type: TYPE_NORMAL
- en: When we start the project the first time, it takes a couple of seconds to load
    our app. This is when everything is downloaded and started. The next time our
    users visit our site, much of the files will be cached and we won’t need to download
    them again.
  prefs: []
  type: TYPE_NORMAL
- en: .NET WebAssembly build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to the more “advanced” scenarios, we need additional tooling installed.
    There are two ways of installing the tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can select the **.NET WebAssembly Build Tools** option when installing Visual
    Studio (or add them using the Visual Studio installer) or run the following command
    in a command prompt (as administrator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The .NET WebAssembly build tools are based on **Emscripten**, a compiler toolchain
    for the web platform.
  prefs: []
  type: TYPE_NORMAL
- en: AOT compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the only thing that is running as WebAssembly in a Blazor WebAssembly
    app is the runtime. Everything else is ordinary .NET assemblies running on the
    browser using a .NET **Intermediate Language** (**IL**) interpreter implemented
    in WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: I was not too fond of that when I started playing around with Blazor; it felt
    wasteful to run everything using IL instead of something the browser would understand
    natively. Then, I thought the browser was running the same code as I would on
    the server. The same code in the browser! That is pretty amazing!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we have the option to compile directly to WebAssembly; this is called
    **ahead-of-time** (**AOT**) compilation. It has a downside: the app download size
    will increase, but it will run and load faster.'
  prefs: []
  type: TYPE_NORMAL
- en: An AOT-compiled app is generally twice the size of an IL-compiled app. AOT will
    take the .NET code and compile that directly into WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: AOT does not trim managed assemblies, and more code is needed to represent high-level
    .NET IL instructions when using native WebAssembly. That is why the size is much
    larger, and it is also less compressible over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: AOT is not for everyone; most apps running without AOT will work fine. However,
    for CPU-intensive apps, there is a lot to gain by using AOT.
  prefs: []
  type: TYPE_NORMAL
- en: My ZX Spectrum emulator is one of those apps; it runs many iterations per second,
    and the performance gain by running AOT for these apps is remarkable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile our Blazor WebAssembly project using AOT, we add the following property
    in the `csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: AOT compilation is only performed when the app is published. It can take a long
    time to compile (seven minutes for the ZX Spectrum emulator), so it is pretty
    nice that we don’t have to wait for that every time we compile our application.
  prefs: []
  type: TYPE_NORMAL
- en: However, running in release mode may be a problem, so if you want to do a quick
    test in release mode, temporarily disable the preceding setting.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to enable it again; I have some experience in that area.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly Single Instruction, Multiple Data (SIMD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the new features in .NET7 is SIMD, a type of parallel processing recently
    added to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: SIMD is a type of computer architecture that allows a CPU to perform the same
    operation on multiple data points simultaneously, improving the performance of
    certain kinds of tasks. SIMD instructions are often used to perform vector arithmetic,
    in which a single instruction is applied to multiple elements of a vector simultaneously.
    SIMD can be beneficial for tasks such as image and video processing, where large
    amounts of data need to be processed quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'SIMD is enabled by default. To disable SIMD, we need to disable it in the project
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to use AOT compilation for SIMD to work.
  prefs: []
  type: TYPE_NORMAL
- en: This is beyond the scope of this book, but I wanted to mention it in case this
    is what you need for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, when publishing a Blazor WebAssembly app, trimming will be performed.
    It will remove unnecessary things and, by doing so, reduce the size of the app.
  prefs: []
  type: TYPE_NORMAL
- en: If our application uses reflection, the trimmer may have problems identifying
    what can and cannot be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most applications, the trimming is automatic and will work. To read more
    about trimming options, you can look here: [https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0).'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Blazor WebAssembly, one of the challenges is download size.
    Even though it’s not a big problem, in my opinion, we can do some things to handle
    the download and loading time. We will get back to this in the *Common problems*
    section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When navigating to a Blazor WebAssembly application, all the DLLs for our application
    and the DLLs from .NET Framework are downloaded. It takes a bit of time to get
    everything started up. We can load some DLLs when needed by using **lazy loading**
    to solve this.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that our application is massive where it has a reporting part. Reporting
    is perhaps not used every day and not used by everyone, and it would make sense
    to remove that part from the initial download and only load it when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that happen, the part we want to lazy load must be in a separate project/DLL.
    In the `csproj` file of the Blazor WebAssembly client project, add a reference
    to the DLL by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `LazyAssemblyLoader` service will make a JS interop call to download the
    assembly and load it into the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make sure to download the necessary assemblies/DLLs in the router (`App.razor`)
    so we make sure they are downloaded before we navigate to the component that is
    using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We need to inject `LazyAssemblyLoader`; it is registered as a singleton by default
    in a Blazor WebAssembly project.
  prefs: []
  type: TYPE_NORMAL
- en: You need to set up an `OnNavigateAsync` event, and in that method, check the
    path and make sure to load the assemblies we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'This event can also be used for routable components by doing something similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This makes it possible not to load the admin interface for the users who don’t
    have access to it, for example. We can of course trigger the downloading of additional
    assemblies when it makes sense to do so (and not wait for a user to hit a specific
    part of the application and then download the assemblies).
  prefs: []
  type: TYPE_NORMAL
- en: Progressive web apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Blazor Server and Blazor WebAssembly can create **Progressive Web Apps**
    (**PWAs**), but it is much more common for Blazor WebAssembly. PWAs make it possible
    to download our web app and run it as an app on our phone or computer. They will
    make it possible to add nice-looking icons and launch our website in a web browser
    without a URL input field, so it will feel more like an app.
  prefs: []
  type: TYPE_NORMAL
- en: When creating our project, we select **Progressive Web App**. By doing that,
    we will get some configuration and JavaScript to set everything up.
  prefs: []
  type: TYPE_NORMAL
- en: 'PWAs are beyond the scope of this book, but there are great resources to get
    us started. You can find more information here: [https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&tabs=visual-studio).'
  prefs: []
  type: TYPE_NORMAL
- en: Native dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are running WebAssembly, we can use WebAssembly assemblies written
    in other languages in our project. This means that we can use any native dependencies
    right inside our project.
  prefs: []
  type: TYPE_NORMAL
- en: One way is to add C files right into our project. In the `Chapter16` folder
    in the repository, you will find an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have added a file called `Test.c` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the project file, I have added a reference to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Home.razor`, I have added the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In our C# project, we now have a C file that we can call from our Blazor project.
    It is compiled into WebAssembly, and then we can reference that WebAssembly file
    (which happens automatically). We can take this even further by using a library
    that is using a C++ library. Skia is an open-source graphics engine written in
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more here: [https://github.com/mono/SkiaSharp](https://github.com/mono/SkiaSharp).
    We can add that library to a Blazor WebAssembly app by adding the NuGet package
    `SkiaSharp.Views.Blazor`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chapter16` folder in the repository, you can explore a project called
    `SkiaSharpDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Home.razor` file, I have added the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The page will draw `"Raccoons are awesome"` on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using a C# library that is using a C++ library.
  prefs: []
  type: TYPE_NORMAL
- en: We can even refer to libraries that have already been built with Emscripten
    directly by adding **object files** (`.o`), **archive files** (`.a`), **bitcode**
    (`.bc`), and **standalone WebAssembly modules** (`.wasm`). If we find a library
    written in another language, we could compile that to WebAssembly and then use
    it from our Blazor application. This opens up so many doors!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at some common problems I have encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Common problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive into this one right from the start.
  prefs: []
  type: TYPE_NORMAL
- en: The most common comments regarding Blazor WebAssembly are download size and
    load time. A small project is around 1 MB in size, but I believe the problem is
    the loading time and not the download size/time since everything is cached and,
    in most parts of the world, we have access to high-speed internet.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of solutions to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Progress indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to **User Experience** (**UX**), we can give the users a perceived
    sense of speed.
  prefs: []
  type: TYPE_NORMAL
- en: The default Blazor WebAssembly template has a loading progress indicator, which
    gives the users something to look at instead of a blank page. It is built so that
    it is easy to customize using CSS variables. We can use the `--blazor-load-percentage`
    and `--blazor-load-percentage-text` variables to customize and create our progress
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t even have to indicate what is happening; Dragons Mania Legends has
    comments like “Sewing mini Vikings,” which is obviously not what is going on.
    So depending on the application we are building, showing something is more important
    than showing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Prerendering on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous versions of Blazor, we had to do some magic ourselves to make prerendering
    work. But with the new Blazor Web App template, we get this out of the box. Up
    until now, we have talked about features in Blazor WebAssembly using the Blazor
    WebAssembly Standalone template; in this section, we are using the Blazor Web
    App template. The better solution is to run it as `InteractiveAuto`; that way,
    we get the power of fast loading on the server, and then get WebAssembly without
    the wait.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great and simple way to add SEO to our site.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one problem: it will load data when rendering on the server, and then
    again when the WebAssembly loads.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to work around that, which we will take a look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Preloading and persisting the state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don’t want our component to call the database twice if we can avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the `BlazorPrerender` example and go to the **Weather** page, you
    should be able to see it load twice since the data is random and generated every
    time we request it.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same behavior you see when using `InteractiveServer, InteractiveWebAssembly,
    and InteractiveAuto`. The page first gets rendered on the server. Then, SignalR
    or WebAssembly gets hooked up and loads the page again.
  prefs: []
  type: TYPE_NORMAL
- en: The source for this example is the `BlazorPrerender` project.
  prefs: []
  type: TYPE_NORMAL
- en: We used this technique when we passed information about the logged-in user to
    WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: In previous versions of Blazor, we had to add a component called `persist-component-state`,
    but this component is added by default in .NET 8\. This component will render
    the saved state of the component when it renders on the server, and, when SignalR
    or WebAssembly takes over, the state is already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Client project and in the component where we want to have the persistence
    (`Weather.razor` in the sample), we inject a `PersistanceComponentState` and also
    make the component implement `Idisposable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a `PersistingComponentStateSubscription` component, which saves the
    data to the application state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In `OnInitializedAsync`, we register to listen to run code when the component
    wants to persist the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we load the data, we make sure first to check the application state. If
    the data is not available, we can continue and make an `HTTP` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It refers to a method that will persist the data in the application state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will first render the content, and when the server is done, it will
    respond with the whole page, including a `Base64`-encoded JSON string with data
    that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since everything we put into the application state is stored as JSON, it is
    important not to include any sensitive data that we were not thinking of displaying.
    This is, of course, true for all calls since we are sending data with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use `PersistentComponentState` on `InteractiveServer, InteractiveWebAssembly,
    and` `InteractiveAuto`. I usually turn off prerendering on my websites, but this
    is great to use if your site needs SEO, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know a couple of common problems and how to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the Blazor WebAssembly-specific things
    in Blazor. For the most part, we can reuse components in both Blazor Server and
    Blazor WebAssembly, and we can speed up WebAssembly by using what we learned in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at native dependencies, opening up the possibilities to reuse
    other libraries and mixing languages. If our application doesn’t need to support
    both scenarios, we can use WebAssembly to the fullest.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine *source generators*.
  prefs: []
  type: TYPE_NORMAL
