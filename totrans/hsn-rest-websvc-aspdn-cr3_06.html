<html><head></head><body>
        

                            
                    <h1 class="header-title">Dependency Injection System</h1>
                
            
            
                
<p class="mce-root">Dependency injection is the basic building block of ASP.NET Core. This chapter shows how you can use dependency injection in order to resolve the dependencies of the classes inside an ASP.NET Core application. It also describes how you can deal with the dependency injection life cycle, and it provides some examples of how to keep the classes loosely coupled. The first part of this chapter will give you some basic theoretical ideas about dependency injection, while the second part will show you how to use it in any ASP.NET Core project.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>What is dependency injection?</li>
<li>Why implement the dependency injection pattern in real-world applications?</li>
<li>Overview of the dependency injection life cycle</li>
<li>How to implement dependency injections in ASP.NET Core</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency inversion principle</h1>
                
            
            
                
<p class="mce-root">The <em>dependency inversion principle</em> is part of the SOLID principles that were established by Robert C. Martin. The purpose of the SOLID principles is to provide some guidelines to developers on how to design code in a way that is more understandable, flexible, and maintainable. The dependency inversion principle, in particular, affirms that a high-level component should not depend directly on an individual component that is concentrated on a precise procedure (low-level component); instead, they should depend on an abstraction. Therefore, abstractions should not depend on any implementation details.</p>
<p>A low-level component usually performs simple operations and provides simple functionalities. A high-level component, on the other hand, manages a set of individual components by orchestrating them. Real-world systems typically have more than two levels of abstractions. The concept of a high-level component is relative to the subject module; therefore, a high-level component for one component might be a low-level component for another. The concept of <em>abstraction</em> is particularly prevalent when we talk about SOLID principles. An abstract component is usually an interface or an abstract class. Therefore, it is an element that does not have any concrete implementation. In summary, the <em>dependency inversion principle</em> states that every element inside our application should only refer to <em>abstractions.</em> Let's look at a concrete example of the <em>dependency inversion principle</em> that has been applied to a system. The schema describes an add-to shopping bag e-commerce process.</p>
<p>It is composed of three different classes:</p>
<ul>
<li>The <kbd>AddToShoppingBagHandler</kbd> handles the requests from the client and sends information to <kbd>PaymentService</kbd>.</li>
<li>The  <kbd>PaymentService</kbd> manages information about payment methods.</li>
<li>The <kbd>CurrencyConverter</kbd> component provides conversions between different currencies.</li>
</ul>
<p>The following diagram describes the standard sequence of processing the preceding mentioned classes:</p>
<div><img src="img/e7b87f01-066f-4e46-aa2c-e27cc7e89647.png" style=""/></div>
<p>If we apply the dependency inversion principle, the direction of our dependencies will change. To be compliant with the dependency inversion principle, we should introduce some abstractions between our components, as follows:</p>
<div><img src="img/7f52ceb7-1d44-485c-87e9-127e2f8f7682.png" style=""/></div>
<p>By comparing the two schemas, we deduce that the direction of the dependencies are inverted. The <kbd>AddToShoppingBagHandler</kbd> class now uses the <kbd>IPaymentService</kbd> interface, and the <kbd>PaymentService</kbd> type is the concrete implementation of the <kbd>IPaymentService</kbd> interface<em>.</em> </p>
<p>However, this schema is not yet complete. Moreover, it is not yet compliant with the second statement of the dependency inversion principle. We should make sure that our abstractions don't depend on the implementations.</p>
<p>Consequently, if we think in terms of architectural boundaries, our schema changes as follows:</p>
<div><img src="img/2fc9cc77-5198-4a08-a0db-1ed23a81f705.png" style=""/></div>
<p>Each rounded rectangle represents a boundary. The classes and the abstractions within the same rectangle are part of the same boundary. In the .NET ecosystem, each border is a project, and our interfaces are the bridge between high-level and low-level classes.</p>
<p>A common inaccuracy is to place the interfaces and the implementation classes within the same boundary. In .NET, this would mean putting the <kbd>IPaymentService</kbd> interface and <kbd>PaymentService</kbd> in the same project<em>.</em> This approach is not necessarily wrong, but it does not respect the <em>dependency inversion principle</em>.</p>
<p>In conclusion, the dependency inversion principle is used to build very flexible systems, and it helps us to design a more readable, flexible, and maintainable code. </p>
<p>The dependency inversion principle is often confused with the idea of dependency injection because the two concepts are strongly related. If dependency inversion defines a principle to improve our systems, dependency injection is a concrete implementation of that principle.</p>
<p>The dependency inversion principle becomes very useful when we want to test our code, especially for the unit testing technique. Unit tests usually cover a particular function in our application, so it is necessary to isolate our classes and methods. Dependency inversion comes in handy because we can mock our abstraction and isolate our subject under testing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of dependency injection</h1>
                
            
            
                
<p>Dependency injection is described as follows:</p>
<p>"A set of software design patterns that enable us to develop a loosely coupled code."</p>
<p>The objective of dependency injection is to implement a loosely coupled code and, as a consequence, write maintainable code. In the book, <em>Dependency Injection in .NET</em>, Mark Seemann describes a bright, real-life example of a loosely coupled code. He compares tightly coupled code with cheap hotel hairdryers: some hostels, hotels, and locker rooms bind their hairdryers directly on the wall without a plug to stop guests from stealing them. If the hairdryer stops working, the owner has to cut the power and call a technician, who has to disconnect the hairdryer and replace it with a new one. This approach is a very tedious procedure. </p>
<p>On the other hand, if the hairdryer is plugged into the wall, the owner has to replace it with a new one. This is a metaphor for <em>dependency injection.</em></p>
<p>The first case is a <em>tightly coupled code</em>: our high-level component (the wall) uses a low-level part (the hairdryer) directly. In the second case, we have a third actor, which is the plug: the high-level element (the wall) directly uses the plug (the abstraction). The hairdryer, which is our low-level component, also uses the plug.</p>
<p>The second case is <em>more flexible and maintainable</em> because we can plug anything into the plug, and if the hairdryer breaks, we can replace it easily.</p>
<p>This is what <em>dependency injection</em> is all about. It comes with a lot of benefits for our code:</p>
<ul>
<li><strong>Late binding</strong>: Third-party services can be plugged in and swapped with other services. This may be useful when you change one third-party dependency for another.</li>
<li><strong>Parallel development</strong>: Different teams can develop code at the same time by defining interaction contracts (interfaces) between components.</li>
<li><strong>Maintainability</strong>: The code is easy to maintain and manage.</li>
<li><strong>Testability</strong>: As mentioned earlier, dependency injection helps us to deal with the isolation of the dependencies of unit tests.</li>
</ul>
<p>The more our codebase grows, the more these benefits are useful. For small codebases, dependency injection can be seen as a useless overhead, but it becomes crucial when we deal with distributed and large codebases. In the next section, we will see how to apply the concept of dependency injection to the </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency injection in ASP.NET Core</h1>
                
            
            
                
<p>The dependency injection concept is a fundamental part of ASP.NET Core. A dependency injection system comes out of box with the ASP.NET Core framework, and it is the preferred way to instantiate components in our application.</p>
<p>ASP.NET Core usually describes types that are managed by the dependency injection container as <em>services.</em> Therefore<em>,</em> all the services<em> </em>are stored in the built-in container that is represented by the <kbd>IServiceProvider</kbd> interface. </p>
<p>In the next part of the chapter, we will see some examples of dependency injection. As a first step, let's create a new class in the <kbd>SampleAPI</kbd> project inside the <kbd>Controllers</kbd> folder, called <kbd>ValuesController.cs</kbd>:</p>
<pre>using System.Collections.Generic;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace SampleAPI.Controllers<br/>{<br/>    [ApiController]<br/>    [Route("[controller]")]<br/>    public class ValuesController : ControllerBase<br/>    {<br/>        public string Get()<br/>        {<br/>            return string.Empty;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding snippet of code declares a <kbd>ValuesController</kbd> class, with a simple <kbd>Get</kbd> method. It is possible to call the route by executing the following CLI command:</p>
<pre><strong>dotnet run</strong></pre>
<p>This is also possible by calling the following endpoint: <kbd>https://localhost:5001/values</kbd>. As a second step, we need to create a new <kbd>PaymentService.cs</kbd> file with the following code:</p>
<pre>namespace SampleAPI<br/>{<br/>    public interface IPaymentService<br/>    {<br/>        string GetMessage();<br/>    }<br/><br/>    public class PaymentService : IPaymentService<br/>    {<br/>        public string GetMessage() =&gt; "Pay me!";<br/>    }<br/><br/>    public class ExternalPaymentService : IPaymentService<br/>    {<br/>        public string GetMessage() =&gt; "Pay me!, I'm an external service!";<br/>    }<br/>}</pre>
<p>The <kbd>PaymentService.cs</kbd> file defines the <kbd>IPaymentService</kbd> interface, which describes a <kbd>GetMessage</kbd> signature. In addition, the <kbd>IPaymentService</kbd> interface is implemented by the <kbd>PaymentService</kbd> class that returns a string. In the same way, we are defining an <kbd>ExternalPaymentService</kbd> class, which implements the <kbd>IPaymentService</kbd> interface with different behavior. The next section describes how to register the <kbd>IPaymentService</kbd> interface in order to use the <kbd>PaymentService</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering services using the dependency injection container</h1>
                
            
            
                
<p>We can register the <kbd>IPaymentService</kbd> interface in <kbd>ConfigureServices</kbd> in the <kbd>Startup</kbd> class by adding the following code:</p>
<pre>      public class Startup<br/>     {<br/>           // ...<br/><br/>         public void<strong> ConfigureServices</strong>(IServiceCollection services)<br/>         {<br/> <strong>            </strong>services<br/>                    <strong>.AddTransient&lt;IPaymentService, PaymentService&gt;()<br/>                    </strong>.AddControllers();       <br/>         }<br/> <br/>           // ...<br/>  <br/>     }</pre>
<p class="mce-root">The preceding code shows a simple instantiation of a service using the ASP.NET Core container. I've omitted some parts of the <kbd>Startup</kbd> class in order to make the code more readable. The runtime executes the  <kbd>services.AddTransient&lt;IPaymentService, PaymentService&gt;()</kbd> method in order to map the <kbd>IPaymentService</kbd> interface with the concrete implementation that was described in the <kbd>PaymentService</kbd> class. The <kbd>AddTransient</kbd> method also defines the scope of our service. We will go into detail about scopes later in this chapter.</p>
<p>We should also note that the dependency injection container requires the concrete class (<kbd>PaymentService</kbd>) in order to implement the abstraction (<kbd>IPaymentService</kbd>) and add the instance to the container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering services conditionally</h1>
                
            
            
                
<p>In a real-world application, it is common practice to conditionally register some services depending on their environment variables. This practice is useful when we want to initialize third-party dependencies differently, such as a data source. The following code shows how to register services conditionally, based on the environment:</p>
<pre>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using Microsoft.Extensions.Hosting;<br/><br/>namespace SampleAPI<br/>{<br/>    public class Startup<br/>    {<br/><br/>        public Startup(IConfiguration configuration, <br/><strong>        IWebHostEnvironment env</strong>)<br/>        {<br/>            Configuration = configuration;<br/>            <strong>Environment = env;</strong><br/>        }<br/><br/>        public IConfiguration Configuration { get; }<br/><br/>        public IWebHostEnvironment Environment { get; }<br/><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            if (<strong>Environment.IsDevelopment()</strong>)<br/>            {<br/>                services.AddTransient&lt;IPaymentService, <strong>PaymentService</strong>&gt;();<br/>            }<br/>            else<br/>            {<br/>                services.AddTransient&lt;IPaymentService, <br/><strong>                ExternalPaymentService</strong>&gt;();<br/>            }<br/>        }<br/><br/>        // ...<br/>    }<br/>}</pre>
<p>The example uses the <kbd>IWebHostEnvironment</kbd> interface to detect the <kbd>IsDevelopment()</kbd> environment. In this case, it initializes <kbd>PaymentService</kbd>. Otherwise, it initializes the <kbd>ExternalPaymentService</kbd> implementation. This practice is widespread in testing environments, especially when initializing testing services or a data source. It is common in broad business applications to register services conditionally for testing and development purposes. In <a href="266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml">Chapter 10</a>, <em>Implementing the RESTful HTTP Layer</em>, we will see some concrete examples that have been applied to integration testing. It is essential to keep testing environments isolated in order to avoid false-positive results. Furthermore, registering services conditionally also helps us to improve the flexibility of our code. In the next subsections, we will see how to use constructor injection and action injection in order to resolve the dependencies of the controller classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constructor injection</h1>
                
            
            
                
<p>We have just seen how we can initialize services in our <kbd>Startup</kbd> class, but how can we consume these services? By default, the built-in dependency injection container of ASP.NET Core uses the constructor injection<em> </em>pattern to retrieve services<em>.</em> We can modify <kbd>ValueController</kbd> to use <kbd>IPaymentServices</kbd> by adding the interface as a parameter of the controller constructor:</p>
<pre>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace SampleAPI.Controllers<br/>{<br/>    [ApiController]<br/>    [Route("[controller]")]<br/>    public class ValuesController : ControllerBase<br/>    {<br/>       <strong> private IPaymentService paymentService { get; set; }</strong><br/><br/>        public ValuesController(<strong>IPaymentService paymentService</strong>)<br/>        {<br/>            <strong>this.paymentService = paymentService;</strong><br/>        }<br/>        <br/>        public string Get()<br/>        {<br/>            return <strong>paymentService.GetMessage();</strong><br/>        }<br/>    }<br/>}</pre>
<p>As you can see, we can inject the <kbd>IPaymentService</kbd> interface into the constructor of our class. It should be noted that to be compliant with constructor injection<em>,</em> the constructor has to abide by the following rules:</p>
<ul>
<li><strong>The constructor should be public</strong>: If our constructor is not public, the reflection process cannot access the constructor.</li>
<li><strong>There should be only one applicable constructor</strong>: For example, if we declare multiple constructors in our <kbd>ValuesController</kbd> class, such as <kbd>public ValuesController(IPaymentService paymentService)</kbd> or <kbd>public ValuesController(IPaymentService paymentService, string[] paymentTypes = new string[] { 1, 2, 3 })</kbd>, the runtime would throw <kbd>InvalidOperationException</kbd>. There should be only one constructor that is suitable for dependency injection.</li>
</ul>
<ul>
<li>You can only pass arguments that <em>are not provided</em> by dependency injection if they have a <em>default value</em><strong>.</strong> For example, the following constructor is suitable for constructor injection: <kbd>public ValuesController(IPaymentService paymentService, string[] paymentTypes = new string[] { 1, 2, 3 })</kbd>.</li>
</ul>
<p>The resolution of the dependencies happens during the runtime execution; therefore, we need to adhere to these rules in order to avoid pitfalls when we alter the dependencies of a controller class. </p>
<p>In conclusion, dependency injection provides a smart way to resolve the dependencies of classes. You should also try to be compliant with the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>). The SRP states that a class should have responsibility for a single part of the functionality. Classes with a lot of injected dependencies are probably not compliant with the SRP. Avoiding these kinds of bad design practices improves the maintainability of our code, and avoids our classes being tightly coupled with static functionalities, which prevent them from being testable. Let's proceed with the next section that covers the action method injection technique.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Action method injection</h1>
                
            
            
                
<p>A valid alternative to constructor injection is the action method injection. Sometimes, controllers use some dependencies in only one action method. In those cases, it may be useful to inject our dependency just in this action method, in order to improve the performance of our code. To perform an<em> </em>action method injection, we should use the <kbd>[FromServices]</kbd> attribute. For example, look at the following snippet of code:</p>
<pre>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace SampleAPI.Controllers<br/>{<br/>    [ApiController]<br/>    [Route("[controller]")]<br/>    public class ValuesController : ControllerBase<br/>    {<br/>        [HttpGet]<br/>        public ActionResult&lt;string&gt; Get(<br/>            <strong>[FromServices]IPaymentService paymentService</strong>)<br/>        {<br/>            <strong>return paymentService.GetMessage();</strong><br/>        }<br/>    }<br/>}</pre>
<p>The example, as aforementioned, uses the action method injection. We are injecting our service into the <kbd>Get</kbd> action method which is the only consumer of the dependency. Although constructor injection is widely adopted, the action method injection technique becomes useful when you don't use the dependency on the whole controller. This only guarantees a lazy resolution of the dependencies when the action method is invoked. We should also note that this approach is strictly dependent on the MVC stack, because the resolution of the service is performed in the model-binding phase of the execution; therefore, it is only supported in the action method and in the filter classes. The next section will be focused on the services life cycle types that are provided by ASP.NET Core. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Services life cycle</h1>
                
            
            
                
<p>A key point to master when we deal with dependency injection is the services life cycle. The services life cycle is an essential concept about performance, because a wrong service life cycle may cause complicated performance degradation. </p>
<p>The object lifetime in .NET is simple: the object is <em>instantiated</em>, <em>used</em>, and finally <em>disposed of</em> by the garbage collector. The <em>dispose</em> phase is the most relevant in terms of performance. In a dependency injection process, the consumer of a specific dependency does not control its lifetime. Indeed, dependencies are usually initialized by the dependency injection container, and they continue to exist until all their consumers hold them.</p>
<p>A typical performance issue that engineers face in large applications is the <em>memory leak</em>. The garbage collector fails to clean objects because they are still referred to as consumers. Consequently, the memory of the server increases until it reaches saturation. It is not easy to find and solve these kinds of performance issues. In a .NET ecosystem, tools such as dotMemory can help you to analyze the instances of the objects that are created by your application, and eventually detect performance issues of this type.</p>
<p class="p1">Speaking of dependency injection, the default life cycle types in ASP.NET Core are <em>transient</em>, <em>scoped</em>, and <em>singleton</em>. Let's discuss them more in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transient life cycle</h1>
                
            
            
                
<p>The services define the transient life cycle using the <kbd>.AddTransient()</kbd> method. Every time the consumer requires the initialization of a transient service, the dependency injection container returns a new instance. The transient life cycle is the safest life cycle, because it returns a new instance each time, and instances are not shared between consumers. It is also, however, the least efficient, because it can create a huge number of instances, especially in the web environment. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scoped life cycle</h1>
                
            
            
                
<p>The services define the scoped life cycle <kbd>.AddScoped()</kbd> method. Scoped instances are created once per request. The scoped life cycle is preferable compared to the transient life cycle regarding performance, but it is less efficient than the singleton life cycle. A scoped approach is usually applied to repository classes and services, and each request to the server will cause the creation of a new instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Singleton life cycle</h1>
                
            
            
                
<p>In the singleton life cycle, each time a consumer asks for a new instance, the same instance is provided. This is the most efficient life cycle because there is only a single instance, so the amount of consumed memory is minimal. However, it is recommended that you only use the singleton life cycle for thread-safe components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Life cycle madness</h1>
                
            
            
                
<p>The term <em>life cycle madness</em> is a quote from Jeffrey Richter's <em>CLR via C#</em>, and its chapter about threading. Understanding the life cycle of dependencies is important in order to avoid performance issues in our application. Above all, we should avoid the following cases:</p>
<ul>
<li><strong>Consuming scoped dependencies in a singleton consumer</strong>:<strong> </strong>As previously mentioned, a scoped life cycle means that a new instance is created for each request. When we try to consume a scoped instance in a singleton life cycle, the runtime will throw an exception as follows: <kbd>InvalidOperationException: Cannot consume scoped service 'Services.MyScopedService' from singleton 'Services.MySingletonService'</kbd>. This is because the runtime cannot create a scoped service for each request when it is referred to by a singleton instance.</li>
</ul>
<ul>
<li><strong>Consuming transient dependencies in a singleton consumer</strong>:<strong> </strong>Similarly, if we use a transient dependency inside a singleton instance, the runtime will not create a new instance of the transient service each time. Furthermore, the transient service will be initialized only once because it is declared in a singleton. Also, the runtime <em>will not throw an exception</em>, because a new instance of the transient service is not requested, as the singleton always uses the same one.</li>
</ul>
<p>In order to prevent possible bugs and runtime errors, it is important to avoid the situation in which a singleton refers to a scoped or transient service. In the first case, the runtime will throw an exception, while in the second case, the singleton consumer will always use the same instance. These behaviors must be avoided in order to prevent any memory issues and performance degradation inside our APIs. The following subsection explains how to use dependency injection in the middleware classes. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Injecting services into middleware</h1>
                
            
            
                
<p>As discussed earlier, middleware can instantiate dependencies through a dependency injection container. We should take the life cycle of the middleware into consideration: they are initialized once per application lifetime. As a consequence, if we try to consume a <em>scoped</em> or <em>transient</em> <em>instance</em> into our middleware we shouldn't inject them through the constructor of the middleware, because this will cause some dependency resolution issues. A good way to avoid this is to use the parameter injection in the <kbd>Invoke</kbd> or <kbd>InvokeAsync</kbd> methods:</p>
<pre>  namespace Middleware<br/> {<br/>     public class MyMiddleware<br/>     {<br/>         readonly RequestDelegate _next;<br/> <br/>         public MyMiddleware(RequestDelegate next)<br/>         {<br/>             _next = next;<br/>         }<br/> <br/>         public async Task InvokeAsync(HttpContext context, <br/><strong>                                       IPaymentService paymentService</strong>)<br/>         {<br/>             Console.WriteLine(paymentService.GetMessage());<br/>          <br/>             await _next(context);<br/>         }<br/>     }<br/> } </pre>
<p>The other middleware implementation injects <kbd>IPaymentService</kbd> in the <kbd>InvokeAsync</kbd> method. Unlike the middleware constructor, the <kbd>InvokeAsync</kbd> method is called for each request. Consequently, it is suitable for both a <em>scoped life cycle</em> and a <em>transient life cycle</em>.</p>
<p>When you want to inject a transient<em> </em>service or a scoped service into middleware, you should inject them in the <kbd>Invoke</kbd> or <kbd>InvokeAsync</kbd> methods in order to avoid life cycle problems. Furthermore, middleware is a cross-cutting component, which means that the application runs them at every request. Therefore, you must pay extra attention when you implement middleware, in order to avoid spreading performance issues across all of the applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has shown us how to deal with the ASP.NET Core default dependency injection engine. The chapter provides various examples that are related to dependency injection, how to use dependency injection in controllers and middleware, and describes the life cycle concepts of the registered services. The next chapter will discuss the controllers and the action methods in detail. It will show you how to use these in order to serialize data and expose it as a web service.</p>


            

            
        
    </body></html>