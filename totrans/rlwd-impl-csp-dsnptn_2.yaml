- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepping for Practical Real-World Applications of Patterns in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Becoming a prepper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may think that because I was born in Oklahoma and live in Texas, I could
    be one of those crazy people who runs around in the woods preparing for the imminent
    end of the world. Hey, letâ€™s try to keep my personal life out of this! However,
    when I tell you that I want you to become a prepper, it has nothing to do with
    a conspiracy theory or end-of-times rhetoric. Instead, it has to do with a fundamental
    transformation that is likely to be happening in your professional life. Unlike
    the radical political transformations that concern most real-world preppers, ours
    are hopefully fully beneficial, with the aim to make us better at our craft. This
    chapter is geared toward preparing you to use patterns. Relying on patterns to
    improve your code doesnâ€™t make sense if the code youâ€™re working with doesnâ€™t conform
    to the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Sports a high level of organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured for modification with minimal risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you need to prepare. Think of it as though you were sanding down rough spots
    on a piece of wood before painting it. The patterns are the paint; if you apply
    the paint before sanding, all the rough spots are going to stand out.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this chapter an explanation of why the code at your company is the
    way it is. If you work at Microsoft, Google, Apple, Meta, Twitter, or Amazon,
    your code is likely in good shape. You need to understand that a high-quality
    code base doesnâ€™t happen by accident, nor is it immune to the same chaotic forces
    that plague the physical universe. Entropy isnâ€™t limited to the concerns of thermodynamics
    in some distant stellar nebulae. Itâ€™s happening all the time in your code and
    you must learn to recognize it and work diligently to fix it or fend it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you work at one of the other 99.99% of the companies in the world that creates
    software as a normal part of doing business, there might be some unrecognized
    opportunities for improvement. Letâ€™s look at what weâ€™re covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Spaghetti < lasagna < ravioli â€“ software evolution explained with pasta
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foundational principle â€“ writing clean code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating maintainable systems using SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you reach the end of the chapter, youâ€™ll be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify some common metaphors for poorly constructed code, as well as exemplary
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articulate the importance of good basic coding habits as the key to the success
    of your project and applying code. Patterns make your code better, but only if
    itâ€™s clean code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply SOLID principles to your code and your design process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the most common software metrics so we can understand when our code
    is more likely good than bad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presents some code samples. They are geared toward demonstrating
    some of the concepts weâ€™re going to be covering. Iâ€™m not sure they are exciting
    enough to make you want to recreate the projects yourself, but you are welcome
    to do so. Should you decide to try any of this out, youâ€™ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer running the Windows operating system. Iâ€™m using Windows 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A supported IDE such as Visual Studio 2022, JetBrains Rider, or Visual Studio
    Code with C# extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 6 SDK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spaghetti < lasagna < ravioli â€“ software evolution explained with pasta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first part of any prepping journey involves securing your food supply. Real-world
    preppers love pasta because itâ€™s portable and keeps without refrigeration. So,
    letâ€™s start with pasta.
  prefs: []
  type: TYPE_NORMAL
- en: The title of [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016) was *Why Is There
    a Big Ball of Mud on Your Plate of Spaghetti?* I never mentioned spaghetti. I
    didnâ€™t need to. Itâ€™s such an obvious descriptive metaphor for a chaotic mess that
    it likely needs little further discussion. Spaghetti code is actually mentioned
    in the original publication of the *Big Ball of Mud* antipattern. What a lot of
    developers donâ€™t see is that spaghetti code is a symptom. It isnâ€™t the disease
    itself. The real diseases are the antipatterns. It is possible to have multiple
    infections ransacking your body at the same time. It is equally as possible for
    your code to be similarly and simultaneously inflicted with multiple antipatterns.
    You can gauge your codeâ€™s health by deciding where your code lies on the pasta
    spectrum..
  prefs: []
  type: TYPE_NORMAL
- en: Spaghetti code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spaghetti code is characterized as chaotic, poorly organized, hard to follow,
    and impossible to maintain. The more spaghetti you have, the worse it is. As soon
    as spaghetti appears, it tends to spread rapidly. Weâ€™ve also compared code architecture
    to a physical buildingâ€™s architecture in the previous chapter. There is a well-known
    principle from the field of criminology called *the broken windows theory*. The
    theory postulates that outward signs of crime, anti-social behavior, civil disobedience,
    or visible urban decay encourage further crime, particularly vandalism. A building
    with one broken window will soon have all its windows broken because itâ€™s clear
    that you can get away with throwing rocks with no repercussions. Who doesnâ€™t enjoy
    breaking Windows? Microsoft does it all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Your code is the same way. If you allow just one broken window, your code is
    no longer clean. You need to correct the situation immediately or it wonâ€™t be
    long before all you have in your code repository is a Big Ball of Mud on your
    plate of spaghetti.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe running fast and loose has paid off so far. Maybe it allowed you to get
    your software to market ahead of any competitors. Maybe your bosses and stakeholders
    are impressed with the velocity and small turnaround time on your initial releases.
    All that feels pretty good. Whatâ€™s really happening is that youâ€™re being rewarded
    for throwing rocks at your own windows. Youâ€™re sacrificing long-term profit for
    short-term gain.
  prefs: []
  type: TYPE_NORMAL
- en: You need to get out of the spaghetti production business entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Lasagna code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logical step up from spaghetti code is lasagna. Most characterizations of
    lasagna code say that it is the object-oriented version of spaghetti. I donâ€™t
    necessarily agree. Lasagna itself consists of many of the same ingredients found
    in spaghetti. Itâ€™s still noodles, tomato sauce, spices, and often meat or vegetables.
    The difference is in how itâ€™s organized. Instead of hundreds of intertwined chaotic
    structures of noodles that can only be tamed by twirling them on a spoon, lasagna
    uses big noodles that serve as boundaries between discrete layers. Many of the
    layers are composed of the same stuff as the other layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In software, layered code fixes the spaghetti code into many small classes.
    Using lasagna as a metaphor for software cropped up around 1982, as the industry
    was beginning to move to a new hardware architecture. We were moving away from
    big-iron monolithic mainframes to something called **client-server**. The mainframes
    of the day required a financial commitment similar to that of the GDP of several
    small European countries combined. Client-server systems, on the other hand, were
    affordable for a reasonably well-funded small business. The systems consisted
    of a powerful server, servicing multiple clients, taking the form of less powerful
    computers. Does this sound familiar? Itâ€™s the same model used by the internet.
    The difference is that networking technology is now universal, exponentially better,
    faster, and more reliable. Spoiler alert: **cloud computing** is not a new concept.
    Itâ€™s just a marketing term for work done on other peopleâ€™s computers.'
  prefs: []
  type: TYPE_NORMAL
- en: Itâ€™s worth noting that the 1980s also brought us the first forays into object-oriented
    programming. I doubt Java was even a glimmer in James Goslingâ€™s eye then, and
    the inventor of C#, Anders Hejlsberg, was still in college. However, Bjarne Stroustrup
    began working on **C++** in 1979 while working at AT&T Bell Labs. He based C++
    on the C language. C is a strictly procedural language designed to control telecommunications
    switching networks. Stroustrup reimagined this language by bolting on object orientation
    by way of classes.
  prefs: []
  type: TYPE_NORMAL
- en: C++ was released to the world in 1985 when Stroustrup published a textbook on
    the language. Those of you who were not yet born now understand that the 80s brought
    us more than just hairbands, Madonna wannabes, *The Karate Kid*, and Valley girls.
    It brought a whole new way of thinking about and designing software. It was a
    mere coincidence that we looked fabulous while doing it.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware shift toward client-server necessitated a change in software design
    practices, as we considered what pieces should run on servers and which on clients.
    We started seeing something that we call **separation of concerns** today. When
    done well, separation of concerns is a really good idea. When done poorly, it
    creates lasagna.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lasagna doesnâ€™t usually begin as lasagna. A software developer thoughtfully
    lays out a layered architecture that separates components of the overall system
    into layers called *tiers*. Hereâ€™s an example of a common four-tier architecture
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 â€“ A common four-tiered architecture ](img/B18605_Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 â€“ A common four-tiered architecture
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the kind of architecture we see in modern mobile applications.
    The presentation layer is the app you downloaded from the app store, which runs
    on your phone, while the remaining tiers run invisibly in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Since the separation exists at the hardware level, it makes sense to think about
    making software in a set of layers that mirrors the systems running the program.
    The presentation layer is the **view**, or the part of the program interacting
    with the users. The business rules layer implements the logic that drives what
    the presentation layer displays. It draws information from the persistence layer,
    which is responsible for storing and retrieving data. Some of this might be stored
    as files, or in memory, but some data will undoubtedly be at the lowest level
    in a database. All communication between the layers should move through each layer
    above it or below it, depending on the direction of flow for the data. As these
    layers become more and more complicated, it is easy for functionality to start
    bleeding out of the intended layer into other layers.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you need a quick fix for the way something is displayed in the UI. Maybe
    you want to show something in one way to an administrative user, and another way
    to a regular user. The right way to effect this change might be to alter a rule
    in the business rule layer, but itâ€™s easier and faster to slap something directly
    into the UI. Youâ€™ve just broken a window. Itâ€™s no big deal; you tell yourself
    youâ€™ll fix it later.
  prefs: []
  type: TYPE_NORMAL
- en: In other scenarios, lasagna can be the result of an overcorrection. Take a programmer
    who writes spaghetti code in a procedural language such as C, then give them an
    object-oriented language such as C++ or C#. Now, add a book on patterns. The natural
    inclination of the programmer will likely be the same as yours the first time
    you realized that you could use different fonts in *PowerPoint*. One font is good;
    therefore,, all 25 on your computer must be better! Naturally, you start creating
    presentations that try to use as many fonts as possible. Patterns are an amazing
    tool. They are meant to guide you toward clean architecture the way fonts, used
    sparingly, should add emphasis, clarity, and aesthetics to a presentation. Patterns
    arenâ€™t meant to be a prison.
  prefs: []
  type: TYPE_NORMAL
- en: The lasagna problem isnâ€™t limited to large, multi-service programs. Youâ€™ll see
    it in smaller ones too, in the form of layers of inheritance. Inheritance is a
    foundational feature of object-oriented programming. If a language doesnâ€™t support
    inheritance, itâ€™s not in the club, and it canâ€™t call itself object-oriented. Consider
    what the `NginxLogLine` class from the project in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016),
    *Thereâ€™s a Big Ball of Mud on Your Plate of Spaghetti*, might look like after
    a few iterations of requirements gathering, coding, and releases. The use case
    Iâ€™m presenting here is pure fiction and doesnâ€™t actually relate to the release
    history of NGINXâ€™s log structure. I need a believable series of complications
    to help make my example work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s say the code in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016) represents
    the first release. The client was thrilled and started coming up with new requirements,
    as the software was exposed to different business users in the real world. A shortlist
    of new requirements might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It was noted by some of the IT professionals using the program that while it
    works perfectly with the latest version of the web server software, it breaks
    when working with older versions because the log structure has changed several
    times over the last few years. We need to support the last major revisionâ€™s log
    format, as well as the most current.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users based in Asia noted that the text formatting in their log files is not
    supported because their text files are encoded using double-byte formats. We need
    to support international text formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important IT group canâ€™t even use your software because they donâ€™t use
    NGINX exclusively. They also use Apache and they noted they have the same constraints.
    The log formats have changed over time, so they have several formats to consider,
    and they too need support for single- and double-byte text implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me reiterate my earlier disclaimer. While I do know my way around a web
    server log, I am by no means a web server log aficionado. As a reminder, this
    is a fictitious cautionary tale. Any resemblance of our requirements to actual
    software requirements is purely coincidental. I further promise under the penalty
    of perjury that no cute and fluffy animals will be harmed in the equally fictitious
    production of said software. My lawyer wants me to add more, but my editor wants
    me to get on with it already and I learned early that my editor is always right.
  prefs: []
  type: TYPE_NORMAL
- en: Next, letâ€™s suppose since there was zero inheritance used in the original code
    that maybe it was because we were new to C# and didnâ€™t fully understand how to
    use inheritance. Now, suppose we bought a book from a publisher other than Packt.
    It was written by a university professor who has never published software in a
    commercial setting. This is common. Theyâ€™ve never heard a pointy-haired boss who
    wielded godlike power over their livelihood tell them to clean up the prototype
    and ship it next week. At no point have they faced a deadline unrealistically
    dictated by a marketing department. In short, this book would be by an author
    who doesnâ€™t work in the real world of software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of author may have presented a muddy, overly academic picture of
    C#â€™s inheritance model, along with the academically perfect way to structure your
    code. They are basing their estimation on the available academic literature reviews,
    also written by university professors who have never actually worked in the field.
    Your young, sharp, supple, but impressionable mind might be persuaded by all the
    authorâ€™s academic credentials to make something similar to what follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 â€“ The UML equivalent of a dumpster fire next to a train wreck
    (this is an example of too much inheritance) ](img/B18605_Figure_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 â€“ The UML equivalent of a dumpster fire next to a train wreck (this
    is an example of too much inheritance)
  prefs: []
  type: TYPE_NORMAL
- en: This is a poorly constructed inheritance chain represented using the **Unified
    Modeling Language** (**UML**). If youâ€™ve never seen a UML class diagram before,
    you should jump to [*Appendix 2*](B18605_Appendix_2.xhtml#_idTextAnchor204) at
    the end of the book. It has an overview of how to draw and interpret these diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance chain represented in the diagram goes deeper than is necessary,
    The design goal can be accomplished more cleanly by using tools such as interfaces
    and techniques such as composition. Youâ€™re also staring at the beginning of class
    proliferation.
  prefs: []
  type: TYPE_NORMAL
- en: Class proliferation happens when you find yourself needing to add more and more
    classes to support new requirements. This sets us up for a classic stovepipe design.
  prefs: []
  type: TYPE_NORMAL
- en: Too many layers of inheritance, especially when functionality that belongs in
    one class slowly bleeds into other classes over time, will yield lasagna.
  prefs: []
  type: TYPE_NORMAL
- en: If only we had yet another pasta metaphor that is delicious and satisfying,
    but less deleterious to the work-life balance of whoever has to maintain what
    weâ€™ve created thus farâ€¦
  prefs: []
  type: TYPE_NORMAL
- en: Ravioli â€“ the ultimate in pasta code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While everybody loves spaghetti and lasagna, you donâ€™t want them showing up
    in your code. Ravioli, on the other hand, is something we aspire toward.
  prefs: []
  type: TYPE_NORMAL
- en: When we make ravioli, it is again comprised of the same set of ingredients used
    to make spaghetti and lasagna. Again, the difference is in the configuration of
    the materials. The noodles now form a full boundary around the deliciousness inside.
    The meat or cheese within the noodle is fully encapsulated, with the content only
    ever being exposed when it is consumed. Thereâ€™s probably also a delicious sauce
    on the outside that brings the whole dish together into something thatâ€™s not chaotic
    and not unnecessarily dense.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth noting that the level of effort needed to shape and stuff
    the noodles is a lot more work than simply boiling a handful of straight noodles.
    Making ravioli, as with good object-oriented code, requires patience and work.
    The idea of ravioli is the epitome of pasta object-oriented design if you remember
    the foundational pillars used to previously describe object-oriented design:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is used to limit access to an objectâ€™s state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction refers to a class modeling a real-world object with only the level
    of detail needed by the software. If we were to write software that needed a `Person`
    class to model a human being, the `Person` class would be modeled differently
    in a medical records application than it would in a phone book application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance allows common structures between classes to be shared in a parent
    class, negating the need to copy the same code repeatedly between classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism allows a class designer to defer implementing abstracted details
    to concrete classes. For example, an abstract `Vehicle` class might have a `Go()`
    method. The `Go()` method would work very differently for concrete classes such
    as a car versus a boat, a skateboard, a submarine, or an airplane. Polymorphism
    allows us to create the appropriate implementation at the concrete level but define
    it at the abstract level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to talk a little more about encapsulation with specific regard to C#.
    In well-designed object-oriented code, objects are encapsulated. This means the
    objectâ€™s state is closely guarded. Only the instance should be allowed to alter
    its own internal state.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, poorly constructed code allows for objects to directly change the
    state of other objects. Auto-implemented properties in C# make this very easy
    by making properties no better than fields. If every property is public, and there
    are no rules, as is the case with auto-implemented properties, any object can
    change the state of any other object. We can compound the problem with a long
    inheritance chain, where every property at every level is public, internal, or
    protected. When this is the case, any object at any level can impose state changes
    up or down the inheritance chain. This makes it difficult to track what is changing
    each objectâ€™s state and under what circumstances. State changes bleeding between
    layers is the very definition of lasagna.
  prefs: []
  type: TYPE_NORMAL
- en: If your code is similar to ravioli, each instance of each object stands alone
    as a fully encapsulated class with limited inheritance. It is the master of its
    own state, and it meticulously and entirely controls that state. Since these objects
    bear all these hallmarks, you can easily leverage composition to build complex
    objects instead of relying solely on inheritance to define the behavior of an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is a technique focusing on building objects out of other objects.
    Composition works best when we use interfaces to define how these objects fit
    together. An interface defines the structure of an object. Think of it as a mechanical
    socket such as a light socket. You can plug any bulb into that socket, provided
    it fits. What makes it fit is the definition presented by the dimensions of the
    socket. Interfaces in C# can define a set of properties and methods that an object
    is expected to have. Any object that fits the specification can be used just as
    a bulb fitting into a socket would.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a set of classes designed to model an automobile. There are lots of
    different kinds of cars. There are sports cars, family sedans, minivans, and my
    personal favorite, the Jeep. All of these cars are very different. We could try
    to come up with an inheritance chain to tie them all together in a familial hierarchy.
    I suspect though, that if you limited your design to strictly inheritance, youâ€™d
    wind up with hundreds of classes. The resulting code would be a messy, muddy plate
    of pasta.
  prefs: []
  type: TYPE_NORMAL
- en: A better idea is to use composition. We can keep our abstract car model, but
    instead of making subclasses, we can add interfaces to define the characteristics
    of the car. For example, we can make an interface for each component that defines
    a car. For example, we can make an interface that defines an engine.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create an interface that defines the transmission. There is a huge
    difference between the transmission of a family sedan, a high-end sports car,
    and a 4x4 off-road vehicle. However, it is possible to define a common set of
    properties and methods. Any transmission object I can model will slot into my
    car object, provided it follows the required interface.
  prefs: []
  type: TYPE_NORMAL
- en: If I were to sum up the job of an object-oriented developer, and I were only
    allowed one sentence, I would say that our job is to always ensure that no object
    should ever be allowed to fall into an invalid state. Iâ€™ll expand on this idea
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The foundational principle â€“ writing clean code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main point of presenting the topics in this chapter is to set a boundary.
    You can master all the patterns in this book and more, but if your software is
    poorly written, overly clever, haphazardly structured, or hard to maintain, then
    all the patterns in the world canâ€™t help you. Letâ€™s set some boundaries. Iâ€™m going
    to suggest some guidelines for creating â€œclean code.â€ You are welcome to argue
    the minutiae. It doesnâ€™t bother me one bit if we differ in opinion over tabs versus
    spaces as long as you have a method to your particular flavor of madness. Letâ€™s
    paint some broad strokes that hopefully everyone can agree with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean code has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Easily readable by human beings with limited cognitive load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent in style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documented with an appropriate level of commentary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should write code that is readable by humans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I feel as though this isnâ€™t as obvious as it should be. We write code to be
    compiled and executed by machines who donâ€™t care for the expressiveness we use
    when we write our code. Writing code is writing language. Human languages are
    expressive and so are humans. We can take our written languages and create a business
    email indicating stock shortages, a medical report outlining potential patient
    outcomes following a diagnosis of dermatomyositis, a masterâ€™s thesis on molecular
    biology, a long-form romance novel, or even a haiku. Your computer languages are
    also expressive with their limited vocabulary. C# has 79 keywords. With those
    79 keywords, you can create everything from a short program to download your email
    to an entire operating system. Itâ€™s a powerful and expressive language. As long
    as you use valid syntax, the compiler will be happy. You need to focus your efforts
    on making your code readable to other people. Iâ€™ve always believed the golden
    rule applies here: *do unto others as you would have others do unto you.* You
    should treat everyone with the same level of respect youâ€™d like to be treated
    to yourself. You should write code that requires minimal effort by others to scan
    and understand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This starts with the way you name classes, variables, methods, and the other
    elements used to create your software. If the names represent the intent for how
    those elements are used, youâ€™ve taken a step toward creating code that is more
    readable and more maintainable. Some staples of best practice include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name your elements so that their intended use is intuitive. `this.pn` is not
    intuitive. You can likely think of a dozen things it might be. If weâ€™d used `this.phoneNumber`,
    you wouldnâ€™t have to guess.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create names that are searchable. `MAX_FILES_PER_UPLOAD` defined as a constant
    makes it easy to find in your code, especially if youâ€™re using an IDE that indexes
    your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave outdated encodings to the old-timers. You likely donâ€™t do things like
    this unless you are very (how can we say it nicely?) seasoned. A long time ago,
    in this very galaxy, we learned to create variable names using codes. I donâ€™t
    mean programming code; I mean codes as in Hungarian notation. This was before
    we had type-checking IDEs. It reminds me of Garrison Keelerâ€™s *Lake Wobegon* podcasts
    where he spun tales of a simpler time. We wrote in simple console editors such
    as *vi* and *emacs* and we liked it that way. We might as well have been using
    *Notepad* with our fingers tied together. Back then, we didnâ€™t have *Roslyn* looking
    over our shoulders and pointing out our missteps. We needed a way to tell which
    data type was used in our variables, so weâ€™d call a variable `intAge` or maybe
    `iAge`. As I said, you probably donâ€™t do this anymore unless you were taught this
    way. If you were taught this way, kindly knock it off. Thank you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Donâ€™t bother with member prefixes or suffixes. It used to be common to prefix
    member variables with `m_`, for example. As with encodings, this kind of thing
    isnâ€™t needed because we have good IDEs, and your classes should be short and discrete
    in function so that prefixes are not needed. Besides, after a while, people tend
    to ignore them as noise while scanning your code and they cease to be significant.
    Iâ€™ve seen university professors teach it this way for a long time. I might have
    been one of them. Iâ€™m not proud of it, but that was a long time ago and Iâ€™ve moved
    on since then. The exception that I still observe is the common custom of naming
    private fields with an initial underscore. I think most people do that so they
    can name the field something obvious that matches the property name where they
    intend to expose the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use parts of speech in your code. Your objects are nouns. They represent people,
    places, and things. Name them as such. `Person` makes for a good abstract class
    name, which might be extended in `Student` and `Professor`. Class names that contain
    verbs as part of the name, such as a class named `ParseLogLines`, become confusing
    as class names. Naming the class `LogLineParser` is clearer because it sounds
    like a thing rather than an action. Within classes, the methods are your verbs,
    so name them that way. `ParseLogLines` totally works as a method name. If you
    pay attention to these details, your code will wind up reading as a normal sentence
    would, albeit with odd but understandable punctuation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Donâ€™t Repeat Yourself** (**DRY**). By this, I mean donâ€™t write the same code
    twice. Also, donâ€™t duplicate anything, and never repeat something youâ€™ve already
    written. Dang it, sorry about that. I see this most often when people are in a
    hurry. Theyâ€™ve got some code in another project or another part of their current
    project but itâ€™s not written in a way that is conducive to reuse, so they copy
    and paste it into different programs or different parts of the same program. This
    is a broken window. Soon, your code will not be DRY; itâ€™ll be wetter than an octopusâ€™
    belly button, and that kind of thing will be everywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of dead code. This is a huge pet peeve for me. Once I was working as
    a Java developer. I know, I was young and I needed the money. I was pretty new
    to the job and we had a database function that wasnâ€™t writing to the database
    as expected. Iâ€™d change the method around and run the tests. Same result. Eventually,
    I decided to make a silly, ridiculous big change. Nothing. I was working on a
    method called `WriteInventoryPartToDatabase`. OK, that seems well named. It seemed
    to be an obvious place to look for the problem. After an hour or so, I realized
    the method I was working on was *old code* and that the actual method I needed
    had been moved to another class. The developer who moved the method kept the old
    method in place *just in case* and never cleaned it up later. OK, people. This
    is why revision control systems exist. You can always go back. Donâ€™t be lazy.
    If you delete or remove something, donâ€™t just change it in the calling method.
    Get rid of the dead parts or someone else will potentially spend a lot of time
    on a red herring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Format your code for human consumption. Something such as this should be an
    anathema to your very being:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our IDEs have gotten pretty good at defaulting to fonts that help us detect
    the differences between zeros and capital Os, and lowercase Ls and 1s. Options
    such as turning on font ligatures help even more. Ligatures are improved fonts
    that show you a more expressive set of characters. For example, look at the way
    `!=` is rendered in *CaskaydiaCove Nerd* Font from [nerfonts.com](http://nerfonts.com).
    It appears as `â‰ `, which is the way your high school math teacher presented it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 â€“ An IDE with font ligatures turned on displaying !=  ](img/B18605_Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 â€“ An IDE with font ligatures turned on displaying !=
  prefs: []
  type: TYPE_NORMAL
- en: 'You can turn these on in your IDE. In Visual Studio, you just set the font
    to one that supports ligatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 â€“ In Visual Studio, simply set the font in the Options window
    to one that supports ligatures, such as CaskaydiaCove Nerd Font Mono, which you
    can find free at nerdfonts.com ](img/B18605_Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 â€“ In Visual Studio, simply set the font in the Options window to
    one that supports ligatures, such as CaskaydiaCove Nerd Font Mono, which you can
    find free at nerdfonts.com
  prefs: []
  type: TYPE_NORMAL
- en: 'In *JetBrains Rider*, you have an actual setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 â€“ JetBrains Rider IDE settings for fonts allow you to specifically
    turn ligatures on and off ](img/B18605_Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 â€“ JetBrains Rider IDE settings for fonts allow you to specifically
    turn ligatures on and off
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer *Visual Studio Code*, youâ€™ll need to edit your `settings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The IDEâ€™s normal coloring helps too, except when youâ€™re reading a book printed
    in grayscale ðŸ˜Š.
  prefs: []
  type: TYPE_NORMAL
- en: The previous bullet points are guidelines for writing code for human consumption.
    These tips will help you as we move into the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing and enforcing style and consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be using a set of conventions for consistently naming elements of
    your code, as well as applying a consistent coding style. If you do this well,
    you wonâ€™t be able to tell where your code ends and someone elseâ€™s starts. Iâ€™m
    not going to dedicate time to recommending coding conventions, as these are well
    established in the industry. Some such conventions are baked into the IDEs, such
    as curly braces always dropping to a new line, For the rest, you can use an automation
    tool such as JetBrainsâ€™ *ReSharper*, *Prettier* for *Visual Studio Code*, or the
    open source project called *StyleCop*. All of these have tools that allow you
    to add style enforcement to the IDE, as well as the ability to run a check when
    you commit your code to a **Continuous Integration** (**CI**) server. Mavericks
    who arenâ€™t using the proper styling will fail their builds, giving everyone else
    on the team the opportunity to help them see the error of their ways.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting cognitive load
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem isnâ€™t that the poorly written code is unintelligible. The problem
    is that itâ€™s unscannable. One thing Iâ€™ve noticed over the years is that, regrettably,
    I no longer read entire paragraphs in prose anymore. Granted, itâ€™s rare that I
    read books with zero code in them. Over the years, my brain has adapted to reading
    code, so I scan. If youâ€™ve also been reading code for a while, you probably do
    it too even if you donâ€™t realize it. Remember this and work toward making your
    code scannable. If you can just look at it and think *OK, got it. Next?*, then
    itâ€™s easy to scan and understand. The opposite is having to stare at some code
    for seconds or minutes in order to decode it in your brain. It takes a noticeable
    and uncomfortable amount of time to figure out what it means and what it does.
    Psychologists refer to this as **cognitive load**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Thatâ€™s better. No more thinking. Save that for when you really need it.
  prefs: []
  type: TYPE_NORMAL
- en: Terse is worse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of cognitive load, I know a lot of developers who love terse syntax.
    Let me show you what I mean. I found a perfect example on Stack Overflow at [https://stackoverflow.com/questions/7103979/nested-ternary-operators/7104091#7104091](https://stackoverflow.com/questions/7103979/nested-ternary-operators/7104091#7104091):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Itâ€™s so terse that itâ€™s impossible to scan. Youâ€™re going to have to hunker down
    for a good few minutes to even figure out what it does. Some developers think
    writing code in this way makes them appear smarter than everyone else. It doesnâ€™t.
    This would be similar to an English writer who is overtly sycophantic and obsequious
    toward their quasi-internalized sesquipedalian. Did you get all that, or did your
    eyes scan back across the sentence a few times? I could have simply said, â€œ*This
    would be the same as an English writer who goes out of their way to give in to
    the obsessive use of long words.*â€ Good writers can write to be understood by
    a university-educated audience, which is to say, their peers. Great writers can
    write the same content to be understood by a group of talented sixth graders.
    This takes as much concentrated effort as writing tersely, but you can do the
    same thing with your code and everybody charged with maintenance will thank you
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s refactor it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Bam! Welcome to the least sexy code ever written. If you post it to Reddit,
    the best you can hope for is the occasional *meh* amidst a litany of trollish
    comments, not all of which are limited to your code. That said, now you can scan
    it, and the rules governing setting the default phone number are fairly obvious.
    This is true because while the terse code was bad, we did at least use obvious
    object and property names to indicate proper intent.
  prefs: []
  type: TYPE_NORMAL
- en: Comment but donâ€™t go overboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commenting on your code is good. Iâ€™ve read academic articles that present solid
    arguments for as much as one-third of your lines of code being devoted to comments.
    The problem with this is the practice is dangerously close to writing documentation,
    and the only thing programmers hate more than writing documentation is directly
    interacting with users. Good news â€“ if you write clean code using the ideas Iâ€™ve
    stressed so far, you can get away with fewer comments because your code will already
    be easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: I think a happy medium is represented by a comment containing a brief restatement
    of the requirements. If your requirements are documented in an online system as
    they should be, you could even link to the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also comment on anything that isnâ€™t obvious, such as my motivations for writing
    something a certain way. This is a useful comment: *Iâ€™m doing it this way because
    our suppliers require data to be in this format.* This way, my team doesnâ€™t come
    in behind me, see something they think needs refactoring, but wind up breaking
    code that conforms to customer requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Comments go bad when there are too many of them. Commenting every line is silly
    unless youâ€™re writing a book, or teaching a class for beginners who are learning
    to read code for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating maintainable systems using SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SOLID is a reference to the top five principles of **Object-Oriented Design**
    (**OOD**):'
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Open-Closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Liskov Substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Interface Segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dependency Inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these principles will allow you to create systems that are robust,
    extensible, and maintainable. Honoring these principles prepares you well for
    working with patterns because many patterns are built on or reference these principles.
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every method should do one thing. Every class should represent one thing. We
    call this idea the **Single Responsibility Principle** (**SRP**). If you have
    a method inside an object that does many things without invoking outside methods,
    your method is doing too much and runs the risk of becoming an example of the
    antipattern known as *the god function*. These are big, messy piles of inedible
    pasta. Once, I got a desperate text from a colleague. Her program was crashing.
    She couldnâ€™t figure out why. I looked. The entire program was in one file that
    when printed out was over 20 pages long. There were nine functions in the whole
    program. I closed the project, deferring the review for a time when I could sit
    down and go through it in earnest. I highly suspected she was ignoring the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s look at an example of a method that does too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Weâ€™ve started a function thatâ€™s clearly going to do too much. We begin by opening
    a text file on our computerâ€™s hard drive and reading in the first line. Next,
    letâ€™s read through each line in the file, and send each line of text to a fictitious
    online service that translates the text into another language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be valid, the sentence needs the text to be trimmed, all uppercase, and
    there can be no semicolons in there because the serviceâ€™s author got hacked by
    SQL injection once, and he vowed never again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, the text is ready. Letâ€™s transmit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Weâ€™ve transmitted the data; letâ€™s parse out the response and print it to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the next line, rinse, and repeat until we reach the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open it, you should close it, so letâ€™s clean up after ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you see the problem here? We have one method performing many operations:'
  prefs: []
  type: TYPE_NORMAL
- en: We open a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We process each line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We transmit to the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We process the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these should be separated into its own method. When you do this, you
    can reuse the methods in other contexts to solve other problems. Reading a file
    is generic. Itâ€™s the kind of thing youâ€™d do often. So is sanitizing your input
    string. So is posting to a `RESTful` endpoint. You canâ€™t reuse the `doesTooMuch()`
    method. Itâ€™s too specific to a single point of implementation. In [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063),
    *Getting Creative with Creational Patterns*, weâ€™re going to take off the training
    wheels and start learning patterns. Patterns are utterly incompatible with god
    methods of this kind.
  prefs: []
  type: TYPE_NORMAL
- en: The Open-Closed Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes should be open for extension but closed for modification. This is called
    the **Open-Closed Principle** (**OCP**). This is especially true of software thatâ€™s
    already in production. Youâ€™ve got a set of well-written, fully tested production
    classes. Messing around with the wiring introduces the risk of breaking something.
    When new code can be written as an extension to what you already have, the risk
    is limited to the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s look at an example by looking at code that violates the OCP. Weâ€™re going
    to make a simple utility designed to add up the areas of a set of geometric shapes.
    For our initial release, weâ€™ll support circles and squares. Iâ€™ll represent the
    `Circle` library this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Iâ€™ve set this up with an `Area` property that is read-only. There is no reason
    to allow someone to set the property directly. Instead, I use the constructor
    to force you to define the radius of the circle on instantiation. This prevents
    you from setting `Area` to whatever the heck you feel like, which might result
    in the object entering an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: When you instantiate, you pass in the radius, which is all we need to find the
    area of the circle. Good old *Ï€Â â€¢ rÂ²,* or the constant pi times the radius squared.
    The area is set automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do something similar with a square. We only need to know the length
    of one side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As before, we present an `area` property as read-only and use the constructor
    to set the area automatically upon instantiation by multiplying the `lengthOfOneSide`
    argument by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I have two classes to represent my shapes and each has an `area` property
    set automatically on instantiation. All I need is a class to glue them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a class called `AreaCalcuator` with an `area` property. On this
    one, I chose to create a backing variable to make it easy to keep a running total.
    Each time you add either a square or a circle using the twice-overloaded `AddShape`
    method, it takes the area computed on instantiation and adds it to the total.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can test its function with code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This looks pretty good! Ship it already! All is well until our delighted customer
    returns with a request to support more shapes. Itâ€™s not hard, is it? Maybe all
    they want is a rectangle. All I need to do is make a `Rectangle` class, then modify
    the `AreaCalculator` class with another constructor.
  prefs: []
  type: TYPE_NORMAL
- en: If I do this, I am violating the OCP because I have to change the `AreaCalculator`
    class directly every time we get a new shape requirement. I should design it so
    that you can pass in anything with an `area` property on it, then I would never
    have to alter `AreaCalculator` ever again. Letâ€™s fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iâ€™ll make an interface to define my requirement for an `Area` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, letâ€™s modify the shape classes to implement the interface. This is easy
    since both already have the `area` property exposed in a way that satisfies the
    requirements of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, letâ€™s do the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'I renamed the class `OCPCircle` so that I wouldnâ€™t get them mixed up. Now,
    letâ€™s do the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, Iâ€™ll modify the `AreaCalculator` class to use the interface as its type
    on the `AddShape` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Now, we never need to alter this method in this class again. It is
    open for extension and closed for modification. To honor any new requirement for
    any shape, I need only add a new class that implements the `IShapeWithArea` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iâ€™ll go ahead and add a rectangle class that implements the same `IShapeWithArea`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It doesnâ€™t matter what the clients ask for next. Adding support for a hexagon,
    rhombus, or dodecagon is a simple matter of Googling the area formula for that
    shape and making a new class that implements our interface.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov Substitution principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1988, Barbara Liskov delivered a keynote speech at a conference titled *Data
    Abstraction and Hierarchy*, wherein she introduced what came to be called the
    **Liskov Substitution Principle** (**LSP**).
  prefs: []
  type: TYPE_NORMAL
- en: The principle states that any object of a subtype should be a suitable and working
    substitute for its superclass. This really relies on inheritance more than anything
    else. Using the strategy I just showed you, which is to rely more on interfaces
    than inheritance, youâ€™ll not likely run afoul of the LSP. By now, youâ€™ve no doubt
    surmised that I enjoy breaking rules (ask anyone), so letâ€™s break this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements Iâ€™m working toward are similar but not identical to the last
    example. Here, I have a requirement to compute the area of rectangles â€“ just rectangles.
    To make this work, pretend that I didnâ€™t show you the best solution already in
    the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I was a little less cautious this time. I used normal auto-implemented properties
    for the width and height rather than a constructor. If Iâ€™m breaking rules, I may
    as well let my hair down entirely. The `Area` property is suitably encapsulated,
    so you canâ€™t get up to anything too nefarious here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, letâ€™s make a class to handle adding up areas of rectangles in a very similar
    fashion to our last example for the OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Thatâ€™s pretty straightforward. Not even an hour after you create this, the ubiquitous
    pointy-haired boss tells you about a requirements change. You need to support
    a square too.
  prefs: []
  type: TYPE_NORMAL
- en: 'No problem, you think. A square IS A rectangle. Obviously, we can do this with
    inheritance. Perhaps we donâ€™t need any change at all, but the pointy-haired boss
    must be appeased. I highlighted the IS A term earlier because this phrase characterizes
    inheritance, and it happens to be true. A square IS A rectangle. We make the class.
    Since weâ€™re using inheritance, we need to make a quick change to the `Rectangle`
    class so that it can support inheritance. Weâ€™ll make the properties virtual so
    that we can override them in the subclass if we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing about the square is that it is rectangular, but we only need the
    length of one side to compute the area. The parent class, `Rectangle`, requires
    the length of two sides. Suddenly, things are starting to look a little ugly.
    Letâ€™s think while we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: I had this great idea! We could fix it so that we have a backing variable. Any
    time you modify the width or height, the `accessor` method simply changes the
    backing variable, which is referenced by the getter on the `Area` property. Since
    both the width and height are set to the same thing, multiplying width times height
    will give us the area of the square. It doesnâ€™t mess up the whole rectangle class
    needing both values. I would now like you to visit YouTube and search for *Guinness
    beer commercial brilliant*. Pick any video with the cartoonish-looking guys. Iâ€™ll
    wait. Brilliant! This calls for celebration, perhaps even a libation. Will it
    work? Of course it will. Iâ€™ll ship it and feel extra special today, as though
    I got away with something naughty because I was clever. In fact, right now might
    be a good time to go do my taxes.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, in a totally different department, the newbie developer recently
    hired by the pointy-haired boss wrestles with a similar requirement. Naturally,
    we want to reuse as much as we can. The newbie takes your code but does something
    totally unexpected. The requirements make it necessary to change the numbers for
    the width and height. Never mind why. Do you know what happened to the last newbie
    that questioned the veracity of the pointy-haired bossâ€™ technical direction? Theyâ€™re
    in a basement cubicle without air conditioning somewhere hot and humid, working
    on ways to speed up bubble sort algorithms using Z80 assembly language on punched
    cards. Their breakroom is devoid of a latte machine. They donâ€™t even get Herman
    Miller chairs. Itâ€™s downright barbaric. You donâ€™t want that to be you, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s the newbieâ€™s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Brilliant? Maybe, but probably not. Some requirement is forcing the newbie to
    change the values of width and height independently within the superclass. This
    is not a problem for the `Rectangle` superclass, which is designed for this kind
    of thing. However, this will absolutely break the square implementation when you
    try to substitute the square for the rectangle, despite the obvious IS A relationship
    between a square and a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If youâ€™re familiar with the Darwin Awards, youâ€™ll know that every winner utters
    the same phrase before embarking upon whatever it is that won them the award.
    In Texas, or pretty much any southern state, it happens as follows: *Hey, yâ€™all?
    Hold my beer and watch this.*'
  prefs: []
  type: TYPE_NORMAL
- en: Iâ€™m going to show you an example of Liskov substitution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Everything works. This next part is where it breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we pass a square to `AddShape`, we get an answer that isnâ€™t 200\. It comes
    out as 400, which causes the error to be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Because our intrepid newbie needed to change the `base` class to modify the
    values independently, we broke the LSP, which says we must be able to substitute
    the subclass, `Square`, for the superclass, `Rectangle`. While our sneaky overrides
    in the `Square` class seem clever, it doesnâ€™t work for every case. You might say
    weâ€™re trying to fit a square peg in a round hole. Then again, you might think
    better of it, ask for that beer back, and stare admiringly at the rugged simplicity
    of the earlier OCP solution with the interface, which is likely the best solution
    to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Youâ€™ve now seen an example of broken Liskov substitution. No doubt you want
    to see it done well. I will be happy to oblige you in later chapters, which are
    chock-full of references to the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: The Interface Segregation principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No class should be forced to implement an interface that it doesnâ€™t use, nor
    should it depend on a method it doesnâ€™t use. Donâ€™t you hate it when this happens?
    Youâ€™re forced to use something you donâ€™t need or want? This is undoubtedly how
    the newbie who blew it with the Liskov substitution problem felt. However, weâ€™re
    coders, not psychologists, so letâ€™s press on and expand upon the idea of railing
    against being forced to use things we donâ€™t need via the **Interface Segregation
    Principle** (**ISP**).
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s say we get a new requirement that has us working with two- and three-dimensional
    shapes, where we need the area for two-dimensional shapes and the volume for three-dimensional
    shapes. Naturally, we want to stick with something that works, and the interface
    idea in the section on the OCP seemed to work so well that it proved useful in
    the Liskov scenario too.
  prefs: []
  type: TYPE_NORMAL
- en: This time, the pointy-haired boss doesnâ€™t give us a newbie â€“ he gives us a seasoned
    veteran. Unfortunately, this seasoned veteran has a case of psychogenic blindness
    as a result of the *not invented by me* syndrome. This is to say that when he
    looks at any solution he didnâ€™t invent personally, he instantly assumes said solution
    is flawed, and he expresses his disdain for the solution using colorful language
    commonly heard emanating from maritime professionals. In short, he cusses as though
    he were a sailor when he describes code that he didnâ€™t write, even though the
    person who did write that code is probably a few cubes away. Since awkwardness
    means nothing to this guy, given heâ€™s the smartest guy in the room, he decides
    he doesnâ€™t need anything that weâ€™ve written so far and he strikes out on his own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heâ€™s in a hurry and this work is beneath him anyway. He wants to get back to
    solving the traveling salesman problem and the n-body problem simultaneously with
    a runtime of O(log n). Your silly project is in the way. He half-heartedly types
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: OK, he wouldnâ€™t call it `IPollutedShape`. I did that for you. I spent 3 years
    working in technical pre-sales and I learned something that stuck with me. Never
    let the truth or any sense of realism get in the way of a good story.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the problem without the implementation, right? If I made a `cube`
    or `cuboid` class that extends this interface, itâ€™s fine. Theyâ€™re both three-dimensional
    shapes and we need three dimensions to calculate volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we use the same interface with a two-dimensional shape, weâ€™d be
    forced to have a `Depth` property, which has no place in such a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Yuck! Weâ€™ve got this extra property just sitting there doing nothing! It reminds
    me of that time my aunt Linda had spinach in her teeth. Whatever, we saved time
    by only making one interface. Our cocky super-coder can get back to picking up
    Sir Isaac Newtonâ€™s slack.
  prefs: []
  type: TYPE_NORMAL
- en: We have now violated the ISP by forcing the use of a property or method that
    we donâ€™t need. That other guy isnâ€™t paying attention. Someone asked about how
    it is to be a graduate student at Carnegie Mellon, and thereâ€™s nothing he loves
    more than talking about his time in graduate school back when he was dumbing down
    his best work just so that his professors could understand his assignments. This
    is perfect. Letâ€™s fix it while heâ€™s not looking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we need two interfaces. Unlike inheritance, where you can only have
    one superclass, you can implement multiple interfaces on one class. With C#, thereâ€™s
    an even cleaner way. Letâ€™s make the interface for the two-dimensional shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy. A three-dimensional shape uses all the same parts as a two-dimensional
    shape but adds depth. Letâ€™s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'C# allows inheritance in interfaces. I used the properties defined in the interface
    for two-dimensional shapes and extended it to require a property representing
    depth. Now, letâ€™s type out the `cube` class for the win:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Ta-da! We honor the ISP by only enforcing exactly what is needed and no more.
    Thereâ€™s nothing wrong with stacking multiple interfaces if thatâ€™s your thing.
    You can also use inheritance in your interfaces, as I did.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Inversion principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you first learn how to design an inheritance hierarchy, you learn that
    high-level objects establish a base, while low-level objects form dependencies
    on that base. The **Dependency Inversion Principle** (**DIP**) flips this upside
    down and forms the basis of a very important practice called **decoupling**. We
    saw the power of decoupling in the OCP example earlier. We learned how to use
    an interface to prevent a strong coupling between two concrete classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am offering a note of caution. Dependency inversion on the surface sounds
    similar to **Dependency Injection** (**DI**). It also sounds similar to **Inversion
    of Control** (**IoC**). These are not identical concepts. Given that we just talked
    about Liskov substitution, you should understand that they are not interchangeable.
    The reasons are subtle but they are there. I donâ€™t want to stray too far off-topic,
    so Iâ€™ll leave you a link in the *Further reading* section at the end of this chapter
    where Martin Fowler explains the subtle differences between the three seemingly
    synonymous words. Letâ€™s move our focus back to the DIP. This principle states
    two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A. High-level classes or modules should not depend on low-level classes or
    modules and both should depend on abstractions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*B. Abstractions should not depend on implementation details but instead details
    should depend upon abstractions.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To me, this sounds comparable to something a Shaolin monk might say in a kung
    fu movie right before ripping off his shirt and serenely engaging in mortal combat.
    Letâ€™s see whether we can bring it to the street. Consider how you might design
    a lamp using OOP principles. One way might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereâ€™s a lamp. We need a button to turn it on and off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This lamp will work. When you trigger the `ToggleLamp` method inside the button,
    the lamp will turn on or off as expected. However, it violates the DIP. The notion
    that a lamp is a high-level object while the button is a low-level object feels
    intuitive. Thereâ€™s just something wrong with putting a lamp inside of a button.
    Youâ€™d think it should be the other way around, just as it is in real life. Your
    gut feeling here results in violating both tenets of the DIP. The high-level object
    is inside the low-level object, and everything is a concrete class with nary an
    abstraction in sight. How do we fix it?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use composition. Remember that composition entails building, or composing,
    an object out of component objects. This could be something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Hereâ€™s our button with no lamp in it. Instead, the button should be in the
    lamp. To put it another way, we should compose a lamp using a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We inverted the dependency. The button is inside the lamp and the low-level
    object directly depends on the high-level object. Weâ€™ve satisfied the first tenet
    of the DIP. We still have more work to do before we reach Shaolin-level mastery.
    The button and the lamp are still tightly coupled via concrete object implementations.
    What if we want to use something other than the button to turn the lamp on? Maybe
    a motion detector. Maybe one of those fancy **Internet of Things** (**IoT**) microcontrollers
    that everybodyâ€™s talking about. Effectively, this is still a button, but itâ€™s
    much fancier and its object representation would be more complex than our button.
    We need an abstraction for the button that allows us to plug in any object that
    works as a button would. Letâ€™s make an interface that describes what the lamp
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we make the button extend the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewire the lamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As usual, I changed the names a little bit so that we can keep our examples
    straight. I changed the name of the member variable that formerly held our concrete
    button to something more generic, namely `DipoleSwitch`, which I figured could
    describe just about anything that fulfills a binary on-and-off function.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a lamp with high-level and low-level objects in the proper orientation.
    We could argue that theyâ€™re correct now and that we started with them inverted
    the wrong way. Kind of like in the southern United States when someone offers
    you sweet tea or unsweetened tea. Thereâ€™s no such thing as unsweetened tea. It
    isnâ€™t as if you put the sweetness in and then took it out. It was unsweetened
    when it was made. The wording is weird, but we say it that way anyway. Thatâ€™s
    how our lamp started when it was inside the button class. It works, and everybody
    knows what you meant, but itâ€™s still wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We also removed the concrete button object and swapped it for an interface.
    We could have used an abstract class to satisfy the second tenet, but I still
    believe we should tend toward interfaces, as they are more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: We have, in the process of learning about the DIP, learned what it means to
    decouple. Decoupling is a strategy rather than a pattern and it has many uses
    at many different levels of your software projects.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring quality beyond the development organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weâ€™ve spent a lot of time in this chapter talking about quality code from the
    perspective of software engineering. Software is never developed in a bubble.
    It is always developed in concert with business professionals working to solve
    business problems. That means a great many people on your project might not be
    developers or engineers. All of our discussions so far have revolved around specific
    engineering practices. However, you need to realize that these views wonâ€™t be
    shared by your business-oriented colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: For them, *quality* is often defined as *conformance to requirements*. That
    means quality code is code that meets its requirements. I would argue that this
    is a far too basic definition. The corporate quality movements of the 80s and
    90s, such as the lean manufacturing and zero defects ideals espoused by Deming,
    have been coopted into our field by well-meaning managers. They want to focus
    100 percent on the customer. They have trouble relating to what we do because
    they donâ€™t understand anything about software beyond the superficial layer the
    users see. Your non-engineer colleagues will have trouble talking to you about
    quality because you are speaking different languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get everybody on the same page, letâ€™s consider some questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the term *quality code* mean to you?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean to your boss?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean to your bossâ€™s boss?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean to your end users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean to your suppliers, that is, the business professionals who
    supply the raw process inputs that drive your work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After youâ€™ve done this exercise, youâ€™ve likely explored a wide gamut of perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an age where everything is expected to be available in an instant, it becomes
    increasingly difficult to stress refactoring as a regular exercise. Itâ€™s very
    easy to solve a bug report as quickly as possible, do something sloppily, then
    move on to the next bug. Runners have the *runnerâ€™s high*, referring to a release
    of endorphins at some point during the run. Personally, I wouldnâ€™t know. I only
    run when chased. I think coders have a similar dependence on the dopamine released
    when we move an issue from *In Progress* to *Done*. Equally, if you have a project
    manager who reports up the chain of command, itâ€™s tempting to always present progress
    in terms of the number of issues worked through, rather than using actual quality
    metrics and tending to the health of your code base.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to conduct code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews are perhaps the most important practice for maintaining a healthy
    code base, which leads to happy developers. Youâ€™ll experience fewer shipped bugs,
    fewer outages, and higher retention rates at a time when organizations are engaged
    in stiff competition to retain their development talent. Code reviews are an easy
    and inexpensive way to invest in your individual contributors. The developers
    under review, often by a senior teammate, will learn better techniques and more
    patterns. The senior developers can help their junior counterparts identify areas
    where they might benefit from training, at the beginning of the course, by assigning
    them a good book on patterns. Hopefully, you presently find yourself in a position
    to recommend one.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of this book assumes very little about your level of experience in the
    field of software development. Following that principle, you may currently be
    wondering what a code review entails. A bad one is where someone glances at your
    code and after a minute or two says, â€œ*Meh. Looks good to me*.â€ They sign off
    on it and go back to what they were working on. Code reviews need to be scheduled
    as a meeting. If the code review is an interruption to someone elseâ€™s work, it
    will not yield results, and it will not be effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'When conducting a code review, there are two key areas to consider: overall
    design and functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is ultimately a book designed to help you improve your understanding and
    practice of software design. It stands to reason that Iâ€™d bring this up in a review.
    Some questions I invariably ask consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How does the new code fit into the overall architecture of the production code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the code follow SOLID principles, domain-driven design, behavior-driven
    design, or other paradigms followed by the team?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are formatting and style conventions being honored? Do the names of things follow
    the guidelines we established earlier? Do they make sense? Are they easy to read?
    Are they self-describing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the code readable per the first half of this chapter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What patterns are used and are they appropriate?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the code in the right place? We donâ€™t want lasagna!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the new code be reused in other places? This might necessitate moving it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could the new code replace something we already have? If your addition has 100
    lines of code that can replace 1,000, thatâ€™s a huge win!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can I take out of the current code now that we have this new addition?
    I consider it a big deal when I get to remove code. If only this could apply to
    the US tax code as well!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the code too clever? Clever code requires effort through the cognitive load
    required to understand it. Look for opportunities to make your code scannable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from being readable, is it rife with features that were not asked for
    or specified? Is it loaded with code for use cases that are very unlikely to ever
    be needed? This is called **You Ainâ€™t Gonna Need It** (**YAGNI**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the word â€œainâ€™tâ€ will likely anger my editors, my wife, my boss, my pastor,
    and my sixth-grade English teacher, but there it is. Deal with it, yâ€™all. Having
    reviewed the overall design, the review can shift to functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reviewâ€™s focus should entail making sure the code does what it is supposed
    to do. It should also ask questions about how we know the code is done beyond
    the warm feeling we got when we changed the issue status from *In Progress*:'
  prefs: []
  type: TYPE_NORMAL
- en: Can someone from another group who doesnâ€™t know the code look at this code and
    understand it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the automated unit and regression tests passing consistently? What? You
    donâ€™t have tests? You need tests!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there documentation for the new features? How will the end users know how
    to use these new features, or even know that theyâ€™re there?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are exceptions communicated well enough to give a full account of what went
    wrong to the technical team without blaming or unnecessarily confusing the user?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this new code introduce holes in your security?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does anything violate regulatory constraints for your industry?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you benchmark performance? Can we make anything faster?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there any risk involved with rolling this to production right now?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What have you not thought of?
  prefs: []
  type: TYPE_NORMAL
- en: This oneâ€™s tough. You canâ€™t do it by yourself. You need code reviews with another
    developer. While this is not an exhaustive checklist, these questions should get
    you moving in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about preparing you to transform the way that you work
    and the way you that think about creating software. Learning patterns is a big
    deal. They usually encourage big changes to the quality and maintainability of
    your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We started with some common metaphors that describe the typical devolution of
    software projects, namely spaghetti code and lasagna code. Spaghetti code is represented
    by a chaotic structure. Lasagna code is represented as a tiered structure with
    a leaky state and functionality between layers. Ravioli code represents the best
    code, as it uses the same ingredients as spaghetti and lasagna, but the contents
    of ravioli are fully encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced a few topics that usually fill entire books on their own. SOLID
    principles are the guiding star for most serious coding organizations, but I rarely
    see them taught. Beginner- and intermediate-level coders are usually so focused
    on languages and syntax that they donâ€™t develop the muscles needed to plan and
    execute an architecture.
  prefs: []
  type: TYPE_NORMAL
- en: If this is you, the five principles of SOLID design are an excellent starting
    point and should be understood before diving into patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We ended with a few pointers on performing code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready for an adventure. Youâ€™ve got all your prepper gear and youâ€™re
    ready for anything I might throw at you. In the next chapter, weâ€™ll begin learning
    about patterns, starting with creation patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Martin, R. C., & Martin, M. (2006.)Â *Agile principles, patterns, and practices
    in C#* (Robert C. Martin.) Prentice Hall PTR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Martin, R. C. (2009.)Â *Clean code: a handbook of agile software craftsmanship.*
    Pearson Education.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schubert, B (2013.) *DIP in the Wild [Blog post.]* Retrieved from [https://martinfowler.com/articles/dipInTheWild.xhtml#YouMeanDependencyInversionRight.](https://martinfowler.com/articles/dipInTheWild.xhtml#YouMeanDependencyInversionRight.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/part-2-getting-started.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Part 2: Patterns You Need in the Real World'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These chapters explain the most useful and popular patterns created by the Gang
    of Four. Weâ€™re strictly focused on the patterns that appear all the time in real-world
    projects â€“ patterns you should definitely know to advance your craft, and your
    career, to the next level. In each case, we will provide a generic UML diagram,
    followed by a real-world application. The generic pattern diagram will be re-drawn
    to fit the problem and we will then write the coded solution as instructed by
    our diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part covers the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18605_03.xhtml#_idTextAnchor063), *Getting Creative with Creational
    Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18605_04.xhtml#_idTextAnchor078), *Fortify Your Code with Structural
    Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18605_05.xhtml#_idTextAnchor089), *Wrangling Problem Code by
    Applying Behavioral Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
