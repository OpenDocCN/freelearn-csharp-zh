- en: Overview of ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some of the fundamental concepts of ASP.NET
    Core. .NET Core is cross-platform, but the IDEs and code editors that are used
    with it might vary depending on which OS they run on. To avoid repetition and
    cover all OS variants, I always use the CLI in the examples presented in this
    book. Furthermore, the `dotnet` instruction is the unique entry point and is also
    used, under the hood, by code editors and IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a .NET Core 3.1 and ASP.NET Core project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file structure of a .NET Core project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our .NET Core project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter assumes that you have already installed .NET Core version 3.1
    or higher on your machine. First of all, let''s start by launching the following
    command in our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26466f6e-c8ea-4210-8234-3187b3ea8d71.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of the *dotnet new* instruction
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows all the .NET Core project templates available on
    the local machine. Each of these has a user-friendly name, a short name, and tags.
    They are available in C#, F# **and** VB; the default is C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new template, we''ll use the short name. For example, in order
    to create a console application, we should run the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding instruction will create a new project in the current folder,
    with the following tree structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `HelloWorld.csproj` file contains all the meta-information about the project.
    The .NET Core version of the `.csproj` file is more lightweight compared to the
    `.csproj` file in previous versions of the .NET Framework. We'll discuss the new
    structure of this project file next in this chapter. The `Program.cs` file is
    the entry point of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and execute our project, we can run the following commands inside
    the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unlike old .NET Framework projects, the build and run steps are lightweight
    processes, and they don't require any additional tools or configurations. In fact,
    .NET Core is not strictly chained to the development machine like the .NET Framework.
    Eventually, developers can write code without any other IDEs or code editors.
    However, for obvious reasons, it is always recommended that you use them to simplify
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also essential to note that, once we execute the `dotnet build` command,
    the project files will change in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `bin/Debug/` folder contains all the app's DLLs. Below that, we can see
    the `netcoreapp3.1` folder, which refers to the current target framework. Therefore,
    if you build your project using a multi-target approach, you will find a folder
    for each target framework you specified. Now that we are able to run a simple
    console app, let's have a closer look at the *csproj* present in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of .csproj
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, in a plain console application template, there are
    two essential files: `ProjectName.csproj` and `Program.cs`. First of all, let''s
    have a look at the `.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The format of the `.csproj` file is XML, just like earlier versions of the .NET
    Framework. The
  prefs: []
  type: TYPE_NORMAL
- en: '`Sdk="Microsoft.NET.Sdk"` namespace refers to the SDK we want to use to build
    our project. The `PropertyGroup` node contains a set of properties, and it can
    be associated with some conditional behaviors. `ItemGroup` is a node that usually
    contains package references. In .NET Core, it is possible to specify the `TargetFramework`
    property to assign a target framework to our project. To set up our application
    as a *multi-target application,* therefore, we can change our `TargetFramework`
    node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the XML node has changed from `TargetFramework` to `TargetFrameworks`,
    furthermore our project will be built on both .NET Core 3.1 and .NET Standard
    2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the MSBuild documentation ( [https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2019)),
    it is possible to define different packages for each target framework. For example,
    in a double target framework project such as the previous one, we may define various
    dependencies for each target, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''ll have separate references for each target: at compile-time,
    the framework generates two target versions, the `netstandard2.0` generated output
    will refer the `Microsoft.AspNetCore.Server.Kestrel.Core` package. This is an
    unusual type of configuration, but it comes in handy if we have a high level of
    customization in our project or if your project is a library consumed by different
    versions of .NET. The `dotnet new` command also sets a specific `OutputType` property
    depending on the type of project you are creating: the `OutputType` property defines
    whether the project is executable (`Exe`) or a library (`Library`). The significant
    difference is that in the first case it can be executed, whereas in the latter
    it does not contain any entry points from which to run the application. Therefore,
    we will not be able to execute the `dotnet run` command on a `<OutputType>Library</OutputType>`
    project type, on the other side, we do need to specify `static void Main` entry
    point method in case of a `<OutputType>Exe</OutputType>` project . Let''s continue
    by discussing a bit the domain of the executable projects by walking through the
    *Program.cs* file of a standard console template.'
  prefs: []
  type: TYPE_NORMAL
- en: The Program.cs file in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Program.cs` file is the main entry point of the application. It sets up
    and runs all the components we need. By default, the console application template
    executes a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is a plain .NET Core application that runs `Console.WriteLine`
    to print a message in the console. In an ASP.NET Core application, the `Program.cs`
    file is usually utilized to initialize and run the web host.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# version 7.1 introduced the `async void Main` method. This feature is implemented
    to avoid workarounds involved in running asynchronous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In summary, the `Program.cs` file is the main execution root for applications
    built on .NET Core 3.1\. It usually runs a set of statements in order to startup
    our application. In general, we should keep `Program.cs` as clean as possible
    to boost the reusability of our classes. In the next section, we will see how
    it is also possible to combine the `csproj` structure and the `Program.cs` file
    in order to build a simple API project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an ASP.NET Core project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml), *REST
    101 and Getting Started with ASP.NET Core*, the MVC pattern is all about separating
    concerns. It aims to give developers some guidelines to ensure that the different
    components of the web application are not mixed up. The following is a refresher
    on the MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The Modelseeks to define the domain model of our application. It should also
    be noted that models don't contain any references to our data sources and databases.
    They describe the entities in our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Views partpresents the data in the form of HTML pages. In web services,
    views are not included because the model is serialized in JSON, HTML, or other
    similar formats. The critical point is that views should not contain logic. They
    are hard to test and hard to maintain. Over the past few years, views have become
    increasingly more powerful. The Razor engine, the default view rendering engine
    provided by ASP.NET Core, has recently made several new features available. It
    is easy for developers to implement logic in views, but this should be avoided
    at all costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controllers part of MVC handles requests from users. They take information
    from the request and update the model. In real business applications, controllers
    are usually supported by service or repository classes, which add another level
    to the domain model layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a detailed look at the default ASP.NET Core web API project template.
    The project uses the model and controller parts of the MVC pattern to serve a
    simple HTTP response with the content serialized in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a new project using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of the preceding command creates the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of the `dotnet new webapi` command creates a new project file
    called `SampleAPI` inside a folder with the same name. The following is the resulting
    `SampleAPI.csproj` generated by the `dotnet new webapi` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is that this project uses the `Microsoft.NET.Sdk.Web`
    SDK, which refers to the web application SDK. Furthermore, the .NET Core framework
    provides different SDKs depending on the purpose of the project we are about to
    create. For example, in the case of a desktop application, the project will specify
    another SDK: `Microsoft.NET.Sdk.WindowsDesktop`. Choosing between different SDKs
    guarantees developers an excellent level of modularity. Secondly, the project
    file does not specify any particular dependency except the `netcoreapp` target
    framework used by the application.'
  prefs: []
  type: TYPE_NORMAL
- en: The project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All ASP.NET Core web templates have a similar structure. The main difference
    lies in the `views` folder, which is not present in web API projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, let''s have a more detailed look at the resulting content
    of the `SampleAPI` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Program.cs` is the main entry point of the application, and it runs the default
    web server used by APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Startup.cs`defines and configures our application pipeline and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Controllers` foldercontains all the controllers for our application. According
    to the default naming convention, ASP.NET Core searches in this folder for the
    controllers of our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Properties/launchSettings.json` file represents the settings for our project.
    This file is created when you try to change any of your project''s properties,
    and it usually stores the application URL for our services or apps. Furthermore,
    if we have a quick look at the content of the file we can notice two different
    profiles: one with the name of the project created, and another one with the `IISExpress`
    name. Every project can have multiple profiles associated with it. they can be
    used to specify some of the launch settings, and the environment variables used
    by the application. Therefore, it is possible to run the application using the
    `dotnet run` command by specifying a profile using the `--launch-profile` flag;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appsettings.json` and `appsettings.{Environment}.json`contains the settings
    based on our environment. They are replacements for the settings section in the
    `web.config` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Program.cs and Startup.cs files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue by examining the `Program.cs` file of a web API project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code imports the `Microsoft.AspNetCore.Hosting` and `Microsoft.Extensions.Hosting`
    namespaces. They supply the necessary references for the initialization of a new
    `IHostBuilder` instance created in the `CreateHostBuilder` function. The `CreateHostBuilder`
    function executes the `Host.CreateDefaultBuilder` method, which initializes the
    web host of our APIs. Furthermore, we should note that the `IHostBuilder` instance
    returned by the `CreateDefaultBuilder` method refers to the `Startup` class of
    the project. The `Main` method invokes the `CreateHostBuilder` function and executes
    the `Build` and `Run` methods exposed by the `IHostBuilder` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `Startup` class (defined in the `Startup.cs` file), which
    is used to configure the application stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Startup` class initializes the `IConfiguration` attribute through dependency
    injection. The `IConfiguration` object represents a key/value object which contains
    configurations for the app. By default, the `CreateDefaultBuilder` method declared
    in the `Program.cs` file sets `appsettings.json` as the default configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Startup` class has two different methods, which behave in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ConfigureServices`method configures services in our application using dependency
    injection. By default, it adds controllers by executing the `.AddControllers`
    extension method. In ASP.NET Core, the term services usually refer to any component
    or class that provides our application with features and functionalities. As we'll
    see in the next few chapters, ASP.NET Core frequently uses dependency injectionto
    maintain a good design and loosely-coupled classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Configure` method is used to configure the application''s middleware pipeline.
    It accepts two arguments: `IApplicationBuilder` and `IWebHostEnvironment`. The
    first contains all the pipelines for our app and exposes extension methods to
    build our app with middleware. We''ll have a look at middleware in detail in [Chapter
    3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml), *Working with the Middleware Pipeline*.
    The `IWebHostEvironment` interface gives some information about the current hosting
    environment of the application, such as its type and its name. In a web API project,
    the `Configure` method executes a list of extensions methods. The most important
    are the `UseRouting` and `UseEndpoints` extension methods. The execution of the
    `UseRouting` method defines the point in the pipeline where routing decisions
    are taken. The `UseEndpoints` extension method defines the actual execution of
    the previously selected endpoint. In the case of a web API project, the only endpoints
    involved are the controllers. Therefore, the `UseEndpoints` method executes the
    `MapControllers` extension method to initialize the default routing convention
    for controller classes, provided in .NET Core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that the ASP.NET Core `Startup` class provides a high-level,
    code-first way to configure the dependencies of your application through dependency
    injection, which means that it only initializes what you need. Furthermore, .NET
    Core is strongly modularity-oriented; this is one of the reasons why it performs
    better than the .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Since all pipelines and dependencies are initialized in the aforementioned class,
    you know exactly where they can be changed. In large applications and services
    with a lot of different components, it is advisable to create custom extension
    methods that handle the initialization of specific parts of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controllers are a fundamental part of the web API in ASP.NET Core projects.
    They handle incoming requests and act as the entry point of our application. We''ll
    look at controllers in more detail in [Chapter 4](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml),
    *Dependency Injection*, but for now, let''s examine the default `WeatherForecastController`
    provided by the web API template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`WeatherForecastController` comes with basic methods. By default, it doesn''t
    use any data source; it simply returns some mock values. Let''s proceed by having
    a look at the main elements of the `WeatherForecastController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ApiController` attribute indicates that the controller and all extended
    controllers serve HTTP API responses. It was introduced in ASP.NET Core version
    2.1, and it is usually combined with the `ControllerBase` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Route("api/[controller]")` attribute defines the route for our controller.
    For example, in this case the controller will respond to the following URI: `https://myhostname:myport/api/weatherforecast`.
    The `[controller]` placeholder is used to indicate the name of the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ControllerBase` class is usually combined with the `ApiController` attribute,
    and it is defined in the `Microsoft.AspNetCore.Mvc` namespace. The `ControllerBase`
    class indicates a controller without support for the views part. It provides a
    few base methods, such as `Created`, `CreatedAtAction`*,* and `NotFound`*.* It
    also provides some properties, for example, `HttpContext`, which contains the
    requests and responses of our web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpGet` attribute is part of the `Microsoft.AspNetCore.Mvc` namespace.
    It identifies the type of HTTP method accepted by the action. It also accepts
    an additional parameter, such as `[HttpGet("{id}")]`, which defines the route
    template of the action. ASP.NET Core exposes an HTTP attribute for each HTTP verb,
    such as `HttpPost`*,* `HttpPut`*,* or`HttpDelete`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we can take a brief look at the implementation of the `WeatherForecastController()`
    constructor method and the `Get()` method. The first initializes all dependencies
    of the controller class, and it is the dependency injection entry point for our
    class; all dependencies relating to the controllers are solved in the constructor.
    The `Get()` method implements the logic and returns a collection of elements that
    will be serialized and then passed to the HTTP response of the web API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced some central concepts in *.*NET Core. We walked
    through the console application and web API templates as well as the ASP.NET Core
    web API structure*,* and the structure of a controller class.
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered in this chapter provide the skills necessary to start with
    a console application project on .NET Core, and they also provides basic knowledge
    regarding the arrangement of an ASP.NET Core project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a core concept of ASP.NET Core, middleware,
    and how it can be used to intercept requests and enhance our application stack.
  prefs: []
  type: TYPE_NORMAL
