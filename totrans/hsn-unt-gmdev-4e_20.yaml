- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next-Gen UI: Creating Dynamic Interfaces with UI Toolkit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to create user interfaces using **uGUI**
    (also known as **Canvas**), one of the most common Unity UI systems, but as we
    already mentioned, this is not the only one. While, so far, uGUI has been the
    most preferred option, Unity is working on a replacement called **UI Toolkit**,
    and even if it doesn’t have feature parity with uGUI yet, we thought it is worth
    covering it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of this chapter is to create the same UI we created previously but
    with UI Toolkit, so you can get an idea of how creating a UI in Unity will look
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following UI concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Why learn how to use UI Toolkit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a UI with UI Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a responsive UI with UI Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will learn how to use UI Toolkit to create basic
    UIs for our game, redoing the UI we did in the last chapter as a point of reference.
    So, let’s start by answering the following question first: why learn how to use
    UI Toolkit?'
  prefs: []
  type: TYPE_NORMAL
- en: Why learn how to use UI Toolkit?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know the topic of this chapter might sound a little bit confusing; we just
    learned how to use a whole Unity system to create our UI, and now we are learning
    how to use another one! Why do we have to learn about this new one?
  prefs: []
  type: TYPE_NORMAL
- en: One reason for learning both systems is that UI Toolkit, while promising, doesn’t
    yet match uGUI in feature completeness, which is crucial for real-world production.
    Another thing to take into account is that even if UI Toolkit is stable enough,
    it’s still a relatively new system, and there are still lots of games in development
    that were created on older Unity versions that don’t support it. This means that
    in order to land a job in this industry, we need to get a decent amount of exposure
    to uGUI, due to most games being created with this technology.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because it’s not safe or practical to update an already-tested
    and working game with new technologies; such changes could lead to a major rework
    of the game to make it compatible with the new versions. Also, this could potentially
    introduce tons of bugs that could delay the release of new versions—not to mention
    the time it would take to remake a full app with a new system.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, we believe it’s still worth learning the basic concepts of
    UI Toolkit to be prepared to use it in newer Unity versions, so let’s dive into
    it now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI with UI Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to learn about UI documents, a cornerstone of
    UI Toolkit. These assets are crucial for defining your UI’s structure and components,
    and we’ll learn how to create and utilize them effectively. To do this, we are
    going to discuss the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing UI Documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UI Stylesheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by seeing how we can create our first UI Document.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a UI with uGUI, we need to create GameObjects and attach components
    like **Button**, **Image**, or **Text**, but with UI Toolkit, we need to create
    a **UI Document** instead. A UI Document is a special kind of asset that will
    contain the definition of the elements our UI will have and its hierarchy. We
    will have a GameObject with a **UI Document** component (yes, it’s called the
    same, so pay attention here) that will reference this **UI Document** asset and
    render its contents. It’s like a mesh asset that contains information about the
    mesh and the `MeshRenderer` component that will render it. In this case, the elements
    to render are contained in an asset, and we have a component that reads the asset
    and renders its content (the UI in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, UI Documents are plain text files at their core. This means
    you can open and inspect them with any standard text editor, offering a straightforward
    way to understand their structure. If you do that and you are familiar with HTML,
    you will recognize the XML-like format used to define the elements our UI will
    be composed of; Unity calls this format UXML. With UI Toolkit, Unity is attempting
    to make it easy for web developers to jump into Unity and create UIs. In the following
    code, you can see the typical look of a UXML document’s file contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if you don’t know XML; we will explain the core concepts in this
    chapter. Also, don’t worry about the UXML format; later in this chapter, we will
    use a visual editor called **UI Builder** to edit our UI without writing UXML
    at all, but it is worth knowing how it actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a UI Document and add it to the scene, we need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **+** | **UI Toolkit** | **UI Document** option in the **Project**
    view to create a **UI Document** asset, and name it `GameHUD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_01_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Creating the UI Document asset'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Game Object** | **UI Toolkit** | **UI Document** option to create
    a GameObject in your scene with the **UI Document** component, which is capable
    of rendering the UI Document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select it, and drag the **GameHUD** **UI Document** asset (the one created
    in *Step 1*) to the **Source Asset** property of the **UI Document** GameObject
    (the one created in *Step 2*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Making the UI Document component to render our UI Document asset'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! Of course, we won’t see anything yet on our screen as the UI
    Document is blank, so let’s start adding elements to it.
  prefs: []
  type: TYPE_NORMAL
- en: Editing UI Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our goal is to recreate the same UI we created in the last chapter, let’s
    start with the simplest part: adding the player avatar to the top-left corner.
    One option would be to open the **UI Document** asset with any text editor and
    start writing the UXML code, but luckily, we have an easier way, which is using
    the **UI Builder** editor. This editor allows us to generate the UXML code visually
    by dragging and dropping elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump in, let’s take a quick tour of the UI **Builder** window to
    see what we’re working with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the **GameHUD** asset in the **Project** view to make **UI Builder**
    open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: The UI Builder editor'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel inside UI Builder (*not* the **Hierarchy** panel
    we’ve used so far in previous chapters), select `GameHUD.uxml`, which is the container
    element of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_04_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Selecting the asset name in Hierarchy to edit the general UI settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the **Inspector** panel at the right of the UI Builder window (*not*
    the **Inspector** we’ve used so far to modify GameObjects). Set the **Size** property
    to a **Width** of `1920` and a **Height** of `1080`. This will allow us to view
    how our UI will look in this resolution. You can later change this value to see
    how it adapts to different sizes, but more on that later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_05_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Setting the preview UI resolution'
  prefs: []
  type: TYPE_NORMAL
- en: You can pan the viewport to navigate the UI by pressing the *mouse wheel button*
    (also known as the *middle button*) and moving the mouse. On a Mac, you can also
    press *Option* *+* *Command* and click and drag any free area of the viewport
    (places without our UI) to do the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also use the *mouse scroll wheel* to zoom in and out. Finally, you
    can use the zoom percentage selection at the top-left part of the viewport and
    the **Fit Canvas** button to automatically fit the entire UI in your viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_06_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Setting the preview zoom'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the basics of UI Builder, let’s add our image to the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the **VisualElement** icon from **Library** at the bottom left to the
    **Hierarchy** section on the left. This will create a basic UI element capable
    of rendering an image and much more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_07_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Creating a visual element'
  prefs: []
  type: TYPE_NORMAL
- en: Select **VisualElement** in **Hierarchy** (under `GameHUD.uxml`) and look at
    the **Inspector** at the right part of the UI Builder window (again, not the regular
    Unity **Inspector** panel) in the **Position** section. Expand it if not already
    expanded (using the arrow on the left).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Position** to **Absolute** in order to allow us to move our element freely
    around the UI. Later in this chapter, in the *Using relative positions* section,
    we will explain how the **Relative** mode works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_16_08_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Setting our UI element to be freely moved around'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Size** section, and set **Width** and **Height** to `100` to make
    our UI element have a non-zero size. This way, we can see its area in the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_09_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Setting our UI element size'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Viewport** pane, you can drag your element around and use the blue
    rectangles in the corners to change its size. Position your element at the top-left
    corner of the UI. If you don’t see your element in the viewport, select it in
    **Hierarchy** (the one for UI Builder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Moving VisualElement'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set an exact position, you can set the **Left** and **Top** values
    of the **Position** section in the **Inspector** to specify the exact *x* and
    *y* coordinates, respectively, expressed in pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Setting the position'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Background** section of the **Inspector**, set the **Image** mode to
    **Sprite** using the combo box at the right of the **Image** property. This allows
    us to apply a sprite as the background of our element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the sprite asset (the image) of our player avatar we imported in *Chapter
    15*, *Interface Brilliance: Designing a User-Friendly UI*, from the **Project**
    panel to the **Image** property in order to set it. Also, you can use the target
    button (the circle button with the dot in the middle) to select the sprite asset
    from the picker window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_12_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Setting the Background image of the element'
  prefs: []
  type: TYPE_NORMAL
- en: Return to the regular **Game** panel to see the results. If you don’t see a
    change, you can turn off and on the GameObject that renders our UI (the one we
    created with the UI Document).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created the player avatar, we can create the player health
    bar by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the previous *steps* *1* to *6* to create a new element that will serve
    as the player health bar container. It won’t have an image, as it will just be
    the container for the rest of the elements that will compose the health bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it right next to the player avatar, and set a width and height to resemble
    a classic health bar. Remember that you can do this by dragging the image and
    the squares at the corners or through the **Size** and **Position** properties
    as we did before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a new VisualElement to the Hierarchy, as we did in *step 1*, but this
    time, drop it over the element created in *step 1*. This will make this new element
    a child of it, which will make that element’s position and size depend on its
    parent, the same as what happened when we parented Canvas objects in *Chapter
    15*, *Interface Brilliance: Designing a User-Friendly UI*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the parent VisualElement, and in the **Inspector**, set the **Name**
    property to `PlayerHealth` to easily identify it. Do the same with the child element,
    calling it `Filling`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, font, screenshot, white  Description automatically
    generated](img/B21361_16_13_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: Parenting and naming visual elements'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Filling** element in the **Hierarchy** and look at the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Background** section, set the **Color** property to red, clicking
    on the color box and using the **Color Picker**. This will fill our UI element
    background with plain red instead of using an image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21361_16_14_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.14: Setting a pure red background for our element'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, set **Position** to **Absolute**, and also the **Left** and **Top**
    properties to `0`. As this is a child of another element, the position will be
    relative to its parent position, so by specifying a **Left** and **Top** value
    of `0`, we are saying that we will be at 0 pixels from the left and top sides
    of our parent. This means that if our parent moves, this child element will move
    along with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Size** **Width** and **Height** to `100`, and change the unit of
    measurement from **px** (pixels) to **%** (percentage) by clicking on the **px**
    button and selecting **%**. This will make the **Filling** element size the same
    as its parent (100 percent of the parent size):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_15_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.15: Setting our size as the same size as our parent element'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new **VisualElement** as a child of **PlayerHealth** (a sibling of **Filling**)
    and call it `Border`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Position** and **Size** as we did in *steps* *7* and *8* for the **Filling**
    element, but don’t set the background color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Background** section’s **Image** property to be the same border image
    we used in the previous chapter. Remember to set the **Image** mode to **Sprite**
    instead of **Texture**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Slice** property in the **Background** section to `15`. This applies
    the nine-slices technique we used in *Chapter 15*, *Interface Brilliance: Designing
    a User-Friendly UI*, to expand an object without stretching it. In this case,
    we are giving the slice a size of 15 pixels from the outer borders of the UI element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_16_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.16: Setting the nine-slice sizes in the element directly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Filling** visual element in the **Hierarchy** and set its **Size**
    section’s **Width** property to simulate the **Fill Amount** property of the images
    we used in *Chapter 11*, *Captivating Visual Effects: Harnessing Particle Systems
    and VFX Graph*. Later, we will change the size to be directly proportional to
    the player’s health number via code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, design  Description automatically generated](img/B21361_16_17_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.17: Health bar result'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *steps* *1* to *12* to create the bottom of the **Base Health** bar.
    Remember that the filling must be green this time. Alternatively, you can just
    copy and paste the **PlayerHealth** container, but I recommend you repeat the
    steps for learning purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In previous steps, we basically saw how to compose several UI elements to create
    a complex object. We needed a parent container element to drive the size of our
    children so that the inner elements adapt to it, especially the filling, which
    requires a percentage value to represent the current player’s health.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have our life bar! Well, not quite yet; those red corners from the filling
    that our border doesn’t cover are pretty rough! We will improve that later in
    this chapter when discussing how to make our UI responsive, so for now, let’s
    keep it as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s add text elements to the UI. But first, we will need to think
    about fonts. If you download a TTF font, you will need to create a font asset,
    as we did in *Chapter 15*, *Interface Brilliance: Designing a User-Friendly UI*,
    for it to be used in UI Toolkit. However, with the current release of UI Toolkit,
    the font asset we created in the last chapter is not compatible.'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to create a font asset using the UI Toolkit Font Asset Creator
    instead of the TextMesh Pro one. The reason behind the existence of duplicated
    tools is that Unity is integrating the Text Mesh Pro package into a new, improved
    one called TextCore, one of those improvements being compatibility with UI Toolkit
    and other Unity systems.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this, in order to convert the TTF to a font asset compatible with
    UI Toolkit, you can just right-click the TTF asset in the **Project** panel and
    select **Create** | **Text** | **Font Asset**. This will create a new asset that
    will be the one we will use to define the font of our UI Toolkit text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having solved this, let’s create the UI element for text, that is, **Label**:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Label** icon from the **Library** pane of the UI Builder window to
    its **Hierarchy** panel. This will add a UI element capable of rendering not only
    an image in its background but also text (yes, you can add a background to the
    text if you want to).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, set its **Position** and **Size**, this time putting it in the top-right
    corner of the screen. Remember, you can simply drag the element; you don’t need
    to set the specific coordinates by hand (although you can if you want to).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the **Text** property in the **Label** section of the **Inspector**
    to the needed text; in our case, this will be `Score: 0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.18: Setting the text to display'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Font** asset created just before these steps to the **Font Asset**
    property in the **Text** section of the **Inspector**. Don’t confuse it with the
    **Font** property (the one above **Font Asset**). That one allows you to drag
    TTF assets directly, but that will be deprecated soon, so let’s stick with the
    Unity-recommended approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you notice that your **Font** asset doesn’t work, try putting it in the **UI
    Toolkit** | **Resources** | **Fonts & Materials** folder in the **Project** panel.
    While this shouldn’t be necessary in the latest Unity versions, I’ve noticed that
    this has solved these sorts of issues in the past. Also, there’s a bug that makes
    the font not recognized sometimes, which can be fixed by deleting and recreating
    the **Label**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Size** property of the **Text** section to any size that seems appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.19: Setting the Text Font and Size of a label'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *steps* *1* to *6* to add all the remaining **labels** to the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last thing we need to do is save, which can be simply done by pressing *Ctrl*
    *+* *S* (*Command* *+* *S* on a Mac) or using the **File** | **Save** menu in
    the top-left part of the **Viewport** section in the **UI Builder** window. Note
    that previous versions of UI Toolkit had a bug where this could make the viewport
    corrupt. Please close it and reopen UI Builder again if this happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have created our UI, you probably noticed the need to repeat several
    settings to make several objects look the same, like our health bars and labels.
    While this is perfectly viable, we could improve our workflow greatly by reusing
    styles, and **Stylesheets** are the exact feature we need to accomplish that,
    so let’s see them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Stylesheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you’re designing various game elements, like buttons and menus, that
    all share a common look – the same background, font, size, and borders. This is
    a common scenario in UI design, where consistency is key. When creating the UI
    with uGUI, one way to avoid repeat configurations for each element would be to
    create a Prefab for the button and create instances (and Prefab variants where
    necessary). Unlike uGUI, UI Toolkit doesn’t use GameObjects, so we can’t rely
    on Prefabs for styling. But no worries, we have a powerful alternative: **Stylesheets**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stylesheets** are separate assets that contain a series of styling presets
    for our UI elements. We can define a set of styles (for example, background, borders,
    font, size, etc.) and apply those to several elements across different UI elements.
    This way, if we change a style in a Stylesheet asset, all UI elements using that
    style will change in a similar way to how materials work.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to create styles in a Stylesheet. The selector system
    in Stylesheets works a bit like filters – you set rules to decide which UI elements
    get certain styles, much like CSS in web design. A class is basically a style
    we can apply to any element via its name. For example, we can create a class called
    `Button` and add that class to every button in the UI that we want to have that
    style. Please note that, here, the concept of class doesn’t refer to a programming
    class. A class is a way to label UI elements that must have specific styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'For advanced tips on USS, please check out this link: [https://docs.unity3d.com/2023.1/Documentation/Manual/UIE-USS.html](https://docs.unity3d.com/2023.1/Documentation/Manual/UIE-USS.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this case, let’s create a class for all the labels in our UI so that
    the appearance of all of them can be modified by simply changing the style:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **StyleSheets** panel of **UI Builder**, click Add (**+**) button and
    click **Create New USS** (Unity StyleSheet). If that doesn’t work, try restarting
    Unity; there’s a bug in the current version of UI Toolkit that could cause this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_20_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.20: Creating a Unity StyleSheet'
  prefs: []
  type: TYPE_NORMAL
- en: Name the USS as you like (`GameUSS` in my case) and save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one of the label elements we have in our UI Document and look at the
    **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **StyleSheet** pane of the **Inspector**, type `HUDText` in the **Style
    Class List** input field, but don’t press *Enter* yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Extract Inlined Styles to New Class** button. This will take all
    the style modifications we applied to our label (position, size, font, etc.) and
    save them into a new style class called `HUDText`. You can observe that it was
    added to the list of classes applied to the element (those labels at the bottom
    of the **StyleSheet** section in the **Inspector**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_16_21_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.21: Extracting settings into a style class'
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, we have taken a label with the style we need to apply to others
    and extracted it into a class named **HUDText**. This way, we can simply add the
    **HUDText** class to other elements in our UI, and we can even add the same USS
    asset to other UI Documents (click the **+** button on the **StyleSheets** pane
    | **Add Existing USS**) to add this class to the elements in it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you select the label again, you will notice how properties that previously
    were in bold have now become normal again; that’s because properties in bold represent
    changed properties, and we have extracted them, so the default values became whatever
    the style classes define. Luckily, not everything is extracted to the new USS
    class; for example, the **Text** field still has our specific desired text, as
    it is highly unlikely you would want to put the same text in other objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_16_22_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.22: The Text property is bold, indicating it is different from the
    default values. On the other hand, Enable Rich Text is not bold, meaning it follows
    the default values and the class’s ones'
  prefs: []
  type: TYPE_NORMAL
- en: If you miss a style detail while extracting the class, don’t worry. You can
    easily adjust it afterward by selecting the class in the **StyleSheets** section
    and making your edits. Then, select the **HUDText** class in the list. If you
    don’t see it, try expanding the **GameUSS.uss** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once selected, you can change it in the **Inspector** panel, similar to when
    we change the properties of a UI element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_16_23_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.23: Selecting a style class for modification'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we have edited our `HUDText` class. If other elements had this class
    applied, they would also have these changes applied. Consider that another option
    would be to create the class first, typing the name in the **StyleSheets** input
    field, pressing *Enter*, and then applying it to UI elements. This way, you will
    avoid needing to revert to unwanted changes, but if you created the element first,
    it’s convenient to have the option to revert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_24_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.24: Creating a style class from scratch'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our style class, let’s apply it to other elements by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select another label of our UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the **HUDText** style from the **Stylesheet** pane at the top-left part
    of the UI Builder window all the way to our element in the viewport. You can also
    drag it to the **Hierarchy** element if you prefer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screen shot of a computer  Description automatically generated with medium
    confidence](img/B21361_16_25_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.25: Applying a class to an element'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Label**, and check how the **HUDText** class has been added to
    the **StyleSheet** section of the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, note that even if the element now has the class applied, the element itself
    has the changes to the text we made in the previous steps, overriding the style
    in our class. You can easily check this by selecting the class again (in the **StyleSheets**
    section at the top-left part of the **UI Builder** window), changing any setting,
    like the size, and seeing how not all the elements have changed. This shows how
    the override system works; the changes on the element take precedence over the
    ones in the classes it has applied.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to remove these overrides, you can simply select the element (not
    the class), right-click on the overridden properties, and unset the changes by
    right-clicking and then selecting **Unset**. In the case of our label, we can
    unset the entire **Text** section and probably the **Absolute** position (as the
    desired values are already contained in the class).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_16_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.26: Reverting an override to use the default values of the classes
    applied to the element'
  prefs: []
  type: TYPE_NORMAL
- en: So, with these steps, we created a new **StyleSheet** asset and added it to
    the UI Document for it to use. We have created a new style class in it, extracting
    the changes of an existing UI element from it, and then adjusted which changes
    we wanted to keep. Finally, we applied that style to another element. With this,
    we just scratched the surface of the real power of StyleSheets. We can start doing
    things like combining different classes from different StyleSheets or using selectors
    to dynamically set styles, but that’s outside the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While UI Toolkit’s documentation is still evolving, you can get a jump start
    on these advanced concepts by delving into CSS literature. The fundamentals and
    best practices of CSS offer valuable insights applicable to UI Toolkit. It won’t
    be exactly the same, but the basic idea and best practices still apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the UI looks almost exactly the same as it does in *Chapter 15*, *Interface
    Brilliance: Designing a User-Friendly UI*, but it won’t behave in the same way.
    If you try changing the size of the viewport (by selecting **GameHUD.uxml** in
    the Hierarchy and changing **Width** and **Height** as we did at the beginning
    of the chapter), you will see that the UI won’t adapt properly, so let’s fix this.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a responsive UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to learn how to make the UI we created previously
    adapt to different screen sizes. We are going to discuss the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic positioning and sizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using relative positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing how we can make the position and size of our objects
    adapt to the screen size.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic positioning and sizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have used the **Left** and **Top** position attributes in order to
    specify the *x* and *y* positions of our elements, with respect to the top-left
    corner of the screen, and then **Width** and **Height** to define the size. While,
    essentially, that’s all that’s needed to define an object’s position and size,
    it is not very useful in all cases, especially when we need to adapt to different
    screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you need to place an object in the top-right corner of the screen,
    knowing its size is `100x100` pixels and the screen size is `1920x1080` pixels,
    we can put the **Left** and **Right** position attributes as `1820x980` pixels,
    and this will work, but only for that specific resolution.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens if the user runs the game at `1280x720` pixels? The object
    will be outside the screen. In uGUI, we used anchors to solve this issue, but
    we don’t have them here. Luckily, we have **Right** and **Bottom** to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the **Left** and **Top** attributes, **Right** and **Bottom** define distances
    from the parent element’s sides (if there is no parent, then just from the entire
    screen). Right now, we have both set to **auto**, meaning that the position will
    be driven by **Left** and **Right** exclusively, but interesting things can happen
    by changing those values, so let’s use them to make our **Score** and **Bullet**
    labels stick to the top-right corner of the screen instead by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the cursor in the bottom part of the UI in the viewport until a white bar
    appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag that bar to resize the screen, and see how our UI adapts (or not) to the
    different size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same on the laterals to also see how it adapts to different screen widths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.27: UI not adapting to different screen sizes'
  prefs: []
  type: TYPE_NORMAL
- en: Select the score label on the viewport and look at the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Top** and **Right** values in the **Position** section to `30`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Left** and **Bottom** values to **auto** by clicking the **px** button
    at the right of each attribute and selecting **auto**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.28: Changing the unit type of the Position attributes to auto mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the **Right** and **Top** golden-colored squares at the sides of the
    label became filled, while the **Left** and **Bottom** squares are hollow. This
    means that the **Left** and **Bottom** squares are in **auto** mode. You can also
    toggle **auto** mode by clicking those boxes if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.29: Toggling auto mode of our element position attributes'
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the size of the UI container again, as we did in *steps* *1* and
    *2*, to see how our **Score** label is always aligned to the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps* *4* to *6* for the **Bullets** label, this time setting the **Top**
    property to `140`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did with these steps was essentially make the position of the object
    expressed as a distance in pixels against the **Top** and **Right** sides of the
    UI or the top-right corner of the screen. We needed to set the other sides to
    **auto** mode so that they wouldn’t participate in the position calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use the **Position** attributes in other ways as well. As you might
    imagine by now, we can start combining **Left** and **Right** and **Top** and
    **Bottom** if we wish. In such cases, **Left** and **Top** will take precedence
    in defining the position, but then, what do **Right** and **Bottom** do? They
    define the size of the element.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have an element with **Left** and **Right** attributes set
    to `100px` each and we see our UI on a screen with a width of `1920` pixels, the
    final width of our element will be `1720` (`1920` minus `100` from **Left** and
    minus `100` from **Right**). This way, the **Position** attributes represent the
    distances of the sides of our element from the sides of the screen (or the parent
    element).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action by making the bottom health bar adapt to the screen
    width while preserving its position relative to the bottom of the screen by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the bottom health bar parent in the **Hierarchy**. Don’t select it in
    the viewport, as you will only be selecting its filling or border.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Left**, **Right**, and **Bottom** to `50px`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Top** to **auto** (click on the **px** button at the right and select
    **auto**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Size** section, set **Width** to **auto** also.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Height** to `35px`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.30: Making the player’s base health bar adapt to the screen width'
  prefs: []
  type: TYPE_NORMAL
- en: Change the size of the UI to see how it adapts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these steps, we defined the bar distance from the sides of the screen as
    `50` pixels for it to adapt to any screen width while keeping the distance from
    the border and height fixed. We basically achieved the same behavior as split
    anchors in uGUI! Note that we needed to set **Size** **Width** attributes to **auto**
    to let the **Left** and **Right** attributes drive the position; if you don’t
    do that, the **Width** attributes take precedence, and **Right** won’t have any
    effect. I invite you to experiment with other combinations of **px**/**auto**.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last trick we can do here is to use negative values in the **Left**, **Top**,
    **Right**, and **Bottom** **Position** attributes of the health bar borders to
    make the borders slightly bigger than the container and cover the filling borders.
    Just set **Left**, **Top**, **Right**, and **Bottom** to `-15px` in this case,
    and remember to set both the **Size** **Width** and **Height** attributes to **auto**.
    You might want to reduce the height of the bar container (not the border) a little
    bit, as now it will look thicker due to this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_16_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.31: Using negative Position attributes to cover the filling'
  prefs: []
  type: TYPE_NORMAL
- en: Another mode aside from **px** (pixels) or **auto** mode is the percentual (**%**)
    mode, which allows us to represent values as percentages relative to the screen
    (or parent element if present) size. For example, if we set **Top** and **Bottom**
    to `25%`, this means that our element will be vertically centered with a size
    of 50% of the screen height (remember to set **Height** to **auto** here). We
    could achieve the same result if we set **Top** to `25%`, **Bottom** to **Auto**,
    and **Height** to `50%`; as you can see, we can achieve a clever combination of
    those values.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will use percentual values in our **Life Bar** fillings so that
    we can express their size in percentages. We need this so, later in the code,
    we can specify the width of the bar as a percentage of the player’s life (for
    example, a player with `25` life points and a max of `100` points has `25%` life).
  prefs: []
  type: TYPE_NORMAL
- en: Now, while we solved adapting positioning to the screen size with the usage
    of the **Left**, **Top**, **Right**, and **Bottom** properties, we still didn’t
    solve the dynamic sizing of the elements. With sizing this time, we refer to screens
    with a different number of **DPI** (**dots per inch**), so let’s discuss how we
    can achieve that with the **Panel Settings** asset.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used `1920x1080` as the UI base resolution to position and size our elements
    so that they look nice in that resolution. While resizing the UI helped us understand
    how elements adapt their position, you might have observed a notable change in
    the size of the elements, appearing larger or smaller. This is an important aspect
    to consider in dynamic UI scaling.
  prefs: []
  type: TYPE_NORMAL
- en: While having a base reference resolution is good for designing our UI, we should
    consider the sizing of elements on different resolutions, especially on screens
    with high DPI. Sometimes, you can have screens with higher resolution but the
    same physical size in centimeters.
  prefs: []
  type: TYPE_NORMAL
- en: This means pixels are smaller in the ones with higher resolution; hence, they
    have a larger DPI, so elements can seem smaller if not scaled properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling in UI design ensures that your interface looks great on any screen
    size. Previously, in traditional Unity UI, we relied on the Canvas Scaler for
    this. Now, in UI Toolkit, we use a similar approach but through the **Panel Settings**
    asset. Let’s see how this is configured to maintain consistent UI elements across
    different resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for the **Panel Settings** asset in the **Project** panel and select it.
    Another option would be to select the `UI Document` GameObject in the Main Editor
    Hierarchy and click the asset referenced in the **Panel Settings** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_32_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.32: Panel Settings being referenced in the UI Document component'
  prefs: []
  type: TYPE_NORMAL
- en: Set **Scale Mode** to **Scale With Screen Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Screen Match Mode** to **Match** **Width Or Height**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Reference Resolution X** value to `1920` and the **Y** value to `1080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the **Match** slider all the way to the right, toward the end labeled
    **Height**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.33: Setting the scaling of our UI'
  prefs: []
  type: TYPE_NORMAL
- en: Observe how changing the height of the **Game** panel of the Unity Editor will
    make the UI adapt its element sizes accordingly (i.e., change the whole Unity
    Editor window height).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did with those changes was first set **Reference Resolution** to whatever
    resolution we designed our UI for – in our case, `1920x1080`. Then, we set **Screen
    Match Mode** to allow us to scale our elements according to one of the sides,
    **Width**, **Height**, or a combination of the two if we prefer. We’re focusing
    on **Height** for scaling, as PCs typically have wider screens. This choice ensures
    that our UI elements maintain their visual consistency across various screen heights.
    This means that on different screen widths, the elements will look the same size,
    but on different heights, the elements will be bigger or smaller.
  prefs: []
  type: TYPE_NORMAL
- en: With these settings, we can do some math to understand the values. If our screen
    is the same as the reference resolution (`1920x1080`), the element sizes will
    be the same as we specified in the size of our elements in pixels, so for the
    case of our player avatar, it will be `150x150` pixels. Remember that the physical
    size in centimeters depends on the DPI of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of how UI elements scale on a 4K screen, let’s put this
    knowledge into practice. We’ll now adjust our UI settings to effectively accommodate
    such high-resolution displays. Follow along with these steps to see how our UI
    elements respond and adapt to a 4K resolution setup.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we have a 4K screen, meaning a resolution of `3840x2160`.
    As we specified that our UI matches via **Height**, we can determine that our
    elements will double in size because our screen has a height that is double the
    reference resolution (`2160` divided by `1080`). Our player avatar, at `300x300`
    pixels, will maintain its physical size on a 4K screen; this is achieved by the
    screen’s double size coupled with its double pixel density. Finally, consider
    an ultra-wide standard resolution of `2560×1080` (yes, very wide screens), in
    which case the elements will be the same size, as the only change is the width;
    the only difference is that the elements will have more horizontal separation
    due to the screen size. I know these calculations can be confusing, but keep experimenting
    with the values of the **Panel Settings** and **Game** view sizes to understand
    them better.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we really have the same HUD. We could start applying the concepts
    seen so far to the **Options** menu, but let’s take the opportunity to do it in
    a different way, using **relative** **positions**, a way to create a flow of elements
    where the elements’ positions depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Using relative positions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the HUD of our game, each element requires its own **Position** and **Size**,
    and the different elements’ positions can be resized and repositioned without
    affecting others. We might observe the case of the player health bar and the avatar,
    but the changes would be trivial in this case. There are other cases where this
    is not that trivial, as in the case of a list of elements (for example, a list
    of matches to join in a multiplayer game) that needs to adapt vertically or horizontally,
    and here is where relative positions help us.
  prefs: []
  type: TYPE_NORMAL
- en: Relative positions allow us to make the positions of the elements relative to
    each other; in a way, the position of one element will depend on the position
    of the previous one, and that one to its previous, and so on, forming a chain
    or **flow**. This works like vertical and horizontal layouts on uGUI. In our case,
    we will make the **Pause** label and the **Options** and **Exit** buttons of our
    options menu vertically aligned and centered along their parent using those.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start creating the menu by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new UI Document (click the **+** button after going to **Project View**
    | **UI Toolkit** | **UI Document**) and call it `OptionsMenu`. We can work on
    the previous UI Document, but let’s keep those pieces of UI separated for easy
    activation and deactivation as well as general asset organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the asset to set it as the current UI being edited by the **UI
    Builder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the root object (**OptionsMenu.uxml** in the **Hierarchy**) and set the
    **Width** and **Height** **Inspector** properties to `1920x1080` pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new GameObject with the **UI Document** component (**GameObject** |
    **UI Toolkit** | **UI Document**) and drag the asset for this object to render
    it (as we did with the HUD created earlier in the chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the **UI Document** asset to open the **UI Builder** window to
    edit it, and in that window, drag a new **VisualElement** to the **Hierarchy**
    or viewport and call it `Container` (the **Name** property in the **Inspector**
    in **UI Builder**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Left**, **Right**, **Top**, and **Right** **Position** attributes
    to `0px`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Position** to **Absolute**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Width** and **Height** in the **Size** section to **auto**. This will
    make the container fit the entire screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new **VisualElement** to be a child of the container and call it `Background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave **Position** as **Relative** this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Size** **Width** and **Height** to `500px`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Background Image** of the **Background** object to use the same background
    sprite used in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Container** parent object (not **Background**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, set the **Align Items** property of the **Align** section
    to `center`, which is the third button. If you hover the mouse over the icons,
    they will show their names in a tooltip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Justify Content** to **Center** (second button):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.34: Preparing the UI background to host elements inside'
  prefs: []
  type: TYPE_NORMAL
- en: Change the size of the UI using the white bars at the sides to see how the background
    is always centered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With just a single element in place, this is a great chance to observe how relative
    positioning functions in a practical setting. First, we created an empty object
    that will always adapt to the screen size, allowing us to make the children’s
    elements depend on the full-screen size. Then, we created an image element with
    a fixed size but with a relative position, meaning its position will be calculated
    by the parent container. Finally, we told the container to make its child objects
    aligned to its horizontal and vertical center, so the background immediately became
    centered, regardless of the screen size. When working with absolute positions,
    the **Align** properties didn’t work, so this is one of the first benefits of
    relativepositioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'But relative positioning becomes more powerful with multiple elements, so let’s
    add the **Label** and buttons to our **Background** element to explore this concept
    further by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Library** pane at the bottom left of **UI Builder**, drag a **Label**
    and two **Button** elements inside **Background** in **Hierarchy**. Note that
    there’s a bug where, sometimes, even if you drag and drop a new element inside
    the desired object, it won’t be its child. Just drag the one created in the Hierarchy
    this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_35_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.35: Adding elements inside the menu background'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe how, by default, the elements became vertically aligned, one on top
    of the other, due to the relative position’s default settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A close-up of a button  Description automatically generated with low confidence](img/B21361_16_36_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.36: Automatic relative vertical positioning'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Background** element and set **Justify Content** to `space-around`
    (the fifth button). This will spread the elements along the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Align Items** to center (the third option) to center elements horizontally:![A
    screenshot of a computer screen  Description automatically generated with low
    confidence](img/B21361_16_37_PE.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 16.37: Automatic relative vertical positioning'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is a similar mode for **Justify Content** called space-between (the fourth
    button in **Justify Content**) that will also spread the elements along the vertical
    axis, but it won’t leave space on top of the first element or at the bottom of
    the last one. Also, **Align Items** has an option called **Stretch** (the fifth
    option) that, like **center**, will not only center elements horizontally but
    also stretch them instead of respecting each element’s width. I recommend experimenting
    with the different aligning modes to discover all opportunities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the **Label** **Text**’s **Font** and **Size** attributes to whatever seems
    fit. In my case, I used the imported font and a size of `60px`. Remember to also
    set **Text** to `Pause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Button** **Background Image** to use the same as was used for the
    button in the last chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Color** property of the **Background** section to a color with no
    alpha. You can achieve this by clicking the color rectangle and reducing the **A**
    channel in the color picker to `0`. The idea of this color is to act as a background
    for our image, but we don’t need it, so we made it completely transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Button **Text** **Font**, **Size**, and **Color** to whatever seems
    fit to you. In my case, I’m using `50` and a gray color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Margin and Padding** section, set **Padding** to have some spacing
    between the text and the borders of the button. In my case, `30px` did the trick:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_16_38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.38: Adding inner padding to the button contents (the text in this
    case)'
  prefs: []
  type: TYPE_NORMAL
- en: Also, set the **Top** and **Bottom** **Padding** of **Background** to allow
    some space between the borders of the window and its elements. In my case, it
    is `40px` each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, we changed different settings to set the size of the elements
    dynamically, like font sizes and paddings, and the relative system, along with
    the align settings, took the role of determining the position of the elements
    automatically. We can rearrange the order of the elements by dragging them in
    the Hierarchy, and they will be accommodated automatically. We could have also
    set the size of the elements with the **Size** property, and we can also apply
    some offsets if desired using the **Position** properties, but I encourage you
    to see how these properties behave in **Relative** mode on your own.
  prefs: []
  type: TYPE_NORMAL
- en: One last setting I want you to explore is the **Direction** attribute of the
    **Flex** section, which, as you can imagine, will determine the orientation the
    elements will follow, vertically from top to bottom or bottom to top and horizontally
    from left to right or right to left. For example, you could set **Direction**
    to distribute the elements from left to right using the **Row** mode (the third
    button) and make the background wider to have a horizontal options menu if you
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_16_39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.39: Changing to a vertical orientation of elements'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, you might have noticed that the images for the background and
    buttons will look bigger than the options menu created in the last chapter. That’s
    because the **Pixels per Unit** setting that we changed on the **Texture** assets
    to control the scaling of the textures won’t take effect in UI Toolkit; you will
    need to manually change the texture file size in any image editor to give it its
    proper size. The best practice here would be to always create the images with
    a size that will look fine in our maximum supported resolution. Usually, this
    is `1920x1080` on a PC, but note that 4K resolutions are becoming more popular
    every day.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to the key concepts of UI Toolkit and how
    to create UI Documents and Stylesheets. Regarding UI Documents, we learned how
    to create different elements like images, text, and buttons and how to position
    and size them using different methods, like absolute and relative positioning
    and pixel or percentual units. Also, we saw how to make the UI adapt to different
    sizes using different combinations of **Position** attributes. Finally, we learned
    how to use USS Stylesheets to share styles between different elements to easily
    manage our whole UI skinning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, we learned again how to make UIs with a different system. Again,
    please note that this system is still in the experimental phase and is not recommended
    for real production projects. We used all these concepts to recreate the same
    UI created in *Chapter 15*, *Interface Brilliance: Designing a User-Friendly UI*.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see how to add animations to our game to
    make our characters move. We will also see how to create cut-scenes and dynamic
    cameras.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1498477041053909218.png)'
  prefs: []
  type: TYPE_IMG
