- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Setting Up a Backend for a Game Using Azure Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure服务设置游戏的后端
- en: In this chapter, we will set up a backend for a game app with real-time communication.
    We will not only create a backend that can scale up to handle a large number of
    users but also scale down when the number of users is reduced. To build that backend,
    we will use a serverless architecture based on services in **Microsoft Azure**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置一个具有实时通信功能的游戏应用的后端。我们不仅将创建一个可以扩展以处理大量用户的后端，当用户数量减少时还可以缩小规模。为了构建这个后端，我们将使用基于**Microsoft
    Azure**服务的无服务器架构。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the different Azure serverless services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同的Azure无服务器服务
- en: Creating a **SignalR** service in Microsoft Azure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Microsoft Azure中创建**SignalR**服务
- en: Using Azure Functions as an **application programming** **interface** (**API**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure Functions作为**应用程序编程** **接口**（**API**）
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, you need to have Visual Studio for Mac
    or PC installed, as well as the necessary .NET MAUI components. See *Chapter 1*,
    *Introduction to .NET MAUI*, for more details on how to set up your environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够完成此项目，您需要安装Visual Studio for Mac或PC，以及必要的.NET MAUI组件。有关如何设置您的环境的更多详细信息，请参阅*第1章*，*.NET
    MAUI简介*。
- en: You also need an Azure account. If you have a Visual Studio subscription, there
    are a specific amount of Azure credits included each month. To activate your Azure
    benefits, go to [https://my.visualstudio.com](https://my.visualstudio.com).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个Azure账户。如果您有Visual Studio订阅，则每月包含一定数量的Azure信用额度。要激活您的Azure福利，请访问[https://my.visualstudio.com](https://my.visualstudio.com)。
- en: You can also create a free account, where you can use selected services for
    free over 12 months. You will get $200 worth of credit to explore any Azure service
    for 30 days, and you can also use the free services at any time. Read more at
    [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个免费账户，在12个月内您可以免费使用所选服务。您将获得价值200美元的信用额度，用于探索任何Azure服务30天，您还可以随时使用免费服务。更多信息请参阅[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: If you do not have and do not want to sign up for a free Azure account, you
    can use local development tools to run the services without Azure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有并且不想注册免费Azure账户，您可以使用本地开发工具在无需Azure的情况下运行服务。
- en: You can find the full source for the code in this chapter at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章中找到代码的完整源代码，请参阅[https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition)。
- en: Project overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: The main aim of this project will be to set up the backend for a game. A large
    part of the project will be the configuration that we will carry out in the Azure
    portal. We will also write some code for the Azure functions that will handle
    the SignalR connections and a bit of the game logic and state. SignalR is a library
    that makes real-time communication in applications easier. Azure SignalR is a
    service that makes it easier to connect multiple clients to send messages via
    the SignalR library. SignalR is described in more detail later. There will be
    functions to return information about the SignalR connection, manage matching
    players to play against each other, and post the result of each player’s turn
    to the SignalR service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的主要目标将是设置游戏的后端。项目的大部分工作将是我们将在Azure门户中进行的配置。我们还将为Azure函数编写一些代码，以处理SignalR连接以及一些游戏逻辑和状态。SignalR是一个使应用程序中的实时通信更简单的库。Azure
    SignalR是一个使通过SignalR库连接多个客户端发送消息更简单的服务。SignalR将在后面详细描述。将会有函数来返回有关SignalR连接的信息，管理匹配玩家进行对战，并将每位玩家的回合结果发布到SignalR服务。
- en: 'The following diagram shows an overview of the architecture of this application:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了此应用程序架构的概述：
- en: '![](img/B19214_09_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19214_09_1.jpg)'
- en: Figure 9.1 – Application architecture
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 应用程序架构
- en: The estimated time to complete this part of the project is about 2 hours.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此项目部分所需的时间估计约为2小时。
- en: An overview of the game
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏概述
- en: '*Sticks & Stones* is a turn-based social game based on the concepts of two
    childhood games mashed into one, Dots and Boxes and Tic-Tac-Toe. The game board
    is laid out in a 9x9 grid. Each player will take a turn placing a stick along
    the side of a box, earning one point. If a stick completes a box, then the player
    takes ownership of the box, earning five points. The game is won when a player
    owns three boxes in a row, horizontally, vertically, or diagonally. If no player
    can own three boxes in a row, the winner of the game is determined by the player
    with the highest score.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sticks & Stones* 是一款基于两个童年游戏概念结合而成的回合制社交游戏，即点线格和井字棋。游戏板布局为一个 9x9 的网格。每位玩家将轮流在盒子的旁边放置一根棍子，获得一分。如果一根棍子完成了一个盒子，那么玩家将获得该盒子的所有权，获得五分。当玩家在水平、垂直或对角线上拥有三个连续的盒子时，游戏结束。如果没有任何玩家能拥有三个连续的盒子，则游戏胜利者由得分最高的玩家决定。'
- en: To keep the app and the service side relatively simple, we will eliminate a
    lot of state management. When the player opens the app, they will have to connect
    to the game service. They will have to provide a gamer tag or username and an
    email address. Optionally, they can upload a picture of themselves to use as a
    profile picture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用和服务端相对简单，我们将消除大量的状态管理。当玩家打开应用时，他们需要连接到游戏服务。他们必须提供游戏标签或用户名和电子邮件地址。可选地，他们可以上传自己的照片作为头像。
- en: Once connected, the player will see a list of all the other players connected
    to the same game service; this is called the lobby. The player’s status, either
    “Ready to play” or “In a match,” will be displayed along with the player’s gamer
    tag and profile picture. If the player is not in a match, then there will also
    be a button to challenge the player to a match.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，玩家将看到连接到同一游戏服务的所有其他玩家的列表；这被称为大厅。玩家的状态，无论是“准备游戏”还是“正在比赛中”，将和玩家的游戏标签和头像一起显示。如果玩家不在比赛中，则还会有一个按钮挑战玩家进行比赛。
- en: Challenging a player to a match will cause the app to prompt the opponent to
    respond to the challenge, either accept or decline. If the opponent accepts the
    challenge, then both players are navigated to a new game board where the player
    who received the challenge will have the first turn. Both players’ statuses will
    update to “In a match” in all the other players’ lobbies. Play will alternate
    between players as they choose a location to place a single stick. Each time a
    stick is placed by a player, the game board and score will update on both players’
    devices. When a stick is placed that completes one or more squares, the player
    then “owns” that square, and a pile of stones is placed in the center of the square.
    When all sticks have been placed, or a player owns three stones in a row, the
    game is over, the players navigate back to the lobby, and their status is updated
    to “Ready to play.”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战玩家进行比赛将导致应用提示对手回应挑战，要么接受要么拒绝。如果对手接受挑战，那么两位玩家将被导航到一个新的游戏板，接受挑战的玩家将先走一步。所有其他玩家的大厅中，两位玩家的状态都将更新为“正在比赛中”。玩家将轮流选择放置一根棍子的位置。每次玩家放置一根棍子时，游戏板和分数将在两位玩家的设备上更新。当放置的棍子完成一个或多个方块时，玩家就“拥有”了那个方块，并在方块的中央放置一堆石头。当所有棍子都放置完毕，或者玩家拥有三个连续的石头时，游戏结束，玩家返回大厅，状态更新为“准备游戏”。
- en: If a player leaves the app during a game, then they will have forfeited the
    game and the remaining opponent will be credited with the win and navigated back
    to the lobby.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在游戏中离开应用，那么他们将放弃比赛，剩余的对手将获得胜利，并返回大厅。
- en: 'The following screenshot should give you an idea of what the app will look
    like when it’s completed in *Chapter 10*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图应能给您一个概念，了解应用完成后的样子，如第 *10* 章所述：
- en: '![Figure 9.2 – The main game screens](img/B19214_09_2_Merged.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 主游戏界面](img/B19214_09_2_Merged.jpg)'
- en: Figure 9.2 – The main game screens
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 主游戏界面
- en: Understanding the different Azure serverless services
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同的 Azure 无服务器服务
- en: Before we start to build a backend with a serverless architecture, we need to
    define what **serverless** means. In a serverless architecture, the code will
    run on a server, but we don’t need to worry about that; the only thing we need
    to focus on is building our software. We let someone else handle everything to
    do with servers. We don’t need to think about how much memory or **central processing
    units** (**CPUs**) the server needs, or even how many servers we need. When we
    use services in Azure, Microsoft takes care of this for us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建无服务器架构的后端之前，我们需要定义**无服务器**的含义。在无服务器架构中，代码将在服务器上运行，但我们无需担心这一点；我们唯一需要关注的是构建我们的软件。我们让其他人处理所有与服务器相关的事情。我们不需要考虑服务器需要多少内存或**中央处理器**（**CPUs**），甚至不需要考虑我们需要多少服务器。当我们使用Azure中的服务时，Microsoft会为我们处理这些事情。
- en: Azure SignalR Service
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure SignalR 服务
- en: '**Azure SignalR Service** is a service in **Microsoft Azure** for real-time
    communication between a server and clients. The service will push content to the
    clients without them having to poll the server to get content updates. SignalR
    can be used for multiple types of applications, including mobile applications,
    web applications, and desktop applications.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure SignalR 服务**是**Microsoft Azure**中的一项服务，用于服务器和客户端之间的实时通信。该服务将内容推送到客户端，而无需客户端轮询服务器以获取内容更新。SignalR可用于多种类型的应用程序，包括移动应用程序、Web应用程序和桌面应用程序。'
- en: SignalR will use **WebSockets** if that option is available. If it is not, SignalR
    will use other techniques for communication, such as **Server-Sent Events** (**SSEs**)
    or **long polling**. SignalR will detect which transport technology is available
    and use it without the developer having to think about it at all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR将使用**WebSockets**，如果该选项可用。如果不可用，SignalR将使用其他通信技术，例如**服务器发送事件**（**SSEs**）或**长轮询**。SignalR将检测哪种传输技术可用，并使用它，而无需开发者进行任何思考。
- en: 'SignalR can be used in the following examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR可以在以下示例中使用：
- en: '**Chat applications**: Where the application requires updates from the server
    as soon as new messages are available'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聊天应用程序**：当应用程序需要在新消息可用时从服务器获取更新时'
- en: '**Collaborative applications**: For example, meeting applications or when users
    on multiple devices are working with the same document'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作应用程序**：例如，会议应用程序或当多个设备上的用户共同编辑同一文档时'
- en: '**Multiplayer games**: Where all users need live updates about other users'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多人游戏**：所有用户都需要实时了解其他用户的更新'
- en: '**Dashboard applications**: Where users need live updates'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板应用程序**：用户需要实时更新'
- en: Azure Functions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Azure Functions is a Microsoft Azure service that allows us to run code in a
    serverless way. We will deploy small pieces of code called **functions**. Functions
    are deployed in groups, called **function apps**. When we are creating a function
    app, we need to select whether we want it to run on a Consumption plan or an App
    Service plan. We select a Consumption plan if we want the application to be completely
    serverless, while with an App Service plan, we have to specify the requirements
    of the server. With a Consumption plan, we pay for the execution time and for
    how much memory the function uses. One benefit of an App Service plan is that
    you can configure it to be **Always-On**, and you won’t have any cold starts,
    so long as you don’t have to scale up to more instances. The big benefit of a
    Consumption plan is that it will always scale according to which resources are
    needed at that time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions是Microsoft Azure的一项服务，允许我们以无服务器的方式运行代码。我们将部署称为**函数**的小块代码。函数以组的形式部署，称为**函数应用**。当我们创建函数应用时，我们需要选择是否希望它在消费计划或应用服务计划上运行。如果我们希望应用程序完全无服务器，则选择消费计划；而使用应用服务计划，我们必须指定服务的要求。使用消费计划，我们只需为函数的执行时间和使用的内存付费。应用服务计划的一个好处是，您可以将其配置为**始终开启**，这样就不会有任何冷启动，只要您不需要扩展到更多实例。消费计划的一个主要好处是，它将始终根据当时所需的资源进行扩展。
- en: There are several ways in which a function can be triggered to run. Two examples
    are `HttpTrigger` and `TimeTrigger`. `HttpTrigger` will trigger the function to
    run when an HTTP request is calling the function. With `TimeTrigger`, functions
    will run at an interval that we specify. There are also triggers for other Azure
    services. For example, we can configure a function to run when a file is uploaded
    to Azure Blob storage, when a new message is posted to an event hub or service
    bus, or when data is changed in an Azure Cosmos DB service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过多种方式触发运行。两个例子是 `HttpTrigger` 和 `TimeTrigger`。`HttpTrigger` 将在 HTTP 请求调用函数时触发函数运行。使用
    `TimeTrigger`，函数将按照我们指定的间隔运行。还有其他 Azure 服务的触发器。例如，我们可以配置一个函数在文件上传到 Azure Blob
    存储时运行，当新消息发布到事件中心或服务总线时运行，或者当 Azure Cosmos DB 服务中的数据发生变化时运行。
- en: Now that we understand what features Azure SignalR Service and Functions offer,
    let’s use them to build our game backend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Azure SignalR 服务和 Functions 提供的功能，让我们使用它们来构建我们的游戏后端。
- en: Building the serverless backend
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建无服务器后端
- en: In this section, we will set up the backend based on the services described
    in the preceding section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据上一节中描述的服务设置后端。
- en: Creating a SignalR service
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SignalR 服务
- en: 'The first service that we will set up is the one for SignalR. To create such
    a service, proceed as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置 SignalR 服务。要创建此类服务，请按照以下步骤操作：
- en: Go to the Azure portal at [https://portal.azure.com](https://portal.azure.com).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Azure 门户 [https://portal.azure.com](https://portal.azure.com)。
- en: Create a new resource. The **SignalR Service** resource is in the **Web &**
    **Mobile** category.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的资源。**SignalR 服务** 资源位于 **Web & 移动** 类别。
- en: Provide a name for the resource in the form.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中为资源提供名称。
- en: Select the subscription you want to use for this project.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想用于此项目的订阅。
- en: We recommend that you create a new **Resource group** and use it for all the
    resources that we will create for this project. The reason that we want one resource
    group is that it is easier to track which resources are related to this project,
    and it is also easier to delete all the resources together.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们建议您创建一个新的 **资源组** 并将其用于我们将为该项目创建的所有资源。我们想要一个资源组的原因是跟踪与该项目相关的资源更容易，并且也更容易一起删除所有资源。
- en: Select a location that is close to your users.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个靠近您用户的位置。
- en: Select a pricing tier. For this project, we will use the **Free** tier. We can
    always use the **Free** tier for development and later scale up to a tier that
    can handle more connections.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个定价层。对于此项目，我们将使用 **免费** 层。我们始终可以使用 **免费** 层进行开发，然后扩展到可以处理更多连接的层。
- en: Set **Service mode** to **Serverless**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **服务模式** 设置为 **无服务器**。
- en: Click **Review + create** to review the settings before creating the SignalR
    service.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **审查 + 创建** 在创建 SignalR 服务之前审查设置。
- en: Click **Create** to create the storage account.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 创建存储账户。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 9.3 – Creating the SignalR service](img/B19214_09_3.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 创建 SignalR 服务](img/B19214_09_3.jpg)'
- en: Figure 9.3 – Creating the SignalR service
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 创建 SignalR 服务
- en: This is all we need to do to set up a SignalR service. We will return to it
    in the Azure portal later to grab a connection string to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们设置 SignalR 服务所需做的所有事情。我们将在 Azure 门户中稍后返回以获取其连接字符串。
- en: The next step is to set up a storage account in which we can store the images
    that are uploaded by the users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在存储账户中设置一个账户，我们可以将用户上传的图片存储在其中。
- en: With the Computer Vision service created, we can now create the Azure Functions
    service, which will run our game logic and use SignalR, Blob storage, and Cognitive
    Services, which we just created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建计算机视觉服务后，我们现在可以创建 Azure Functions 服务，该服务将运行我们的游戏逻辑并使用 SignalR、Blob 存储和认知服务，这些服务我们刚刚创建。
- en: Using Azure Functions as an API
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure Functions 作为 API
- en: All the code we will write for the backend will be in Azure Functions. We will
    use a Visual Studio project to write, debug, and deploy our functions. Before
    we create the project, we will have to set up and configure the Azure Functions
    service. Then, we will implement the function to connect the player to the game
    and provide the client with a list of current players. Next, we will write the
    functions that allow one player to challenge another to a game. Finally, we will
    wrap up by writing the function that allows players to take turns placing sticks
    on the board.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为后端编写的所有代码都将使用 Azure Functions。我们将使用 Visual Studio 项目来编写、调试和部署我们的函数。在创建项目之前，我们必须设置和配置
    Azure Functions 服务。然后，我们将实现连接玩家到游戏并提供客户端当前玩家列表的函数。接下来，我们将编写允许一个玩家向另一个玩家挑战游戏的函数。最后，我们将通过编写允许玩家轮流在棋盘上放置木棒的函数来结束。
- en: Let’s begin by creating the Azure Functions service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建 Azure Functions 服务开始。
- en: Creating the Azure Functions service
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Azure Functions 服务
- en: 'Before we write any code, we will create the function app. This will contain
    the functions in the Azure portal. Proceed as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们将创建函数应用。这将包含 Azure 门户中的函数。按照以下步骤操作：
- en: Create a new **Function App** resource. **Function App** can be found under
    the **Compute** category.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **Function App** 资源。**Function App** 可在 **计算** 类别下找到。
- en: Select a subscription for the function app.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择函数应用的订阅。
- en: Select a resource group for the function app. This should be the same as the
    other resources we have created in this chapter.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择函数应用的资源组。这应该与我们在本章中创建的其他资源相同。
- en: Give the function app a name. The name will also be the start of the URL of
    the function.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给函数应用起一个名字。这个名字也将是函数 URL 的起始部分。
- en: Select **Code** as the deployment mechanism.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **代码** 作为部署机制。
- en: Select **.NET** as the runtime stack for the functions.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **.NET** 作为函数的运行时堆栈。
- en: Select **.NET 6.0 (Long Term Support)** for the version.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **.NET 6.0 (长期支持)** 作为版本。
- en: Select a location that is closest to your users.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择离您的用户最近的位置。
- en: Select **Windows** for **Operating System**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Windows** 作为 **操作系统**。
- en: We will use the **Consumption** plan as our **Hosting** plan, so we’ll only
    pay for what we use. **Function app** will scale both up and down according to
    our requirements – without us having to think about it at all – if we select a
    **Consumption** plan.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 **消费** 计划作为我们的 **托管** 计划，因此我们只为使用的内容付费。**Function app** 将根据我们的需求进行扩展和缩减
    – 而无需我们考虑 – 如果我们选择 **消费** 计划。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: "![Figur\uFEFFe 9.4 – Create Function App – Basics](img/B19214_09_4.jpg)"
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 创建 Function App – 基础](img/B19214_09_4.jpg)'
- en: Figure 9.4 – Create Function App – Basics
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 创建 Function App – 基础
- en: Click **Review + create** to review the settings before creating the function
    app.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **审查 + 创建** 在创建函数应用之前审查设置。
- en: Click **Create** to create the function app.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 以创建函数应用。
- en: Creating the projects
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'If you want, you can create functions in the Azure portal. I prefer to use
    Visual Studio, however, because the code editing experience is better, and you
    can use source control. For this project, we will need to separate projects as
    part of our solution – an Azure Functions project and a class library for shared
    code between the functions and the .NET MAUI app that will be built in *Chapter
    10*. To create and configure the projects, proceed as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以在 Azure 门户中创建函数。我更喜欢使用 Visual Studio，因为代码编辑体验更好，并且可以使用源代码控制。对于此项目，我们需要在我们的解决方案中创建和配置单独的项目
    – 一个 Azure Functions 项目和一个用于函数和将在第 10 章中构建的 .NET MAUI 应用之间共享代码的类库。要创建和配置项目，请按照以下步骤操作：
- en: Create a new project in Visual Studio.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建一个新项目。
- en: Enter `function` in the search field to find the template for Azure Functions.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索字段中输入 `function` 以找到 Azure Functions 的模板。
- en: 'Click the **Azure Functions** template to continue, as illustrated in the following
    screenshot:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击以下截图所示的 **Azure Functions** 模板以继续：
- en: '![Figure 9.5 – Create a new project](img/B19214_09_5.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 创建新项目](img/B19214_09_5.jpg)'
- en: Figure 9.5 – Create a new project
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 创建新项目
- en: Name the project `SticksAndStones.Functions`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `SticksAndStones.Functions`。
- en: 'Name the solution `SticksAndStones.Functions`, as illustrated in the following
    screenshot, and click **Next**:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解决方案命名为 `SticksAndStones.Functions`，如以下截图所示，然后点击 **下一步**：
- en: "![Figu\uFEFFre 9.6 – Configure your new project](img/B19214_09_7.jpg)"
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 配置您的项目](img/B19214_09_7.jpg)'
- en: Figure 9.6 – Configure your new project
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 配置您的新的项目
- en: 'The next step is to create our first function, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的第一个函数，如下所示：
- en: Select **.Net 6.0 (Long Term Support)** for **Functions worker** at the top
    of the dialog box.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框顶部选择 **.Net 6.0 (长期支持**) 作为 **函数工作器**。
- en: Select **Http trigger** as the trigger for our first function.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Http 触发器** 作为我们第一个函数的触发器。
- en: Click **Create** to continue; our functions project will be created.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 以继续；我们的函数项目将被创建。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 9.7 – Creating a new Azure Functions application – Additional information](img/B19214_09_8.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 创建新的 Azure Functions 应用程序 – 其他信息](img/B19214_09_8.jpg)'
- en: Figure 9.7 – Creating a new Azure Functions application – Additional information
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 创建新的 Azure Functions 应用程序 – 其他信息
- en: 'Our first function will return the connection information for the SignalR service.
    To do that, we need to connect the function by adding a connection string to the
    SignalR service, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数将返回 SignalR 服务的连接信息。为此，我们需要通过向 SignalR 服务添加连接字符串来连接函数，如下所示：
- en: Go to the **SignalR Service** resource in the Azure portal.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Azure 门户中的 **SignalR 服务** 资源。
- en: Go to the **Keys** tab on the left and copy the connection string.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到左侧的 **键** 选项卡并复制连接字符串。
- en: Go to the `AzureSignalRConnectionString` as the name for the setting.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AzureSignalRConnectionString` 作为设置的名称。
- en: 'Add the connection string to the `local.settings.json` file in the Visual Studio
    project to be able to run the function locally on the development machine, as
    illustrated in the following code block:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将连接字符串添加到 Visual Studio 项目中的 `local.settings.json` 文件中，以便能够在开发机上本地运行函数，如下面的代码块所示：
- en: '[PRE0]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, in the `SticksAndStones.Functions` project, we need to reference the `Microsoft.Azure.WebJobs.Extensions.SignalRService`
    NuGet package. This package contains the classes we need to communicate with the
    SignalR service. If an error occurs during this and you are not able to install
    the package, make sure that you have the latest version of all other packages
    in the project and try again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `SticksAndStones.Functions` 项目中，我们需要引用 `Microsoft.Azure.WebJobs.Extensions.SignalRService`
    NuGet 包。此包包含我们与 SignalR 服务通信所需的类。如果在安装此包时发生错误并且您无法安装包，请确保项目中所有其他包都是最新版本，然后重试。
- en: 'The last change we need to make is to adjust the automatic namespace generation.
    By default, the default namespace is the name of the project, which means all
    types in this project would have a root namespace of `SticksAndStones.Functions`.
    We don’t need the `Functions` part of that, so let’s remove it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个更改是调整自动命名空间生成。默认情况下，默认命名空间是项目的名称，这意味着本项目中所有类型都将有一个根命名空间 `SticksAndStones.Functions`。我们不需要
    `Functions` 这部分，所以让我们将其删除：
- en: Right-click the `SticksAndStones.Functions` project in **Solution Explorer**
    and select **Properties**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中右键单击 `SticksAndStones.Functions` 项目并选择 **属性**。
- en: In the `Default namespace`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `默认命名空间`。
- en: Change the `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`。
- en: This will split the project name on `.`, using only the first part and replacing
    any spaces with underscores.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将根据点号 `. ` 分割项目名称，仅使用第一部分并将任何空格替换为下划线。
- en: Now, when we create a new class, the namespace will start with just `SticksAndStones`.
    It’s time to create a shared project so that we can reuse code in both the .NET
    MAUI client and the Azure Functions service.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建一个新的类时，命名空间将仅以 `SticksAndStones` 开头。是时候创建一个共享项目，以便我们可以在 .NET MAUI 客户端和
    Azure Functions 服务中重用代码了。
- en: 'The shared code will go into a class library project. To create the project
    and reference it from the `SticksAndStones.Functions` project, follow these steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 共享代码将放入一个类库项目中。要创建项目并将其从 `SticksAndStones.Functions` 项目中引用，请按照以下步骤操作：
- en: Right-click on the `SticksAndStones` solution node in **Solution Explorer**
    and select **Add**, then **New Project**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中右键单击 `SticksAndStones` 解决方案节点并选择 **添加**，然后 **新建项目**。
- en: 'Search for `Class Library` in the **Add a new project** dialog box, as shown
    here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在如图所示的 **添加新项目** 对话框中搜索 **类库**。
- en: '![Figure 9.8 – Add a new project](img/B19214_09_9.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 添加新项目](img/B19214_09_9.jpg)'
- en: Figure 9.8 – Add a new project
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 添加新项目
- en: Select the **Class Library** template, then click **Next**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **类库** 模板，然后点击 **下一步**。
- en: 'In the `StickAndStones.Shared` for the name, as shown in the following screenshot,
    and click **Next**:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StickAndStones.Shared`命名空间中，如图下所示，然后点击**下一步**：
- en: '![Figure 9.9 – Configure your new project](img/B19214_09_10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 配置您的新的项目](img/B19214_09_10.jpg)'
- en: Figure 9.9 – Configure your new project
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 配置您的新的项目
- en: Select the **.NET 6.0 (Long Term Support)** framework project in the **Additional
    information** dialog, then click **Create**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加信息**对话框中，选择**.NET 6.0 (长期支持**)框架项目，然后点击**创建**。
- en: Delete the `Class1.cs` file that is created as part of the project template.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除由项目模板创建的`Class1.cs`文件。
- en: Add a reference to `SticksAndStones.Shared` in the `SticksAndStones.Functions`
    project.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SticksAndStones.Functions`项目中添加对`SticksAndStones.Shared`的引用。
- en: 'As we did for the `SticksAndStones.Functions` project, we will change the default
    namespace by following these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对`SticksAndStones.Functions`项目所做的那样，我们将通过以下步骤更改默认命名空间：
- en: Right-click the `SticksAndStones.Functions` project in **Solution Explorer**
    and select **Properties**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击`SticksAndStones.Functions`项目并选择**属性**。
- en: In the `Default namespace`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**默认命名空间**。
- en: Change the `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`。
- en: This will split the project name on `.`, using only the first part and replacing
    any spaces with underscores.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将根据`.`分割项目名称，只使用第一部分，并将任何空格替换为下划线。
- en: Now, we can write the code for the function that will return the connection
    information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写返回连接信息的函数的代码。
- en: Connecting a player to the game
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将玩家连接到游戏
- en: The first step in the game is to get connected. Being connected adds you to
    the list of available players so that you or other players can then join a game.
    As we have done in other projects in this book, first, we will create the models
    that we need to store or transfer data between the service and the clients. Then,
    we will implement the `Connect` function itself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的第一步是建立连接。建立连接会将您添加到可用玩家的列表中，这样您或其他玩家就可以加入游戏。正如我们在本书中的其他项目中做的那样，首先，我们将创建存储或在不同服务之间传输数据的所需模型。然后，我们将实现`Connect`函数本身。
- en: Creating the models
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型
- en: We will need a few functions for the app in *Chapter 10* to call during the
    life cycle of the app. The first is to establish a connection with the game services,
    called `Connect`. Essentially, this tells the service that a new or existing player
    is active and ready for play. The `Connect` function will register the player
    details and return the connection string to the SignalR hub so that the app can
    receive messages. We will need a few models before we can complete the function.
    There needs to be a `Player` model, a `Game` model, and models to assist with
    passing data between Azure Functions and the SignalR service to the app.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在应用的生命周期中调用几个函数，这些函数位于第10章。第一个是建立与游戏服务的连接，称为`Connect`。本质上，这告诉服务有一个新的或现有的玩家正在活跃并准备游戏。`Connect`函数将注册玩家详细信息并返回连接字符串到SignalR中心，以便应用可以接收消息。在完成函数之前，我们需要一些模型。需要一个`Player`模型，一个`Game`模型，以及帮助在Azure函数和SignalR服务之间传递数据的模型。
- en: Before we dive into creating the library, we should discuss the naming convention
    used in this chapter. Having a convention for how you name things will make it
    easier to determine how the class is used. When the app calls any Azure function,
    if it needs to send any data, it will do so using a class that has a suffix of
    `-Request`, and any Azure function that returns data will do so using a class
    that ends with `-Response`. For any data that is sent via the SignalR hub, we
    will use a class that has an `EventArgs` suffix. These classes will contain references
    to our actual models, and just act as a container for the data. Having these classes
    in place means that you can modify the data being sent or received without affecting
    the models themselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入创建库之前，我们应该讨论本章中使用的命名约定。有一个命名约定将使确定类的使用方式变得更容易。当应用调用任何Azure函数时，如果需要发送任何数据，它将使用后缀为`-Request`的类来发送，任何返回数据的Azure函数将使用以`-Response`结尾的类来发送。对于通过SignalR中心发送的任何数据，我们将使用带有`EventArgs`后缀的类。这些类将包含对我们实际模型的引用，仅作为数据的容器。拥有这些类意味着您可以修改发送或接收的数据，而不会影响模型本身。
- en: Since this is a two-player game, we need to track a little bit of the state
    so that we know who is online and what matches are in play. For this project,
    we will keep the state simple and not involve an actual database, but we will
    still use Entity Framework to do most of the work for us.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个双人对战游戏，我们需要跟踪一些状态信息，以便我们知道谁在线以及正在进行的比赛。对于这个项目，我们将保持状态简单，不涉及实际的数据库，但我们将仍然使用
    Entity Framework 来为我们完成大部分工作。
- en: 'Now that we have created and referenced the new project, and we have a naming
    convention in place, we can start creating the classes we will need. We will start
    with the two models, `Player` and `Match`. `Player` represents each person, while
    `Game` is a match between two `Player instances` and the state of play. To create
    the two models, follow these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建并引用了新的项目，并且我们已经建立了命名约定，我们可以开始创建所需的类。我们将从两个模型 `Player` 和 `Match` 开始。`Player`
    代表每个人，而 `Game` 是两个 `Player` 实例之间的比赛以及游戏状态。要创建这两个模型，请按照以下步骤操作：
- en: Create a new folder in the `SticksAndStones.Shared` project called `Models`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.Shared` 项目中创建一个新的文件夹名为 `Models`。
- en: Create a new class in the `Models` folder called `Player`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中创建一个新的类名为 `Player`。
- en: Create a `public` property in the `Player` class called `Id` as `Guid` and initialize
    it to `Guid.Empty`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Player` 类中创建一个名为 `Id` 的 `public` 属性，类型为 `Guid`，并将其初始化为 `Guid.Empty`。
- en: Create another `public` property called `GamerTag` as `string` and initialize
    it to `string.Empty`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `GamerTag` 的 `public` 属性，类型为 `string`，并将其初始化为 `string.Empty`。
- en: Create a `public` property named `GameId` as `Guid` and initialize it to `Guid.Empty`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GameId` 的 `public` 属性，类型为 `Guid`，并将其初始化为 `Guid.Empty`。
- en: 'Your `Player` class should now resemble the following code block:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的 `Player` 类现在应该类似于以下代码块：
- en: '[PRE1]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our model classes will use the `Id` field as a unique identifier so that we
    can locate each one individually. It will be used to locate specific players for
    messaging and relating `Match` instances to `Player` instances. `GamerTag` will
    be the display name for the player, and `EmailAddress` is how we can correlate
    players if they leave the app and then log back in again. Finally, the `MatchId`
    property will track whether the player is actively in a game.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型类将使用 `Id` 字段作为唯一标识符，以便我们可以单独定位每个对象。它将用于定位特定玩家进行消息传递以及将 `Match` 实例与 `Player`
    实例相关联。`GamerTag` 将是玩家的显示名称，而 `EmailAddress` 是我们关联离开应用程序并再次登录的玩家的方式。最后，`MatchId`
    属性将跟踪玩家是否正在积极进行游戏。
- en: 'Now that we have defined the `Player` class, it’s time to define the `Match`
    class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 `Player` 类，是时候定义 `Match` 类了：
- en: Create a new class in the `Models` folder called `Match`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中创建一个新的类名为 `Match`。
- en: Create a `public` property in the `Game` class called `Id` as `Guid` and initialize
    it to `Guid.Empty`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Game` 类中创建一个名为 `Id` 的 `public` 属性，类型为 `Guid`，并将其初始化为 `Guid.Empty`。
- en: Create a `public` property called `PlayerOneId` as `Guid`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerOneId` 的 `public` 属性，类型为 `Guid`。
- en: Add a `public` property named `PlayerOneScore` as `int`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `PlayerOneScore` 的 `public` 属性，类型为 `int`。
- en: Create another `public` property called `PlayerTwoId` as `Guid`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `PlayerTwoId` 的 `public` 属性，类型为 `Guid`。
- en: Add a `public` property named `PlayerTwoScore` as `int`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `PlayerTwoScore` 的 `public` 属性，类型为 `int`。
- en: Create a `public` property called `NextPlayerId` as `Guid`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `NextPlayerId` 的 `public` 属性，类型为 `Guid`。
- en: Create a `public` property called `Sticks` as `List<int>` and initialize it
    to `new List<int>(24)`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Sticks` 的 `public` 属性，类型为 `List<int>`，并将其初始化为 `new List<int>(24)`。
- en: Create a `public` property called `Stones` as `List<int>` and initialize it
    to `new List<int>(9)`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Stones` 的 `public` 属性，类型为 `List<int>`，并将其初始化为 `new List<int>(9)`。
- en: Create a `public` property called `Scores` as `List<int>` and initialize it
    to `new List<int>(2)`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Scores` 的 `public` 属性，类型为 `List<int>`，并将其初始化为 `new List<int>(2)`。
- en: Create a `public` property called `Completed` as `bool` and initialize it to
    `false`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Completed` 的 `public` 属性，类型为 `bool`，并将其初始化为 `false`。
- en: Create a `public` property called `WinnerId` as `Guid` and initialize it to
    `Guid.Empty`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `WinnerId` 的 `public` 属性，类型为 `Guid`，并将其初始化为 `Guid.Empty`。
- en: Add a `public` `static` method named `New` that takes two parameters, both of
    the `Guid` type, called `challengerId` and `opponentId`. The method returns an
    object of the `Game` type. The method should return a new instance of `Game` and
    assign the `Id` property to `Guid.NewGuid()`, `PlayerOneId` and `NextPlayerId`
    to `opponentId`, and `PlayerTwoId` to `challengerId`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `New` 的 `public` `static` 方法，该方法接受两个参数，参数类型均为 `Guid`，分别命名为 `challengerId`
    和 `opponentId`。该方法返回一个 `Game` 类型的对象。该方法应返回一个新的 `Game` 实例，并将 `Id` 属性设置为 `Guid.NewGuid()`，`PlayerOneId`
    和 `NextPlayerId` 设置为 `opponentId`，`PlayerTwoId` 设置为 `challengerId`。
- en: 'The `Player` class should now resemble the following code block:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Player` 类现在应类似于以下代码块：'
- en: '[PRE2]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Player` and `Match` classes will be used for data storage and data transfer
    between the client and server. Before we go any further with creating our models,
    let’s add the database using Entity Framework. Perform the following steps to
    add a reference to Entity Framework and create the database context so that the
    `Player` and `Match` classes can be stored in an `InMemory` database:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 和 `Match` 类将用于客户端和服务器之间的数据存储和数据传输。在我们创建模型之前，让我们使用 Entity Framework
    添加数据库。执行以下步骤以添加对 Entity Framework 的引用并创建数据库上下文，以便 `Player` 和 `Match` 类可以存储在 `InMemory`
    数据库中：'
- en: Add a package reference to `Microsoft.EntityFrameworkCore.InMemory` to the `SticksAndStones.Functions`
    project.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Microsoft.EntityFrameworkCore.InMemory` 包引用添加到 `SticksAndStones.Functions`
    项目中。
- en: Create a new folder called `Repository` in the `SticksAndStones.Functions` project.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.Functions` 项目中创建一个名为 `Repository` 的新文件夹。
- en: Create a class named `GameDbContext` in the `Repository` folder.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Repository` 文件夹中创建一个名为 `GameDbContext` 的类。
- en: 'Modify the constructor for the class to set database options:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类的构造函数以设置数据库选项：
- en: '[PRE3]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a public `Players` property to store the `Player` objects:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共 `Players` 属性以存储 `Player` 对象：
- en: '[PRE4]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a public `Matches` property to store the `Match` objects:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共 `Matches` 属性以存储 `Match` 对象：
- en: '[PRE5]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add an override to the `OnModelCreating` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnModelCreating` 方法中添加一个重写：
- en: '[PRE6]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method is where we specify to Entity Framework how to relate our classes
    together in a relational database.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法是我们指定 Entity Framework 如何在关系数据库中将我们的类关联在一起的地方。
- en: 'Start by declaring the identifiers for each class in the `OnModelCreating`
    method, as shown here:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在 `OnModelCreating` 方法中声明每个类的标识符，如下所示：
- en: '[PRE7]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Entity Framework does not handle our `List<int>` properties properly. It assumes
    that since it is a list, they are related instances. To change the default behavior
    in Entity Framework, we can use the following highlighted code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework 无法正确处理我们的 `List<int>` 属性。它假设由于它是一个列表，它们是相关实例。为了在 Entity Framework
    中更改默认行为，我们可以使用以下突出显示的代码：
- en: '[PRE8]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What each block does is define a conversion for the property. A conversion has
    two Lambda expressions – one from the C# object to the database and the other
    from the database to the C# object. For our `List<int>` properties, we want to
    convert a C# `List<int>` into a comma-separated string of integers, and then a
    comma-separated string of integers to `List<int>`.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个块所做的是定义属性的转换。转换有两个 Lambda 表达式 - 一个是从 C# 对象到数据库的转换，另一个是从数据库到 C# 对象的转换。对于我们的
    `List<int>` 属性，我们希望将 C# `List<int>` 转换为逗号分隔的整数字符串，然后将逗号分隔的整数字符串转换为 `List<int>`。
- en: '`toDB` is an instance of `List<int>`, so to convert that into a comma-separated
    list of numbers, we can use the `String.Join` function to join each element of
    the list with `,` between them.'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`toDB` 是 `List<int>` 的一个实例，因此要将它转换为逗号分隔的数字列表，我们可以使用 `String.Join` 函数将列表中的每个元素与它们之间的
    `,` 连接起来。'
- en: '`fromDb` is a `string` value containing numbers separated by commas. To convert
    that into `List<int>`, we can use the `String.Split` method to isolate each number,
    then pass each number into the `Int.Parse` method to convert the number into an
    `int` value. `Select` will produce `IEnumberable<int>`; we can use the `ToList`,
    to convert that into `List<int>`. If it doesn’t create a list, we can supply a
    default list of values, just like we did in the `Match` class itself.'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fromDb` 是一个包含逗号分隔的数字的 `string` 值。要将该值转换为 `List<int>`，我们可以使用 `String.Split`
    方法来隔离每个数字，然后将每个数字传递给 `Int.Parse` 方法以将数字转换为 `int` 值。`Select` 将生成 `IEnumberable<int>`；我们可以使用
    `ToList` 将其转换为 `List<int>`。如果它没有创建列表，我们可以提供一个默认值列表，就像我们在 `Match` 类本身中所做的那样。'
- en: 'To initialize Entity Framework to use an in-memory database, we need to create
    a `Startup` method. To create the method and initialize the database, follow these
    steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 Entity Framework 以使用内存数据库，我们需要创建一个 `Startup` 方法。要创建该方法并初始化数据库，请按照以下步骤操作：
- en: Create a new class named `Startup` in the root of the `SticksAndStones.Functions`
    project.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.Functions` 项目的根目录中创建一个名为 `Startup` 的新类。
- en: 'Modify the class file with the following highlighted code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改以下突出显示的代码的类文件：
- en: '[PRE9]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Startup` method will now be called when the `SticksAndStones.Functions`
    project is loaded at runtime. It will then create a factory for creating instances
    of the `GameDbContext` class we created previously and initialize it with an in-memory
    database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `SticksAndStones.Functions` 项目在运行时加载时，将调用 `Startup` 方法。然后，它将为之前创建的 `GameDbContext`
    类创建一个工厂以创建其实例，并使用内存数据库对其进行初始化。
- en: 'That concludes our setup for Entity Framework and our basic models, `Player`
    and `Game`. There is one final model that we need to send the SignalR connection
    information to the client. To create this model, follow these steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对Entity Framework和基本模型`Player`和`Game`的设置。我们还需要一个最终模型，将SignalR连接信息发送到客户端。要创建此模型，请按照以下步骤操作：
- en: Create a new class in the `Models` folder named `ConnectionInfo`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Models`文件夹中创建一个名为`ConnectionInfo`的新类。
- en: Add a public property `Url` that is a `string` value.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Url`的公共属性，它是一个`string`值。
- en: Add another public property named `AccessToken` that is also a `string` value.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为`AccessToken`的公共属性，它也是一个`string`值。
- en: 'The `ConnectionInfo` class should look like this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConnectionInfo`类应该看起来像这样：'
- en: '[PRE10]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the models now created, we can start creating the `Connect` function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型已经创建，我们可以开始创建`Connect`函数。
- en: Creating the Connect function
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建Connect函数
- en: We will start with a function to connect our player to the game, aptly named
    `Connect`. This function will expect a partially filled `Player` object to be
    sent in the request body. The function will return a fully populated `Player`
    object, a list of the currently connected players, and the connection information
    needed by the client to connect to the SignalR hub. To make the inputs and outputs
    cleaner, we will wrap them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个连接我们的玩家到游戏的函数开始，这个函数恰当地命名为`Connect`。这个函数将期望在请求体中发送一个部分填充的`Player`对象。该函数将返回一个完全填充的`Player`对象、当前连接的玩家列表以及客户端连接到SignalR中心所需连接信息。为了使输入和输出更清晰，我们将它们包装起来。
- en: 'To create the input and output classes, proceed as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建输入和输出类，请按照以下步骤操作：
- en: Create a new class in the `Messages` folder called `ConnectMessages`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Messages`文件夹中创建一个名为`ConnectMessages`的新类。
- en: 'Modify `ConnectMessages.cs` so that it looks like this:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ConnectMessages.cs`使其看起来像这样：
- en: '[PRE11]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For all the classes that will be used to transfer data between the client and
    Azure Functions or the SignalR service, we will use the `record` syntax. Since
    these classes will not have any real functionality, their sole purpose is to contain
    our models. By using a `record` struct, we also improve the memory usage of our
    functions since a new instance would be created in local memory and not global
    memory, which requires additional handling. The `record` syntax combines the constructor
    and property declarations into a single line of code, eliminating a lot of boilerplate
    code that adds no real benefit.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有将在客户端和Azure函数或SignalR服务之间传输数据的类，我们将使用`record`语法。由于这些类没有任何实际功能，它们唯一的目的就是包含我们的模型。通过使用`record`结构体，我们还提高了我们函数的内存使用效率，因为新实例将在本地内存中创建，而不是全局内存中，这需要额外的处理。`record`语法将构造函数和属性声明合并为单行代码，消除了大量无实际益处的样板代码。
- en: You will notice that we are using the conventions we discussed in the *Creating
    the models* section. Classes that have a suffix of `Request` or `Response` are
    used as input and output for any Azure function. For any data that is sent via
    the SignalR service, the class will use a suffix of `EventArgs`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们正在使用我们在*创建模型*部分讨论的约定。后缀为`Request`或`Response`的类被用作任何Azure函数的输入和输出。对于通过SignalR服务发送的任何数据，该类将使用后缀为`EventArgs`。
- en: 'When a new client is connecting, a message will be sent to other users via
    the SignalR service to indicate that they have connected. This message will also
    be used to notify when players start or end a game. To create such a message,
    proceed as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当新客户端连接时，将通过SignalR服务向其他用户发送消息，以表明他们已连接。此消息还将用于通知玩家开始或结束游戏。要创建此类消息，请按照以下步骤操作：
- en: Create a new class called `PlayerUpdatedEventArgs` in the `Messages` folder
    of the `SticksAndStones.Shared` project.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SticksAndStones.Shared`项目的`Messages`文件夹中创建一个名为`PlayerUpdatedEventArgs`的新类。
- en: 'Modify the class so that it’s a `record` struct with a single `Player` parameter,
    as shown in the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改该类，使其成为一个具有单个`Player`参数的`record`结构体，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have created the structures needed for the `Connect` function,
    we can start writing the function itself:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Connect`函数所需的架构，我们可以开始编写函数本身：
- en: Create a new folder called `Hubs`. We will put our service class into this folder.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Hubs`的新文件夹。我们将把我们的服务类放入这个文件夹。
- en: Move the `Function1.cs` file into the `Hubs` folder.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Function1.cs`文件移动到`Hubs`文件夹。
- en: Respond **Yes** to the next two prompts for moving the file and adjusting the
    namespace.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于移动文件和调整命名空间的下两个提示，回答**是**。
- en: Rename the `Function1.cs` file `GameHub.cs` and click **Yes** in the rename
    prompt.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Function1.cs` 文件重命名为 `GameHub.cs`，并在重命名提示中点击 **是**。
- en: 'Open the `GameHub.cs` file and rename the class `GameHub`, replace the `internal
    static` access modifiers and replace them with `public`, and derive it from the
    `ServerlessHub` base class, as highlighted here:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameHub.cs` 文件，将类名 `GameHub` 重命名为 `GameHub`，将 `internal static` 访问修饰符替换为
    `public`，并从 `ServerlessHub` 基类派生，如以下突出显示所示：
- en: '[PRE13]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Rename the default `Function1` function `Connect`, removing the `static` modifier
    as well. The method signature should look like the following highlighted code
    snippet:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Function1` 函数重命名为 `Connect`，同时移除 `static` 修饰符。方法签名应如下所示的高亮代码片段：
- en: '[PRE14]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To send a message to all clients connected to the SignalR hub, we will need
    another SignalR binding. This time, it is an `HubName` and is of the `IAsyncCollector<SignalRMessage>`
    type, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向连接到 SignalR 中心的所有客户端发送消息，我们需要另一个 SignalR 绑定。这次是一个 `HubName`，类型为 `IAsyncCollector<SignalRMessage>`，如下所示：
- en: '[PRE15]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remove the contents of the `Connect` method and proceed as follows to implement
    the function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 `Connect` 方法的所有内容，并按照以下步骤实现功能：
- en: 'Logging is important in Azure Functions as it helps when debugging in production
    environments. So, let’s add a `log` message:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Functions 中，日志记录非常重要，因为它有助于在生产环境中调试。因此，让我们添加一个 `log` 消息：
- en: '[PRE16]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The client, a .NET MAUI app, will send `ConnectRequest` in the body of the
    HTTP request as JSON. To get an instance of `ConnectRequest` from the request
    body, use the following lines of code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端，一个 .NET MAUI 应用，将在 HTTP 请求体中发送 `ConnectRequest` 作为 JSON。要从请求体中获取 `ConnectRequest`
    的实例，请使用以下代码行：
- en: '[PRE17]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will have to add `using System.Text.Json` to the namespace declarations
    as well. This uses the `System.Text.Json.JsonSerializer` class to read the contents
    of the request body and create a `ConnectRequest` object from it. It uses `jsonOptions`
    to properly deserialize the object.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将需要在命名空间声明中添加 `using System.Text.Json`。这使用 `System.Text.Json.JsonSerializer`
    类来读取请求体的内容，并从中创建一个 `ConnectRequest` 对象。它使用 `jsonOptions` 正确反序列化对象。
- en: 'Now, we need to define the `jsonOptions` field. Add the following line of code
    above the `Connect` method:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义 `jsonOptions` 字段。在 `Connect` 方法上方添加以下代码行：
- en: '[PRE18]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`JsonSerializerDefaults.Web` ensures that the JSON is formatted properly so
    that Azure Functions and the SignalR service will properly serialize and deserialize
    the objects. Mainly, it will enforce the following:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JsonSerializerDefaults.Web` 确保了 JSON 格式正确，以便 Azure Functions 和 SignalR 服务可以正确地序列化和反序列化对象。主要将强制执行以下操作：'
- en: Property names are case-insensitive
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称不区分大小写
- en: All property and object names will be formatted as camelCase
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有属性和对象名称都将格式化为 camelCase
- en: Numbers can be quoted
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可以加引号
- en: 'If we receive bad player data, return `ArgumentException` to the client, as
    follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们收到不良玩家数据，向客户端返回 `ArgumentException`，如下所示：
- en: '[PRE19]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the return type of the function is `IActionResult`, we can’t simply return
    our custom objects. Instead, we need to create an object that derives or implements
    `IActionResult` and pass in our result. In the case of errors, we will use `BadRequestObjectResult`,
    which will accept `Exception` as a parameter in the constructor. `BadRequestObjectResult`
    will set the HTTP status code to `400`, indicating an error. This status code
    can then be checked by the client to know whether the request succeeded or not
    before parsing the body of the response.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于函数的返回类型是 `IActionResult`，我们无法简单地返回自定义对象。相反，我们需要创建一个派生或实现 `IActionResult` 的对象，并传入我们的结果。在错误的情况下，我们将使用
    `BadRequestObjectResult`，它将在构造函数中接受 `Exception` 作为参数。`BadRequestObjectResult`
    将 HTTP 状态码设置为 `400`，表示错误。然后，客户端可以检查此状态码，以确定在解析响应体之前请求是否成功。
- en: 'The next couple of steps will require us to query the database, so we need
    to add the database context factory to the class. Add the `Microsoft.EntityFrameworkCore`
    namespace declaration:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下几个步骤将需要我们查询数据库，因此我们需要将数据库上下文工厂添加到类中。添加 `Microsoft.EntityFrameworkCore` 命名空间声明：
- en: '[PRE20]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: private readonly JsonSerializerOptions jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);
    private readonly IDbContextFactory <GameDbContext> dbContextFactory;public GameHub(IDbContextFactory<GameDbContext>
    dbcontext){    contextFactory = dbContextFactory;}
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly JsonSerializerOptions jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);
    private readonly IDbContextFactory<GameDbContext> dbContextFactory;public GameHub(IDbContextFactory<GameDbContext>
    dbcontext){    contextFactory = dbContextFactory;}
- en: '[FunctionName("Connect")]public async Task<IActionResult> Connect('
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FunctionName("Connect")]public async Task<IActionResult> Connect('
- en: '[PRE21]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a namespace declaration for `System.Linq` to allow the use of **Linq**
    queries:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `System.Linq` 的命名空间声明以允许使用 **Linq** 查询：
- en: '[PRE22]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: using var context = contextFactory.CreateDbContext();log.LogInformation("Checking
    for GameTag usage");var gamerTagInUse = (from p in context.Players                      where
    string.Equals(p.GamerTag, newPlayer.GamerTag, StringComparison.InvariantCultureIgnoreCase)                     &&
    !string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase)                     select
    p).Any();if (gamerTagInUse){    var error = new ArgumentException($"The GamerTag
    {newPlayer.GamerTag} is in use, please choose another.", "GamerTag");    log.LogError(error,
    "GamerTag in use.");    return new BadRequestObjectResult(error);}
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 var context = contextFactory.CreateDbContext();log.LogInformation("Checking
    for GameTag usage");var gamerTagInUse = (from p in context.Players where string.Equals(p.GamerTag,
    newPlayer.GamerTag, StringComparison.InvariantCultureIgnoreCase) && !string.Equals(p.EmailAddress,
    newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase) select p).Any();if
    (gamerTagInUse){    var error = new ArgumentException($"The GamerTag {newPlayer.GamerTag}
    is in use, please choose another.", "GamerTag");    log.LogError(error, "GamerTag
    in use.");    return new BadRequestObjectResult(error);}
- en: '[PRE23]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, query the `Players` dataset for a player with a matching email:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查询 `Players` 数据集以找到匹配的电子邮件的玩家：
- en: '[PRE24]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If there is no `Player` in `Players` that matches, then add `Player` to the
    dataset:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在 `Players` 中没有匹配的 `Player`，则将 `Player` 添加到数据集中：
- en: '[PRE25]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We assign the `Player` object a new `Guid` so that each `Player` has a unique
    identifier. This could also be done by Entity Framework; however, we will take
    care of it here. The context is then used to add the `Player` instance so that
    it is tracked for any changes. After this, `SaveChangesAsync` will commit all
    changes to the database.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为 `Player` 对象分配一个新的 `Guid`，以便每个 `Player` 都有一个唯一的标识符。这也可以通过 Entity Framework
    来完成；然而，我们将在这里处理它。然后使用上下文添加 `Player` 实例，以便跟踪任何更改。之后，`SaveChangesAsync` 将提交所有更改到数据库。
- en: 'The next step in the `Connect` function is to send a message to all the connected
    players that a new player has joined. We can do that using the `SendAsync` method.
    The `SendAsync` method takes two parameters – the method name as a `string` value
    that the message is intended for, and the message as an `object` value. To ensure
    we are sending and receiving the right method, we will create a constant value.
    Create a new class named `Constants` in the root of the `SticksAndStones.Shared`
    project, then update it so that it looks like this:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Connect` 函数的下一步中，我们需要向所有已连接的玩家发送一条消息，告知他们有新玩家加入。我们可以使用 `SendAsync` 方法来完成此操作。`SendAsync`
    方法接受两个参数 - 一个作为 `string` 值的方法名称，该消息旨在为其发送，以及一个作为 `object` 值的消息。为了确保我们发送和接收正确的方法，我们将创建一个常量值。在
    `SticksAndStones.Shared` 项目的根目录下创建一个名为 `Constants` 的新类，然后更新它，使其看起来像这样：
- en: '[PRE26]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can notify other connected players that a new player has connected.
    Open the `GameHub` class and, at the end of the `Connect` method, add the following
    code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通知其他已连接的玩家有新玩家连接。打开 `GameHub` 类，并在 `Connect` 方法的末尾添加以下代码：
- en: '[PRE27]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code uses the `SendAsync` method from the `Clients.All` collection in the
    `ServerlessHub` base class to send a message to all connected clients. We pass
    `Constants.Events.PlayerUpdated`, which is the `"PlayerUpdated"` string, as the
    method name. As arguments, we are sending the `Player` instance wrapped in `PlayerUpdatedEventArgs`.
    We will handle this message in *Chapter 10*.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码使用 `ServerlessHub` 基类中 `Clients.All` 集合的 `SendAsync` 方法向所有已连接的客户端发送消息。我们传递
    `Constants.Events.PlayerUpdated`，即 `"PlayerUpdated"` 字符串，作为方法名称。作为参数，我们发送包裹在 `PlayerUpdatedEventArgs`
    中的 `Player` 实例。我们将在 *第 10 章* 中处理此消息。
- en: 'Now, get the set of available players from the database to send back to the
    client:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从数据库中获取可用的玩家集合以发送回客户端：
- en: '[PRE28]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using Linq, we can easily query the `Players` collection and exclude the current
    player.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Linq，我们可以轻松查询 `Players` 集合并排除当前玩家。
- en: 'At this point, we need to get the SignalR connection information from the SignalR
    service. This can be accomplished by calling the `NegotiateAsync` method of the
    `ServerlessHub` base class. Additionally, so that we can send directed messages
    to individual users, we will set the `UserId` value for the connection to the
    player ID value. Add the following line of code to configure and retrieve the
    SignalR connection information:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们需要从 SignalR 服务中获取 SignalR 连接信息。这可以通过调用 `ServerlessHub` 基类中的 `NegotiateAsync`
    方法来实现。此外，为了能够向单个用户发送定向消息，我们将连接的 `UserId` 值设置为玩家 ID 值。添加以下代码行以配置和检索 SignalR 连接信息：
- en: '[PRE29]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have all the information that we need to return to the client,
    we can construct the `ConnectResponse` object. We will use the `ConnectionInfo`
    class and map the `SignalRConnection` properties to it so that we avoid having
    to reference the SignalR service in the shared library:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了返回给客户端所需的所有信息，我们可以构建`ConnectResponse`对象。我们将使用`ConnectionInfo`类并将`SignalRConnection`属性映射到它，这样我们就可以避免在共享库中引用SignalR服务：
- en: '[PRE30]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once `ConnectResponse` has been initialized, we can return it by using `OkObjectResult`,
    which will use an HTTP response code of **200 OK**:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`ConnectResponse`被初始化，我们可以通过使用`OkObjectResult`来返回它，这将使用HTTP响应代码**200 OK**：
- en: '[PRE31]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To test the function we just wrote, you can use a PowerShell command prompt
    and the following command, after pressing *F5* in Visual Studio:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们刚刚编写的函数，你可以在Visual Studio中按下*F5*后，使用PowerShell命令提示符和以下命令：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The port number used in the `Uri` parameter may be different for your project.
    You can get the correct port number by opening the `launchSettings.json` file
    in the `Properties` folder of the `SticksAndStones.Functions` project. The port
    number is set in the `commandLineArgs` property, as highlighted here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Uri`参数中使用的端口号可能因项目而异。你可以通过打开`SticksAndStones.Functions`项目的`Properties`文件夹中的`launchSettings.json`文件来获取正确的端口号。端口号设置在`commandLineArgs`属性中，如下所示：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '''{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress":
    "newplayer2@gmail.com",    }}'''
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '''{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress":
    "newplayer2@gmail.com",    }}'''
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect
    -Method Post -Body ''{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress":
    "newplayer2@gmail.com",    }}'''
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect
    -Method Post -Body ''{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress":
    "newplayer2@gmail.com",    }}'''
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct GetAllPlayersResponse(List<Player> Players);
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct GetAllPlayersResponse(List<Player> Players);
- en: '[PRE36]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[FunctionName("GetAllPlayers")]public IActionResult GetAllPlayers([HttpTrigger(AuthorizationLevel.Function,
    "get", Route = "Players/GetAll")] HttpRequest req,ILogger log){}'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FunctionName("GetAllPlayers")]public IActionResult GetAllPlayers([HttpTrigger(AuthorizationLevel.Function,
    "get", Route = "Players/GetAll")] HttpRequest req,ILogger log){}'
- en: '[PRE37]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: // Exclude the playerId if provided Guid playerId = Guid.Empty;if (req.Query.ContainsKey("id")){    string
    id = req.Query["id"];    if (!string.IsNullOrEmpty(id))    {        playerId =
    new Guid(id);    }}
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 排除提供的playerId Guid playerId = Guid.Empty;if (req.Query.ContainsKey("id")){    string
    id = req.Query["id"];    if (!string.IsNullOrEmpty(id))    {        playerId =
    new Guid(id);    }}
- en: '[PRE38]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: using var context = contextFactory.CreateDbContext();// Get the set of available
    players log.LogInformation("Getting the set of available players.");var players
    = (from player in context.Players                where player.Id != playerId                select
    player).ToList();
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using var context = contextFactory.CreateDbContext();// 获取可用玩家的集合 log.LogInformation("获取可用玩家的集合.");var
    players = (from player in context.Players                where player.Id != playerId
                   select player).ToList();
- en: '[PRE39]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: return new OkObjectResult(new GetAllPlayersResponse(players));
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new OkObjectResult(new GetAllPlayersResponse(players));
- en: '[PRE40]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct IssueChallengeRequest(Player Challenger, Player Opponent);
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct IssueChallengeRequest(Player Challenger, Player Opponent);
- en: '[PRE41]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: namespace SticksAndStones.Models;public enum ChallengeResponse {    None,    Accepted,    Declined,    TimeOut
    }
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: namespace SticksAndStones.Models;public enum ChallengeResponse {    None,    Accepted,    Declined,    TimeOut
    }
- en: '[PRE42]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: public record struct IssueChallengeResponse(ChallengeResponse Response);
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public record struct IssueChallengeResponse(ChallengeResponse Response);
- en: '[PRE43]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: public record struct AcknowledgeChallengeRequest(Guid Id, ChallengeResponse
    Response);
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public record struct AcknowledgeChallengeRequest(Guid Id, ChallengeResponse
    Response);
- en: '[PRE44]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct ChallengeEventArgs(Guid Id, Player Challenger, Player Opponent);
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct ChallengeEventArgs(Guid Id, Player Challenger, Player Opponent);
- en: '[PRE45]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: public static class Events {    public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);}
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static class Events {    public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);
- en: '[PRE46]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: using System;namespace SticksAndStones.Models;public record struct Challenge(Guid
    Id, Player Challenger, Player Opponent, ChallengeResponse Response);
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using System;namespace SticksAndStones.Models;public record struct Challenge(Guid
    Id, Player Challenger, Player Opponent, ChallengeResponse Response);
- en: '[PRE47]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: public static class Events {    public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);
    public static readonly string GameStarted = nameof(MatchStarted);}
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static class Events {    public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);
    public static readonly string GameStarted = nameof(MatchStarted);}
- en: '[PRE48]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct MatchStartedEventArgs(Match Match);
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct MatchStartedEventArgs(Match Match);
- en: '[PRE49]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[FunctionName("IssueChallenge")]public async Task<IssueChallengeResponse> IssueChallenge(    [HttpTrigger(AuthorizationLevel.Function,
    "post", Route = $"Challenge/Issue")] HttpRequest req,    ILogger log){}'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FunctionName("IssueChallenge")]public async Task<IssueChallengeResponse> IssueChallenge([HttpTrigger(AuthorizationLevel.Function,
    "post", Route = $"Challenge/Issue")] HttpRequest req, ILogger log){}'
- en: '[PRE50]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '{    var result = await JsonSerializer.DeserializeAsync<IssueChallengeRequest>(req.Body,
    jsonOptions);}'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{    var result = await JsonSerializer.DeserializeAsync<IssueChallengeRequest>(req.Body,
    jsonOptions);}'
- en: '[PRE51]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: using var context = contextFactory.CreateDbContext();Guid challengerId = result.Challenger.Id;var
    challenger = (from p in context.Players                   where p.Id == challengerId
                      select p).FirstOrDefault();
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using var context = contextFactory.CreateDbContext();Guid challengerId = result.Challenger.Id;var
    challenger = (from p in context.Players where p.Id == challengerId select p).FirstOrDefault();
- en: 'Guid opponentId = result.Opponent.Id;var opponent = (from p in context.Players
                    where p.Id == opponentId                 select p).FirstOrDefault();if
    (challenger is null)    throw new ArgumentException(paramName: nameof(challenger),
    message: $"{challenger.GamerTag} is not a valid player.");if (opponent is null)    throw
    new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag}
    is not a valid player.");'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Guid opponentId = result.Opponent.Id;var opponent = (from p in context.Players
    where p.Id == opponentId select p).FirstOrDefault();if (challenger is null)throw
    new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag}
    is not a valid player.");if (opponent is null)throw new ArgumentException(paramName:
    nameof(opponent), message: $"{opponent.GamerTag} is not a valid player.");'
- en: '[PRE52]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: var challengerInMatch = (from g in context.Matches
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var challengerInMatch = (from g in context.Matches
- en: where g.PlayerOneId == challengerId || g.PlayerTwoId == challengerId
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: where g.PlayerOneId == challengerId || g.PlayerTwoId == challengerId
- en: select g).Any();
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: select g).Any();
- en: var opponentInMatch = (from g in context.Matches
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var opponentInMatch = (from g in context.Matches
- en: where g.PlayerOneId == opponentId || g.PlayerTwoId == opponentId
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: where g.PlayerOneId == opponentId || g.PlayerTwoId == opponentId
- en: select g).Any();
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: select g).Any();
- en: if (challengerInMatch)
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (challengerInMatch)
- en: 'throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag}
    is already in a match!");'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag}
    is already in a match!");'
- en: if (opponentInMatch)
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (opponentInMatch)
- en: 'throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag}
    is already in a match!");'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag}
    is already in a match!");'
- en: '[PRE53]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Guid matchId = Guid.Empty;log.LogInformation($"{challenger.GamerTag} has challenged
    {opponent.GamerTag} to a match!");
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Guid matchId = Guid.Empty;log.LogInformation($"{challenger.GamerTag} has challenged
    {opponent.GamerTag} to a match!");
- en: '[PRE54]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: private readonly TimeSpan ackThreshold;private readonly Timer timer;
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly TimeSpan ackThreshold;private readonly Timer timer;
- en: 'public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold,
    TimeSpan ackInterval){    if (completeAcksOnTimeout)    {        timer = new Timer(_
    => CheckAcks(), state: null, dueTime: ackInterval, period: ackInterval);    }    this.ackThreshold
    = ackThreshold;}'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold,
    TimeSpan ackInterval){    if (completeAcksOnTimeout)    {        timer = new Timer(_
    => CheckAcks(), state: null, dueTime: ackInterval, period: ackInterval);    }    this.ackThreshold
    = ackThreshold;}'
- en: '[PRE55]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'private readonly Timer timer; public ChallengeHandler() : this(    completeAcksOnTimeout:
    true,    ackThreshold: TimeSpan.FromSeconds(30),    ackInterval: TimeSpan.FromSeconds(1))    {    }'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'private readonly Timer timer; public ChallengeHandler() : this(completeAcksOnTimeout:
    true, ackThreshold: TimeSpan.FromSeconds(30), ackInterval: TimeSpan.FromSeconds(1))    {    }'
- en: public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan
    ackInterval)
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan
    ackInterval)
- en: '[PRE56]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: public (Guid id, Task<Challenge> responseTask) CreateChallenge(Player challenger,
    Player opponent){    var id = Guid.NewGuid();    var tcs = new TaskCompletionSource<Challenge>(TaskCreationOptions.RunContinuationsAsynchronously);    handlers.TryAdd(id,
    new(id, tcs, DateTime.UtcNow, new(id, challenger, opponent, ChallengeResponse.None)));    return
    (id, tcs.Task);}
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public (Guid id, Task<Challenge> responseTask) CreateChallenge(Player challenger,
    Player opponent){    var id = Guid.NewGuid();    var tcs = new TaskCompletionSource<Challenge>(TaskCreationOptions.RunContinuationsAsynchronously);    handlers.TryAdd(id,
    new(id, tcs, DateTime.UtcNow, new(id, challenger, opponent, ChallengeResponse.None)));    return
    (id, tcs.Task);}
- en: private record struct ChallengeRecord(Guid Id, TaskCompletionSource<Challenge>
    ResponseTask, DateTime Created, Challenge Challenge);
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private record struct ChallengeRecord(Guid Id, TaskCompletionSource<Challenge>
    ResponseTask, DateTime Created, Challenge Challenge);
- en: '[PRE57]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: private readonly ConcurrentDictionary<Guid, ChallengeRecord> handlers = new();
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly ConcurrentDictionary<Guid, ChallengeRecord> handlers = new();
- en: '[PRE58]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: using SticksAndStones.Models;
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;
- en: using System;
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using System;
- en: using System.Collections.Concurrent;
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using System.Collections.Concurrent;
- en: using System.Threading;
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 System.Threading;
- en: 'AcknowledgeChallenge function will call a method named Respond. The Respond
    method will remove ChallengeRecord from the dictionary, if it exists, and return
    the associate Challenge. If there is no ChallengeRecord, then a new empty Challenge
    record is returned, as shown in the following code:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AcknowledgeChallenge 函数将调用一个名为 Respond 的方法。Respond 方法会从字典中移除 ChallengeRecord（如果存在），并返回关联的
    Challenge。如果没有 ChallengeRecord，则返回一个新的空 Challenge 记录，如下代码所示：
- en: '[PRE59]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: private void CheckAcks(){    foreach (var pair in handlers)    {        var
    elapsed = DateTime.UtcNow - pair.Value.Created;        if (elapsed > ackThreshold)        {            pair.Value.ResponseTask.TrySetException(new
    TimeoutException("Response time out"));        }    }}
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private void CheckAcks(){    foreach (var pair in handlers)    {        var
    elapsed = DateTime.UtcNow - pair.Value.Created;        if (elapsed > ackThreshold)        {            pair.Value.ResponseTask.TrySetException(new
    TimeoutException("Response time out"));        }    }}
- en: '[PRE61]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: public void Dispose(){    timer?.Dispose();    foreach (var pair in handlers)    {        pair.Value.ResponseTask.TrySetCanceled();    }}
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public void Dispose(){    timer?.Dispose();    foreach (var pair in handlers)    {        pair.Value.ResponseTask.TrySetCanceled();    }}
- en: '[PRE62]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: private readonly GameDbContext context;private readonly ChallengeHandler challengeHandler;
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly GameDbContext context;private readonly ChallengeHandler challengeHandler;
- en: public GameHub(GameDbContext dbcontext, ChallengeHandler handler){    context
    = dbcontext;    challengeHandler = handler;
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public GameHub(GameDbContext dbcontext, ChallengeHandler handler){    context
    = dbcontext;    challengeHandler = handler;
- en: '}'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE63]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: builder.Services.AddSingleton<ChallengeHandler>();
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: builder.Services.AddSingleton<ChallengeHandler>();
- en: '[PRE64]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: var challengeInfo = challengeHandler.CreateChallenge(challenger, opponent);log.LogInformation($"Challenge
    [{challengeInfo.id}] has been created.");
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var challengeInfo = challengeHandler.CreateChallenge(challenger, opponent);log.LogInformation($"Challenge
    [{challengeInfo.id}] has been created.");
- en: log.LogInformation($"Waiting on response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");await
    Clients.User(opponent.Id.ToString()).SendAsync(Constants.Events.Challenge, new
    ChallengeEventArgs(challengeInfo.id, challenger, opponent));
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogInformation($"Waiting on response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");await
    Clients.User(opponent.Id.ToString()).SendAsync(Constants.Events.Challenge, new
    ChallengeEventArgs(challengeInfo.id, challenger, opponent));
- en: '[PRE65]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ChallengeResponse response;try {    var challenge = await challengeInfo.responseTask.ConfigureAwait(false);    log.LogInformation($"Got
    response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");    response
    = challenge.Response;}catch {    log.LogInformation($"Never received a response
    from {opponent.GamerTag} for challenge[{challengeInfo.id}], it timed out.");    response
    = ChallengeResponse.TimeOut;}return new(response);
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ChallengeResponse response;try {    var challenge = await challengeInfo.responseTask.ConfigureAwait(false);    log.LogInformation($"Got
    response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");    response
    = challenge.Response;}catch {    log.LogInformation($"Never received a response
    from {opponent.GamerTag} for challenge[{challengeInfo.id}], it timed out.");    response
    = ChallengeResponse.TimeOut;}return new(response);
- en: '[PRE66]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[FunctionName("AcknowledgeChallenge")]public async Task AcknowledgeChallenge(    [HttpTrigger(AuthorizationLevel.Function,
    "post", Route = $"Challenge/Ack")] HttpRequest req,    ILogger log)'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FunctionName("AcknowledgeChallenge")]public async Task AcknowledgeChallenge(    [HttpTrigger(AuthorizationLevel.Function,
    "post", Route = $"Challenge/Ack")] HttpRequest req,    ILogger log)'
- en: '{}'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{}'
- en: '[PRE67]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: var result = await JsonSerializer.DeserializeAsync<AcknowledgeChallengeRequest>(req.Body,
    jsonOptions);
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var result = await JsonSerializer.DeserializeAsync<AcknowledgeChallengeRequest>(req.Body,
    jsonOptions);
- en: '[PRE68]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: var challenge = challengeHandler.Respond(result.Id, result.Response);if (challenge.Id
    == Guid.Empty){    return;}
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var challenge = challengeHandler.Respond(result.Id, result.Response);if (challenge.Id
    == Guid.Empty){    return;}
- en: '[PRE69]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: var challenger = challenge.Challenger;var opponent = challenge.Opponent;if (result.Response
    == ChallengeResponse.Declined){    log.LogInformation($"{opponent.GamerTag} has
    declined the challenge from {challenger.GamerTag}!");}
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var challenger = challenge.Challenger;var opponent = challenge.Opponent;if (result.Response
    == ChallengeResponse.Declined){    log.LogInformation($"{opponent.GamerTag} has
    declined the challenge from {challenger.GamerTag}!");}
- en: '[PRE70]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: if (result.Response == ChallengeResponse.Accepted)
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (result.Response == ChallengeResponse.Accepted)
- en: '{'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: log.LogInformation($"{opponent.GamerTag} has accepted the challenge from {challenger.GamerTag}!");
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogInformation($"{opponent.GamerTag} has accepted the challenge from {challenger.GamerTag}!");
- en: using var context = contextFactory.CreateDbContext();
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: using var context = contextFactory.CreateDbContext();
- en: var game = Match.New(challenger.Id, opponent.Id);
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: var game = Match.New(challenger.Id, opponent.Id);
- en: context.Matches.Add(game);
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.Matches.Add(game);
- en: opponent.MatchId = challenger.MatchId = match.Id;
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: opponent.MatchId = challenger.MatchId = match.Id;
- en: context.Players.Update(opponent);
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.Players.Update(opponent);
- en: context.Players.Update(challenger);
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.Players.Update(challenger);
- en: context.SaveChanges();
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.SaveChanges();
- en: log.LogInformation($"Created match {match.Id} between {opponent.GamerTag} and
    {challenger.GamerTag}!");
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogInformation($"创建了玩家 {opponent.GamerTag} 和 {challenger.GamerTag} 之间的比赛
    {match.Id}!");
- en: // Create Group for Game
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 为游戏创建组
- en: await UserGroups.AddToGroupAsync(opponent.Id.ToString(), $"Match[{match.Id}]");
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await UserGroups.AddToGroupAsync(opponent.Id.ToString(), $"Match[{match.Id}]");
- en: await UserGroups.AddToGroupAsync(challenger.Id.ToString(), $"Match[{match.Id}]");
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await UserGroups.AddToGroupAsync(challenger.Id.ToString(), $"Match[{match.Id}]");
- en: await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchStarted,
    new MatchStartedEventArgs(match));
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchStarted,
    new MatchStartedEventArgs(match));
- en: await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(opponent));
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(opponent));
- en: await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(challenger));
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(challenger));
- en: '}'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE71]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct GetMatchResponse(Match Match);
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct GetMatchResponse(Match Match);
- en: '[PRE72]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[FunctionName("GetMatch")]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FunctionName("GetMatch")]'
- en: public IActionResult GetMatch(
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public IActionResult GetMatch(
- en: '[HttpTrigger(AuthorizationLevel.Function, "get", Route ='
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[HttpTrigger(AuthorizationLevel.Function, "get", Route ='
- en: '"Match/{id}")] HttpRequest req,'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Match/{id}")] HttpRequest req,'
- en: Guid id,    ILogger log){}
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Guid id,    ILogger log){}
- en: '[PRE73]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: using var context = contextFactory.CreateDbContext();Match match = (from m in
    context.Matches where m.Id == id select m).FirstOrDefault();
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using var context = contextFactory.CreateDbContext();Match match = (from m in
    context.Matches where m.Id == id select m).FirstOrDefault();
- en: '[PRE74]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: return new OkObjectResult(new GetMatchResponse(match));
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new OkObjectResult(new GetMatchResponse(match));
- en: '[PRE75]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '{    "match": null }'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{    "match": null }'
- en: '[PRE76]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct ProcessTurnRequest(Guid MatchId, Player Player, int Position);
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct ProcessTurnRequest(Guid MatchId, Player Player, int Position);
- en: public record struct ProcessTurnResponse(Match Match);
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public record struct ProcessTurnResponse(Match Match);
- en: '[PRE77]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: public static class Events     {        public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);        public static readonly string Challenge = nameof(Challenge);        public
    static readonly string MatchStarted = nameof(MatchStarted);
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static class Events     {        public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);        public static readonly string Challenge = nameof(Challenge);        public
    static readonly string MatchStarted = nameof(MatchStarted);
- en: public static readonly string MatchUpdated = nameof(MatchUpdated);
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static readonly string MatchUpdated = nameof(MatchUpdated);
- en: '}'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE78]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct MatchUpdatedEventArgs(Match Match);
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct MatchUpdatedEventArgs(Match Match);
- en: '[PRE79]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[FunctionName("ProcessTurn")]public async Task<IActionResult> ProcessTurn('
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FunctionName("ProcessTurn")]public async Task<IActionResult> ProcessTurn('
- en: '[HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Game/Move")] HttpRequest
    req,'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Game/Move")] HttpRequest
    req,'
- en: ILogger log)
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ILogger log)
- en: '{}'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{}'
- en: '[PRE80]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: private Exception ValidateProcessTurnRequest(ProcessTurnRequest args)
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private Exception ValidateProcessTurnRequest(ProcessTurnRequest args)
- en: '{    return null;}'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{    return null;}'
- en: '[PRE81]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: private Exception VerifyMatchState(Match match, ProcessTurnRequest args)
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private Exception VerifyMatchState(Match match, ProcessTurnRequest args)
- en: '{    return null;}'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{    return null;}'
- en: '[PRE82]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: if (args.Position <= 0 || args.Position > 23)
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (args.Position <= 0 || args.Position > 23)
- en: '{'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return new IndexOutOfRangeException("Position is out of range, must be between
    1 and 24");}
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new IndexOutOfRangeException("位置超出范围，必须在1到24之间");}
- en: '[PRE83]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: if (args.Player is null){    return new ArgumentException("Invalid Player");}
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (args.Player is null){    return new ArgumentException("无效的玩家");}
- en: '[PRE84]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: if (args.MatchId == Guid.Empty){
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (args.MatchId == Guid.Empty){
- en: return new ArgumentException("Invalid MatchId");}
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new ArgumentException("无效的比赛ID");}
- en: '[PRE85]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: if (match.Sticks[args.Position] != 0){    return new ArgumentException($"Position
    [{args.Position}] has already been played");}
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (match.Sticks[args.Position] != 0){    return new ArgumentException($"位置
    [{args.Position}] 已经被玩过");}
- en: '[PRE86]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: if (args.Player.Id != game.NextPlayerId){    return new ArgumentException($"It
    is not {args.Player.GamerTag}'s turn");}
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (args.Player.Id != game.NextPlayerId){    return new ArgumentException($"现在不是
    {args.Player.GamerTag}'s 轮次");}
- en: '[PRE87]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: if (match.WinnerId != Guid.Empty){    return new ArgumentException("Match is
    complete");}
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (match.WinnerId != Guid.Empty){    return new ArgumentException("比赛已完成");}
- en: '[PRE88]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: if (match is null)
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (match is null)
- en: '{'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return new ArgumentException("Invalid MatchId");
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new ArgumentException("无效的MatchId");
- en: '}'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE89]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: var args = await JsonSerializer.DeserializeAsync<ProcessTurnRequest>(req.Body,
    jsonOptions);
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var args = await JsonSerializer.DeserializeAsync<ProcessTurnRequest>(req.Body,
    jsonOptions);
- en: '[PRE90]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: var error = ValidateProcessTurnRequest(args);
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var error = ValidateProcessTurnRequest(args);
- en: if (error is not null)
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (error is not null)
- en: '{'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: log.LogError(error, "Error validating turn request");
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogError(error, "验证回合请求时出错");
- en: return new BadRequestObjectResult(error);
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new BadRequestObjectResult(error);
- en: '}'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE91]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: using var context = contextFactory.CreateDbContext();
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: using var context = contextFactory.CreateDbContext();
- en: var game = (from g in context.Matches where m.Id == args.MatchId select m).FirstOrDefault()
    ?? throw new ArgumentException("Invalid MatchId.");
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var game = (from g in context.Matches where m.Id == args.MatchId select m).FirstOrDefault()
    ?? throw new ArgumentException("无效的MatchId.");
- en: '[PRE92]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: error = VerifyGameState(game, args);
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: error = VerifyGameState(game, args);
- en: if (error is not null)
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (error is not null)
- en: '{'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: log.LogError(error, "Error validating game state");
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogError(error, "验证游戏状态时出错");
- en: return new BadRequestObjectResult(error);
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new BadRequestObjectResult(error);
- en: '}'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE93]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: if (turnHandler.EndTurn(args.GameId) == TurnHandler.TurnStatus.Forfeit)
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (turnHandler.EndTurn(args.GameId) == TurnHandler.TurnStatus.Forfeit)
- en: '{'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: error = new ArgumentException($"The turn has expired.");
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: error = new ArgumentException($"The turn has expired.");
- en: log.LogError(error, $"Player did not respond in the time alloted.");
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogError(error, $"玩家未在规定时间内做出回应。");
- en: return new BadRequestObjectResult(error);
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new BadRequestObjectResult(error);
- en: '}'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE94]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: (int stone, int[] sticks)[][] stickToStoneMap = new (int, int[])[][] {/* 1 */
    new (int, int[])[] { (1, new int[] { 4, 5, 8}), (0, new int[] { 0, 0, 0})},/*
    2 */ new (int, int[])[] { (2, new int[] { 5, 6, 9}), (0, new int[] { 0, 0, 0})},/*
    3 */ new (int, int[])[] { (3, new int[] { 6, 7,10}), (0, new int[] { 0, 0, 0})},/*
    4 */ new (int, int[])[] { (1, new int[] { 1, 5, 8}), (0, new int[] { 0, 0, 0})},/*
    5 */ new (int, int[])[] { (1, new int[] { 1, 4, 8}), (2, new int[] { 2, 6, 9})},/*
    6 */ new (int, int[])[] { (2, new int[] { 2, 5, 9}), (3, new int[] { 3, 7,10})},/*
    7 */ new (int, int[])[] { (3, new int[] { 3, 6,10}), (0, new int[] { 0, 0, 0})},/*
    8 */ new (int, int[])[] { (1, new int[] { 1, 4, 5}), (4, new int[] {11,12,15})},/*
    9 */ new (int, int[])[] { (2, new int[] { 2, 5, 6}), (5, new int[] {12,13,16})},/*10
    */ new (int, int[])[] { (3, new int[] { 3, 6, 7}), (6, new int[] {13,14,17})},/*11
    */ new (int, int[])[] { (4, new int[] { 8,12,15}), (0, new int[] { 0, 0, 0})},/*12
    */ new (int, int[])[] { (4, new int[] { 8,11,15}), (5, new int[] { 9,13,16})},/*13
    */ new (int, int[])[] { (5, new int[] { 9,12,16}), (6, new int[] {10,14,17})},/*14
    */ new (int, int[])[] { (6, new int[] {10,13,17}), (0, new int[] { 0, 0, 0})},/*15
    */ new (int, int[])[] { (4, new int[] { 8,11,12}), (7, new int[] {18,19,22})},/*16
    */ new (int, int[])[] { (5, new int[] { 9,12,13}), (8, new int[] {19,20,23})},/*17
    */ new (int, int[])[] { (6, new int[] {13,14,17}), (9, new int[] {20,21,24})},/*18
    */ new (int, int[])[] { (7, new int[] {15,19,22}), (0, new int[] { 0, 0, 0})},/*19
    */ new (int, int[])[] { (7, new int[] {15,18,22}), (8, new int[] {16,20,23})},/*20
    */ new (int, int[])[] { (8, new int[] {16,19,23}), (9, new int[] {17,21,24})},/*21
    */ new (int, int[])[] { (9, new int[] {17,20,24}), (0, new int[] { 0, 0, 0})},/*22
    */ new (int, int[])[] { (7, new int[] {15,18,19}), (0, new int[] { 0, 0, 0})}, /*23
    */ new (int, int[])[] { (8, new int[] {16,19,20}), (0, new int[] { 0, 0, 0})},/*24
    */ new (int, int[])[] { (9, new int[] {17,20,21}), (0, new int[] { 0, 0, 0})},};
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: (int stone, int[] sticks)[][] stickToStoneMap = new (int, int[])[][] {/* 1 */
    new (int, int[])[] { (1, new int[] { 4, 5, 8}), (0, new int[] { 0, 0, 0})},/*
    2 */ new (int, int[])[] { (2, new int[] { 5, 6, 9}), (0, new int[] { 0, 0, 0})},/*
    3 */ new (int, int[])[] { (3, new int[] { 6, 7,10}), (0, new int[] { 0, 0, 0})},/*
    4 */ new (int, int[])[] { (1, new int[] { 1, 5, 8}), (0, new int[] { 0, 0, 0})},/*
    5 */ new (int, int[])[] { (1, new int[] { 1, 4, 8}), (2, new int[] { 2, 6, 9})},/*
    6 */ new (int, int[])[] { (2, new int[] { 2, 5, 9}), (3, new int[] { 3, 7,10})},/*
    7 */ new (int, int[])[] { (3, new int[] { 3, 6,10}), (0, new int[] { 0, 0, 0})},/*
    8 */ new (int, int[])[] { (1, new int[] { 1, 4, 5}), (4, new int[] {11,12,15})},/*
    9 */ new (int, int[])[] { (2, new int[] { 2, 5, 6}), (5, new int[] {12,13,16})},/*10
    */ new (int, int[])[] { (3, new int[] { 3, 6, 7}), (6, new int[] {13,14,17})},/*11
    */ new (int, int[])[] { (4, new int[] { 8,12,15}), (0, new int[] { 0, 0, 0})},/*12
    */ new (int, int[])[] { (4, new int[] { 8,11,15}), (5, new int[] { 9,13,16})},/*13
    */ new (int, int[])[] { (5, new int[] { 9,12,16}), (6, new int[] {10,14,17})},/*14
    */ new (int, int[])[] { (6, new int[] {10,13,17}), (0, new int[] { 0, 0, 0})},/*15
    */ new (int, int[])[] { (4, new int[] { 8,11,12}), (7, new int[] {18,19,22})},/*16
    */ new (int, int[])[] { (5, new int[] { 9,12,13}), (8, new int[] {19,20,23})},/*17
    */ new (int, int[])[] { (6, new int[] {13,14,17}), (9, new int[] {20,21,24})},/*18
    */ new (int, int[])[] { (7, new int[] {15,19,22}), (0, new int[] { 0, 0, 0})},/*19
    */ new (int, int[])[] { (7, new int[] {15,18,22}), (8, new int[] {16,20,23})},/*20
    */ new (int, int[])[] { (8, new int[] {16,19,23}), (9, new int[] {17,21,24})},/*21
    */ new (int, int[])[] { (9, new int[] {17,20,24}), (0, new int[] { 0, 0, 0})},/*22
    */ new (int, int[])[] { (7, new int[] {15,18,19}), (0, new int[] { 0, 0, 0})}, /*23
    */ new (int, int[])[] { (8, new int[] {16,19,20}), (0, new int[] { 0, 0, 0})},/*24
    */ new (int, int[])[] { (9, new int[] {17,20,21}), (0, new int[] { 0, 0, 0})},};
- en: '[PRE95]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'match.Sticks[args.Position] = args.Player.Id == match.PlayerOneId ? 1 : -1;'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'match.Sticks[args.Position] = args.Player.Id == match.PlayerOneId ? 1 : -1;'
- en: '[PRE96]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: if (args.Player.Id == game.PlayerOneId){    match.PlayerOneScore += 1;}else
    {    match.PlayerTwoScore += 1;}
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (args.Player.Id == game.PlayerOneId){    match.PlayerOneScore += 1;}else
    {    match.PlayerTwoScore += 1;}
- en: '[PRE97]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: // Determine if this play creates a square
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // Determine if this play creates a square
- en: foreach (var tuple in stickToStoneMap[args.Position])
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: foreach (var tuple in stickToStoneMap[args.Position])
- en: '{'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (tuple.stone == 0) continue;
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (tuple.stone == 0) continue;
- en: var stickCompletesABox =
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: var stickCompletesABox =
- en: (
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (
- en: Math.Abs(match.Sticks[tuple.sticks[0] - 1]) +
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Math.Abs(match.Sticks[tuple.sticks[0] - 1]) +
- en: Math.Abs(match.Sticks[tuple.sticks[1] - 1]) +
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Math.Abs(match.Sticks[tuple.sticks[1] - 1]) +
- en: Math.Abs(match.Sticks[tuple.sticks[2] - 1])
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Math.Abs(match.Sticks[tuple.sticks[2] - 1])
- en: ) == 3;
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ) == 3;
- en: if (stickCompletesABox)
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (stickCompletesABox)
- en: '{'
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: // If so, place stone, and adjust score
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // If so, place stone, and adjust score
- en: 'var player = args.Player.Id == match.PlayerOneId ? 1 : -1;'
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var player = args.Player.Id == match.PlayerOneId ? 1 : -1;'
- en: match.Stones[tuple.stone - 1] = player;
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: match.Stones[tuple.stone - 1] = player;
- en: if (player > 0)
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (player > 0)
- en: '{'
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: match.PlayerOneScore += 5;
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: match.PlayerOneScore += 5;
- en: '}'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: match.PlayerTwoScore += 5;
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: match.PlayerTwoScore += 5;
- en: '}'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE98]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: private static bool AllSticksHaveBeenPlayed(Match match)
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private static bool AllSticksHaveBeenPlayed(Match match)
- en: '{'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return !(from s in match.Sticks where s == 0 select s).Any();
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return !(from s in match.Sticks where s == 0 select s).Any();
- en: '}'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE99]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: private static int HasThreeInARow(List<int> stones){    for (var rc = 0; rc
    < 3; rc++)    {        var rowStart = rc * 3;        var rowValue = stones[rowStart]
    + stones[rowStart + 1] + stones[rowStart + 2];        if (Math.Abs(rowValue) ==
    3) // we Have a winner!        {            return rowValue;        }        var
    colStart = rc;        var colValue = stones[colStart] + stones[colStart + 3] +
    stones[colStart + 6];        if (Math.Abs(colValue) == 3) // We have a winner!        {            return
    colValue ;        }    }    var tlbrValue = stones[0] + stones[4] + stones[8];    var
    trblValue = stones[2] + stones[4] + stones[6];    if (Math.Abs(tlbrValue) == 3)
    { return tlbrValue; }    if (Math.Abs(trblValue) == 3) { return trblValue; }    return
    0;}
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private static int HasThreeInARow(List<int> stones){    for (var rc = 0; rc
    < 3; rc++)    {        var rowStart = rc * 3;        var rowValue = stones[rowStart]
    + stones[rowStart + 1] + stones[rowStart + 2];        if (Math.Abs(rowValue) ==
    3) // we Have a winner!        {            return rowValue;        }        var
    colStart = rc;        var colValue = stones[colStart] + stones[colStart + 3] +
    stones[colStart + 6];        if (Math.Abs(colValue) == 3) // We have a winner!        {            return
    colValue ;        }    }    var tlbrValue = stones[0] + stones[4] + stones[8];    var
    trblValue = stones[2] + stones[4] + stones[6];    if (Math.Abs(tlbrValue) == 3)
    { return tlbrValue; }    if (Math.Abs(trblValue) == 3) { return trblValue; }    return
    0;}
- en: '[PRE100]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: // Does one player have 3 stones in a row?
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // Does one player have 3 stones in a row?
- en: var winner = Guid.Empty;
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var winner = Guid.Empty;
- en: var threeInARow = HasThreeInARow(match.Stones);
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var threeInARow = HasThreeInARow(match.Stones);
- en: if (threeInARow != 0)
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (threeInARow != 0)
- en: 'winner = threeInARow > 0 ? match.PlayerOneId : match.PlayerTwoId;'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'winner = threeInARow > 0 ? match.PlayerOneId : match.PlayerTwoId;'
- en: if (winner == Guid.Empty) // No Winner yet
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (winner == Guid.Empty) // No Winner yet
- en: '{'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: // Have all sticks been played, if yes, use top score.
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // Have all sticks been played, if yes, use top score.
- en: if (HaveAllSticksBeenPlayed(match))
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (HaveAllSticksBeenPlayed(match))
- en: '{'
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'winner = match.PlayerOneScore > match.PlayerTwoScore ? match.PlayerOneId :
    match.PlayerTwoId;'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'winner = match.PlayerOneScore > match.PlayerTwoScore ? match.PlayerOneId :
    match.PlayerTwoId;'
- en: '}'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE101]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: if (winner == Guid.Empty)
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (winner == Guid.Empty)
- en: '{'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'match.NextPlayerId = args.Player.Id == match.PlayerOneId ? match.PlayerTwoId
    : match.PlayerOneId;'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'match.NextPlayerId = args.Player.Id == match.PlayerOneId ? match.PlayerTwoId
    : match.PlayerOneId;'
- en: '}'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: match.NextPlayerId = Guid.Empty;
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: match.NextPlayerId = Guid.Empty;
- en: match.WinnerId = winner;
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: match.WinnerId = winner;
- en: match.Completed = true;
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: match.Completed = true;
- en: '}'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE102]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: private async Task SaveMatchAndSendUpdates(GameDbContext context, Match match)
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private async Task SaveMatchAndSendUpdates(GameDbContext context, Match match)
- en: '{'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: context.Matches.Update(match);
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.Matches.Update(match);
- en: await context.SaveChangesAsync();
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await context.SaveChangesAsync();
- en: await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchUpdated,
    new MatchUpdatedEventArgs(match));
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchUpdated,
    new MatchUpdatedEventArgs(match));
- en: if (match.Completed)
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (match.Completed)
- en: '{'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: await UserGroups.RemoveFromGroupAsync(match.PlayerOneId.ToString(), $"Match[{match.Id}]");
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await UserGroups.RemoveFromGroupAsync(match.PlayerOneId.ToString(), $"Match[{match.Id}]");
- en: await UserGroups.RemoveFromGroupAsync(game.PlayerTwoId.ToString(), $"Match[{match.Id}]");
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await UserGroups.RemoveFromGroupAsync(game.PlayerTwoId.ToString(), $"Match[{match.Id}]");
- en: '}'
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE103]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: await SaveMatchAndSendUpdates(context, match);
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: await SaveMatchAndSendUpdates(context, match);
- en: return new OkObjectResult(new ProcessTurnResponse(match));
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new OkObjectResult(new ProcessTurnResponse(match));
- en: '[PRE104]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: error = VerifyMatchState(game, args);
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: error = VerifyMatchState(game, args);
- en: if (error is not null)
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (error is not null)
- en: '{'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: await SaveMatchAndSendUpdates(game);
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: await SaveMatchAndSendUpdates(game);
- en: log.LogError(error, "Error validating match state.");
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: log.LogError(error, "Error validating match state.");
- en: return new BadRequestObjectResult(error);
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new BadRequestObjectResult(error);
- en: '}'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE105]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
