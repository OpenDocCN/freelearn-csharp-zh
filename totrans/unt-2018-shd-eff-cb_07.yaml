- en: Fragment Shaders and Grab Passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have relied on Surface Shaders. They have been designed to simplify
    the way shader coding works, providing meaningful tools for artists. If we want
    to push our knowledge of shaders further, we need to venture into the territory
    of Vertex and Fragment Shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vertex and Fragment Shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using grab passes to draw behind objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Glass Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Water Shader for 2D games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compared to Surface Shaders, Vertex and Fragment Shaders come with little to
    no information about the physical properties that determine how light reflects
    on surfaces. What they lack in expressivity, they compensate for with power: Vertex
    and Fragment Shaders are not limited by physical constraints and are perfect for
    non-photorealistic effects. This chapter will focus on a technique called the
    **grab pass**, which allows these shaders to simulate deformations.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vertex and Fragment Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to understand how Vertex and Fragment Shaders work is by creating
    one yourself. This recipe will show you how to write one of these shaders, which
    will simply apply a texture to a model and multiply it by a given color, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how it works similarly to how the Multiply filter in Photoshop works.
    That's because we will be doing the same calculation done there!
  prefs: []
  type: TYPE_NORMAL
- en: The shader presented here is very simple, and it will be used as a starting
    base for all the other Vertex and Fragment Shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will need a new shader. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader (`Multiply`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material (`MultiplyMat`) and assign the shader to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring the soldier prefab from the `Chapter 06 `| `Prefabs` folder into the scene,
    and attach the new material to the prefab's head. The head can be found in the
    `Soldier` child of the `Soldier` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, in the Inspector tab, scroll down to the Skinned Mesh Renderer
    component and, under Materials, set Element 0 to the new materials. Lastly, in
    the `Albedo (RGB)` property, drag and drop the `Unity_soldier_Head_DIF_01` texture.
    The following screenshot should help demonstrate what we are looking for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In all the previous chapters, we have always been able to refit Surface Shaders.
    This is not the case any more, as Surface and Fragment Shaders are structurally
    different. We will need to implement the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete all the properties of the shader, replacing them with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete all the code in the `SubShader` block and replace it with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your shader script and return to the Unity editor. Once finished, modify
    the Color property of the `MultiplyMat` material and see that we get the result
    we are looking for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will also be the base for all future Vertex and Fragment Shaders.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, Vertex and Fragment Shaders work in two steps. The model
    is first passed through a vertex function; the result is then inputted to a Fragment
    function. Both these functions are assigned using `#pragma` directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, they are simply called `vert` and `frag`.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually speaking, fragments are closely related to pixels; the term fragment
    is often used to refer to the collection of data necessary to draw a pixel. This
    is also why Vertex and Fragment Shaders are often called **Pixel Shaders**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex function takes the input data in a structure that is defined as
    `vertInput` in the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Its name is totally arbitrary, but its content is not. Each field of the `struct`
    must be decorated with a **binding semantic**. This is a feature of Cg that allows
    us to mark variables so that they will be initialized with certain data, such
    as normal vectors and the vertex position. The binding semantic, `POSITION`, indicates
    that when `vertInput` is inputted to the vertex function, `pos` will contain the
    position of the current vertex. This is similar to the vertex field of the `appdata_full`
    structure in a Surface Shader. The main difference is that `pos` is represented
    in model coordinates (relative to the 3D object), which we need to convert to
    view coordinates manually (relative to the position on the screen).
  prefs: []
  type: TYPE_NORMAL
- en: The vertex function in a Surface Shader is used to alter the geometry of the
    model only. In a Vertex and Fragment Shader, instead, the vertex function is necessary
    to project the coordinates of the model to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mathematics behind this conversion is beyond the scope of this chapter.
    However, this transformation can be achieved by using the `UnityObjectToClipPos`
    function, which will take a point from object space to the camera''s clip space
    in homogeneous coordinates. This is done by multiplying by the **model-view-projection
    matrix**, and it is essential to find the position of a vertex on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this and other helper functions that ShaderLab has built-in,
    check out [https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html](https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other piece of information initialized is `textcoord`, which uses the `TEXCOORD0`
    binding semantics to get the UV data of the first texture. No further processing
    is required, and this value can be passed directly to the fragment function (`frag`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While Unity will initialize `vertInput` for us, we are responsible for the
    initialization of `vertOutput`. Despite this, its fields still need to be decorated
    with binding semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once the vertex function has initialized `vertOutput`, the structure is passed
    to the fragment function (`frag`). This samples the main texture of the model
    and multiplies it by the color provided.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Vertex and Fragment Shader have no knowledge of the physical
    properties of the material. This means that the material does not have the same
    effect by light sources, and it does not have data regarding how light reflects
    to create bumped surfaces compared to a Surface Shader; it works closer to the
    architecture of the graphics GPU.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most confusing aspects of Vertex and Fragment Shaders is binding
    semantics. There are many others that you can use, and their meanings depend on
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Input semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The binding semantics in the following table can be used in `vertInput`, which
    is the structure that Unity provides to the vertex function. The fields decorated
    with this semantics will be initialized automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binding semantics** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POSITION`, `SV_POSITION` | The position of a vertex in world coordinates
    (object space) |'
  prefs: []
  type: TYPE_TB
- en: '| `NORMAL` | The normal of a vertex, relative to the world (not to the camera)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `COLOR`, `COLOR0`, `DIFFUSE`, `SV_TARGET` | The color information stored
    in the vertex |'
  prefs: []
  type: TYPE_TB
- en: '| `COLOR1`, `SPECULAR` | The secondary color information stored in the vertex
    (usually the specular) |'
  prefs: []
  type: TYPE_TB
- en: '| `TEXCOORD0`, `TEXCOORD1`, …, `TEXCOORDi` | The i-th UV data stored in the
    vertex |'
  prefs: []
  type: TYPE_TB
- en: Output semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When binding, semantics are used in `vertOutput`; they do not automatically
    guarantee that fields will be initialized. Quite the opposite; it''s our responsibility
    to do so. The compiler will do its best to ensure that the fields are initialized
    with the right data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binding semantics** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POSITION`, `SV_POSITION`, `HPOS` | The position of a vertex in camera coordinates
    (clip space, from zero to one for each dimension) |'
  prefs: []
  type: TYPE_TB
- en: '| `COLOR`, `COLOR0`, `COL0`, `COL`, `SV_TARGET` | The front primary color |'
  prefs: []
  type: TYPE_TB
- en: '| `COLOR1`, `COL1` | The front secondary color |'
  prefs: []
  type: TYPE_TB
- en: '| `TEXCOORD0`, `TEXCOORD1`, …, `TEXCOORDi`, `TEXi` | The i-th UV data stored
    in the vertex |'
  prefs: []
  type: TYPE_TB
- en: '| `WPOS` | The position, in pixels, in the window (origin in the lower left
    corner) |'
  prefs: []
  type: TYPE_TB
- en: If, for any reason, you need a field that will contain a different type of data,
    you can decorate it with one of the many `TEXCOORD` data available. The compiler
    will not allow fields to be left undecorated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the NVIDIA Reference Manual to check the other binding semantics
    that are available in Cg:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf](http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the grab pass to draw behind objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Adding transparency to PBR* recipe of [Chapter 5](part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08), *Physically-Based
    Rendering*, we have seen how a material can be made transparent. Even if a transparent
    material can draw over a scene, it cannot change what has been drawn underneath
    it. This means that those Transparent Shaders cannot create distortions such as
    the ones typically seen in glass or water. In order to simulate them, we need
    to introduce another technique called a grab pass. This allows us to access what
    has been drawn on-screen so far, so that a shader can use it (or alter it) with
    no restrictions. To learn how to use grab passes, we will create a material that
    grabs what's rendered behind it and draws it again on the screen. It's a shader
    that, paradoxically, uses several operations to show no changes at all.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a shader (`GrabShader`) that we will initialize later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a material (`GrabMat`) to host the shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the material to a flat piece of geometry, such as a quad. Place it in
    front of some other object so that you cannot see through it. The quad will appear
    transparent as soon as the shader is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a grab pass, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `Properties` section, and the `Input` section; this shader will not
    use any of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `SubShader` section, remove everything, and add the following to ensure
    the object is treated as being `Transparent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below that, add a grab pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `GrabPass`, we will need to add this extra pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and return to the Unity editor. Upon getting back, you should
    notice your material now works the way you intend it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe not only introduces grab passes, but also Vertex and Fragment Shaders;
    for this reason, we have to analyze the shader in detail.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the code has always been placed directly in the `SubShader` section.
    This is because our previous shaders required only a single pass. This time, two
    passes are required. The first one is the `GrabPass{}`, which is defined simply
    by `GrabPass{}`. The rest of the code is placed in the second pass, which is contained
    in a `Pass` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second pass is not structurally different from the shader shown in the
    first recipe of this chapter; we use the vertex function, `vert`, to get the position
    of the vertex, and then we give it a color in the Fragment function frag. The
    difference is that vert calculates another important detail: the UV data for the
    `GrabPass{}`. The `GrabPass{}` automatically creates a texture that can be referred
    to as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to sample this texture, we need its UV data. The `ComputeGrabScreenPos`
    function returns data that we can use later to sample the grab texture correctly.
    This is done in the Fragment Shader using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the standard way in which a texture is grabbed and applied to the screen
    in its correct position. If everything has been done correctly, this shader will
    simply clone what has been rendered behind the geometry. We will see in the following
    recipes how this technique can be used to create materials such as water and glass.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time you use a material with `GrabPass{}`, Unity will have to render
    the screen to a texture. This operation is very expensive and limits the number
    of `GrabPass` instances that you can use in a game. Cg offers a slightly different
    variation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This line not only allows you to give a name to the texture, but also shares
    the texture with all the materials that have a `GrabPass` called `TextureName`.
    This means that if you have ten materials, Unity will only do a single `GrabPass`
    and share the texture with all of them. The main problem of this technique is
    that it doesn't allow for effects that can be stacked. If you are creating a glass
    with this technique, you won't be able to have two glasses one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Glass Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Glass is a very complicated material; it should not be a surprise that other
    chapters have already created shaders to simulate it in the *Adding transparency
    to PBR* recipe of [Chapter 5](part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08), *Physically-Based
    Rendering*. We already know how to make our glasses semi-transparent to show the
    objects behind it perfectly and that works for a number of applications. However,
    most glasses are not perfect. For instance, if you look through a stain glass
    window you may notice distortions or deformations when you look through them.
    This recipe will teach you how to achieve that effect. The idea behind this effect
    is to use a Vertex and Fragment Shader with a `GrabPass`, and then sample the
    grab texture with a little change to its UV data to create a distortion. You can
    see the effect in the following screenshot, using the glass-stained textures from
    the Unity Standard Assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The setup for this recipe is similar to the one presented previously in [Chapter
    6](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08), *Vertex Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Vertex and Fragment Shader. You can start by copying the one used
    in the previous recipe, *Using the grab pass to draw behind objects*, as a base
    by selecting it and hitting *Ctrl*+*D* to duplicate it. Once duplicated, change
    its name to `WindowShader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a material that will use the shader (`WindowMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the material to a quad or another flat geometry that will simulate your
    glass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place some objects behind it so that you can see the distortion effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by editing the Vertex and Fragment Shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Properties` block with these items in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add their variables in the second pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the texture information to the input and output structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer the UV data from the input to the output structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following Fragment function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This material is transparent, so it changes its tags in the `SubShader` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left now is to set the texture for the glass, and for a normal map
    to displace the grab texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core that this shader uses is a grab pass to take what has already been
    rendered on the screen. The part where the distortion takes place is in the Fragment
    function. Here, a normal map is unpacked and used to offset the UV data of the
    grab texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_Magnitude` slider is used to determine how strong the effect is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This effect is very generic; it grabs the screen and creates a distortion based
    on a normal map. There is no reason why it shouldn't be used to simulate more
    interesting things. Many games use distortions around explosions or other sci-fi
    devices. This material can be applied to a sphere and, with a different normal
    map, it would simulate the heat wave of an explosion perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Water Shader for 2D games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Glass Shader introduced in the previous recipe is static; its distortion
    never changes. It takes just a few changes to convert it to an animated material,
    making it perfect for 2D games that feature water. This uses a similar technique
    to the one shown in [Chapter 6](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08), *Vertex
    Functions*, in the recipe entitled *Animating Vertices in a Surface Shader*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is based on the Vertex and Fragment Shaders described in the *Using
    the grab pass to draw behind objects* recipe, as it will rely heavily on `GrabPass`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Vertex and Fragment Shader. You can start by copying the one used
    in the previous recipe, *Using the grab pass to draw behind objects*, as a base
    by selecting it and hitting *Ctrl*+*D* to duplicate it. Once duplicated, change
    its name to `WaterShader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a material that will use the shader (`WaterMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the material to a flat geometry that will represent your 2D water. In
    order for this effect to work, you should have something rendered behind it so
    that you can see the water-like displacement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This recipe requires a noise texture, which is used to get pseudo-random values.
    It is important that you choose a seamless noise texture, such as the ones generated
    by tileable 2D Perlin noise, as shown in the following screenshot. This ensures
    that when the material is applied to a large object, you will not see any discontinuity.
    In order for this effect to work, the texture has to be imported in Repeat mode.
    If you want a smooth and continuous look for your water, you should also set it
    to Bilinear from Inspector. These settings ensure that the texture is sampled
    correctly from the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can find an example noise texture in `Chapter 6` | `Textures` folder of
    the book's example code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create this animated effect, you can start by refitting the shader. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add their respective variables to the second pass of the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the following input and output structures for the vertex function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This shader needs to know the exact position of the space of every fragment.
    To do this, update the vertex function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following Fragment function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Save your script and return to the Unity editor. Afterward, select your Water
    Material (`WatMat`)and apply the noise texture. Afterward, tweak the properties
    in the Water Material and notice how it modifies the things behind it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shader is very similar to the one introduced in the *Implementing a Glass
    Shader* recipe. The major difference is that this is an animated material; the
    displacement is not generated from a normal map, but takes into account the current
    time in order to create a constant animation. The code that displaces the UV data
    of the grab texture seems quite complicated; let''s try to understand how it has
    been generated. The idea behind it is that a sinusoid function is used to make
    the water oscillate. This effect needs to evolve over time; to achieve this effect,
    the distortion generated by the shader depends on the current time that is retrieved
    with the built-in variable, `_Time`. The `_Period` variable determines the period
    of the sinusoid, which means how fast the waves appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that you have the same displacement on the *X*
    and *Y* axes; as a result, the entire grab texture will rotate in a circular motion,
    which looks nothing like water. We obviously need to add some randomness to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to add random behaviors to shaders is by including a noise
    texture. The problem now is to find a way to sample the texture at seemingly random
    positions. The best way to avoid seeing an obvious sinusoid pattern is to use
    the sine waves as an offset in the UV data of the `_NoiseTex` texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_Scale` variable determines the size of the waves. This solution is closer
    to the final version but has a severe issue—if the water quad moves, the UV data
    follows it and you can see the water waves following the material rather than
    being anchored to the background. To solve this, we need to use the world position
    of the current fragment as the initial position for the UV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result is a pleasant, seamless distortion, which doesn't move in any clear
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also improve the readability of the code by breaking apart the distortion
    into smaller steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That is what you should see in the final result.
  prefs: []
  type: TYPE_NORMAL
- en: As happens with all these special effects, there is no perfect solution. This
    recipe shows you a technique to create water-like distortion, but you are encouraged
    to play with it until you find an effect that fits the aesthetics of your game.
  prefs: []
  type: TYPE_NORMAL
