- en: '*Chapter 4*: Memory Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：内存管理'
- en: In this chapter, we will be looking at object generations and how to avoid memory
    issues, followed by a discussion on strong and weak references. Then, we will
    look at finalization and how we can suppress finalization by implementing the
    `IDisposable` pattern to clean up managed and unmanaged resources. Finally, we
    will take a high-level look at ways to avoid memory leaks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨对象生成以及如何避免内存问题，然后讨论强引用和弱引用。接着，我们将探讨终结器以及如何通过实现 `IDisposable` 模式来抑制终结器，以清理托管和非托管资源。最后，我们将从高层次上探讨避免内存泄漏的方法。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '`System.OutOfMemoryException`. We learn how to predict out-of-memory errors
    before they happen by using the `System.Runtime.MemoryFailPoint` class.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.OutOfMemoryException`. 我们学习如何在内存耗尽错误发生之前预测它们，通过使用 `System.Runtime.MemoryFailPoint`
    类。'
- en: '**Understanding long and short weak references**: In this section, we learn
    about long and short weak references and how they are affected by the garbage
    collector.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解长弱引用和短弱引用**：在本节中，我们了解长弱引用和短弱引用以及它们如何受到垃圾收集器的影响。'
- en: '**Finalization**: In this section, we look at how to use finalizers to clean
    up resources, and understand why we have no control over if and when they will
    run.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终结器**：在本节中，我们探讨如何使用终结器来清理资源，并理解为什么我们对它们何时以及是否运行没有控制权。'
- en: '`IDisposable` pattern.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDisposable` 模式。'
- en: '**Preventing memory leaks**: In this section, we look at how the use of the
    **Component Object Model** (**COM**) and managed events can be sources that generate
    memory leaks and what we can do to avoid memory leaks from being generated. We
    will be using Microsoft Excel and JetBrains dotMemory in this section to see how
    leaks can be generated and to see how using a memory profiler can be very useful
    in identifying memory leaks and their sources.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止内存泄漏**：在本节中，我们探讨使用 **组件对象模型**（**COM**）和托管事件可能成为产生内存泄漏的来源，以及我们可以采取哪些措施来避免产生内存泄漏。在本节中，我们将使用
    Microsoft Excel 和 JetBrains dotMemory 来查看如何产生泄漏，以及使用内存分析器如何非常有用，可以帮助识别内存泄漏及其来源。'
- en: 'By the end of this chapter, you will have gained skills in the following areas:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将在以下领域获得技能：
- en: Understanding object generations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象生成
- en: Understanding how objects are disposed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象如何被销毁
- en: Understanding why it is best to avoid finalizers and implement `IDisposable`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么最好避免终结器并实现 `IDisposable`
- en: Understanding how to prevent memory leaks arising from the use of unmanaged
    COM libraries and components and from using events
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何防止由于使用非托管 COM 库和组件以及使用事件而产生的内存泄漏
- en: Using anonymous methods, long weak references, and short weak references to
    improve garbage collection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名方法、长弱引用和短弱引用来提高垃圾收集
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the steps in this chapter, there are some technical requirements,
    as outlined here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章中的步骤，有一些技术要求，如下所述：
- en: Visual Studio 2022
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: JetBrains dotMemory
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains dotMemory
- en: 'Source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04)
- en: Object generations and avoiding memory issues
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象生成和避免内存问题
- en: 'There are three object generations in the .NET runtime, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 运行时中，有三个对象生成，如下所示：
- en: Generation 0
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 0
- en: Generation 1
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 1
- en: Generation 2
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 2
- en: Generation 0 is the youngest generation and holds short-lived objects. Objects
    that are less than 80,000 bytes are generation 0 objects that get placed on the
    **small object heap** (**SOH**) when they are instantiated. Objects that are 80,000
    bytes or larger are usually generation 2 objects and live on the **large object
    heap** (**LOH**). Generation 1 objects are those objects that survived generation
    0 garbage collection and received a promotion to generation 1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 0 是最年轻的生成，包含短生命周期的对象。小于 80,000 字节的对象是生成 0 对象，当它们被实例化时会被放置在 **小型对象堆**（**SOH**）上。80,000
    字节或更大的对象通常是生成 2 对象，它们存在于 **大型对象堆**（**LOH**）上。生成 1 对象是那些在生成 0 垃圾收集中存活下来的对象，并晋升到生成
    1。
- en: Generation 0 is where most of the garbage collection takes place. Objects that
    do not get collected when they are generation 0 will get promoted to generation
    1 to make room for more generation 0 objects to be added to the heap. If generation
    0 and 1 become full, then generation 1 objects are promoted to generation 2, and
    generation 0 objects are promoted to generation 1\. If generations 0, 1, and 2
    become full so that no more objects can be added to the heap, you then end up
    with a `System.OutOfMemoryException`-type exception.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成0是垃圾回收主要发生的地方。当对象在生成0时没有被回收，它们将被提升到生成1以腾出空间，让更多的生成0对象能够添加到堆中。如果生成0和1都满了，那么生成1的对象将被提升到生成2，而生成0的对象将被提升到生成1。如果生成0、1和2都满了，以至于不能再向堆中添加更多对象，那么你最终会得到一个`System.OutOfMemoryException`类型的异常。
- en: 'We are now going to write a very simple program that will throw a `System.OutOfMemoryException`-type
    exception. Follow these next steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个非常简单的程序，该程序将抛出一个`System.OutOfMemoryException`类型的异常。请按照以下步骤操作：
- en: 'Start a new .NET 6 console application project called `CH04_OutOfMemoryExceptions`.
    Add the following `using` statements to the `Program.cs` file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的.NET 6控制台应用程序项目，命名为`CH04_OutOfMemoryExceptions`。将以下`using`语句添加到`Program.cs`文件中：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following method calls to the `Main` method:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法调用添加到`Main`方法中：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `DataExportToCsv()` method builds up a very large data file. `ReadCsvBroken()`
    reads in the `System.OutOfMemoryException`-type exception. The exception is avoided
    in the `ReadCsvPredictive()` method, as the method instantiates the `MemoryFailPoint`
    class to ensure that the data read of the file will not generate an exception.
    If the operation does generate a `System.OutOfMemory exception`-type exception,
    then the `MemoryFailPoint` object will raise an `OutOfMemoryException`-type exception.
    This saves memory, time, `Program` class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DataExportToCsv()`方法构建一个非常大的数据文件。`ReadCsvBroken()`读取`System.OutOfMemoryException`类型的异常。在`ReadCsvPredictive()`方法中避免了异常，因为该方法实例化了`MemoryFailPoint`类以确保读取的文件数据不会生成异常。如果操作生成了`System.OutOfMemoryException`类型的异常，那么`MemoryFailPoint`对象将引发一个`OutOfMemoryException`类型的异常。这节省了内存和时间，`Program`类：'
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will be the file we will write to and read from. Add the following `DataExportToCsv()`
    method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将是我们将写入和读取的文件。添加以下`DataExportToCsv()`方法：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code writes 491,616,373 lines of data to a CSV file. Add the following
    `ReadCsvBroken()` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码将491,616,373行数据写入CSV文件。添加以下`ReadCsvBroken()`方法：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ReadCsvBroken()` method tries to read the massive 44.2 `string` variable.
    This operation throws a `System.OutOfMemoryException`-type exception. Add the
    following `ReadCsvPredictive()` method:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadCsvBroken()`方法尝试读取巨大的44.2`string`变量。此操作抛出一个`System.OutOfMemoryException`类型的异常。添加以下`ReadCsvPredictive()`方法：'
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code uses predictive memory checking using the `MemoryFailPoint` class.
    We show it working for the `alphabet` string, and we show that it highlights an
    error and fails with an `OutOfMemoryException`-type exception when the length
    of the file contents is assigned to the `length` variable that is passed into
    the `MemoryFailPoint` constructor. We use the unchecked struct since the length
    of the file is a long value, and this value to too big to be assigned to an `int`
    data type. If we used the checked struct instead, we would have an `ArithmeticOverflowException`-type
    exception.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码使用`MemoryFailPoint`类进行预测性内存检查。我们展示了它对`alphabet`字符串的工作情况，并展示了当文件内容的长度被分配给传递给`MemoryFailPoint`构造函数的`length`变量时，它会突出显示一个错误并以`OutOfMemoryException`类型的异常失败。我们使用未检查的结构体，因为文件长度是一个长值，而这个值太大，无法分配给`int`数据类型。如果我们使用检查的结构体，则会抛出一个`ArithmeticOverflowException`类型的异常。
- en: Building and running the code takes hours. I recommend you build the code in
    `Release` mode, and then run the executable from a command window. The code will
    successfully build up the CSV file and save it. When the file contents are read
    all at once, they will generate an `OutOfMemoryException`-type exception. Then,
    the program will do a precheck prior to loading the file and will fail before
    the file read is attempted with a more detailed `OutOfMemoryException`-type exception.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行代码需要数小时。我建议你在`Release`模式下编译代码，然后从命令窗口运行可执行文件。代码将成功构建CSV文件并将其保存。当一次性读取文件内容时，将生成一个`OutOfMemoryException`类型的异常。然后，程序将在加载文件之前进行预检查，并在尝试读取文件之前失败，并抛出一个更详细的`OutOfMemoryException`类型的异常。
- en: Predicting memory exceptions saves time and improves application performance,
    as you are not wasting CPU cycles and memory performing an operation that is ultimately
    going to fail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 预测内存异常可以节省时间并提高应用程序性能，因为你不会浪费 CPU 周期和内存来执行最终会失败的操作。
- en: We have seen how easy it is for an application to run out of memory and how
    we can predict and prevent memory exceptions. So, let’s now move on to discuss
    strong and weak references.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到应用程序如何容易耗尽内存，以及我们如何预测和预防内存异常。现在，让我们继续讨论强引用和弱引用。
- en: Understanding long and short weak references
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解长弱引用和短弱引用
- en: 'In the .NET runtime, there are two types of references: **long weak references**
    and **short weak references**. These are described in more detail here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 运行时，有两种类型的引用：**长弱引用**和**短弱引用**。这些在这里有更详细的描述：
- en: '`Finalize()` method has been called on an object, a long weak reference is
    retained in memory. You specify `true` in the `WeakReference` constructor to define
    a long reference. A long weak reference can be recreated, although its state can
    be unpredictable. A short weak reference will be applied when an object’s type
    does not have a `Finalize()` method. The weak reference will only remain until
    its target is collected sometime after the finalizer is run. You will need to
    cast the target property of a `WeakReference` constructor to the type of an object
    if you want to create a strong weak reference that will be reused. When the object
    is collected, the `Target` property will be `null`. If it is not `null`, then
    you can continue to use the object because the application has regained a strong
    reference to it.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象的 `Finalize()` 方法被调用时，一个长弱引用会被保留在内存中。你可以在 `WeakReference` 构造函数中指定 `true`
    来定义一个长引用。长弱引用可以被重新创建，尽管其状态可能不可预测。当对象的类型没有 `Finalize()` 方法时，将应用短弱引用。弱引用将仅保持到其目标在最终化器运行后某个时间被回收。如果你想创建一个将被重用的强弱引用，你需要将
    `WeakReference` 构造函数的目标属性强制转换为对象的类型。当对象被回收时，`Target` 属性将是 `null`。如果它不是 `null`，那么你可以继续使用该对象，因为应用程序已经重新获得了对该对象的强引用。
- en: '`WeakReference` is a short weak reference. When the garbage collector reclaims
    a short weak reference, its target becomes `null`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakReference` 是一个短弱引用。当垃圾回收器回收一个短弱引用时，其目标变为 `null`。'
- en: A long weak reference protects referenced objects from garbage collection, and
    a short weak reference does not protect referenced objects from garbage collection.
    This means that when garbage collection executes, the long weak referenced objects
    will not be garbage-collected, but the short weak referenced objects will be garbage-collected.
    We will demonstrate this with a code example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 长弱引用可以保护引用对象免受垃圾回收的影响，而短弱引用则不能。这意味着当垃圾回收执行时，长弱引用的对象将不会被垃圾回收，但短弱引用的对象将会被垃圾回收。我们将通过代码示例来演示这一点。
- en: 'Our code example will show both long and short weak references at work. Follow
    these next steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例将展示长弱引用和短弱引用的工作原理。按照以下步骤进行：
- en: 'Start by adding a new .NET 6 console application called `CH04_WeakReferences`.
    Add the following class called `ReferenceObject`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个新的 .NET 6 控制台应用程序，名为 `CH04_WeakReferences`。添加以下名为 `ReferenceObject` 的类：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This class will be our reference object that we will be adding to two different
    object managers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将是我们将要添加到两个不同对象管理器中的引用对象。
- en: 'Add a new class called `LongWeakReferenceObjectManager`. Then, add the following
    list field:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `LongWeakReferenceObjectManager` 的新类。然后，添加以下列表字段：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our read-only `Objects` list will contain several `ReferenceObject` types.
    Now, add the following method to add items to the list:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的只读 `Objects` 列表将包含几种 `ReferenceObject` 类型。现在，添加以下方法来向列表中添加项：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method adds a `ReferenceObject` object to the list of reference objects.
    Then, the next task is to add a method that will print a list of stored objects
    to the console, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法将一个 `ReferenceObject` 对象添加到引用对象列表中。接下来的任务是添加一个将打印存储对象列表到控制台的方法，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ListObjects()` method prints out the contents of the list to the console
    window. That concludes our `LongWeakReferenceObjectManager` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListObjects()` 方法将列表的内容打印到控制台窗口。这就完成了我们的 `LongWeakReferenceObjectManager`
    类。'
- en: 'Now, add a class called `ShortWeakReferenceObjectManager`. At the top of the
    class, add the following list field:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为 `ShortWeakReferenceObjectManager` 的类。在类的顶部添加以下列表字段：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice with the list that the `ReferenceObject` object is wrapped in a `WeakReference`
    object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，列表中的 `ReferenceObject` 对象被包装在一个 `WeakReference` 对象中。
- en: 'Now, add a method to add items to the list, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个方法来向列表中添加项目，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method wraps the passed-in `ReferenceObject` object in a `WeakReference`
    object and assigns it to the list.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将传入的 `ReferenceObject` 对象包装在 `WeakReference` 对象中，并将其分配到列表中。
- en: 'We now add the `ListObjects()` method, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在添加 `ListObjects()` 方法，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ListObjects()` method prints out to the console window all the weak objects
    that are stored in the list. Our focus now moves to the `Program` class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListObjects()` 方法将打印出存储在列表中的所有弱引用对象。我们的关注点现在转向 `Program` 类。'
- en: 'Add the following two fields to the top of the `Program` class:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下两个字段添加到 `Program` 类的顶部：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are our read-only strong and weak object managers that we will use to
    demonstrate strong and weak references in action, with regard to the garbage collector.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将用于演示有关垃圾回收器的强引用和弱引用的只读强和弱对象管理器。
- en: 'Update the `Main(string[] _)` method by adding the following three method calls:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下三个方法调用来更新 `Main(string[] _)` 方法：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `TestLongWeakreferences()`, `TestStrongReferences()`, and `TestWeakReferences()`
    methods build up our lists of strong referenced objects and weak referenced objects
    respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestLongWeakreferences()`、`TestStrongReferences()` 和 `TestWeakReferences()`
    方法分别构建我们的强引用对象列表和弱引用对象列表。'
- en: 'Add the `TestStrongReferences()` method, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `TestStrongReferences()` 方法，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method adds three `ReferenceObject` objects to the `StrongReferences` list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法向 `StrongReferences` 列表添加三个 `ReferenceObject` 对象。
- en: 'Next, add the `TestWeakReferences()` method, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `TestWeakReferences()` 方法，如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method adds three weak referenced objects to the `WeakReferences` list
    and then sets the objects it instantiated to `null` so that they will be garbage-collected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法向 `WeakReferences` 列表添加三个弱引用对象，然后将其实例化的对象设置为 `null`，以便它们将被垃圾回收。
- en: 'Finally, add the `ProcessReferences()` method, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `ProcessReferences()` 方法，如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ProcesseReferences()` method loops 10 times. During each iteration, the
    `ListObjects()` method is called on the `StrongReferences` and `WeakReferences`
    fields. The program sleeps for 2 seconds, and then the garbage collector is executed
    manually.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcesseReferences()` 方法循环 10 次。在每次迭代中，对 `StrongReferences` 和 `WeakReferences`
    字段调用 `ListObjects()` 方法。程序休眠 2 秒，然后手动执行垃圾回收器。'
- en: 'It is now time to run the program. When you run the program, you should see
    the following output:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是运行程序的时候了。当你运行程序时，你应该看到以下输出：
- en: '![Figure 4.1 – Weak references’ project output'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 弱引用的项目输出'
- en: '](img/B16617_Figure_4.1.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_4.1.jpg)'
- en: Figure 4.1 – Weak references’ project output
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 弱引用的项目输出
- en: As you can see from *Figure 4.1*, on the first iteration of the loop, both strong
    and weak reference objects exist, and the names of those objects are printed in
    the console window. However, after garbage collection is called, the weak references
    are garbage-collected, and so, from the second iteration onward, only the strongly
    referenced objects remain in memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 4.1* 所示，在循环的第一迭代中，存在强引用和弱引用对象，并且那些对象的名称在控制台窗口中打印出来。然而，在调用垃圾回收后，弱引用被垃圾回收，因此，从第二次迭代开始，只有强引用对象保留在内存中。
- en: A weakly referenced object’s lifespan is not extended as it is for strong references.
    This means that they can be garbage-collected once all strong references have
    gone out of scope.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用对象的生命周期不会像强引用那样延长。这意味着一旦所有强引用超出作用域，它们就可以被垃圾回收。
- en: Objects that are large but cheap to rehydrate on-demand benefit from weak references.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大但按需重新加湿成本低的对象受益于弱引用。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To improve the performance of your applications, avoid using weak references
    on many small objects as they can take up more memory space than the objects they
    wrap, thus adding performance overhead. But if you are working with many large
    expensive objects, using cached weak references may help improve your application’s
    performance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高应用程序的性能，避免在许多小对象上使用弱引用，因为它们可能比它们包装的对象占用更多的内存空间，从而增加性能开销。但是，如果你正在处理许多大而昂贵的对象，使用缓存的弱引用可能有助于提高应用程序的性能。
- en: That concludes our look at strong and weak references. Let’s move our focus
    and attention to finalization in C#.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对强引用和弱引用的探讨。让我们将我们的关注点转向 C# 中的清理。
- en: Finalization
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: In C#, there is no direct way of destroying an object. The nearest thing we
    have is **finalization**. A finalizer in C# is the C# equivalent of a destructor
    in C++. Except in C#, you have no control over if and when it will run this down
    to the garbage collector to make that decision.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，没有直接销毁对象的方法。我们最接近的方法是 **终结化**。C# 中的终结器是 C++ 中析构函数的等价物。但在 C# 中，您无法控制它是否以及何时运行，直到垃圾回收器做出决定。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The terms *finalizer* and *destructor* are used interchangeably in C#. A finalizer
    is where the user-defined finalizer code is run. After the finalizer in an object
    is run, it is once again considered alive and the garbage collector will then
    finally collect the object. This means an object is actually marked “`collectable`”
    twice if it has a finalizer defined.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，*终结器* 和 *析构函数* 可以互换使用。终结器是用户定义的终结器代码运行的地方。在对象中的终结器运行之后，它再次被认为是活跃的，垃圾回收器随后将最终收集该对象。这意味着如果对象定义了终结器，它实际上会被标记为“`可收集`”两次。
- en: Finalization is used by an object to release resources and perform other housekeeping
    operations prior to the object being garbage-collected. Cleanup operations to
    release unmanaged resources held by an object can be performed by overriding the
    protected `Finalize()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对象使用终结化来释放资源并在对象被垃圾回收之前执行其他清理操作。可以通过重写受保护的 `Finalize()` 方法来执行释放对象持有的非托管资源的清理操作。
- en: You have to override the `Finalize()` method for the garbage collector to mark
    types derived from `Object` for finalization. When you override the `Finalize()`
    method, an entry for the instance is placed in a finalization queue. Before reclaiming
    memory, the `Finalize()` method is called for each object instance in the finalization
    queue. Once an object’s `Finalize()` method has been run, then its memory can
    be reclaimed by the garbage collector.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须重写 `Finalize()` 方法，以便垃圾回收器标记从 `Object` 派生的类型以进行终结化。当您重写 `Finalize()` 方法时，将为实例放置一个终结化队列中的条目。在回收内存之前，将为终结化队列中的每个对象实例调用
    `Finalize()` 方法。一旦对象的 `Finalize()` 方法运行完毕，垃圾回收器就可以回收其内存。
- en: The `Finalize()` method is not called if `GC.SupressFinalize()` has been called
    during the disposing of the object’s resources, but the `Finalize()` method will
    be called automatically when an object is discovered to be inaccessible, and during
    **application domain** (**AppDomain**) shutdown (even if the object is accessible).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在处理对象资源时调用了 `GC.SupressFinalize()`，则不会调用 `Finalize()` 方法，但如果发现对象不可访问，或者在 **应用程序域**（**AppDomain**）关闭期间（即使对象是可访问的），`Finalize()`
    方法将自动调用。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: AppDomains isolate applications from one another, but their usage is very expensive.
    In .NET 5+, some AppDomain `AssemblyLoadContext` class for dynamic assembly loading.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AppDomains 将应用程序彼此隔离，但它们的用法非常昂贵。在 .NET 5+ 中，有一些用于动态加载程序集的 `AssemblyLoadContext`
    类。
- en: '`Finalize()` methods only run once unless `GC.SuppressFinalize()` has not been
    called and `GC.ReRegisterForFinalize()` is called; then, the `Finalize()` method
    can be called again.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Finalize()` 方法仅在未调用 `GC.SuppressFinalize()` 且调用 `GC.ReRegisterForFinalize()`
    时才会运行一次；然后，`Finalize()` 方法可以再次被调用。'
- en: 'When overriding `Finalize()`, there are a few things to keep in mind, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当重写 `Finalize()` 时，有一些事情需要记住，如下所述：
- en: You have no control over when the `Finalize()` method will be called.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法控制 `Finalize()` 方法何时被调用。
- en: To guarantee the release of managed and unmanaged resources within your instance,
    implement the `IDisposable.Dispose()` method using the `IDisposable` pattern.
    There is no guarantee of the order in which finalizers will run.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保在您的实例中释放托管和非托管资源，请使用 `IDisposable` 模式实现 `IDisposable.Dispose()` 方法。无法保证终结化运行的顺序。
- en: Finalizers run on an unspecified thread, and they implicitly call the `Finalize()`
    method on the base class.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终结化在未指定的线程上运行，并且它们隐式调用基类的 `Finalize()` 方法。
- en: To avoid the need to override the `Finalize()` method and for us to ensure the
    cleanup of our managed and unmanaged resources, we will look at implementing the
    `IDisposable` pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要重写 `Finalize()` 方法，并确保我们清理托管和非托管资源，我们将探讨实现 `IDisposable` 模式。
- en: Using finalization
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用终结化
- en: 'We are going to write a sample application that demonstrates the use of `Finalize()`.
    Then, we will modify the program to implement the `IDisposable` pattern and suppress
    the call to `Finalize()`, while ensuring the deterministic release of our managed
    and unmanaged resources. Follow these next steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个示例应用程序来演示`Finalize()`的使用。然后，我们将修改程序以实现`IDisposable`模式并抑制对`Finalize()`的调用，同时确保我们的托管和非托管资源得到确定性的释放。按照以下步骤操作：
- en: 'Start a new .NET 6 console application called `CH04_Finalization`. Add a new
    internal class called `Product`. Then, add the following properties:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的.NET 6控制台应用程序，命名为`CH04_Finalization`。添加一个新的内部类`Product`。然后添加以下属性：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have created four properties—`Id`, `Name`, `Description`, and `UnitPrice`.
    Now, add the constructor, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已创建了四个属性—`Id`、`Name`、`Description`和`UnitPrice`。现在，添加构造函数，如下所示：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our constructor writes a message to the console window so that we know we have
    entered the constructor. Next, add the finalizer, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数向控制台窗口写入一条消息，以便我们知道我们已经进入了构造函数。接下来，添加终结器，如下所示：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our finalizer, we write a message to the console window so that we know
    our finalizer has been called. For the last bit of code in our `Product` class,
    we will override the `ToString()` method, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的终结器中，我们向控制台窗口写入一条消息，以便我们知道我们的终结器已被调用。对于我们的`Product`类中的最后一部分代码，我们将重写`ToString()`方法，如下所示：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our `ToString()` method returns a string that outputs the values of each of
    the properties of the `Product` class. For now, unless stated otherwise, the following
    code is to be added to the `Program` class. Add the following variable:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`ToString()`方法返回一个字符串，输出`Product`类每个属性的值。目前，除非另有说明，以下代码应添加到`Program`类中。添加以下变量：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `_product` variable will be used to store an instance of our `Product`
    class. Update the `Main` method, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_product`变量将用于存储我们的`Product`类的一个实例。更新`Main`方法，如下所示：'
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we have several methods that instantiate the object, print
    object data, remove object references, display object generations, and run the
    garbage collector. We will now add each of the methods in turn. Add the `InitiateObject()`
    method, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们有几个方法用于实例化对象、打印对象数据、删除对象引用、显示对象生成和运行垃圾收集器。我们现在将逐一添加每个方法。添加`InitiateObject()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this method, we write a console window message, create a new product, and
    assign it to the `_product` member variable. Now, we will add the `PrintObjectData()`
    method, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们向控制台窗口写入消息，创建一个新的产品，并将其分配给`_product`成员变量。现在，我们将添加`PrintObjectData()`方法，如下所示：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are printing the contents of the `Product` class to the console window.
    Next, we will write the `RemoveObjectReference()` method, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将`Product`类的内容打印到控制台窗口。接下来，我们将编写`RemoveObjectReference()`方法，如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are setting the `Product` object to `null`. This removes references to the
    object and makes it eligible for garbage collection. We now add a method to call
    the garbage collection, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`Product`对象设置为`null`。这移除了对该对象的引用，使其有资格进行垃圾收集。我们现在添加一个调用垃圾收集的方法，如下所示：
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this method, we call the garbage collector, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们调用垃圾收集器，如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this method, we create a local object. Then, we call the method to display
    the current generation. We then assign the local product to the member product,
    followed by a call to the garbage collector. Our final method, for now, is the
    `DisplayGeneration(Product product)` method, as illustrated in the following code
    snippet:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建了一个局部对象。然后，我们调用显示当前生成的方法。我们将局部产品分配给成员产品，然后调用垃圾收集器。我们的最终方法，目前是`DisplayGeneration(Product
    product)`方法，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This method prints out the generation of the product passed into it. Run the
    code. You should see the following output:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法打印传入的产品生成。运行代码。您应该看到以下输出：
- en: '![Figure 4.2 – The finalization project output'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 终结化项目输出'
- en: '](img/B16617_Figure_4.2.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.2.jpg)'
- en: Figure 4.2 – The finalization project output
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 终结化项目输出
- en: As you can see, our code demonstrates construction and finalization. We have
    both generation 0 and generation 2 code, and both our constructor and finalizer
    methods do get called. Now, we will look at implementing `IDisposable` to make
    the cleanup of our code more deterministic so that `Finalize()` does not need
    to be called.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的代码展示了构造和终结。我们既有0代代码也有2代代码，我们的构造函数和终结器方法都得到了调用。现在，我们将探讨实现`IDisposable`以使代码的清理更加确定，这样`Finalize()`就不需要被垃圾回收器调用。
- en: Implementing the IDisposable pattern
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现IDisposable模式
- en: 'In this section, we will implement a reusable `IDisposable` pattern. We will
    have a base class that implements `IDisposable`. This base class will provide
    two methods that subclasses can override. One method will be for cleaning up managed
    resources, and the other method will be for disposing of unmanaged resources.
    For us to implement the `IDisposable` pattern, proceed as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个可重用的`IDisposable`模式。我们将有一个实现`IDisposable`的基类。这个基类将提供两个子类可以重写的方法。一个方法用于清理托管资源，另一个方法用于释放非托管资源。为了实现`IDisposable`模式，请按照以下步骤操作：
- en: 'Add a new class called `DisposableBase` that implements `IDisposable`, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`DisposableBase`的新类，该类实现`IDisposable`，如下所示：
- en: '[PRE30]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This class acts as a base class that can be inherited. It implements the `IDisposable`
    interface and calls two virtual methods called `ReleaseManagedResources()` and
    `ReleaseUnmanagedResources()` that will be overridden in the subclass.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类作为一个可以被继承的基类。它实现了`IDisposable`接口，并调用两个名为`ReleaseManagedResources()`和`ReleaseUnmanagedResources()`的虚拟方法，这些方法将在子类中被重写。
- en: 'Move the code from `Main` into a new method called `Finalization()`. Then,
    modify `Main`, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main`中的代码移动到一个名为`Finalization()`的新方法中。然后修改`Main`，如下所示：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are calling two methods. The `Finalization()` method demonstrates using
    finalization to clean up resources that you have no control over when finalization
    will be called by the garbage collector. `Disposing()` demonstrates the determined
    disposing of managed and unmanaged resources, with finalization being suppressed
    so that it is not called by the garbage collector. Your `Finalization()` method
    should look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了两个方法。`Finalization()`方法展示了使用终结来清理在垃圾回收器调用终结时你无法控制的资源。`Disposing()`展示了确定性地释放托管和非托管资源，并抑制了终结，以便垃圾回收器不会调用它。您的`Finalization()`方法应如下所示：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are passing `“Finalization”` into the `InstantiateObject(string cleanUpMethod)`
    and `InstantiateLocalObject(string cleanUpMethod)` methods so that we know the
    objects being finalized were instantiated in our `Finalization()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`“Finalization”`传递给`InstantiateObject(string cleanUpMethod)`和`InstantiateLocalObject(string
    cleanUpMethod)`方法，这样我们就可以知道正在终结的对象是在我们的`Finalization()`方法中实例化的。
- en: 'Add a new method called `Disposing()`, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Disposing()`的新方法，如下所示：
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `Disposing()` method, we write a message to the console identifying that
    the `Disposing()` method is running. We then call `InstantiateObject(“Disposing”)`.
    Next, we print the object data and dispose of the object. Then, we instantiate
    a local object that will get assigned to the member variable. The generations
    of the local and member variables are printed to the console window, and then
    we dispose of the object and call garbage collection.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Disposing()`方法中，我们向控制台写入一条消息，标识`Disposing()`方法正在运行。然后我们调用`InstantiateObject(“Disposing”)`。接下来，我们打印对象数据并销毁对象。然后，我们实例化一个将分配给成员变量的本地对象。本地和成员变量的生成被打印到控制台窗口，然后我们销毁对象并调用垃圾回收。
- en: 'Add the `DisposeofObject()` method, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`DisposeofObject()`方法，如下所示：
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `DisposeOfObject()` method calls the `Dispose()` method on the `_product`
    object to free up resources. Update the `Product` class, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DisposeOfObject()`方法调用`_product`对象的`Dispose()`方法来释放资源。更新`Product`类，如下所示：'
- en: '[PRE35]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are storing the name of the cleanup method we are using so that when the
    finalizer is called, we will know the method of cleanup the object uses. Modify
    the `InstantiateObject()` method, as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们存储了我们正在使用的清理方法的名称，这样当终结器被调用时，我们将知道对象使用的清理方法。修改`InstantiateObject()`方法，如下所示：
- en: '[PRE36]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are assigning the method of cleanup to the `Product` object. Do the same
    with the `InstantiateLocalObject()` method so that the code looks like this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将清理方法分配给`Product`对象。同样修改`InstantiateLocalObject()`方法，使代码看起来如下：
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, we are assigning the method of cleanup to the `Product` object. Update
    `Product` to inherit from `DisposableBase`. Then, add the `ReleaseManagedResources()`
    method to the `Product` class, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，我们将清理方法分配给 `Product` 对象。将 `Product` 更新为从 `DisposableBase` 继承。然后，将 `ReleaseManagedResources()`
    方法添加到 `Product` 类中，如下所示：
- en: '[PRE38]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method will be used to release managed resources. Now, add the `ReleaseUnmanagedResources()`
    method to the `Product` class, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法将用于释放托管资源。现在，将 `ReleaseUnmanagedResources()` 方法添加到 `Product` 类中，如下所示：
- en: '[PRE39]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method will be used for cleaning up unmanaged resources.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将用于清理非托管资源。
- en: 'Run the code and you should see the output, as shown here:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，您应该看到如下所示的输出：
- en: '![Figure 4.3 – The output of finalization and disposing code'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 终结化和释放代码的输出'
- en: '](img/B16617_Figure_4.3.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.3.jpg)'
- en: Figure 4.3 – The output of finalization and disposing code
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 终结化和释放代码的输出
- en: As you can see, the finalization code calls the finalizer, but the methods used
    for releasing managed and unmanaged resources explicitly do not get called. Objects
    also survive the generation 0 garbage collection. Conversely, the disposing code
    explicitly releases the managed and unmanaged code, and finalization being suppressed
    is not called by the garbage collector. No objects in our example survive generation
    0 garbage collection.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，终结化代码调用了终结器，但用于显式释放托管和非托管资源的代码方法并没有被调用。对象也存活在 0 代垃圾回收中。相反，释放代码显式释放了托管和非托管资源，并且由于抑制了终结化，垃圾回收器没有调用。在我们的示例中，没有对象存活在
    0 代垃圾回收中。
- en: 'Another way to implicitly call `Dispose()` on disposable classes is to use
    a `using` statement. Here is an example, as can be seen in the `Program` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在可处置类中隐式调用 `Dispose()` 的方法是使用 `using` 语句。以下是一个示例，如 `Program` 类中所示：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `using` statement is used with disposable objects. When the code block completes,
    the object is automatically disposed of. The object’s generation is 0\. Add a
    call to `UsingDispose()` in the `Main` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 语句与可处置对象一起使用。当代码块完成时，对象将被自动处置。对象的代数为 0。在 `Main` 方法中添加对 `UsingDispose()`
    的调用。'
- en: Well, you have seen how to use finalization and implement the `IDisposable`
    pattern in relation to the garbage collector. Now, let’s look at how we can avoid
    memory leaks in C#.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，您已经看到了如何使用终结器和实现与垃圾回收器相关的 `IDisposable` 模式。现在，让我们看看我们如何避免在 C# 中的内存泄漏。
- en: Preventing memory leaks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止内存泄漏
- en: In this section, we will understand the issues around COM objects and what can
    lead to memory leaks using COM objects. We will look at interoping with the Excel
    COM library for our example code. We will see how instances of Excel are kept
    alive after our code exits. By using Windows Task Manager, we will be able to
    see instances of Excel being generated. Our Excel code will be developed in such
    a way as to avoid memory leaks and ensure that every Excel instance is closed
    when our code has completed running so that no instances of Excel remain in memory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 COM 对象周围的问题以及使用 COM 对象可能导致内存泄漏的原因。我们将查看我们的示例代码与 Excel COM 库的互操作性。我们将看到在代码退出后
    Excel 实例是如何保持活跃的。通过使用 Windows 任务管理器，我们将能够看到 Excel 实例的生成。我们的 Excel 代码将以避免内存泄漏并确保在代码完成运行后关闭每个
    Excel 实例的方式开发，这样就不会在内存中留下 Excel 实例。
- en: We will then move on to look at how using events can be a common source of memory
    leaks at runtime and how we can avoid them. Using JetBrains dotMemory, we will
    profile a runtime build executable of our program code. As the code is running,
    we will generate snapshots. As the profiler runs, you will see the memory usage
    gradually climbing. Clicking on the snapshots will display detailed memory information
    for our running profile. We will also be able to see if we have any memory leaks,
    and will see that we have event-based memory leaks. In this section, we will also
    be looking at anonymous methods and weak references.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续探讨使用事件如何成为运行时内存泄漏的常见来源，以及我们如何避免它们。使用 JetBrains dotMemory，我们将分析我们程序代码的运行时构建可执行文件。当代码运行时，我们将生成快照。当分析器运行时，您将看到内存使用量逐渐上升。点击快照将显示我们运行配置的详细内存信息。我们还将能够查看是否存在内存泄漏，并会发现存在基于事件的内存泄漏。在本节中，我们还将探讨匿名方法和弱引用。
- en: The outcome of this section will be that you understand how COM and the use
    of events, if not handled correctly, can introduce memory exceptions, and you
    will see how you can write your code so that no memory exceptions are generated.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的结果将是您了解 COM 和事件的使用，如果处理不当，可以引入内存异常，您将看到如何编写代码以避免生成内存异常。
- en: Understanding the dangers of using Marshal.ReleaseComObject
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解使用 Marshal.ReleaseComObject 的风险
- en: The Visual Studio team ran into problems with Visual Studio 2010\. Their problems
    arose due to rewriting native C++ components in managed C# code. The components
    that were rewritten as managed C# code were the window manager, command bars,
    and text editor.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 团队遇到了 Visual Studio 2010 的问题。他们的问题是由于将原生 C++ 组件重写为托管 C# 代码而引起的。被重写为托管
    C# 代码的组件包括窗口管理器、命令栏和文本编辑器。
- en: With the release of Visual Studio 2010, there were two extension enablers—the
    existing extension mechanism that uses COM interfaces for older extensions, and
    a new managed programming model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Visual Studio 2010 的发布，有两个扩展启用器——现有的使用 COM 接口为旧扩展提供支持的扩展机制，以及一个新的托管编程模型。
- en: In order for the `RuntimeCallableWrapper` or **RCW**. An RCW acts as a bridge
    between the worlds of COM and managed code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `Runtime Callable Wrapper` 或 **RCW**。RCW 在 COM 和托管代码的世界之间充当桥梁。
- en: All COM components must, at the very minimum, implement the `IUnknown` interface.
    When an object that implements the `IUnknown` interface enters the managed runtime,
    it is wrapped in an RCW. An RCW is, therefore, a regular managed object that references
    native code that implements the `IUnknown` interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 COM 组件至少必须实现 `IUnknown` 接口。当一个实现 `IUnknown` 接口的对象进入托管运行时，它会被包装在一个 RCW 中。因此，RCW
    是一个引用实现 `IUnknown` 接口的原生代码的常规托管对象。
- en: 'There are two types of objects that can reference an RCW in a managed .NET
    computer program: COM objects and managed objects. This is the point at which
    issues can start to present themselves.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管 .NET 计算机程序中，有两种类型的对象可以引用 RCW：COM 对象和托管对象。这就是可能出现问题的起点。
- en: At this point, we will now consider a typical scenario that will result in memory
    issues between COM objects and managed objects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将考虑一个典型的场景，该场景可能导致 COM 对象和托管对象之间出现内存问题。
- en: The `DatabaseSearch` component begins the `Find` operation by asking the `DatabaseManager`
    service. A valid instance of `IDatabaseManager` is returned to the `DatabaseSearch`
    component. The `DatabaseManager` component returned to the `DatabaseSearch` component
    is a native COM component. Because the `DatabaseManager` component is a native
    COM component, it is wrapped in an RCW by the runtime. The `DatabaseSearch` component
    does not know or care whether the `DatabaseManager` component is a native COM
    component or managed code component because all it sees is the `IDatabaseManager`
    interface. The `Find` operation continues with the `DatabaseSearch` component
    making various calls through `IDatabaseManager` to complete its task. Once the
    `Find` operation is completed, it is exited. Since `IDatabaseManager` is an RCW,
    it has the same lifetime semantics as managed objects. As a result, the `IDatabaseManager`
    component will be cleaned up when the garbage collector runs. The garbage collector
    may not run for a long time if there is not a lot of memory pressure, and there
    is the possibility that it may not even run. At this point, we end up with a native
    and managed memory clash because of the different ways in which they both manage
    system memory. The managed `DatabaseSearch` component is finished with the `DatabaseManager`
    component until it needs it again. If there are no references to the `DatabaseManager`
    component, then this would be a good time for the garbage collector to run and
    remove `DatabaseManager`. Any component written in native code would, as soon
    as the `Find` method is exited, call `Release` on `IDatabaseManager`. This would
    indicate that the reference to `IDatabaseManager` is no longer needed. Since the
    final `Release` is not being called until the next garbage collection, it appears
    that there is a memory leak with `IDatabaseManager`. This is an example of non-deterministic
    finalization. The inability to determine when an object should be garbage-collected
    is known as non-deterministic finalization. The `Finalize()` method is executed
    on a special thread allocated by the garbage collector whenever the object it
    belongs to is being garbage-collected and finalization has not been suppressed
    when there are non-managed resources to be disposed of.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatabaseSearch` 组件通过询问 `DatabaseManager` 服务来开始 `Find` 操作。它返回给 `DatabaseSearch`
    组件一个有效的 `IDatabaseManager` 实例。返回给 `DatabaseSearch` 组件的 `DatabaseManager` 组件是一个本机
    COM 组件。由于 `DatabaseManager` 组件是一个本机 COM 组件，它被运行时封装在一个 RCW 中。`DatabaseSearch` 组件不知道或不在乎
    `DatabaseManager` 组件是本机 COM 组件还是托管代码组件，因为它所看到的是 `IDatabaseManager` 接口。`Find` 操作通过
    `DatabaseSearch` 组件通过 `IDatabaseManager` 进行各种调用来完成其任务。一旦 `Find` 操作完成，它就会退出。由于
    `IDatabaseManager` 是一个 RCW，它具有与托管对象相同的生命周期语义。因此，当垃圾收集器运行时，`IDatabaseManager` 组件将被清理。如果没有大量的内存压力，垃圾收集器可能不会运行很长时间，甚至可能根本不会运行。在这种情况下，由于它们管理系统内存的方式不同，我们最终会因本机和托管内存冲突而结束。托管
    `DatabaseSearch` 组件在需要 `DatabaseManager` 组件之前完成与 `DatabaseManager` 组件的交互。如果没有对
    `DatabaseManager` 组件的引用，那么这就是垃圾收集器运行并删除 `DatabaseManager` 的好时机。任何用本机代码编写的组件，一旦
    `Find` 方法退出，就会在 `IDatabaseManager` 上调用 `Release`。这表明对 `IDatabaseManager` 的引用不再需要。由于最后的
    `Release` 调用直到下一次垃圾收集才会进行，因此看起来 `IDatabaseManager` 存在内存泄漏。这是一个非确定性终止的例子。无法确定何时应该进行垃圾收集被称为非确定性终止。当对象所属的对象正在被垃圾收集且存在非托管资源需要释放时，垃圾收集器会为该对象分配一个特殊线程来执行
    `Finalize()` 方法。'
- en: This scenario that we have looked at would result in expensive objects being
    reported as leaked objects, and this would be during application shutdown.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所考虑的这种场景会导致昂贵的对象在应用程序关闭时被报告为泄漏对象。
- en: The natural solution would be to call `Marshal.ReleaseComObject(object)`. This
    call would be made as soon as the expensive object is no longer needed. In our
    scenario, it would be when `DatabaseManager` is no longer needed. This call causes
    the RCW to be released, and the internal reference count is decremented by one.
    At this point, the underlying COM object is usually released.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 自然的选择是调用 `Marshal.ReleaseComObject(object)`。这个调用会在昂贵的对象不再需要时立即进行。在我们的场景中，这将是
    `DatabaseManager` 不再需要时。这个调用会导致 RCW 被释放，并且内部引用计数减一。此时，底层的 COM 对象通常会释放。
- en: However, calling `Marshal.ReleaseComObject(object)` can be dangerous.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，调用 `Marshal.ReleaseComObject(object)` 可能是危险的。
- en: Consider that as part of a migration away from COM, `DatabaseManager` has been
    written in managed code. The `DatabaseSearch` managed component requests the `DatabaseManager`
    component via the GSP. An `IDatabaseManager` instance is returned to the `DatabaseSearch`
    component. The instance returned is an RCW that wraps a COM object. As a result,
    we have double wrapping that consists of an RCW wrapped around a `Find` operation
    exits that problems arise. The `DatabaseSearch` component still calls `Marshall.ReleaseComObject(object)`
    for the RCW of `DatabaseManager` when terminating.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到作为从COM迁移的一部分，`DatabaseManager`已被编写为托管代码。`DatabaseSearch`托管组件通过GSP请求`DatabaseManager`组件。返回给`DatabaseSearch`组件的是一个`IDatabaseManager`实例。返回的实例是一个包装COM对象的RCW。因此，我们有了双重包装，即RCW包装在`Find`操作退出时出现问题的外围。在终止时，`DatabaseSearch`组件仍然对`DatabaseManager`的RCW调用`Marshall.ReleaseComObject(object)`。
- en: This results in an `ArgumentException`-type exception being raised. The exception
    message generated is `“The object’s type must be _ComObject or derived from _ComObject.”`
    When this happens, remove the call to `Marshal.ReleaseComObject(object)`. An alternative
    is to call `Marshal.IsComObject` before `ReleaseComObject` is called.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致引发一个`ArgumentException`类型的异常。生成的异常信息是：“对象的类型必须是_ComObject或从_ComObject派生。”当这种情况发生时，请移除对`Marshal.ReleaseComObject(object)`的调用。另一种选择是在调用`ReleaseComObject`之前调用`Marshal.IsComObject`。
- en: 'Calling `Marshal.IsComObject` causes further problems. The `DatabaseManager`
    RCW has been declared as being no longer needed, but the problem is that the `DatabaseManager`
    RCW is still a valid object, meaning that it may still be reachable by managed
    objects. The next time the object is accessed, if reachable from managed code,
    an `InvalidComObjectException`-type exception will be raised by the CLR, stating:
    `“COM object that has been separated from its underlying RCW cannot be used.”`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Marshal.IsComObject`会导致更多问题。`DatabaseManager` RCW已被声明为不再需要，但问题是`DatabaseManager`
    RCW仍然是一个有效的对象，这意味着它可能仍然可以被托管对象访问。下次访问该对象时，如果可以从托管代码中访问，CLR将引发一个`InvalidComObjectException`类型的异常，指出：“与底层RCW分离的COM对象不能使用。”
- en: If the COM components used by our `DatabaseManager` RCW are cached by managed
    code instead of being returned to the GSP each time our `DatabaseManager` component
    is requested, our cached COM components will be checked first. This is done to
    avoid costly calls across the boundary between managed and unmanaged code. If
    several components then request the same COM component, they will each receive
    the same RCW.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们`DatabaseManager` RCW使用的COM组件被托管代码缓存，而不是每次请求`DatabaseManager`组件时都返回给GSP，我们的缓存COM组件将首先被检查。这样做是为了避免在托管和非托管代码之间的边界上进行昂贵的调用。如果随后有多个组件请求相同的COM组件，它们将各自接收到相同的RCW。
- en: The problem here is that the component calling the RCW that has had `ReleaseComObject`
    called will often be blamed as the component that generated the exception. But
    this is not the case—it is the component that called `ReleaseComObject` that is
    the component at fault, which in our scenario would be the `DatabaseSearch` component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，调用过`ReleaseComObject`的RCW的组件通常会被指责为生成异常的组件。但事实并非如此——调用`ReleaseComObject`的组件才是有问题的组件，在我们的场景中，这个组件将是`DatabaseSearch`组件。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended by Microsoft developers, especially those on the Visual Studio
    team, that unless you are 100% certain that there are no managed code items that
    have access to the RCW, you do not call `Marshal.ReleaseComObject`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的开发者，尤其是Visual Studio团队的开发者推荐，除非你100%确定没有托管代码项可以访问RCW，否则不要调用`Marshal.ReleaseComObject`。
- en: We will delve deeper into what we have just been discussing by looking at an
    Excel example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看一个Excel示例来更深入地探讨我们刚才讨论的内容。
- en: Using the Microsoft Excel 16.0 Object Library in .NET 6
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在.NET 6中使用Microsoft Excel 16.0对象库
- en: We are going to be looking at COM interoperability in .NET 6 in this section,
    by referencing the Microsoft Excel 16.0 Object Library. This library is a COM
    library. You will see how to use Excel to create a new application, modify it,
    and save it. When the first example is run a few times, you will see that your
    code does not fail. But in Task Manager, each time the method is run, another
    instance of Excel will remain open, as seen in Windows Task Manager. Then, we
    will move on to see how we can correctly dispose of COM objects so that instances
    of Excel are not kept open when our applications complete. Let’s start by viewing
    what happens when we don’t release Excel COM objects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过引用Microsoft Excel 16.0对象库来探讨.NET 6中的COM互操作性。这个库是一个COM库。您将了解如何使用Excel创建新应用程序、修改它并保存它。当第一个示例运行几次后，您会发现代码没有失败。但在任务管理器中，每次运行该方法时，都会打开另一个Excel实例，就像在Windows任务管理器中看到的那样。然后，我们将继续探讨如何正确地释放COM对象，以便在应用程序完成后Excel实例不会保持打开状态。让我们首先查看当我们不释放Excel
    COM对象时会发生什么。
- en: Investigating what happens when Excel COM objects are not released
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调查当Excel COM对象未释放时会发生什么
- en: In this section, we will create a spreadsheet, add data to it, and then save
    the file. This will reveal memory issues that arise from using Excel and not cleaning
    up properly after ourselves when we have finished using Excel. We will also see
    how to use Excel and clean up after ourselves so that we prevent memory issues
    through using Excel.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个电子表格，向其中添加数据，然后保存文件。这将揭示使用Excel时产生的内存问题，以及我们在使用Excel后没有正确清理时可能出现的内存问题。我们还将了解如何使用Excel并清理以防止通过使用Excel产生的内存问题。
- en: Add a COM reference to the `CH04_PreventingMemoryLeaks` project for the *Microsoft
    Excel 16.0 Object Library*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Microsoft Excel 16.0 Object Library`的COM引用添加到`CH04_PreventingMemoryLeaks`项目中。
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you add a COM reference to your project, you will have IntelliSense available
    to you. But when you come to run your successfully compiled program, when it attempts
    to create an Excel application, it will raise a `FileNotFoundException`-type exception.
    Therefore, you need to set the values for `EmbedInteropTypes` and `Private` to
    `true`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向项目中添加COM引用，您将获得IntelliSense支持。但当您运行成功编译的程序时，当它尝试创建Excel应用程序时，将引发`FileNotFoundException`类型的异常。因此，您需要将`EmbedInteropTypes`和`Private`的值设置为`true`。
- en: 'Since a `FileNotFoundException`-type exception is the last thing we need, edit
    your project file and then update the `COMReference` section, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最不希望遇到的是`FileNotFoundException`类型的异常，请编辑您的项目文件，然后更新`COMReference`部分，如下所示：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will ensure that we don’t experience the `FileNotFoundException`-type
    exception. Add a new `UsingExcel` class to the project, and then add the following
    `using` statements:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们不会遇到`FileNotFoundException`类型的异常。向项目中添加一个新的`UsingExcel`类，然后添加以下`using`语句：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, add the `RunExcelExamples()` method, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`RunExcelExamples()`方法，如下所示：
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This method calls two methods. It calls each of these methods 10 times and
    then exits. Let’s add the `NotReleasingExcelComObjects()` method, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用两个方法。它调用每个方法10次然后退出。让我们添加`NotReleasingExcelComObjects()`方法，如下所示：
- en: '[PRE80]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This method declares a `filename` string. It then instantiates a new Excel
    application that is not visible. It then adds a column header called “`Bucket
    List”`, and adds two items to that bucket list column in the rows below. It then
    checks if the file exists. If the file does exist, then it is deleted. The workbook
    is then saved and closed, and the Excel application is exited. Comment out the
    following lines from the `RunExcelExamples()` method:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法声明了一个`filename`字符串。然后它实例化一个新的不可见的Excel应用程序。接着它添加一个名为“`Bucket List”`的列标题，并在下面的行中添加两个项目到该列表列。然后它检查文件是否存在。如果文件确实存在，则将其删除。然后保存并关闭工作簿，并退出Excel应用程序。从`RunExcelExamples()`方法中注释掉以下行：
- en: '[PRE99]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If you then save your project and run it, you will find that once the program
    exits, you are left with multiple Excel processes. Each of these processes takes
    up memory. The following screenshot shows Excel processes that remain in memory
    after our program exits:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您保存项目并运行它，您会发现程序退出后，您会留下多个Excel进程。这些进程中的每一个都会占用内存。以下截图显示了程序退出后仍然留在内存中的Excel进程：
- en: '![Figure 4.4 – Windows Task Manager displaying Excel processes no longer in
    use using up memory'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – Windows任务管理器显示不再使用的Excel进程正在占用内存'
- en: '](img/B16617_Figure_4.4.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.4.jpg)'
- en: Figure 4.4 – Windows Task Manager displaying Excel processes no longer in use
    using up memory
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – Windows任务管理器显示不再使用的Excel进程正在占用内存
- en: As you can see, these Excel processes that remain in memory after our program
    finishes are using up 367.6 **megabytes** (**MB**) of RAM, which is the combined
    sum of all Excel processes’ RAM. If this program in its current form were to be
    run multiple times, you would eventually run out of memory, as the Excel processes
    left running in memory constitute a memory leak. Each time the program runs, you
    are using up another 367 MB of RAM, or thereabouts. Eventually, the amount of
    memory available will not be enough, and you will end up with an out-of-memory
    exception.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些在我们程序完成后仍然留在内存中的Excel进程正在消耗367.6 **兆字节**（**MB**）的RAM，这是所有Excel进程RAM的总和。如果这个程序以当前的形式多次运行，你最终会耗尽内存，因为留在内存中运行的Excel进程构成了内存泄漏。每次程序运行，你都会消耗另外367
    MB或大约的RAM。最终，可用的内存将不足以满足需求，你将遇到内存不足异常。
- en: 'The following screenshot shows the display in Task Manager after the program
    has been run once:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序运行一次后的任务管理器显示：
- en: '![Figure 4.5 – Windows Task Manager after the program has been run once'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 程序运行一次后的Windows任务管理器'
- en: '](img/B16617_Figure_4.5.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.5.jpg)'
- en: Figure 4.5 – Windows Task Manager after the program has been run once
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 程序运行一次后的Windows任务管理器
- en: 'From *Figure 4.5*, we can see that we are using 7.4 GB (793 MB), with 8.5 GB
    RAM still available to us. Run the program through a number of times continually.
    Each time the program is run, you will see the compressed memory rise and the
    available memory fall. At no point does the memory appear to be reclaimed, as
    shown in the following screenshot:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图4.5*中，我们可以看到我们正在使用7.4 GB（793 MB），而我们还有8.5 GB的RAM可用。连续多次运行程序。每次运行程序，你都会看到压缩内存增加，可用内存减少。内存似乎从未被回收，如下面的截图所示：
- en: '![Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished
    available memory after multiple program runs'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 多次运行程序后，Windows任务管理器显示内存使用增加和可用内存减少'
- en: '](img/B16617_Figure_4.6.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.6.jpg)'
- en: Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished
    available memory after multiple program runs
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 多次运行程序后，Windows任务管理器显示内存使用增加和可用内存减少
- en: After multiple continuous runs of our program, we can see that our **In use
    (Compressed)** memory has gone from 7.4 GB (793 MB) to 10.9 GB (799 MB) and our
    available memory has gone from 8.5 GB to 4.9 GB. This is clearly a problem that
    needs to be addressed, but how?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序多次连续运行之后，我们可以看到我们的**使用中（压缩）**内存已从7.4 GB（793 MB）增加到10.9 GB（799 MB），而我们的可用内存已从8.5
    GB减少到4.9 GB。这显然是一个需要解决的问题，但该如何解决呢？
- en: 'This is where the `ReleasingExcelComObjects()` method shown here comes in:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这里显示的`ReleasingExcelComObjects()`方法的作用：
- en: '[PRE101]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: This rather lengthy method does what we need Excel to do—it releases the Excel
    COM objects, sets the managed objects to `null`, runs the garbage collector, and
    then terminates all running Excel processes. If you uncomment the code in the
    `RunExcelExamples()` method and then run the code once, you will see that we no
    longer have any Excel processes running in memory once our code has finished running.
    You will also see if you look at the **Performance** tab of Windows Task Manager
    that we have reclaimed our memory.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当长的方法做了我们需要Excel做的——释放Excel COM对象，将托管对象设置为`null`，运行垃圾收集器，然后终止所有运行的Excel进程。如果你取消注释`RunExcelExamples()`方法中的代码，然后运行一次代码，你将看到我们的代码运行完成后，内存中不再有任何Excel进程在运行。如果你查看Windows任务管理器的**性能**选项卡，你也会看到我们已经回收了内存。
- en: We have managed to fix our memory leak by terminating COM components and setting
    managed objects to `null` to remove managed references. Then, we killed all processes
    called `EXCEL`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过终止COM组件并将托管对象设置为`null`以移除托管引用，成功地修复了内存泄漏。然后，我们杀死了所有名为`EXCEL`的进程。
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when using the `process.Kill()` method to kill off all processes
    for a given name such as `EXCEL`. There may be other programs that also use that
    process that could be badly impacted by such termination. You should run such
    code in an isolated environment if doing batch processing on a server, or schedule
    such operations for a time when you can guarantee that other processes will not
    be affected by running such code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`process.Kill()`方法杀死具有特定名称（如`EXCEL`）的所有进程时请小心。可能有其他程序也使用该进程，可能会因这种终止而受到严重影响。如果您在服务器上执行批处理，应在此代码在隔离环境中运行，或者安排在您能保证其他进程不会因运行此代码而受到影响的时间进行操作。
- en: It is now time to look at how using events can be a source of memory leaks.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看使用事件如何成为内存泄漏的来源了。
- en: How using events can be a source of memory leaks
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件如何成为内存泄漏的来源
- en: In this section, we will look at how the use of events in your computer programs
    can be a source of memory leaks. We will demonstrate this using a very simple
    Windows Forms application that we will write. Then, we will analyze our memory
    usage using JetBrains dotMemory. There will be two methods employed to show events
    in use. One method will generate a memory leak, while the other won’t generate
    a memory leak.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在您的计算机程序中使用事件如何成为内存泄漏的来源。我们将使用我们将编写的非常简单的Windows Forms应用程序来演示这一点。然后，我们将使用JetBrains
    dotMemory分析我们的内存使用情况。我们将采用两种方法来展示事件的使用。一种方法将产生内存泄漏，而另一种则不会。
- en: So, how can using events generate memory leaks?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用事件如何会产生内存泄漏呢？
- en: 'Unless you are using anonymous methods, subscribing to an event holds a reference
    to the class that holds that event until such time as the event is unsubscribed
    from. Consider the following class:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你使用匿名方法，否则订阅事件会保留对持有该事件的类的引用，直到事件被取消订阅。考虑以下类：
- en: '[PRE162]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'If the control outlives the `EventSubscriber` class, then all instances of
    `EventSubscriber` will not be deallocated by the garbage collector. The end result
    is a memory leak. Here are some different ways to avoid event-based memory leaks:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制对象比`EventSubscriber`类存活时间更长，那么`EventSubscriber`的所有实例将不会被垃圾回收器回收。最终结果是内存泄漏。以下是一些避免基于事件的内存泄漏的不同方法：
- en: Subscribe to anonymous methods.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅匿名方法。
- en: Unsubscribe from events when you are finished with them.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成事件后取消事件订阅。
- en: Implement the weak-handler pattern.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现弱处理程序模式。
- en: 'Before we look at each of these ways of avoiding memory leaks, we will write
    our Windows Forms application that demonstrates a way to avoid memory leaks and
    a way to generate memory leaks. Follow these steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看避免内存泄漏的这些方法之前，我们将编写我们的Windows Forms应用程序，演示避免内存泄漏和产生内存泄漏的方法。按照以下步骤操作：
- en: Start a new .NET Core Windows Forms project, and then change the target framework
    from .NET Core 3.1 to .NET 5 in the project settings.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的.NET Core Windows Forms项目，然后在项目设置中将目标框架从.NET Core 3.1更改为.NET 5。
- en: Rename `Form1` to `MainForm`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Form1`重命名为`MainForm`。
- en: Add a label called `InformationLabel` with the text `“Information”`, a button
    called `RaiseEventsButton` with the text `“Raise Events”`, and another label called
    `ProgressLabel` with the text `“Progress:”`. You can lay the components out and
    style them according to your preference.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`InformationLabel`的标签，其文本为`“Information”`，一个名为`RaiseEventsButton`的按钮，其文本为`“Raise
    Events”`，以及另一个名为`ProgressLabel`的标签，其文本为`“Progress:”`。您可以根据自己的喜好布局和样式化这些组件。
- en: Double-click on the `RaiseEventsButton` button. This will generate a click event
    handler method.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`RaiseEventsButton`按钮。这将生成一个点击事件处理方法。
- en: 'Add a class to the project called `EventOne`. You will need the following `using`
    statements:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为`EventOne`的类。您需要以下`using`语句：
- en: '[PRE176]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Add the following code to the top of the `EventOne` class:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`EventOne`类的顶部：
- en: '[PRE177]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'These elements are needed to handle the event and keep a count of how many
    instances are still being kept alive. Add the constructor, as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些元素是处理事件并记录仍被保持活跃的实例数量的必需元素。添加构造函数，如下所示：
- en: '[PRE178]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The constructor code increments the _`count` member variable in an atomic and
    thread-safe manner for each instance of the class. Add the `RaiseEvent(EventArgs
    e)` method, as follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数代码以原子和线程安全的方式为类的每个实例递增`_`count`成员变量。添加`RaiseEvent(EventArgs e)`方法，如下所示：
- en: '[PRE179]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This method is called by the clients and is responsible for firing the event
    upon request. Now, add the finalizer, as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法由客户端调用，负责在请求时触发事件。现在，添加最终的终结器，如下所示：
- en: '[PRE180]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The finalizer decrements the _`count` member variable in a thread-safe manner
    each time an instance of the class is terminated and collected by the garbage
    collector. Add a new `EventTwo` class to the project. You will need the following
    `using` statements:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当类的实例被终止并由垃圾回收器收集时，终结器以线程安全的方式递减`_count`成员变量。将新的`EventTwo`类添加到项目中。你需要以下`using`语句：
- en: '[PRE181]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Add the following code to the top of the `EventTwo` class:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EventTwo`类的顶部添加以下代码：
- en: '[PRE182]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The code stores the count of the number of alive instances and the current
    text of the subscribed control. Add the following constructor:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码存储了活动实例的数量和订阅控件的当前文本。添加以下构造函数：
- en: '[PRE183]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The constructor takes a Windows Forms control as a parameter. It increments
    the `_count` member variable by one in a thread-safe manner. It then subscribes
    to the `TextChanged` event that is handled by the `OnTextChanged` method. Add
    the `OnTextChanged` method, as follows:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受一个Windows Forms控件作为参数。它以线程安全的方式将`_count`成员变量增加一。然后它订阅由`OnTextChanged`方法处理的事件`TextChanged`。添加以下`OnTextChanged`方法：
- en: '[PRE184]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'This method is fired when the `Text` property of the subscribed control is
    changed. It takes the `Text` content of the control and assigns it to the `Text`
    property of the `EventTwo` class. Add the `Finalizer()` method, as follows:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法在订阅的控件`Text`属性更改时触发。它将控件的`Text`内容分配给`EventTwo`类的`Text`属性。添加以下`Finalizer()`方法：
- en: '[PRE185]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The finalizer decrements the `_count` member variable by one in a thread-safe
    manner each time an instance is garbage-collected. We now have in place the two
    classes that our form will use for raising events. Switch back to the `MainForm`
    class.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当实例被垃圾回收时，终结器以线程安全的方式递减`_count`成员变量。我们现在已经设置了我们的表单将用于引发事件的两个类。切换回`MainForm`类。
- en: 'At the top of the `MainForm` class, add the following member variables:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainForm`类的顶部添加以下成员变量：
- en: '[PRE186]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'These two values will store the number of events that have been generated.
    Add the `SetTitleText()` method, as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个值将存储已生成的事件数量。添加以下`SetTitleText()`方法：
- en: '[PRE187]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'This method sets the control’s `Text` property for each method that raises
    events. The text displays the number of events raised and the number of events
    still alive for the non-memory leak method, and the same again for the memory
    leak method. Add the `SetInformationLabelText()` method, as follows:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法为引发事件的方法设置控件的`Text`属性。文本显示引发的事件数量以及非内存泄漏方法中仍然存活的事件数量，以及内存泄漏方法中的相同内容。添加以下`SetInformationLabelText()`方法：
- en: '[PRE188]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The `SetInformationLabelText()` method updates the `InformationLabel` text
    to display the number of events raised in each method and the number of events
    remaining in memory once both methods have finished executing. Add the `RaiseEvent`
    method, as follows:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetInformationLabelText()`方法更新`InformationLabel`文本，以显示每个方法中引发的事件数量以及两种方法执行完毕后内存中剩余的事件数量。添加以下`RaiseEvent`方法：'
- en: '[PRE189]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The `RaiseEvent` method updates the `ProgressLabel.Text` property, but so that
    it is updated in real time, it is necessary to call the `Invalidate()` and `Update()`
    methods. Now, add the `MemoryLeakMethod` method, as follows:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RaiseEvent`方法更新`ProgressLabel.Text`属性，但为了实时更新，需要调用`Invalidate()`和`Update()`方法。现在，添加以下`MemoryLeakMethod`方法：'
- en: '[PRE190]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'This method declares a count of 10,000 items. It then loops through 10,000
    iterations. A new `EventTwo` object is subscribed to with the reference to `MainForm`
    passed in. Once the loop completes, the `_eventTwoCount` variable is incremented
    by 10,000\. Next, we will add the `NoMemoryLeakedMethod` method, as follows:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法声明一个10,000项的计数。然后它循环10,000次。使用传递给`MainForm`的引用订阅一个新的`EventTwo`对象。一旦循环完成，`_eventTwoCount`变量增加10,000。接下来，我们将添加以下`NoMemoryLeakedMethod`方法：
- en: '[PRE191]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'This method declares a count of 10,000\. It iterates 10,000 times. During that
    10,000 times, it instantiates a new `EventOne` object, adds an event handler called
    `RaisedEvent`, and then raises the event. Once, the loop has completed, the `_eventOneCount`
    variable is incremented by 10,000\. Update the click event handler with the following
    code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法声明一个计数为10,000。它迭代10,000次。在这10,000次迭代中，它实例化一个新的`EventOne`对象，添加一个名为`RaisedEvent`的事件处理程序，然后引发事件。一旦循环完成，`_eventOneCount`变量增加10,000。更新点击事件处理程序，如下所示：
- en: '[PRE192]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Change the build mode to `Release` and build the project.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建模式更改为`Release`并构建项目。
- en: 'Open **JetBrains dotMemory**. Select **Local** | **.NET Core Application**,
    select an executable generated by the build process, then check the **Collect
    memory allocation and traffic from start** box. Your screen should look like this:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **JetBrains dotMemory**。选择 **本地** | **.NET Core 应用程序**，选择由构建过程生成的可执行文件，然后勾选
    **从启动时收集内存分配和流量**复选框。您的屏幕应该看起来像这样：
- en: '![Figure 4.7 – The JetBrains dotMemory configuration screen'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – JetBrains dotMemory 配置屏幕'
- en: '](img/B16617_Figure_4.7.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.7.jpg)'
- en: Figure 4.7 – The JetBrains dotMemory configuration screen
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – JetBrains dotMemory 配置屏幕
- en: 'Click on the **Run** button. This will start your application and profiling
    session, as shown in the next two screenshots:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。这将启动您的应用程序和性能分析会话，如下两个屏幕截图所示：
- en: '![Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – JetBrains dotMemory 分析我们的 Windows Forms 应用程序'
- en: '](img/B16617_Figure_4.8.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.8.jpg)'
- en: Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – JetBrains dotMemory 分析我们的 Windows Forms 应用程序
- en: '![Figure 4.9 – Our Windows Forms application before any events have been run'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 在运行任何事件之前我们的 Windows Forms 应用程序'
- en: '](img/B16617_Figure_4.9.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.9.jpg)'
- en: Figure 4.9 – Our Windows Forms application before any events have been run
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 在运行任何事件之前我们的 Windows Forms 应用程序
- en: 'Click on the **Raise Events** button a few times. Each time you click on the
    button, the memory profile should change and the memory usage should increase,
    as shown in the following screenshot:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几次点击**触发事件**按钮。每次您点击按钮时，内存配置文件应该会改变，内存使用量应该会增加，如下面的屏幕截图所示：
- en: '![Figure 4.10 – Our Windows Forms application showing 50,000 alive events,'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 显示 50,000 个活跃事件的我们的 Windows Forms 应用程序，'
- en: indicating we have a memory leak
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 表明我们存在内存泄漏
- en: '](img/B16617_Figure_4.10.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.10.jpg)'
- en: Figure 4.10 – Our Windows Forms application showing 50,000 alive events, indicating
    we have a memory leak
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 显示 50,000 个活跃事件的我们的 Windows Forms 应用程序，表明我们存在内存泄漏
- en: As you can see, we have a memory leak. Our `NoMemoryLeakMethod` method does
    not generate a memory leak. As you can see, after 50,000 raised events, the objects
    kept alive in memory is 0\. But our `MemoryLeakMethod` method does produce a memory
    leak. Out of 50,000 raised events, 50,000 objects remain alive.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个内存泄漏。我们的 `NoMemoryLeakMethod` 方法不会产生内存泄漏。如您所见，在触发 50,000 个事件后，内存中保持活跃的对象为
    0。但我们的 `MemoryLeakMethod` 方法确实产生了内存泄漏。在触发 50,000 个事件中，有 50,000 个对象保持活跃。
- en: 'Run the program a few more times, and pay attention to what is going on in
    dotMemory. When you see a point of interest, click on the area and then click
    on **Get Snapshot**. This will take a snapshot of that moment in time that users
    can analyze to see if there are any issues. You should end up with something similar
    to this:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序几次，并注意 dotMemory 中的情况。当您看到感兴趣的点时，点击该区域，然后点击 **获取快照**。这将捕捉到那一刻的快照，用户可以分析以查看是否存在任何问题。您应该得到类似以下的内容：
- en: '![Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – JetBrains dotMemory 对我们的 Windows Forms 应用程序的配置'
- en: when events are raised and snapshots are taken
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发事件并获取快照时
- en: '](img/B16617_Figure_4.11.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.11.jpg)'
- en: Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application when
    events are raised and snapshots are taken
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 当触发事件并获取快照时 JetBrains dotMemory 对我们的 Windows Forms 应用程序的配置
- en: 'Click on any one of your snapshots. You should see an output like this:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击任何一个快照。您应该看到类似以下的内容：
- en: '![Figure 4.12 – A memory leak has been identified with the EventTwo class'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 已识别 EventTwo 类的内存泄漏'
- en: '](img/B16617_Figure_4.12.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.12.jpg)'
- en: Figure 4.12 – A memory leak has been identified with the EventTwo class
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 已识别 EventTwo 类的内存泄漏
- en: JetBrains dotMemory has detected a memory leak in the `EventTwo` class. This
    is because the class subscribes to an event of another object, but never unsubscribes
    from it. However, you will see that all the objects for the `EventOne` class have
    been finalized.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JetBrains dotMemory 在 `EventTwo` 类中检测到内存泄漏。这是因为该类订阅了另一个对象的事件，但从未取消订阅。然而，您会看到
    `EventOne` 类的所有对象都已最终化。
- en: 'You have seen how to use events in such a way that generates memory leaks and
    in such a way that all objects are finalized and a memory leak is prevented. Let’s
    revisit the three ways to prevent memory leaks when using events, as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何使用事件以产生内存泄漏的方式，以及以防止内存泄漏的方式。让我们回顾一下使用事件时防止内存泄漏的三种方法，如下：
- en: Subscribe to anonymous methods.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅匿名方法。
- en: Unsubscribe from events when you are finished with them.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成事件时，取消订阅事件。
- en: Implement the weak-handler pattern.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现弱处理器模式。
- en: Let’s take a look at subscribing to anonymous methods and then unsubscribing
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何订阅匿名方法，然后取消订阅
- en: Using local methods
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用局部方法
- en: 'Prior to C# 7.0, you would use anonymous methods as a way of handling events
    such that you avoid introducing memory leaks. As of C# 7.0, you can use local
    methods. In this example, we will handle events using local methods. Follow these
    next steps:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.0 之前，你会使用匿名方法作为处理事件的方式，以避免引入内存泄漏。从 C# 7.0 开始，你可以使用局部方法。在这个例子中，我们将使用局部方法来处理事件。遵循以下步骤：
- en: Load the `CH04_PreventingMemoryLeaks` project.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `CH04_PreventingMemoryLeaks` 项目。
- en: 'Add a class called `Website`, as follows:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Website` 的类，如下所示：
- en: '[PRE193]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'This class has two events for logging in and logging out of a website. Add
    a new class called `AnonymousEventSubscription`. Add the `Login()` method, as
    follows:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类有两个事件用于网站的登录和注销。添加一个名为 `AnonymousEventSubscription` 的新类。添加 `Login()` 方法，如下所示：
- en: '[PRE194]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'The `Login()` method instantiates a new `Website` object. It then has a local
    method called `LoginHandler` that writes a message to the debug window and then
    unsubscribes from the `Website.Login` event. Then, outside of the local method,
    it subscribes to the `Website.Login` event and raises the event. Let’s add the
    `Logout()` method, as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Login()` 方法实例化一个新的 `Website` 对象。然后它有一个名为 `LoginHandler` 的局部方法，该方法将消息写入调试窗口，然后取消订阅
    `Website.Login` 事件。然后，在局部方法外部，它订阅 `Website.Login` 事件并引发事件。让我们添加 `Logout()` 方法，如下所示：'
- en: '[PRE195]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The `Logout()` method instantiates a new `Website` object. It then has a local
    method called `LogoutHandler` that writes a message to the debug window and then
    unsubscribes from the `Website.Logout` event. Then, outside of the local method,
    it adds the event handler for the `Website.Logout` event, and then raises the
    event.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Logout()` 方法实例化一个新的 `Website` 对象。然后它有一个名为 `LogoutHandler` 的局部方法，该方法将消息写入调试窗口，然后取消订阅
    `Website.Logout` 事件。然后，在局部方法外部，它添加 `Website.Logout` 事件的处理器，然后引发事件。'
- en: 'In the `Main` method, comment out the `RunExcelExamples()` line. Then, add
    the `UseAnonymousEventSubscription()` method call, as follows:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中，注释掉 `RunExcelExamples()` 行。然后，添加 `UseAnonymousEventSubscription()`
    方法调用，如下所示：
- en: '[PRE196]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: This code runs through 1,000,000 iterations. For each iteration, a new `AnonymousEventSubscription`
    is instantiated, with calls to `Login()` and `Logout()` made. These two calls
    will each have a subscription to an event, an event executed via a local method,
    and, as the local method is executed, the event it will be unsubscribed from.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码运行了 1,000,000 次迭代。对于每次迭代，都会实例化一个新的 `AnonymousEventSubscription`，并调用 `Login()`
    和 `Logout()`。这两个调用将各自有一个事件订阅，一个通过局部方法执行的事件，以及，当局部方法执行时，它将取消订阅该事件。
- en: 'If you build and run the code, you should see the following lines printed 1,000,000
    times in your debug window:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你构建并运行代码，你应该在你的调试窗口中看到以下行打印了 1,000,000 次：
- en: '![Figure 4.13 – The debug window showing events firing for Login and Logout'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 显示登录和注销事件触发的调试窗口'
- en: '](img/B16617_Figure_4.13.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_4.13.jpg)'
- en: Figure 4.13 – The debug window showing events firing for Login and Logout
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 显示登录和注销事件触发的调试窗口
- en: If you perform a release build and run dotMemory, you will see that we have
    no memory leak, considering we have just generated 2,000,000 event subscriptions
    and unsubscriptions—that is, 1,000,000 for `Login()` and 1,000,000 for `Logout()`.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你执行发布构建并运行 dotMemory，你会看到我们没有内存泄漏，考虑到我们刚刚生成了 2,000,000 个事件订阅和取消订阅——即 `Login()`
    有 1,000,000 个，`Logout()` 也有 1,000,000 个。
- en: We have seen how to effectively use anonymous events using local methods without
    causing memory leaks. Now, let’s look at our final topic of the chapter—weak references.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用局部方法有效地使用匿名事件，而不会造成内存泄漏。现在，让我们看看本章的最后一个主题——弱引用。
- en: Using weak reference events
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用弱引用事件
- en: 'We use the weak reference event pattern to allow an object to be garbage-collected
    if its only remaining link is an event handler. We will implement the weak reference
    event pattern in this section in the `CH04_PreventingMemoryLeaks` project. Follow
    these next steps:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用弱引用事件模式，允许一个对象如果其唯一剩余的链接是事件处理器，则可以被垃圾回收。我们将在本节中的 `CH04_PreventingMemoryLeaks`
    项目中实现弱引用事件模式。遵循以下步骤：
- en: 'In the Package Manager Console, type the following: `install-package WeakEventListener`.
    The `System.Windows.WeakEventManager` package only works with .NET 4.8 and older,
    which is why we install this package.'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包管理器控制台中，输入以下命令：`install-package WeakEventListener`。`System.Windows.WeakEventManager`
    包仅适用于 .NET 4.8 及更早版本，这就是我们安装此包的原因。
- en: 'Add the following `SampleClass` class:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `SampleClass` 类：
- en: '[PRE197]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'In this class, we declare an event called `RaiseEvent`. The `DoSomething()`
    method calls the `OnRaiseEvent()` method. The `OnRaiseEvent()` method checks if
    the event is `null`; if it is not `null`, then the event is invoked. Add a new
    class called `UsingWeakreferences`. You will need the following references:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们声明了一个名为 `RaiseEvent` 的事件。`DoSomething()` 方法调用 `OnRaiseEvent()` 方法。`OnRaiseEvent()`
    方法检查事件是否为 `null`；如果不是 `null`，则事件被调用。添加一个名为 `UsingWeakreferences` 的新类。你需要以下引用：
- en: '[PRE198]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Add the `RaiseWeakReferenceEvents()` method, as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `RaiseWeakReferenceEvents()` 方法，如下所示：
- en: '[PRE199]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: We have two variables that are `true` when an event has been triggered and when
    it has been detached. We instantiate a new `SampleClass` class instance. Then
    we declare a `WeakEventListener` package that references the `SampleClass` class.
    Anonymous methods are used to handle the `OnEventAction` and `OnDetachAction`
    methods. The `WeakReferenceListener.OnEvent` method is then assigned as the handler
    for the `SampleClass.RaiseEvent` event. We then call the `DoSomething()` method
    that raises the event. Then, we assert that the event has been triggered, detach
    the event, and then assert that the event has been detached.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个变量，当事件被触发和解除时它们为 `true`。我们实例化一个新的 `SampleClass` 类实例。然后我们声明一个引用 `SampleClass`
    类的 `WeakEventListener` 包。使用匿名方法来处理 `OnEventAction` 和 `OnDetachAction` 方法。然后将 `WeakReferenceListener.OnEvent`
    方法分配为 `SampleClass.RaiseEvent` 事件的处理器。然后我们调用引发事件的 `DoSomething()` 方法。然后，我们断言事件已被触发，解除事件，然后断言事件已被解除。
- en: Make sure the project is set to **Debug** mode, and then step through the code.
    It should work as expected, with the event being correctly triggered and detached.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目设置为 **调试** 模式，然后逐步执行代码。它应该按预期工作，事件被正确触发和解除。
- en: Let’s now summarize what we have learned in this chapter.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来总结一下本章所学的内容。
- en: Summary
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We looked at object generations and saw how easy it was to generate a `System.OutOfMemoryException`-type
    exception. We saw how we can use predictive out-of-memory exception checking to
    save time by preventing the running of code that will cause this exception.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了对象生成，并看到了如何容易地生成 `System.OutOfMemoryException` 类型的异常。我们看到了如何使用预测性内存不足异常检查来节省时间，通过防止运行将导致此异常的代码。
- en: Then, we moved on to discuss long weak references and short weak references.
    We learned that strong references are not garbage-collected, and weak references
    are garbage-collected.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向讨论长弱引用和短弱引用。我们了解到强引用不会被垃圾回收，而弱引用会被垃圾回收。
- en: We then looked at finalization and saw how the `Finalize()` method will be called
    on objects that are not disposed of, and that we have no control over when the
    `Finalize()` method will run. Then, we looked at how to implement the `IDisposable`
    pattern and suppress the need for garbage collection to call `Finalize()`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着探讨了终结化，并看到了在未释放的对象上调用 `Finalize()` 方法的情况，以及我们没有控制 `Finalize()` 方法何时运行的情况。然后，我们探讨了如何实现
    `IDisposable` 模式，并抑制垃圾回收调用 `Finalize()` 的需求。
- en: Finally, we looked at the various ways to prevent memory leaks, such as properly
    disposing of managed resources and unmanaged resources. We also saw how to correctly
    handle events so that we do not cause memory leaks.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了防止内存泄漏的各种方法，例如正确释放托管资源和非托管资源。我们还看到了如何正确处理事件，以避免内存泄漏。
- en: With what you have learned in this chapter, you will be able to overcome out-of-memory
    exceptions, improve memory performance, and improve garbage collection in your
    applications, and you will be to correctly use events and event handlers without
    generating memory leaks and will be able to effectively release COM objects and
    allocated memory. This will lead to better quality and more stable programs that
    make good use of memory.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章所学的内容，你将能够克服内存不足异常，提高内存性能，并改善应用程序中的垃圾回收，你将能够正确使用事件和事件处理器，而不会产生内存泄漏，并且能够有效地释放
    COM 对象和分配的内存。这将导致质量更高、更稳定的程序，并能够充分利用内存。
- en: In the next chapter, we will be looking at application profiling.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨应用程序分析。
- en: Questions
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How many object generations are there?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少个对象生成？
- en: Which sized objects get placed on the SOH?
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些大小的对象会被放置在 SOH 上？
- en: Which sized objects get placed on the LOH?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些大小的对象会被放置在 LOH 上？
- en: What is a strong reference?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是强引用？
- en: What is a weak reference?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是弱引用？
- en: How can we clean up objects without having to rely on finalization?
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在不依赖终结的情况下清理对象？
- en: How do we avoid memory leaks when using events?
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在使用事件时避免内存泄漏？
- en: Which method do we use to release COM objects?
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪种方法来释放 COM 对象？
- en: How do we prevent memory leaks when allocating memory?
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分配内存时我们如何防止内存泄漏？
- en: Further reading
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Weak references: [https://www.youtube.com/watch?v=2WcDhh8lvJs](https://www.youtube.com/watch?v=2WcDhh8lvJs)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '弱引用: [https://www.youtube.com/watch?v=2WcDhh8lvJs](https://www.youtube.com/watch?v=2WcDhh8lvJs)'
- en: '`ComWrappers` class: https://docs.microsoft.com/ dotnet/api/system.runtime.interopservices.comwrappers?view=net-5.0'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComWrappers` 类: https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.comwrappers?view=net-5.0'
- en: '*Marshal.ReleaseComObject Considered Dangerous*: [https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/](https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/)'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Marshal.ReleaseComObject 被认为是危险的*: [https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/](https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/)'
- en: '*WeakEventManager Class:* https://docs.microsoft.com /dotnet/api/system.windows.weakeventmanager?view=net-5.0'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WeakEventManager 类:* https://docs.microsoft.com/dotnet/api/system.windows.weakeventmanager?view=net-5.0'
- en: '*Weak Event Patterns*: [https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8)'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*弱事件模式*: [https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8)'
- en: '*How to properly release Excel COM objects*: [https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/](https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/)'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何正确释放 Excel COM 对象*: [https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/](https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/)'
- en: '*Understanding and Avoiding Memory Leaks with Event Handlers and Event Aggregators*:
    [https://www.markheath.net/post/understanding-and-avoiding-memory-leaks](https://www.markheath.net/post/understanding-and-avoiding-memory-leaks)'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过事件处理程序和事件聚合器理解和避免内存泄漏*: [https://www.markheath.net/post/understanding-and-avoiding-memory-leaks](https://www.markheath.net/post/understanding-and-avoiding-memory-leaks)'
- en: 'Why and how to avoid event handler memory leaks: [https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks](https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为什么以及如何避免事件处理程序内存泄漏: [https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks](https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks)'
- en: '*.NET Framework technologies unavailable on .NET Core and .NET 5+:* [https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable](https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Framework 技术在 .NET Core 和 .NET 5+ 上不可用:* [https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable](https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable)'
