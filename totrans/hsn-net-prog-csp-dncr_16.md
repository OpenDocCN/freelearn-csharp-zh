# 互联网协议

在上一章中，我们全面了解了**开放系统互联**（**OSI**）网络堆栈传输层中最常见且最健壮的两个协议：**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。在本章中，我们将探讨使这两个传输层服务得以实现的网络层协议。在本章中，我们将学习关于**互联网协议**（**IP**）的内容。我们将探讨IP标准是如何演变为支持数十亿设备的全球网络，并允许它们之间可靠地相互通信的。我们将考虑较早且更常见的IPv4，查看IPv4旨在解决的问题，并讨论其达到的限制。接下来，我们将检查IPv6旨在解决这些限制的方式。最后，我们将更详细地查看`IPAddress`类，并仔细研究核心库是如何实现IPv4和IPv6的。我们将借此机会讨论并考虑IP地址如何映射到域名，以及学习**域名系统**（**DNS**）服务器如何将地址映射到资源，并查看一些代码示例，这些示例将使我们能够自行实现这些映射。

本章将涵盖以下主题：

+   IP地址的组成以及它是如何被使用的，包括网络掩码、本地寻址和DNS服务器，用于识别物理设备

+   使用IPv4标准分配IP地址的方式，以及识别IPv4的限制

+   IPv6标准的详细信息，列举利用IPv6的优势以及在全球互联网规模上实施它的成本

+   DNS级别的域名到IP地址解析

# 技术要求

在本章中，我们将编写示例软件来解析从我们的主机文件配置的IP地址，以模拟DNS服务器。您需要.NET Core **集成开发环境**（**IDE**）或代码编辑器。您可以在[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2012](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2012)访问示例代码。查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HYmyi9](http://bit.ly/2HYmyi9)。

# IP标准

在我们开始查看IP标准从其起源发展到广泛采用的IPv4，再到现在的IPv6之前，我们首先必须了解该标准是什么以及它与我们所查看的传输层协议有何不同。这对于巩固我们对OSI网络堆栈的理解至关重要，因为IP是互联网上运行的传输层协议的基础。因此，让我们弄清楚IP是为什么而设计的，它是如何实现其设计目标的，以及它为网络软件和硬件提供了哪些功能。

# IP的起源

IP最初作为TCP最早版本中的数据包传输机制实现。IP首次在1974年得到正式描述。在现代计算机历史的早期，计算网络还处于起步阶段。然而，这些网络在范围上不断增长，并开始使用各种交互机制封装多个子网络。随着网络的增长，对网络连接设备之间标准的需求迅速显现。

为了满足这一对标准的需要，美国政府的高级研究计划署（**ARPA**）赞助了一系列实验，以定义一个能够支持大规模互联网络的协议。在这一赞助下，电气和电子工程师协会（**IEEE**）的成员撰写了一篇论文，描述了一种利用分组交换技术在网络中的主机之间共享资源的互联网络协议。从1977年开始，该组织开始尝试使用这篇论文中描述的协议的各种草案。在1977年至1979年之间，根据**互联网实验笔记**（**IEN**）的描述，有四个IP的实验版本，分别标记为IPv0至IPv3。这些版本中的每一个都解决了前一个协议版本中的某些主要缺陷，直到团队确信他们的协议足够健壮，可以供更广泛的公众使用。

# IPv0 – TCP的网络层协议

这些实验中的第一个，IEN 2，是在1977年8月撰写的。它明确指出，工程师们在设计IP时违反了分层原则。在其初始草案中，TCP负责抽象应用层数据包的主机到主机的传输，以及协商两个连接主机之间路由上的网络设备之间的跳数。通过这种方式过度设计TCP，工程师创建了一个跨越OSI网络堆栈的传输和网络层的单一协议。这种违反OSI层之间边界的行为几乎立即被认识到是一个糟糕的设计和做法。因此，在IEN 2中，作者提出了一个新的、独特的互联网协议，并建议TCP严格用作主机级别的端到端协议。通过这个实验，IP诞生了。

在IEN 2中描述的协议和接口描述了两个之前都由TCP执行的主要操作。首先，有**互联网主机-跳协议**，它将成为TCP。这是为了描述主机之间完整端到端交互的接口，而不关心如何在这两个主机之间导航。它描述了一个基本的负载分片过程和许多今天仍在TCP中使用的头部信息。

描述的第二种协议是**互联网跳接口**。IEN的这一部分描述了最终成为IP的内容。在这个上下文中，“跳”是指网络图中两个节点或主机之间单条边上的跳。IEN的这一部分的目标是定义与数据包捆绑的最小必要信息，以便路径上的任何一步都能相应地路由它，避免将同一数据包的多个实例路由到目的地，并允许以这种方式进行分片，以便数据包可以在目的地网关重新组装。

# IPv1到IPv3 – 正式化报头格式

在接下来的两年里，又编写了几个IEN来描述不断演变的IP接口。这些IEN各自以不同的方式，正式化了IP的一些细节，这些细节最终成为了广泛发布和普遍支持的IPv4。从IPv1开始，正如IEN 26所描述的，工程师们设定的第一个任务是定义成功路由跨越任意大和任意组织的网络所需的最小必要报头，以及它们的最小必要大小规范。

没有某种类型的报头的普遍接受，最终将无法出现我们今天所知道的互联网。然而，直到有某种接口的普遍接受，**互联网工程任务组**（**IETF**）的成员知道他们的工作将受到反馈和变化的制约。因此，第一份IP报头描述的主要任务之一是允许支持多个版本和多种在那些网络上暴露的服务。因此，IEN 26中描述的报头引入了诸如IP版本报头和**服务类型**（**TOS**）报头等字段。

紧接着，在IEN 28中，团队定义了IPv2，这进一步明确了接口的报头以及网络上的数据包分片过程。这也是第一个提出检测数据包损坏机制的IEN，尽管它没有提供如何实现的指导。最后，它描述了数据包的基本寻址组件以及网络上的主机寻址机制。然而，值得注意的是，所描述的机制并非最终发布给更广泛公众的机制。

# IPv4 – 建立IP

在对协议进行多次迭代的过程中，团队解决了他们的设计问题，直到IEN 54，他们最终确定了将被**请求评论**（**RFC**）791标准化的报头定义，即IPv4。随着RFC 791的发布，IETF最终确立了IP标准的操作和实施细节。自1981年以来，该协议版本在全球范围内使用，即使今天，该接口规范也几乎用于互联网上主机之间发送的所有数据报的80%左右。

# IP的功能

如RFC 791所述，IP设计为网络提供三个主要功能。在该规范的1.2节中，协议的作用域被明确限制在仅提供将一个比特包（一个互联网数据报）从源传输到目的地的必要功能上，这些功能是在一个互联的网络系统中实现的。

你会注意到，在这个定义中，作者们没有提到可靠性、有序交付或连接协商。这完全是他们有意为之的省略。正如他们在IEN 2中所说的，试图用网络层协议来处理这些功能将违反OSI网络栈的边界。这不仅仅是我个人的推测；在IP作用域的定义中，作者们明确指出，没有机制来增强端到端数据可靠性、流量控制、排序或主机到主机协议中发现的其它服务。在这里，作者们指的是传输层协议和接口的职责。

因此，如果可靠的交付、流量控制和排序都不在IP的范围内，你可能很想知道它负责哪些功能，以及它是如何实现这些功能的。嗯，根据标准，IP精确负责两个功能：地址和分片。该协议为上层的传输层协议提供这些功能，它通过利用下层数据链路层的本地网络协议来实现这一点。

# IP地址

地址用于唯一标识可以处理网络请求的主机（或一组主机）。任何必须被连接到其网络的其它主机定位的设备都必须有一个与其关联的地址。这是IP从数据链路层请求路由信息的唯一机制。

在这里，区分地址和名称、主机名或域名是值得的。名称，或主机名，是供人类阅读的**统一资源标识符**（**URI**）结构，而地址是一个唯一、语义结构的键，指示主机名的所有者所在的位置。根据IP标准，传输层协议负责在将地址信息传递给网络层以传输到路由中的下一个设备之前，将主机名解析为其特定的地址。

在这里，应该进一步区分地址或识别目标主机的子网和特定位置，以及路由或找到源主机到目标主机之间的完整路径。一旦数据报被主机的IP接口接收，目标地址就会被验证，数据包会被分片，并应用所有IP头部。然后，数据报会被传递下去，而数据链路层负责在网络的链路和节点之间执行路由任务，以找到两个主机之间的连接路径。

因此，IP实现的地址功能围绕着在网络上为新节点分配地址，以及解析和解释附加到数据包上的地址。在分配新地址时，它们使用固定长度、语义上有意义的数值键。语义上有意义的数值键就是指可以从键的结构中推断出其含义的键。

在IP地址的情况下，地址的不同部分包含有关IP地址标识的主机特定位置的信息。例如，在早期地址解析规范中，32位地址方案的前8位用于定位目标主机所在的具体子网。地址中的下一个24位在本地网络地址方案中作为主机的地址。

随着网络范围的不断扩展和地址空间的日益增大，IP地址方案的规范在多年中不断发展和变化，但自1981年IPv4引入以来，用作主机地址的良好格式化、语义键的原则保持不变。

# 数据包分片

由于IP设计用于促进网络中节点之间的跳转，因此需要为数据包分片（在可能已在传输层执行的分片之上）制定规范。由于大型互联网中的每个连接子网都可以自由指定其自己的数据包大小和交付约束，因此在数据包穿越网络时，数据报的大小和格式要求可能会出现不一致。可能存在的情况是，由源主机子网认为足够小的数据报实际上对于目标主机子网来说太大。因此，运行在路由器或两个子网之间的桥上的IP实现可能需要在两个子网之间移动数据报时对其进行分解或重新组装。

规范确实提供了一种机制，用于指示在任何情况下都不应将数据报分片。然而，如果数据链路层的规范阻止数据报在不分片的情况下交付，并且数据报被标记为不分片，那么它就会被简单地丢弃。

标准定义了分片过程的实际步骤，作为一个将较长的数据报分解成若干个较小数据报的通用系统。数据报被分解成更小的二进制数据帧，并添加额外的头部信息，以便将这些较小的数据报重新组合成适当大小的原始数据报。添加到较小数据报中的额外字段如下：

+   **偏移量**：新分片在数据报中的位置。这允许正确地重新排序可能已经乱序交付的数据报片段。

+   **长度**：这指定了从原始数据报中提取并存储在当前分片有效载荷中的内容的长度。

+   **标识符字段**：新的、较小的分片也使用一个标识符来指定它们属于哪个较大的数据报。这有助于确保在重组过程中，来自不同父数据报的较小片段不会混淆。

+   **更多分片标志**：最后，有一个更多分片标志字段，用于指示是否需要将额外的较小分片添加到重建的父数据报中。

这些字段（偏移量、长度、标识符和更多分片）结合起来，足以从任意数量的片段在目标主机上重建一个数据报。我们在RFC中看到的描述的通用性质允许在几乎任何网络网关、路由器或子网接口的任何用例中进行可靠的分片和重组。现在我们了解了该协议旨在实现的目标，让我们看看自其诞生以来是如何实施和部署的。

# IPv4及其限制

1981年首次定义，并于1983年广泛部署，IPv4已经成为整个互联网以及几乎所有局域网网络层交互的标准，至今已有三十多年的历史。正如我之前提到的，几乎所有互联网流量都是使用IP接口的IPv4规范完成的。它的稳定性、可扩展性和可靠性已经得到了充分证明。那么，IPv4的哪些特性使其在网络层责任实施上如此成功？IPv4规范中的哪些特性在如此漫长且成功的历史之后，促使定义和部署新的IPv6协议？

# IPv4的寻址标准

正如我在关于IP寻址功能的上一节中提到的，IPv4的地址设计具有语义结构，而不是简单地为网络上的每个新设备分配一个任意的键。因此，只要你理解如何解析地址的语义意义，就可以通过分析地址的每个段来进行分层分析，从而确定主机的具体位置。

# IPv4地址语法

IPv4地址是32位的，通常分为四个八位字节（字节），由十进制分隔，每个字节以十进制表示。然而，地址的底层结构足够灵活，可以表示为从点十进制表示法，到32位值的原始十进制整数表示，到十六进制，到点十六进制格式。这些表示法中的每一种都只是表达相同二进制值的不同方式。因此，给定IP地址的语法表示法并不重要，因为底层32位表示法保留了语义意义。

那么，让我们考虑以下IPv4地址：

[PRE0]

这可能对你来说并不熟悉，作为一个IP地址，至少不是以那种形式。那么，让我们看看我们如何以我们更容易识别为IP地址的方式表达它。我们将首先将二进制表示分为四个八位字节：

[PRE1]

接下来，我们将每个以点分隔的字节转换为它们的十进制表示：

[PRE2]

就这样，我们得到了一个我们更熟悉的IP地址格式。然而，我们同样可以将字符串转换为它的十六进制点表示法，并得到以下结果：

[PRE3]

只要我们保持八位字节的顺序，意义就保持不变，并且可以为我们提供有关将路由请求发送到给定地址的有用信息。

# 类别IP寻址

在IPv4中，地址中每个八位字节的值可以携带关于该地址主机分层路由信息。当协议版本最初定义时，有一个规定，即地址值的第一个八位字节将指定主机所属的子网。这被称为网络字段。剩下的三个八位字节被用来指定主机在该子网中的地址。这些八位字节共同被称为**剩余字段**，简称**地址的其余部分**。

现在，如果你对二进制数学很熟悉，你可能会已经意识到了我刚才描述的结构问题。由于只有一个八位字节来指定子网，整个互联网上最多只能有`255`个子网。这种限制几乎立即被认定为不可行，因此标准文档中包含了针对不同类别的寻址方案的规定。在RFC 791中描述了三种特定的IP地址类别，每个类别使用不同数量的位来指定主机的子网，并且每个类别都有其自己独特的最大主机数限制。

在RFC被起草的时候，只有大约`64`个子网存在，这意味着最多只有网络字段的六个最低有效位被用来指定已知的子网，直到那时。为了避免重新分配广泛使用的子网地址，网络字段的最高有效位被设置为用于指定给定IP地址的类标志。在原始RFC中，有三个定义良好的IP结构类，第四个留作未来根据需要指定的开放类。这三个原始类被定义为如下：

+   **A类**：在一个**A类**地址中，最高有效位为零，接下来的七个位用于子网标识。这留下剩余的三个八位作为其余字段，允许在一个由**A类**地址标识的子网中有多达`16,777,215`个可能的唯一宿地址。

+   **B类**：在一个**B类**地址中，地址的最高有效位值为`1`，次高有效位值为`0`。地址的接下来的14位用于子网标识，留下两个最低有效八位用于子网内唯一的宿地址。

+   **C类**：最后，在一个**C类**地址中，地址的前两个最高有效位值为`1`，而第三个最高有效位值为`0`。在这三个最高有效位中的这些值，接下来的21位用于子网标识，允许有`2,097,151`个可能的唯一子网。这仅留下最后一个八位用于宿地址标识，在一个**C类**IP地址中最多只有`255`个宿地址可用。

为了进一步说明这些类在语义上的解析方式，考虑以下三个IP地址：

[PRE4]

现在，通过将每个地址转换为它们的点二进制表示，我们可以检查最高有效位来确定每个地址属于哪个IP地址类。

![图片](img/f7dc5ef3-ae5c-4849-a973-ad47c7d670ef.png)

然而，将三个最高有效位限制用于指示网络类是一个不可持续的长期解决方案。不久之后，IETF设计了一种新的机制来确定IP地址的网络字段。

# 子网掩码

到1993年，在类地址架构下的可用IP地址池以不可持续的速度耗尽（我们将在稍后讨论这个问题）。为了减轻这一挑战，IETF废除了由RFC 791描述的类地址架构，并引入了**无类域间路由（CIDR）**地址语法。CIDR语法在IP地址上应用了一个额外的、可选的后缀，用于精确指示地址中有多少位是用于网络字段。后缀由一个开头的`/`字符分隔，然后是一个整数，表示子网掩码中有多少个前导`1`。

如果术语**子网掩码**听起来很熟悉，你可能在你终端中运行`ipconfig`命令时的诊断输出中见过它。在这个上下文中，术语**掩码**特指位掩码。基本上，当你将掩码应用于另一个二进制数时，结果是在两个数中至少有一个为`1`的任何位置上都有一个`1`值。考虑以下IP地址：

[PRE5]

然后是以下子网掩码：

[PRE6]

将掩码应用于IP地址的结果如下：

[PRE7]

因此，在这个例子中，如果我们将我们的二进制数转换为点十进制表示法，我们得到的IP地址如下：

[PRE8]

我们还有以下子网掩码：

[PRE9]

这个子网掩码的作用是指示路由设备哪些IP地址的位应该用于网络识别。因此，因为我们刚才查看的子网掩码的前24位都是`1`，这意味着这前24位应该用作网络标识符。

这个特定的子网掩码可能对你来说很熟悉，因为它是最现代路由器的默认本地子网和子网掩码。这个IP地址所标识的子网是由你的家用路由器创建的，它作为更广泛互联网和你的家庭网络之间的网关。但是，这意味着对于任何只有一个路由器的家庭，可以连接到网络的最大设备数量是有限的。

使用CIDR的表示法，相同的IP地址和子网掩码组合如下表示：

[PRE10]

这就产生了所谓的**可变长度子网掩码**（**VLSM**）。它允许我们使用任意数量的位进行网络识别，而无需保留最高位作为标志值。这意味着IP地址可以用来识别更大的一组唯一子网，而这些网络可以有更广泛的最大尺寸范围。

# 地址空间耗尽

所有这些将标准适应以允许地址语法的更大灵活性的工作主要是为了减轻IPv4可能的最大限制。我之前已经提到过，IPv4的地址规范允许地址最多有32位。这意味着无论你如何结构化你的网络字段和其余字段，最大唯一IP地址的数量始终是`4,294,967,296`个。

在1983年，当IPv4被标准化时，互联网还只是一个实验。当然，在IETF工作的工程师们有远见，预计他们的网络实验最终会扩展到覆盖整个世界。然而，IPv4的发展是基于他们的特定网络实验不会超出ARPA的计算机网络。然而，即使他们看到他们的标准在新兴互联网上的广泛应用，仍然有一个假设，即430亿个唯一地址将提供足够的时间在地址空间耗尽之前设计出一个可行的替代方案。

他们没有预料到的是，计算机的功率会增加，成本会降低的速度。这种组合导致了消费计算机市场的爆炸性增长，随之而来的是需要地址的网络主机数量的爆炸性增长。随着新世纪的临近，最后可用的IPv4地址的分配也随之而来。因此，在1998年，发布了下一个IP版本的草案标准。

# IPv6 – 协议的未来

设计用来克服网络主机有效地址数量不足的问题，IPv6首次在1998年被引入，尽管它直到2017年才被正式接受为标准（这也说明了工程师在定义标准方面的勤奋）。新的规范是为了处理IPv4提出的一些问题而编写的，包括有限的地址空间。该标准还支持多播传输，以及**IP安全**（**IPSec**）安全特性。

# IPv6地址方案

与IPv4有32位地址机制，允许最多有约430亿个唯一地址相比，IPv6标准提供了一个128位的地址方案，允许有3.4 x 10^(38)个唯一地址。那就是3400亿个地址！为了有一点背景，该方案允许的地址数量比从地球表面到可观测宇宙边缘的米数还要多。有了如此大的地址空间，IPv6方案允许更简单的地址分配、路由聚合和我们将要探讨的唯一地址特性。

这128位被组织成每组16位的八个组。这些组通常以四个十六进制数字的形式书写（与IPv4中典型的整数表示形式不同），每个分组之间用冒号分隔。然而，为了最小化数据包头的大小，有一个标准可以缩写IPv6地址，而不会丢失有意义的信息。地址缩写的两个步骤如下：

1.  删除路由中任何16位（或四个十六进制）段的前导零

1.  删除一个连续的零字符串，并用`**:**`替换被删除的部分

要看到这一过程在实际中的应用，让我们从以下地址开始：

[PRE11]

现在，在应用步骤1之后，我们有以下内容：

[PRE12]

现在，移除最长的连续零字符串，我们得到以下内容：

[PRE13]

虽然这种表示方式在实质上更小，但它实际上只用作便利。IPv6数据包的报头被配置为使用完整的128位地址作为数据包的源地址和目的地址，因此，在传输之前，无论缩写得多短，完整的地址都会应用到数据包上。

# 网络字段和路由效率

在IPv4中，人们投入了大量工作来在有限的32位地址内分配足够的空间用于子网标识符。然而，由于IPv6设计时考虑到了如此庞大的地址空间，网络标识大大简化。所有IPv6地址都将最重要的64位分配给子网寻址，而将剩余的64位分配给主机或接口标识。

这使得路由器和网络交换机能够更有效地处理数据。因为网络标识符和主机地址总是固定长度的，并且这些长度与32位和64位硬件的字长很好地对齐，因此路由器可以更高效地解析地址结构。

# IPv6中的分片

在IPv4和IPv6之间，另一个主要的变化在于对数据包进行适当分片以适应其路由的责任分配。在IPv4中，这明确是网络层的关注点，IPv6试图解决这个问题。关于数据包分片提供的指导是定义IPv4的RFC中的一个重要部分。与此同时，在IPv6中，数据包分片被认为是传输层和数据链路层的共同责任。

这种责任变化背后的理念是断言，在传输层的端到端协议中应该有一个步骤。这个步骤就是确定两个主机之间路由上允许的最大数据包大小。同时，两个主机之间路由的每个边缘的**最大传输单元**（**MTU**）应在传输开始时从数据链路层可发现。在无法发现两个主机之间特定路由的MTU的情况下，传输层应回退到互联网的默认MTU，即1280字节的数据。因此，在理想情况下，数据链路层可以提供特定路由的MTU，而传输层可以相应地分片其数据包。如果数据链路层未能提供路由的MTU，传输层将使用默认MTU的最坏情况分片大小，即1280字节。

# IPv6到IPv4接口

由于IPv6从根本上改变了IPv4数据包头部的结构，这两个版本完全不兼容。当网络工程师需要在整个IPv4向IPv6过渡的整个生命周期内支持广泛部署的IPv4时，这显然是一个问题。为了促进这一过渡，已经设计出一些中间解决方案，以允许IPv6流量在IPv4网络上运行。

# 并行IP部署

在单个网络上使IPv4和IPv6共存的最简单方法是在该网络上的每个主机部署每个版本的完整协议实现。这通常在操作系统（OS）级别完成，并允许流量在到达和离开单个硬件接口时与两个IP版本交互，一旦物理数据传输被交付给操作系统。使用这种并行部署的设备将同时获得IPv4和IPv6的地址，如果主机有一个注册的域名，该域名将由DNS服务器解析为这两种地址方案。当然，这里的明显缺点是并行部署的效果仅与部署的子网一样好。如果一个主机支持两种协议，但存在于仅支持IPv4的网络中，那么就没有任何好处。然而，在一个严格控制的子网中，并行部署是一个可行且通常简单的选项。

# 隧道接口

IP流量跨版本支持的另一种替代方案被称为**隧道**。这是一种通过将IPv6数据包封装在IPv4数据包中来在IPv4网络上隧道传输IPv6流量的机制。这一过程在RFC 4213中有描述，并被严格使用IPv6数据包方案的服务器广泛采用。

最受欢迎的隧道方案之一，**Teredo**，一直被用来将IPv6子网集成到更广泛的IPv4互联网中。Teredo实现这一目标的方式是通过利用我们的老朋友，UDP。IPv6数据包被封装在一个UDP数据包头部中，而这个UDP头部本身又被封装在一个IPv4数据包中。IPv4数据包按正常路由，直到被配置为专门分解IPv4数据包为原始IPv6结构的Teredo客户端或服务器接收。

虽然这对任何网络工程师来说都是有用的信息，但作为C#开发者，我们很幸运，不需要关心这些接口的细节。虽然我们可以从软件中的任何网络流量中获取特定的IP信息，但IP数据包的翻译和解析主要被抽象化，不为我们所知。因此，现在让我们看看我们如何调查和理解软件中IP流量的本质。

# 在C#中利用IP

由于 C# 和 .NET Core 运行时会从我们的应用程序软件中抽象出大多数 IP 交互的细节，所以这个演示将相对简单。我们将编写一个简单的 Web API 来模拟 DNS 名称解析。我们将使用一个简单的 JSON 文件来存储域名及其相关地址，并提供 `IPAddress` 类（或其实例列表）的一个实例作为我们的响应。这将展示语言在幕后为您提供了大量的解析和协商，以及这如何显著简化您的开发过程。而且，因为我们一直在本书中处理 IP 地址和端口，所以其中很多内容应该对您来说都很熟悉。

# 设置我们的服务器

我们将使用一个简单的 Web API 项目来完成这个任务，因此我们将使用 **命令行界面**（**CLI**）来创建它：

[PRE14]

一旦设置好，我们将从我们的控制器中移除所有除 POST 端点之外的所有脚手架端点。这将是通过用户从我们的 DNS 服务器查找主机名的路由。我们还将修改我们的路由，以更准确地表达我们的 API 提供的内容。因此，在我们开始编码之前，我们的控制器应该如下所示：

[PRE15]

接下来，我们需要为我们的应用程序添加一个简单的主机注册表，以便执行查找。因此，创建一个表示键值对的 JSON 文件。键将是我们在执行查找的主机名，值将是任意 IP 地址的字符串表示的数组。并且为了演示目的，确保在我们的文件中使用 IPv4 和 IPv6 地址。我的文件看起来像这样，但您的可以使用您喜欢的任何主机名和地址：

[PRE16]

作为最后的设置步骤，我们将添加一个简单的静态类，以便从我们的控制器中更容易地处理 `hosts.json` 文件。为此，我们将创建一个 `Hosts` 静态类，给它一个名为 `Map` 的单个公共属性，然后使用 C# 的静态构造函数特性来初始化 `Map` 属性，使其包含我们的 JSON 文件的内容。然后，每次我们需要访问我们的主机文件时，我们都会通过到 `Hosts.Map` 方法的静态引用来这样做，并相应地查询其字典。这种模式非常简单，也非常有用，可以为您的应用程序代码提供直接且易于理解的静态内容文件访问。我们的示例如下所示：

[PRE17]

到此为止，我们已经准备好实现我们的 IP 查找。

# C# 中的 IP 解析

现在我们已经准备好从主机文件中读取，我们可以开始解析传入的请求，并以 JSON 字符串的形式返回给我们的消费者 IP 信息。就像我们所有的演示代码一样，我们将假设我们得到的是格式良好的输入，并且暂时忽略错误处理。

我们的输入将是一个完全限定的 URI，因此我们将初始化一个临时的 URI 变量，以便更容易地获取域名：

[PRE18]

接下来，我们将尝试访问`Hosts.Map`方法中的主机名对应的IP地址。如果失败，我们将回退到外部的DNS服务器，并返回它为我们的主机名提供的任何地址。我们将使用一个名为`GetSerializedIpAddresses()`的实用方法来完成这项工作，该方法将`IPAddress`数组序列化为字符串，我们稍后会讨论它。现在，重要的是要理解，当我们无法在我们的服务器注册表中找到主机名时，我们的回退是查找外部的DNS服务器以进行名称解析：

[PRE19]

一旦我们通过了这一点，我们就知道我们拥有了请求主机的`IPAddress`条目，我们可以使用C#的`IPAddress`类来相应地解析它们。所以，首先，我们将为我们的`IPAddress`实例创建一个容器。然后，我们将尝试使用`IPAddress.TryParse()`方法初始化每个实例。假设这成功了（在我的例子中是这样，并且假设你自己的文件中有良好格式的IP地址，它也会在你的文件中成功），我们将新的`IPAddress`实例添加到我们的列表中：

[PRE20]

如果你一直按照我的例子做，你会发现`IPAddress`类的`TryParse()`方法会自动检测并处理我之前讨论的所有寻址方案。我们可以添加从人类可读的点分十进制格式的IPv4地址，到简化的IPv6地址，再到原始的32位二进制字符串，`TryParse()`方法会相应地构建地址。这种实用工具是为什么本章的软件演示可以如此轻量。几乎所有繁重的工作都是由.NET Core运行时为您完成的。

# 在C#中使用`IPAddress`类

我们对这个服务的最后一个任务是将我们的`IPAddress`实例列表转换为相应的JSON。这可能是你代码中遇到的一个相当大的障碍。不幸的是，`IPAddress`类与`JsonConvert.SerializeObject()`配合得不是很好。事实上，如果你尝试在一个`IPAddress`实例上执行该方法，你几乎每次都会得到一个异常。这是因为`IPAddress.Address`属性实际上是已弃用的。它被定义为长类型，在C#中是64位整数。然而，正如你所知，IPv6地址是一个128位值。不幸的是，`JsonConverter`类并不足够智能，无法在运行时确定哪些公共属性已弃用。这意味着它将尝试访问你的`IPAddress`实例的`Address`属性进行序列化，并且对于包含IPv6地址的任何`IPAddress`实例，这种访问将引发错误。

现在，如果你熟悉编写自己的 `JsonConverter` 扩展类，你可以覆盖 `IPAddress` 的 `JsonConverter` 类，并使用它来序列化你的返回对象。然而，由于这超出了本书的范围，因此，我们将采取不太理想的捷径，通过编写自己的 `GetSerializedIPAddresses()` 方法来实现序列化。既然我们知道最好不要使用 `IPAddress.Address` 属性，我们只需使用 `ToString()` 方法来获取我们的 `IPAddress` 实例的值。该方法将简单地构建出每个 `IPAddress` 实例的字符串表示形式，作为 JSON，使用我们知道的每个不是已弃用且可以安全访问的公共属性。该方法如下所示：

[PRE21]

通过该方法，我们可以确切地看到 `IPAddress` 类可以通过其公共属性为我们提供有关 IP 版本性质及其实现的哪些信息。我们可以了解用于利用 IPv6 覆盖 IPv4 的映射或接口，或者简单地了解 IPv6 主机的功能支持。

随着最后一块拼图的到位，我们的最终控制器方法应该如下所示：

[PRE22]

如果你运行应用程序并将 `POST` 主机名发送到你的端点，你会注意到返回的 IP 地址总是格式良好的，甚至完全限定的 IPv6 地址也被缩写了。通过这种简单的功能，你可以抽象出在应用程序代码中解析和操作 IP 地址的所有混乱。你可以信任，这项工作正在由底层的 IPv4 和 IPv6 的强大实现为你正确处理。

# 摘要

在本章中，我们极其仔细地研究了 IP，首先精确地辨别了为什么 IP 作为一种网络层协议，与之前我们考察过的传输层协议不同，然后通过其起源了解了 IP 的功能和用途。我们考察了 TCP 的传输层责任与 IP 的网络层责任（最终成为 IP）之间的分界点。通过这样做，我们明确了 IP 的范围以及它旨在提供的功能，以及哪些功能超出了其范围。

一旦我们确定了 IP 的范围和意图，我们就仔细研究了它多年来是如何演变的。从 IPv4 开始，我们学习了寻址方案、它是如何产生的以及网络软件如何使用它来唯一标识网络上的主机。我们了解了在 IPv4 寻址架构中区分网络地址和主机地址的常见机制。我们还考察了子网掩码如何帮助区分单个地址中的这两个字段。一旦我们涵盖了 IPv4 的寻址架构，我们就考察了它在支持可寻址主机总数方面的局限性。

在探索了IPv4的全貌之后，我们看到了其当前提议的替代品IPv6，并看到了新标准中更新的地址结构如何支持单个通用网络中的大量主机。然后，简要地，我们检查了一些允许IPv4和IPv6共存的接口。最后，我们探讨了C#为我们软件中解析和构建IPv4和IPv6地址提供的类，以确保我们的网络数据包可靠路由。

现在我们已经看到了信息在最低级别是如何路由和交付的，是时候考虑网络交互的最重要方面了。因此，在下一章中，我们将探讨如何在网络中提供安全性。

# 问题

1.  IP的两个主要功能是什么？

1.  什么是类地址？IPv4地址有哪些类别？

1.  什么是可变长度子网掩码？

1.  什么是地址耗尽？

1.  IPv4地址空间的上限是多少？

1.  IPv4地址的结构是什么？IPv6地址的结构又是什么？

1.  什么是Teredo隧道？

1.  IPv6启用了哪些功能？

# 进一步阅读

为了您自己的参考，我强烈建议您阅读IPv4的原始RFC。您会惊讶地发现它有多容易阅读，以及您可以从底层规范中获取多少信息。它也可以免费在线阅读，这里： [https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791)。

我还建议，仅仅为了其简洁性，您阅读原始IEN 2，以了解IP最初发展的确切动机。它也可以免费在线阅读，并且出人意料地引人入胜：[https://www.rfc-editor.org/ien/ien2.txt](https://www.rfc-editor.org/ien/ien2.txt)。

此外，如果您想了解其他编程IP的方法，我再次推荐由*Alena Kabelová*和*Libor Dostálek*撰写的*Understanding TCP/IP*，由Packt Publishing提供，这里：[https://www.packtpub.com/networking-and-servers/understanding-tcpip](https://www.packtpub.com/networking-and-servers/understanding-tcpip)。
