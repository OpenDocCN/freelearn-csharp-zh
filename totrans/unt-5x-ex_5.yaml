- en: Chapter 5. Project C – a 2D Adventure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will begin a completely new project; specifically, a 2D
    adventure game in which the player controls an alien character, exploring and
    navigating a dangerous world complete with quests and interactive elements. This
    project will incorporate elements and ideas from previous chapters as well as
    focus on new techniques, such as Complex Collisions, 2D Physics, Singletons and
    Statics, and more. In short, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 2D characters and player movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembling complex and multipart characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D Physics and collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting project and assets can be found in the book companion files in
    the `Chapter05/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A 2D Adventure – getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adventure games require the player to use their cunning, dexterity, mental sharpness,
    and acumen to make progress. Such games feature dangerous obstacles, challenging
    missions, and character interaction, as opposed to *all-out* action like many
    first-person shooter games. Our adventure game will be no exception. See *Figure
    5.1* for a glimpse of the game that we'll create. In this game, the player moves
    around using the keyboard arrows or *W*, *A*, *S*, *D* keys. Furthermore, they
    can jump with the spacebar and interact with characters simply by approaching
    them. During the game, the player will be tasked with a mission from an NPC character
    to collect an ancient gem hidden somewhere within a level. The player must then
    navigate dangerous obstacles in search of the gem, and then finally collect it
    before returning to the NPC, completing the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2D Adventure – getting started](img/figure_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The 2D adventure game to create'
  prefs: []
  type: TYPE_NORMAL
- en: To get started with creating the adventure, create a completely new and empty
    Unity project, and then import the `Particles`, `Effects`, `Characters`, `2D`,
    `ParticleSystems`, and `CrossPlatformInput` packages. You can import these from
    the **Project Creation Wizard** or from the application menu via the **Assets**
    | **Import Packages** option. See *Figure 5.2*. Details on how to import standard
    assets are included in [Chapter 1](ch01.html "Chapter 1. The Coin Collection Game
    – Part 1"), *The Coin Collection Game – Part 1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![A 2D Adventure – getting started](img/figure_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Importing packages to a new project from the Project Creation screen'
  prefs: []
  type: TYPE_NORMAL
- en: Importing assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting from an empty project created in the previous section, let''s now
    import the texture assets we''ll be using, both for the player character and environment.
    The assets to import are included in the book companion files in the `Chapter05/Assets`
    folder. From here, select all textures together in Windows Explorer or Mac Finder,
    and drag and drop them to the Unity Project panel in a designated `Textures` folder.
    (Create one if you haven''t already!). This imports all relevant textures to the
    active Project. See *Figure 5.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing assets](img/figure_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Importing texture assets to the Project'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you can always use the Thumbnail Size Slider (at the bottom right
    corner of the Project panel) to adjust the size of thumbnail previews in order
    to get an easier view of your texture assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Unity assumes that all imported textures will eventually be used
    as regular textures applied to 3D models in the scene, such as cubes, spheres,
    and meshes. In most cases, this assumption is correct because most games are 3D.
    However, for 2D games like the one we''re making, the settings should be different.
    In our case, objects don''t recede in the distance, moving further away, but just
    remain at a constant offset from the camera. For this reason, we must adjust some
    crucial properties for all imported textures. Specifically, select all imported
    textures, and, from the **Object Inspector**, change the **Texture Type** field
    from **Texture** to **Sprite 2D and UI**. Then, remove the check mark from the
    **Generate Mip Maps** box. Then, click on the **Apply** button. When you do this,
    Unity flags the assets as having a *2D usage* internally. It allows transparent
    backgrounds to be applied where applicable (such as for PNG sprites) and also
    has important performance implications for graphics rendering, as we''ll see.
    See *Figure 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing assets](img/figure_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Configuring imported textures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve imported all essential textures for the project, let''s configure
    our main scene, game camera, and target resolution. Switch to the **Game** tab
    and set the resolution to **1024 x 600**; which works well across many devices.
    To do this, click on the **Free Aspect** button from the **Game** tab toolbar
    and pick **1024 x 600** from the drop-down menu, if it appears as an option. If
    not, click on the **+** button from the bottom of the list to add the new resolution.
    See *Figure 5.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing assets](img/figure_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Adding game resolutions'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new resolution, enter a custom name in the **Name** field, select
    **Fixed Resolution** from the **Type** drop-down, and then type your resolution
    dimensions in the **Width & Height** fields. Once completed, click on **OK**.
    Your target resolution should then be added as a selectable option from the **Game**
    tab. See *Figure 5.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing assets](img/figure_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Creating a custom resolution'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll configure the scene camera for a 2D setup so that our textures,
    when added as sprites, will display onscreen at a 1:1 ratio, texel for pixel.
    To achieve this, select the **MainCamera** in the scene, either by clicking on
    it in the **Scene viewport** or selecting it in the **Scene Hierarchy**. Then,
    from the **Object Inspector**, change **Projection** to **Orthographic**. This
    ensures that the camera displays objects in true 2D with perspective and foreshortening
    effects removed. Then change the camera Size to `3`. The formula for this field
    is *Screen Height / 2 / Pixel to World*. In this case, the *Screen Height* is
    *600*. Thus, *600 / 2 = 300*. Then, *300 / 100 = 3*. *100* refers to the pixel
    to world ratio applied to sprite textures; this details how many pixels in the
    texture will be mapped to a square meter in the world. A value of `1` means *1
    pixel = 1 meter*. This value can be viewed and changed by selecting a sprite in
    the **Project** panel and changing the **Pixel to World ratio** field in the **Object
    Inspector**. See *Figure 5.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing assets](img/figure_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Configuring camera orthographic size'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the camera and scene settings, simply drag and drop a background texture
    from the **Project** panel to the scene. The **Background** textures are sized
    at exactly 1024 x 600 to fit the scene background. Therefore, when added to a
    scene and when the camera is configured correctly, the background textures should
    fill the screen. See *Figure 5.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing assets](img/figure_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Testing the camera settings with a texture'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an environment – getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our adventure game will feature three separate but connected scenes, which
    the player may explore, moving from one scene to the next. The player may travel
    between scenes, simply by walking off the edge of one and then moving into the
    next. Each scene consists primarily of platforms and ledges and, in some cases,
    dangers and obstacles. In terms of graphical assets, each scene is made from two
    textures or sprites: the background and foreground. An example for Scene 1 is
    shown in *Figures 5.9* and and *Figure 5.10*. *Figure 5.9* represents the background
    scene and *Figure 5.10* represents the foreground, which includes a complete layout
    of all the platforms and ledges that the player must traverse. These files are
    included in the book companion files in the `Chapter05/Assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Scene background - tex_level01_bck.png'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Scene foreground - tex_level01_design.png'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the first level now, based on the sprites in *Figures 5.9* and
    *Figure 5.10*. To do this, use the existing empty scene, or create a new scene,
    ensuring that the scene camera is configured to display textures at their native
    size. Then, drag and drop both the background and foreground sprites from the
    **Project** panel to the scene. Both will be added to the scene as separate sprite
    objects. Then, position them both to the World Origin at (0,0,0). See *Figure
    5.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Adding a scene background and foreground'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you drag and drop both the background and foreground textures together as
    one selection from the **Project** panel to the scene, Unity may ask you to create
    an Animation when you release your mouse. In such cases, Unity assumes that you
    want to create an animated sprite in which each selected texture becomes a frame
    of animation played in a sequence. You don't want to do this; instead, drag and
    drop each sprite to a separate **Hierarchy** panel, allowing both the foreground
    and background to be seen at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both sprite objects are now added to the scene at the same world position (0,0,0).
    The question arises now as to which sprite Unity should display on top, given
    that both sprites overlap one another. Left as it is right now, there is a conflict
    and ambiguity about depth order, and we cannot rely on Unity consistently showing
    the correct sprite on top. We can solve this problem with two methods: one is
    to move the sprite forward in the *Z* axis, closer to the Orthographic camera;
    and the other is to change its **Order** setting from the **Object Inspector**.
    High values for **Order** result in the sprite appearing atop lower-order sprites.
    Here, I''ll use both methods and that''s fine too! See *Figure 5.12*. Note, however,
    that **Order** always takes precedence over **Position**. This means that higher-order
    objects will always appear on top of lower-order objects, even if higher-order
    objects are positioned behind lower-order objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Ordering sprite layers in a scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving further, let''s get organized in terms of scene hierarchy to
    prevent overcomplication and confusion happening later. Select each environment
    object and name them appropriately. I named the background `scene_background`
    and the foreground `scene_foreground`. Having done this, create a new, empty **GameObject**
    named `Env` (for Environment), which will be the ultimate parent or ancestor of
    all static (non-movable) objects in the environment. This lets us group together
    all related objects easily. To do this, choose **GameObject** | **Create Empty**
    from the application menu, position the created empty object to the world origin,
    and drag and drop both the background and foreground objects as its children.
    See *Figure 5.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Organizing the scene hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'By switching to the Game tab, we can get an early preview of the level as it
    will appear to the gamer in terms of mood and emotional resonance. This feel can
    be enhanced further by adding some Camera Post-process Effects. These refer to
    pixel-based effects that can be applied to the camera in order to enhance the
    atmosphere of the final, rendered image on each frame. The **Image Effects** are
    included in the Effects package, which you should have imported during the project
    creation phase. If you did not import the package at that time, you can do so
    now by navigating to **Assets** | **Import Package** | **Effects**. The **Image
    Effects** assets are stored in the `Standard Assets/Effects` folder. Once imported,
    you can add Image Effects to the selected camera via the Application Menu by choosing
    **Component** | **Image Effects** and then choosing the effect to add. See *Figure
    5.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Adding Image Effects to the selected camera'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this level, and all other levels in the game, I''ll add the following two
    image effects: **Bloom Optimized** and **Noise and Grain**. Once added, you will
    typically need to adjust the sliders and settings in the **Inspector** to achieve
    the look you want, continually previewing the result in the **Game** tab. The
    **Scene** tab remains unaffected by image effects. The complete range of settings
    I''ve used for both image effects are included in *Figure 5.15*. In many cases,
    these settings will take some trial and error—tweak values and observe the effect.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an environment – getting started](img/figure_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Image Effects applied to the game camera'
  prefs: []
  type: TYPE_NORMAL
- en: Good work. The scene so far features a background and foreground taken from
    texture files and enhancing special effects using the Image Effects assets package.
    This is a great start, but there's still much to do so let's move on!
  prefs: []
  type: TYPE_NORMAL
- en: Environment Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main problem with our level as it stands is that it lacks interactivity.
    Specifically, if we dragged and dropped a player object to the level and pressed
    play on the toolbar, the player would drop through the floor and walls because
    the foreground texture isn''t recognized by Unity as a solid object. It''s just
    a texture and exists only in appearance and not in substance. In this section,
    we''ll correct this using Physics and Colliders. To get started, we''ll create
    a temporary player object (not the final version but just a temporary *White Box*
    version used only for testing purposes). To create this, generate a capsule object
    in the scene by navigating to **GameObject** | **3D Object** | **Capsule** from
    the application menu. Set the *Z* position of the transform to match the foreground
    texture (for me, this is `-2`). Once generated, remove **Capsule Collider** from
    the object. By default, the Capsule is assigned a 3D collider (such as the **Capsule
    Collider**), which is useful primarily for 3D physics, but our game will be 2D.
    To remove the Collider, click on the Cog icon on the **Capsule Collider** component
    in the **Object Inspector** and choose **Remove Component** from the menu. See
    *Figure 5.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Removing a Capsule Collider component'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the object compatible with 2D Physics, add a Circle Collider component
    by choosing **Component** | **Physics 2D** | **Circle Collider** from the application
    menu. Once added, use the **Offset** and **Radius** settings on the Circle Collider
    component in the Inspector to adjust the size and position of the circle in relation
    to the capsule object in order to approximate the feet of a player character.
    To aid you in positioning the **Circle Collider** more easily, you can switch
    the **Scene** viewport mode to **Wireframe** and **2D**, if needed. To do this,
    use the **2D Toggle** button and the **Scene Render** mode drop-down button in
    the viewport toolbar. See *Figure 5.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Adjusting the Circle Collider for the player character'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to make the **Circle Collider** work with 2D Physics, add a RigidBody2D
    component to the Capsule. To do this, select **Component** | **Physics 2D** |
    **RigidBody2D** from the application menu. You can confirm that this has worked
    by previewing the game in Play mode. When you click on the play icon, the Capsule
    object should fall down and through the foreground floor under the effect of gravity.
    See *Figure 5.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Adding a Rigidbody 2D component to a test character'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to configure the foreground texture to work as a unified whole
    with physics. Right now, our test player character falls through the floor and
    this is not what we want. To fix this, we''ll need to add a collider to the foreground
    environment. One method for this is to use Edge Collider 2D. This lets you draw
    out a low polygon mesh collider around your ground image manually, approximating
    the terrain. To get started, select the foreground in the scene and then choose
    **Component** | **Physics 2D** | **Edge Collider 2D** from the application menu.
    Doing this will add an Edge Collider 2D component to the foreground object. See
    *Figure 5.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Adding an Edge Collider'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, adding an Edge Collider 2D appears to have little effect on the
    selected object or any other objects, except for a single horizontal line drawn
    across the width of the scene. This can be seen in the **Scene** tab when the
    **Foreground** object is selected and in the **Game** tab if the **Gizmos** tool
    button is enabled. If the player is positioned above the horizontal line and you
    press Play on the toolbar, the player character will fall downward and treat the
    horizontal edge as a solid platform. See *Figure 5.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: The Edge Collider is useful to approximate platforms and solid
    surfaces'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, our terrain isn''t simply a straight-edged surface. Rather, it has
    elevations, bumps, and platforms. These can be approximated closely with the Edge
    Collider 2D component using the **Collider Edit** mode. To access this mode, click
    on the **Edit Collider** button from the **Object Inspector**. See *Figure 5.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: The Edit Collider mode lets you change the shape of an Edge Collider
    2D'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Edit Collider** mode active, you can reshape the collider to conform
    to the terrain. Let''s focus on one area such as the bottom right-hand side of
    the terrain. By moving your mouse cursor over the edge points of the **Edge Collider**
    (the green line), you can click and drag to reposition it. To approximate the
    bottom right island of the terrain, click and drag the rightmost edge point to
    the right-hand side of the scene. See *Figure 5.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Starting to reshape the Edge Collider to approximate the terrain'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click and drag the left point of the collider to match with the leftmost
    edge of the right-hand island. See *Figure 5.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Positioning the left-most of the right-hand island'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the left and right edge points are positioned, let''s add some additional
    points on the line between to reshape it, conforming to the right-hand island.
    Move your cursor anywhere on the line, click and drag to insert a new point, and
    reposition it to match the island. Repeat this process, adding additional points
    to reshape the line as needed. See *Figure 5.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Shaping the Edge Collider to the right-most island'
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have a fully shaped line that matches the terrain''s right-most island.
    Having created this, exit the **Edit Collider** mode by simply clicking on the
    **Edit Collider** button again from the **Object Inspector**. To create colliders
    for the remaining islands of the terrain, add a new **Edge Collider** to the same
    object. You can then add any number of **Edge Colliders** to a single object,
    and each collider should be used to approximate the topology of a single, isolated
    island in the complete terrain. See *Figure 5.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Multiple Edge Colliders on one object can be used to approximate
    complex terrain'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple Edge Collider components are now added together to a single foreground
    object, approximating the complete terrain for the scene. We can now test play
    collisions against the **Player Capsule** object by pressing the play icon on
    the toolbar and seeing how the capsule reacts against the terrain. This time,
    the capsule will collide and interact with the ground as opposed to passing through.
    This confirms that the terrain is configured appropriately with the physics system.
    See *Figure 5.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment Physics](img/figure_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Capsule Object interacting with a terrain made from Edge Colliders'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! In this section, we've created a complete terrain for a single
    scene using Edge Collider components. This terrain not only fits the screen and
    appears as intended, but acts as a physical obstacle for the player character
    and other physics-based objects. Of course, so far, we've been using a rough approximation
    for the player and now it's time to expand upon this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The player character is a small, green alien-looking creature that can be controlled
    and guided by the gamer through a level using many conventional platform-game
    mechanics, such as walking, jumping, and interacting. In the previous section,
    we built a *White Box* (prototype) character to test physical interactions with
    the environment, but here, we''ll develop the player character in more depth.
    *Figure 5.27* illustrates our character texture imported earlier in the chapter,
    representing all limbs and parts for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: Character and his limbs in a consolidated texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'The player texture, as shown in *Figure 5.27*, is called an **Atlas Texture**
    or **Sprite Sheet** because it contains all frames or parts of a character in
    a single texture space. The problem with this texture, as it stands, is that when
    dragged and dropped from the **Project** panel to the scene, it''ll be added as
    a single, self-contained sprite. This is because Unity recognizes all the separate
    parts as a single sprite. Rather, these should be separated into distinct units.
    See *Figure 5.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: The player sprite texture needs to be divided into separate parts'
  prefs: []
  type: TYPE_NORMAL
- en: 'To divide the character texture into separate parts on a per-limb basis, we''ll
    use **Sprite Editor**. To access this tool, select the character texture in the
    **Project** panel. Then, from the **Object Inspector**, change **Sprite Mode**
    from **Single** to **Multiple**. Then, click on **Apply**. Next, click on the
    **Sprite Editor** button to open the **Sprite Editor** tool, allowing you cut
    apart the whole texture into specific slices. See *Figure 5.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: Specifying a sprite as Multiple'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Sprite Editor** tool, you can separate different parts of a texture
    into discrete and separate units. One method to achieve this is by drawing a rectangle
    around each image area that should be separate, and simply clicking and dragging
    your mouse to draw a texture region. See *Figure 5.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: Drawing a sprite manually'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, although a sprite can be separated manually, as we''ve just seen, Unity
    can often cut apart the texture automatically, identifying isolated areas of pixels
    and saving us a lot of time. We''ll do that here for the player character. To
    do this, click on the **Slice** button listed at the top left corner of the **Sprite
    Editor** window. See *Figure 5.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.31: Accessing the Slice tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Slice** tool window, ensure that **Type** is set to **Automatic**,
    which means that Unity will auto-detect the location of separate sprites. **Pivot**
    can be left at **Center**, determining the pivot point for each sprite. **Method**
    should be **Delete Existing**, meaning that any existing sprites or slices in
    the texture space will be erased and replaced entirely by the newly autogenerated
    slices. Then, click on the **Slice** button to confirm the operation and the texture
    will be sliced into separate sprites with a clear border drawn around each sprite.
    See *Figure 5.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.32: A fully sliced sprite'
  prefs: []
  type: TYPE_NORMAL
- en: 'The texture is now divided into several sprites: head, body, arm, and leg.
    The final character in-scene will obviously have two arms and two legs but these
    will be formed from duplicated sprites. The final process now is to set the pivot
    point for each sprite—the point around which the sprite will rotate. This will
    be important later to animate the character correctly, as we''ll see. Let''s start
    by setting the pivot for the head. Select the head sprite in the editor and then
    click and drag the pivot handle (blue circle) to reposition the sprite''s center
    of rotation. Click and drag the handle to the bottom middle of the head, roughly
    where the head would connect to the neck. This makes sense because the head will
    rotate and hinge from around this point. As you move the pivot around, you should
    see the **X** and **Y** values change from the **Custom Pivot** field in the **Sprite
    Properties** dialog, shown in the bottom right-hand corner of the **Sprite Editor**
    window. See *Figure 5.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.33: Repositioning the sprite pivot'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, position the pivot for the arm, which should be at the shoulder joint
    where the arm connects to a torso; then for the leg, which should be near the
    hip where the leg connects to a torso, and finally, the torso itself, whose pivot
    should be at the hip joint. See *Figure 5.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.34: Positioning the pivot for the torso'
  prefs: []
  type: TYPE_NORMAL
- en: 'When completed, click on the **Apply** button to confirm changes and then close
    the **Sprite Editor**. On returning to the main Unity interface, the appearance
    of the character texture will have changed in the **Project** panel. Specifically,
    the character texture features a small arrow icon attached to the right-hand side.
    When you click this, the texture expands to review all the separate sprites in
    a row, which can be dragged and dropped individually to the scene. See *Figure
    5.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure: 5.35: Previewing character sprites'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve isolated all player sprite textures, we can start to build
    a game character in the scene. Start by creating an empty game object with the
    **GameObject** | **Create Empty** command from the application menu. Name the
    object `Player` and assign it a Player Tag from the Inspector. This object will
    act as the ultimate or topmost parent object for the player character. Existing
    beneath this object as children will be the character''s constituent parts: torso,
    arms, and legs. So, let''s drag and drop the Torso sprite from the **Project**
    panel to the **Hierarchy** panel as a child of the **Player** object. See *Figure
    5.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.36: Starting the player character'
  prefs: []
  type: TYPE_NORMAL
- en: After the torso has been added, we can add legs and arms. The arms should be
    added as children of the torso because the torso determines where the arms will
    be. However, the legs should be added as children of the **Player** object and
    are therefore siblings of the torso, because the torso can rotate independently
    of the legs. See *Figure 5.37* for the complete hierarchical arrangement. As you
    add each limb, you'll want to offset its position so that it appears correctly
    in relation to other limbs—the head should appear above the feet and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.37: Building a character'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rendering order of body parts is probably not correct by default insofar
    as each item will have an identical order in the Sprite Renderer component. This
    means that Unity could potentially render each limb in any order, allowing arms
    to appear in front of the head, legs to appear in front of the body, and so on.
    To correct this, we''ll select each limb in turn and assign it an appropriate
    order value, taking care that it''s higher than the world background order and
    less than the world foreground order. I''ve assigned the body an order of `103`,
    the head `105`, left arm `102`, right arm `104`, left leg `100`, and right leg
    `101`. See *Figure 5.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.38: Ordering body parts'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rendering order for limbs is now configured successfully. Let''s set up
    collisions and physics for the player. To do this, add two colliders—a Circle
    Collider to approximate the character feet, allowing us to determine when the
    character is in contact with the ground, and a Box Collider that approximates
    most of the body including the head. These colliders can be added by selecting
    the **Player** object (the topmost object) and then navigating to **Component**
    | **Physics 2D** | **Circle Collider 2D** and **Component** | **Physics 2D** |
    **Box Collider 2D**. See *Figure 5.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.39: Adding two colliders to the Player Object: Circle Collider and
    Box Collider'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Circle Collider is of special importance because it''s the primary means
    to determine whether the character is touching the ground, and it''ll also be
    in contact with the ground as the character moves. For this reason, a Physics
    Material should be assigned to this collider to prevent friction effects from
    stopping or corrupting character motion as it moves around the scene. To achieve
    this, create a new Physics Material by right-clicking in the empty space in the
    **Project** panel and choose **Create** | **Physics2D Material** from the context
    menu. Name the material `Low Friction`. See *Figure 5.40*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.40: Creating a new Physics Material'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Physics2D material in the **Project** panel, and from the **Inspector**,
    change the Friction setting to `0.1`. Then, drag and drop the Physics2D material
    from the **Project** panel to the **Material** slot for the CircleCollider2D component
    on the **Player** object. See *Figure 5.41*. Using these settings, the character
    will behave more realistically.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.41: Assigning a Physics material to the player character'
  prefs: []
  type: TYPE_NORMAL
- en: Then, finally assign RigidBody2D to the **Player** object and set both **Linear
    Drag** and **Gravity Scale** to `3`. In addition, set **Collison Detection** to
    **Continuous** for the most accurate collision detection and **Freeze Rotation**
    of the object on the *Z* axis because the player character should never rotate.
    Now, you have a fully completed physical object representing the player. See *Figure
    5.42*. Good work!
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player](img/figure_05_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.42: Configuring the player character for Physics'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the player movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game so far features an environment with collision data and a multipart
    player object that interacts and responds to this environment. The player, however,
    cannot yet be controlled, and this section explores controller functionality further.
    The user will have two main input mechanics, namely, movement (walking left and
    right) and jumping. This input can be read seamlessly and easily using `CrossPlatformInputManager`,
    which is a native Unity asset package. This package was imported at the project
    creation phase, but it can be imported now via the application menu with **Assets**
    | **Import Package** | **CrossPlatformInput**. Once imported, open the `Standard
    Assets` | `CrossPlatformInput` | `Prefabs` folder and drag and drop the **MobileTiltControlRig**
    prefab to the scene. This prefab lets you read input data across a range of devices,
    mapping directly to the horizontal and vertical axes that we''ve already seen
    in previous chapters. See *Figure 5.43*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting the player movement](img/figure_05_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.43: Cross-platform input prefabs offer easy multidevice control'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now script player controls. To do this, create a new C# script named
    `PlayerControl.cs` and attach it to the Player character. The full source code
    for this file is given in the *Code Sample 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 5.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerControl` class is responsible for handling all player input, making
    the character move left and right and jump.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve player movement, a reference to the RigidBody2D component is retained
    in the `ThisBody` variable, which is retrieved in the `Awake` function. The movement
    and motion of the player is set using the `RigidBody2D.Velocity` variable. More
    information on this variable can be found online at [http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html](http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FlipDirection` function is used to invert the horizontal scale of the sprite,
    turning it to face left or right as needed (reversing the image direction, for
    example, `1` and `-1`). From Unity 5.3 onward, the `Flip` property of the `SpriteRenderer`
    component can be used instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FixedUpdate` function is used instead of Update to update the movement
    of the player character because we're working with `RigidBody2D`—a physics-based
    component. All physics functionality should be updated in `FixedUpdate` that is
    invoked at a fixed interval each second as opposed to every frame. More information
    can be found at the Unity online documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetGrounded` function detects where any `CircleCollider` intersects and
    overlaps with any other collider in the scene on a specific layer. In short, this
    function indicates whether the player character is touching the ground at the
    position of the feet. If so, the player is able to jump; otherwise, the player
    cannot jump as they are already airborne. Double-jumping is not allowed in this
    game!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the preceding code to work correctly, a few tweaks must be made to both
    the scene and player character. Specifically, the `GetGrounded` function requires
    that the floor area of the level is grouped together on a single layer. This simply
    means that the level foreground should be on a distinctive layer from other objects.
    To achieve this, create a new layer named `Ground`, and then assign the foreground
    object to this layer. To create a new layer, select the foreground object and,
    from the **Object Inspector**, click on the drop-down named **Layer**. Then, select
    Add Layer from the context menu. See *Figure 5.44*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 5.1](img/figure_05_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.44: Adding a new layer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add a new layer named `Ground` simply by entering `Ground` in an available
    type-in field. See *Figure 5.45*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 5.1](img/figure_05_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.45: Creating a new ground layer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, assign the foreground object to the `Ground` layer. Simply select the
    foreground object, and then select the **Ground** layer from the **Layer** drop-down
    in the **Object Inspector**. After the foreground object is assigned to the ground
    layer, the `PlayerControl` script requires us to indicate which layer has been
    designated for the ground. To achieve this, select the **Player** object and,
    from the **Object Inspector**, select the **Ground** layer for the **Ground Layer**
    field. See *Figure 5.46*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 5.1](img/figure_05_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.46: Selecting the Ground layer for collision detection'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the **Feet Collider** slot needs assignment too in order to indicate
    which collider object should be used for ground collision detection. For this
    field, you need to drag and drop the **CircleCollider** component to the **Feet
    Collider** slot. See *Figure 5.47*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 5.1](img/figure_05_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.47: The Feet Collider detects when the character is in contact with
    the ground'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, give the player character a test run. Simply click on the play icon on
    the toolbar and test out the controls of the player character. *W*, *A*, *S*,
    *D* (or the arrow keys) will move the player character around. The spacebar makes
    the character jump. See *Figure 5.48*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 5.1](img/figure_05_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.48: Play testing with the player character'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our work so far has produced an interesting environment and a controllable character
    within this environment. Before moving forward, let's turn our attention to optimization—an
    issue that should be considered early during development. Optimization refers
    to the tips and tricks that we can apply to improve runtime performance as well
    as our workflow generally. Here, we'll consider prefabs to improve our workflow
    and Sprite Packing to improve runtime performance. Let's start with prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prefab is a Unity asset that lets you group together many objects in a scene
    and package them together as a single unit that can be added to the **Project**
    panel as an asset. From here, the prefab can be added as a complete unit to any
    other scene or environment as though it were a separate and complete *thing*.
    The player character is an ideal candidate for a prefab because it must feature
    in all the other scenes we create. Let''s create a prefab from the player. To
    do this, simply drag and drop the **Player** object to the **Project** panel in
    a separate folder called `Prefabs`. See *Figure 5.49*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/figure_05_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.49: Generating a player prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the **Prefab** is created, the **Player** object name in the hierarchy
    panel will turn blue, indicating that it''s connected to the Prefab asset. This
    means that if you select the **Prefab** in the **Project** panel and make changes
    in the Inspector, then the **Player** object in the scene will change automatically
    to match these changes. You can, however, break the connection between the **Player**
    in the scene and **Prefab** by selecting the **Player** object and choosing **GameObject**
    | **Break Prefab Instance** from the application menu. This converts the scene
    object into a separate and independent duplicate of the Prefab. See *Figure 5.50*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/figure_05_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.50: Breaking a prefab instance'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, however, you''ll want to keep the connection between objects
    and their prefabs. Sometimes, though, you may make changes to the object in the
    scene, and then want these changes to feedback to the **Prefab** asset in the
    **Project** panel, affecting all other linked instances if there are any. To do
    this, select the object to which changes have been made, and then select **GameObject**
    | **Apply Changes to Prefab** from the application menu. See *Figure 5.51*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/figure_05_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.51: Applying changes to a prefab'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to making Prefabs, you'll also want to optimize the render performance
    for your 2D games. Right now, when running the game, Unity will perform a unique
    and separate draw call for each and every unique texture or sprite onscreen at
    the time. A draw call simply refers to a step or process cycle that Unity must
    run through to properly display a graphic onscreen, such as a mesh, material,
    or texture. Draw calls represent a computational expense, and so it's a good idea
    to reduce them wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For 2D games, we can reduce draw calls by batching together related textures,
    such as all the props for a scene, all the enemies, or all the weapons. That is,
    by indicating to Unity that a group of textures belong together, Unity can perform
    internal optimizations that increase render performance. Specifically, Unity will
    paste all related textures in a single and larger internal texture that it uses
    instead. To achieve this optimization, select all *prop* textures. For our game,
    I will include the **Player**, **House**, **Platform**, and **Gem** as props.
    These textures are all featured in the **Project** panel, though not all are used
    in the game yet. Select these textures and, from the Inspector, assign them the
    same name for the **Packing Tag** field (Props). Then, click on **Apply**. See
    *Figure 5.52*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/figure_05_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.52: Assigning multiple textures to the same Packing Tag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, repeat this process for the **Backgrounds**, selecting all backgrounds
    and assigning them to the **Background Packing** tag. Then, click on **Apply**.
    See *Figure 5.53*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/figure_05_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.53: Creating a Background batch of textures'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! Now, when you press on the play icon, Unity will automatically
    batch and organize the textures for optimal performance based on your groupings.
    This technique can significantly reduce draw calls. On pressing the play icon,
    you may see a loading bar or progress bar while Unity internally generates a new
    texture set. During Play Mode, you can view how Unity has organized the textures
    through the **Sprite Packer** window. To access this, select **Window** | **Sprite
    Packer**. See *Figure 5.54*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/figure_05_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.54: Unity organizes all similarly tagged textures into the same texture
    space as an Atlas'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Superb work! We've come a long way in this chapter, from a blank project to
    an effective 2D game in which a player character can navigate a complete 2D environment
    with 2D Physics. The character can move left and right and jump, and the sprite
    texture will change to match the direction of travel as well. In addition, Sprite
    Packing has been used to optimize runtime performance, which is ideal for mobile
    devices. In the next chapter, we'll continue working by adding obstacles, collectable
    objects, and more!
  prefs: []
  type: TYPE_NORMAL
