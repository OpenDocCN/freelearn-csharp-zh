- en: Securing Your Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we saw how to exchange data between multiple services
    using an event bus and resilient clients and how to consume messages and run background
    services using ASP.NET Core. This chapter is about securing service data. It covers
    concepts such as SSL, **cross-origin resource sharing** (**CORS**), and HTTP/2,
    and it walks through the implementation of token-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, this chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A general overview of SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enable CORS in an ASP.NET Core service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enable HTTPS and HTTP/2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How token-based authentication works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build token-based authentication in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a broad understanding of the security
    features provided by ASP.NET Core, and you will be able to implement token-based
    authentication in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of secure communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a crucial aspect of building applications. Web services usually
    expose information to third-party clients and companies; therefore, it is vital
    to avoid leaking data. The security layer of a web service is often a tedious
    part of the development process because it is hard to test and to verify.
  prefs: []
  type: TYPE_NORMAL
- en: Security is important even for web services that are published in the internal
    network of the company, which, by default, is not accessible from the outside.
    As software engineers, we should do as much as possible to guarantee a strong
    level of security when we release a web service. It is also essential to understand
    that securing a web service is necessary to identify the consumers of your data
    and to prevent overuse of your web service. The next section will start by describing
    HTTPS and how to secure your data using HTTPS in a ASP.NET Core web service.
  prefs: []
  type: TYPE_NORMAL
- en: Securing data using HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common practice for attackers is to intercept data exchanged between the
    client and the server. For that reason, it is essential to encrypt communication
    between them to keep the data secure. SSL uses SSL certificates to set up a trusted
    connection between the server company and the client. SSL uses *symmetric* and
    *asymmetric encryption* to encrypt keys used during this communication. Let''s
    see a schema of a typical SSL handshake between client and server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38cf9627-a94f-4c11-a896-59138269b4f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This schema shows the conventional steps of an SSL handshake:'
  prefs: []
  type: TYPE_NORMAL
- en: The connection starts with the client that initiates the request. Before the
    start, the server sends an SSL certificate to the client, which ensures that the
    certificate is valid and trustable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client proceeds by extracting and encrypting the *public key* included in
    the SSL certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends the encrypted key (private key) to the server, which encodes
    the data and transmits it back to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data communication starts and the encrypted key is used to encrypt and decrypt
    data shared by the client and the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSL is the basis of the HTTPS protocol, which is the standard way to transfer
    encrypted data. The following section describes how to set up and enforce HTTPS
    in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing HTTPS in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTPS is enabled by default on ASP.NET Core. The main middleware related to
    the HTTPS protocol is the `HttpsRedirection` middleware class, which enforces
    redirection from HTTP to HTTPS. Therefore, it is possible to call the `UseHttpsRedirection`
    extension method in the `Startup` class in order to enable the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to enable and force HTTPS in an ASP.NET Core application running
    in a docker container. The first step is to generate a self-signed certificate
    used by the ASP.NET Core application that runs in the container. .NET Core provides
    a global tool that creates a self-signed certificate on your local environment
    called `dotnet-dev-certs`. We can proceed by installing this tool on our local
    environment using the following CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, it is possible to create a new certificate using the `.pfx` format
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned instruction specifies the export path using the `-ep` option,
    with the `-p` password. Furthermore, it is possible to trust the certificate using
    the `--trust` options.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `dotnet-dev-certs` tool works only on Windows
    and macOS. In the case of Linux, we should proceed by generating the certificate
    using OpenSSL. The following tutorial ([https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core](https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core))
    provides more information about the creation of an HTTPS certificate using OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created a new certificate file, we can proceed by adjusting the
    `docker-compose.yml` file of the `Catalog.API` and `Cart.API` solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned `docker-compose.yml` definition declares a `volumes` node
    to create a binding between the local `./certificate/` folder and the `/root/.dotnet/https`
    folder in the instance of the container. Furthermore, we can proceed by adding
    the following variables in the `containers/api.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The file adds two environment variables related to the certificate: `ASPNETCORE_Kestrel__Certificates__Default__Password`
    provides the certificate password, and `ASPNETCORE_Kestrel__Certificates__Default__Path`
    defines its path. The new definition of the `docker-compose.yml` file also exposes
    the `5001` port, and it also adds the `https://*:5001 URL` URL to the pool of
    URLs run by Kestrel. Futhermore, now it is possible to enforce the HTTPS in our
    `Startup` class by adding the following line in the `Configure` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After applying the HTTPS restriction, the client will always be redirected to
    the HTTPS endpoint of the web service for every request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 on Kestrel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core has supported HTTP/2 on Kestrel since version 2.2.0, and it is
    enabled by default if you are using HTTPS. In addition, another HTTP/2 requirement
    is support for the **Application-Layer Protocol Negotiation** (**ALPN**) protocol.
    The ALPN protocol enhances the handshake process between a client and a server:
    the client lists all the supported protocols, and the server will confirm which
    protocol to use for the HTTP transfer. Moreover, this approach allows an eventual
    fallback to HTTP 1.1 if the client or the server doesn''t support HTTP/2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the default configuration, both HTTP 1.1 and HTTP/2 run on the same binding,
    but it is possible to customize and create a dedicated binding for HTTP/2 by extending
    the Kestrel configuration in the `static void Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows how to set an HTTP/2 binding on port number `5002`. This
    approach forces the HTTP/2 bindings without providing any fallback to HTTP 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CORS in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another critical aspect of security is to protect our APIs from CORS calls.
    By default, it is not possible to use client-side code to call services that are
    hosted on other domains, because scam websites may use a cross-origin call to
    get sensitive information about users. This security restriction is called *the
    same-origin policy*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The restrictions on the *same-origin policy* act on HTTP calls using the following
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: The request is made from a different domain (for example, the site at `example.com`
    calls `api.com`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request is enabled from a different subdomain (for example, the website
    at `example.com` calls `api.example.com`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request is made from a different port (for example, the site at `example.com`
    calls `example.com:3001`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request is made from a different protocol (for example, the `https://example.com`
    site calls `http://example.com`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS provides a way to allow a specific domain to make client-side calls to
    a service hosted within a different domain. This kind of approach becomes very
    useful when we want to enable a customer or a third-party client to call our service
    without restrictions. It is also essential to note that CORS can be enabled to
    allow every domain. This approach must be avoided because it will enable attackers
    to use our API inappropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides an out-of-the-box way to enable CORS*.* The framework
    permits the creation of CORS policies using two approaches: the *middleware approach*
    and the *attributes approach.* As we saw in [Chapter 3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml),
    *Working with the Middleware Pipeline*, middleware are usually implemented to
    develop cross-cutting logic that covers the whole web service. On the other hand,
    *attributes* are used to apply a restriction on a single action. In the same way,
    this approach is taken for CORS policies.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CORS using the middleware approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *CORS middleware* approach can be used to enable a specific HTTP domain,
    method, or port to call our service. As with any middleware, it can be defined
    in the `Startup` class of the service, specifically in the `Configure` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UseCors` middleware extension method accepts an action method to configure
    the different rules. For example, the previous code executes the `AllowAnyOrigin`
    method to allow calls from any website. In the same way, it is possible to define
    more restricting rules on a specific domain, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are blocking all cross-origin requests except those coming
    from the [https://samuele.dev/](https://samuele.dev/) website. A more advanced
    and clean way to define CORS rules is to group them using named policies. It is
    also possible to use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous code defines a CORS policy with the name `BlogDomainPolicy` using
    the `app.AddCors` construct in the `ConfigureServices` method. Once we have described
    the rules for the policy, we can proceed with using the defined policy in the
    `Configure` method of the `Startup` class using the `app.UseCors` method. It will
    enable us to establish different policies and apply them conditionally in the
    `Startup` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CORS using the attribute approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, it may be necessary to define specific policies for some routes
    or actions. Therefore, it is possible to apply CORS policies using attributes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are restricting the use of the `BlogDomainPolicy` only to
    the `ItemController`. Therefore, all of the routes defined under the controller
    will use the same policy. In the same way, we can add the policy to a specific
    action method in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In that case, the `GetByIdActionPolicy` will act only on the `GetById` action
    method, while the `BlogDomainPolicy` will act on the whole controller. This approach
    provides a nice level of granularity; furthermore, it provides a way to specify
    policies for a single route of the service. The next section describes the characteristics
    of the token-based authentication approach.
  prefs: []
  type: TYPE_NORMAL
- en: Securing APIs with token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications have traditionally persisted identity through session cookies,
    relying on session IDs stored on the server-side. This method brings a few significant
    problems and pitfalls: it is *not* *scalable*,because you need a common point
    where you can store sessions and, every time a user is authenticated; the server
    will need to create a new record in a data source. Therefore, this approach may
    become a significant bottleneck for your web service.'
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, token authentication can be helpful to authenticate and authorize
    users, especially in a distributed system context. The main strength of token-based
    authentication lies in the fact that the consumer asks for a token to an identityservice.
    Next, the client can store the token locally and use it for authentication and
    authorization purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, token authentication is *stateless* and *designed to be scalable*.
    Let''s have a look at the token-authentication process and how it works, to better
    understand the benefits of this kind of approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ee505ee-009d-4b3e-a04b-4499295d996b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This schema describes a typical workflow when implementing token-based authentication.
    The schema describes three entities:'
  prefs: []
  type: TYPE_NORMAL
- en: The *client* is the application that is trying to access our resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *identity provider* is the service that, given a username and a password,
    provides an encrypted authentication token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *resource provider* is another service called by the *client.* Furthermore*,
    the resource provider* will accept the encrypted authentication token, and it
    will provide the information requested by the *client* if it is authorized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since token-based authentication has a *stateless* approach, the application
    doesn't store the authentication tokens. Therefore, it is essential to note that
    the client must pass the authentication token in every request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Token-based authentication can be implemented in different ways. **JSON Web
    Token** (**JWT**) is a standard, defined in the RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    open directive, which describes a way to represent claims between two parties.
    JWT is defined as a JSON object, which contains the payload, and a signature,
    which encrypts the data in the token. In other words, it provides a way to encrypt
    secure data formatted as JSON through the use of a secret key. The JWT token standard
    has become quite popular in recent years because web services can use it for two
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization**: The web service returns a JWT token to transfer information
    about claims and personal details to signed-in users. Moreover, single sign-on
    features and token authentication features use this technique to transfer data
    to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information exchange**: You can use the JWT token standard to prevent data
    exploitation and to certify the authenticity of the data you have received by
    signing it with the provided key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JWT token anatomy is very similar to the structure of a web request. It
    is composed of three parts: *header*, *payload*, and *signature*. The header part
    contains information about the token type and the signing algorithm used by the
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case, we can deduce that the token uses the *HMAC* *SHA256* algorithm,
    and it is a JWT token type. The *payload* part is the core part of our token,
    and it contains the information to be sent to the user. By default, there is a
    set of predefined information to populate, for example, the `exp` *(expiration
    time)* field. The following JSON is an example of a payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `email` field is a claim for the token. `nbf` stands for **not valid before**,
    and `iat` stands for **issued at**. The three fields represent the time calculated
    since the UNIX epoch.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *signature* part of the token signs the encoded header and the
    encoded payload with the secret key and the algorithm specified in the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting encoded token is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is crucial to note that each point separator (`.`) in the encoded token represents
    an encrypted token, as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to perform token-based authentication using
    ASP.NET Core. Going into more detail, we will dig into the development and testing
    of the token-based authentication and learn how to store user data in a database
    using the default identity provider of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will implement the authentication as part of the *catalog service*
    solution. It is essential to note that, in real-world applications, the authentication
    and the whole identity process have a dedicated service with a separate data store.
  prefs: []
  type: TYPE_NORMAL
- en: For demo purposes, we are going to implement the authentication part inside
    the *catalog service*. Please consider keeping the identity part of your application
    in a separate service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the packages we need to develop token-based authentication
    in our `Catalog.Domain` and `Catalog.Infrastructure` projects. Please note that
    these packages are compatible only with the `netcoreapp3.1` framework, therefore,
    you need to change the `TargetFramework` variable in the csproj from `netstandard2.1`
    to `netcoreapp3.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define the `User` entity inside the `Catalog.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `User` entity represents a generic user inside the *domain model* of the
    service. It is important to note that it extends the `IdentityUser` class, which
    provides some additional fields to the entity. The `IdentityUser` class identifies
    a storable user entity. Furthermore, the entity can be used to store data through
    the `Microsoft.AspNetCore.Identity` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by declaring the `IUserRepository` interface in the `Catalog.Domain`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This interface represents an intermediary between the *catalog service* and
    the data layer. Moreover, it can be used to authenticate, register, and retrieve
    `User` entities. The `IUserRepository` acts like a data store for the user data,
    and it also performs user-related operations, such as the sign-up process and
    authentication. It is also important to note that the `AuthenticateAsync` and
    `SignUpAsync` methods return a boolean that indicates whether the corresponding
    operation has succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After defining the `User` entity and the `IUserRepository` interface, we can
    proceed with the definition of the service layer in the `Catalog.Domain` project.
    Let''s start by describing the `IUserService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface defines the methods necessary for the authentication phase. The
    `GetUserAsync` method uses the `GetUserRequest` type to retrieve information related
    to a specific user. The `SignUpAsync` and the `SignInAsync` methods define the
    sign-up and sign-in process: the sign-up operation returns a new `UserResponse`
    instance, which determines the information related to the signed user, and the
    sign-in operation returns the `TokenResponse` instance, which contains the resulting
    token that will be stored by the client. Therefore, let''s proceed by defining
    the request DTOs used by the service interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, request classes are represented in a unique snippet. The `GetUserRequest`
    type contains an `Email` field that specifies the email address to retrieve. As
    we will see later in the chapter, the `GetUser` action method of the controller
    will need to be authenticated in order to retrieve the user's data.
  prefs: []
  type: TYPE_NORMAL
- en: The `SignInRequest` type defines the `Email` and the `Password` fields used
    to authenticate the user. Finally, the `SignUpRequest` type also contains the
    `Name` of the user represented by a string. Please note that for demo purposes,
    the code only stores the `Name` of the user. In a real-world application, the
    complexity of the `SignUpRequest` type is likely to increase with more personal
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by also defining the response type used by the `IUserService`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `UserResponse` type is meant to retrieve all the personal information of
    the user. It is important to note that it obviously omits the `Password` field
    of the entity for security reasons. On the other hand, the `TokenResponse` type
    retrieves the `Token` field containing the JWT token resulting from the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can continue by describing the implementation of `IUserService`
    interface: it will contain the logic related to the generation of the token used
    by ASP.NET Core for authentication, and the get and sign-up operations on user
    entities. The following code illustrates the dependencies in the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, the `IUserRepository` interface is used as the main
    entry point to query and perform operations on our data source. `IOption<AuthenticationSettings>`
    type defines the settings needed by the authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The class is stored in the `Configurations` folder of the `Catalog.Domain`
    project. The `AuthenticationSettings` class contains the `Secret` field, which
    describes a phrase that is used to encrypt the token''s information, and the `ExpirationDays`
    field provides the number of days before the omitted tokens expire. Furthermore,
    we can proceed by defining the `GetUserAsync` and the `SignUpAsync` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `GetUserAsync` method uses the request provided by the high-level layer
    to execute the `GetByEmailAsync` method of the `IUserRepository` interface. It
    also maps the response and retrieves a new instance of the `UserReponse` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `SignUpAsync` method initializes a new `User` instance
    with the corresponding values, and it performs the `SignUpAsync` method provided
    by the `IUserRepository` interface. Finally, if the user is created, the `SignUpAsync`
    method retrieves a new `UserResponse` instance. Let''s continue by completing
    the implementation of the `IUserService` by defining the `SignInAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As a first step, the `SignInAsync` method calls the underlying `AuthenticateAsync`
    method provided by `IUserRepository` by giving the `Email` and the `Password`
    sent by the client. The statement returns a boolean variable that indicates whether
    the user is authenticated. If the user is authenticated, the method retrieves
    a new instance of the `TokenResponse` class by calling the `GenerateSecurityToken`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `GenerateSecurityToken` method defines a new instance of the `JwtSecurityTokenHandler`
    type, which provides some utilities for generating and creates tokens through
    the use of the `CreateToken` and the `WriteToken` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it defines a new instance of the `SecurityTokenDescriptor` type,
    which declares the `Expire` time and the `SigningCredentials` fields by signing
    the `Secret` field of the `AuthorizationSettings` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Applying authentication on the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next steps consist of registering dependencies in the dependency injection
    engine and in using the resulting dependency, for example, the `IUserService`
    instance, in the controller layer. Therefore, this section focuses on the `Catalog.API`
    and `Catalog.Infrastructure` projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a new extension method in the `Catalog.Infrastructure`
    project, which adds the authentication part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The core part of the preceding code is the execution of two methods: `AddAuthentication`
    and `AddJwtBearer`. Both extension methods add the middlewares and the services
    used by the authentication process. In more detail, `AddAuthentication` specifies
    `DefaultAuthenticationScheme` and `DefaultChallengeScheme` by applying the JWT
    bearer authentication scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the `AddJwtBearer` method defines the options related to token
    authentication, such as the `TokenValidationParameters` field, which includes
    the `SigningKey` used to validate the token parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `IssuerSigningKey` must be the same as the key used to generate
    the token. Otherwise, the validation will fail. It is important to note that the
    `ValidateIssuer` and the `ValidateAudience` fields are `false`. Therefore, ASP.NET
    Core will not validate the issuer or the audience URL. Although this approach
    works fine for testing environments, I strongly suggest using the following setup
    for production cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the validation of the issuer and the audience will happen; therefore
    it will check that the token issuer and the audience of the token match those
    specified in the configurations. The `AddTokenAuthentication` extension method
    also owns the registration of the `AuthenticationSettings` used by the `UserService`
    class. Therefore, let''s have a look at the `AuthenticationSettings` values defined
    in the `appsettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can proceed by adding the authentication implementation to the
    `Startup` class in the `Catalog.API` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Startup` class is the core component that initializes the authentication
    process. In the `ConfigureServices` method, it configures and initializes the
    `AuthorizationSettings` class by reading from the `appsettings.json` file. Next,
    it calls the `AddAuthentication` extension method by passing the `AuthorizationSettings`
    type instance. It is also essential to note that the `Configure` method adds authentication
    middleware by calling the `UseAuthentication` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can proceed by adding the `UserController` and exposing authentication
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines the `UserController` class, which exposes authentication
    routes. It is important to note that the whole controller is decorated by using
    the `[Authorize]` attribute, which means that each route is covered by authentication.
    Therefore, to access the routes declared within the controller it is necessary
    to use a valid token in the request. The class defines an action method for each
    operation defined before in the service layer:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Get` action method exposes some details regarding the current user, such
    as the `Email` field and the `Name` field. The action method gets user details
    from the incoming token. The token information is represented by accessing the
    `HttpContext.User` property and getting the value of `ClaimType.Email`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SignIn` action method is decorated using `[AllowAnonymous]` attribute.
    Furthermore, it is possible to call the action method without being authenticated.
    The action method binds the `request.Email` and `request.Password` fields and
    sends the request object using `IUserService` interface. The action method returns
    the `TokenResponse` with the generated token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SignUp` action method is also decorated using the `[AllowAnonymous]` attribute.
    In that case, the action method registers a new user and returns the `201 Created`
    HTTP code if the operation has success.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our setup is now almost complete. What we need to do is define the last common
    point between the `IUserRepository` interface and the underlying data store. For
    this purpose, we will use again the EF Core framework combined with the `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    package maintained by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data using EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s proceed by implementing the data access layer and create a concrete
    implementation of the `IUserRepository` interface. The `UserRepository` class
    will have to main dependencies, the `SignInManager` and the `UserManager` classes,
    both of which are provided by the `Microsoft.AspNetCore.Identity` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the resulting code implements the `IUserRepository` interface.
    The class depends on the `SignInManager<User>` and the `UserManager<User>` types.
    These types accept a generic entity class that is a representation of the authentication
    objects. The `SignInManager<T>` generic class provides functionalities with which
    to interact with the user sign-in process.
  prefs: []
  type: TYPE_NORMAL
- en: It exposes the `PasswordSignInAsync` method used by the `UserRepository.Authenticate`
    method. On the other hand, the `UserManager<T>` class provides ways to interact
    with users in a persistent store. Furthermore, `UserRepository` uses the `SignUp`
    and the `UserRepository.GetByEmail` method to interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the identity database context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have declared the `IUserRepository` implementation, we can proceed
    by declaring the *identity data context.* The *identity data context* is identified
    by extending the `IdentityDbContext` class. This type of `DbContext` is used by
    EF Core to locate and access the data source used as the persistent user store.
    In order to declare the *identity data context,* it is necessary to extend the
    `CatalogContext` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It is essential to note that the `IdentityDbContext` class extends the `DbContext`
    class. Furthermore, every property and behavior present in the `DbContext` class
    is also inherited by the `IdentityDbContext` class. Therefore, it is essential
    to note that the override method, `OnModelCreating`, must also call the base method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a way to store user information using EF Core, it is also necessary
    to add and configure the identity system for the specified `User` type by calling
    the `AddIdentity` extension method. Furthermore, it is also essential to call
    `AddEntityFrameworkStores` and refer to the `CatalogContext` class to add the
    entity framework implementation. The following code is the previously created
    `AddAuthentication` extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can proceed by initializing `IUserRepository` with its concrete
    implementation. Also, in that case, we will declare the dependency injection resolution
    in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we can register `IUserService` by adding the following row
    to the `AddServices` extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To sum up, now we have the whole authentication stack in place. The `Catalog.API`
    project exposes the HTTP routes through the `UserController` class. The controller
    depends on the `IUserService` interface, which exposes the operation needed by
    the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the `UserService` class depends on the `IUserRepository` interface,
    which is the main entry point that calls the API exposed by the EF Core framework.
    Therefore, we can now proceed by verifying the authentication logic using some
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing our code is essential at this point: we should check, document, and
    verify the behaviors of our system before running the application in a server
    instance. Furthermore, it is also crucial to test authentication behavior because
    it is a sensitive part of our service.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `UserRepository` implementation is the most low-level part of the
    authentication stack and the first component that relies on EF Core to retrieve,
    update, and authenticate the user, we can keep it isolated and exclude it from
    the testing process by mocking the `IUserRepository` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Both `SignInManager<T>` and the `UserManager<T>` classes represent a core part
    of our authentication process, and they are part of a third-party package maintained
    by Microsoft. Furthermore, it is not necessary to cover their implementations
    with tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a new `UserContextFactory` in the `Catalog.Fixture`
    project in the `tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The factory class exposes an `IUserRepository` instance with some pre-populated
    data and it depends on the `PasswordHasher<T>` generic type, which is used by
    `SignUp` and in the `Authenticate` mock methods declaration to *encode-decode*
    the password by using the `HashPassword` and `VerifyHashedPassword` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the `IUserRepository` interface is mocked through
    the use of the `GetInMemoryUserManager` method. Furthermore, it uses `List<User>`
    to emulate a data source, and it implements the `AuthenticateAsync`, `GetByEmailAsync`,
    and `SignUpAsync` methods exposed by the `IUserRepository` interface using the
    `Moq` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns a mocked `IUserRepository` instance by providing
    a fake behavior for the methods of the interface. Consequently, it is possible
    to verify the `IUserService` class by implementing the following test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The test class implements two different tests: `signin_with_invalid_user_should_return_a_valid_token_response`
    and `signin_with_valid_user_should_return_a_valid_token_response`. In both cases,
    the tests will use `UserContextFactory` to resolve the dependency of the class.
    We will also use the `Option.Create` method provided by ASP.NET Core to generate
    `AuthenticationSettings` options. In this case, we are testing the entire stack
    that has been implemented in the handler layer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to note that we are excluding the whole underlying part related
    to the management and storage of the users'' information. We can expand the scope
    of our tests by including the controller part. Going into more detail, we can
    implement the test to check the functionalities implemented in the `UserController`
    class. To do that, we will inject a fake `IUserRepository` implementation at `TStartup`
    time, using the `services.Replace` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can act on the `InMemoryApplicationFactory<TStartup>` class to replace the
    `IUserService` with a new instance of the mocked class by initializing the `UsersContextFactory`
    class. After that, it will be possible to test the `UserController` class action
    by resolving the `InMemoryApplicationFactory<TStartup>` factory class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The previous code verifies the routes defined in the `UserController` class,
    and it also performs an integration test by checking the authentication process.
    The `sign_in_should_retrieve_a_token` test method calls the `/api/user/auth` address
    using the HTTP `POST` verb to verify the implementation of the sign-in procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, it also validates the operation in case the user''s password
    is wrong. Furthermore, we can also provide more tests to verify the whole process
    of authentication, from the sign-in phase to the call to retrieve the authenticated
    user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Going into more detail, the `get_with_authorized_user_should_retrieve_the_right_user`
    test executes the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: It performs a `POST` request to the following route/`auth` in order to authenticate
    the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It deserializes the result of the `POST` request, and it gets the token field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It adds an authentication header by passing the token, and it performs a request
    to the `/api/user` route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks that the result status code is HTTP `200 OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this way, we are testing both the `UsersController` class and the underlying
    handlers used in each action method. It is also possible to test the authentication
    process by running the catalog web service using the `docker-compose up --build`
    command. First of all, we need to create a new user by adding some necessary information,
    such as the email and the name of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous HTTP call (written as a `curl` call) creates a new user with the
    specified credentials. We can proceed by generating the token using our credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can continue by calling the secret endpoint using the following
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned `curl` command calls the `https://localhost:5001/api/users/`
    address by passing the token in the `Authorization` header of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to secure a web service using some standard
    practices. HTTPS is now a standard and must-have feature if you want to secure
    data. Furthermore, we saw how token-based authentication provides a useful way
    to secure data and information that are exposed.
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered in this chapter provide a way to secure information exposed
    by the web service, and explored the implementation of token-based authentication
    in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to cache responses in ASP.NET Core and
    look at how a caching mechanism works in general.
  prefs: []
  type: TYPE_NORMAL
