<html><head></head><body>
        

                            
                    <h1 class="header-title">Working with the Middleware Pipeline</h1>
                
            
            
                
<p class="mce-root">The previous chapter provided an overview of ASP.NET Core projects. We looked at how to create an ASP.NET Core project and how to deal with the files and the structure involved. Also, we learned some of the basic concepts behind the MVC stack and ASP.NET Core. Now, let's explore the concept of middleware in depth. Middleware is an essential part of the ASP.NET Core platform: it helps us to deal with incoming requests and outgoing responses. Most of all, these types of components can be used to monitor performances and implement cross-cutting functionalities. The chapter starts with an introduction to the middleware concept. It goes on to show how to implement custom middleware and it ends with an overview of the built-in middleware of ASP.NET Core. </p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Introducing middleware and dealing with its different aspects</li>
<li>Concrete use cases for middleware in an ASP.NET Core project</li>
<li>An overview of the built-in middleware of ASP.NET Core</li>
<li>Implementing custom middleware</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing middleware</h1>
                
            
            
                
<p>As the name suggests, middleware is a component placed between our application and incoming requests. Incoming requests hit the middleware's pipeline before they can reach the effective logic implemented in our application. As a result, middleware are considered one of the essential concepts of ASP.NET Core because it is the first layer in front of our application, and it is usually associated with cross-cutting concepts such as <em>logging</em>, <em>error handling</em>, <em>authentication</em>, and <em>validation.</em> It can also perform advanced tasks such as <em>conditional service initialization, </em>based on a request.</p>
<p class="mce-root"/>
<p>In general, middleware can:</p>
<ul>
<li>Handle, process, and modify incoming <em>HTTP requests</em></li>
<li>Handle, process, and change outgoing <em>HTTP responses</em></li>
<li>Interrupt the middleware pipeline by returning an <em>early response</em></li>
</ul>
<p>Furthermore, the whole ASP.NET Core stack is composed of middleware. Middleware is also compliant with some essential concepts of <em>clean code</em>:</p>
<ul>
<li>Each middleware focuses on a single purpose: taking a request and enhancing it. It is advisable to implement new middleware for each goal, to be compliant with the <em>single responsibility principle</em>.</li>
<li>Middleware also uses the concept of<em> chaining.</em> It takes an incoming request and passes it through the next piece of middleware.  Therefore, every piece of middleware enhances the request and it decides whether to interrupt or continue the middleware pipeline.</li>
</ul>
<p>As previously mentioned, middleware can <em>short-circuit</em> the pipeline, which means that it can block our requests and skip the rest of the pipeline. This <em>short-circuit</em> concept should not be underestimated as it is an excellent way to <em>increase the performance</em> of our service. Furthermore, the request will not hit our controllers if there is something wrong or if the user is not authorized to proceed. Moreover, the middleware pipeline is usually associated with a schema that looks like this:</p>
<div><img src="img/ecf5ed76-d153-4a5b-95e1-0870d11ec63a.png" style=""/></div>
<p>A single piece of middleware can act, and perform logic, on the <em>request</em> but also the <em>response.</em> Besides, it is essential to understand that the order of middleware countsâ€”indeed, we declare the order when we bind it to our pipeline. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The middleware pipeline in practice</h1>
                
            
            
                
<p>We have looked at some theory behind the middleware pipeline and how it can be useful in terms of short-circuiting and the single responsibility principle. Now let's contextualize that in ASP.NET Core. In the previous chapter, we looked at the default Web API template provided by .NET Core. Let's proceed by replacing the content of the <kbd>Startup</kbd> class with the following snippet of code:</p>
<pre>    public class Startup<br/>    {<br/>        public Startup(IConfiguration configuration)<br/>        {<br/>            Configuration = configuration;<br/>        }<br/><br/>        public IConfiguration Configuration { get; }<br/><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>        }<br/>        public void Configure(IApplicationBuilder app, IWebHostEnvironment <br/>        env)<br/>        {<br/>    <strong>        app.Run(async context =&gt;</strong><br/><strong>                    {</strong><br/><strong>                        await context.Response.WriteAsync("Hello, World!");</strong><br/><strong>                    });</strong><br/>        }<br/>    }</pre>
<p>We can run this project by executing the following CLI command in the <kbd>SampleAPI</kbd> folder:</p>
<pre><strong>dotnet run</strong></pre>
<p>The aforementioned command starts our application using the <kbd>http://localhost:5000</kbd> address. We can invoke it using our browser:</p>
<div><img src="img/68e623dc-705d-4dc5-a2b1-a89fd8ce1baf.png" style=""/></div>
<p>As you can see, running Hello, World! using a middleware strategy is simple. It requires implementing the <kbd>Configure</kbd> method, which is the method whereby middleware is usually defined. <kbd>app.Run</kbd> executes a delegate method, which is the representation of our middleware. In our case, it takes the <kbd>HttpContext</kbd> of the request and writes content inside the response of the context.</p>
<p>It is essential to understand how the ASP.NET Core framework implements the <kbd>Run</kbd> method. Let's have a closer look at the implementation of the <kbd>Run</kbd> method by checking the code in the <kbd>Microsoft.AspNetCore.Builder</kbd> namespace:</p>
<pre>using System;<br/>using Microsoft.AspNetCore.Http;<br/><br/>namespace Microsoft.AspNetCore.Builder<br/>{<br/>    /// &lt;summary&gt;<br/>    /// Extension methods for adding terminal middleware.<br/>    /// &lt;/summary&gt;<br/>    public static class RunExtensions<br/>    {<br/>        /// &lt;summary&gt;<br/>        /// Adds a terminal middleware delegate to the application's <br/>            request pipeline.<br/>        /// &lt;/summary&gt;<br/>        /// &lt;param name="app"&gt;The &lt;see cref="IApplicationBuilder"/&gt; <br/>            instance.&lt;/param&gt;<br/>        /// &lt;param name="handler"&gt;A delegate that handles the <br/>            request.&lt;/param&gt;<br/>        public static void Run(this IApplicationBuilder app, <br/>        RequestDelegate handler)<br/>        {<br/>            if (app == null)<br/>            {<br/>                throw new ArgumentNullException(nameof(app));<br/>            }<br/><br/>            if (handler == null)<br/>            {<br/>                throw new ArgumentNullException(nameof(handler));<br/>            }<br/><br/>            app.Use(_ =&gt; handler);<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding code gives us more details about what we are doing. We notice that the <kbd>RequestDelegate</kbd> handler cannot be <kbd>null</kbd>, and if we go deep into the stack we can see that our delegate will be added <em>at the end of the pipeline</em> by using the <kbd>app.Use</kbd> extension method.</p>
<p>It is essential to understand that the order of middleware counts. The order of the middleware pipeline is implicitly defined in the <kbd>Configure</kbd> method of the <kbd>Startup</kbd> class. Furthermore, <em>MVC middleware</em> is usually the last one hit by requests; on the other hand, authorization <em>middleware</em> is generally placed before other middleware to guarantee the correct security level (putting authorization <em>middleware</em> after <em>MVC middleware </em>may damage our service and make it unsafe)<em>.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">HttpContext in ASP.NET Core</h1>
                
            
            
                
<p>In the previous example, we saw how to create middleware using the <kbd>app.Run</kbd> extension method. A key concept involved in that implementation is the <kbd>HttpContext</kbd> type, which is the unique entry point for obtaining all information about HTTP properties; it is usually related to the incoming request. The <kbd>HttpContext</kbd> attribute exposes methods and properties to get information from the request and update information in the response. The response and request information are represented by the following attributes: <kbd>HttpContext.Response</kbd> and <kbd>HttpContext.Request</kbd>. For example, in the previous case, we used the  <kbd>WriteAsync</kbd> method, which wrote the <kbd>Hello World!</kbd> string in response to the current <kbd>HttpContext</kbd>.</p>
<p>Dependency injection is a core part of ASP.NET Core. <kbd>HttpContext</kbd> has all references to services instantiated in the current request. To be specific, it provides a <kbd>RequestServices</kbd> property, which refers to the service container. We will explore dependency injection in more detail in the next chapter. Declaring a piece of <em>inline</em> middleware using the <kbd>app.Run</kbd> method is not the only way to define new middleware. Furthermore, in the following sub-section, we will see how to build middleware logic using a <em>class-based</em> approach.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Class-based middleware</h1>
                
            
            
                
<p>Middleware can also be implemented by using a <em>class-based</em> approach<em>.</em> This kind of approach increases the r<em>eusability</em>, <em>testability</em>, and <em>maintainability</em> of middleware. A <em>class-based</em> approach involves the definition of a new type, for example. Let's have a look at class-based middleware:</p>
<pre>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Http;<br/><br/>namespace Demo.WebAPI<br/>{<br/>    public class SampleMiddleware<br/>    {<br/>        private readonly RequestDelegate _next;<br/><br/>        public RequestCultureMiddleware(RequestDelegate next)<br/>        {<br/>            _next = next;<br/>        }<br/><br/>        public async Task InvokeAsync(HttpContext context)<br/>        {<br/>            //DO STUFF<br/>            <br/>            // Call the next delegate/middleware in the pipeline<br/>            await _next(context);<br/>        }<br/>    }<br/>}<br/></pre>
<p>Let's examine some key points in this class:</p>
<ul>
<li><kbd>RequestDelegate</kbd> represents the reference to the next element in the pipeline. This could be a delegate or other class-based middleware.</li>
<li><kbd>InvokeAsync</kbd> is the core part of our middleware<em>. </em>This contains the implementation of the middleware and calls the <kbd>_next</kbd> element in our pipeline. At this point, our implementation must choose between continuing the pipeline or only returning a result to the client. For example, in the case of a <em>not authorized</em> message, the middleware will interrupt the pipeline.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After defining our middleware class, we need to add it to our pipeline. An excellent way to do this is to establish a new extension method as follows:</p>
<pre>public static class SampleMiddlewareExtensions<br/>{<br/>    public static IApplicationBuilder UseSampleMiddleware(<br/>        this IApplicationBuilder builder)<br/>    {<br/>        return builder.UseMiddleware&lt;SampleMiddleware&gt;();<br/>    }<br/>}</pre>
<p>After this, we can add our middleware to the pipeline in our <kbd>Startup</kbd> class by executing the extension method previously defined:</p>
<pre><br/>    public class Startup<br/>    {<br/>        <br/>        //  ...<br/>        <br/>        public void Configure(IApplicationBuilder app, <br/>        IHostingEnvironment env)<br/>        {<br/>            <strong>app.UseSampleMiddleware();</strong><br/>            <br/>            app.Run(async context =&gt;<br/>            {<br/>                await context.Response.WriteAsync("Hello, World!");<br/>            });<br/>        } <br/>     }</pre>
<p>The preceding implementation provides a way to encapsulate the logic of the middleware in the <kbd>SampleMiddleware</kbd> class. This approach is preferred for various reasons. First of all, the middleware class and the logic can be verified and tested using unit tests. Secondly, in an enterprise environment, it can be useful to create dedicated library projects containing common middleware used by the web services and to distribute them through the company's NuGet repository. Finally, the class-based approach provides a clear way to highlight middleware dependencies using constructor injection. We will look at this topic in more depth in <a href="54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml">Chapter 4</a>, <em>Dependency Injection</em>. Now that we have seen how to declare and add middleware to the ASP.NET Core pipeline, it is necessary to cover the conditional initialization of middleware in slightly more depth.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Conditional pipeline</h1>
                
            
            
                
<p>ASP.NET Core provides some useful operators that let us put conditional initialization logic inside the middleware pipeline. Those kinds of operators may assist in providing additional performance benefits to our services and applications. Let's have a look at some of these operators.</p>
<p>The <kbd>IApplicationBuilder Map (this IApplicationBuilder app, PathString pathMatch, Action&lt;IApplicationBuilder&gt; configuration)</kbd> extension method helps us to initialize our middleware by mapping a URI path; for example:</p>
<pre>public static class SampleMiddlewareExtensions<br/>{<br/>    public static IApplicationBuilder UseSampleMiddleware(<br/>        this IApplicationBuilder builder)<br/>    {<br/>       return builder.Map("/test/path", _ =&gt; <br/>       _.UseMiddleware&lt;SampleMiddleware&gt;());<br/>    }<br/>}</pre>
<p>In this case, <kbd>SampleMiddleware</kbd> will only be added to our pipeline if it is called as a URI with the specified path. Notice that the <kbd>Map</kbd> operator can also be nested inside others: this approach provides a more advanced approach to conditional initialization.</p>
<p>Another useful operator is <kbd>MapWhen</kbd>, which only initializes the middleware provided as a parameter if the <em>predicate </em>function returns <kbd>true</kbd>; for example:</p>
<pre>public static class SampleMiddlewareExtensions<br/>{<br/>    public static IApplicationBuilder UseSampleMiddleware(<br/>        this IApplicationBuilder builder)<br/>    {<br/>      return  builder.MapWhen(context =&gt; context.Request.IsHttps, <br/>      _ =&gt; _.UseMiddleware&lt;SampleMiddleware&gt;());<br/>    }<br/>}</pre>
<p>In this case, if the request is HTTPS, we will initialize the <kbd>SampleMiddleware</kbd> class. Conditional middleware initialization can be really useful when we need to act on a specific type of request. It usually becomes necessary when we need to force the execution of some logic on HTTP request types, such as when a specific header is present in the request, or a specific protocol is used.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In conclusion, <em>class-based</em> middleware is really useful when we need to implement custom logic in the middleware pipeline, and conditional initialization provides a cleaner way to initialize our set of middleware. In ASP.NET Core, middleware is a first-class citizen of the base logic of the framework; therefore, the next section covers some use cases and some middleware that comes out of the box with ASP.NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding built-in middleware</h1>
                
            
            
                
<p>So, what are the use cases for middleware? As discussed earlier, they are usually related to cross-cutting concerns such as <em>logging</em>, <em>authentication,</em> and <em>exception handling</em>. ASP.NET Core itself provides some <em>built-in middleware</em> that represents a standard way to solve problems<em>:</em></p>
<ul>
<li><kbd>UseStaticFiles()</kbd>: Provides a way to deal with static files and assets inside your application. When the client asks for a static resource, this middleware filters the request and returns the requested file without hitting the rest of the pipeline.</li>
<li><kbd>AddResponseCaching()</kbd>: Helps developers to configure the caching system of the application. This middleware also adds all HTTP-compliant information related to the cache.</li>
<li><kbd>UseHttpsRedirection()</kbd>: This new, built-in piece of ASP.NET Core 2.1  middleware provides a way to force HTTPS redirection.</li>
<li><kbd>UseDeveloperExceptionPage()</kbd>: This shows a detailed error page (the new YSOD) in the case of exceptions<em>.</em> This is usually conditionally initialized, depending on the environment.</li>
</ul>
<p>These are some built-in pieces of middleware provided by ASP.NET Core. As you can see, all middleware provides cross-cutting functionalities for your application. What's important here is that the order of middleware initialization reflects the order of our pipeline; for example:</p>
<pre>     public void Configure(IApplicationBuilder app, IHostingEnvironment env)<br/>        {<br/>            // ...<br/>            app.UseHttpsRedirection();<br/>            app.UseStaticFiles();<br/>        }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In this case, the <kbd>UseStaticFiles</kbd> middleware will never receive requests for static files because the MVC middleware handles them first. A general rule is to place <kbd>UseHttpsRedirection()</kbd> as the last middleware in the pipeline; otherwise, other middleware will not intercept requests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Middleware is a useful tool for developers dealing with cross-cutting concerns. This is because it intercepts and enhances every <em>incoming request</em> and <em>outgoing response, and it can increase performance with early-return requests.</em> Concepts from logging to authentication should be handled by using middleware. The topics covered in the chapter provided you with the necessary knowledge to understand the middleware-first approach taken by the ASP.NET Core framework. Furthermore, the chapter also gave an overview of the built-in middleware of ASP.NET Core, and it described how to create custom middleware.</p>
<p>In the next chapter, we will explore another core topic for increasing the maintainability and testability of our code: <em>dependency injection</em>. ASP.NET Core provides out-of-the-box dependency injection, and we will also explore how to solve dependencies and how to deal with different life cycle types.</p>


            

            
        
    </body></html>