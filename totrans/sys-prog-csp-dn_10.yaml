- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: The One with the Systems Check-Ups
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有系统检查的方案
- en: '*Logging, Monitoring,* *and Metrics*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*日志记录、监控、和指标*'
- en: Now and then, software fails. Whether we like it or not, that is simply a fact
    of life. We make mistakes during development. Other people make mistakes. The
    environment changes. A network becomes unstable. These are all reasons the system
    might not behave as we intended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件时不时地会失败。无论我们是否喜欢，这只是一个生活的事实。我们在开发过程中犯错误。其他人也会犯错误。环境发生变化。网络变得不稳定。这些都是系统可能不会按我们预期行为的原因。
- en: 'Testing can help. A good and solid set of tests can show you the errors in
    your work and help make your system more robust. However, sometimes things still
    go wrong. Let’s face it: building software is a creative art form and thus subject
    to influences beyond our control. So, when things go wrong and our systems do
    not do what we thought they would be doing, we need a way to look into their workings.
    That can help us figure out what happened and what we can do to fix things.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以帮助。一套良好且稳固的测试可以显示出你工作中的错误，并有助于使你的系统更加健壮。然而，有时事情仍然会出错。让我们面对现实：构建软件是一种创造性的艺术形式，因此会受到我们无法控制的影响。所以，当事情出错，我们的系统没有按照我们预期的那样运行时，我们需要一种方法来探究它们的运作。这可以帮助我们弄清楚发生了什么，以及我们可以做些什么来解决问题。
- en: This is where logging and monitoring comes into play. Logging helps us write
    important information and store it in a well-known place. Logging is part of our
    code base. Monitoring is watching the system from the outside to track what is
    happening. In this chapter, I will show you exactly how to do everything from
    a systems developer’s perspective.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是日志和监控发挥作用的地方。日志帮助我们记录重要信息并将其存储在已知的位置。日志是我们代码库的一部分。监控是从外部观察系统以跟踪正在发生的事情。在本章中，我将从系统开发者的角度向你展示如何做所有这些事情。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: What logging frameworks are there?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些日志框架？
- en: How do I set up the correct levels of logging?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何设置正确的日志级别？
- en: What is structured logging?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化日志是什么？
- en: How can I monitor my logs outside my system?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何在我的系统外监控日志？
- en: What is monitoring?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控是什么？
- en: How do I set up monitoring?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何设置监控？
- en: What should I monitor or log?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该监控或记录什么？
- en: I hope you are as excited about this as I am!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你对这像我对它一样兴奋！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we look into monitoring and logging tools. One of the tools
    I often use is **Seq**. I am not affiliated with them; it is just a tool I like
    to use. You can download a free-to-use personal version at [https://datalust.co/download](https://datalust.co/download).
    You can download the installer or run the tool as a Docker image. To use this,
    you have to install Docker on your environment. I suggest you go to [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
    to learn more about Docker. If you want to play around, I suggest you choose the
    Docker version. You can run the image locally by invoking the following command
    from a terminal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨监控和日志工具。我经常使用的一个工具是**Seq**。我与他们没有关联；这只是我喜欢使用的工具。你可以在[https://datalust.co/download](https://datalust.co/download)下载免费的个人版本。你可以下载安装程序或以Docker镜像的形式运行该工具。要使用它，你必须在你的环境中安装Docker。我建议你访问[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)了解更多关于Docker的信息。如果你想尝试，我建议你选择Docker版本。你可以在终端中通过调用以下命令在本地运行镜像：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Docker command downloads the image from `datalust/seq`. It listens to ports
    `80` for the `5341` to intercept logs. All settings are stored in the `C:\data`
    folder, so you must create that folder beforehand (or change the `-v` property
    in the Docker command).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Docker命令从`datalust/seq`下载镜像。它监听`80`端口，用于`5341`拦截日志。所有设置都存储在`C:\data`文件夹中，因此你必须事先创建该文件夹（或者更改Docker命令中的`-v`属性）。
- en: 'I will also show you how to use Prometheus in this chapter. To get that up
    and running, you could do the same thing. Either download the software from their
    website at [https://prometheus.io/](https://prometheus.io/) or run it in a Docker
    container:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我也将在本章中向你展示如何使用Prometheus。为了使其运行起来，你可以做同样的事情。要么从他们的网站[https://prometheus.io/](https://prometheus.io/)下载软件，要么在Docker容器中运行它：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You need to have a `prometheus.yml` file that contains information about what
    you want to monitor. I will show you what that file looks like later in this chapter,
    where I will also explain what each part does.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个包含你想要监控的信息的`prometheus.yml`文件。我将在本章的后面部分向你展示该文件的样子，我还会解释每个部分的作用。
- en: We will be using a lot of NuGet packages as well; they are all mentioned in
    the paragraphs where I discuss each of them and how to use them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用很多NuGet包；它们都在我讨论每个包及其使用方法的段落中提到。
- en: You can download all code samples mentioned in this chapter from our GitHub
    repo at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从我们的GitHub仓库下载本章中提到的所有代码示例：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10)
- en: Available logging frameworks
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用的日志框架
- en: Logging has been around forever. In the early days of computing, operators would
    walk around the machines and note whatever they saw happening to them. If a light
    blinked when it should not have blinked or vice versa, they wrote it down a journal
    somewhere. Later, systems would log everything they could onto paper and punch
    cards. If systems did something unexpected, the operators could go to the paper
    trail and figure out what had caused the event. After that, people used serial
    monitors that logged everything onto a separate device.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 日志一直存在。在计算机的早期阶段，操作员会在机器周围走动，并记录他们看到的所有事情。如果一个灯在不应该闪烁的时候闪烁，或者相反，他们会把它记在某本日记里。后来，系统会将它们能记录的所有内容都记录在纸上和穿孔卡片上。如果系统做了意料之外的事情，操作员可以查看纸上的记录来找出导致事件的原因。之后，人们使用串行监视器，将所有内容记录在单独的设备上。
- en: These days, we hardly use punch cards anymore. However, we still log. There
    are many frameworks out there that help you get the job done. In this chapter,
    I will explain three of those frameworks. They all have pros and cons. I will
    highlight these as much as possible. That way, you can make your own decisions
    about what to use and when to use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，我们几乎不再使用穿孔卡片了。然而，我们仍然在记录。有许多框架可以帮助你完成任务。在本章中，我将解释这三个框架。它们都有优点和缺点。我会尽可能突出这些，这样你可以自己决定使用什么以及何时使用。
- en: Default logger in .NET
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET中的默认日志记录器
- en: 'Microsoft offers a **default logger**. We have seen it before: if you create
    an ASP.Net application or, as we have done, a worker process, you will get a logger
    framework for free. This framework is surprisingly full-featured. This framework
    offers enough features to satisfy the needs of most developers. So, let’s have
    a look at it!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了一个**默认的日志记录器**。我们之前见过：如果你创建一个ASP.Net应用程序，或者像我们这样创建一个工作进程，你将免费获得一个日志框架。这个框架功能非常全面。这个框架提供了足够的功能来满足大多数开发者的需求。所以，让我们看看它吧！
- en: As I said, many of the templates in Visual Studio already include the standard
    `Logger` class. Some templates, however, do not have this. So, let’s have a look
    at how to add it. We’ll begin with a clean, empty Console application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，Visual Studio中的许多模板已经包含了标准的`Logger`类。然而，有些模板并没有这个。所以，让我们看看如何添加它。我们将从一个干净、空白的控制台应用程序开始。
- en: The first thing we need to do is add the correct NuGet package. In this case,
    you need to install `Microsoft.Extensions.Logging` in your project. Once you have
    done that, you will have access to the logging framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加正确的NuGet包。在这种情况下，你需要在你的项目中安装`Microsoft.Extensions.Logging`。一旦完成，你将能够访问日志框架。
- en: 'In your main project, you can set up the logging like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主项目中，你可以这样设置日志：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code works. If you run it, you will not get any errors. However, you will
    also not get any output, so that is pretty useless, to be honest.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是有效的。如果你运行它，你不会得到任何错误。然而，你也不会得到任何输出，所以坦白说，这几乎没什么用。
- en: This is because the framework is quite flexible. It can handle all sorts of
    outputs to various destinations. However, you have to specify what you want.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为框架非常灵活。它可以处理各种输出到各种目的地。然而，你必须指定你想要的内容。
- en: 'Let’s fix this. Install another NuGet package; this time, we need the `Microsoft.Extensions.Logging.Console`
    package. Once you have installed that, we need to change the code in the `LoggerFactory.Create()`
    method to look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复这个问题。安装另一个NuGet包；这次，我们需要`Microsoft.Extensions.Logging.Console`包。一旦安装了它，我们需要将`LoggerFactory.Create()`方法中的代码修改如下：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the second line, we added the Console as a way to output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们添加了控制台作为输出方式。
- en: 'If you run the program this time, you will get the desired information:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这次运行程序，你将得到所需的信息：
- en: '![Figure 10.1: Output from the log](img/B20924_11_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：日志输出](img/B20924_11_01.jpg)'
- en: 'Figure 10.1: Output from the log'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：日志输出
- en: OK. We got something on our screen. Let’s see what we have done so far since
    I deliberately skipped over some steps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们在屏幕上看到了一些内容。让我们看看我故意跳过的一些步骤以来我们做了什么。
- en: '`LoggerFactory` is a factory class that can create instances of a class that
    implements `Ilogger<T>`. We set up `LoggerFactory` by hooking up the desired outputs
    (in our case, Console; we’ll add others later). We also gave it the minimum log
    level we wanted.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggerFactory` 是一个工厂类，可以创建实现 `Ilogger<T>` 的类的实例。我们通过连接所需的输出（在我们的情况下，是控制台；我们稍后会添加其他输出）来设置
    `LoggerFactory`。我们还给它设置了我们想要的最低日志级别。'
- en: Let’s dive into this. I want to discuss log levels and configuration, as well
    as the different tools we have.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨。我想讨论日志级别和配置，以及我们拥有的不同工具。
- en: Log levels
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志级别
- en: Not all messages are equally important. If you are starting out on your project,
    you will probably want to log a lot. You can output anything you want and you
    will probably do so. You can write the contents of variables, loop controls, where
    you are in the flow, and so on. Anything that can help you understand the flow
    of your program as you run it is a candidate for logging.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有消息都同等重要。如果你刚开始你的项目，你可能希望记录很多。你可以输出任何你想要的内容，你很可能也会这样做。你可以记录变量的内容、循环控制、你在流程中的位置等等。任何有助于你在运行程序时理解程序流程的内容都适合记录。
- en: However, once you have written and tested your software, you will probably not
    want all of that information anymore. You might want to log exceptional cases
    and errors, but that is about it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你编写并测试了你的软件，你可能不再需要所有这些信息。你可能只想记录异常情况和错误，仅此而已。
- en: 'To achieve that, you must remove all the logging code that you do not need
    anymore. Alternatively, you could wrap up the code in `#IF / #ENDIF` statements
    and thus effectively remove the calls when you recompile using a different `#DEFINE`.
    However, that means changing your code. That could lead to side effects. If you
    later find a bug and decide that you need that code in again, you will need to
    rewrite or recompile the system.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '要实现这一点，你必须删除你不再需要的所有日志代码。或者，你可以用 `#IF / #ENDIF` 语句包裹代码，从而在重新编译时使用不同的 `#DEFINE`
    有效地删除调用。然而，这意味着改变你的代码。这可能会导致副作用。如果你后来发现了一个错误并决定你需要再次使用那段代码，你将需要重写或重新编译系统。'
- en: '`Loglevels` eliminates that problem.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loglevels` 消除了这个问题。'
- en: 'Each log message we write has a level. In the preceding example, we used `Log.LogInformation()`.
    That means that we want to write something informational. There are other levels
    we can use as well. What you use them for is entirely up to you. However, in general,
    there is meaning to each level. These are the levels we can use with `ILogger`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的每条日志消息都有一个级别。在先前的例子中，我们使用了 `Log.LogInformation()`。这意味着我们想要记录一些信息。我们还可以使用其他级别。你使用它们的目的完全取决于你。然而，一般来说，每个级别都有其意义。以下是我们可以与
    `ILogger` 一起使用的级别：
- en: '| **Log level** | **Description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **日志级别** | **描述** |'
- en: '| Trace | This refers to the most detailed messages. These messages may contain
    sensitive application data and are therefore not recommended to be enabled in
    a production environment unless they are necessary for troubleshooting and only
    for short periods. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪 | 这指的是最详细的消息。这些消息可能包含敏感的应用程序数据，因此不建议在生产环境中启用，除非它们对于故障排除是必要的，并且仅限于短时间内。
    |'
- en: '| Debug | This displays messages that are useful for debugging. It is less
    verbose than Trace, but more than Information. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 这显示对调试有用的消息。它比 Trace 更简洁，但比信息更多。 |'
- en: '| Information | This allows the system to show informational messages that
    highlight the general flow of the application. It is useful for general application
    insights. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 这允许系统显示突出显示应用程序一般流程的信息性消息。这对于一般的应用程序洞察力很有用。 |'
- en: '| Warning | This is all about messages that highlight an abnormal or unexpected
    event in the application flow, but which do not otherwise cause the application
    execution to stop. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | 这涉及的是在应用程序流程中突出显示异常或意外事件的消息，但不会导致应用程序执行停止。 |'
- en: '| Error | These are messages that highlight when the current flow of execution
    is stopped due to a failure. These should indicate a failure in the current activity,
    not an application-wide failure. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 这些消息突出显示当前执行流程由于失败而停止的情况。这些应该表明当前活动中的失败，而不是应用程序范围内的失败。 |'
- en: '| Critical | This is about messages describing an unrecoverable application,
    system crash, or catastrophic failure requiring immediate attention. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Critical | 这涉及描述不可恢复的应用程序、系统崩溃或需要立即注意的灾难性故障的消息。|'
- en: '| None | This results in no messages being logged. This level is used to turn
    off logging. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| None | 这会导致没有任何消息被记录。此级别用于关闭日志。|'
- en: Table 10.1 Log levels in Microsoft Logger
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 Microsoft Logger 中的日志级别
- en: 'There are two ways in which you can specify what level your message has to
    be. You can use one of the dedicated log methods (such as `LogInformation`, `LogTrace`,
    `LogDebug`, and so on) or the generic `Log()` method. That looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式指定消息的级别。你可以使用专用日志方法（例如 `LogInformation`、`LogTrace`、`LogDebug` 等）或通用的
    `Log()` 方法。它看起来是这样的：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You just call `Log()` and then give it the `LogLevel`. Whatever method you choose,
    you can decide what level the log is supposed to be on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需调用 `Log()` 并给它传递 `LogLevel`。无论你选择哪种方法，你都可以决定日志应该处于哪个级别。
- en: However, that only solves a part of the issue. We want to be flexible in what
    we output to the screen. That’s where the `SetMinimumLevel()` method on the `ILoggingBuilder`
    comes into play.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只能解决部分问题。我们希望输出到屏幕的内容更加灵活。这就是 `ILoggingBuilder` 上的 `SetMinimumLevel()` 方法发挥作用的地方。
- en: The method determines what the log is writing to the chosen output channels.
    If you set it to `Information`, all calls to the log are processed if they are
    of the Information level or higher. In other words, all calls to `Log.LogTrace()`,
    `Log.Debug()`, `Log.Log(LogLevel.Trace)`, and `Log.Log(LogLevel.Debug)` are ignored.
    So you can, in one line, determine what you do and do not want to appear on the
    logs. You specify the level and all information on that level or above is outputted.
    The rest is ignored.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法确定日志写入所选输出通道的内容。如果你将其设置为 `Information`，则所有信息级别或更高级别的日志调用都会被处理。换句话说，所有调用 `Log.LogTrace()`、`Log.Debug()`、`Log.Log(LogLevel.Trace)`
    和 `Log.Log(LogLevel.Debug)` 的都会被忽略。因此，你可以在一行中确定你想要和不要出现在日志中的内容。你指定了级别，并且该级别及以上的所有信息都会输出。其余的将被忽略。
- en: During development, you might want to set the level to Trace. After extensive
    testing, you might want to set it to `Critical` or maybe `Error` during production.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可能希望将级别设置为 Trace。经过广泛的测试后，在生产过程中你可能希望将其设置为 `Critical` 或 `Error`。
- en: Using a Settings file
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用设置文件
- en: Of course, we are not there yet. If you want to change the log level, you still
    need to change the code and recompile the system. Let’s change that so we can
    use something else.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有完成。如果你想更改日志级别，你仍然需要更改代码并重新编译系统。让我们改变一下，这样我们就可以使用其他东西了。
- en: Add a new file to your program called `appsettings.json`. Make sure you change
    the `Copy to output directory` property to `Copy if newer`; you need this file
    next to the binaries.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个名为 `appsettings.json` 的新文件添加到你的程序中。确保将 `Copy to output directory` 属性更改为 `Copy
    if newer`；你需要将此文件放在二进制文件旁边。
- en: 'The file should look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文件应该看起来像这样：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we need to add a couple of NuGet packages. Install `Microsoft.Extensions.Configuration.JSon`
    and `Microsoft.Extensions.Logging.Configuration`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加几个 NuGet 包。安装 `Microsoft.Extensions.Configuration.JSon` 和 `Microsoft.Extensions.Logging.Configuration`。
- en: 'When we have done that, we will add the following code that actually reads
    the configuration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这些后，我们将添加以下代码来实际读取配置：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code creates a `ConfigurationBuilder` and then adds the JSON file we just
    added. We set the `optional` parameter to `true`; if people decide to remove the
    file, our app will still work. We also specify that the `reloadOnChange` parameter
    is `true`. As you have probably guessed, the configuration is reloaded when the
    file changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个 `ConfigurationBuilder`，然后添加了我们刚刚添加的 JSON 文件。我们将 `optional` 参数设置为 `true`；如果人们决定删除文件，我们的应用程序仍然可以工作。我们还指定了
    `reloadOnChange` 参数为 `true`。正如你可能已经猜到的，当文件更改时，配置将被重新加载。
- en: 'The following is relatively straightforward: we call `Build()` to get the `IConfiguration`,
    then call `GetSection` (Logging) to load that specific part of our JSON file.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下相对简单：我们调用 `Build()` 来获取 `IConfiguration`，然后调用 `GetSection`（Logging）来加载我们 JSON
    文件中的特定部分。
- en: 'We need to do some work on our `LoggerFactory` as well. Change it to look like
    this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的 `LoggerFactory` 上做一些工作。将其修改为如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of hardcoding the log level, we will now give it the configuration section
    from the JSON file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用硬编码的日志级别，而是现在将配置部分从 JSON 文件中提供给它。
- en: 'Lastly, let’s change the code that does the actual logging a bit. I will wrap
    it in a continuous loop:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们稍微修改一下实际执行日志记录的代码。我将将其包裹在一个连续循环中：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run your program and see all the different ways of displaying your message.
    Open another terminal window, navigate to the compiled application folder, and
    change the log setting in the `appsettings.json` file. As soon as you save the
    file, you will see a different behavior in the application. Depending on your
    desire, it will display more or fewer lines of logging.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序，看看所有不同的显示消息的方式。打开另一个终端窗口，导航到编译的应用程序文件夹，并在`appsettings.json`文件中更改日志设置。一旦保存文件，你将看到应用程序中的不同行为。根据你的需求，它将显示更多或更少的日志行。
- en: Now, you can add all the logging you want to your application, use `Trace` during
    debugging and development, and then move to `Critical` or `Error` if your system
    is ready for production. You can quickly return to a more detailed debugging level
    as soon as something happens. All of that is done without recompiling!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将所有你想要的日志添加到你的应用程序中，在调试和开发期间使用`Trace`，然后在系统准备生产时切换到`Critical`或`Error`。一旦发生某些事情，你可以迅速返回到更详细的调试级别。所有这些都不需要重新编译！
- en: Using EventId
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用EventId
- en: Having different debugging levels is nice, but that is not enough to structure
    the information if you have a lot of messages. To help you create a bit of order
    in the logging chaos, you can use the `EventId`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的调试级别很好，但如果你有大量消息，这不足以对信息进行结构化。为了帮助你创建一些日志混乱中的秩序，你可以使用`EventId`。
- en: 'All log methods have an overload that allows you to add an `EventId`. An `EventId`
    is a class that contains an ID in the `integer` form and a name in the `string`
    form. What those are is entirely left up to you. The name is not even used in
    the logs, but it is there for your convenience during development. We can create
    an `EventId`, or multiple, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有日志方法都有一个重载，允许你添加一个`EventId`。`EventId`是一个包含整数形式的ID和字符串形式的名称的类。这些是什么完全取决于你。名称甚至不在日志中使用，但它是在开发期间为你提供的便利。我们可以创建一个`EventId`，或者多个，如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I just made up a bunch of categories: `Initialization`, `Shutdown`, and `File
    Reading`. This is just an example; I am sure that you can come up with much better
    names.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是随意创建了一些类别：`Initialization`（初始化）、`Shutdown`（关闭）和`File Reading`（文件读取）。这只是一个例子；我相信你可以想出更好的名字。
- en: 'When you log something, you can use an `EventId` to indicate that the message
    you log has to do with a certain part of the system. That looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你记录某些信息时，可以使用一个`EventId`来指示你记录的消息与系统的某个部分有关。这看起来是这样的：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output now looks a bit different:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在看起来有些不同：
- en: '![FIgure 10.2: Output of logging with an EventId (or multiple)](img/B20924_11_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：使用EventId（或多个）的日志输出](img/B20924_11_02.jpg)'
- en: 'FIgure 10.2: Output of logging with an EventId (or multiple)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：使用EventId（或多个）的日志输出
- en: Next to the `Log` type and the `Program`, you can see the number between brackets.
    That is the number of the `EventId` type. In our case, `1` was initialization,
    `2` was shut down, and `3` was file reading. Again, these strings are never used
    and, unfortunately, are not shown on the screen. However, having these numbers
    in there can help you find the areas that you are interested in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Log`类型和`Program`旁边，你可以看到括号中的数字。这是`EventId`类型的编号。在我们的例子中，`1`代表初始化，`2`代表关闭，`3`代表文件读取。再次强调，这些字符串永远不会被使用，并且不幸的是，它们也不会显示在屏幕上。然而，这些数字的存在可以帮助你找到你感兴趣的区域。
- en: Using Type information
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型信息
- en: 'There is one last thing you can use to organize your logs. I didn’t explain
    it earlier, but you must have noticed that when we created the instance of our
    `logger`, we gave it a `Program` type parameter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用它来组织你的日志。我之前没有解释这一点，但你一定注意到了，当我们创建`logger`的实例时，我们给了它一个`Program`类型的参数：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we called `CreateLogger` with the `Program` type, we see the `Program`
    string on the screen in the logs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`Program`类型调用了`CreateLogger`，所以我们看到日志中的`Program`字符串。
- en: 'You can create several instances of the `ILogger` interface, each with its
    own type attached to it. That way, you can create different loggers for each application
    part. If you have a part of your system that handles printing and the main class
    is called `Printer`, you can create a logger of the `Printer` type like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`ILogger`接口创建几个实例，每个实例都附加了自己的类型。这样，你可以为每个应用程序部分创建不同的记录器。如果你有一个处理打印的系统部分，而主类被命名为`Printer`，你可以创建一个`Printer`类型的记录器，如下所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All logs written to the `printLogger` instance will now show `Printer` in their
    log lines instead of `Program`. Of course, it doesn’t really matter what you pass
    in that parameter. You can use the `Printer` logger in your main program if you
    want to. It is just decoration that helps you organize the output of the logs.
    That’s it. There is no logic behind it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有写入`printLogger`实例的日志现在将在它们的日志行中显示“Printer”，而不是“Program”。当然，你传递给那个参数的内容实际上并不重要。如果你想的话，可以在主程序中使用`Printer`日志记录器。这只是装饰，有助于你组织日志输出。就是这样。背后没有逻辑。
- en: Using categories wisely
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 智能使用类别
- en: I suggest you use these categories, but use them sparingly; too many will only
    clutter your logs. I usually create empty classes just for use in the logger creation.
    That way, I can get a nice set of logger instances without relying on internal
    code that nobody outside should see. However, I will leave that entirely up to
    you.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用这些类别，但不要过度使用；太多的类别只会让你的日志变得杂乱。我通常只为日志创建器创建空类。这样，我就可以得到一组漂亮的日志实例，而不必依赖于外部人士不应该看到的内部代码。然而，我将完全由你来决定。
- en: Now that we have basic logging out of the way, it is time to look at some popular
    alternatives that offer some other nifty tricks we can use. Let us begin with
    NLog!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了基本的日志记录，是时候看看一些流行的替代方案了，它们提供了一些我们能够使用的巧妙技巧。让我们从NLog开始！
- en: NLog
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NLog
- en: Microsoft is not the only company that offers a logging framework. There are
    others out there, each with their own strengths and weaknesses. One of the more
    popular ones out there is **NLog**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 微软并不是唯一提供日志框架的公司。还有其他公司，每个都有自己的优势和劣势。其中之一是更受欢迎的**NLog**。
- en: NLog was created by Jared Kowalski in 2006 as an alternative to the popular
    log4net solution, which is a port of the immensely popular log4j Java logging
    solution. Kowalski aimed to build a logging solution that was high in performance
    but also flexible in the configuration of the settings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NLog是由Jared Kowalski于2006年创建的，作为流行的log4net解决方案的替代品，而log4net是广泛流行的log4j Java日志解决方案的移植版本。Kowalski的目标是构建一个性能高且设置灵活的日志记录解决方案。
- en: Setting up NLog
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置NLog
- en: To use NLog, you need to install the corresponding NuGet package. The name of
    the package is simply `NLog`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用NLog，你需要安装相应的NuGet包。包的名称很简单，就是`NLog`。
- en: 'Once you have installed that package, we must create a configuration file.
    To do that, add a new XML file to your project (do not forget to set the properties
    to `Copy if newer` so that the project can find the file when it runs). By convention,
    this file is called `NLog.config`, but you can choose any name. The file should
    look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了那个包之后，我们必须创建一个配置文件。为此，在你的项目中添加一个新的XML文件（不要忘记将属性设置为`Copy if newer`，这样项目在运行时可以找到该文件）。按照惯例，这个文件叫做`NLog.config`，但你可以选择任何名称。文件应该看起来像这样：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can control almost all of NLog through this configuration file. You can
    set up all parameters in code, but that kind of defeats the purpose of NLog. I
    suggest that you use the `configuration` file and avoid setting things in the
    code. That is unless you have a really good reason to do otherwise, of course.
    After all, it is still your code, not mine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这个配置文件控制几乎所有的NLog。你可以在代码中设置所有参数，但这似乎违背了NLog的目的。我建议你使用`configuration`文件，并避免在代码中设置东西。当然，除非你真的有很好的理由这样做，毕竟，这还是你的代码，不是我的。
- en: 'Now, it is time to start logging. In your program, add the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始日志记录了。在你的程序中添加以下代码：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we will load the configuration in the `LogManager`. You usually have
    one setup for all your logging needs in your entire application, so you might
    as well do this first.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`LogManager`中加载配置。你通常在整个应用程序中为所有日志需求设置一个配置，所以你不妨先做这件事。
- en: Then, we will call `GetCurrentClassLogger()`. This call is the equivalent of
    the call to `CreateLogger<T>` in the Microsoft framework. It ties the current
    class name to the logger so you can categorize your logs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将调用`GetCurrentClassLogger()`。这个调用等同于在Microsoft框架中调用`CreateLogger<T>`。它将当前类名绑定到日志记录器，以便你可以对日志进行分类。
- en: 'If you want other loggers to be associated with different classes, you can
    do so by calling something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将其他日志记录器与不同的类关联，你可以通过调用类似以下内容的方式来实现：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This call creates another logger with the same configuration but will show `"OtherLogger"`
    in the output this time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将创建另一个具有相同配置的日志记录器，但这次输出将显示“OtherLogger”。
- en: The rest of the code is self-explanatory, except for the line that says `LogManager.Shutdown()`.
    This line is needed to flush out all logs in the code and ensure that no message
    is left behind.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分都是不言自明的，除了说“LogManager.Shutdown()”的那一行。这一行是必要的，用于清除代码中的所有日志并确保没有消息被留下。
- en: Log levels in NLog logging
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NLog日志记录的日志级别
- en: 'As with the Microsoft framework, you can specify which level you want to see
    in the log files. The levels for NLog are comparable, but there are minor differences.
    The following table shows the available options:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与Microsoft框架一样，您可以在日志文件中指定您想要看到哪个级别。NLog的级别是可比的，但有一些细微的差异。以下表格显示了可用的选项：
- en: '| **NLog level** | **Description** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **NLog级别** | **描述** |'
- en: '| Trace | This provides the most detailed information. Use this for the most
    low-level debug information. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪 | 这提供了最详细的信息。用于最底层的调试信息。|'
- en: '| Debug | This provides coarse-grained debugging information. It is less detailed
    than Trace. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 这提供了粗粒度的调试信息。它比跟踪更不详细。|'
- en: '| Info | Informational messages that highlight the general flow of the application
    come with this level. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 此级别包含强调应用程序一般流程的信息性消息。|'
- en: '| Warn | Potentially harmful situations of interest to end users or system
    managers that indicate potential problems are flagged at this level. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | 在此级别标记对最终用户或系统管理员感兴趣的有潜在危害的情况，这些情况表明可能存在问题。|'
- en: '| Error | Error events of considerable importance that will prevent normal
    program execution but might still allow the application to continue running are
    flagged here. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 这里标记了相当重要的错误事件，这些事件将阻止正常程序执行，但可能仍然允许应用程序继续运行。|'
- en: '| Fatal | This level focuses on very severe error events that will presumably
    lead the application to abort. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 致命 | 这个级别关注的是非常严重的错误事件，这些事件可能会使应用程序崩溃。|'
- en: '| Off | This involves no logging at all. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 关闭 | 这完全不涉及日志记录。|'
- en: 'Table 10.2: Log levels in NLog'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2：NLog中的日志级别
- en: As you can see, the levels are almost the same; they are just named differently.
    That makes it harder to remember when you switch from one framework to another,
    but we can do nothing about that. We have to memorize the terms, I guess.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，级别几乎相同；只是名称不同。这使得在从一种框架切换到另一种框架时更难以记住，但我们对此无能为力。我猜我们不得不记住这些术语。
- en: NLog targets
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NLog目标
- en: You control NLog through the configuration file. That is one of the two main
    principles that drove the development of NLog (the other being that NLog should
    be highly performant).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过配置文件来控制NLog。这是推动NLog开发的主要原则之一（另一个原则是NLog应该具有高性能）。
- en: In the sample we have worked on, we wrote the logs in both the Console and a
    file. In the `settings` file, we have defined different targets where NLog writes
    the logs. Currently, more than 100 different targets are available, some of which
    are part of the core package and some of which require a NuGet package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们工作的示例中，我们在控制台和文件中记录了日志。在`settings`文件中，我们定义了不同的目标，NLog在这些目标中写入日志。目前，有超过100个不同的目标可用，其中一些是核心包的一部分，而另一些则需要NuGet包。
- en: Let’s have a look at another target. We currently use `Console`, but we can
    replace that with `ColoredConsole`. That is part of the default package, so we
    do not have to add a NuGet package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个目标。我们目前使用的是`Console`，但我们可以将其替换为`ColoredConsole`。这是默认包的一部分，所以我们不需要添加NuGet包。
- en: 'In the configuration, add a new target to the `targets` section. It looks like
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，向`targets`部分添加一个新的目标。它看起来像这样：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This segment tells NLog that we want to use a new target of the `ColoredConsole`
    type. We can call it `logcolorconsole`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分告诉NLog我们想要使用一个新的`ColoredConsole`类型的目标。我们可以称它为`logcolorconsole`。
- en: 'We also specified a header that should display the `Logfile for run` text and
    then the current data. I also added a footer that consists of a simple line. The
    layout section is the same as the one we used with the file: we display the time
    (in the `HH:mm:ss` format), the name of the logger (which is `Program` or `OtherLogger`,
    depending on the line we are on), the level of the log in uppercase, and finally
    the message itself.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了一个应显示“运行日志文件”文本和当前数据的标题。我还添加了一个由简单行组成的页脚。布局部分与我们在文件中使用的相同：我们显示时间（以“HH:mm:ss”格式），记录器的名称（根据我们所在的行，可能是“程序”或“其他记录器”），日志级别的大写形式，最后是消息本身。
- en: You can vary this as much as you want and add or remove elements at will. You
    can also set up rules on what to display depending on various factors, such as
    the level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要调整这些内容，随意添加或删除元素。你还可以根据各种因素（如级别）设置显示规则。
- en: 'We must also add it to the rules. Just for simplicity, I removed the file and
    console as a target and used the new `logcolorconsole` one:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将其添加到规则中。为了简单起见，我移除了文件和控制台作为目标，并使用了新的 `logcolorconsole`：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you run the sample after making these changes, you will see a set of colorful
    lines. Yes, you can change or alter the colors based on the level. The options
    are almost endless.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在对这些更改后运行示例，你会看到一组彩色线条。是的，你可以根据级别更改或修改颜色。选项几乎是无限的。
- en: 'As I said, there are over 100 targets available. Let me give you a shortened
    list of some of the more commonly used targets:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，有超过 100 个目标可用。让我给你一个常用目标的简短列表：
- en: '| **Target name** | **Description** | **NuGet package** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **目标名称** | **描述** | **NuGet 包** |'
- en: '| File Target | Logs data to files on a disk with options for filenames, directories,
    rotations, and archiving | NLog |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 文件目标 | 将数据记录到磁盘上的文件中，具有文件名、目录、轮换和存档选项 | NLog |'
- en: '| Console Target | Sends log messages to the standard output or error streams;
    useful during development | NLog |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 控制台目标 | 将日志消息发送到标准输出或错误流；在开发期间很有用 | NLog |'
- en: '| ColoredConsole Target | Sends log messages to the Console with color coding
    based on log level | NLog |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 彩色控制台目标 | 根据日志级别对控制台进行着色，将日志消息发送到控制台 | NLog |'
- en: '| Database Target | Logs messages to a database using parameterized SQL commands
    | NLog |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 数据库目标 | 使用参数化 SQL 命令将消息记录到数据库中 | NLog |'
- en: '| EventLog Target | Writes log entries to the Windows Event Log; ideal for
    Windows apps | NLog.WindowsEventLog |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 事件日志目标 | 将日志条目写入 Windows 事件日志；非常适合 Windows 应用程序 | NLog.WindowsEventLog |'
- en: '| Mail Target | Sends log entries as email messages; suitable for alerts and
    monitoring | NLog.MailKit |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 邮件目标 | 将日志条目作为电子邮件消息发送；适合警报和监控 | NLog.MailKit |'
- en: '| Network Targets | Includes WebService, TCP, and UDP targets for logging over
    networks | NLog |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 网络目标 | 包括用于通过网络进行日志记录的 WebService、TCP 和 UDP 目标 | NLog |'
- en: '| Trace Target | Sends log messages to .NET trace listeners, integrating with
    other diagnostics tools | NLog |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪目标 | 将日志消息发送到 .NET 跟踪监听器，与其他诊断工具集成 | NLog |'
- en: '| Memory Target | Logs messages to an in-memory list of strings, mainly for
    debugging purposes | NLog |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 内存目标 | 将消息记录到内存中的字符串列表中，主要用于调试目的 | NLog |'
- en: '| Null Target | A target that does nothing; useful for disabling logging in
    certain scenarios | NLog |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 空目标 | 一个什么也不做的目标；在特定场景中禁用日志记录很有用 | NLog |'
- en: 'Table 10.3: Targets in NLog'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3：NLog 中的目标
- en: I recommend you look at the documentation at [https://nlog-project.org/config/](https://nlog-project.org/config/)
    to see the different options and the settings per option. It is pretty extensive!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你查看 [https://nlog-project.org/config/](https://nlog-project.org/config/)
    上的文档，以了解不同的选项以及每个选项的设置。内容相当丰富！
- en: Rules in NLog
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NLog 中的规则
- en: In addition to the targets, you can set rules in NLog. The rules define which
    target is used under which circumstances.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了目标之外，你还可以在 NLog 中设置规则。规则定义了在什么情况下使用哪个目标。
- en: 'In our example, we used one rule: all logs should go to the Console and `file`
    targets or the `ColoredConsole` target, which we named `logcolorconsole`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了一个规则：所有日志都应该发送到控制台和 `file` 目标或我们命名为 `logcolorconsole` 的 `ColoredConsole`
    目标。
- en: 'Let’s change that a bit; I want to make it more intelligent. Change the rules
    section so that it looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下；我想让它变得更智能。将规则部分修改如下：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now have three rules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个规则：
- en: The first is the catch-all. By writing `name="*"`, we tell the system to take
    all loggers. The minimum level we want is Trace, the lowest level, so we want
    all messages (yes, you can also define a maximum level). We define the target
    as a **logfile**. This target is the one that writes to a file.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是通配符。通过写入 `name="*"`，我们告诉系统接收所有日志记录器。我们想要的最低级别是 Trace，即最低级别，因此我们想要所有消息（是的，你也可以定义一个最大级别）。我们将目标定义为
    **logfile**。这个目标是将日志写入文件的。
- en: The second rule only applies to the logger that has the name `Program`. Thus,
    all loggers are created by calling `GetCurrentClassLogger()` using our `Main`
    method. We raise the minimum level to Warn; we are not interested in anything
    below that. The file catches this. We want to see them in nice colors, so we specify
    the `writeTo` parameter as `logcolorconsole`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条规则仅适用于名为 `Program` 的日志记录器。因此，所有日志记录器都是通过调用 `GetCurrentClassLogger()` 使用我们的
    `Main` 方法创建的。我们将最低级别提高到 Warn；我们对低于这个级别的任何内容都不感兴趣。文件会捕获这些。我们希望看到它们以漂亮的颜色显示，所以我们指定
    `writeTo` 参数为 `logcolorconsole`。
- en: All messages sent to the logger named `OtherLogger` are the subject of the third
    rule. We want all messages of the Info level or above, and we want to see them
    processed by our colorless, default Console logger.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到名为 `OtherLogger` 的日志记录器的所有消息都是第三条规则的主体。我们希望所有 Info 级别或以上的消息，并且我们希望看到它们被我们无色的默认控制台日志记录器处理。
- en: Run the sample. See how messages on different loggers get sent to the right
    place.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例。看看不同日志记录器的消息是如何被发送到正确的地方的。
- en: Asynchronous logging
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步日志记录
- en: Remember when I said that anything that takes longer than a few clock cycles
    should be done asynchronously? Well, NLog allows you to log to databases or network
    connections. They definitely have long-running operations. Unfortunately, there
    is no such method as `LogAsync()` in NLog. However, there is another solution
    to this.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我之前说过，任何需要超过几个时钟周期才能完成的事情都应该异步处理吗？嗯，NLog 允许你将日志记录到数据库或网络连接中。它们确实有长时间运行的操作。不幸的是，NLog
    中没有名为 `LogAsync()` 的方法。然而，对此还有一个解决方案。
- en: 'There is a target called `AsyncWrapper`. As the name suggests, this is a wrapper
    around other targets that make them work asynchronously. All you have to do is
    add that to the configuration like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `AsyncWrapper` 的目标。正如其名所示，这是一个围绕其他目标进行包装的包装器，使它们能够异步工作。你只需要像这样将其添加到配置中：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although the methods are still synchronous, NLog places all the log messages
    in a queue on a separate thread and writes them to the target on that thread instead
    of on the calling thread. You can set several variables to determine how long
    the delay must be, how long the queue can become, and so on. However, we have
    eliminated our delay when writing to a file, a database, or a network connection.
    I strongly suggest that you use that wrapper for anything besides Console!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方法仍然是同步的，但 NLog 将所有日志消息放入一个单独线程上的队列中，并在该线程上而不是在调用线程上将其写入目标。你可以设置几个变量来确定延迟必须多长时间，队列可以变得多长，等等。然而，我们在写入文件、数据库或网络连接时已经消除了延迟。我强烈建议你除了控制台之外，使用那个包装器来处理任何其他事情！
- en: Two useful but often neglected additional settings
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个有用但常被忽视的附加设置
- en: There are two more things I want to show you in the configuration file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，我还要展示两个更多的事情。
- en: The root element, NLog, can have a property named `autoReload=true`. If you
    set that, you can have NLog pick up changes in the log file while the application
    runs. We saw a similar option with the Microsoft logger; it is good to know that
    NLog also supports this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素 NLog 可以有一个名为 `autoReload=true` 的属性。如果你设置它，NLog 就可以在应用程序运行时拾取日志文件中的更改。我们之前在
    Microsoft 日志记录器中看到了类似的选项；了解 NLog 也支持这一点是很好的。
- en: With all the available rules, targets, variables, and other things you can set
    in the configuration file, you might wonder what to do if things go wrong.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中可以设置的所有可用规则、目标、变量和其他事情，你可能会想知道如果出了问题该怎么办。
- en: 'The people behind NLog thought of that as well. You can turn on logging for
    NLog itself. All you have to do is change the root entry to look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: NLog 背后的团队也想到了这一点。你可以打开 NLog 自身的日志记录。你只需要将根条目更改如下：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I have added the `internalLogFile` and `internalLogLevel` properties. Adding
    these properties results in NLog logging its internal logs to the given file.
    Doing this might help you find issues in your logging. It is all becoming a bit
    metaphysical, but you can log better by logging the workings of the log. Give
    it a try!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了 `internalLogFile` 和 `internalLogLevel` 属性。添加这些属性会导致 NLog 将其内部日志记录到指定的文件中。这样做可能有助于你找到日志中的问题。这有点形而上学，但通过记录日志的工作原理，你可以记录得更好。试试看吧！
- en: Serilog
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serilog
- en: There is one more framework I want to share with you. Serilog is a popular logging
    framework that first saw the light of day in 2013.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想与你分享另一个框架。Serilog 是一个流行的日志记录框架，它首次在 2013 年亮相。
- en: The idea behind Serilog is that it allows for structured logging. So far, all
    the logs we have seen have all just been one-liners with some text. Serilog is
    built around the idea that structure can bring clarity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog背后的理念是它允许结构化日志记录。到目前为止，我们所看到的日志都是一些只有一行文本的日志。Serilog 是围绕结构可以带来清晰这一理念构建的。
- en: Let me show you what I mean by that. Let’s build a sample.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过一个示例来展示我的意思。让我们构建一个示例。
- en: Although Serilog can (and should) be controlled by the settings in a configuration
    file, I will control this final example exclusively through code. I want to show
    you how to do that so you have at least seen it once.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Serilog可以通过配置文件中的设置进行控制（并且应该如此），但我会通过代码来控制这个最终示例。我想展示如何做到这一点，这样你至少见过一次。
- en: However, again, since you want to change logging depending on the state of the
    system, you are better off having a configuration file that you can change without
    recompiling.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，再次强调，由于你希望根据系统的状态来更改日志记录，你最好有一个可以更改而不需要重新编译的配置文件。
- en: Of course, we will begin by creating a new Console application and adding some
    NuGet packages.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将从创建一个新的控制台应用程序并添加一些 NuGet 包开始。
- en: Standard logging with Serilog
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Serilog 进行标准日志记录
- en: 'NLog has targets, and Serilog has **sinks**. You have to install all the sinks
    you need from different packages. I will only use Console and File in my sample,
    but there are others: SQL Server, HTTP, AWS, and so on.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: NLog 有目标，而 Serilog 有 **sinks**。你必须从不同的包中安装你需要的所有 sinks。在我的示例中，我将只使用控制台和文件，但还有其他：SQL
    Server、HTTP、AWS 等。
- en: You need to install the `Serilog`, `Serilog.Sinks.Console` and `Serilog.Sinks.File`
    NuGet packages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 `Serilog`、`Serilog.Sinks.Console` 和 `Serilog.Sinks.File` NuGet 包。
- en: 'Let’s write the code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code should look familiar. We create a configuration, this time all in
    code; we create a logger and log our messages. We end with a `CloseAndFlushAsync()`
    to ensure nothing is left in some buffer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来很熟悉。我们创建了一个配置，这次全部在代码中完成；我们创建了一个日志记录器并记录了我们的消息。我们以 `CloseAndFlushAsync()`
    结尾，以确保缓冲区中没有留下任何内容。
- en: There is nothing special about this code. OK, the new thing here is the `RollingInterval`.
    This property determines when the system should create a new file. You can set
    that to anything from a minute to a year. If you do not want to create a new file
    at any point, you can also set it to `Infinite`. That way, the system creates
    the file once and never again (unless you delete it, of course).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有什么特别之处。好吧，这里的新东西是 `RollingInterval`。这个属性决定了系统应该在何时创建一个新的文件。你可以将其设置为从一分钟到一年之间的任何时间。如果你在任何时候都不想创建新文件，你也可以将其设置为
    `Infinite`。这样，系统就会创建一个文件，然后永远不再创建（当然，除非你删除它）。
- en: 'Apart from that, there is nothing remarkable about Serilog. However, let’s
    change that. Change the parameters in the call to `WriteTo.File()` so that it
    looks like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，Serilog 没有什么特别之处。然而，让我们改变这一点。更改对 `WriteTo.File()` 的调用中的参数，使其看起来如下：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code sample, I added a `JsonFormatter` to the output of both the console
    and the file. When you add a formatter, you tell Serilog to output the logs a
    certain way. The `JsonFormatter` formatter forces the output to be in (well, you
    guessed it) the JSON format.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我向控制台和文件的输出中添加了一个 `JsonFormatter`。当你添加一个格式化器时，你告诉 Serilog 以某种方式输出日志。`JsonFormatter`
    格式化器强制输出为（好吧，你已经猜到了）JSON 格式。
- en: 'To truly use the structure log, we must change how we log the messages. Let’s
    add one line to the part where we write the logs:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正使用结构化日志，我们必须改变我们记录消息的方式。让我们在写入日志的部分添加一行：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we log a line of text, but instead of building that string beforehand,
    we do it in the message. In this case, we give it named parameters, `userId,`
    and `loggedInTime`, and then pass in the values that we want to display.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们记录了一行文本，但我们不是在事先构建那个字符串，而是在消息中完成。在这种情况下，我们提供了命名参数 `userId` 和 `loggedInTime`，然后传递我们想要显示的值。
- en: 'If you run it now, that last line, after formatting, results in this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行它，最后一行，在格式化后，结果如下：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, a lot more information is suddenly available. The structure
    of the logline is such that if we store it in a system somewhere, we can easily
    query the lines. Later in this chapter, I will show you how this is done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，突然出现了更多信息。日志行的结构是这样的，如果我们将其存储在某个系统中的话，我们可以轻松地查询这些行。在本章的后面部分，我将向你展示如何做到这一点。
- en: So, Serilog is comparable to the other two frameworks until you use one of the
    many formatters. The ability to store the log information to easily query it makes
    it a very powerful tool to have in your toolbelt!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直到您使用众多格式化工具之一，Serilog 与其他两个框架是可比的。将日志信息存储起来以便轻松查询的能力使其成为工具箱中一个非常强大的工具！
- en: Log levels in Serilog logging
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Serilog 日志记录中的日志级别
- en: As you will probably expect by now, Serilog also has levels. Those levels should
    look very familiar to you. This table shows the levels that Serilog offers and
    what they are meant to do.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能预料到的，Serilog 也具有级别。这些级别应该对您来说非常熟悉。下表显示了 Serilog 提供的级别以及它们的目的。
- en: '| **Serilog level** | **Description** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **Serilog 级别** | **描述** |'
- en: '| Verbose | This contains the most detailed information. These messages may
    contain sensitive application data and are therefore not recommended for production
    unless hidden. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 详细 | 这包含最详细的信息。这些消息可能包含敏感的应用程序数据，因此不建议在生产环境中使用，除非隐藏。 |'
- en: '| Debug | This level contains information that is useful in development and
    debugging. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 此级别包含在开发和调试中有用的信息。 |'
- en: '| Information | This level contains informational messages that highlight the
    general flow of the application. It is useful for general application insights.
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 此级别包含强调应用程序一般流程的信息性消息。它对一般应用程序洞察力很有用。 |'
- en: '| Warning | Indications of possible issues or service and functionality degradation
    are included at this level. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | 在此级别包含可能的问题或服务和功能退化的指示。 |'
- en: '| Error | Errors and exceptions that cannot be handled or are unexpected are
    included here. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 包含无法处理或意外的错误和异常。 |'
- en: '| Fatal | This level focuses on critical errors causing complete failure of
    the application and requiring immediate attention. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 致命 | 此级别关注导致应用程序完全失败的关键错误，需要立即关注。 |'
- en: '| Silent | This is the level for no logging at all (Serilog does not explicitly
    define a Silent level, but logging can effectively be turned off). |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 静默 | 这是完全不记录日志的级别（Serilog 并没有明确定义静默级别，但日志可以被有效关闭）。 |'
- en: 'Table 10.4: Serilog log levels'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.4：Serilog 日志级别
- en: 'Again, there are no surprises here. As with the other frameworks, you can use
    this however you want: no one can stop you from adding lots of debug information
    to the Error level. It is just not a very good idea.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里没有惊喜。与其他框架一样，您可以随意使用它：没有人能阻止您在错误级别添加大量调试信息。但这并不是一个好主意。
- en: Comparing the logging frameworks
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较日志框架
- en: 'After having seen all of these frameworks, you might wonder: which one should
    I pick? The answer is simple: choose whichever one you feel most comfortable with.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在看过所有这些框架之后，您可能会想知道：我应该选择哪一个？答案是简单的：选择您感觉最舒适的一个。
- en: 'All frameworks have pros and cons; none are bad or extremely good. They do
    have different use cases and areas of attention. The following table highlights
    some of those:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有框架都有优点和缺点；没有一个是坏的或极其好的。它们有不同的用例和关注领域。下表突出了一些这些：
- en: '| **Feature** | **.****NET Logger** | **NLog** | **Serilog** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **.NET 日志记录器** | **NLog** | **Serilog** |'
- en: '| **Overview** | Reliable and integrates seamlessly with .NET | Rich in features,
    great for a wide range of applications | Excels in structured logging, making
    data meaningful and searchable |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **概述** | 可靠且与 .NET 无缝集成 | 功能丰富，适用于广泛的用途 | 在结构化日志方面表现卓越，使数据有意义且可搜索 |'
- en: '| **Integration** | Deeply integrated with .NET Core, supports dependency injection
    and configuration settings | Flexible, can be used in various .NET applications,
    supports multiple targets | Great with .NET applications, especially for structured
    data stores such as Seq or Elasticsearch |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **集成** | 深度集成于 .NET Core，支持依赖注入和配置设置 | 灵活，可用于各种 .NET 应用程序，支持多个目标 | 与 .NET
    应用程序配合良好，特别是对于结构化数据存储如 Seq 或 Elasticsearch |'
- en: '| **Pros** | Minimal setupSupports structured logging | Advanced log routing
    and filtering; logs to multiple targets simultaneously | Exceptional at structured
    logging; supports enrichers for additional context |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | 最小化设置，支持结构化日志 | 高级日志路由和过滤；同时将日志发送到多个目标 | 在结构化日志方面表现卓越；支持 enrichers
    以提供更多上下文 |'
- en: '| **Cons** | Less feature-rich without third-party providers | Configuration
    can get complex | Might be overkill for simple needs; best features require compatible
    logging targets |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **缺点** | 没有第三方提供者功能较少 | 配置可能变得复杂 | 对于简单需求可能过于复杂；最佳功能需要兼容的日志目标 |'
- en: '| **Best for** | Projects that need straightforward logging with minimal setup
    | Applications requiring detailed control over logging, or when logging into multiple
    places | Projects where structured logging and data querying are priorities |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **最佳用途** | 需要简单日志记录且设置最少的工程 | 需要详细控制日志记录或需要在多个地方记录日志的应用程序 | 需要将结构化日志记录和数据查询作为优先事项的工程
    |'
- en: 'Table 10.5: Comparison between the logging frameworks'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.5：日志框架之间的比较
- en: You just have to look at your own needs and determine your scenario and way
    of working best. Pick that tool. My advice is to give the others a go. You might
    find a new favorite logging framework!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要看看自己的需求，确定最适合你的场景和工作方式。选择那个工具。我的建议是尝试其他工具。你可能会发现一个新的最喜欢的日志记录框架！
- en: So, we have now looked at logging. We have seen the most commonly used frameworks
    and how to use them. We have looked at default Microsoft logging; we have had
    an in-depth look at NLog and its robust collection of targets and rules. Finally,
    we have looked at Serilog’s structured logging approach.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经了解了日志记录。我们看到了最常用的框架以及如何使用它们。我们研究了默认的微软日志记录；我们深入研究了NLog及其强大的目标和规则集合。最后，我们探讨了Serilog的结构化日志方法。
- en: You should be able to use logging from now on. However, logging is part of your
    application. What if you do not get all the information you need from logging?
    That is where monitoring comes into play. Let’s have a look at that next!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你应该能够使用日志记录。然而，日志记录是应用程序的一部分。如果你从日志记录中没有获取到所有需要的信息怎么办？这就是监控发挥作用的地方。让我们看看下一个话题！
- en: A word of caution
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一点注意事项
- en: 'Logging is very useful. In fact, I would suggest that you cannot do serious
    development on systems without a UI if you do not have extensive logging. However,
    you must be careful: it is too easy to leak sensitive information about your system.
    Consider things such as connection strings, credentials, and other sensitive information.
    Also, you might sometimes accidentally disclose information about the inner workings
    of your system or even about the organization that this system runs. Be careful.
    Do not assume that people will not try to move the log level to Trace to see what
    is happening. Log as much as possible, but be mindful of the dangers!'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录非常有用。事实上，我建议如果你没有广泛的日志记录，你无法在没有用户界面的系统上进行严肃的开发。然而，你必须小心：泄露系统敏感信息太容易了。考虑一下连接字符串、凭证和其他敏感信息。此外，你有时可能会无意中泄露关于系统内部工作或运行此系统的组织的详细信息。要小心。不要假设人们不会尝试将日志级别移动到跟踪以查看发生了什么。尽可能多地记录日志，但要注意危险！
- en: Logging is one of the best things you can do to solve development and production
    issues. However, there is more that we can do. We need insights into these logs,
    but we must also monitor things such as memory usage, CPU usage, and much more.
    Let’s talk about monitoring next!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是解决开发和生产问题的最佳方法之一。然而，我们还可以做更多。我们需要深入了解这些日志，但我们也必须监控内存使用、CPU使用等更多事情。让我们接下来谈谈监控！
- en: Monitoring your applications
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控你的应用程序
- en: We need to keep an eye on things as our software runs. During development, we
    can turn on extensive logging to the console or to a file, which helps us track
    errors and issues. However, once our code runs on the final machine, it needs
    to run, and it might be a bit harder to look at all those log files.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在软件运行时密切关注事情。在开发过程中，我们可以将详细的日志记录到控制台或文件中，这有助于我们跟踪错误和问题。然而，一旦我们的代码在最终机器上运行，它需要运行，查看所有这些日志文件可能有点困难。
- en: Monitoring with Seq
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Seq进行监控
- en: Monitoring the system’s state is essential to keep things healthy. One of the
    great tools we have available to do this is Seq. Seq and Serilog are a match made
    in heaven!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 监控系统的状态对于保持系统健康至关重要。我们用来做这件事的伟大工具之一是Seq。Seq和Serilog是天作之合！
- en: One of the reasons why Serilog is getting so much attention these days is because
    of its ability to write logs in a structured manner. We looked at this in the
    previous section but did not dive into what we could do. It is time to change
    that.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog之所以最近受到如此多的关注，其中一个原因就是它能够以结构化的方式记录日志。我们在上一节中提到了这一点，但没有深入探讨我们可以做什么。现在是时候改变这一点了。
- en: Since the logs coming from Serilog are formatted in a particular way, we can
    also store them in a specific way. One of the tools that allow us to do so is
    Seq. Seq is a tool by the company Datalust. You can get a free personal license
    from them to play around with your logs. You can choose to install Seq on your
    machine, or you can choose to download a Docker image that contains everything
    you need. I prefer the latter, but it doesn’t matter which option you choose.
    The Datalust website clearly explains how to get the bits. You can find the documentation
    at [https://docs.datalust.co/docs/an-overview-of-seq](https://docs.datalust.co/docs/an-overview-of-seq).
    In the *Technical requirements* section of this chapter, I have shown you the
    Docker command that you will need to execute to get a local version of Seq running.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Serilog 生成的日志以特定方式格式化，我们也可以以特定方式存储它们。允许我们这样做的一个工具是 Seq。Seq 是 Datalust 公司的一个工具。你可以从他们那里获得一个免费的个人许可证来玩转你的日志。你可以选择在你的机器上安装
    Seq，或者你可以选择下载一个包含你所需所有内容的 Docker 镜像。我更喜欢后者，但选择哪个选项都无关紧要。Datalust 网站清楚地解释了如何获取这些资源。你可以在[https://docs.datalust.co/docs/an-overview-of-seq](https://docs.datalust.co/docs/an-overview-of-seq)找到文档。在本章的*技术要求*部分，我向你展示了你需要执行的
    Docker 命令来运行本地的 Seq 版本。
- en: 'Once you have done that, you can actually start to use Seq. We need to change
    our code a little bit. In addition to the packages that we installed earlier to
    enable logging to `Console` and `File`, we will also need a new package: `Serilog.Sinks.Seq`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你实际上可以开始使用 Seq。我们需要稍微修改一下我们的代码。除了我们之前安装的用于将日志记录到`Console`和`File`的包之外，我们还需要一个新的包：`Serilog.Sinks.Seq`。
- en: 'Once you have installed that, we must change the setup of the log a bit. That
    looks like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们必须稍微修改一下日志的设置。看起来是这样的：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we added a new `Sink` to our configuration, and this time, we
    are writing to Seq. I use the default port `5341`, since this is the port that
    Seq listens to.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在配置中添加了一个新的`Sink`，这次我们正在将数据写入 Seq。我使用默认端口`5341`，因为这是 Seq 监听的端口。
- en: 'If I run the application and go to the Seq dashboard on my machine, I will
    also get to see the logs there. That looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我运行应用程序并访问我机器上的 Seq 仪表板，我也可以在那里看到日志。看起来是这样的：
- en: '![Figure 10.3: Serilog captured by Seq](img/B20924_11_03.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：Seq 捕获的 Serilog](img/B20924_11_03.jpg)'
- en: 'Figure 10.3: Serilog captured by Seq'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：Seq 捕获的 Serilog
- en: You can clearly see all log messages. They are nicely colored. I have also opened
    the last message, in which we added some structural information. Seq captures
    this information and shows you exactly what is going on.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到所有的日志消息。它们被很好地着色。我还打开了最后一条消息，其中我们添加了一些结构化信息。Seq 捕获这些信息并显示正在发生的事情。
- en: 'You can also query over the logs by entering a SQL-like statement in the top
    edit box. That looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在顶部编辑框中输入类似 SQL 的语句来查询日志。看起来是这样的：
- en: "![Figure 10.\uFEFF4: Seq dashboard with a filter for user Id.](img/B20924_11_04.jpg)"
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：带有用户 ID 过滤器的 Seq 仪表板](img/B20924_11_04.jpg)'
- en: 'Figure 10.4: Seq dashboard with a filter for user Id.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：带有用户 ID 过滤器的 Seq 仪表板
- en: I added the `userId = 42` query in the edit box. This results in Seq only showing
    all messages about the user whose `userId` is `42`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我在编辑框中添加了`userId = 42`查询。这导致 Seq 只显示关于`userId`为`42`的用户的全部消息。
- en: The query language is extensive and you can write complex queries. This means
    that you can always find what you need even if you log many messages.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语言非常丰富，你可以编写复杂的查询。这意味着即使你记录了很多消息，你总能找到你需要的东西。
- en: Seq is extremely powerful and yet easy to set up. I highly recommend checking
    it out!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Seq 非常强大，同时设置起来也很简单。我强烈推荐您去了解一下！
- en: Performance counters
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能计数器
- en: Windows gives us lots of tools to monitor our systems, such as `EventViewer`.
    We can use those tools in our own systems as well. For instance, there are a lot
    of performance counters available that you can access both inside and outside
    of your code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 提供了许多工具来监控系统，例如`EventViewer`。我们也可以在我们的系统中使用这些工具。例如，有很多性能计数器可供访问，你可以在代码内外访问它们。
- en: Let’s look at how to get that in our code first.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何在代码中实现这一点。
- en: 'I started a new Console application, added the `System.Diagnostic` NuGet package,
    and then wrote the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我启动了一个新的控制台应用程序，添加了`System.Diagnostic` NuGet 包，然后编写了以下代码：
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Near the top of the file, I have created an instance of the `PerformanceCounter`
    class. This class gives us access to all the performance counters that we have
    mentioned, so we can also use them in our code. We need to specify the category
    and the item in that category we want to monitor. In my case, I went for `Processor`
    and `% Processor Time`, which are indicators of the load on the CPUs
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部附近，我创建了一个`PerformanceCounter`类的实例。这个类让我们能够访问我们提到过的所有性能计数器，因此我们也可以在代码中使用它们。我们需要指定我们想要监控的类别和该类别中的项目。在我的情况下，我选择了`Processor`和`%
    Processor Time`，这些都是CPU负载的指标。
- en: Then, I start a never-ending loop in which I increase a counter. As soon as
    that counter reaches `10`, I do some silly calculations on all the CPUs available
    on my machine. These calculations do not do anything useful besides keeping the
    CPUs busy. All this happens on a background thread, so the main loop keeps displaying
    how busy the system is.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我启动一个永无止境的循环，在这个循环中我增加一个计数器。一旦这个计数器达到`10`，我就会在我机器上所有可用的CPU上进行一些愚蠢的计算。这些计算除了让CPU忙碌之外没有任何实际作用。所有这些都在后台线程上发生，所以主循环会持续显示系统的忙碌程度。
- en: For readability, I will also change the color of the output if the CPU percentage
    is over 10%. You might have to change this threshold if you have a slower or faster
    machine than I do.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，如果CPU使用率超过10%，我还会更改输出颜色的。如果你使用的机器比我慢或快，你可能需要更改这个阈值。
- en: If you run this, you will be able to see how busy the system is. You should
    see a nice green output, but the system will get busier every few seconds, as
    shown by the red output.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你将能够看到系统的忙碌程度。你应该看到一个漂亮的绿色输出，但系统每几秒钟就会变得更忙，如红色输出所示。
- en: 'You can measure many items, tracking what the computer is doing. Suppose that
    you want to find out what you can monitor. In that case, you only need to open
    the Performance Monitor application on your Windows machine (search for `perfmon.exe`).
    You can add counters to the main screen; the dialog that shows them is a good
    source of information. Make sure that you check the **Show description** box at
    the bottom of the screen to see what all the counters do. To give you an idea,
    this is what that screen looks like when you search for the counter that we just
    used:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以测量许多项目，跟踪计算机正在做什么。假设你想找出你可以监控的内容。在这种情况下，你只需要打开Windows机器上的性能监视器应用程序（搜索`perfmon.exe`）。你可以在主屏幕上添加计数器；显示它们的对话框是一个很好的信息来源。确保你检查屏幕底部的**显示描述**框，以查看所有计数器的功能。为了给你一个概念，这是当你搜索我们刚刚使用的计数器时屏幕看起来像什么：
- en: '![Figure 10.5: Perfmon.exe example with % Processor Time](img/B20924_11_05.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：带有% Processor Time的Perfmon.exe示例](img/B20924_11_05.jpg)'
- en: 'Figure 10.5: Perfmon.exe example with % Processor Time'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：带有% Processor Time的Perfmon.exe示例
- en: I suggest that you browse through that list and see what you can find that might
    be useful. There are even categories specifically for the .NET CLR, so you can
    see how often the garbage collector runs or how frequently an exception has been
    raised per second!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你浏览这个列表，看看你能找到什么可能有用的东西。甚至有专门针对.NET CLR的类别，所以你可以看到垃圾收集器运行得多频繁，或者每秒钟抛出异常的频率是多少！
- en: Prometheus
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus
- en: Keeping an eye on your system’s vital metrics can help you pinpoint issues.
    If your system suddenly starts using a lot more memory, or if at certain times
    the CPU usage spikes, you might have a problem that needs fixing. Thus, it is
    important to track those metrics. As we just learned, we can use the `PerformanceCounter`
    class to get the necessary information and do something with it, such as writing
    it to Seq with Serilog.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关注你系统的重要指标可以帮助你定位问题。如果你的系统突然开始使用更多的内存，或者在某些时候CPU使用率突然上升，你可能有一个需要修复的问题。因此，跟踪这些指标非常重要。正如我们刚刚学到的，我们可以使用`PerformanceCounter`类来获取必要的信息并对其进行处理，例如将其写入Seq使用Serilog。
- en: However, that is not the only way. There is nothing wrong with the combination
    of Serilog and Seq. However, their primary goal is to log events. You can use
    a tool such as Prometheus to track trends, such as CPU usage or memory pressure.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是唯一的方法。Serilog和Seq的组合并没有什么问题。然而，它们的主要目标是记录事件。你可以使用像Prometheus这样的工具来跟踪趋势，比如CPU使用率或内存压力。
- en: 'Prometheus is similar to Serilog and Seq: they allow you to write something
    in your code to an external system that you can look at in your web browser. However,
    Prometheus is primarily used for ad monitoring and time series databases. It is
    designed to record real-time metrics in a scalable fashion. It excels at monitoring
    the state of your applications and infrastructure.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 与 Serilog 和 Seq 类似：它们允许你在代码中写入一些内容到外部系统，你可以在你的网页浏览器中查看这些内容。然而，Prometheus
    主要用于广告监控和时间序列数据库。它被设计成以可扩展的方式记录实时指标。它在监控应用程序和基础设施的状态方面表现出色。
- en: Let’s have a look at how all of that works.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这一切是如何工作的。
- en: The application that you want to monitor needs a NuGet package. So, let’s install
    that. It is called `prometheus-net`. However, that is only part of the equation.
    As I said, you can use your browser to see the events that you are interested
    in, so we will also need to install the server.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要监控的应用程序需要一个 NuGet 包。所以，让我们安装它。它被称为 `prometheus-net`。然而，这仅仅是方程的一部分。正如我所说的，你可以使用你的浏览器来查看你感兴趣的事件，因此我们还需要安装服务器。
- en: You can download Prometheus from [https://prometheus.io](https://prometheus.io)
    and run it on your machine. However, if you are just trying to figure out how
    it works and see whether this is the tool for you, I recommend downloading the
    Docker image and running it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://prometheus.io](https://prometheus.io) 下载 Prometheus 并在你的机器上运行它。然而，如果你只是想了解它是如何工作的，并看看这个工具是否适合你，我建议下载
    Docker 镜像并运行它。
- en: Prometheus needs a configuration file. This is a simple YAML file telling it
    how to behave. We need to link to that configuration file when we start the Docker
    image, so let’s write that file first.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 需要一个配置文件。这是一个简单的 YAML 文件，告诉它如何行为。当我们启动 Docker 镜像时，我们需要链接到这个配置文件，所以让我们先写这个文件。
- en: 'Open your favorite code editor and create a file called `prometheus.yml` somewhere.
    I have placed mine in a folder called `c:\data`. The preceding Docker command
    will ensure that it gets read and used inside the running container. This is what
    the file looks like:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你喜欢的代码编辑器，在某个地方创建一个名为 `prometheus.yml` 的文件。我把我的放在了一个名为 `c:\data` 的文件夹中。前面的
    Docker 命令将确保它在运行的容器内部被读取和使用。文件看起来是这样的：
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s see what is going on here.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。
- en: The first line defines the `scrape_interval`. This is the interval that determines
    how often Prometheus looks at the metrics. Since metrics are usually interesting
    over a longer time, you do not need the system to measure them continuously. In
    our example, I have set it to do a scrape every five seconds.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了 `scrape_interval`。这是 Prometheus 查看指标的间隔。由于指标通常在较长时间内才有意义，你不需要系统持续测量它们。在我们的例子中，我将其设置为每五秒进行一次抓取。
- en: The following line defines the `evaluation_interval`. Prometheus can have rules
    and alerts that fire when a particular metric goes over or under a specific metric.
    This interval determines how often it checks to see whether the alert needs to
    be fired. Again, I have set it to five seconds.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行定义了 `evaluation_interval`。Prometheus 可以有规则和警报，当某个特定指标超过或低于特定指标时，这些规则和警报会被触发。这个间隔决定了它检查是否需要触发警报的频率。再次强调，我已经将其设置为五秒。
- en: These two settings are global; they apply to all the metrics for all the applications
    that we monitor. We can later change these for each specific metric or application
    if we want to.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设置是全局的；它们适用于我们监控的所有应用程序的所有指标。如果我们想的话，以后我们可以为每个特定的指标或应用程序进行更改。
- en: 'The following section, called `scrape_configs`, defines the specific metrics
    that we want to collect. In my case, I have given it a name: `C# worker`. Then,
    we will tell it which server supplies the metrics. Again, in my case, it is `host.docker.internal:1234`.
    This means that the server runs on that URL with that specific port.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分，称为 `scrape_configs`，定义了我们想要收集的特定指标。在我的情况下，我给它起了一个名字：`C# worker`。然后，我们将告诉它哪个服务器提供指标。同样，在我的情况下，它是
    `host.docker.internal:1234`。这意味着服务器在该 URL 上运行，并使用特定的端口。
- en: “Wait a minute,” you might say, “I am not running a server; I am running a Console
    application!” Do not worry; Prometheus takes care of this.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，”你可能会说，“我并不是在运行服务器；我正在运行一个控制台应用程序！”不用担心；Prometheus 会处理这个问题的。
- en: The server application of Prometheus calls into the systems it needs to monitor
    over an HTTP connection. Thus, the clients it monitors need a web server that
    supplies that information. We do not have to take care of that; Prometheus does
    that for us.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 的服务器应用程序通过 HTTP 连接调用它需要监控的系统。因此，它监控的客户端需要一个提供该信息的网络服务器。我们不必担心这一点；Prometheus
    会为我们处理。
- en: IP addresses in Docker
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中的 IP 地址
- en: You might wonder why I use the `host.docker.internal` hostname as the server
    address. After all, both Docker and our Console application run on the same system.
    They both are available on `localhost`, right? That is incorrect; Docker containers
    all run in their own network (I am simplifying things here, but the idea still
    works). That means that if the Prometheus server would listen to anything on `localhost:1234`,
    it would only listen to the virtual network in the image. We need to supply the
    actual IP address of the machine that runs our application. However, if you do
    not want to hardcode that, use the `host.docker.internal` DNS name. The DNS system
    in Docker knows this name. It resolves the actual IP address of the host machine
    so that the containers in Docker can find the correct machine.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我使用`host.docker.internal`主机名作为服务器地址。毕竟，Docker和我们的控制台应用程序都在同一个系统上运行。它们都在`localhost`上可用，对吧？这是不正确的；Docker容器都在它们自己的网络中运行（我在这里简化了一些事情，但这个想法仍然有效）。这意味着如果Prometheus服务器监听`localhost:1234`上的任何内容，它只会监听镜像中的虚拟网络。我们需要提供运行我们应用程序的机器的实际IP地址。然而，如果你不想硬编码它，使用`host.docker.internal`
    DNS名称。Docker中的DNS系统知道这个名称。它解析主机机的实际IP地址，以便Docker容器可以找到正确的机器。
- en: 'Let’s have a look at our code. I have started a new Console application and
    added the NuGet package. The code itself looks like this. I start by setting up
    our metrics:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的代码。我已经启动了一个新的控制台应用程序并添加了NuGet包。代码本身看起来是这样的。我首先设置我们的指标：
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, I create a `Gauge`. This is like a thermometer that you use to measure
    metrics. In this case, I will make one that measures `app_memory_usage_bytes`,
    one of the many metrics that we can use.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我创建了一个`Gauge`。这就像一个温度计，你可以用它来测量指标。在这种情况下，我将创建一个测量`app_memory_usage_bytes`的，这是我们可用的许多指标之一。
- en: Then, we will create an instance of a `MetricServer`. You must specify the host
    from which the app runs and the port from which it broadcasts the metrics. Remember
    when I said that Prometheus listens to servers to collect its metrics? Well, this
    is where we set up that server.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`MetricServer`的实例。你必须指定应用程序运行的主机和广播指标所用的端口。记得我之前说过Prometheus会监听服务器来收集其指标吗？好吧，这就是我们设置那个服务器的地方。
- en: IP addresses and Docker, again
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址和Docker，再次
- en: I have used the `127.0.0.1` hostname here. If I used `localhost`, I would get
    errors for some reason. If I used the machine’s actual hostname, I would get errors.
    Either the app does not start up, or the Prometheus server can’t find my app.
    However, if I specify the IP address here (my actual IP address also works), the
    system works just fine. So, if you have issues with getting things to work, just
    try to use `127.0.0.1` here.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了`127.0.0.1`主机名。如果我使用`localhost`，由于某种原因我会得到错误。如果我使用机器的实际主机名，我也会得到错误。要么应用程序无法启动，要么Prometheus服务器找不到我的应用程序。然而，如果我在这里指定IP地址（我的实际IP地址也有效），系统就可以正常工作。所以，如果你在使事情正常工作时有问题，只需在这里尝试使用`127.0.0.1`。
- en: Then, I will start the server.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将启动服务器。
- en: 'Now, you are ready to send the metrics to the server. I have created a simple
    method that does this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好将指标发送到服务器了。我创建了一个简单的用于此目的的方法：
- en: '[PRE29]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That is basically all that you have to do.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是你必须做的所有事情。
- en: However, let’s see what happens when we actually do something. In the main body
    of my code, I have a simple loop that adds a block of memory every five seconds
    and then clears them all after 20 seconds, after which the whole thing starts
    all over again.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看当我们实际做些什么会发生什么。在我的代码的主体中，我有一个简单的循环，每五秒钟添加一个内存块，然后在20秒后清除所有这些，之后整个过程重新开始。
- en: 'The code looks like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是这样的：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I have defined some variables, such as `counter`, `buffer,` and `rnd`. In the
    loop, I will either add memory to the system, clear the memory, or do nothing.
    At the end, I will make sure to call the `UpdateMemoryGauge()` method. Then, the
    app sleeps for one second.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一些变量，例如`counter`、`buffer`和`rnd`。在循环中，我将向系统添加内存、清除内存或什么都不做。最后，我确保调用`UpdateMemoryGauge()`方法。然后，应用程序休眠一秒钟。
- en: 'The `AllocateMemoryBlock()` looks like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`AllocateMemoryBlock()`看起来是这样的：'
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, this is silly code; I hope you never write this in actual production
    code. However, it works here; we want to measure the memory usage of our app,
    so we might as well allocate lots of it. I have used a randomizer to make the
    system a bit less predictable because I like the look of the charts a bit better
    that way.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这段代码很愚蠢；我希望你永远不会在实际的生产代码中编写这样的代码。然而，它在这里是有效的；我们想要测量我们应用程序的内存使用情况，所以我们不妨分配很多内存。我使用了一个随机化器来使系统更不可预测，因为我更喜欢这样图表的外观。
- en: 'The `ClearMemory()` is even simpler:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearMemory()` 函数甚至更简单：'
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We then clear the list and clean up the memory by calling `GC.Collect()`, and
    we will log that to the screen.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后通过调用 `GC.Collect()` 清除列表并清理内存，并将此信息记录到屏幕上。
- en: 'That is it! If you run this for a while and open your browser to the default
    Prometheus URL of [http://localhost:9090](http://localhost:9090), you can search
    for the `app_memory_usage_bytes` metric. If you run the app for a while, you will
    get a nice chart like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！如果你运行一段时间，然后在浏览器中打开默认的Prometheus URL [http://localhost:9090](http://localhost:9090)，你可以搜索
    `app_memory_usage_bytes` 指标。如果你运行应用程序一段时间，你将得到一个像这样的图表：
- en: '![Figure 10.6: Prometheus sampling our memory usage](img/B20924_11_6.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：Prometheus采样我们的内存使用](img/B20924_11_6.jpg)'
- en: 'Figure 10.6: Prometheus sampling our memory usage'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：Prometheus采样我们的内存使用
- en: The chart shows our app in action, depicting how much memory it uses. You can
    probably also see why I used a randomizer; the chart looks slightly more interesting.
    However, that is just my personal preference.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了我们的应用程序在运行时的状态，描述了它使用了多少内存。你可能也能看出我为什么使用随机化器；图表看起来稍微有趣一些。然而，这只是我个人的偏好。
- en: You can search for metrics in the top part of the screen, or you can search
    for jobs. If you specify the `{job = "c# worker"}` search string, you will get
    over 30 metrics for your app. You can click on each of them to add them to the
    chart. There is a ton of information there!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在屏幕顶部搜索指标，或者搜索作业。如果你指定了 `{job = "c# worker"}` 搜索字符串，你将获得超过30个关于你应用程序的指标。你可以点击它们中的每一个来将它们添加到图表中。那里有大量的信息！
- en: Other platforms for monitoring
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他监控平台
- en: We have looked at Seq to collect our logs. We looked at performance counters
    and we looked at Prometheus. These are all great tools and I believe they are
    the ones that fit us as system programmers the best. However, there are many more
    systems out there that might work better for you and your specific use case. I
    will not describe them all in detail; that would justify a book in itself. However,
    here is an overview of some of the most used ones. If you are interested in them,
    I suggest that you do research and find out how they can help you!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了Seq来收集日志。我们查看了性能计数器，也查看了Prometheus。这些都是非常好的工具，我相信它们是我们作为系统程序员最适合的工具。然而，还有许多其他系统可能更适合你和你特定的用例。我不会详细描述它们；那足以写一本书。但是，这里是一些最常用的工具的概述。如果你对它们感兴趣，我建议你进行研究，找出它们如何帮助你！
- en: '| **Tool** | **Description** | **Use case** |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **工具** | **描述** | **用例** |'
- en: '| Application Insights | Part of Azure Monitor, it provides APM features and
    telemetry data | Cloud-based monitoring |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| Application Insights | 作为Azure Monitor的一部分，它提供APM功能和遥测数据 | 基于云的监控 |'
- en: '| New Relic | Offers full-stack observability, including application monitoring
    | Performance insights |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| New Relic | 提供全栈可观察性，包括应用程序监控 | 性能洞察 |'
- en: '| Dynatrace | Utilizes AI for automatic monitoring and problem resolution |
    Full-stack monitoring |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| Dynatrace | 利用AI进行自动监控和问题解决 | 全栈监控 |'
- en: '| Datadog | Provides monitoring, troubleshooting, and security for cloud applications
    | Cloud-native environments |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| Datadog | 为云应用程序提供监控、故障排除和安全 | 云原生环境 |'
- en: '| ELK Stack | Elasticsearch, Logstash for data processing, Kibana for visualization
    | Log Management |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| ELK Stack | Elasticsearch用于数据处理，Logstash用于数据收集，Kibana用于可视化 | 日志管理 |'
- en: '| Nagios | Offers monitoring and alerting services for servers, switches, applications,
    and services | Infrastructure monitoring |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| Nagios | 为服务器、交换机、应用程序和服务提供监控和警报服务 | 基础设施监控 |'
- en: '| AppDynamics | Application performance management and IT operations analytics
    | Business performance monitoring |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| AppDynamics | 应用性能管理和IT运营分析 | 业务性能监控 |'
- en: 'Table 10.6: Monitoring tools'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.6：监控工具
- en: As you can see, there are many options available, so there is definitely something
    that you can use that fits your specific needs!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有很多选项可供选择，所以肯定有适合你特定需求的东西可以使用！
- en: Now that you know how to monitor using Seq, performance counters, and Prometheus,
    we should look at what we are logging and monitoring.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用Seq、性能计数器和Prometheus进行监控，我们应该看看我们在记录和监控什么。
- en: What you should be monitoring or logging
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该监控或记录的内容
- en: 'We have seen a lot of ways in which we can log and monitor our systems. However,
    the question remains: what should you be logging and monitoring? The answer is
    simple: whatever you need to keep your systems healthy.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多可以记录和监控系统的方式。然而，问题仍然存在：你应该记录和监控什么？答案是简单的：无论你需要什么来保持系统健康。
- en: OK, that answer is probably the easy way out. Let’s be a bit more specific.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那个答案可能是个简单的方法。让我们更具体一点。
- en: Basic health monitoring
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本健康监控
- en: 'You should monitor the overall health of your system. Your application does
    not live in a vacuum, so you should be mindful of the state of the complete system
    and how you interact with it. These are some of the items you might want to keep
    an eye on:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该监控系统的整体健康状况。您的应用程序并不存在于真空中，因此您应该关注整个系统的状态以及您如何与之交互。以下是一些您可能想要关注的项目：
- en: '**CPU usage**: Track CPU usage to determine whether your application is causing
    a high CPU load'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU使用率**：跟踪CPU使用率，以确定您的应用程序是否导致高CPU负载'
- en: '**Memory usage**: Monitor memory consumption to detect memory leaks or excessive
    memory usage, which is critical in a managed environment such as .NET, where garbage
    collection occurs'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用**：监控内存消耗以检测内存泄漏或过度使用，这在垃圾回收发生的.NET等托管环境中至关重要'
- en: '**Disk I/O**: Monitor read/write operations and disk usage to ensure that disk
    I/O is not a bottleneck'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘I/O**：监控读写操作和磁盘使用情况，以确保磁盘I/O不是瓶颈'
- en: '**Network I/O**: Keep an eye on inbound and outbound network traffic, especially
    if your system communicates with other services'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络I/O**：关注入站和出站网络流量，尤其是如果您的系统与其他服务进行通信时'
- en: Of course, there are many other metrics you might be interested in, but these
    are usually the ones that people care about the most.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能对许多其他指标感兴趣，但这些通常是人们最关心的。
- en: Application-specific metrics
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序特定指标
- en: 'Of course, your system itself is also something that you should look into.
    These are the metrics I would suggest you add to your monitoring tool:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您自己的系统本身也是您应该关注的事情。以下是我建议您添加到监控工具中的指标：
- en: '**Thread counts and thread pool health**: It is helpful to know whether your
    threads are getting starved or whether the pool is overworked'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程计数和线程池健康**：了解您的线程是否被饿死或线程池是否过度工作是有帮助的'
- en: '**Garbage collection metrics**: Track the frequency and duration of garbage
    collection events to manage memory more effectively and optimize application performance'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收指标**：跟踪垃圾回收事件的频率和持续时间，以更有效地管理内存并优化应用程序性能'
- en: '**Queue lengths**: If your application uses message queues or similar structures,
    monitoring their lengths can help you understand throughput and backlogs'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列长度**：如果您的应用程序使用消息队列或类似结构，监控它们的长度可以帮助您了解吞吐量和积压情况'
- en: These metrics are more geared toward your application than the whole system,
    so I really recommend that you use these.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标更多地针对您的应用程序而不是整个系统，所以我强烈建议您使用这些。
- en: Errors and exceptions
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误和异常
- en: 'Exceptions happen. That is just a fact of life. So, you might want to track
    those as well. Monitoring tools can capture these exceptions, but I would not
    solely rely on them. Always log what is happening in your exception-handling code
    blocks. You should be thinking about these items:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 异常会发生。这就是生活的现实。因此，您可能还想跟踪这些异常。监控工具可以捕获这些异常，但我不会仅仅依赖它们。始终记录异常处理代码块中发生的事情。您应该考虑以下事项：
- en: '**Unhandled exceptions**: Log all unhandled exceptions with complete stack
    traces for debugging'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未处理的异常**：记录所有未处理的异常及其完整的堆栈跟踪，以便进行调试'
- en: '**Handled exceptions**: Sometimes, knowing about handled exceptions can provide
    insights into potential issues that are not critical yet but may become problematic'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已处理的异常**：有时，了解已处理的异常可以提供对潜在问题的洞察，这些问题目前可能不是关键的，但可能成为问题'
- en: Monitoring errors and exceptions is, in my opinion, a given. You really want
    to know about these events!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，监控错误和异常是理所当然的。您真的想了解这些事件！
- en: Application logs
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用程序日志
- en: 'Several things are happening around your application that might be worthwhile
    to keep track of. These are some of them:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕您的应用程序发生了一些可能值得跟踪的事情。以下是一些：
- en: '**Start/stop events**: Log when services or components start and stop to understand
    application life cycle events'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动/停止事件**：记录服务或组件的启动和停止，以了解应用程序的生命周期事件'
- en: '**Significant state changes**: Any change in the state that might affect the
    application’s behavior should be logged'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重要状态变化**：任何可能影响应用程序行为的状态变化都应该被记录'
- en: '**Security-related events**: These events include authentication attempts,
    access violations, and other security checks'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全相关事件**：这些事件包括身份验证尝试、访问违规和其他安全检查'
- en: Dependency health
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖项健康
- en: 'Applications rarely work in isolation. There are usually other systems that
    they depend on. You should track those dependencies as well:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少独立工作。通常还有其他系统依赖于它们。您应该跟踪这些依赖关系：
- en: '**Database connectivity**: Regular checks to ensure that your application can
    connect to databases or other storage systems'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库连接**：定期检查以确保您的应用程序可以连接到数据库或其他存储系统'
- en: '**External services**: Monitor the availability and response times of any APIs
    or external services that your application relies on'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部服务**：监控您的应用程序所依赖的任何API或外部服务的可用性和响应时间'
- en: Custom business logic monitoring
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制业务逻辑监控
- en: 'Of course, the application does some specific things that only apply to your
    environment. These might also be targets to monitor. Think about things such as
    these:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序会做一些特定的事情，这些事情仅适用于您的环境。这些也可能是监控的目标。考虑以下这些事情：
- en: '**Performance of critical operations** such as algorithms or processes central
    to your application’s functionality'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键操作的性能**，例如算法或对应用程序功能至关重要的进程'
- en: '**Data processing rates**, especially in systems that handle large volumes
    of data or streaming data'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理速率**，尤其是在处理大量数据或流数据的系统中'
- en: These are just some of the things you might add to your toolbelt.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是您可能添加到工具包中的一小部分内容。
- en: Use the right level!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确级别！
- en: 'Remember: assigning the right level to each event is essential when logging.
    Not everything should be Information; you must distinguish between an error and
    debug information. Again, please make sure that you are not leaking sensitive
    information through your logs.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：在记录日志时，为每个事件分配正确的级别是至关重要的。并非所有内容都应该是信息；你必须区分错误和调试信息。再次提醒，请确保您没有通过日志泄露敏感信息。
- en: Next steps
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: 'I hope that you took note of all of these items and kept a log of what we have
    been talking about! Logging and monitoring are extremely important, especially
    when you do not have a UI. We covered the logging frameworks available to you
    as a systems programmer in this chapter: the good and default Microsoft log, as
    well as NLog and structured logging in Serilog.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经注意到了所有这些项目，并记录了我们一直在讨论的内容！记录和监控非常重要，尤其是在您没有用户界面时。在本章中，我们介绍了作为系统程序员可用的日志记录框架：良好的默认微软日志，以及NLog和Serilog的结构化日志。
- en: We also looked at monitoring the health of your system and your application.
    We looked at Seq to collect our logs, discussed how to use performance counters,
    and dove into monitoring with Prometheus.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了您的系统和应用程序的健康状况。我们探讨了如何使用性能计数器，并深入研究了Prometheus的监控。
- en: We also talked about what you should be logging and monitoring and why you should
    do that.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了您应该记录和监控的内容以及为什么您应该这样做。
- en: All in all, from now on, you will no longer be in the dark when unexpected things
    happen. Since they *will* happen, you’d better make sure that you are prepared.
    A good logging and monitoring strategy can save your life. Well, maybe not your
    life, but it can help your system. That is what makes it all worth it. After all,
    a good log can set you on the right track when you want to start debugging your
    system. Incidentally, that is the topic of the next chapter!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，从现在开始，当意外事情发生时，您将不再处于黑暗中。因为它们**将会**发生，您最好确保自己已经做好准备。良好的日志记录和监控策略可以拯救您的生命。好吧，也许不是您的生命，但它可以帮助您的系统。这就是这一切都值得的原因。毕竟，一个好的日志可以帮助您在开始调试系统时走上正确的道路。顺便说一句，这正是下一章的主题！
