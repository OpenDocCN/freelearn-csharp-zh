- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Wrapping It All Up
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, we have discovered several patterns and nuances surrounding microservices
    design. Now, let us explore our patterns at a high level and tie all the concepts
    together. It is essential to scope which pattern fits best into each situation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经发现了围绕微服务设计的一些模式和细微差别。现在，让我们从高层次上探索我们的模式，并将所有概念联系起来。确定哪种模式最适合每种情况是至关重要的。
- en: The microservices architectural approach to software development promotes loose
    coupling of autonomous processes and creating standalone software components that
    handle these processes. An excellent approach to scoping these processes is to
    employ the **domain-driven design** (**DDD**) pattern. In DDD, we categorize the
    system’s functionality into sub-sections called domains and then use these domains
    to govern what services or standalone apps are needed to support each domain.
    We then use the aggregator pattern to attempt to scope the domain objects needed
    per service.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务软件开发方法促进了自主过程的松散耦合和创建处理这些过程的独立软件组件。对这些过程进行范围的一个优秀方法是采用**领域驱动设计**（**DDD**）模式。在DDD中，我们将系统的功能分类到称为领域的子部分，然后使用这些领域来管理需要支持每个领域的服务或独立应用程序。然后我们使用聚合器模式来尝试确定每个服务所需的领域对象。
- en: Aggregator pattern
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合器模式
- en: We scope the datas needed in each domain and what data needs to be shared between
    domains. At this point, we do risk duplicating data points across domains. Still,
    it is a condition we accept, given the need to promote autonomy across the services
    and their respective databases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定了每个领域所需的数据以及需要在领域之间共享的数据。在这个阶段，我们确实面临在领域之间重复数据点的风险。然而，鉴于需要促进服务及其相应数据库的自主性，这是一个我们接受的条件。
- en: In scoping the data requirements, we use the aggregator pattern, which allows
    us to define the various data requirements and relationships the different entities
    will have. An aggregate represents a cluster of domain objects that can be seen
    as a single unit. In this scoping exercise, we seek to find a root element in
    this cluster, and all other entities are seen as domain objects with associations
    with the root.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定数据需求时，我们使用聚合器模式，这使我们能够定义不同实体将具有的各种数据需求和关系。聚合体代表了一组可以被视为单一单位的领域对象。在这个范围练习中，我们试图找到这个集群的根元素，其他所有实体都被视为与根关联的领域对象。
- en: The general idea in scoping our domain objects per service is to capture the
    minimum amount of data needed for each service to operate. This means we will
    try to avoid storing entire domain records in several services and instead allow
    our services to communicate to retrieve details that might be domain-specific
    and reside in another service. This is where we need our services to communicate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在按服务确定我们的领域对象时的一般想法是捕捉每个服务操作所需的最小数据量。这意味着我们将尝试避免在多个服务中存储整个领域记录，而是允许我们的服务进行通信以检索可能具有领域特定性并驻留在另一个服务中的详细信息。这就是我们需要我们的服务进行通信的地方。
- en: Synchronous and asynchronous communication
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步和异步通信
- en: Our microservices need to communicate from time to time. The type of communication
    that we employ is based on the type of operation that we need to complete in the
    end. Synchronous communication means that one service will directly call another
    and wait for a response. It will then use this response to inform the process
    it sought to complete. This approach is ideal for situations where one service
    might have some data and needs the rest from another. For instance, the appointment
    booking service knows the patient’s ID number but has no other information. It
    will then need to make a synchronous API call to the patients’ service and GET
    the patient’s details. It can then carry one to process those details as necessary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务需要不时地进行通信。我们采用的通信类型基于我们最终需要完成的操作类型。同步通信意味着一个服务将直接调用另一个服务并等待响应。然后它将使用这个响应来通知它试图完成的进程。这种方法适用于一个服务可能有一些数据而需要从另一个服务获取其余数据的情况。例如，预约服务知道患者的ID号码但没有其他信息。然后它需要向患者服务进行同步API调用并获取患者的详细信息。然后它可以携带这些详细信息进行处理。
- en: Synchronous communication is great when we need instant feedback from another
    service. Still, it can introduce issues and increase response time when several
    other services must be consulted. We also run the risk of failures with each API
    call attempt, and one failure might lead to a total failure. We need to handle
    partial or complete failures gracefully and relative to the rules governing the
    business process. To mitigate this risk, we must employ asynchronous communication
    strategies to hand it off to a more stable and always-on intermediary that will
    transport data to the other services as needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从另一个服务获得即时反馈时，同步通信是非常好的。然而，当必须咨询多个其他服务时，它可能会引入问题并增加响应时间。我们还有每次API调用尝试失败的风险，一次失败可能会导致完全失败。我们需要优雅地处理部分或完全失败，并相对于业务流程的规则来处理。为了减轻这种风险，我们必须采用异步通信策略，将其传递给一个更稳定且始终在线的中介，该中介将根据需要将数据传输到其他服务。
- en: Asynchronous communication is better used in processes that need another service’s
    participation but not necessarily immediate feedback. The process of booking an
    appointment, for instance, will need to complete several operations that involve
    other microservices and third-party services. The process, for instance, will
    take and save the appointment information, make a calendar entry, and send several
    emails and notifications. We can then use an asynchronous messaging system (such
    as RabbitMQ or Azure Service Bus) as the intermediary system that will receive
    the information from the microservice. The other services that need participation
    are configured to monitor the messaging system and process any data that appears.
    Each service can then individually complete its operation in its own time and
    independently. The appointment service can also confirm success based on its needs
    without worrying about whether everything has been done.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信更适合需要其他服务参与但不需要即时反馈的过程。例如，预约过程将需要完成涉及其他微服务和第三方服务的多个操作。例如，该过程将获取并保存预约信息，创建日历条目，并发送多个电子邮件和通知。然后，我们可以使用异步消息系统（如RabbitMQ或Azure
    Service Bus）作为中介系统，该系统将接收来自微服务的信 息。需要参与的其他服务被配置为监控消息系统并处理任何出现的数据。然后，每个服务都可以在其自己的时间独立地完成其操作。预约服务也可以根据其需求确认成功，而无需担心是否已经完成了一切。
- en: As we separate our business process and scope and figure out which operations
    require synchronous communication and which ones require asynchronous communication,
    we find that we need better ways to format our code and properly separate the
    moving parts of our application’s code. This is where we begin looking at more
    complex design patterns such as **Command and Query Responsibility Separation**
    (**CQRS**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们分离业务流程和范围，并确定哪些操作需要同步通信以及哪些操作需要异步通信，我们发现我们需要更好的方式来格式化我们的代码，并正确地分离应用程序代码的移动部分。这就是我们开始查看更复杂的设计模式，如**命令和查询责任分离**（**CQRS**）的地方。
- en: CQRS
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS
- en: CQRS is a popular pattern employed to allow developers to better organize application
    logic. It is an improvement to the originally drafted pattern called **Command
    Query Separation** (**CQS**), which sought to give developers a clean way to separate
    logic that augments data in the database (commands) from the logic that retrieves
    data (query).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是一种流行的模式，它允许开发者更好地组织应用逻辑。它是最初称为**命令查询分离**（**CQS**）的模式的改进，该模式旨在为开发者提供一种清晰的方式来分离增强数据库中数据（命令）的逻辑和检索数据的逻辑（查询）。
- en: By introducing this level of separation, we can introduce additional abstractions
    and adhere to our SOLID principles more easily. Here, we introduce the concept
    of handlers, which represent individual units of work to be done. These handlers
    are implemented to specifically complete an operation using the minimum needed
    and fewest number of dependencies. This allows the code to become more scalable
    and easier to maintain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入这种级别的分离，我们可以引入额外的抽象，并更容易地遵循我们的SOLID原则。在这里，我们引入了处理器的概念，它代表要执行的单个工作单元。这些处理器被实现为专门使用最少的资源和最少的依赖关系来完成操作。这使得代码更具可扩展性，并且更容易维护。
- en: One downside to introducing this level of separation and abstraction is a major
    increase in the number of files and folders. To fully implement CQRS based on
    the recommended approach, we might also have several databases to support a single
    application. This is because the database used for the query operations needs
    to be optimized, which usually means we need a denormalized and high-speed lookup
    database structure. Our command operations might use a different database since
    storing data generally has stricter guidelines than reading it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这种程度分离和抽象的一个缺点是文件和文件夹数量的显著增加。根据推荐方法完全实现基于CQRS，我们可能还需要几个数据库来支持单个应用程序。这是因为用于查询操作的数据库需要优化，这通常意味着我们需要一个非规范化和高速查找的数据库结构。我们的命令操作可能使用不同的数据库，因为存储数据通常比读取数据有更严格的准则。
- en: Using the `NuGet` packages that help us to easily implement this pattern and
    reduce our overall development overhead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NuGet`包，这些包帮助我们轻松实现此模式并减少整体开发开销。
- en: 'Ultimately, this pattern should be leveraged for applications that have more
    complex business logic needs. It is not a recommended approach for standard applications
    that do the basic **Create, Read, Update, and Delete** (**CRUD**) operations,
    given the complexity level and project bloat it brings with it from an application
    code and supporting infrastructure perspective. It also introduces a new problem:
    keeping our read and write databases in sync.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这种模式应该被用于具有更复杂业务逻辑需求的应用程序。鉴于其复杂性和项目膨胀，它不是推荐用于执行基本**创建、读取、更新和删除**（**CRUD**）操作的标准应用程序的方法。它还引入了一个新问题：保持我们的读取和写入数据库同步。
- en: Let us take the approach where we use separate databases for query and command
    operations. We run the risk of having out-of-date data available for read operations
    in between operations. The best solution for the disconnect between the databases
    is called event sourcing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用使用单独的数据库进行查询和命令操作的方法。我们面临的风险是在操作之间，读取操作可能获得过时的数据。解决数据库之间断开连接的最佳解决方案被称为事件溯源。
- en: Event sourcing patterns
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源模式
- en: Event sourcing patterns bridge the gap between databases that need to be in
    sync. They help us track the changes across the system and act as a behind-the-scenes
    transport or lookup system to ensure that we always have the best data representation
    at any time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源模式弥合了需要同步的数据库之间的差距。它们帮助我们跟踪系统中的更改，并作为幕后传输或查找系统，确保我们始终拥有最佳的数据表示。
- en: 'First, an event represents a moment in time. The data contained in the event
    will indicate the type of action taken and the resulting data. This information
    can then be used for several reasons within the system:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个事件代表一个时间点。事件中包含的数据将指示采取的操作类型和结果数据。这些信息可以在系统内用于多个目的：
- en: Complete tasks for third-party services that need the resulting data for their
    operations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为需要用于其操作的结果数据的第三方服务完成任务
- en: Update the database for query operations with the latest copy of the augmented
    record
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最新副本更新查询操作的数据库
- en: Add to an event store as a versioning mechanism
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为版本控制机制添加到事件存储库
- en: Event sourcing can play several roles in a system and can aid us in completing
    several routines and unique tasks. Routine tasks within the context could include
    updating our read-only query database and acting as a source of truth for services
    that need to be executed based on the latest data after an operation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源可以在系统中扮演多个角色，并帮助我们完成多个常规和独特任务。在上下文中，常规任务可能包括更新我们的只读查询数据库，并作为在操作后基于最新数据执行的服务的事实来源。
- en: Less routine operations would depend on implementing an event store, another
    database provisioned to keep track of each event and its copy of the data. This
    acts as a versioning mechanism that allows us to easily facilitate auditing activities,
    point-in-time lookups, and even business intelligence and analytics operations.
    By keeping track of each data version over time, we can see the precise evolution
    of the records and use it to inform business decisions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 较少的常规操作将依赖于实现事件存储库，另一个数据库用于跟踪每个事件及其数据副本。这充当了一个版本控制机制，使我们能够轻松地促进审计活动、时间点查找，甚至商业智能和分析操作。通过跟踪随时间推移的每个数据版本，我们可以看到记录的精确演变，并利用它来指导业务决策。
- en: Not surprisingly, this pattern works naturally with CQRS, as we can easily and
    naturally trigger our events from our handlers. We can even use the event store
    as our query database lookup location, easing the tension associated with reading
    stale data. We can then extend our query capabilities and leverage the version
    and point-in-time lookups we now have access to.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 并不令人意外，这种模式与CQRS自然地结合在一起，因为我们可以从我们的处理程序中轻松且自然地触发事件。我们甚至可以使用事件存储作为我们的查询数据库查找位置，缓解与读取过时数据相关的紧张关系。然后我们可以扩展我们的查询能力，并利用我们现在可以访问的版本和特定时间点查找。
- en: Through the previously mentioned `NuGet` packages that allow us to implement
    the MediatR pattern, we can raise events at the end of an operation. We can also
    implement handlers that subscribe to specific events and carry out their operations
    once an event is raised. This allows us to easily scale the number of subscribers
    per event and individually and uniquely implement operations that execute per
    event.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前提到的允许我们实现MediatR模式的`NuGet`包，我们可以在操作结束时引发事件。我们还可以实现订阅特定事件的处理器，并在事件引发时执行其操作。这使得我们能够轻松扩展每个事件的订阅者数量，并单独且独特地实现每个事件执行的操作。
- en: These patterns are implemented per service and in no way unify code spread across
    several individual applications. Ensure that the patterns you choose are warranted
    for the microservice. Between event sourcing and CQRS, we have increased the number
    of scoped databases from one to potentially three. This can introduce hefty infrastructural
    requirements and costs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式是按服务实现的，并且以任何方式都不会统一分散在多个独立应用程序中的代码。确保你选择的模式适用于微服务。在事件溯源和CQRS之间，我们已经将作用域数据库的数量从一个增加到可能三个。这可能会引入大量的基础设施需求和成本。
- en: Now, let us review how we should handle database requirements in our microservices
    application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们应该如何处理微服务应用程序中的数据库需求。
- en: Database per service pattern
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个服务一个数据库模式
- en: The microservices architecture promotes autonomy and loose coupling of services.
    This concept of loose coupling should ideally be implemented throughout the entire
    code base and infrastructure. Sadly, this is only sometimes possible for cost
    reasons, especially at the database level.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构促进了服务的自主性和松散耦合。这种松散耦合的概念理想情况下应该在整个代码库和基础设施中得到实施。遗憾的是，由于成本原因，这只有在某些情况下才可能实现，尤其是在数据库层面。
- en: Databases can be expensive to license, implement, host, and maintain. The costs
    also vary based on the needs of the service that the database supports and the
    type of storage that is needed. One compelling reason to have individual databases
    is that we always want to choose the best technology stack for each microservice.
    Each one needs to retain its individuality, and the database choice is integral
    to the implementation process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的许可、实施、托管和维护可能成本高昂。成本也根据数据库支持的服务需求以及所需存储类型而变化。拥有独立数据库的一个令人信服的理由是我们总是希望为每个微服务选择最佳的技术堆栈。每个都需要保持其独特性，数据库选择对于实现过程至关重要。
- en: We have different types of databases, and it is important to appreciate the
    nuances between each and use that knowledge to scope the best database solution
    for the data we can expect to store for each microservice. Let us look at some
    of the more popular options.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同的数据库类型，重要的是要欣赏它们之间的细微差别，并利用这些知识来为每个微服务可以存储的数据范围最佳数据库解决方案。让我们看看一些更受欢迎的选项。
- en: Relational databases
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Relational databases store data in a tabular format and have strict measures
    to ensure that stored data is of the highest possible quality by its standards.
    They are best for systems that need to ensure data accuracy and might have several
    entities they need to store data for. They generally rely on a language called
    SQL to interact with data and, through a normalization process, will force us
    to spread data across several tables. This way, we can avoid repeating data and
    establish references to a record found in one table in other tables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库以表格格式存储数据，并采取严格的措施确保存储数据按照其标准达到最高可能的质量。它们最适合需要确保数据准确性的系统，可能需要为多个实体存储数据。它们通常依赖于一种称为SQL的语言来与数据交互，并通过规范化过程，将迫使我们在多个表中分散数据。这样，我们可以避免数据重复，并在其他表中建立对在一个表中找到的记录的引用。
- en: The downside is that the strict rules make it difficult to scale on demand,
    which leads to slower read times for data related to several entities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是严格的规则使得按需扩展变得困难，这导致与多个实体相关的数据读取时间变慢。
- en: Non-relational databases
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系型数据库
- en: Non-relational databases are also referred to as NoSQL databases, given their
    structural differences from traditional relational databases. They are not as
    strict regarding data storage and allow for greater scalability. They are best
    used for systems that require flexible data storage options, given rapidly changing
    requirements and functionality. They are also popularly used as read-only databases,
    given that they support the data being structured acutely to the system’s needs.
    The most popular implementations of these kinds of databases include document
    databases (such as **MongoDB** or **Azure Cosmos DB**), key-value databases (such
    as **Redis**), and graph databases (such as **Neo4j**).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系数据库也被称为NoSQL数据库，因为它们与传统的关系数据库在结构上有所不同。它们在数据存储方面不太严格，允许更大的可伸缩性。它们最适合需要灵活数据存储选项的系统，考虑到快速变化的需求和功能。它们也常作为只读数据库使用，因为它们支持数据被精确地结构化以满足系统的需求。这些类型数据库最流行的实现包括文档数据库（如**MongoDB**或**Azure
    Cosmos DB**）、键值数据库（如**Redis**）和图数据库（如**Neo4j**）。
- en: Each type has its strengths and weaknesses. The document databases option is
    most popularly used as an alternative to a relational database, given that it
    offers a more flexible way to store all the data points but keeps them in one
    place. This, however, can lead to data duplications and a reduction in overall
    quality if not managed properly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都有其优点和缺点。文档数据库选项最常作为关系数据库的替代品使用，因为它提供了一种更灵活的方式来存储所有数据点，但将它们保存在一个地方。然而，如果管理不当，这可能导致数据重复和整体质量的下降。
- en: When considering the best database option for services, we must consider maintainability,
    technology maturity and ease of use, and general appropriateness for the task.
    One size certainly does not fit all, but we must also consider costs and feasibility.
    We have several approaches to implementing supporting databases for our services;
    each has pros and cons.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑为服务选择最佳数据库选项时，我们必须考虑可维护性、技术成熟度和易用性以及任务的一般适用性。一种解决方案肯定不能适用于所有情况，但我们还必须考虑成本和可行性。我们有几种方法来实现支持我们服务的数据库；每种方法都有其优缺点。
- en: One database for all services
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有服务一个数据库
- en: This is the ideal solution from a cost analysis and maintenance perspective.
    Database engines are powerful and designed to perform under heavy workloads, so
    having several services using the same database is not the most difficult to implement.
    The team also doesn’t need a diverse skill set to maintain the database and work
    with the technology.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从成本分析和维护角度来看，这是理想的解决方案。数据库引擎功能强大，旨在在重负载下运行，因此多个服务使用相同的数据库并不难实现。团队也不需要多样化的技能集来维护数据库和与该技术合作。
- en: This approach, however, gives us one point of failure for all services. If this
    database goes offline, then all services will be affected. We also forfeit the
    flexibility of choosing the best database technology to support the technology
    stack that best implements each service. While most technology stacks have drivers
    to support most databases, the fact remains that some languages work best with
    certain databases. Be very careful when choosing this approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法给所有服务带来了一个故障点。如果这个数据库离线，那么所有服务都会受到影响。我们还放弃了选择最佳数据库技术以支持每个服务最佳实现的技术堆栈的灵活性。虽然大多数技术堆栈都有支持大多数数据库的驱动程序，但事实仍然是，某些语言与某些数据库配合得最好。在选择这种方法时务必非常小心。
- en: One database per service
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个服务一个数据库
- en: This solution provides maximum flexibility in our per-service implementations.
    Here, we can use the database technology that best serves the programming language
    and framework used and the microservice’s data storage needs. Services requiring
    a tabular data storage structure can rely on a relational database. By extension,
    microservices developed using PHP technology may favor a MySQL database, and using
    ASP.NET Core may favor Microsoft SQL Server. This will ease the attrition in supporting
    a database because a language might have less than adequate tooling. On the other
    hand, a NodeJS-based microservice might favor MongoDB since its data doesn’t need
    to be as structured and might evolve faster than the other services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案为我们每个服务的实现提供了最大的灵活性。在这里，我们可以使用最适合所使用的编程语言和框架以及微服务的数据存储需求的数据库技术。需要表格数据存储结构的服务可以依赖关系数据库。通过扩展，使用PHP技术开发的微服务可能会倾向于MySQL数据库，而使用ASP.NET
    Core可能会倾向于Microsoft SQL Server。这将减轻支持数据库的磨损，因为一种语言可能缺乏足够的工具。另一方面，基于NodeJS的微服务可能会倾向于MongoDB，因为其数据不需要那么结构化，并且可能比其他服务更快地发展。
- en: The obvious drawbacks here are that we need to be able to support multiple database
    technologies, and the skill sets must be present for routine maintenance and upkeep
    activities. We also incur additional costs for licensing and hosting options since
    the databases may (ideally, will) require separate server hosting arrangements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里明显的缺点是我们需要能够支持多种数据库技术，并且必须具备进行常规维护和保养活动的技能集。我们还因为许可和托管选项而承担额外的成本，因为数据库可能（理想情况下，将会）需要单独的服务器托管安排。
- en: Individually, each service needs to ensure its data is as accurate and reliable
    as possible. Therefore, we use a concept called transactions to ensure that data
    either gets augmented successfully or not. This is especially useful for relational
    databases where the data might be spread across several tables. By enforcing this
    all-or-nothing mechanism, we mitigate partial successes and ensure that the data
    is consistent across all tables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，每个服务都需要确保其数据尽可能准确和可靠。因此，我们使用一个称为事务的概念来确保数据要么成功更新，要么不更新。这对于数据可能分布在多个表中的关系数据库来说特别有用。通过强制执行这种全有或全无机制，我们减少了部分成功的情况，并确保数据在所有表中保持一致性。
- en: Always choose the best technologies for the microservice you are constructing
    to address the business problem or domain. This flexibility is one of the more
    publicized benefits of having a loosely coupled application where the different
    parts do not need to share assets or functionality.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总是选择最适合你正在构建的微服务的技术来解决问题或领域。这种灵活性是拥有松散耦合应用程序的更多公开宣传的好处之一，在这种应用程序中，不同的部分不需要共享资产或功能。
- en: Conversely, having separate databases supporting autonomous services can lead
    to serious data quality issues. Recall that some operations need the participation
    of several services, and sometimes, if one service fails to augment its data store,
    there is no real way to track what has failed and take corrective measures. Each
    service will handle its transaction, but an operation involving several independent
    databases will run the risk of partial completion, which is bad. This is where
    we can look to the Saga pattern to help us manage this risk.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用支持独立服务的单独数据库可能会导致严重的数据质量问题。回想一下，某些操作需要几个服务的参与，有时，如果一个服务未能更新其数据存储，就真的没有方法来跟踪失败并采取纠正措施。每个服务将处理其事务，但涉及几个独立数据库的操作将面临部分完成的风险，这是不好的。这就是我们可以求助于悲剧模式来帮助我们管理这种风险的地方。
- en: Using the saga pattern across services
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务之间使用悲剧模式
- en: The saga pattern is generally implemented to assist with the concept of all-or-nothing
    in our microservices application. Each service will do this for itself, but we
    need mechanisms to allow the services to communicate their success or failure
    to others and, by extension, act when necessary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 悲剧模式通常用于协助我们在微服务应用程序中实现全有或全无的概念。每个服务都会为自己做这件事，但我们需要机制来允许服务相互通知其成功或失败，并且，通过扩展，在必要时采取行动。
- en: Take, for instance, if we have an operation that requires the participation
    of four services, and each one will store bits of data along the way; we need
    a way to allow the services to report on whether their database operations were
    successful. If not, we trigger rollback operations. Two ways we can implement
    our saga patterns are through choreography or orchestration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们有一个需要四个服务参与的操作为例，每个服务都会在过程中存储一些数据；我们需要一种方式让服务报告其数据库操作是否成功。如果不成功，我们触发回滚操作。我们可以通过编排或编排来实现我们的悲剧模式。
- en: Using choreography, we implement a messaging system (such as RabbitMQ or Azure
    Services Bus) where services notify each other of the completion or failure of
    their operations. There is no central control of the flow of messages. Still,
    each service is configured to act on the receipt of certain messages and publish
    messages based on the outcome of its internal operation. This is a good model
    where we want to retain each service’s autonomy, and no service needs any knowledge
    of the other.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编排，我们实现了一个消息系统（如RabbitMQ或Azure服务总线），其中服务会相互通知其操作完成或失败。虽然没有中央控制消息流，但每个服务都被配置为在接收到某些消息时采取行动，并根据其内部操作的结果发布消息。这是一个很好的模型，我们希望保持每个服务的自主性，并且没有服务需要了解其他服务。
- en: Choreography seems straightforward in theory but can be complex to implement
    and extend when new services need to be added to the saga. In the long run, each
    time the saga needs modification, several touchpoints will need attention. These
    factors promote the orchestration approach as a viable alternative.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，编排看起来很简单，但在需要向叙事添加新服务时实现和扩展可能会很复杂。从长远来看，每次叙事需要修改时，都需要关注几个接触点。这些因素促进了编排方法作为一个可行的替代方案。
- en: Using the orchestration method, we can establish a central observer that will
    coordinate the activities related to the saga. It will orchestrate each call to
    each service and decide on the next step based on the service’s success or failure
    response. The saga in the orchestrator is implemented to follow specific service
    calls in a specific order along a success track and, separately, along a failure
    track. If a failure occurs in the middle of the saga, the orchestrator will begin
    calling the rollback operations for each service that previously reported success.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编排方法，我们可以建立一个中央观察者，该观察者将协调与叙事相关的活动。它将编排对每个服务的每个调用的调用，并根据服务的成功或失败响应决定下一步。在编排器中实现的叙事将按照特定顺序沿着成功轨迹和单独的失败轨迹跟踪特定的服务调用。如果在叙事的中间发生失败，编排器将开始调用之前已报告成功的每个服务的回滚操作。
- en: Comparably, the orchestrator approach allows for better control and oversight
    of what is happening at each step of the saga but might be more challenging to
    implement and maintain in the long run. We will have just as many touchpoints
    to maintain as the saga evolves.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 比较而言，编排方法允许更好地控制和对叙事每个步骤发生情况的监督，但可能更难以在长期内实现和维护。随着叙事的发展，我们将有同样多的接触点需要维护。
- en: Your chosen approach should match your system’s needs and your desired operational
    behavior. Choreography promotes service autonomy but can lead to a spaghetti-like
    implementation for a large saga where we need to track which service consumes
    which message. This also makes it very difficult to debug. The orchestrator method
    forces us to introduce a central point of failure since if the orchestrator fails,
    nothing else can happen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的方法应与您的系统需求以及您期望的操作行为相匹配。编排促进服务自治，但可能导致大型叙事的意大利面式实现，我们需要跟踪哪个服务消费了哪个消息。这也使得调试变得非常困难。编排方法迫使我们引入一个中心故障点，因为如果编排器失败，其他什么都不会发生。
- en: Both approaches, however, hinge on the overall availability of the services
    and dependencies involved in completing the operation. We need to ensure that
    we do not take the first failure as the final response and implement logic that
    will try an operation several times before giving up.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种方法都取决于服务及其依赖项的整体可用性，以完成操作。我们需要确保我们不将第一次失败视为最终响应，并实现逻辑，在放弃之前尝试操作多次。
- en: Resilient microservices
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性微服务
- en: Building resilient services is very important. This acts as a safety net against
    transient failures that otherwise break our system and lead to poor user experiences.
    No infrastructure is bulletproof. Every network has failure points, and services
    that rely on an imperfect network are inherently also imperfect. Beyond the imperfections
    of the infrastructure, we also need to consider the general application load and
    the act that our request now might be one too many. This doesn’t mean that the
    service is offline; it just means that it is stressed out.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构建具有弹性的服务非常重要。这充当了对系统造成破坏并导致糟糕用户体验的暂时性失败的缓冲。没有基础设施是坚不可摧的。每个网络都有故障点，依赖于不完美网络的服务的本质也是不完美的。除了基础设施的不完美之外，我们还需要考虑一般的应用负载以及我们的请求现在可能是一个过多的行为。这并不意味着服务已离线；这只是意味着它压力很大。
- en: Not all failure reasons are under our control, but how our services react can
    be. By implementing retry logic, we can force a synchronous call to another service
    to make the call again until a successful call has been made. This helps us reduce
    the number of failures in the application and gives us more positive and accurate
    outcomes in our operations. Typical retry logic involves us making an initial
    call and observing the response. We try the call again when the response is something
    other than the expected outcome. We continue this until we receive a response
    that we can work with. This very simplified take on retry logic has some flaws,
    however.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有故障原因都在我们的控制之下，但我们可以控制我们的服务如何响应。通过实现重试逻辑，我们可以强制同步调用另一个服务，直到成功调用为止。这有助于我们减少应用程序中的故障数量，并在我们的操作中提供更多积极和准确的结果。典型的重试逻辑包括我们进行初始调用并观察响应。当响应不是预期结果时，我们再次尝试调用。我们继续这样做，直到我们收到可以处理的响应。然而，这种非常简化的重试逻辑存在一些缺陷。
- en: We should only retry for a while since we are unsure if the service is experiencing
    an outage. In that case, we need to implement a policy that will stop making the
    retry calls after a certain number of attempts. We call this a circuit-breaker
    policy. We also want to consider that we want to add some time between the retry
    attempts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只重试一段时间，因为我们不确定服务是否正在经历中断。在这种情况下，我们需要实施一个策略，在尝试一定次数后停止重试调用。我们称这种策略为断路器策略。我们还希望考虑在重试尝试之间添加一些时间。
- en: Policies this complex can be implemented using simple code through a `NuGet`
    package called Polly. This package allows us to declare global policies that can
    be used to govern how our `HttpClient` services make API calls. We can also define
    specific policies for each API call.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这么复杂的策略可以通过一个名为 Polly 的简单代码实现，这是一个 `NuGet` 包。这个包允许我们声明全局策略，这些策略可以用来管理我们的 `HttpClient`
    服务如何进行 API 调用。我们还可以为每个 API 调用定义特定的策略。
- en: Retries go a long way in helping us maintain the appearance of a healthy application.
    Still, prevention is better than a cure, and we prefer to track and mitigate failures
    before they become serious. For this, we need to implement health checks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重试在很大程度上有助于我们保持应用程序健康的外观。然而，预防胜于治疗，我们更喜欢在故障变得严重之前跟踪和缓解故障。为此，我们需要实施健康检查。
- en: Importance of health checks
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查的重要性
- en: A health check, as the name suggests, allows us to track and report on the health
    of a service. Each service is a potential point of failure in an application,
    and each service has dependencies that can influence its health. We need a mechanism
    that allows us to probe the overall status of our services to be more proactive
    in solving issues.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，健康检查允许我们跟踪和报告服务的健康状况。每个服务都是应用程序中可能发生故障的点，每个服务都有可能影响其健康状况的依赖项。我们需要一个机制来探测我们服务的整体状态，以便更主动地解决问题。
- en: ASP.NET Core has a built-in mechanism for reporting on the health of a service,
    and it can very simply tell us if the service is healthy, degraded, or unhealthy.
    We can extend this functionality to report the health of not only the service
    but to also account for the health of the connections to dependent services such
    as databases and caches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 内置了一种报告服务健康状况的机制，它可以非常简单地告诉我们服务是否健康、退化或不健康。我们可以扩展这个功能，不仅报告服务的健康状况，还要考虑对数据库和缓存等依赖服务的连接健康状况。
- en: We can also establish various endpoints that can be used to check different
    outcomes, such as general runtime versus startup health. This categorization comes
    in handy when we want to categorize monitoring operations based on the tools we
    are using, monitoring teams in place, or general application startup operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以建立各种端点，用于检查不同的结果，例如一般运行时与启动时的健康状况。当我们想要根据我们使用的工具、现有的监控团队或一般的应用程序启动操作对监控操作进行分类时，这种分类非常有用。
- en: We can establish liveness checks, which can be probed at regular intervals to
    report on the overall health of an application that is expected to be running.
    We act whenever there is an unhealthy result, which will be a part of our daily
    maintenance and upkeep activities. When a distributed application is starting
    up, however, and several services depend on each other, we want to accurately
    determine which dependent service is healthy and available before we launch the
    service that depends on it. These kinds of checks are called readiness checks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以建立存活性检查，这些检查可以定期进行以报告预期运行的应用程序的整体健康状况。只要出现不健康的结果，我们就会采取行动，这将是我们的日常维护和保养活动的一部分。然而，当分布式应用程序启动时，并且多个服务相互依赖时，我们希望在启动依赖于它的服务之前，准确确定哪个依赖服务是健康和可用的。这类检查被称为就绪性检查。
- en: Given the complexity and often overwhelming number of services to keep track
    of in a distributed application, we tend to automate our hosting, deployment,
    and monitoring duties as much as possible. Containerization, which we will discuss
    shortly, is a standard way of hosting our applications in a lightweight and stable
    manner, and orchestration tools such as Kubernetes make it easy for us to perform
    health probes on the services and the container, which will inform us of the infrastructure’s
    health. Ultimately, we can leverage several automated tools to monitor and report
    on our services and dependencies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分布式应用中需要跟踪的服务复杂性和数量往往很大，我们尽可能地自动化我们的托管、部署和监控任务。容器化，我们将在稍后讨论，是一种以轻量级和稳定的方式托管我们的应用程序的标准方法，而编排工具如Kubernetes使我们能够轻松地对服务和容器进行健康检查，这将告诉我们基础设施的健康状况。最终，我们可以利用几个自动化工具来监控和报告我们的服务和依赖项。
- en: We have spent some time exploring nuances surrounding our microservices and
    how they relate to each other. However, we have yet to discuss the nuances surrounding
    having one client or more client applications that need to relate to several services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间探索围绕我们的微服务及其相互关系的细微差别。然而，我们还没有讨论围绕一个或多个需要与多个服务相关联的客户端应用程序的细微差别。
- en: API Gateways and backend for frontend
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关和前端后端
- en: An application based on the microservices architecture will have a user interface
    that will interact with several web services. Recall that our services have been
    designed to rule over a business domain, and many operations that users complete
    span several domains. Because of this, the client application will need to have
    knowledge of the services and how to interact with them to complete one operation.
    By extension, we can have several clients in web and mobile applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务架构的应用程序将有一个用户界面，该界面将与多个网络服务交互。回想一下，我们的服务已经被设计来统治一个业务领域，并且用户完成的许多操作跨越了多个领域。因此，客户端应用程序需要了解服务以及如何与它们交互以完成一个操作。通过扩展，我们可以在Web和移动应用程序中拥有多个客户端。
- en: The problem is that we will need to implement too much logic in the client application
    to facilitate all the service calls, which can lead to a chatty client app. Then,
    maintenance becomes more painful with each new client that we introduce. The solution
    here is to consolidate a point of entry to our microservices. This is called an
    API gateway, and it will sit between the services and the client app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们需要在客户端应用程序中实现过多的逻辑来支持所有服务调用，这可能导致客户端应用程序变得冗长。随着我们引入的新客户端越来越多，维护工作也会变得更加痛苦。这里的解决方案是将我们的微服务的入口点进行整合。这被称为API网关，它将位于服务和客户端应用程序之间。
- en: An API gateway allows us to centralize all our services behind a single endpoint
    address, making it easier to implement API logic. After a request is sent to the
    central endpoint, it is routed to the appropriate microservice, which exists at
    a different endpoint. The API gateway allows us to create a central register for
    all endpoint addresses in our application and add intermediary operations to massage
    request and response data in between requests as needed. Several technologies
    exist to facilitate this operation, including a lightweight ASP.NET Core application
    called **Ocelot**. As far as cloud options go, we can turn to Azure API Management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: API网关允许我们将所有服务集中在一个单一端点地址之后，这使得实现API逻辑变得更加容易。在请求发送到中央端点之后，它会被路由到适当的微服务，这些微服务存在于不同的端点。API网关允许我们为应用中的所有端点地址创建一个中央注册表，并在需要时添加中间操作来处理请求和响应数据。为此操作提供便利的技术包括一个轻量级的ASP.NET
    Core应用程序，称为**Ocelot**。至于云选项，我们可以转向Azure API管理。
- en: Now that we have a gateway, we have another issue where we have multiple clients,
    and each client has different API interaction needs. For instance, mobile devices
    will need different caching and security allowances than the web and smart device
    client apps. In this case, we can implement the backend for frontend pattern.
    This is much simpler than it sounds, but it needs to be properly implemented to
    be effective and can lead to additional hosting and maintenance costs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了网关，我们遇到了另一个问题，即我们有多位客户端，每个客户端都有不同的 API 交互需求。例如，移动设备将需要与 Web 和智能设备客户端应用程序不同的缓存和安全权限。在这种情况下，我们可以实现后端为前端模式。这比听起来简单得多，但需要正确实施才能有效，并可能导致额外的托管和维护成本。
- en: This pattern behooves us to provide a specially configured gateway to cater
    to the targeted client app’s needs. If our healthcare application needs to be
    accessed by web and mobile clients, we will implement two gateways. Each gateway
    will expose a specific API endpoint that the relevant client will consume.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式要求我们提供一个专门配置的网关，以满足目标客户端应用程序的需求。如果我们的医疗保健应用程序需要被 Web 和移动客户端访问，我们将实现两个网关。每个网关将公开一个相关的客户端将使用的特定
    API 端点。
- en: Now that we are catering to various client applications and devices, we need
    to consider security options that facilitate any client application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在为各种客户端应用程序和设备提供服务，我们需要考虑便于任何客户端应用程序的安全选项。
- en: Bearer token security
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 携带者令牌安全性
- en: Security is one of the fundamental parts of application development that we
    need to get right. Releasing software that does not control user access and permissions
    can have adverse side effects in the long run and allow for the exploitation of
    our application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是应用开发中需要正确处理的基本部分之一。发布无法控制用户访问和权限的软件，从长远来看可能会产生不利影响，并允许我们的应用程序被利用。
- en: Using ASP.NET Core, we have access to an authentication library called `Identity
    Core`, which supports several authentication methods and allows us to easily integrate
    authentication into our application and supporting database. It has optimized
    implementations for the various authentication methods and authorization rules
    we implement in web applications and allows us to easily protect certain parts
    of our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core，我们可以访问一个名为 `Identity Core` 的身份验证库，它支持多种身份验证方法，并允许我们轻松地将身份验证集成到我们的应用程序和支持数据库中。它为我们在
    Web 应用程序中实现的多种身份验证方法和授权规则提供了优化的实现，并允许我们轻松地保护应用程序的某些部分。
- en: Typically, we use authentication to identify the user attempting to gain access
    to our system. This usually requires the user to input a username and a password.
    If their information can be validated, we can check what they are authorized to
    do and then create a session using their basic information. All of this is done
    to streamline an experience for the user where they can freely use different parts
    of the application as needed without reauthenticating each step. This session
    is also referred to as a state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用身份验证来识别试图访问我们系统的用户。这通常需要用户输入用户名和密码。如果他们的信息可以验证，我们可以检查他们被授权执行的操作，然后使用他们的基本信息创建一个会话。所有这些操作都是为了简化用户体验，使用户能够根据需要自由地使用应用程序的不同部分，而无需在每一步重新进行身份验证。这个会话也被称为状态。
- en: In API development, we do not have the luxury of creating a session or maintaining
    a state. Therefore, we require that a user authenticates each request to secured
    API endpoints. This means we need an efficient way to allow the user to pass their
    information with each request, evaluate it, and then send an appropriate response.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 开发中，我们没有创建会话或维护状态的便利。因此，我们需要用户对受保护的 API 端点进行每次请求的身份验证。这意味着我们需要一种有效的方法来允许用户在每次请求中传递他们的信息，评估它，然后发送适当的响应。
- en: Bearer tokens are the current industry standard method of supporting this form
    of stateless authentication needs. A bearer token gets generated after the initial
    authentication attempt, where the user shares their username and password. Once
    the information is validated, we retrieve bits of information about the user,
    which we call claims, and combine them into an encoded string value, which we
    call a token. This token is then returned in the API response.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 携带者令牌是当前行业标准的支持这种无状态身份验证需求的方法。携带者令牌在初始身份验证尝试之后生成，此时用户分享他们的用户名和密码。一旦信息得到验证，我们检索关于用户的一些信息，这些信息我们称之为声明，并将它们组合成一个编码的字符串值，我们称之为令牌。然后，这个令牌作为
    API 响应返回。
- en: The application that triggered the authentication call initially will need to
    store this token for future use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 触发初始身份验证调用的应用程序需要存储此令牌以供将来使用。
- en: 'Now that the user has been issued a token, any follow-up API calls will need
    to include this token. When the API receives subsequent requests to secure endpoints,
    it will check for the presence of the token in the header section of the API request
    and then seek to validate the token for the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户已经颁发了一个令牌，任何后续的 API 调用都需要包含这个令牌。当 API 收到后续请求以保护端点时，它将检查 API 请求的头部部分是否存在令牌，然后尝试验证令牌以进行以下操作：
- en: '**Audience**: This is a value that depicts the expected receiving application
    of the token'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受众**：这是一个表示预期接收令牌的应用程序的值'
- en: '**Issuer**: This states the application that was issued to the token'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者**：这表明了颁发给令牌的应用程序'
- en: '**Expiration Date and Time**: Tokens have a lifespan, so we ensure that the
    token is still usable'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期日期和时间**：令牌有生命周期，因此我们确保令牌仍然可用'
- en: '**User claims**: This information usually includes the user’s roles and what
    they are authorized to do'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户声明**：这些信息通常包括用户的角色以及他们被授权执行的操作'
- en: We can gauge all the points we wish to validate each time a request comes in
    with a token; the stricter the validation rules, the more difficult it is for
    someone to fake or reuse a token on an API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每次带有令牌的请求到来时评估我们希望验证的所有点；验证规则越严格，就越难有人伪造或重复使用令牌在 API 上。
- en: Securing one API is simple enough, but this becomes very tedious and difficult
    to manage when this effort is spread across several APIs, as in a microservice-based
    application. It is not a good experience to have a user required to authenticate
    several times when accessing different parts of an application that might be using
    different services to complete a task. We need a central authority for token issuance
    and validation that all services can leverage. Essentially, we need to be able
    to use one token and validate a user across several services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 保护一个 API 足够简单，但当这种努力分散到多个 API 上时，例如在基于微服务的应用程序中，这会变得非常繁琐且难以管理。当用户在访问可能使用不同服务来完成任务的程序的不同部分时需要多次进行身份验证，这不是一个好的体验。我们需要一个中央权威机构来颁发和验证令牌，所有服务都可以利用它。本质上，我们需要能够使用一个令牌并在多个服务中验证用户。
- en: Considering this new challenge, we need to use an OAuth provider to secure our
    services centrally and handle our user information and validation. An OAuth provider
    application can take some time to configure and launch, so several companies offer
    OAuth services as SaaS applications. Several options exist to set up and host
    your OAuth provider instance, but this will require more maintenance and configuration
    efforts. The benefit of self-hosting is that you have more control over the system
    and the security measures you implement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这一新的挑战，我们需要使用 OAuth 提供商来集中保护我们的服务，并处理我们的用户信息和验证。OAuth 提供商应用程序的配置和启动可能需要一些时间，因此一些公司提供
    OAuth 服务作为 SaaS 应用程序。设置和托管您的 OAuth 提供商实例有几种选择，但这将需要更多的维护和配置工作。自托管的好处是您对系统和您实施的安保措施有更多的控制。
- en: Duende IdentityServer is the more famed self-hosted option for an OAuth provider.
    It is based on ASP.NET Core and leverages Identity Core capabilities to deliver
    industry-standard security measures. It is free for small organizations and can
    be deployed as a simple web service and the central security authority for our
    microservices. They do also have a hosted model and can be compared with other
    hosted options, such as Microsoft Azure AD, and Auth0, to name a few.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Duende IdentityServer 是 OAuth 提供商更著名的自托管选项。它基于 ASP.NET Core，并利用 Identity Core
    功能来提供行业标准的安全措施。对于小型组织是免费的，可以部署为一个简单的 Web 服务和我们的微服务的中央安全权威。他们也有托管模式，可以与其他托管选项进行比较，例如
    Microsoft Azure AD 和 Auth0 等。
- en: Now that we have explored securing our microservices, we need to figure out
    the best way to host them alongside their various dependencies. Do we use a team
    of web servers, or do more efficient options exist?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了保护我们的微服务，我们需要找出最佳方式来托管它们以及它们的各种依赖项。我们是使用一组 Web 服务器，还是存在更高效的选项？
- en: Containers and microservices
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和微服务
- en: We can typically host a web application or API and its supporting database on
    one server. This makes sense because everything is in one place and is easy to
    get to and maintain. But this server will also need to be very powerful and be
    outfitted to several applications and processes to support the different moving
    parts of the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以在一个服务器上托管一个Web应用程序或API及其支持数据库。这样做是有道理的，因为所有东西都在一个地方，易于访问和维护。但这个服务器也需要非常强大，并配备多个应用程序和进程来支持应用程序的不同部分。
- en: Therefore, we should consider splitting the host considerations and placing
    the API and the database on separate machines. This costs more, but we get to
    maintain or host better and ensure that we do not burden either the machine or
    the environment with applications that are not needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该考虑将托管考虑因素分开，并将API和数据库放置在不同的机器上。这会花费更多，但我们可以更好地维护或托管，并确保我们不会因为不需要的应用程序而给机器或环境带来负担。
- en: When dealing with microservices, we will run into a challenging situation when
    attempting to replicate these hosting considerations for several services. We
    want each microservice to be autonomous functionally and from a hosting standpoint.
    Our services should share as little infrastructure as possible, so we don’t want
    to risk placing more than one service on the same machine. We also don’t want
    to burden a single device with supporting several hosting environment requirements
    since each microservice might have different needs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理微服务时，在尝试为多个服务复制这些托管考虑因素时，我们会遇到一个具有挑战性的情况。我们希望每个微服务在功能和托管方面都是自治的。我们的服务应尽可能少地共享基础设施，因此我们不希望在一个机器上放置超过一个服务。我们也不希望让单个设备负担支持多个托管环境的要求，因为每个微服务可能都有不同的需求。
- en: We turn to container hosting as a lightweight alternative to provisioning several
    machines. Each container represents a slice of machine resources with optimized
    storage and performance resources needed for an application to run. Translating
    this concept into our hosting needs, we can create slices of these optimized environments
    for each microservice, database, and another third-party service as needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转向容器托管作为一种轻量级的替代方案，以配置多个机器。每个容器代表机器资源的一部分，具有为应用程序运行所需的优化存储和性能资源。将这个概念转化为我们的托管需求，我们可以为每个微服务、数据库和所需的第三方服务创建这些优化环境的切片。
- en: The advantage here is that we can still create optimal hosting environments
    for each service and supporting database, requiring far fewer machines to support
    this endeavor. Another benefit here is that each container is based on an image,
    representing the exact needs of the environment for the container. This image
    is reusable and repeatable, so we have less to worry about when transitioning
    between environments and trying to provision an environment per service. The image
    will always produce the same container, and there be no surprises during deployments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势是，我们仍然可以为每个服务及其支持数据库创建最佳托管环境，所需机器数量远少于支持这项工作。另一个好处是，每个容器都基于一个镜像，代表容器环境的精确需求。这个镜像是可以重复使用的，因此我们在环境转换和尝试为每个服务配置环境时，要担心的事情更少。这个镜像将始终产生相同的容器，并且在部署过程中不会有惊喜。
- en: Containers are widely used and supported in the development community. The premiere
    container hosting option is Docker, an industry-leading container technology provider.
    Docker provides an extensive repository of container images that we can leverage
    for safe and maintained images from popular third-party applications that we typically
    leverage during development. It is also an open community, so we can create containers
    for our own needs and add them to the community repository for later access, whether
    for public or private use.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在开发社区中得到广泛使用和支持。首选的容器托管选项是Docker，这是一家行业领先的容器技术提供商。Docker提供了一个广泛的容器镜像库，我们可以利用它来获取从流行的第三方应用程序中提取的安全和可维护的镜像，这些应用程序通常在开发过程中被使用。它也是一个开放的社区，因此我们可以为我们的需求创建容器，并将它们添加到社区存储库中，以便以后访问，无论是公共还是私人用途。
- en: When using .NET, we can generate a `Dockerfile`, a file containing declarations
    about the image that should be used to create a container for the service we wish
    to host. This `dockerfile`, written using a language called **Yet Another Markup
    Language** (**YAML**), outlines a base image, and then special build and deploy
    instructions. The base image states that we are borrowing information from an
    existing image and then we state that we wish to deploy our application to a container
    after combining the existing image and this application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 .NET 时，我们可以生成一个 `Dockerfile`，这是一个包含有关应使用以创建我们希望托管的服务容器的镜像声明的文件。这个 `dockerfile`
    使用一种名为 **Yet Another Markup Language** (**YAML**) 的语言编写，概述了一个基础镜像，然后是特殊的构建和部署指令。基础镜像声明我们从现有镜像中借用信息，然后我们声明希望在将现有镜像和此应用程序结合后，将我们的应用程序部署到容器中。
- en: When we use container hosting, we generate a `dockerfile` for each service,
    and we need to orchestrate the order in which they are started and their dependencies.
    For instance, we probably don’t want to start a service before its supporting
    database’s container starts. For this, we must use an orchestrator. Industry-leading
    options include `docker-compose` and Kubernetes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用容器托管时，为每个服务生成一个 `dockerfile`，我们需要编排它们启动的顺序及其依赖关系。例如，我们可能不希望在支持数据库的容器启动之前启动服务。为此，我们必须使用一个编排器。行业领先的选项包括
    `docker-compose` 和 Kubernetes。
- en: '`docker-compose` is a simple and easy-to-understand option for container orchestration
    operations. `docker-compose` will refer to each `dockerfile` and allow us to outline
    any unique parameters we wish to include when executing this `dockerfile`. We
    can also outline dependencies and provide specific configuration values for the
    execution of that `dockerfile` and the resulting container. Now, we can orchestrate
    the provisioning of the containers to support our web services, databases, and
    other applications with one command. We can even reuse dockerfiles to create more
    than one container and have several containers with the same service on a different
    port and possibly with different configurations. We can see where this can come
    in handy when implementing the backend for frontend pattern.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 是容器编排操作简单易懂的选项。`docker-compose` 将引用每个 `dockerfile`，并允许我们概述在执行此
    `dockerfile` 时希望包含的任何独特参数。我们还可以概述依赖关系，并为该 `dockerfile` 的执行和生成的容器提供特定的配置值。现在，我们可以使用一条命令编排容器的供应，以支持我们的网络服务、数据库和其他应用程序。我们甚至可以重用
    dockerfile 来创建多个容器，并在不同的端口上拥有具有相同服务但可能具有不同配置的多个容器。在实现前端模式的后端时，我们可以看到这在哪里非常有用。'
- en: Container hosting is platform-agnostic – we can leverage several hosting options,
    including cloud hosting options. Major cloud hosting providers such as Microsoft
    Azure and Amazon Web Services provide container hosting and orchestration support.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 容器托管是平台无关的 - 我们可以利用多种托管选项，包括云托管选项。主要云托管提供商，如微软 Azure 和亚马逊网络服务，提供容器托管和编排支持。
- en: Now that we have our hosting sorted out, we need to be able to track what is
    happening across the application. Each service should provide logs of its activities,
    and more importantly, we need to be able to trace the logs across the various
    services.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了托管问题，我们需要能够跟踪应用程序中发生的事情。每个服务都应该提供其活动的日志，更重要的是，我们需要能够跨各种服务追踪日志。
- en: Centralized logging
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中日志
- en: Logging is an essential part of post-deployment and maintenance operations.
    Once our application has been deployed, we need to be able to track and trace
    errors and bottlenecks in our application. This is easy enough to accomplish when
    we have one application and one logging source. We can always go to one space
    and retrieve the logs of what has happened.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是部署后和维护操作的重要组成部分。一旦我们的应用程序已经部署，我们需要能够跟踪和追踪应用程序中的错误和瓶颈。当我们只有一个应用程序和一个日志源时，这很容易实现。我们总是可以到一个地方检索已经发生的事情的日志。
- en: '.NET has native support for simple to advanced logging options. We can leverage
    the native logging operations and support powerful integrations for several logging
    destinations, such as the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 对简单到高级的日志选项提供原生支持。我们可以利用原生的日志操作，并支持与多个日志目标强大的集成，如下所示：
- en: '**Console**: Shows the log outputs in a native console window. Usually used
    during development.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**：在原生控制台窗口中显示日志输出。通常在开发期间使用。'
- en: '**Windows Event Log**: Also knowns as Event Viewer, this is a convenient way
    to view logs of several applications on a Windows-based machine.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 事件日志**：也称为事件查看器，这是在基于 Windows 的机器上查看多个应用程序日志的便捷方式。'
- en: '**Azure Log Stream**: Azure has a central logging service that supports logging
    for the application.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 日志流**：Azure 有一个中央日志服务，支持应用程序的日志记录。'
- en: '**Azure Application Insights**: A power log aggregation service provided by
    Microsoft Azure.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 应用洞察**：由 Microsoft Azure 提供的强大日志聚合服务。'
- en: When writing logs, we need to decide on the type of information we are logging.
    We want to avoid logging sensitive information such as compromising user or system
    information since we want to protect the integrity of our system and user secrets
    as much as possible. This will be relative to the context under which the application
    operates. Still, responsibility, wisdom, and maturity must be exercised during
    this scoping exercise. We also want to consider that we do not want to include
    too much clutter in the logs. Having chatty logs can be as bad as having no logs
    at all.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写日志时，我们需要决定我们要记录的信息类型。我们希望避免记录敏感信息，例如可能损害用户或系统信息的信息，因为我们希望尽可能保护我们系统的完整性和用户机密。这将与应用程序运行的环境相关。然而，在这个范围界定练习中，我们必须行使责任、智慧和成熟度。我们还希望考虑我们不想在日志中包含太多杂乱无章的内容。拥有冗长的日志可能和没有日志一样糟糕。
- en: 'We also want to ensure we choose the correct classification for each log message.
    We can log messages as being any of the following levels:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保为每条日志消息选择正确的分类。我们可以将日志消息记录为以下任何级别：
- en: '**Information**: General information about an operation.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：关于操作的通用信息。'
- en: '**Debug**: Usually used for development purposes. Should not be visible in
    a live environment.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：通常用于开发目的。不应在实时环境中可见。'
- en: '**Warning**: Depicts that something might not have gone as expected but is
    not a system error.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：表示某事可能没有按预期进行，但不是系统错误。'
- en: '**Error**: This occurs when an operation fails. They are usually used when
    an exception is caught and/or handled.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：当操作失败时发生。通常在捕获并/或处理异常时使用。'
- en: '**Critical/Fatal**: Used to highlight that an operation has failed and led
    to a system failure.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严重/致命**：用于突出显示操作失败并导致系统故障。'
- en: Choosing the correct classification for the log messages goes a long way in
    helping the operations team to monitor and track messages that need to be prioritized.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为日志消息选择正确的分类对于帮助操作团队监控和跟踪需要优先处理的消息大有裨益。
- en: We can also add unique configurations for each logging destination and fine-tune
    the types of messages each will receive. This ability becomes relevant if we only
    wish to log messages that are informational to the Windows event log and all warnings,
    errors, and critical messages should be visible in Azure Log Stream and Application
    Insights. .NET Core allows us to make these granular adjustments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为每个日志目标添加独特的配置，并微调每个目标将接收的消息类型。如果我们只想将信息性消息记录到 Windows 事件日志，并且所有警告、错误和严重消息都应该在
    Azure 日志流和应用洞察中可见，这种能力就变得相关了。.NET Core 允许我们进行这些细粒度的调整。
- en: We can further extend the capabilities of the native logging libraries by using
    extension packages such as `Serilog`. `Serilog` is the most popular logging extension
    library used in .NET applications. It supports more logging destinations such
    as rolling text files, databases (SQL Server, MySQL, PostgreSQL, and more), and
    cloud providers (Microsoft Azure, Amazon Web Services, and Google Cloud Platform),
    to name a few. We can write to multiple destinations with each log message by
    including this extension package in our application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用扩展包，如 `Serilog` 来进一步扩展原生日志库的功能。`Serilog` 是在 .NET 应用程序中使用最广泛的日志扩展库。它支持更多的日志目标，例如滚动文本文件、数据库（SQL
    Server、MySQL、PostgreSQL 等）和云提供商（Microsoft Azure、Amazon Web Services 和 Google Cloud
    Platform）等。我们可以通过在应用程序中包含此扩展包，将每个日志消息写入多个目标。
- en: Individual application logging can be set up relatively quickly, but this concept
    becomes complex when we attempt to correlate the logs. When a user has trouble
    accessing one feature, we need to check several possible points of failure, considering
    that our microservice application will trigger several actions across several
    services. We need an efficient way to collate the logs produced by each service
    and, by extension, be able to trace and relate calls associated with a single
    operation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 个人应用程序的日志记录可以相对快速地设置起来，但当尝试关联日志时，这个概念会变得复杂。当用户在访问某个功能时遇到困难，我们需要检查几个可能的问题点，考虑到我们的微服务应用程序将在多个服务中触发多个操作。我们需要一种有效的方法来汇总每个服务产生的日志，并且通过扩展，能够追踪和关联与单个操作相关的调用。
- en: Now, we turn to log aggregation platforms. Simply put, they act as log destinations
    and are designed to store all logs that are written to them. They also provide
    a user interface with advanced querying support. This is needed for a distributed
    application since we can now configure the aggregator as a central logging destination
    for several applications, and we can more easily query the logs to find logs that
    might be related but from different sources. We can also configure them to monitor
    and alert when logs of specific categorizations are received.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转向日志聚合平台。简单来说，它们充当日志目的地，旨在存储写入它们的所有日志。它们还提供了一个具有高级查询支持的用户界面。这对于分布式应用程序是必要的，因为我们现在可以将聚合器配置为多个应用程序的中心日志目的地，并且我们可以更容易地查询日志以找到可能相关但来自不同来源的日志。我们还可以配置它们在接收到特定分类的日志时进行监控和警报。
- en: Popular options for log aggregation include **Seq**, the **Elastisearch, Logstash,
    and Kibana** (**ELK**) stack, and hosted options such as **Azure Application Insights**
    and **DataDog**. Each platform has its strengths and weaknesses and can be leveraged
    for small to large applications. Seq is a popular option for small to medium-sized
    applications, and it has easy-to-use tools and supports robust querying operations.
    Still, aggregators have some limitations, and those come up when we need to properly
    trace logs from several sources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 日志聚合的流行选项包括**Seq**、**Elasticsearch、Logstash和Kibana**（**ELK**）堆栈，以及托管选项，如**Azure
    Application Insights**和**DataDog**。每个平台都有其优势和劣势，并且可以用于从小型到大型应用程序。Seq是小型到中型应用程序的流行选择，它具有易于使用的工具并支持强大的查询操作。然而，聚合器有一些限制，这些限制在我们需要正确跟踪来自多个来源的日志时会出现。
- en: Tracing logs from several sources is referred to as distributed logging. It
    involves us using common information in our log messages and tracing related tags
    and trace IDs to correlate logs to a single event. This requires us to write more
    enriched logs containing more details and headers that a log tracing tool can
    use and give us the best possible information about. An emerging technology to
    support this concept is **OpenTelemetry**, which will produce logs with greater
    detail and correlation from our various applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从多个来源跟踪日志被称为分布式日志。这涉及到我们在日志消息中使用常见信息，并跟踪相关的标签和跟踪ID，以将日志关联到单个事件。这要求我们编写包含更多详细信息和大头信息的丰富日志，以便日志跟踪工具可以使用并提供关于最佳可能信息的。支持这一概念的新兴技术是**OpenTelemetry**，它将从我们的各种应用程序中生成更详细和关联的日志。
- en: We can now use more specialized tools, such as **Jaeger**, to sift through the
    enriched logs and perform even more complex queries across the logs. Jaeger is
    a free, lightweight, and open source tool that can get us started with this concept,
    but we can once again use Microsoft Azure Insights for production workloads.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用更专业的工具，如**Jaeger**，来筛选丰富的日志并在日志之间执行更复杂的查询。Jaeger是一个免费、轻量级且开源的工具，可以帮助我们开始这个概念，但我们还可以再次使用Microsoft
    Azure Insights来处理生产工作负载。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the various moving parts of microservices and how
    we can leverage different development patterns to ensure that we deliver a stable
    and extendable solution. We saw where the microservices architecture has a problem
    for every solution it introduces, and we need to ensure that we are aware of all
    the caveats of each decision we make.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了微服务的各个组成部分以及我们如何利用不同的开发模式来确保我们交付一个稳定且可扩展的解决方案。我们看到了微服务架构在引入每个解决方案时都存在问题，我们需要确保我们了解我们做出的每个决定的全部潜在问题。
- en: Ultimately, we need to ensure that we properly assess and scope the needs of
    our application and refrain from introducing a microservices architecture where
    it might not be required. If we end up using one, we must ensure that we make
    the best use of the various technologies and techniques that support our application.
    Always seek to do the minimum necessary to address an issue before introducing
    complexity in the name of advanced architecture.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要确保我们正确评估和界定我们应用程序的需求，并避免在不必要的情况下引入微服务架构。如果我们最终使用了微服务架构，我们必须确保我们充分利用支持我们应用程序的各种技术和技巧。在以高级架构的名义引入复杂性之前，始终寻求采取最必要的措施来解决一个问题。
- en: I hope you enjoyed this journey and have enough information to inform the decision-making
    and development processes that will be involved when you start developing microservices
    with ASP.NET.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您喜欢这次旅程，并且有足够的信息来指导您在开始使用 ASP.NET 开发微服务时将涉及到的决策和开发过程。
