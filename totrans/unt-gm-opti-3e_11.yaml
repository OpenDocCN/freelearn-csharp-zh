- en: Masterful Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通内存管理
- en: Memory efficiency is an important element of performance optimization. It's
    possible for games of limited scope, such as hobby projects and prototypes, to
    get away with ignoring memory management. These games will tend to waste a lot
    of resources and potentially leak memory, but this won't be a problem if we limit
    its exposure to friends and coworkers. However, anything we want to release professionally
    needs to take this subject seriously. Unnecessary memory allocations lead to poor
    user experience due to excessive garbage collection (costing precious CPU time)
    and memory leaks, which will lead to crashes. None of these situations are acceptable
    in modern game releases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内存效率是性能优化的一个重要元素。对于范围有限的游戏，如爱好项目和原型，可以忽略内存管理。这些游戏可能会浪费大量资源，并可能发生内存泄漏，但如果仅限于朋友和同事之间，这不会成为问题。然而，任何我们想要专业发布的，都需要认真对待这个问题。不必要的内存分配会导致垃圾回收过多（消耗宝贵的CPU时间）和内存泄漏，这会导致崩溃。在现代游戏发布中，这些情况都是不可接受的。
- en: Using memory efficiently with Unity requires a solid understanding of the underlying
    Unity engine, the Mono platform, and the C# language. Also, if we're making use
    of the new IL2CPP scripting backend, then it would be wise to become familiar
    with its inner workings. This can be a bit of an intimidating place for some developers
    since many pick Unity3D for their game development solution primarily to avoid
    the kind of low-level work that comes from engine development and memory management.
    We'd prefer to focus on higher-level concerns related to gameplay implementation,
    level design, and art asset management, but, unfortunately, modern computer systems
    are complex tools, and ignoring low-level concerns for too long could potentially
    lead to disaster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity高效利用内存需要深入了解底层Unity引擎、Mono平台和C#语言。此外，如果我们正在使用新的IL2CPP脚本后端，那么熟悉其内部工作原理将是明智的。这对一些开发者来说可能有点令人畏惧，因为许多人选择Unity3D作为他们的游戏开发解决方案，主要是为了避免来自引擎开发和内存管理的底层工作。我们更愿意关注与游戏实现、关卡设计和艺术资源管理相关的更高层次的问题，但不幸的是，现代计算机系统是复杂的工具，长期忽视底层问题可能会导致灾难。
- en: 'Understanding what is happening with memory allocations and C# language features,
    how they interact with the Mono platform, and how Mono interacts with the underlying
    Unity engine are absolutely paramount to making high-quality, efficient script
    code. So, in this chapter, you will learn about all of the nuts and bolts of the
    underlying Unity engine: the Mono platform, the C# language, **Intermediate Language
    to C++** (**IL2CPP**), and the .NET Framework.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解内存分配和C#语言特性正在发生什么，它们如何与Mono平台交互，以及Mono如何与底层Unity引擎交互，对于编写高质量、高效的脚本代码至关重要。因此，在本章中，你将了解底层Unity引擎的所有细节：Mono平台、C#语言、**中间语言到C++（IL2CPP**）和.NET框架。
- en: 'Fortunately, it is not necessary to become absolute masters of the C# language
    to use it effectively. This chapter will boil these complex subjects down to a
    more digestible form and is split into the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，要有效地使用C#语言，并不需要成为绝对的语言大师。本章将把这些复杂主题简化为更易于理解的形式，并分为以下主题：
- en: 'Overview of the Mono platform:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono平台概述：
- en: Native and managed memory domains
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生和托管内存域
- en: Garbage collection
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Memory fragmentation
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存碎片化
- en: Building a project using IL2CPP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IL2CPP构建项目
- en: How to profile memory issues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何分析内存问题
- en: 'Implement various memory-related performance enhancements:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施各种与内存相关的性能提升：
- en: Minimizing garbage collection
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化垃圾回收
- en: Using value types and reference types properly
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用值类型和引用类型
- en: Using strings responsibly
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责任地使用字符串
- en: A multitude of potential enhancements related to the Unity engine
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Unity引擎相关的众多潜在提升
- en: Object and Prefab pooling
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和Prefab池化
- en: The Mono platform
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono平台
- en: Mono is a magical sauce mixed into the Unity recipe, which gives it a lot of
    its cross-platform capability. Mono is an open source project that built its own
    platform of libraries based on the API, specifications, and tools from Microsoft's
    .NET Framework. Essentially, it is an open source recreation of the .NET library,
    was accomplished with little-to-no access to the original source code, and is
    fully compatible with the original library from Microsoft.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 是一种神奇的风味酱，被混合到 Unity 的配方中，赋予了它许多跨平台的能力。Mono 是一个开源项目，它基于微软 .NET 框架的 API、规范和工具构建了自己的平台库。本质上，它是对
    .NET 库的开源重制，几乎无需访问原始源代码，并且与微软的原始库完全兼容。
- en: The goal of the Mono project is to provide cross-platform development through
    a framework that allows code written in a common programming language to run against
    many different hardware platforms, including Linux, macOS, Windows, ARM, PowerPC,
    and more. Mono even supports many different programming languages. Any language
    that can be compiled into .NET's **Common Intermediate Language** (**CIL**) is
    sufficient to integrate with the Mono platform. This includes C# itself, but also
    several other languages, such as F#, Java, Visual Basic .NET, pythonnet, and IronPython.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 项目的目标是提供一个框架，通过这个框架，用通用编程语言编写的代码可以在许多不同的硬件平台上运行，包括 Linux、macOS、Windows、ARM、PowerPC
    等。Mono 还支持许多不同的编程语言。任何可以编译成 .NET 的 **通用中间语言**（**CIL**）的语言都足以与 Mono 平台集成。这包括 C#
    本身，还包括 F#、Java、Visual Basic .NET、pythonnet 和 IronPython 等几种其他语言。
- en: A common misconception about the Unity engine is that it is built on top of
    the Mono platform. This is untrue, as its Mono-based layer does not handle many
    important game tasks such as audio, rendering, physics, and keeping track of time.
    Unity Technologies built a native C++ backend for the sake of speed and allowed
    its users control of this game engine through Mono as a scripting interface. As
    such, Mono is merely an ingredient of the underlying Unity engine. This is equivalent
    to many other game engines, which run C++ under the hood, handling important tasks
    such as rendering, animation, and resource management, while providing a higher-level
    scripting language for gameplay logic to be implemented. As such, the Mono platform
    was chosen by Unity Technologies to provide this feature.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Unity 引擎的一个常见误解是它建立在 Mono 平台之上。这是不正确的，因为基于 Mono 的层不处理许多重要的游戏任务，如音频、渲染、物理和跟踪时间。Unity
    Technologies 为了速度构建了一个本地的 C++ 后端，并允许用户通过 Mono 作为脚本接口来控制这个游戏引擎。因此，Mono 只是底层 Unity
    引擎的一个成分。这与许多其他游戏引擎类似，它们在底层运行 C++，处理渲染、动画和资源管理等重要任务，同时为游戏逻辑的实现提供高级脚本语言。因此，Unity
    Technologies 选择 Mono 平台来提供这一功能。
- en: Native code is a common vernacular for code that is written specifically for
    the given platform. For instance, writing code to create a window object or interface
    with networking subsystems in Windows would be completely different to code performing
    the tasks for a macOS, Unix, PlayStation 4, Xbox One, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本地代码是对专门为特定平台编写的代码的通俗说法。例如，在 Windows 中编写创建窗口对象或与网络子系统接口的代码，与为 macOS、Unix、PlayStation
    4、Xbox One 等执行任务的代码完全不同。
- en: Scripting languages typically abstract away complex memory management through
    automatic garbage collection and provide various safety features, which simplify
    the act of programming at the expense of runtime overhead. Some scripting languages
    can also be interpreted at runtime, meaning that they don't need to be compiled
    before execution. The raw instructions are converted dynamically into machine
    code and executed the moment they are read during runtime; of course, this often
    makes the code relatively slow. The last feature, and probably the most important
    one, is that they allow simpler syntax of programming commands. This usually improves
    development workflow immensely, as team members without much experience using
    languages such as C++ can still contribute to the code base. This enables them
    to implement things such as gameplay logic in a simpler format at the expense
    of a certain amount of control and runtime execution speed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言通常通过自动垃圾回收来抽象复杂的内存管理，并提供各种安全特性，从而简化编程过程，但这也带来了运行时的开销。一些脚本语言也可以在运行时进行解释，这意味着它们在执行前不需要编译。原始指令在运行时动态转换为机器代码，并在读取时立即执行；当然，这通常会使代码相对较慢。最后一个特性，也可能是最重要的特性，是它们允许编程命令具有更简单的语法。这通常极大地改善了开发工作流程，因为即使是没有太多使用C++等语言经验的团队成员也能为代码库做出贡献。这使他们能够在牺牲一定程度的控制和运行时执行速度的情况下，以更简单的格式实现游戏逻辑等功能。
- en: Note that such languages are often called **managed languages**, which feature
    **managed code**. Technically, this was a term coined by Microsoft to refer to
    any source code that must run inside their **Common Language Runtime** (**CLR**)
    environment, as opposed to code that is compiled and run natively through the
    target OS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这类语言通常被称为**管理语言**，它们具有**管理代码**的特点。技术上，这是一个由微软创造的术语，指的是必须在他们的**公共语言运行时**（**CLR**）环境中运行的任何源代码，与通过目标操作系统本地编译和运行的代码相对。
- en: However, because of the prevalence and common features that exist between the
    CLR and other languages that feature their own similarly designed runtime environments
    (such as Java), the term **managed** has since been hijacked. It tends to be used
    to refer to any language or code that depends on its own runtime environment,
    and that may or may not include automatic garbage collection. For the rest of
    this chapter, we will adopt this definition and use the term **managed** to refer
    to code that both depends on a separate runtime environment to execute and is
    being monitored by automatic garbage collection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于CLR与其他具有类似设计的运行时环境的语言（如Java）的普遍性和共同特性，术语**管理**已经被篡改。它通常用来指代任何依赖于其自身运行时环境，并且可能包含或不包含自动垃圾回收的语言或代码。在本章的其余部分，我们将采用这个定义，并使用术语**管理**来指代既依赖于单独的运行时环境来执行，又受到自动垃圾回收监控的代码。
- en: The runtime performance cost of managed languages is always greater than the
    equivalent native code, but it is becoming less significant every year. This is
    partly due to gradual optimizations in tools and runtime environments, and partly
    due to the computing power of the average device gradually becoming greater although
    the main point of controversy with using managed languages still remains their
    automatic memory management. Managing memory manually can be a complex task that
    can take many years of difficult debugging to be proficient at, but many developers
    feel that managed languages solve this problem in ways that are too unpredictable,
    risking too much product quality. Such developers might claim that managed code
    will never reach the same level of performance as native code, and hence it is
    foolhardy to build high-performance applications with them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 管理语言的运行时性能成本始终大于等效的本地代码，但每年都在逐渐降低。这部分是由于工具和运行时环境的逐步优化，部分是由于平均设备的计算能力逐渐增强。然而，使用管理语言的主要争议点仍然是它们的自动内存管理。手动管理内存可能是一项复杂的任务，可能需要多年的困难调试才能熟练掌握，但许多开发者认为，管理语言以过于不可预测的方式解决这个问题，风险太大，可能会影响产品质量。这样的开发者可能会声称，管理代码永远不会达到本地代码相同的性能水平，因此用它们构建高性能应用是鲁莽的。
- en: This is true to an extent, as managed languages invariably inflict runtime overheads,
    and we lose partial control over runtime memory allocations. This would be a deal-breaker
    for high-performance server architecture; however, for game development, it becomes
    a balancing act since not all resource usage will necessarily result in a bottleneck,
    and the best games aren't necessarily the ones that use every single byte to their
    fullest potential. For example, imagine a user interface that refreshes in 30
    ms via native code versus 60 µs in managed code due to an extra 100% overhead
    (an extreme example). The managed code version is still fast enough that the user
    will never be able to notice the difference, so is there really any harm in using
    managed code for such a task?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上这是正确的，因为受管理语言不可避免地会带来运行时开销，我们失去了对运行时内存分配的部分控制。这对于高性能服务器架构来说可能是一个致命的问题；然而，对于游戏开发来说，这变成了一种权衡，因为并非所有资源的使用都会必然导致瓶颈，而且最好的游戏也不一定是那些充分利用每个字节的潜在能力的游戏。例如，想象一个用户界面通过原生代码在
    30 毫秒内刷新，而通过受管理代码在 60 微秒内刷新，因为额外的 100% 开销（一个极端的例子）。受管理代码版本仍然足够快，以至于用户永远无法察觉到差异，那么使用受管理代码来完成这样的任务真的有伤害吗？
- en: In reality, at least for game development, working with managed languages often
    just means that developers have a unique set of concerns to worry about compared
    to native code developers. As such, the choice to use a managed language for game
    development is partly a matter of preference and partly a compromise of control
    versus development speed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，至少对于游戏开发来说，使用受管理语言通常意味着与原生代码开发者相比，开发者有一套独特的担忧需要关注。因此，选择使用受管理语言进行游戏开发部分是关于偏好，部分是关于控制与开发速度的妥协。
- en: 'Let''s revisit a topic we touched upon in earlier chapters but didn''t quite
    flesh out: the concept of memory domains in the Unity engine.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在前面的章节中提到但并未详细阐述的话题：Unity 引擎中内存域的概念。
- en: Memory domains
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存域
- en: 'Memory space within the Unity engine can be essentially split into three different
    memory domains. Each domain stores different types of data and takes care of a
    very different set of tasks. Let''s take a look at each of them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 引擎内的内存空间可以基本上分为三个不同的内存域。每个域存储不同类型的数据，并负责非常不同的任务。让我们逐一看看它们：
- en: The first memory domain—the managed domain—should be very familiar. This domain
    is where the Mono platform does its work, where any `MonoBehaviour` scripts and
    custom C# classes we write will be instantiated at runtime, and so we will interact
    with this domain very explicitly through any C# code we write. It is called the
    managed domain because this memory space is automatically managed by a **Garbage
    Collector** (**GC**).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个内存域——受管理域——应该非常熟悉。这个域是 Mono 平台工作的地方，我们编写的任何 `MonoBehaviour` 脚本和自定义 C# 类将在运行时实例化，因此我们将通过我们编写的任何
    C# 代码非常明确地与这个域交互。它被称为受管理域，因为这个内存空间是由 **垃圾回收器**（**GC**）自动管理的。
- en: The second domain—the native domain—is more subtle since we only interact with
    it indirectly. Unity has an underlying native code foundation, which is written
    in C++ and compiled into our application differently, depending on which platform
    is being targeted. This domain takes care of allocating internal memory space
    for things such as asset data (for example, textures, audio files, and meshes)
    and memory space for various subsystems such as the Rendering Pipeline, physics
    system, and user input system. Finally, it includes partial native representations
    of important gameplay objects such as GameObjects and components so that they
    can interact with these internal systems. This is where a lot of built-in Unity
    classes keep their data, such as the `transform` and `Rigidbody` components.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个域——原生域——更为微妙，因为我们只是间接地与之交互。Unity 有一个底层的原生代码基础，它用 C++ 编写，并根据目标平台的不同编译成我们的应用程序。这个域负责为诸如资产数据（例如，纹理、音频文件和网格）以及各种子系统（如渲染管线、物理系统和用户输入系统）分配内部内存空间。最后，它还包括重要的游戏玩法对象（如
    GameObject 和组件）的部分原生表示，以便它们可以与这些内部系统交互。这就是许多内置的 Unity 类存储数据的地方，例如 `transform`
    和 `Rigidbody` 组件。
- en: The third and final memory domains are those of external libraries, such as
    DirectX and OpenGL libraries, as well as any custom libraries and plugins we include
    in our project. Referencing these libraries from our C# code will cause a similar
    memory context switch and subsequent cost.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三和最后一个内存域是外部库，例如DirectX和OpenGL库，以及我们项目中所包含的任何自定义库和插件。从我们的C#代码中引用这些库将导致类似的内存上下文切换和后续成本。
- en: The managed domain also includes wrappers for the very same object representations
    that are stored within the native domain. As a result, when we interact with components
    such as `transform`, most instructions will ask Unity to dive into its native
    code, generate the result there, and then copy it back to the managed domain for
    us. This is where the native-managed bridge between the managed domain and native
    domains derives from, which was briefly mentioned in previous chapters. When both
    domains have their own representations for the same entity, crossing the bridge
    between them requires a memory context switch that can potentially inflict some
    fairly significant performance hits on our game. Obviously, crossing back and
    forth across this bridge should be minimized as much as possible due to the overhead
    involved. We covered several techniques for this in Chapter 2, *Scripting Strategies**.*
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 管理域还包括对存储在本地域中的相同对象表示的包装器。因此，当我们与如`transform`之类的组件交互时，大多数指令都会要求Unity深入到其本地代码中，在那里生成结果，然后将结果复制回管理域供我们使用。这就是本地-管理桥在管理域和本地域之间的由来，这在之前的章节中简要提到过。当两个域都有相同实体的自己的表示时，跨越它们之间的桥梁需要内存上下文切换，这可能会对我们的游戏造成相当大的性能影响。显然，由于涉及的开销，跨越这座桥梁的次数应该尽可能减少。我们在第二章“脚本策略”中介绍了几种处理这种问题的技术。
- en: Memory in most modern OS splits runtime memory space into two categories.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代操作系统中，内存运行时空间被分为两个类别。
- en: The stack
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'The stack is a special reserved space in memory, dedicated to small, short-lived
    data values, which are automatically deallocated the moment they go out of scope,
    hence why it is called the stack. It literally operates as a stack data structure,
    pushing and popping data from the top. Allocation to the stack complies with the
    following properties:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是内存中的一个特殊预留空间，用于存储小而短暂的数据值，这些数据值一旦超出作用域就会被自动释放，这就是为什么它被称为堆栈。它实际上就像一个堆栈数据结构，从顶部推入和弹出数据。堆栈的分配符合以下属性：
- en: The stack contains any local variables we declare and handles the loading and
    unloading of functions as they're called. These function calls to expand and contract
    through what is known as the call stack. When the call stack is done with the
    current function, it jumps back to the previous point on the call stack and continues
    from where it left off.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈包含我们声明的任何局部变量，并处理函数的加载和卸载，当函数被调用时。这些函数调用通过所谓的调用栈进行扩展和收缩。当调用栈完成当前函数的处理时，它会跳回到调用栈上的前一个点，并从那里继续执行。
- en: The start of the previous memory allocation is always known, and there's no
    reason to perform any clean-up operations since any new allocations can simply
    overwrite the old data. Hence, the stack is relatively quick and efficient.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一次内存分配的起始位置总是已知的，因此没有必要执行任何清理操作，因为任何新的分配都可以简单地覆盖旧数据。因此，堆栈相对快速且高效。
- en: The total stack size is usually very small, usually on the order of MB. It's
    possible to cause a stack overflow by allocating more space than the stack can
    support. This can occur during exceptionally large call stacks (for example, an
    infinite loop) or having a large number of local variables, but in most cases,
    causing a stack overflow is rarely a concern despite its relatively small size.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的堆栈大小通常非常小，通常在MB的数量级。如果分配的空间超过了堆栈所能支持的范围，就可能导致堆栈溢出。这种情况可能发生在异常大的调用栈（例如，无限循环）或拥有大量局部变量时，但在大多数情况下，尽管堆栈大小相对较小，但造成堆栈溢出通常不是一个大问题。
- en: The heap
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: The heap represents all remaining memory space, and it is used for the overwhelming
    majority of memory allocation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 堆代表所有剩余的内存空间，并且它被用于绝大多数的内存分配。
- en: Since we want most of the memory allocated to persist longer than the current
    function call, we couldn't allocate it on the stack since it would just get overwritten
    when the current function ends. So, instead, whenever a data type is too big to
    fit in the stack or must persist outside the function it was declared in, it is
    allocated on the heap.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们希望大部分分配的内存能够比当前函数调用持久，所以我们不能在栈上分配它，因为当当前函数结束时，它会被覆盖。因此，相反，每当一个数据类型太大而无法适应栈或者必须在声明它的函数外部持久时，它就会在堆上分配。
- en: There's nothing physically different between the stack and the heap; they're
    both just memory spaces containing bytes of data that exist in RAM, which have
    been requested and set aside for us by the OS. The only difference is in when,
    where, and how they are used.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和堆在物理上没有区别；它们都是包含在RAM中的字节数据内存空间，这是操作系统为我们请求并预留的。唯一的不同在于它们的使用时间、地点和方式。
- en: In native code, such as code written in languages such as C++, these memory
    allocations are handled manually in that we are responsible for ensuring that
    all pieces of memory we allocate are properly and explicitly deallocated when
    they are no longer needed. If this is not done properly, then we could easily
    and accidentally introduce memory leaks since we are likely to keep allocating
    more and more memory space from RAM that is never cleaned up until there is no
    more space to allocate and the application crashes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生代码中，例如用C++等语言编写的代码，这些内存分配是手动处理的，我们负责确保所有分配的内存在我们不再需要时都得到适当的和明确的释放。如果没有正确处理，我们很容易无意中引入内存泄漏，因为我们可能会不断地从RAM中分配更多的内存空间，而这些内存永远不会被清理，直到没有更多的空间可以分配，应用程序崩溃。
- en: Meanwhile, in managed languages, this process is automated through the GC. During
    the initialization of our Unity app, the Mono platform will request a given chunk
    of memory from the OS and use it to generate a heap memory space that our C# code
    can use (often known as the **managed heap**). This heap space starts off fairly
    small, less than 1 MB, but will grow as new blocks of memory are needed by our
    script code. This space can also shrink by releasing it back to the OS if Unity
    determines that it's no longer needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在托管语言中，这个过程通过GC（垃圾回收）自动化。在我们Unity应用的初始化过程中，Mono平台将从操作系统请求一块内存，并使用它来生成我们的C#代码可以使用的堆内存空间（通常称为**托管堆**）。这个堆空间最初相当小，小于1
    MB，但随着我们的脚本代码需要新的内存块时，它会增长。如果Unity确定它不再需要，这个空间也可以通过释放回操作系统来缩小。
- en: Garbage collection
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: The GC has an important job, which is to ensure that we don't use more managed
    heap memory than we need, and that memory that is no longer needed will be automatically
    deallocated. For instance, if we create `GameObject` and then later destroy it,
    the GC will flag the memory space used by `GameObject` for eventual deallocation
    later. This is not an immediate process, as the GC only deallocates memory when
    necessary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: GC有一个重要的任务，就是确保我们不会使用比我们需要的更多的托管堆内存，并且不再需要的内存会被自动释放。例如，如果我们创建`GameObject`然后后来销毁它，GC会标记`GameObject`使用的内存空间，以便稍后进行释放。这不是一个立即的过程，因为GC只有在必要时才会释放内存。
- en: When a new memory request is made, and there is enough empty space in the managed
    heap to satisfy the request, the GC simply allocates the new space and hands it
    over to the caller. However, if the managed heap does not have room for it, then
    the GC will need to scan all of the existing memory allocations for anything that
    is no longer being used and cleans them up first. It will only expand the current
    heap space as the last resort.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当发起一个新的内存请求，并且托管堆中有足够的空闲空间来满足请求时，GC简单地分配新的空间并将其交给调用者。然而，如果托管堆没有足够的空间，GC将需要扫描所有现有的内存分配，查找任何不再被使用的部分，并首先清理它们。它只有在最后手段的情况下才会扩展当前的堆空间。
- en: 'The GC in the version of Mono that Unity uses is a type of tracing GC, which
    uses a **Mark-and-Sweep** strategy. This algorithm works in two phases: each allocated
    object is tracked with an additional bit. This flags whether the object has been
    marked or not. These flags start set to `false` to indicate that it has not yet
    been marked.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用的Mono版本中的GC是一种跟踪GC，它使用**标记-清除**策略。这个算法分为两个阶段：每个分配的对象都通过一个额外的位来跟踪。这个位标记对象是否被标记。这些标志最初设置为`false`，表示它尚未被标记。
- en: When the collection process begins, it marks all objects that are still reachable
    to the program by setting their flags to `true`. Either the reachable object is
    a direct reference, such as static or local variables on the stack, or it is an
    indirect reference through the fields (member variables) of other directly or
    indirectly accessible objects. In essence, it is gathering a set of objects that
    are still referenceable to our application. Everything that is not still referenceable
    would be effectively invisible to our application and can be deallocated by the
    GC.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当收集过程开始时，它会通过将它们的标志设置为`true`来标记所有程序仍然可以到达的对象。这些可到达的对象可以是直接引用，例如堆栈上的静态或局部变量，或者是通过其他直接或间接可访问对象的字段（成员变量）进行间接引用。本质上，它是收集一组我们应用仍然可以引用的对象。所有不再可引用的东西将对我们应用来说实际上是不可见的，并且可以被GC回收。
- en: The second phase involves iterating through this catalog of references (which
    the GC will have kept track of throughout the lifetime of the application) and
    determining whether or not it should be deallocated based on its **marked** status.
    If the object is marked, then it is still being referenced by something else,
    and so the GC leaves it alone. However, if it is not marked, then it is a candidate
    for deallocation. During this phase, all marked objects are skipped over, but
    not before setting their flag back to `false` for the first phase of the next
    garbage collection scan.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段涉及遍历这个引用目录（GC将在整个应用生命周期中跟踪这个目录），并根据其**标记**状态确定是否应该释放。如果对象被标记，那么它仍然被其他东西引用，因此GC不会对其进行操作。然而，如果没有标记，那么它就是释放的候选对象。在这个阶段，所有标记的对象都会被跳过，但在下一轮垃圾收集扫描的第一阶段之前，会将其标志重新设置为`false`。
- en: In essence, the GC maintains a list of all objects in memory, while our application
    maintains a separate list containing only a portion of them. Whenever our application
    is done with an object, it simply forgets it exists, removing it from its list.
    Hence, the list of objects that can be safely deallocated would be the difference
    between the GC's list and our application's list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，GC维护内存中所有对象的列表，而我们的应用维护一个单独的列表，只包含其中的一部分。每当我们的应用完成一个对象时，它只是简单地忘记它的存在，将其从列表中删除。因此，可以安全释放的对象列表将是GC的列表和我们的应用列表之间的差异。
- en: Once the second phase ends, all unmarked objects are deallocated to free space,
    and then the initial request to create the object is revisited. If the GC has
    freed up enough space for the object, then it is allocated within that newly-freed
    space and returned to the caller. However, if it is not, then we hit the last-resort
    situation and must expand the managed heap by requesting it from the OS, at which
    point the object space can finally be allocated and returned to the caller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段结束后，所有未标记的对象都会被释放到空闲空间，然后重新访问创建对象的初始请求。如果GC已经为对象释放了足够的空间，那么它将在新释放的空间中分配，并返回给调用者。然而，如果没有足够的空间，那么我们将遇到最后的手段情况，必须通过从操作系统请求来扩展托管堆，此时对象空间最终可以被分配并返回给调用者。
- en: In an ideal world, where we only keep allocating and deallocating objects, but
    only a finite number of them exist at once, the heap would maintain a roughly
    constant size because there's always enough space to fit the new objects we need.
    However, all objects in an application are rarely deallocated in the same order
    they were allocated, and even more rarely do they all have the same size in memory.
    This leads to memory fragmentation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我们只分配和释放对象，但一次只存在有限数量的对象，堆将保持大致恒定的尺寸，因为总有足够的空间来容纳我们需要的新的对象。然而，一个应用中的所有对象很少按照它们分配的顺序被释放，而且它们在内存中的大小也很少相同。这导致了内存碎片。
- en: Memory fragmentation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存碎片
- en: Fragmentation occurs when objects of different sizes are allocated and deallocated
    in alternating orders and if lots of small objects are deallocated, following
    by lots of large objects being allocated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同大小的对象交替分配和释放，并且大量小对象被释放，随后大量大对象被分配时，就会发生碎片化。
- en: 'This is best explained through an example. The following shows four steps we
    take in allocating and deallocating memory in a typical heap memory space:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好通过一个例子来解释。以下展示了我们在典型堆内存空间中分配和释放内存的四个步骤：
- en: '![](img/573bbf10-163c-4ab8-a83e-aa2705b2387c.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/573bbf10-163c-4ab8-a83e-aa2705b2387c.png)'
- en: 'The memory allocation takes place as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配如下：
- en: We start with an empty heap space
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个空的堆空间开始
- en: We then allocate four objects on the heap, **A**, **B**, **C**, and **D**, each
    64-bytes in size
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在堆上分配了四个对象，**A**、**B**、**C** 和 **D**，每个对象大小为 64 字节
- en: At a later time, we deallocate two of the objects, **A** and **C**, freeing
    up 128-bytes
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在稍后的时间，我们释放了两个对象，**A** 和 **C**，释放了 128 字节
- en: We then try to allocate a new object that is 128-bytes in size
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们尝试分配一个大小为 128 字节的新的对象
- en: Deallocating objects **A** and **C** technically frees 128 bytes worth of space,
    but since the objects were not contiguous (adjoining neighbors) in memory, we
    cannot allocate an object larger than both individual spaces there. New memory
    allocations must always be contiguous in memory; therefore, the new object must
    be allocated in the next available contiguous 128-byte space available in the
    managed heap. We now have two empty 64-byte holes in our memory space, which will
    never be reused unless we allocate objects sized 64 bytes or smaller.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 释放对象 **A** 和 **C** 从技术上讲释放了 128 字节的空间，但由于这些对象在内存中不是连续的（相邻的邻居），我们无法分配比这两个单独空间都大的对象。新的内存分配必须始终在内存中连续；因此，新对象必须在托管堆中下一个可用的连续
    128 字节空间中分配。我们现在在内存空间中有两个 64 字节的空隙，除非我们分配大小为 64 字节或更小的对象，否则将永远不会被重用。
- en: Over long periods of time, our heap memory can become riddled with more, smaller
    empty spaces such as these as objects of different sizes are deallocated, and
    then the system later tries to allocate new objects within the smallest available
    space that it can fit within, leaving some small remainder that becomes harder
    to fill. In the absence of background techniques that automatically clean up this
    fragmentation, this effect would occur in literally any memory space—RAM, heap
    space, and even hard drives—which are just larger, slower, and more permanent
    memory storage areas (this is why it's a good idea to defragment our hard drives
    from time to time).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在长时间内，我们的堆内存可能会因为不同大小的对象释放后留下的更多、更小的空隙而变得布满空隙，然后系统稍后尝试在可以容纳新对象的最小可用空间内分配新对象，留下一些难以填充的小余量。如果没有自动清理这种碎片化的背景技术，这种效果会在任何内存空间中发生——RAM、堆空间，甚至硬盘——它们只是更大、更慢、更持久的内存存储区域（这就是为什么定期对硬盘进行碎片整理是个好主意）。
- en: 'Memory fragmentation causes two problems:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 内存碎片化导致两个问题：
- en: Firstly, it effectively reduces the total usable memory space for new objects
    over long periods of time, depending on the frequency of allocations and deallocations.
    This is likely to result in the GC having to expand the heap to make room for
    new allocations.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它有效地减少了长期内新对象的可用内存空间，这取决于分配和释放的频率。这可能导致垃圾回收器必须扩展堆以为新分配腾出空间。
- en: Secondly, it makes new allocations take longer to resolve due to the extra time
    it takes to find a new memory space large enough to fit the object.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它使得新的分配需要更长的时间来解决，因为找到足够大的新内存空间来容纳对象需要额外的时间。
- en: This becomes important when new memory allocations are made in a heap since
    the location of available space becomes just as important as how much free space
    is available. There is no way to split an object across partial memory locations,
    so the GC must either continue searching until it finds a large enough space or
    the entire heap size must be increased to fit the new object, costing even more
    time after it just spent a bunch of time doing an exhaustive search.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当在堆中创建新的内存分配时，这变得很重要，因为可用空间的位置变得与可用空间的大小一样重要。无法将对象分割到部分内存位置，因此垃圾回收器必须继续搜索，直到找到足够大的空间，或者整个堆大小必须增加以容纳新对象，这会在它花费大量时间进行彻底搜索之后，再次花费更多时间。
- en: Garbage collection at runtime
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时垃圾回收
- en: 'So, in a worst-case scenario, when a new memory allocation is being requested
    by our game, the CPU would have to spend cycles completing the following tasks
    before the allocation is finally completed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在最坏的情况下，当我们的游戏请求新的内存分配时，CPU 必须完成以下任务才能最终完成分配：
- en: Verify that there is enough contiguous space for the new object.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认有足够连续的空间用于新对象。
- en: If there is not enough space, iterate through all known direct and indirect
    references, marking everything they connect to as reachable
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果空间不足，遍历所有已知的直接和间接引用，标记它们连接的所有内容为可到达的
- en: Iterate through all of these references again, flagging unmarked objects for
    deallocation
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次遍历所有这些引用，标记未标记的对象以进行释放
- en: Iterate through all flagged objects to check whether deallocating some of them
    would create enough contiguous space for the new object
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有标记的对象，检查释放其中一些是否能为新对象创建足够的连续空间
- en: If not, request a new memory block from the OS to expand the heap
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，则从操作系统请求新的内存块以扩展堆空间
- en: Allocate the new object at the front of the newly allocated block and return
    it to the caller
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新分配的块的前端分配新对象，并将其返回给调用者
- en: This can be a lot of work for the CPU to handle, particularly if this new memory
    allocation is an important object such as a particle effect, a new character entering
    the scene, or a cutscene transition. Users are extremely likely to note moments
    where the GC is freezing gameplay to handle this extreme case. To make matters
    worse, the garbage collection workload scales poorly as the allocated heap space
    grows since sweeping through a few MBs of space will be significantly faster than
    scanning several GBs of space.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于CPU来说可能是一项繁重的工作，尤其是如果这种新的内存分配是一个重要的对象，如粒子效果、新角色进入场景或场景过渡。用户极有可能注意到GC在处理这种极端情况时冻结游戏时刻。更糟糕的是，随着分配的堆空间增长，垃圾回收的工作负载扩展得不好，因为扫描几个MB的空间将比扫描几个GB的空间快得多。
- en: All of this makes it absolutely critical to control our heap space intelligently.
    The lazier our memory usage tactics are, the worse the GC will behave in an almost
    exponential fashion, as we are more and more likely to hit this worst-case scenario.
    So, it's a little ironic that, despite the efforts of managed languages to make
    the memory management problem easier, managed language developers still find themselves
    being just as, if not more, concerned with memory consumption than developers
    of native applications. The main difference is in the types of problems they're
    trying to solve.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些使得智能控制堆空间变得绝对关键。我们的内存使用策略越懒惰，垃圾回收（GC）的行为就会以几乎指数级的速度变得更糟，因为我们越来越有可能遇到这种最坏的情况。因此，尽管管理语言试图使内存管理问题更容易解决，但管理语言的开发者仍然发现自己对内存消耗的关注程度与本地应用程序的开发者一样，如果不是更多的话。主要区别在于他们试图解决的问题类型。
- en: Threaded garbage collection
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程化垃圾回收
- en: 'The GC runs on two separate threads: the main thread and what is called the
    **finalizer thread**. When the GC is invoked, it will run on the main thread and
    flag heap memory blocks for future deallocation. This does not happen immediately.
    The finalizer thread, controlled by Mono, can have a delay of several seconds
    before the memory is finally freed and available for reallocation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GC在两个独立的线程上运行：主线程和所谓的**终结器线程**。当GC被调用时，它将在主线程上运行，并为未来的释放标记堆内存块。这不会立即发生。由Mono控制的终结器线程，在内存最终被释放并可用于重新分配之前，可能会有几秒钟的延迟：
- en: '![](img/94a86feb-5908-4874-ba02-0fb1c4c8da8b.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94a86feb-5908-4874-ba02-0fb1c4c8da8b.png)'
- en: We can observe this behavior in the Total Allocated block (the green line, with
    apologies to that 5% of the population with deuteranopia/deuteranomaly) of the
    Memory Area within the Profiler window. It can take several seconds for the total
    allocated value to drop after a garbage collection has occurred. Owing to this
    delay, we should not rely on memory being available the moment it has been deallocated,
    and as such, we should never waste time trying to eke out every last byte of memory
    that we believe should be available. We must ensure that there is always some
    kind of buffer zone available for future allocations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在分析器窗口中的内存区域（绿色线条，向那5%的色盲/色觉异常人群道歉）的“总分配”块中观察到这种行为。垃圾回收发生后，总分配值可能需要几秒钟才能下降。由于这种延迟，我们不应依赖于内存一旦被释放就立即可用，因此我们永远不应浪费时间试图挤出我们认为应该可用的每一字节内存。我们必须确保始终有一些类型的缓冲区可用于未来的分配。
- en: Blocks that have been freed by the GC may sometimes be given back to the OS
    after some time, which would reduce the reserved space consumed by the heap and
    allow the memory to be allocated for something else, such as another application.
    However, this is very unpredictable and depends on the platform being targeted,
    so we shouldn't rely on it. The only safe assumption to make is that as soon as
    the memory has been allocated to Mono, it's then reserved and is no longer available
    to either the native domain or any other application running on the same system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 被GC释放的块有时会在一段时间后归还给操作系统，这将减少堆占用的预留空间，并允许内存为其他事物分配，例如另一个应用程序。然而，这是非常不可预测的，并且取决于目标平台，所以我们不应该依赖它。唯一安全的假设是，一旦内存被分配给Mono，它就被预留，并且不再对本地域或同一系统上运行的任何其他应用程序可用。
- en: 'In the next section, we will look at another essential element of the development
    process: code compilation. During code compilation, the C# code will be transformed
    into real instructions executed by the CPU. Surprisingly, there are multiple ways
    of performing this conversion; let''s see how to choose among them.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨开发过程中的另一个基本元素：代码编译。在代码编译过程中，C#代码将被转换成CPU实际执行的指令。令人惊讶的是，有多种执行这种转换的方法；让我们看看如何在这之间进行选择。
- en: Code compilation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码编译
- en: When we make changes to our C# code, it is automatically compiled when we switch
    back from our favorite IDE (which is typically either MonoDevelop or the much
    more feature-rich Visual Studio) to the Unity Editor. However, the C# code is
    not converted directly into machine code, as we would expect static compilers
    to do if we are using languages such as C++.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修改我们的C#代码时，当我们从我们最喜欢的IDE（通常是MonoDevelop或功能更丰富的Visual Studio）切换回Unity编辑器时，它会被自动编译。然而，C#代码并不是直接转换成机器代码，正如我们预期的那样，如果我们使用像C++这样的语言，静态编译器会这样做。
- en: Instead, the code is converted into an intermediate stage called **Common Intermediate
    Language** (**CIL**), which is an abstraction above the native code. This is how
    .NET can support multiple languages—each uses a different compiler, but they're
    all converted into CIL, so the output is effectively the same regardless of the
    language that we pick. CIL is similar to Java bytecode, upon which it is based,
    and the CIL code is entirely useless on its own, as CPUs have no idea how to run
    the instructions defined in this language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，代码被转换成一个称为**通用中间语言**（**CIL**）的中间阶段，它是对本地代码的抽象。这就是.NET能够支持多种语言的原因——每种语言使用不同的编译器，但它们都被转换成CIL，所以输出的结果在语言选择上实际上是相同的。CIL类似于基于其之上的Java字节码，CIL代码本身是完全无用的，因为CPU不知道如何运行这种语言中定义的指令。
- en: At runtime, this intermediate code is run through the Mono **Virtual Machine**
    (**VM**), which is an infrastructure element that allows the same code to run
    against multiple platforms without the need to change the code itself. This is
    an implementation of the .NET CLR. If we're running on iOS, we run on the iOS-based
    VM infrastructure, and if we're running on Linux, then we simply use a different
    one that is better suited for Linux. This is how Unity allows us to write code
    once, and it works magically on multiple platforms.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，这种中间代码将通过Mono的**虚拟机**（**VM**）运行，这是一个基础设施元素，它允许相同的代码在多个平台上运行而无需更改代码本身。这是.NET
    CLR的一个实现。如果我们运行在iOS上，我们就运行在基于iOS的VM基础设施上；如果我们运行在Linux上，我们就简单地使用更适合Linux的一个。这就是Unity允许我们一次编写代码，并在多个平台上神奇地工作的原因。
- en: Within the CLR, the intermediate CIL code will actually be compiled into the
    native code on demand. This immediate native compilation can be accomplished either
    by an **Ahead-Of-Time** (**AOT**) or **Just-In-Time** (**JIT**) compiler. Which
    one is used will depend on the platform that is being targeted. These compilers
    allow code segments to be compiled into native code, allowing the platform's architecture
    to complete the written instructions without having to write them ourselves. The
    main difference between the two compiler types is when the code is compiled.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLR内部，中间的CIL代码实际上会在需要时编译成本地代码。这种即时本地编译可以通过**提前编译**（**AOT**）或**即时编译**（**JIT**）编译器来完成。使用哪种编译器将取决于目标平台。这些编译器允许代码段被编译成本地代码，使得平台的架构能够完成编写的指令，而无需我们亲自编写。这两种编译器类型的主要区别在于代码编译的时间。
- en: AOT compilation is the typical behavior for code compilation and happens early
    (AOT) either during the build process or in some cases during app initialization.
    In either case, the code has been precompiled, and no further runtime costs are
    inflicted due to dynamic compilation since there are always machine code instructions
    available whenever the CPU needs them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译是代码编译的典型行为，在构建过程中或在某些情况下在应用程序初始化期间早期（AOT）发生。在任何情况下，代码都已预编译，由于始终有机器代码指令可用，因此动态编译不会对运行时造成进一步的成本。
- en: JIT compilation happens dynamically at runtime in a separate thread and begins
    just before execution (JIT for execution). Often, this dynamic compilation causes
    the first invocation of a piece of code to run a little (or a lot) more slowly
    because the code must finish compiling before it can be executed. However, from
    that point forward, whenever the same code block is executed, there is no need
    for recompilation, and the instructions run through the previously compiled native
    code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译在运行时动态发生，在单独的线程中进行，并在执行前开始（JIT用于执行）。通常，这种动态编译会导致代码的第一次调用运行得稍微慢一些（或者很多），因为代码必须完成编译才能执行。然而，从那时起，每次执行相同的代码块时，就无需重新编译，指令将通过之前编译的本地代码运行。
- en: A common adage in software development is that 90% of the work is being done
    by only 10 percent of the code. This generally means that JIT compilation turns
    out to be a net positive on performance than if we simply tried to interpret the
    CIL code directly. However, because the JIT compiler must compile code quickly,
    it is not able to make use of many optimization techniques that static AOT compilers
    can exploit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中有一个常见的谚语，那就是90%的工作量只由10%的代码完成。这通常意味着即时编译（JIT）在性能上比直接尝试解释CIL代码要更有优势。然而，由于JIT编译器必须快速编译代码，它无法利用静态AOT编译器可以使用的许多优化技术。
- en: Not all platforms support JIT compilation, but some scripting functionalities
    are not available when using AOT. Unity provides a complete list of these restrictions
    at [https://docs.unity3d.com/Manual/ScriptingRestrictions.html](https://docs.unity3d.com/Manual/ScriptingRestrictions.html).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有平台都支持JIT编译，但在使用AOT时，某些脚本功能不可用。Unity在[https://docs.unity3d.com/Manual/ScriptingRestrictions.html](https://docs.unity3d.com/Manual/ScriptingRestrictions.html)提供了一个完整的限制列表。
- en: A few years ago, Unity Technologies was faced with a choice to either continue
    to support the Mono platform, which Unity was finding more and more difficult
    to keep up with, or implement their own scripting backend. They chose the latter
    option, and multiple platforms now support IL2CPP.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Unity Technologies面临着一个选择，要么继续支持Mono平台，而Unity发现越来越难以跟上这个平台的发展，要么实现自己的脚本后端。他们选择了后者，现在多个平台都支持IL2CPP。
- en: The Unity Technologies' initial post about IL2CPP, the reasoning behind the
    decision, and its long-term benefits can be found at [https://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/](https://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Technologies关于IL2CPP的初始帖子，包括决策背后的原因及其长期效益，可以在[https://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/](https://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/)找到。
- en: IL2CPP
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IL2CPP
- en: IL2CPP is a scripting backend designed to convert Mono's CIL output directly
    into the native C++ code. This leads to improved performance since the application
    will now be running native code. This ultimately gives Unity Technologies more
    control of runtime behavior since IL2CPP provides its own AOT compiler and VM,
    allowing custom improvements to subsystems such as the GC and compilation process.
    IL2CPP does not intend to replace the Mono platform completely, but it is an additional
    tool we can enable, which improves part of the functionality that Mono provides.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: IL2CPP是一个脚本后端，旨在将Mono的CIL输出直接转换为本地C++代码。这导致了性能的提升，因为应用程序现在将运行本地代码。这最终使Unity
    Technologies对运行时行为有了更多的控制，因为IL2CPP提供了自己的AOT编译器和VM，允许对GC和编译过程等子系统进行自定义改进。IL2CPP并不打算完全取代Mono平台，但它是一个我们可以启用的额外工具，它改进了Mono提供功能的一部分。
- en: 'Note that IL2CPP is automatically enabled for iOS and WebGL projects. For other
    platforms that support it, IL2CPP can be enabled under Edit | Project Settings
    | Player | Other Settings | Configure | Scripting Backend:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IL2CPP在iOS和WebGL项目中是自动启用的。对于支持它的其他平台，可以在“编辑”|“项目设置”|“播放器”|“其他设置”|“配置”|“脚本后端”下启用IL2CPP。
- en: '![](img/69ce6f1d-e1db-431b-9048-4cc06c0226c4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ce6f1d-e1db-431b-9048-4cc06c0226c4.png)'
- en: A list of platforms currently supporting IL2CPP can be found at [https://docs.unity3d.com/Manual/IL2CPP.html](https://docs.unity3d.com/Manual/IL2CPP.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持IL2CPP的平台列表可以在[https://docs.unity3d.com/Manual/IL2CPP.html](https://docs.unity3d.com/Manual/IL2CPP.html)找到。
- en: Profiling memory
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析内存
- en: 'There are two issues we are concerned about when it comes to memory management:
    how much we''re consuming and how often we''re allocating new blocks. Let''s cover
    each of these topics separately.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存管理方面，我们关注两个问题：我们消耗了多少以及我们多久分配一次新的内存块。让我们分别讨论这些话题。
- en: Profiling memory consumption
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析内存消耗
- en: We do not have direct control over what is going on in the native domain since
    we don't have the Unity engine source code and hence can't add any code that will
    interact with it directly. We can, however, control it indirectly using various
    script-level functions that serve as interaction points between managed and native
    code. There are technically a variety of memory allocators available, which are
    used internally for things such as GameObjects, graphics objects, and the Profiler,
    but these are hidden behind the native-managed bridge.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有Unity引擎的源代码，因此无法直接控制本地域中的操作，我们无法直接添加任何与之交互的代码。然而，我们可以通过各种脚本级函数间接控制它，这些函数作为托管代码和本地代码之间的交互点。实际上，有各种内存分配器可用，它们在内部用于诸如GameObject、图形对象和Profiler等事物，但这些都被隐藏在本地-托管桥接器后面。
- en: 'However, we can observe how much memory has been allocated and reserved in
    this memory domain via the Memory Area of the Profiler window. Native memory allocations
    show up under the values labeled Unity, and we can even get more information using
    Detailed mode and sampling the current frame:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过Profiler窗口的内存区域观察到在这个内存域中分配和保留了多少内存。本地内存分配显示在标记为Unity的值下，我们甚至可以使用详细模式和采样当前帧来获取更多信息：
- en: '![](img/30b8e292-906d-40d6-a003-a90237837821.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30b8e292-906d-40d6-a003-a90237837821.png)'
- en: Under the Scene Memory section of breakdown view, we can observe that `MonoBehaviour`
    objects always consume a constant amount of memory, regardless of their member
    data. This is the memory consumed by the native representation of the object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在分解视图的“场景内存”部分，我们可以观察到`MonoBehaviour`对象总是消耗固定数量的内存，无论它们的成员数据如何。这是对象本地表示消耗的内存。
- en: Note that memory consumption in Edit mode is always wildly different from that
    of a standalone version due to various debugging and editor hook data being applied.
    This adds a further incentive to avoid using Edit mode for benchmarking and instrumentation
    purposes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于各种调试和编辑器钩子数据的应用，编辑模式下的内存消耗总是与独立版本大相径庭。这进一步增加了避免使用编辑模式进行基准测试和仪器测量的动机。
- en: We can also use the `Profiler.GetRuntimeMemorySize()` method to get the native
    memory allocation size of a particular object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Profiler.GetRuntimeMemorySize()`方法来获取特定对象的本地内存分配大小。
- en: Managed object representations are intrinsically linked to their native representations.
    The best way to minimize our native memory allocations is to simply optimize our
    managed memory usage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象表示与它们的本地表示内在相关联。最小化我们的本地内存分配的最佳方式是简单地优化我们的托管内存使用。
- en: 'We can verify how much memory has been allocated and reserved for the managed
    heap using the Memory Area of the Profiler window, under the values labeled Mono,
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Profiler窗口的内存区域，在标记为Mono的值下验证为托管堆分配和保留了多少内存，如下所示：
- en: '![](img/c2540c86-793d-47ab-9656-a3ea1a558ff2.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2540c86-793d-47ab-9656-a3ea1a558ff2.png)'
- en: We can also determine the current used and reserved heap space at runtime using
    the `Profiler.GetMonoUsedSize()` and `Profiler.GetMonoHeapSize()` methods, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`Profiler.GetMonoUsedSize()`和`Profiler.GetMonoHeapSize()`方法分别在运行时确定当前使用的和保留的堆空间。
- en: Profiling memory efficiency
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析内存效率
- en: The best metric we can use to measure the health of our memory management is
    simply watching the behavior of the GC. The more work it's doing, the more waste
    we're generating and the worse our application's performance is likely to become.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来衡量我们内存管理健康状况的最佳指标是简单地观察GC的行为。它做的工作越多，我们产生的浪费就越多，我们的应用程序的性能可能就越差。
- en: We can use both the CPU Usage Area (the GarbageCollector checkbox) and Memory
    Area (the GC Allocated checkbox) of the Profiler window to observe the amount
    of work the GC is doing and the time it is taking to do it. This can be relatively
    straightforward for some situations, where we only allocated a temporary small
    block of memory or we just destroyed a `GameObject` instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Profiler窗口的CPU使用区域（垃圾回收器复选框）和内存区域（GC分配复选框）来观察GC正在执行的工作量以及它所花费的时间。在某些情况下，这可能是相对直接的，比如我们只分配了一小块临时内存，或者我们刚刚销毁了一个`GameObject`实例。
- en: However, root-cause analysis for memory efficiency problems can be challenging
    and time-consuming. When we observe a spike in the GC's behavior, it could be
    a symptom of allocating too much memory in a previous frame and merely allocating
    a little more in the current frame, requiring the GC to scan a lot of fragmented
    memory, determine whether there is enough space, and decide whether to allocate
    a new block. The memory it cleaned up could have been allocated a long time ago,
    and we may only be able to observe these effects when our application runs over
    long periods of time and could even happen when our scene is sitting relatively
    idle, giving no obvious cause for the GC to trigger suddenly. Even worse, the
    Profiler can only tell us what happened in the last few seconds or so, and it
    won't be immediately obvious what data was being cleaned up.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对内存效率问题的根本原因分析可能具有挑战性和耗时。当我们观察到GC行为的峰值时，这可能意味着在前一帧分配了过多的内存，而在当前帧仅仅分配了更多一些，需要GC扫描大量碎片化的内存，确定是否有足够的空间，并决定是否分配一个新的块。它清理的内存可能是在很久以前分配的，我们可能只能在应用程序长时间运行时观察到这些效果，甚至可能在我们场景相对空闲时发生，这时GC突然触发没有明显的触发原因。更糟糕的是，Profiler只能告诉我们过去几秒钟内发生了什么，而且清理了哪些数据可能不会立即明显。
- en: We must be vigilant and test our application rigorously, observing its memory
    behavior while simulating a typical play session if we want to be certain we are
    not generating memory leaks or creating a situation where the GC has too much
    work to complete in a single frame.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须保持警惕并对我们的应用程序进行严格的测试，在模拟典型游戏会话的同时观察其内存行为，以确保我们没有产生内存泄漏或创建一个GC（垃圾回收器）在一个帧内需要完成太多工作的情况。
- en: Memory management performance enhancements
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理性能提升
- en: In most game engines, we would have the luxury of being able to port inefficient
    managed code into faster native code if we were hitting performance issues. This
    is not an option unless we invest serious cash in obtaining the Unity source code,
    which is offered as a license separate from the Free/Personal/Pro licensing system,
    and on a per case, per-title basis. We could also purchase a license of Unity
    Pro with the hope of using native plugins, but doing so rarely leads to a performance
    benefit since we must still cross the native-managed bridge to invoke function
    calls inside of it. Native plugins are normally used to interface with systems
    and libraries that are not built specifically for C#. This forces the overwhelming
    majority of us into a position of needing to make our C# script-level code as
    performant as possible ourselves.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏引擎中，如果我们遇到性能问题，我们可以将低效的托管代码移植到更快的本地代码中。除非我们投入大量资金获取Unity源代码，这作为一项单独的许可证提供，并且基于每个案例、每个标题，否则这不是一个选项。我们也可以购买Unity
    Pro许可证，希望使用本地插件，但这样做很少能带来性能提升，因为我们仍然必须跨越本地-托管桥来调用其中的函数调用。本地插件通常用于与为C#构建的系统库接口。这迫使绝大多数人需要自己尽可能使C#脚本级代码高效。
- en: With this in mind, we should now have enough understanding of Unity engine internals
    and memory spaces to detect and analyze memory performance issues and understand
    and implement enhancements for them. So, let's cover some performance enhancements
    we can apply.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在应该对Unity引擎内部和内存空间有足够的了解，以便检测和分析内存性能问题，并理解和实现对其的改进。因此，让我们来看看我们可以应用的一些性能提升方法。
- en: Garbage collection tactics
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收策略
- en: One strategy to minimize garbage collection problems is concealment by manually
    invoking the GC at opportune moments when we're certain the player would not notice.
    Garbage collection can be manually invoked by calling `System.GC.Collect()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 减少垃圾回收问题的一种策略是在玩家不会注意到的合适时机手动调用GC。可以通过调用`System.GC.Collect()`来手动调用垃圾回收。
- en: Good opportunities to invoke a collection may occur while loading between levels,
    when the gameplay is paused, shortly after a menu interface has been opened, during
    cutscene transitions, or any break in gameplay when the player would not witness,
    or care about, a sudden performance drop. We could even use the `Profiler.GetMonoUsedSize()`
    and `Profiler.GetMonoHeapSize()` methods at runtime to determine whether a garbage
    collection needs to be invoked soon.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载不同层级之间、游戏暂停时、菜单界面刚打开后、场景切换过程中，或者在玩家不会看到或不在乎性能突然下降的任何游戏中断时，都可能有机会调用垃圾回收。我们甚至可以在运行时使用`Profiler.GetMonoUsedSize()`和`Profiler.GetMonoHeapSize()`方法来确定是否需要很快地调用垃圾回收。
- en: We can also cause the deallocation of a handful of specific objects. If the
    object in question is one of the Unity object wrappers, such as a `GameObject`
    or `MonoBehaviour` component, then the finalizer will first invoke the `Dispose()`
    method within the native domain. At this point, the memory consumed by both the
    native and managed domains will then be freed. In some rare instances, if the
    Mono wrapper implements the `IDisposable` interface class (that is, it has a `Dispose()`
    method available from script code), then we can actually control this behavior
    and force the memory to be freed instantly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以释放一些特定对象。如果问题对象是Unity对象包装器之一，例如`GameObject`或`MonoBehaviour`组件，那么终结器将首先在本地域中调用`Dispose()`方法。此时，本地域和管理域消耗的内存将被释放。在某些罕见情况下，如果Mono包装器实现了`IDisposable`接口类（即，从脚本代码中可用`Dispose()`方法），那么我们实际上可以控制这种行为并强制立即释放内存。
- en: 'There are a number of different object types in the Unity engine (most of which
    are introduced in Unity 5 or later), which implement the `IDisposable` interface
    class, as follows: `NetworkConnection`, `WWW`, `UnityWebRequest`, `UploadHandler`,
    `DownloadHandler`, `VertexHelper`, `CullingGroup`, `PhotoCapture`, `VideoCapture`,
    `PhraseRecognizer`, `GestureRecognizer`, `DictationRecognizer`, `SurfaceObserver`,
    and more.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Unity引擎中有许多不同的对象类型（其中大多数是在Unity 5或更高版本中引入的），它们实现了`IDisposable`接口类，如下所示：`NetworkConnection`、`WWW`、`UnityWebRequest`、`UploadHandler`、`DownloadHandler`、`VertexHelper`、`CullingGroup`、`PhotoCapture`、`VideoCapture`、`PhraseRecognizer`、`GestureRecognizer`、`DictationRecognizer`、`SurfaceObserver`等。
- en: These are all utility classes for pulling in potentially large datasets where
    we might want to ensure immediate destruction of the data it has acquired since
    they normally involve allocating several buffers and memory blocks in the native
    domain to accomplish their tasks. If we kept all of this memory for a long time,
    it would be a colossal waste of precious space. So, by calling their `Dispose()`
    method from script code, we can ensure that the memory buffers are freed promptly
    and precisely when they need to be.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是用于拉取可能非常大的数据集的实用类，我们可能希望确保立即销毁它所获取的数据，因为它们通常涉及在本地域中分配几个缓冲区和内存块以完成任务。如果我们长时间保留所有这些内存，那将是一种巨大的空间浪费。因此，通过从脚本代码中调用它们的`Dispose()`方法，我们可以确保内存缓冲区能够及时且精确地被释放。
- en: All other asset objects offer some kind of unloading method to clean up any
    unused asset data, such as `Resources.UnloadUnusedAssets()`. Actual asset data
    is stored within the native domain, so the GC technically isn't involved here,
    but the idea is basically the same. It will iterate through all assets of a particular
    type, check whether they're no longer being referenced, and, if so, deallocate
    them. However, again, this is an asynchronous process, and we cannot guarantee
    exactly when the deallocation will occur. This method is automatically called
    internally after a scene is loaded, but this still doesn't guarantee instant deallocation.
    The preferred approach is to use `Resources.UnloadAsset()` instead, which will
    unload one specific asset at a time. This method is generally faster since time
    will not be spent iterating through an entire collection of asset data to figure
    out what is unused.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他资产对象都提供某种卸载方法来清理任何未使用的资产数据，例如`Resources.UnloadUnusedAssets()`。实际的资产数据存储在本地域中，因此GC实际上并不涉及这里，但基本思想是相同的。它将遍历特定类型的所有资产，检查它们是否不再被引用，如果是，则释放它们。然而，这同样是一个异步过程，我们无法保证确切的释放时间。此方法在场景加载后自动内部调用，但这仍然不能保证立即释放。首选的方法是使用`Resources.UnloadAsset()`，它将一次卸载一个特定的资产。这种方法通常更快，因为不会花费时间遍历整个资产数据集合来确定哪些是未使用的。
- en: However, the best strategy for garbage collection will always be avoidance;
    if we allocate as little heap memory and control its usage as much as possible,
    then we won't have to worry about the GC inflicting frequent, expensive performance
    costs. We will cover many tactics for this throughout the remainder of this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最佳的垃圾回收策略始终是避免；如果我们尽可能少地分配堆内存并尽可能多地控制其使用，那么我们就无需担心GC造成频繁且昂贵的性能成本。我们将在本章的剩余部分介绍许多此类策略。
- en: Manual JIT compilation
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动JIT编译
- en: If JIT compilation is causing a runtime performance loss, be aware that it is
    actually possible to force JIT compilation of a method at any time via reflection.
    Reflection is a useful feature of the C# language that allows our code base to
    explore itself introspectively for type information, methods, values, and metadata.
    Using reflection is often a very costly process. It should be avoided at runtime
    or, at the very least, only used during initialization or other loading times.
    Not doing so can easily cause significant CPU spikes and gameplay freezing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JIT编译导致运行时性能损失，请注意，实际上可以通过反射强制在任何时候对方法进行JIT编译。反射是C#语言的一个有用特性，它允许我们的代码库以自省的方式探索自身以获取类型信息、方法、值和元数据。使用反射通常是一个代价很高的过程。它应该在运行时避免使用，或者至少仅在初始化或其他加载时间使用。不这样做很容易导致显著的CPU峰值和游戏冻结。
- en: 'We can manually force JIT compilation of a method using reflection to obtain
    a function pointer to it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用反射手动强制对方法进行JIT编译以获取其函数指针：
- en: '[PRE0]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code only works on `public` methods. Obtaining `private` or `protected`
    methods can be accomplished through the use of `BindingFlags`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅适用于`public`方法。获取`private`或`protected`方法可以通过使用`BindingFlags`实现：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This kind of code should only be run for very targeted methods where we are
    certain that JIT compilation is causing CPU spikes. This can be verified by restarting
    the application and profiling a method's first invocation versus all subsequent
    invocations. The difference will tell us the JIT compilation overhead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码仅应在非常具体的方法上运行，其中我们确信JIT编译导致了CPU峰值。这可以通过重新启动应用程序并分析方法的第一次调用与所有后续调用之间的差异来验证。差异将告诉我们JIT编译的开销。
- en: Note that the official method for forcing JIT compilation in the .NET library
    is `RuntimeHelpers.PrepareMethod()`, but this is not properly implemented in the
    current default version of Mono that comes with Unity (Mono version 2.6.5). Since
    Unity 2018.1, the .NET 4.x runtime is no longer considered experimental; however,
    it is not supported on all platforms, and it is still not the suggested one. The
    aforementioned workaround is not pretty, but it is still the best and most consistent
    way to proceed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，强制在.NET库中进行JIT编译的官方方法是`RuntimeHelpers.PrepareMethod()`，但在Unity当前默认版本的Mono（Mono版本2.6.5）中并未正确实现。自Unity
    2018.1以来，.NET 4.x运行时不再被视为实验性；然而，它并不支持所有平台，并且仍然不是建议使用的版本。上述解决方案并不完美，但它仍然是最佳且最一致的方法。
- en: Value types and reference types
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型和引用类型
- en: Not all memory allocations we make within Mono will go through the heap. The
    .NET Framework (and, by extension, the C# language, which merely implements the
    .NET specification) has the concept of value types and reference types, and only
    the latter needs to be marked by the GC while it is performing its Mark-and-Sweep
    algorithm. Reference types are expected to (or need to) last a long time in memory
    due to their complexity, their size, or how they're used. Large datasets and any
    kind of object instantiated from a `class` instance is a reference type. This
    also includes arrays (regardless of whether it is an array of Value types or reference
    types), delegates, all classes, such as `MonoBehaviour`, `GameObject`, and any
    custom classes we define.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mono中，我们进行的所有内存分配并不都会通过堆。.NET Framework（以及通过扩展，C#语言，它仅仅实现了.NET规范）有值类型和引用类型的概念，并且只有后者在GC执行其标记-清除算法时需要被标记。由于它们的复杂性、大小或使用方式，引用类型通常（或需要）在内存中持续很长时间。大型数据集以及从`class`实例实例化的任何类型的对象都是引用类型。这还包括数组（无论它是一个值类型数组还是引用类型数组）、委托、所有类，例如`MonoBehaviour`、`GameObject`以及我们定义的任何自定义类。
- en: Reference types are always allocated on the heap, whereas value types can be
    allocated either on the stack or the heap. Primitive data types such as `bool`,
    `int`, and `float` are examples of value types. These values are typically allocated
    on the stack, but as soon as a value type is contained within a reference type,
    such as `class` or an array, then it is implied that it is either too large for
    the stack or will need to survive longer than the current scope and must be allocated
    on the heap, bundled with the reference type it is contained within.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型始终在堆上分配，而值类型可以在栈或堆上分配。例如，`bool`、`int` 和 `float` 这样的原始数据类型是值类型的例子。这些值通常在栈上分配，但一旦值类型被包含在引用类型中，例如
    `class` 或数组，那么就隐含着它要么太大不适合栈，要么需要比当前作用域存活得更久，因此必须分配在堆上，与它所包含的引用类型一起。
- en: 'All of this can be best explained through examples. The following code will
    create an integer as a value type that exists on the stack only temporarily:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过示例最好地解释。以下代码将创建一个作为值类型的整数，它仅在栈上临时存在：
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As soon as the `TestFunction()` method ends, the integer is deallocated from
    the stack. This is essentially a free operation since, as mentioned previously,
    it doesn't bother doing any cleanup; it just moves the stack pointer back to the
    previous memory location in the call stack (back to whichever function called
    `TestFunction()` on the `TestComponent` object). Any future stack allocations
    simply overwrite the old data. More importantly, no heap allocation took place
    to create the data, so the GC does not need to track its existence.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `TestFunction()` 方法结束，整数将从栈上释放。这本质上是一个免费操作，因为，如前所述，它不需要进行任何清理；它只是将栈指针移回到调用栈中的上一个内存位置（回到调用
    `TestFunction()` 的 `TestComponent` 对象的函数）。任何未来的栈分配都会简单地覆盖旧数据。更重要的是，没有进行堆分配来创建数据，因此垃圾收集器不需要跟踪其存在。
- en: 'However, if we created an integer as a member variable of the `MonoBehaviour`
    class definition, then it is now contained within a reference type (`class`) and
    must be allocated on the heap along with its container:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把整数作为 `MonoBehaviour` 类定义的成员变量创建，那么它现在包含在一个引用类型（`class`）中，并且必须与它的容器一起在堆上分配：
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_data` integer is now an additional piece of data that consumes space in
    the heap alongside the `TestComponent` object it is contained within. If `TestComponent`
    is destroyed, then the integer is deallocated along with it, but not before then.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`_data` 整数现在是一块额外的数据，它占据了与它所包含的 `TestComponent` 对象一起在堆上的空间。如果 `TestComponent`
    被销毁，那么整数也会随之被释放，但在此之前不会。'
- en: 'Similarly, if we put the integer into a normal C# class, then the rules for
    reference types still apply and the object is allocated on the heap:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们把整数放入一个普通的 C# 类中，那么引用类型的规则仍然适用，对象将在堆上分配：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, there is a big difference between creating a temporary value type within
    a `class` method versus storing long-term value type as a member field of `class`.
    In the former case, we''re storing it in the stack, but in the latter case, we''re
    storing it within a reference type, which means it can be referenced elsewhere.
    For example, imagine that `DoSomething()` has stored the reference to `dataObj`
    within a member variable:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `class` 方法中创建临时值类型与将长期值类型作为 `class` 的成员字段存储之间有很大的区别。在前一种情况下，我们将其存储在栈上，但在后一种情况下，我们将其存储在引用类型中，这意味着它可以在其他地方被引用。例如，想象一下
    `DoSomething()` 在一个成员变量中存储了 `dataObj` 的引用：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, we would not be able to deallocate the object pointed to `dataObj`
    as soon as the `TestFunction()` method ends because the total number of things
    referencing the object would go from `2` to `1`. This is not `0`, and hence the
    GC would still mark it during Mark-and-Sweep. We would need to set the value of
    `_testDataObj` to `null` or make it reference something else before the object
    is no longer reachable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们无法在 `TestFunction()` 方法结束时立即释放指向 `dataObj` 的对象，因为引用该对象的总数将从 `2` 变为
    `1`。这不是 `0`，因此垃圾收集器仍然会在标记-清除过程中标记它。在对象不再可达之前，我们需要将 `_testDataObj` 的值设置为 `null`
    或使其引用其他东西。
- en: 'Note that a value type must have a value and can never be `null`. If a stack-allocated
    value type is assigned to a reference type, then the data is simply copied. This
    is true even for arrays of value types:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值类型必须有一个值，并且永远不能为 `null`。如果栈分配的值类型被赋值给引用类型，那么数据就会被简单地复制。即使对于值类型的数组也是如此：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the initial array is created (during object initialization), `1000` integers
    will be allocated on the heap set to a value of `0`. When the `StoreANumber()`
    method is called, the value of `num` is merely copied into the zeroth element
    of the array rather than storing a reference to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始数组创建时（在对象初始化期间），将在堆上分配`1000`个整数，并设置为`0`的值。当调用`StoreANumber()`方法时，`num`的值仅仅是复制到数组的零元素，而不是存储对其的引用。
- en: The subtle change in the referencing capability is what ultimately decides whether
    something is a reference type or a value type, and we should try to use value
    types whenever we have the opportunity so that they generate stack allocations
    instead of heap allocations. Any situation where we're just sending around a piece
    of data that doesn't need to live longer than the current scope is a good opportunity
    to use a value type instead of a reference type. Ostensibly, it does not matter
    if we pass the data into another method of the same class or a method of another
    class—it still remains a value type that will exist on the stack until the method
    that created it goes out of the scope.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 引用能力的微妙变化最终决定了某物是引用类型还是值类型，我们应该尽可能使用值类型，以便它们生成栈分配而不是堆分配。任何我们只是发送不需要比当前作用域存活更长时间的数据的情况，都是使用值类型而不是引用类型的好机会。表面上，无论我们将数据传递给同一类的另一个方法还是另一个类的方法，这都没有关系——它仍然是一个将存在于栈上直到创建它的方法超出作用域的值类型。
- en: Pass by value and by reference
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值传递和引用传递
- en: Technically, something is duplicated every time a data value is passed as an
    argument from one method to another, and this is true whether it is a value type
    or a reference type. When we're passing the object's data, this is known as **passing
    by value**. When we're simply copying a reference to something else, it is called
    **passing by reference**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，每次将数据值作为参数从一个方法传递到另一个方法时，都会进行复制，这无论是值类型还是引用类型都适用。当我们传递对象的数据时，这被称为**值传递**。当我们只是复制对其他事物的引用时，这被称为**引用传递**。
- en: An important difference between value types and reference types is that a reference
    type is merely a pointer to another location in memory that consumes only 4 or
    8-bytes in memory (32 bit or 64 bit, depending on the architecture), regardless
    of what it is actually pointing to. When a reference type is passed as an argument,
    it is only the value of this pointer that gets copied into the function. Even
    if the reference type points to a humongous array of data, this operation will
    be very quick since the data being copied is very small.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的重要区别是，引用类型仅仅是内存中另一个位置的指针，它只占用4或8个字节（32位或64位，取决于架构），无论它实际上指向什么。当引用类型作为参数传递时，只有这个指针的值被复制到函数中。即使引用类型指向一个巨大的数据数组，这个操作也会非常快，因为被复制的数据非常小。
- en: Meanwhile, a value type contains the full and complete bits of data stored within
    a concrete object. Hence, all of the data of a value type will be copied whenever
    they are passed between methods or stored in other value types. In some cases,
    it can mean that passing a large value type as arguments around too much can be
    more costly than just using a reference type and letting the GC take care of it.
    For most value types, this is not a problem since they are comparable in size
    to a pointer, but this becomes important when we begin to talk about the `struct`
    type in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，值类型包含存储在具体对象内的完整和完整的数据位。因此，值类型的数据在它们在方法之间传递或存储在其他值类型时都会被复制。在某些情况下，这意味着传递一个大的值类型作为参数可能比仅仅使用引用类型并让GC处理它更昂贵。对于大多数值类型来说，这并不是问题，因为它们的大小与指针相当，但当我们开始讨论下一节中的`struct`类型时，这一点变得很重要。
- en: Data can also be passed around by reference using the `ref` keyword, but this
    is very different from the concept of value and reference types, and it is very
    important to keep them distinct in our mind when we try to understand what is
    going on under the hood. We can pass a value type by value or by reference, and
    we can pass a reference type by value or by reference. This means that there are
    four distinct data passing situations that can occur, depending on which type
    is being passed and whether the `ref` keyword is being used or not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也可以通过 `ref` 关键字以引用方式传递，但这与值类型和引用类型的概念非常不同，在我们试图理解底层发生的事情时，非常重要的一点是要在脑海中区分它们。我们可以通过值或引用传递值类型，也可以通过值或引用传递引用类型。这意味着根据传递的类型以及是否使用
    `ref` 关键字，可能会出现四种不同的数据传递情况。
- en: 'When data is passed by reference (even if it is a value type), then making
    any changes to the data will change the original. For example, the following code
    would print the value as `10`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过引用传递（即使它是值类型）时，对数据的任何更改都会改变原始数据。例如，以下代码将打印出值 `10`：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Removing the `ref` keyword from both places would make it print the value `5`
    instead (and removing it from only one of them would lead to a compiler error
    since the `ref` keyword needs to be present in both locations or neither). This
    understanding will come in handy when we start to think about some of the more
    interesting data types we have access to, namely, structs, arrays, and strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个地方都移除 `ref` 关键字将使其打印出值 `5`（并且只从其中一个移除会导致编译器错误，因为 `ref` 关键字需要同时出现在两个位置或都不出现）。这种理解将在我们开始思考一些更有趣的数据类型时派上用场，即结构体、数组和字符串。
- en: Structs are value types
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体是值类型
- en: 'The `struct` type is an interesting special case in C#. A `struct` object can
    contain `private`, `protected`, and `public` fields; have methods; and be instantiated
    at runtime, just like a `class` type. However, there is a fundamental difference
    between the two: a `struct` type is a value type, and a `class` type is a reference
    type. Consequently, this leads to some important differences between the two,
    namely, that a `struct` type cannot support inheritance, their properties cannot
    be given custom default values (member data always defaults to values such as
    `0` or `null` since it is a value type), and their default constructors cannot
    be overridden. This greatly restricts their usage compared to classes, so simply
    replacing all classes with structs (under the assumption that it will just allocate
    everything on the stack) is not as easy as it sounds.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 类型在 C# 中是一个有趣的特殊情况。结构体对象可以包含 `private`、`protected` 和 `public` 字段；有方法；并且可以在运行时实例化，就像
    `class` 类型一样。然而，两者之间有一个根本的区别：结构体类型是值类型，而 `class` 类型是引用类型。因此，这导致两者之间的一些重要差异，即结构体类型不支持继承，它们的属性不能赋予自定义默认值（成员数据始终默认为
    `0` 或 `null`，因为它是一个值类型），并且它们的默认构造函数不能被重写。这大大限制了它们的用途，与类相比，所以简单地将所有类替换为结构体（假设它只是将所有内容分配到栈上）并不像听起来那么简单。'
- en: 'However, if we''re using a class in a situation whose only purpose is to send
    a blob of data to somewhere else in our application, and it does not need to last
    beyond the current scope, then we might be able to use a `struct` type instead,
    since a `class` type would result in a heap allocation for no particularly good
    reason:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在一个仅用于将数据块发送到应用程序中其他地方的情况中使用类，并且它不需要超出当前作用域，那么我们可能能够使用 `struct` 类型，因为
    `class` 类型会导致堆分配，而没有任何特别好的理由：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we're using a `class` type to pass a bunch of data from one
    subsystem (the combat system) to another (the UI system). The only purpose of
    this data is to be calculated and read by various subsystems, so this is a good
    candidate to convert into a `struct` type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `class` 类型从一个子系统（战斗系统）传递大量数据到另一个子系统（UI系统）。这些数据的唯一目的是被各个子系统计算和读取，因此将其转换为
    `struct` 类型是一个很好的候选方案。
- en: 'Merely changing the `DamageResult` definition from a `class` type to a `struct`
    type could save us quite a few unnecessary garbage collections since it would
    be allocated on the stack as a value type instead of the heap as a reference type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 仅将 `DamageResult` 定义从 `class` 类型更改为 `struct` 类型，就可以节省我们很多不必要的垃圾回收，因为它将作为值类型在栈上分配，而不是作为引用类型在堆上分配：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is not a catch-all solution. Since structs are value types, the entire
    blob of data will be duplicated and provided to the next method in the call stack,
    regardless of how large or small it is. So, if a `struct` object is passed by
    a value between five different methods in a long chain, then five different stack
    copies will occur at the same time. Recall that stack deallocations are effectively
    free, but stack allocations (which involve copying of data) is not. This data
    copying is pretty much negligible for small values, such as a handful of integers
    or floating-point values, but passing around ridiculously large datasets through
    structs over and over again is obviously not a trivial task and should be avoided.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个万能的解决方案。由于结构体是值类型，整个数据块将被复制并传递给调用堆栈中的下一个方法，无论它的大小如何。因此，如果`struct`对象在长链中的五个不同方法之间通过值传递，那么将同时发生五个不同的栈复制。回想一下，栈的释放是免费的，但栈的分配（涉及数据复制）不是。对于小值，如少量整数或浮点值，这种数据复制几乎可以忽略不计，但反复通过结构体传递大量数据集显然不是一项微不足道的工作，应该避免。
- en: We can work around this problem by passing the `struct` object by reference
    using the `ref` keyword to minimize the amount of data being copied each time
    (just a single pointer). However, this can be dangerous since passing by reference
    allows any subsequent methods to make changes to the `struct` object, in which
    case it would be prudent to make its data values `readonly`. This means that the
    values can only be initialized in the constructor, and never again, even by its
    own member functions, which prevents accidental changes as it's passed through
    the chain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`ref`关键字通过引用传递`struct`对象来解决这个问题，以最小化每次复制的数据量（仅一个指针）。然而，这可能是危险的，因为通过引用传递允许任何后续方法对`struct`对象进行更改，在这种情况下，明智的做法是将其数据值设置为`readonly`。这意味着值只能在构造函数中初始化，并且永远不会再被初始化，即使是它的成员函数也不行，这可以防止在传递链中意外更改。
- en: 'All of the preceding is also true when structs are contained within reference
    types, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构体包含在引用类型中时，上述所有内容也是正确的，如下所示：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To the untrained eye, the preceding code appears to be attempting to store a
    stack-allocated struct (`ds`) within a reference type (`StructHolder`). Does this
    mean that a `StructHolder` object on the heap can now reference an object on the
    stack? If so, what will happen when the `StoreStruct()` method goes out of scope
    and the `struct` object is (effectively) erased? It turns out that these are the
    wrong questions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未经训练的眼睛来说，前面的代码看起来像是在尝试将一个栈分配的结构体（`ds`）存储在一个引用类型（`StructHolder`）中。这意味着堆上的`StructHolder`对象现在可以引用栈上的对象吗？如果是这样，当`StoreStruct()`方法超出作用域并且`struct`对象（实际上）被删除时会发生什么？事实证明，这些问题都是错误的。
- en: What's actually happening is that while a `DataStruct` object (`_memberStruct`)
    has been allocated on the heap within the `StructHolder` object, it is still a
    value type and does not magically transform into a reference type when it is a
    member variable of a reference type. So, all of the usual rules for value types
    apply. The `_memberStruct` variable cannot have a value of `null`, and all of
    its fields will be initialized to `0` or `null` values. When `StoreStruct()` is
    called, the data from `ds` will be copied into `_memberStruct` in its entirety.
    There are no references to stack objects taking place, and there is no concern
    about lost data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是，尽管`DataStruct`对象（`_memberStruct`）已经在`StructHolder`对象中分配在堆上，但它仍然是一个值类型，并且当它是引用类型的成员变量时，并不会神奇地变成引用类型。因此，适用于值类型的所有常规规则都适用。`_memberStruct`变量不能有`null`值，并且它的所有字段都将初始化为`0`或`null`值。当调用`StoreStruct()`时，`ds`中的数据将完整地复制到`_memberStruct`中。没有对栈对象的引用发生，也没有丢失数据的问题。
- en: Arrays are reference types
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组是引用类型
- en: The purpose of arrays is to contain large datasets, which makes them difficult
    to be treated as a value type since there's probably not enough room on the stack
    to support them. Therefore, they are treated as a reference type so that the entire
    dataset can be passed around via a single reference (if it were a value type,
    we would need to duplicate the entire array every time it is passed around). This
    is true irrespective of whether the array contains value types or reference types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的目的在于包含大量数据集，这使得它们难以被视为值类型，因为堆栈上可能没有足够的空间来支持它们。因此，它们被视为引用类型，以便可以通过单个引用传递整个数据集（如果它是值类型，每次传递时都需要复制整个数组）。这与数组包含值类型或引用类型无关。
- en: 'This means that the following code will result in a heap allocation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下代码将导致堆分配：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, the following, functionally equivalent, code would not result in any
    heap allocations since the `struct` objects being used are value types, and hence,
    it would be created on the stack:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下功能等效的代码不会导致任何堆分配，因为所使用的`struct`对象是值类型，因此它将在栈上创建：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The subtle difference in the second example is that only one `TestStruct` exists
    on the stack at a time, whereas the first example needs to allocate `1000` of
    them via an array. Obviously, these methods are kind of ridiculous as they're
    written, but they illustrate an important point to consider. The compiler isn't
    smart enough to automatically find these situations for us and make the appropriate
    changes. Opportunities to optimize our memory usage through value type replacements
    will be entirely down to our ability to detect them and understand why conversions
    from reference types to value types will result in stack allocations, rather than
    heap allocations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例中的微妙差异在于，一次只有一个`TestStruct`存在于栈上，而第一个示例需要通过数组分配`1000`个。显然，这些方法按现在的写法有点荒谬，但它们说明了需要考虑的一个重要观点。编译器并不足够智能，能够自动为我们找到这些情况并做出相应的更改。通过值类型替换优化内存使用的机遇将完全取决于我们检测它们和理解为什么从引用类型到值类型的转换会导致栈分配，而不是堆分配。
- en: Note that when we allocate an array of reference types, we're creating an array
    of references, which can provide each reference other locations on the heap. However,
    when we allocate an array of value types, we're creating a packed list of value
    types on the heap. Each of these value types will be initialized with a value
    of `0` (or equivalent) since they cannot be `null`, while each reference within
    an array of reference types will always initialize to `null` since no references
    have been assigned yet.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们分配引用类型数组时，我们正在创建一个引用数组，它可以提供堆上的其他位置给每个引用。然而，当我们分配值类型数组时，我们正在堆上创建一个值类型的紧凑列表。由于这些值类型不能为`null`，因此每个值类型都将初始化为`0`（或等效值），而引用类型数组中的每个引用将始终初始化为`null`，因为尚未分配任何引用。
- en: Strings are immutable reference types
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串是不可变引用类型
- en: We briefly touched upon the subject of strings in Chapter 2, *Scripting Strategies*,
    but now it's time to go into more detail about why proper string usage is extremely
    important.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章“脚本策略”中简要提到了字符串的主题，但现在我们需要更详细地探讨为什么正确使用字符串非常重要。
- en: Strings are essentially arrays of characters, and so they are considered reference
    types and follow all of the same rules as other reference types; they will be
    allocated on the heap, and a pointer is all that is copied from one method to
    the next. Since a string is effectively an array, this implies that the characters
    it contains must be contiguous in memory. However, we often find ourselves expanding,
    contracting, or combining strings to create other strings. This can lead us to
    make some faulty assumptions about how strings work. We might assume that because
    strings are such common, ubiquitous objects, performing operations on them is
    fast and cheap. Unfortunately, this is incorrect. Strings are not made to be fast.
    They are only made to be convenient.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串本质上是由字符组成的数组，因此它们被认为是引用类型，并遵循所有其他引用类型的相同规则；它们将在堆上分配，并且从一种方法复制到另一种方法时，只需复制一个指针。由于字符串实际上是一个数组，这意味着它包含的字符在内存中必须是连续的。然而，我们经常发现自己需要扩展、收缩或组合字符串以创建其他字符串。这可能导致我们对字符串的工作方式产生一些错误的假设。我们可能会假设，由于字符串如此常见且无处不在，对它们进行操作既快又便宜。不幸的是，这是不正确的。字符串并不是为了快速而设计的。它们只是为了方便。
- en: The string object class is immutable, which means they cannot be changed after
    they've been allocated. Therefore, when we change a string, we are actually allocating
    a whole new string on the heap to replace it, where the contents of the original
    will be copied and modified as needed into a whole new character array, and the
    original string object reference now points to a completely new string object.
    In which case, the old string object might no longer be referenced anywhere, will
    not be marked during *Mark-and-Sweep*, and will eventually be purged by the GC.
    As a result, lazy string programming can result in a lot of unnecessary heap allocations
    and garbage collection.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象类是不可变的，这意味着它们在分配后不能被更改。因此，当我们更改字符串时，我们实际上是在堆上分配了一个全新的字符串来替换它，其中原始字符串的内容将被复制并按需修改到一个全新的字符数组中，而原始字符串对象引用现在指向一个全新的字符串对象。在这种情况下，旧的字符串对象可能不再被任何地方引用，不会在*标记-清除*过程中被标记，最终会被GC清除。因此，懒惰的字符串编程可能导致大量的不必要的堆分配和垃圾回收。
- en: 'A good example to illustrate how strings are different than normal reference
    types is the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个很好的例子，说明了字符串与普通引用类型的不同：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we were under the mistaken assumption that strings worked just like other
    reference types, then we might be forgiven for assuming that the log output of
    the following to be `World!`. It appears as though `testString`, a reference type,
    is being passed into `DoSomething()`, which would change what `testString` is
    referencing to, in which case, the `Log` statement will print out the new value
    of the string.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们错误地认为字符串的工作方式与其他引用类型一样，那么我们可能会被原谅，认为下面的日志输出是`World!`。看起来`testString`，一个引用类型，被传递到`DoSomething()`中，这将改变`testString`所引用的内容，在这种情况下，`Log`语句将打印出字符串的新值。
- en: However, this is not the case, and it will simply print out `Hello`. What is
    actually happening is that the `localString` variable, within the scope of `DoSomething()`,
    starts off referencing the same place in memory as `testString` due to the reference
    being passed by value. This gives us two references pointing to the same location
    in memory as we would expect if we were dealing with any other reference type.
    So far, so good.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非如此，它只会打印出`Hello`。实际上发生的情况是，在`DoSomething()`的作用域内，`localString`变量一开始引用内存中的同一位置，就像我们处理任何其他引用类型时预期的那样，因为引用是通过值传递的。这给了我们两个指向内存中同一位置的引用，正如我们预期的那样。到目前为止，一切顺利。
- en: However, as soon as we change the value of `localString`, we run into a little
    bit of a conflict. Strings are immutable, and we cannot change them, so, therefore,
    we must allocate a new string containing the `World!` value and assign its reference
    to the value of `localString`; now, the number of references to the `Hello` string
    returns back to one. The value of `testString`, therefore, has not been changed,
    and that is still the value that will be printed by `Debug.Log()`. All we've succeeded
    in doing by calling `DoSomething()` is creating a new string on the heap that
    gets garbage-collected and doesn't change anything. This is the textbook definition
    of wasteful.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们更改`localString`的值，我们就会遇到一点冲突。字符串是不可变的，我们不能更改它们，因此，我们必须分配一个新的包含`World!`值的字符串，并将它的引用分配给`localString`的值；现在，对`Hello`字符串的引用数量又回到了一个。因此，`testString`的值并没有改变，这仍然是`Debug.Log()`将要打印的值。通过调用`DoSomething()`，我们成功做到的只是创建了一个新的字符串在堆上，它会被垃圾回收，但并没有改变任何东西。这就是教科书上对浪费的定义。
- en: If we change the method definition of `DoSomething()` to pass the string by
    reference via the `ref` keyword, the output would indeed change to `World!`. Of
    course, this is also what we would expect to happen with a value type, which leads
    a lot of developers to incorrectly assume that strings are value types. However,
    this is an example of the fourth and final data-passing case, where a reference
    type is being passed by reference, which allows us to change what the original
    reference is referencing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`DoSomething()`的方法定义更改为通过`ref`关键字按引用传递字符串，输出确实会变为`World!`。当然，这也是我们对值类型的预期，这也导致许多开发者错误地假设字符串是值类型。然而，这是一个第四个也是最后一种数据传递情况的例子，其中引用类型是通过引用传递的，这允许我们改变原始引用所引用的内容。
- en: 'So, let''s recap:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们回顾一下：
- en: If we pass a value type by value, we can only change the value of a copy of
    its data
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们按值传递一个值类型，我们只能改变其数据副本的值
- en: If we pass a value type by reference, we can change the value of the original
    data passed in
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们通过引用传递一个值类型，我们可以改变原始传入数据的值
- en: If we pass a reference type by value, we can make changes to the object referenced
    by the original reference variable
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们通过值传递一个引用类型，我们可以修改原始引用变量所引用的对象
- en: If we pass a reference type by reference, we can change to which object the
    original reference is pointing to
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们通过引用传递一个引用类型，我们可以改变原始引用所指向的对象
- en: If we find functions that seem to generate a lot of GC allocations the moment
    they are called, then we might be causing undue heap allocations due to a misunderstanding
    of the preceding rules.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现某些函数在被调用时似乎会生成大量的垃圾回收（GC）分配，那么我们可能是因为对先前规则的理解错误而导致了不必要的堆分配。
- en: String concatenation
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Concatenation is the act of appending strings to one another to form a larger
    string. As you've learned, any such cases are likely to result in excess heap
    allocations. The biggest offender in a string-based memory waste is concatenating
    strings using the `+` operator and `+=` operators, because of the allocation chaining
    effect they cause.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是将字符串附加到另一个字符串上以形成更大的字符串的行为。正如你所学的，任何此类情况都可能导致额外的堆分配。在基于字符串的内存浪费中，最大的罪魁祸首是使用
    `+` 运算符和 `+=` 运算符连接字符串，因为它们引起的分配链效应。
- en: 'For example, the following code tries to combine a group of string objects
    together to print some information about a combat result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码尝试将一组字符串对象组合起来，以打印关于战斗结果的一些信息：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An example output of this function might be a string that reads as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的一个示例输出可能是一个如下所示的字符串：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function features a handful of string literals (hardcoded strings that
    are allocated during application initialization) such as `" dealt "`, `" damage
    to "`, and `" blocked)"`, which are simple constructs for the compiler to pre-allocate
    for us. However, because we are using other local variables within this combined
    string, it cannot be compiled away at build time, and, therefore, the complete
    string is regenerated dynamically at runtime each time the function is called.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包含一些字符串字面量（在应用程序初始化期间分配的硬编码字符串），例如 `" dealt "`, `" damage to "`, 和 `" blocked)"`，这些是编译器可以为我们预先分配的简单结构。然而，因为我们在这个组合字符串中使用了其他局部变量，所以它不能在构建时编译掉，因此每次函数被调用时，完整的字符串都会在运行时动态重新生成。
- en: A new heap allocation will be generated each time a `+` or `+=` operator is
    executed. Only a single pair of strings will be merged at a time, and it allocates
    a new string object each time. Then, the result of one merger will be fed into
    the next and merged with the next string and so on until the final string object
    has been built.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行 `+` 或 `+=` 运算符时，都会生成一个新的堆分配。一次只会合并一对字符串，并且每次都会分配一个新的字符串对象。然后，合并的结果将被输入到下一个合并中，并与下一个字符串合并，依此类推，直到构建出最终的字符串对象。
- en: 'So, the previous example will result in nine different strings being allocated
    all in one statement. All of the following strings would be allocated to satisfy
    this instruction, and all would eventually need to be garbage collected (note
    that the operators are resolved from right to left):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的示例将导致在一个语句中分配九个不同的字符串。所有以下字符串都将被分配以满足这个指令，并且最终都需要进行垃圾回收（注意运算符是从右到左解析的）：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's 262 characters being used, instead of 49\. In addition, because a character
    is a 2-byte data type (for Unicode strings), that's 524 bytes of data being allocated
    when we only need 98 bytes. The chances are that if this code exists in the code
    base once, it exists all over the place; so, for an application that's doing a
    lot of lazy string concatenation like this, that is a ton of memory being wasted
    on generating unnecessary strings.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就使用了262个字符，而不是49个。此外，因为字符是一个2字节的 数据类型（对于Unicode字符串），所以当我们只需要98个字节时，就会分配524个字节数据。很可能如果这段代码在代码库中存在一次，它就会到处存在；因此，对于一个进行大量类似这种惰性字符串连接的应用程序来说，这会导致大量的内存浪费在生成不必要的字符串上。
- en: Note that big, constant string literals can be safely combined using the `+`
    and `+=` operators. The compiler knows that you will eventually need the full
    string and pre-generates the string automatically. This helps us to make a huge
    block of text more readable within the code base, but only if they will result
    in a constant string.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大型的、常量的字符串字面量可以使用 `+` 和 `+=` 运算符安全地组合。编译器知道你最终需要完整的字符串，并会自动预先生成字符串。这有助于我们在代码库中使大量文本更易于阅读，但前提是它们将产生一个常量字符串。
- en: Better approaches for generating strings are to use either the `StringBuilder`
    class or one of several string class methods for string formatting.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 生成字符串的更好方法是用 `StringBuilder` 类或几个字符串类方法之一进行字符串格式化。
- en: StringBuilder
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`StringBuilder`'
- en: Conventional wisdom says that if we roughly know the final size of the resultant
    string, then we can allocate an appropriate buffer AOT and save ourselves undue
    allocations. This is the purpose of the `StringBuilder` class. It is effectively
    a mutable (changeable) string-based object that works like a dynamic array. It
    allocates a block of space, which we can copy future string objects into, and
    allocates additional space whenever the current size is exceeded. Of course, expanding
    the buffer should be avoided as much as possible by predicting the maximum size
    we will need and allocating a sufficiently sized buffer AOT.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 传统智慧认为，如果我们大致知道最终字符串的大小，那么我们可以在 AOT（提前优化）时分配一个合适的缓冲区，从而避免不必要的分配。这就是 `StringBuilder`
    类的目的。它实际上是一个可变（可更改）的基于字符串的对象，其工作方式类似于动态数组。它分配一块空间，我们可以将未来的字符串对象复制到其中，并在当前大小超过时分配额外的空间。当然，通过预测我们需要的最大大小并提前分配足够大小的缓冲区，应尽可能避免扩展缓冲区。
- en: When we use `StringBuilder`, we can retrieve the resultant string object by
    calling the `ToString()` method. This still results in one additional memory allocation
    for the completed string, but, at the very least, we only allocated one large
    string as opposed to dozens of smaller strings, had we used the `+` or `+=` operators.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `StringBuilder` 时，可以通过调用 `ToString()` 方法来检索生成的字符串对象。这仍然会导致为完成的字符串分配一个额外的内存空间，但至少，我们只分配了一个大字符串，而不是使用
    `+` 或 `+=` 运算符时可能使用的数十个小字符串。
- en: 'For the previous example, we might allocate a `StringBuilder` buffer of `100`
    characters to make room for long character names and damage values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的示例，我们可能会分配一个容量为 `100` 个字符的 `StringBuilder` 缓冲区，以留出足够的空间用于长字符名称和伤害值：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: String formatting
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: If we don't know the final size of the resultant string, then using a `StringBuilder`
    class is unlikely to generate a buffer that fits the result size exactly. We will
    either end up with a buffer that's too large (wasted space) or, worse, a buffer
    that's too small, which must keep expanding as we generate the complete string.
    In this scenario, it might be best to use one of the various string class formatting
    methods.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道最终字符串的大小，那么使用 `StringBuilder` 类可能无法生成一个恰好适合结果大小的缓冲区。我们最终可能会得到一个过大的缓冲区（浪费空间），或者更糟糕的是，一个过小的缓冲区，随着我们生成完整的字符串，它必须不断扩展。在这种情况下，最好使用各种字符串类格式化方法之一。
- en: 'There are three string class methods available for generating strings: `string.Format()`,
    `string.Join()`, and `string.Concat()`. Each operates slightly differently, but
    the overall output is the same. A new string object is allocated, containing the
    contents of the string objects we pass into them, and it is all done in a single
    action, which reduces excess string allocations.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种字符串类方法可用于生成字符串：`string.Format()`、`string.Join()` 和 `string.Concat()`。它们的工作方式略有不同，但总体输出是相同的。会分配一个新的字符串对象，包含我们传递给它们的字符串对象的内容，并且这一切都是在单一操作中完成的，这减少了多余的字符串分配。
- en: Unfortunately, regardless of the approach we use, if we're converting other
    objects into additional string objects (such as the calls to generate the strings
    for `"Orc"`, `"Dwarf"`, or `"Slashing"` in the preceding example), then this will
    allocate an additional string object on the heap. There is nothing we can do about
    this allocation, except perhaps cache the result so that we don't need to recalculate
    it each time it's needed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，无论我们使用哪种方法，如果我们正在将其他对象转换为额外的字符串对象（例如，在前面示例中生成 `"Orc"`、`"Dwarf"` 或 `"Slashing"`
    字符串的调用），那么这将在堆上分配一个额外的字符串对象。我们对此分配无能为力，除非可能缓存结果，这样我们就不需要每次需要时都重新计算它。
- en: It can be surprisingly hard to say which one of these string generation approaches
    would be more beneficial in a given situation, as there are a lot of silly little
    nuances involved that tend to explode into religious debate (just do a Google
    search for `C# string concatenation performance`*,* and you'll see what I mean),
    so the simplest approach is to implement one or the other using the conventional
    wisdom described previously. Whenever we run into bad performance with one of
    the string-manipulation methods, we should also try the other to check whether
    it results in performance improvement. The best way to be certain is to profile
    them both for comparison and then pick the best options.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定情况下，很难说哪种字符串生成方法更有益，因为涉及许多微小的细节，这些细节往往会演变成宗教辩论（只需在Google上搜索`C# string concatenation
    performance`，你就会明白我的意思），所以最简单的方法是使用之前描述的常规智慧实现一种或另一种方法。每当我们在字符串操作方法中遇到性能问题时，我们也应该尝试另一种方法，以检查它是否会导致性能提升。最确定的方法是为它们两者进行性能分析比较，然后选择最佳选项。
- en: Boxing
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装箱
- en: Everything in C# is an object (caveats apply), meaning that they derive from
    the `System.Object` class. Even primitive data types such as `int`, `float`, and
    `bool` are implicitly derived from `System.Object`, which is itself a reference
    type. This is a special case, which allows them access to helper methods such
    as `ToString()` so that they can customize their string representation, but without
    actually turning them into reference types. Whenever one of these value types
    is implicitly treated in such a way that it must act as an object, the CLR automatically
    creates a temporary object to store, or *box*, the value inside so that it can
    be treated as a typical reference type object. As we should expect, this results
    in a heap allocation to create the containing vessel.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，一切皆对象（有一些例外），这意味着它们都从`System.Object`类派生。即使是像`int`、`float`和`bool`这样的原始数据类型，也是隐式地从`System.Object`派生的，而`System.Object`本身是一个引用类型。这是一个特殊情况，它允许它们访问如`ToString()`这样的辅助方法，以便它们可以自定义其字符串表示形式，但又不实际上将它们转换为引用类型。每当这些值类型被隐式地以必须作为对象的方式处理时，CLR会自动创建一个临时对象来存储或*装箱*其内部的值，以便它可以被当作典型的引用类型对象处理。正如我们所预期的，这会导致堆分配以创建包含容器。
- en: Note that boxing is not the same thing as using value types as member variables
    of reference types. Boxing only takes place when value types are treated as reference
    types via conversion or casting.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，装箱与将值类型用作引用类型的成员变量不是一回事。装箱仅在值类型通过转换或强制类型转换被当作引用类型处理时才会发生。
- en: 'Check out these examples:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例：
- en: 'The following code will cause the `i` integer variable to be boxed inside the
    `obj` object:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码将导致`i`整数变量在`obj`对象内部被装箱：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code will use the `obj` object representation to replace the
    value stored within the integer, and unbox it back into an integer, storing it
    in `i`. The final value of `i` would be `256`:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码将使用`obj`对象表示来替换存储在整数中的值，并将其解箱回整数，存储在`i`中。`i`的最终值将是`256`：
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding types can be changed dynamically.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型可以动态更改。
- en: 'The following is perfectly legal C# code, where we override the type of `obj`,
    converting it into `float`:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是完全合法的C#代码，其中我们重写了`obj`的类型，将其转换为`float`：
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is also legal—conversion into `bool`:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下也是合法的——转换为`bool`：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that attempting to unbox `obj` into a type that isn''t the most recently
    assigned type would result in `InvalidCastException`:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，尝试将`obj`解箱到不是最近分配的类型会导致`InvalidCastException`：
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All of this can be a little tricky to wrap our head around until we remember
    that, at the end of the day, everything is just bits in memory and that we are
    free to interpret them any way we like. After all, data types such as `int`, `float`,
    and so on are just an abstraction over binary lists of `0` and `1`. What's important
    is knowing that we can treat our primitive types as objects by boxing them, converting
    their types, and then unboxing them into a different type at a later time, but
    each time we do this results in a heap memory allocation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能有点难以理解，直到我们记住，最终，一切只是内存中的位，我们可以自由地以任何方式解释它们。毕竟，像`int`、`float`等数据类型只是对二进制列表`0`和`1`的抽象。重要的是要知道我们可以通过装箱、转换类型，然后在以后的时间将它们解箱到不同的类型来将我们的原始类型当作对象处理，但每次这样做都会导致堆内存分配。
- en: Note that it's possible to convert a boxed object's type using one of the many
    `System.Convert.To…()` methods.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以使用许多`System.Convert.To…()`方法之一将装箱对象的类型转换为其他类型。
- en: Boxing can be either implicit, as shown in the preceding examples, or explicit,
    by typecasting to `System.Object`. Unboxing must always be explicit by typecasting
    back to its original type. Whenever we pass a value type into a method that uses
    `System.Object` as arguments, boxing will be applied implicitly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱可以是隐式的，如前例所示，或者通过类型转换到`System.Object`来显式。解装箱必须始终通过类型转换回其原始类型来显式进行。每次我们将值类型传递给使用`System.Object`作为参数的方法时，都会隐式地应用装箱。
- en: Methods such as `String.Format()`, which take `System.Object` as arguments,
    are one such example. We typically use them by passing in value types, such as
    `int`, `float`, and `bool`, to generate a string with. Boxing is automatically
    taking place in these situations, causing additional heap allocations that we
    should be aware of. `Collections.Generic.ArrayList` is another such example since
    `ArrayList` always contains converts its inputs into `System.Object` references,
    regardless of what types are stored within.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`String.Format()`这样的方法，它接受`System.Object`作为参数，就是这样一个例子。我们通常通过传递值类型，如`int`、`float`和`bool`，来生成字符串，这些情况下会自动进行装箱，导致额外的堆分配，我们应该注意。`Collections.Generic.ArrayList`也是这样的例子，因为`ArrayList`总是将其输入转换为`System.Object`引用，无论存储了什么类型。
- en: Any time we use a function definition that takes `System.Object` as arguments,
    and we're passing in value types, we should be aware that we're implicitly causing
    heap allocations due to boxing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用一个接受`System.Object`作为参数的函数定义，并且传递值类型时，我们应该意识到我们正在隐式地导致堆分配，这是由于装箱造成的。
- en: The importance of data layout
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据布局的重要性
- en: The importance of how our data is organized in memory can be surprisingly easy
    to forget about but can result in a fairly big performance boost if it is handled
    properly. Cache misses should be avoided whenever possible, which means that in
    most cases, arrays of data that are contiguous in memory should be iterated over
    sequentially as opposed to any other iteration style.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内存中如何组织数据的重要性可能很容易被忘记，但如果处理得当，可能会带来相当大的性能提升。应尽可能避免缓存未命中，这意味着在大多数情况下，内存中连续的数据数组应该按顺序迭代，而不是其他任何迭代方式。
- en: This means that data layout is also important for garbage collection since it
    is done in an iterative fashion, and if we can find ways to have the GC skip over
    problematic areas, then we can potentially save a lot of iteration time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着数据布局对于垃圾回收也很重要，因为它是迭代进行的，如果我们能找到让GC跳过问题区域的方法，那么我们可以潜在地节省大量的迭代时间。
- en: In essence, we want to keep large groups of reference types separated from large
    groups of value types. If there is even one reference type within a value type,
    such as `struct`, then the GC considers the entire object, and all of its data
    members, indirectly referenceable objects. When it comes time to Mark-and-Sweep,
    it must verify all fields of the object before moving on. However, if we separate
    the various types into different arrays, then we can make the GC skip the majority
    of the data.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们希望将大量引用类型与大量值类型分开。如果值类型（如`struct`）中包含任何引用类型，那么垃圾回收器（GC）会认为整个对象及其所有数据成员都是间接可引用的对象。在执行标记-清除操作时，它必须验证对象的所有字段才能继续。然而，如果我们将各种类型分开到不同的数组中，那么我们可以让GC跳过大部分数据。
- en: 'For instance, if we have an array of `struct` objects that looks like the following
    code, then the GC will need to iterate over every member of every `struct`, which
    could be fairly time-consuming:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个类似以下代码的`struct`对象数组，那么GC将需要迭代每个`struct`的每个成员，这可能相当耗时：
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, if we reorganize all pieces of this data into multiple arrays of each
    time, then the GC will ignore all of the primitive data types and only check the
    string objects. The following code will result in much a faster garbage collection
    sweep:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将这些数据的所有部分重新组织成多个数组，那么GC将忽略所有原始数据类型，只检查字符串对象。以下代码将导致垃圾收集扫描速度更快：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reason this works is that we're giving the GC fewer indirect references
    to check. When the data is split into separate arrays (reference types), it finds
    three arrays of value types, marks the arrays, and then immediately moves on because
    there's no reason to mark the contents of an array of value types. It must still
    iterate through all of the string objects within `myStrings` since each is a reference
    type and it needs to verify that there are no indirect references within it. Technically,
    the string objects cannot contain indirect references, but the GC works at a level
    where it only knows whether the object is a reference type or value type and,
    therefore, can't tell the difference between a string and class. However, we have
    still spared the GC from needing to iterate over an extra 3,000 pieces of data
    (the 3,000 values in `myInts`, `myFloats`, and `myBools`).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为我们给了 GC 更少的间接引用去检查。当数据被分成单独的数组（引用类型）时，它找到三个值类型的数组，标记这些数组，然后立即继续，因为没有理由标记值类型数组的内部内容。它仍然必须遍历
    `myStrings` 中的所有字符串对象，因为每个都是引用类型，并且它需要验证其中没有间接引用。技术上，字符串对象不能包含间接引用，但 GC 在一个层面上工作，它只知道对象是引用类型还是值类型，因此无法区分字符串和类。然而，我们仍然节省了
    GC 需要遍历额外的 3,000 份数据（`myInts`、`myFloats` 和 `myBools` 中的 3,000 个值）的需要。
- en: Arrays from the Unity API
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity API 中的数组
- en: 'Several instructions within the Unity API result in heap memory allocations,
    which we should be aware of. This essentially includes everything that returns
    an array of data. For example, the following methods allocate memory on the heap:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Unity API 中的几个指令会导致堆内存分配，我们应该对此有所了解。这基本上包括返回数据数组的所有内容。例如，以下方法在堆上分配内存：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each and every time we call a Unity API method that returns an array will cause
    a whole new version of that data to be allocated. Such methods should be avoided
    whenever possible or at the very least called once and cached so that we don't
    cause memory allocations more often than necessary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用返回数组的 Unity API 方法时，都会分配一个新的数据版本。这些方法应尽可能避免使用，或者至少调用一次并缓存，以减少不必要的内存分配。
- en: There are other Unity API calls where we provide an array of elements to a method,
    and it writes the necessary data into the array for us. One such example is providing
    a `Particle[]` array to `ParticleSystem` to get its `Particle` data. The benefit
    of these types of API calls is that we can avoid reallocating large arrays, whereas
    the downside is that the array needs to be large enough to fit all of the objects.
    If the number of objects we need to acquire keeps increasing, then we may find
    ourselves reallocating larger arrays. In the case of `ParticleSystem`, we need
    to be certain we create an array large enough to contain the maximum number of
    `Particle` objects it generates at any given time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些 Unity API 调用，我们将元素数组提供给方法，它将必要的数据写入数组。一个这样的例子是将 `Particle[]` 数组提供给 `ParticleSystem`
    以获取其 `Particle` 数据。这些类型 API 调用的好处是我们可以避免重新分配大数组，而缺点是数组需要足够大以容纳所有对象。如果我们需要获取的对象数量持续增加，我们可能会发现自己需要重新分配更大的数组。在
    `ParticleSystem` 的情况下，我们需要确保创建的数组足够大，可以包含它在任何给定时间生成的最大数量的 `Particle` 对象。
- en: Unity Technologies have hinted in the past that they may eventually change some
    of the API calls that return arrays into the form that requires an array to be
    provided. The API of the latter form can be confusing for new programmers at first
    glance; however, unlike the first form, it allows responsible programmers to use
    memory much more efficiently.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Technologies 在过去暗示过，他们可能最终会将一些返回数组的 API 调用更改为需要提供数组的格式。这种形式的 API 在初看时可能会让新程序员感到困惑；然而，与第一种形式不同，它允许负责任的程序员更有效地使用内存。
- en: Using InstanceIDs for dictionary keys
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 InstanceID 作为字典键
- en: As mentioned in Chapter 2, *Scripting Strategies*, dictionaries are used to
    map associations between two different objects, which are very quick at telling
    us whether a mapping exists, and if so, what that mapping is. It's common practice
    to map `MonoBehaviour` or `ScriptableObject` reference as the key of a dictionary,
    but this causes some problems. When the dictionary element is accessed, it will
    need to call into several derived methods of `UnityEngine.Object`, which both
    of these object types derive from. This makes element comparison and mapping acquisition
    relatively slow.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 2 章所述，*脚本策略*，字典用于映射两个不同对象之间的关联，它们非常快速地告诉我们是否存在映射，如果存在，映射是什么。将 `MonoBehaviour`
    或 `ScriptableObject` 引用作为字典的键是一种常见做法，但这也引起了一些问题。当访问字典元素时，它将需要调用 `UnityEngine.Object`
    的几个派生方法，这两个对象类型都从 `UnityEngine.Object` 派生。这使得元素比较和映射获取相对较慢。
- en: This can be improved by making use of `Object.GetInstanceID()`, which returns
    an integer representing a unique identification value for that object that never
    changes and is never reused between two objects during the entire lifecycle of
    the application. If we cache this value in the object somehow and use it as the
    key in our dictionary, then the element comparison will be around two to three
    times faster than if we used the object reference directly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `Object.GetInstanceID()` 来改进，它返回一个整数，代表该对象的唯一标识值，在整个应用程序的生命周期中该值永远不会改变，也不会在两个对象之间重复使用。如果我们以某种方式将此值缓存到对象中，并将其用作字典中的键，那么元素比较将比直接使用对象引用快两到三倍。
- en: However, there are caveats to this approach. If the instance ID value is not
    cached (we keep calling `Object.GetInstanceID()` each time we need to index into
    our dictionary) and we are compiling with Mono (and not IL2CPP), then element
    acquisition could end up being slow. This is because it will call some thread-unsafe
    code to acquire the instance ID, in which case, the Mono compiler cannot optimize
    the loop, and, therefore causes some additional overhead by comparison to caching
    the instance ID value. If we are compiling with IL2CPP, which doesn't have this
    problem, then the benefits are still not as great (only around 50% faster) than
    if we had simply cached the value beforehand. Therefore, we should aim to cache
    the integer value in some way so that we avoid having to call `Object.GetInstanceID()`
    too often.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有一些注意事项。如果实例 ID 值未缓存（我们每次需要索引字典时都调用 `Object.GetInstanceID()`）并且我们使用
    Mono（而不是 IL2CPP）进行编译，那么元素获取可能会变得缓慢。这是因为它将调用一些线程不安全的代码来获取实例 ID，在这种情况下，Mono 编译器无法优化循环，因此与缓存实例
    ID 值相比，会产生一些额外的开销。如果我们使用 IL2CPP 进行编译，它没有这个问题，那么好处仍然不如事先缓存值（大约快 50%）。因此，我们应该努力以某种方式缓存整数值，以避免频繁调用
    `Object.GetInstanceID()`。
- en: foreach loops
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: foreach 循环
- en: The `foreach` loop keyword is a bit of a controversial issue in Unity development
    circles. It turns out that a lot of `foreach` loops implemented in Unity C# code
    will incur unnecessary heap memory allocations during these calls, as they allocate
    an `Enumerator` object as a class on the heap, instead of a `struct` on the stack.
    It all depends on the given collection's implementation of the `GetEnumerator()`
    method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环关键字在 Unity 开发圈子中是一个有点争议的话题。事实证明，在 Unity C# 代码中实现的许多 `foreach` 循环在调用过程中会引发不必要的堆内存分配，因为它们在堆上分配了一个
    `Enumerator` 对象作为类，而不是在栈上作为 `struct`。这完全取决于给定集合的 `GetEnumerator()` 方法的实现。'
- en: Note that it is safe to use `foreach` loops on typical arrays. The Mono compiler
    secretly converts `foreach` over arrays into simple for loops.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在典型数组上使用 `foreach` 循环是安全的。Mono 编译器秘密地将数组上的 `foreach` 转换为简单的 for 循环。
- en: 'Since Unity 2018.1, Unity uses an upgraded Mono runtime (4.0.30319) and some
    compiler fixes many of the previous issues with `foreach`. As a consequence, `foreach`
    is no more a big issue in the general case. Yet, `foreach` still has a bad reputation
    among developers. The fact that sometimes they can actually be problematic makes
    everything more complicated. As usual, there is only one way to be sure: use the
    Profiler and check whether `foreach` is actually creating problems in your specific
    situation.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Unity 2018.1 以来，Unity 使用了升级的 Mono 运行时（4.0.30319）和一些编译器修复了之前 `foreach` 的一些问题。因此，在一般情况下，`foreach`
    已不再是重大问题。然而，`foreach` 在开发者中仍然有很差的声誉。有时它们实际上可能存在问题，这使得一切变得更加复杂。通常，只有一种方法可以确保：使用
    Profiler 并检查 `foreach` 是否确实在你的特定情况下造成问题。
- en: In any case, even in the worst scenario—that is, your `foreach` loop is actually
    doing heap allocations—the cost is fairly negligible, as the heap allocation cost
    does not scale with the number of iterations. Only one `Enumerator` object is
    allocated and reused over and over again, which only costs a handful of bytes
    of memory overall. So, unless our `foreach` loops are being invoked for every
    update (which is typically dangerous in, and of, itself), the costs will be mostly
    negligible on small projects. The time taken to convert everything into a `for`
    loop may not be worth it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，即使在最糟糕的场景中——也就是说，你的`foreach`循环实际上正在进行堆分配——成本也是相当可忽略的，因为堆分配成本不会随着迭代次数的增加而增加。只有一个`Enumerator`对象被分配并反复使用，这总共只花费了几字节内存。所以，除非我们的`foreach`循环在每次更新时都被调用（这通常本身就很危险），否则成本在小型项目中将主要是可以忽略的。将所有内容转换为`for`循环所需的时间可能不值得。
- en: Coroutines
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: As mentioned before, starting a coroutine costs a small amount of memory, to
    begin with, but note that no further costs are incurred when the method calls
    `yield`. If memory consumption and garbage collection are significant concerns,
    we should try to avoid having too many short-lived coroutines and avoid calling
    `StartCoroutine()` too much during runtime.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，启动协程最初需要少量内存，但请注意，当方法调用`yield`时不会产生进一步的成本。如果内存消耗和垃圾回收是重大关注点，我们应该尽量避免有太多短生命周期的协程，并在运行时尽量避免过多调用`StartCoroutine()`。
- en: Closures
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are useful, but dangerous tools. Anonymous methods and lambda expressions
    are not always closures, but they can be. It all depends on whether the method
    uses data outside of its own scope and parameter list or not.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是有用的，但危险的工具。匿名方法和lambda表达式并不总是闭包，但它们可以是。这完全取决于方法是否使用其自身作用域和参数列表之外的数据。
- en: 'For example, the following anonymous function would not be a closure, since
    it is self-contained and functionally equivalent to any other locally defined
    function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下匿名函数不会是一个闭包，因为它自包含并且功能上等同于任何其他局部定义的函数：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if the anonymous function pulled in data from outside itself, it becomes
    a closure, as it closes the environment around the required data. The following
    would result in a closure:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果匿名函数从自身外部拉取数据，它就变成了闭包，因为它关闭了所需数据的周围环境。以下将导致闭包：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In order to complete this transaction, the compiler must define a new custom
    class that can reference the environment where the `i` data value would be accessible.
    At runtime, it creates the corresponding object on the heap and provides it to
    the anonymous function. Note that this includes value types (as per the preceding
    example), which were originally on the stack, possibly defeating the purpose of
    them being allocated on the stack in the first place. So, we should expect each
    invocation of the second method to result in heap allocations and inevitable garbage
    collection.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个交易，编译器必须定义一个新的自定义类，该类可以引用`i`数据值可访问的环境。在运行时，它会在堆上创建相应的对象并将其提供给匿名函数。请注意，这包括值类型（如前例所示），它们最初在栈上，可能最初分配在栈上的目的被抵消了。因此，我们应该预计第二次方法的每次调用都会导致堆分配和不可避免的垃圾回收。
- en: The .NET library functions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET库函数
- en: The .NET library offers a huge amount of common functionalities that help to
    solve numerous problems that programmers may come across during day-to-day implementation.
    Most of these classes and functions are optimized for general use cases, which
    may not be optimal for a specific situation. It may be possible to replace a particular
    .NET library class with a custom implementation that is more suited to our specific
    use case.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: .NET库提供了大量的常用功能，有助于解决程序员在日常实现过程中可能遇到的各种问题。这些类和函数大多数都针对通用用例进行了优化，可能不是特定情况的最佳选择。可能可以用更适合我们特定用例的自定义实现替换特定的.NET库类。
- en: There are also two big features in the .NET library that often become big performance
    hogs whenever they're used. This tends to be because they are only included as
    a quick-and-dirty solution to a given problem without much effort put into optimization.
    These features are **LINQ** and **r****egular expressions**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: .NET库中也有两个大特性，当它们被使用时往往会成为性能瓶颈。这通常是因为它们只是作为一个针对特定问题的快速且简单的解决方案，而没有投入太多精力进行优化。这些特性是**LINQ**和**正则表达式**。
- en: LINQ provides a way to treat arrays of data as miniature databases and perform
    queries against them using a SQL-like syntax. The simplicity of its coding style
    and complexity of the underlying system (through its usage of closures) implies
    that it has a fairly large overhead cost. LINQ is a handy tool, but is not really
    intended for high-performance, real-time applications, such as games, and does
    not even function on platforms that do not support JIT compilation, such as iOS.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ提供了一种将数据数组视为小型数据库并使用类似SQL的语法对其执行查询的方法。其编码风格的简洁性和底层系统的复杂性（通过其闭包的使用）暗示了它有相当大的开销成本。LINQ是一个方便的工具，但并不真正适用于高性能、实时应用，如游戏，甚至在不支持JIT编译的平台（如iOS）上也无法运行。
- en: Meanwhile, regular expressions through the `Regex` class allow us to perform
    complex string parsing to find substrings that match a particular format, replace
    pieces of a string, or construct strings from various inputs. Regular expressions
    are very useful tools but tends to be overused in places where they are largely
    unnecessary or in so-called clever ways to implement a feature such as text localization,
    when straightforward string replacement would be far more efficient.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，通过`Regex`类提供的正则表达式允许我们执行复杂的字符串解析，以找到匹配特定格式的子字符串，替换字符串的一部分，或从各种输入中构建字符串。正则表达式是非常有用的工具，但往往在它们在很大程度上不必要的地方或以所谓的巧妙方式实现功能（如文本本地化）时过度使用，而直接字符串替换会更为高效。
- en: Specific optimizations for both of these features go far beyond the scope of
    this book, as they could fill an entire book by themselves. We should either try
    to minimize their usage as much as possible, replace their usage with something
    less costly, bring in a LINQ or regex expert to solve the problem for us or do
    some Googling on the subject to optimize how we're using them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个功能的具体优化远远超出了本书的范围，因为它们可以单独填满一本书。我们应该尽可能地最小化它们的用法，用成本较低的方法替换它们的用法，引入LINQ或正则表达式专家来为我们解决问题，或者在网上搜索相关内容以优化我们使用它们的方式。
- en: One of the best ways to find the correct answer online is to simply post the
    wrong answer. People will either help us out of kindness or will take such a great
    offense from our implementation that they will consider it their civic duty to
    correct us. Just be sure to do some kind of research on the subject first. Even
    the busiest of people are generally happy to help if they can see that we've put
    in our fair share of effort beforehand.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上找到正确答案的最好方法之一就是简单地发布错误的答案。人们可能会出于善意帮助我们，或者会因我们的实现而感到极大冒犯，以至于他们认为纠正我们是他们的公民责任。只是确保在发布之前对主题进行一些研究。即使是最忙碌的人，如果他们看到我们事先已经付出了公平的努力，通常也愿意提供帮助。
- en: Temporary work buffers
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时工作缓冲区
- en: If we get into the habit of using large, temporary work buffers for one task
    or another, then it just makes sense that we should look for opportunities to
    reuse them, instead of reallocating them over and over again, as this lowers the
    overhead involved in allocation and garbage collection (often called **memory
    pressure**). It might be worthwhile to extract such functionality from case-specific
    classes into a generic *G**od* class that contains a big work area for multiple
    classes to reuse.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们养成了使用大型的临时工作缓冲区来完成一项或另一项任务的习惯，那么寻找机会重复使用它们而不是反复重新分配它们就很有意义，因为这样可以降低分配和垃圾回收（通常称为**内存压力**）所涉及的开销。可能值得将此类功能从特定类中提取出来，放入一个包含大量工作区域以供多个类重复使用的通用**G**od类中。
- en: Object pooling
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池
- en: Speaking of temporary work buffers, object pooling is an excellent way of both
    minimizing and establishing control over our memory usage by avoiding deallocation
    and reallocation. The idea is to formulate our own system for object creation,
    which hides away whether the object we're getting has been freshly allocated or
    has been recycled from an earlier allocation. The typical terms to describe this
    process are to spawn and despawn the object rather than creating and deleting
    them in memory. When an object is despawned, we're simply hiding it, making it
    lay dormant until we need it again, at which point it is respawned from one of
    the previously despawned objects and used in place of an object we might have
    otherwise newly allocated.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到临时工作缓冲区，对象池是一种既可最小化又可控制我们内存使用的方法，通过避免分配和重新分配来实现。其思路是制定我们自己的对象创建系统，隐藏我们获取的对象是刚刚分配的还是从之前的分配中回收的。描述此过程的典型术语是“生成”和“销毁”对象，而不是在内存中创建和删除它们。当一个对象被销毁时，我们只是将其隐藏起来，使其处于休眠状态，直到我们再次需要它，此时它将从之前销毁的对象中重新生成，并替代我们可能新分配的对象。
- en: 'Let''s cover a quick implementation of an object pooling system:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速实现一个对象池系统：
- en: 'First, we define a common interface for the object we want to use in the object
    pool. An important feature of this system is to allow the pooled object to decide
    how to recycle itself when the time comes. The following interface class called
    `IPoolableObject` will satisfy this requirement nicely:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为要在对象池中使用的对象定义一个公共接口。此系统的一个重要特性是允许池化对象在需要时决定如何回收自己。以下名为`IPoolableObject`的接口类将很好地满足这一要求：
- en: '[PRE28]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This interface class defines two methods: `New()` and `Respawn()`. These should
    be called when the object is first created and when it has been respawned, respectively.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口类定义了两个方法：`New()`和`Respawn()`。这些方法分别在对象首次创建和被重新生成时调用。
- en: 'Now, we need to implement a class that manages the poolable objects. The following
    `ObjectPool` class definition is a fairly simple implementation of the object
    pooling concept:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实现一个管理池化对象类的类。以下`ObjectPool`类定义是对象池概念的相当简单的实现：
- en: '[PRE29]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This class allows `ObjectPool` to be used with any object type so long as it
    fits the following two criteria: it must implement the `IPoolableObject` interface
    class, and the derived class must allow for a parameter-less constructor (specified
    by the `new()` keyword in the class declaration).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此类允许`ObjectPool`与任何符合以下两个条件的对象类型一起使用：它必须实现`IPoolableObject`接口类，并且派生类必须允许无参数构造函数（由类声明中的`new()`关键字指定）。
- en: 'Finally, we need to implement the `IPoolableObject` interface for any object
    we want to pool. An example poolable object would look like so: it must implement
    two `public` methods, `New()` and `Respawn()`, which are invoked by the `ObjectPool`
    class at the appropriate times:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为任何我们想要池化的对象实现`IPoolableObject`接口。一个示例池化对象可能如下所示：它必须实现两个`public`方法，`New()`和`Respawn()`，这些方法在适当的时候由`ObjectPool`类调用：
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, just consider this usage example: we want to have a continuous wave of
    monsters. Obviously, we do not want to create new enemies continuously, instead,
    we want to recycle the enemies killed by the player. To do that, first we create
    a pool of 100 `EnemyObject` objects (we assume we never need to show more than
    100 enemies on screen at the same time):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个使用示例：我们希望有一个连续的怪物浪潮。显然，我们不想不断地创建新的敌人，而是希望回收玩家杀死的敌人。为此，首先我们创建一个包含100个`EnemyObject`对象的池（我们假设我们不需要同时显示超过100个敌人）：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first 100 calls to `Spawn()` on `ObjectPool` will cause the enemy to be
    respawned, providing the caller with a unique instance of the object each time.
    If there are no more enemies to provide (we have called `Spawn()` more than 100
    times), then we will allocate a new `EnemyObject` instance and push it onto the
    stack. Finally, if `Reset()` is called on `ObjectPool`, it will begin again from
    the start, recycling enemies and providing them to the caller.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ObjectPool`上对`Spawn()`的前100次调用将导致敌人被重新生成，每次为调用者提供一个对象的唯一实例。如果没有更多的敌人可以提供（我们已经调用了`Spawn()`超过100次），那么我们将分配一个新的`EnemyObject`实例并将其推入堆栈。最后，如果对`ObjectPool`调用`Reset()`，它将从头开始，回收敌人并将它们提供给调用者。
- en: Note that we are using the `Peek()` method on the `Stack` object so that we
    don't remove the old instance from the stack. We want `ObjectPool` to maintain
    references to all of the enemies we create.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`Stack`对象的`Peek()`方法，这样我们就不从堆栈中移除旧实例。我们希望`ObjectPool`维护我们创建的所有敌人的引用。
- en: 'Also, note that this pooling solution will not work for classes we haven''t
    defined and cannot derive from `IPoolableObject`, such as `Vector3` and `Quaternion`.
    This is normally dictated by the `sealed` keyword in the class definition. In
    these cases, we would need to define a containing class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这个池化解决方案不适用于我们没有定义且无法从`IPoolableObject`派生的类，例如`Vector3`和`Quaternion`。这通常由类定义中的`sealed`关键字决定。在这些情况下，我们需要定义一个包含类：
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We could extend this system in a number of ways, such as defining a `Despawn()`
    method to handle destruction of the object, making use of the `IDisposable` interface
    class and `using` blocks when we wish to automatically spawn and despawn objects
    within a small scope, and/or allowing objects instantiated outside the pool to
    be added to it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式扩展这个系统，例如定义一个`Despawn()`方法来处理对象的销毁，当我们在小范围内自动生成和销毁对象时，利用`IDisposable`接口类和`using`块，以及/或者允许在池外实例化的对象被添加到池中。
- en: Prefab pooling
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制体池化
- en: The previous pooling solution is useful for typical C# objects, but it won't
    work for specialized Unity objects, such as `GameObject` and `MonoBehaviour`.
    These objects tend to consume a large chunk of our runtime memory, can cost us
    a great deal of CPU usage when they're created and destroyed, and tend to risk
    a large amount of garbage collection at runtime. For instance, during the lifecycle
    of a small RPG game, we might spawn a thousand Orc creatures, but at any given
    moment, we may only need a maximum of 10 of them. It would be nice if we could
    perform similar pooling as before but, for Unity Prefabs, to save on a lot of
    unnecessary overhead creating and destroying 990 Orcs we don't need.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的池化解决方案对于典型的C#对象很有用，但它不适用于专门的Unity对象，如`GameObject`和`MonoBehaviour`。这些对象往往消耗大量的运行时内存，在创建和销毁时可能会消耗大量的CPU资源，并且容易在运行时产生大量的垃圾回收。例如，在一个小型RPG游戏的生命周期中，我们可能会生成一千个兽人生物，但在任何给定时刻，我们可能只需要最多10个。如果能像之前一样执行类似的池化操作，但对于Unity
    Prefabs来说，可以节省创建和销毁我们不需要的990个兽人的大量不必要的开销，那就太好了。
- en: Our goal is to push the overwhelming majority of object instantiation to scene
    initialization rather than letting them get created at runtime. This can provide
    some big runtime CPU savings and avoids a lot of spikes caused by object creation/destruction
    and garbage collection at the expense of scene loading times and runtime memory
    consumption. As a result, there are quite a few pooling solutions available on
    the Asset Store to handle this task, with varying degrees of simplicity, quality,
    and feature sets.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将绝大多数对象实例化推到场景初始化阶段，而不是让它们在运行时创建。这可以在一定程度上节省运行时的CPU资源，并避免由于对象创建/销毁和垃圾回收导致的许多峰值，尽管这可能会牺牲场景加载时间和运行时内存消耗。因此，在Asset
    Store上有许多不同的池化解决方案可供处理这项任务，它们在简单性、质量和功能集方面各不相同。
- en: It is often recommended that pooling should be implemented in any game that
    intends to be deployed on mobile devices, due to the greater overhead costs involved
    in the allocation and deallocation of memory compared to desktop applications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议，任何打算在移动设备上部署的游戏都应该实现池化，因为与桌面应用程序相比，内存分配和释放的额外开销更大。
- en: However, creating a pooling solution is an interesting topic, and building one
    from scratch is a great way of getting to grips with a lot of important internal
    Unity engine behavior. Also, knowing how such a system is built makes it easier
    to extend if we wish it to meet the needs of our particular game, rather than
    to rely on a prebuilt solution.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建一个池化解决方案是一个有趣的话题，从头开始构建一个可以让我们更好地理解许多重要的Unity引擎内部行为。此外，了解这样一个系统是如何构建的，如果我们要使其满足我们特定游戏的需求，而不是依赖于预构建的解决方案，这将更容易进行扩展。
- en: 'The general idea of Prefab pooling is to create a system that contains lists
    of active and inactive GameObjects that were all instantiated from the same Prefab
    reference. The following diagram shows how the system might look after several
    spawns, despawns, and respawns of various objects derived from four different
    Prefabs (**Orc**, **Troll**, **Ogre**, and **Dragon**):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件池化的基本思想是创建一个系统，该系统包含从同一预制件引用实例化的活动和非活动GameObject的列表。以下图表展示了在经过几个不同预制件（**兽人**、**巨魔**、**兽人**和**龙**）的生成、销毁和重生后，系统可能的外观：
- en: '![](img/1a9a8f86-8bc4-4750-8b4a-50ed0ec65a19.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a9a8f86-8bc4-4750-8b4a-50ed0ec65a19.png)'
- en: Note that the **Heap Memory** area in the previous screenshot represents the
    objects as they exist in memory, while the **Pooling System** area represents
    the **Pooling System's** references to those objects.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前一个截图中的**堆内存**区域表示内存中存在的对象，而**池化系统**区域表示**池化系统**对这些对象的引用。
- en: In this example, several instances of each Prefab were instantiated (**11 Orcs**,
    **8 Trolls**, **5 Ogres**, and **1 Dragon**). Currently, only 11 of these objects
    are active, while the other 14 have been previously despawned and are inactive.
    Note that the despawned objects still exist in memory, although they are not visible
    and cannot interact with the game world until they have been respawned. Naturally,
    this costs us a constant amount of heap memory at runtime to maintain the inactive
    objects, but when a new object is instantiated, we can reuse one of the existing
    inactive objects rather than allocating more memory to satisfy the request. This
    saves significant runtime CPU costs during object creation and destruction and
    avoids garbage collection.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个预制件都实例化了多个实例（**11个兽人**、**8个巨魔**、**5个兽人**和**1条龙**）。目前，只有11个这些对象是活动的，而其他14个已经被先前销毁并且处于非活动状态。请注意，销毁的对象仍然存在于内存中，尽管它们不可见且无法与游戏世界交互，直到它们被重生。自然地，这在我们运行时需要持续占用一定的堆内存来维护非活动对象，但当我们实例化新对象时，我们可以重用现有的一个非活动对象，而不是分配更多内存来满足请求。这显著节省了对象创建和销毁期间的运行时CPU成本，并避免了垃圾回收。
- en: 'The following diagram shows the chain of events that needs to occur when **New
    Orc is spawned**:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了当**新兽人**被生成时需要发生的事件链：
- en: '![](img/66c18f0a-1750-47bb-ba14-a631fe3f9bc8.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66c18f0a-1750-47bb-ba14-a631fe3f9bc8.png)'
- en: The first object in the **Inactive** Orc pool (**Orc7**) is reactivated and
    moved into the **Active** pool. We now have six active Orcs and five inactive
    Orcs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**非活动**兽人池中的第一个对象（**兽人7**）被重新激活并移动到**活动**池。我们现在有六个活动的兽人和五个非活动的兽人。'
- en: 'The following diagram shows the order of events when an **Ogre** object is
    despawned:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了当**兽人**对象被销毁时的事件顺序：
- en: '![](img/6f60b2b9-e1fb-40a0-8743-cf891a46b8a5.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f60b2b9-e1fb-40a0-8743-cf891a46b8a5.png)'
- en: This time, the object is deactivated and moved from the **Active** pool into
    the **Inactive** pool, leaving us with one active **Ogre** and four inactive Ogres.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，对象被停用并从**活动**池移动到**非活动**池，留下我们有一个活动的**兽人**和四个非活动的兽人。
- en: 'Finally, the following diagram shows what happens when a new object is spawned,
    but there are no inactive objects to satisfy the request:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下图表展示了当生成新对象时，但没有非活动对象来满足请求会发生什么：
- en: '![](img/ac207546-6fe8-475f-8dcd-fecbec9b3985.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac207546-6fe8-475f-8dcd-fecbec9b3985.png)'
- en: In this scenario, more memory must be allocated to instantiate the new **Dragon**
    object since there are no **Dragon** objects in its **Inactive** pool to reuse.
    Therefore, to avoid runtime memory allocations for our GameObjects, it is critical
    that we know beforehand how many we will need and that there is sufficient memory
    space available to contain them all at once. This will vary depending on the type
    of object in question and requires occasional testing and sanity checking to ensure
    that we have a sensible number of each Prefab instantiated at runtime.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，必须分配更多内存来实例化新的**龙**对象，因为其**非活动**池中没有可重用的**龙**对象。因此，为了避免为我们的GameObject进行运行时内存分配，我们事先知道需要多少以及是否有足够的内存空间一次性容纳它们是至关重要的。这会根据所讨论的对象类型而变化，需要偶尔进行测试和合理性检查，以确保在运行时实例化了合理数量的每个预制件。
- en: With all of this in mind, let's create a pooling system for Prefabs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们为预制件创建一个池化系统。
- en: Poolable components
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可池化组件
- en: 'Let''s first define an interface class for a component that can be used in
    the pooling system:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个用于池化系统的组件的接口类：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The approach for `IPoolableComponent` will be very different from the approach
    taken for `IPoolableObject`. The objects being created this time are GameObjects,
    which are a lot trickier to work with than standard objects because of how much
    of their runtime behavior is already handled through the Unity engine and how
    little low-level access we have to it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`IPoolableComponent`的方法将与`IPoolableObject`的方法大不相同。这次创建的对象是GameObject，与标准对象相比，它们更难以处理，因为它们的运行时行为中有很大一部分是通过Unity引擎处理的，而我们对其的低级访问很少。
- en: GameObjects do not give us access to an equivalent `New()` method that we can
    invoke any time the object is created, and we cannot derive from the `GameObject`
    class to implement one. GameObjects are created either by placing them in a scene
    or by instantiating them at runtime through `GameObject.Instantiate()`, and the
    only inputs we can apply are an initial position and rotation. Of course, their
    components have an `Awake()` callback that we can define, which is invoked the
    first time the component is brought to life, but this is merely a compositional
    object—it's not the actual parent object we're spawning and despawning.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: GameObjects没有提供我们可以随时调用的等效`New()`方法，我们也不能从`GameObject`类派生以实现它。GameObject是通过将它们放置在场景中或在运行时通过`GameObject.Instantiate()`实例化来创建的，我们唯一可以应用的是初始位置和旋转。当然，它们的组件有一个`Awake()`回调，我们可以定义它，它是在组件第一次被激活时调用的，但这仅仅是一个组合对象——它不是我们实际创建和销毁的父对象。
- en: So, because we have control over only a `GameObject` class's components, it
    is assumed that the `IPoolableComponent` interface class is implemented by at
    least one of the components that is attached to the `GameObject` class we wish
    to pool.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，因为我们只能控制`GameObject`类组件，所以假设我们想要池化的`GameObject`类至少有一个组件实现了`IPoolableComponent`接口类。
- en: The `Spawned()` method should be invoked on every implementing component each
    time the pooled `GameObject` class is respawned, while the `Despawned()` method
    gets invoked whenever it is despawned. This gives us entry points to control the
    data variables and behavior during the creation and destruction of the parent
    `GameObject` class.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每次池化的`GameObject`类被重新生成时，应该在每个实现组件上调用`Spawned()`方法，而`Despawned()`方法则在它被销毁时被调用。这为我们提供了在父`GameObject`类的创建和销毁过程中控制数据变量和行为的方法。
- en: 'The act of despawning `GameObject` is trivial: turn its `active` flag to `false`
    through `SetActive()`. This disables `Collider` and `Rigidbody` for physics calculations,
    removes it from the list of renderable objects, and essentially takes care of
    disabling all interactions with all built-in Unity engine subsystems in a single
    stroke. The only exception is any coroutines that are currently invoking on the
    object since, as you learned in [Chapter 2](https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&action=edit#post_44),
    *Scripting Strategies*, coroutines are invoked independently of any `Update()`
    and `GameObject` activity. We will, therefore, need to call `StopCoroutine()`
    or `StopAllCoroutines()` during the despawning of such objects.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁`GameObject`的行为很简单：通过`SetActive()`将其`active`标志设置为`false`。这会禁用`Collider`和`Rigidbody`进行物理计算，将其从可渲染对象列表中移除，并基本上在一次操作中处理与所有内置Unity引擎子系统的所有交互。唯一的例外是当前正在对象上调用的任何协程，因为，正如你在[第2章](https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&action=edit#post_44)中学习的*脚本策略*，协程是独立于任何`Update()`和`GameObject`活动的。因此，在销毁此类对象时，我们需要调用`StopCoroutine()`或`StopAllCoroutines()`。
- en: Also, components typically hook into our own custom gameplay subsystems as well,
    so the `Despawn()` method allows our components to take care of any custom cleanup
    before shutting down. For example, we would probably want to use `Despawn()` to
    deregister the component from the messaging system we defined in [Chapter 2](https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&action=edit#post_44),
    *Scripting Strategies*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件通常也会连接到我们自己的自定义游戏子系统，因此`Despawn()`方法允许我们的组件在关闭之前处理任何自定义清理工作。例如，我们可能希望使用`Despawn()`来从我们在[第2章](https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&action=edit#post_44)中定义的消息系统中注销组件，*脚本策略*。
- en: Unfortunately, successfully respawning the `GameObject` is a lot more complicated.
    When we respawn an object, there will be many settings that were left behind when
    the object was previously active, and these must be reset to avoid conflicting
    behaviors. A common problem with this is the Rigidbody's `linearVelocity` and
    `angularVelocity` properties. If these values are not explicitly reset before
    the object is reactivated, then the newly respawned object will continue moving
    with the same velocity the old version had when it was despawned.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，成功重新生成 `GameObject` 要复杂得多。当我们重新生成一个对象时，会有许多设置在对象之前处于活动状态时被遗留下来的，并且这些设置必须重置以避免冲突行为。这个问题的一个常见问题是
    Rigidbody 的 `linearVelocity` 和 `angularVelocity` 属性。如果这些值在对象重新激活之前没有明确重置，那么新重新生成的对象将继续以旧版本在消失时相同的速度移动。
- en: 'This problem becomes further complicated by the fact that built-in components
    are `sealed`, which means that they cannot be derived from. So, to avoid these
    issues, we can create a custom component that resets the attached `Rigidbody` instance
    whenever the object is despawned:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置组件是 `sealed` 的，这意味着它们不能被继承，这个问题变得更加复杂。所以，为了避免这些问题，我们可以创建一个自定义组件，在对象消失时重置附加的
    `Rigidbody` 实例：
- en: '[PRE34]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the best place to perform the cleanup task is during despawning, because
    we cannot be certain in what order the `GameObject` class's `IPoolableComponent`
    interface classes will have their `Spawned()` methods invoked. It is unlikely
    that another `IPoolableComponent` will change the object's velocity during despawning,
    but it is possible that a different `IPoolableComponent` attached to the same
    object might want to set the Rigidbody's initial velocity to some important value
    during its own `Spawned()` method. Ergo, performing the velocity reset during
    the `ResetPooledRigidbodyComponent` class's `Spawned()` method could potentially
    conflict with other components and cause some very confusing bugs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，执行清理任务的最佳位置是在消失期间，因为我们不能确定 `GameObject` 类的 `IPoolableComponent` 接口类将按什么顺序调用其
    `Spawned()` 方法。在消失期间，另一个 `IPoolableComponent` 改变对象的速率的可能性不大，但可能存在一个附加到同一对象的不同的
    `IPoolableComponent` 希望在其自己的 `Spawned()` 方法中将 Rigidbody 的初始速度设置为某个重要值。因此，在 `ResetPooledRigidbodyComponent`
    类的 `Spawned()` 方法中执行速度重置可能会与其他组件冲突并导致一些非常令人困惑的错误。
- en: In fact, creating poolable components that are not self-contained and tend to
    tinker with other components like this is one of the biggest dangers of implementing
    a pooling system. We should minimize such design and routinely verify them when
    we're trying to debug strange issues in our game.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，创建不是自包含的且倾向于与其他组件（如本例所示）进行交互的池化组件是实现池化系统时最大的危险之一。我们应该最小化这种设计，并在尝试调试游戏中出现的奇怪问题时定期验证它们。
- en: 'For the sake of illustration, here is the definition of a simple poolable component
    making use of the `MessagingSystem` class we defined in Chapter 2, *Scripting
    Strategies*. This component automatically handles some basic tasks every time
    the object is spawned and despawned:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下是定义一个简单的可池化组件的示例，该组件利用我们在第 2 章中定义的 `MessagingSystem` 类。此组件在每次对象生成和消失时自动处理一些基本任务：
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Prefab pooling system
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件池化系统
- en: 'Hopefully, we now have an understanding of what we need from our pooling system,
    so all that''s left is to implement it. The requirements are as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在我们已经理解了我们需要的池化系统，所以剩下的就是实现它。要求如下：
- en: 'It must accept requests to spawn a `GameObject` instance from a Prefab, an
    initial position, and an initial rotation:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须接受请求从 Prefab、初始位置和初始旋转生成 `GameObject` 实例：
- en: If a despawned version already exists, it should respawn the first available
    one
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经存在一个消失的版本，它应该重新生成第一个可用的一个
- en: If it does not exist, then it should instantiate a new `GameObject` instance
    from the Prefab
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不存在，则应该从 Prefab 实例化一个新的 `GameObject` 实例
- en: In either case, the `Spawned()` method should be invoked on all `IPoolableComponent`
    interface classes attached to `GameObject`
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何情况下，都应在附加到 `GameObject` 的所有 `IPoolableComponent` 接口类上调用 `Spawned()` 方法
- en: 'It must accept requests to despawn a specific `GameObject` instance:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须接受请求以消失特定的 `GameObject` 实例：
- en: If the object is managed by the pooling system, it should deactivate it and
    call the `Despawned()` method on all `IPoolableComponent` interface classes attached
    to `GameObject`
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象由池化系统管理，则应将其停用，并在 `GameObject` 上调用所有 `IPoolableComponent` 接口类的 `Despawned()`
    方法
- en: If the object is not managed by the pooling system, it should send an error
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象不由池化系统管理，它应该发送一个错误
- en: 'The requirements are fairly straightforward, but the implementation requires
    some investigation if we wish to make the solution performance-friendly. Firstly,
    a typical singleton would be a good choice for the main entry point since we want
    this system to be globally accessible from anywhere:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要求相当直接，但如果我们希望使解决方案性能友好，实现则需要一些调查。首先，一个典型的单例将是一个好的选择，因为我们希望这个系统可以从任何地方全局访问：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The main task for object spawning involves accepting a Prefab reference and
    figuring whether we have any despawned GameObjects that were originally instantiated
    from the same reference. To do this, we will essentially want our pooling system
    to keep track of two different lists for any given Prefab reference: a list of
    active (spawned) GameObjects and a list of inactive (despawned) objects that were
    instantiated from it. This information would be best abstracted into a separate
    class, which we will name `PrefabPool`.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生成的主任务涉及接受一个Prefab引用，并确定是否有任何原本由同一引用实例化的已销毁GameObject。为此，我们希望我们的池化系统为任何给定的Prefab引用跟踪两个不同的列表：一个活跃（生成）GameObject的列表和一个由它实例化的非活跃（销毁）对象的列表。这些信息最好抽象成一个单独的类，我们将它命名为`PrefabPool`。
- en: To maximize the performance of this system (and hence make the largest gains
    possible, relative to just allocating and deallocating objects from memory all
    of the time), we will want to use some fast data structures in order to acquire
    the corresponding `PrefabPool` objects whenever a spawn or despawn request comes
    in.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化该系统的性能（从而相对于始终从内存中分配和释放对象所能实现的最大增益），我们希望使用一些快速的数据结构，以便在收到任何生成或销毁请求时获取相应的`PrefabPool`对象。
- en: Since spawning involves being given a Prefab, we will want a data structure
    that can quickly map Prefabs to the `PrefabPool` that manages them. Also, since
    despawning involves being given `GameObject`, we will want another data structure
    that can quickly map spawned GameObjects to the `PrefabPool` instance that originally
    spawned them. A pair of dictionaries would be a good choice for both of these
    needs.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成涉及到提供一个Prefab，我们希望有一个可以快速将Prefab映射到管理它们的`PrefabPool`的数据结构。同样，由于销毁涉及到提供一个`GameObject`，我们希望有一个可以快速将生成的GameObject映射到最初生成它们的`PrefabPool`实例的数据结构。一对字典将满足这两个需求。
- en: 'Let''s define these dictionaries in our `PrefabPoolingSystem` class:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`PrefabPoolingSystem`类中定义这些字典：
- en: '[PRE37]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we''ll define what happens when we `Spawn` an object:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义当我们`Spawn`一个对象时会发生什么：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Spawn()` method will be given a `prefab` reference, an initial `position`,
    and an initial `rotation`. We need to figure out which `PrefabPool` the `prefab`
    reference belongs to (if any), ask it to spawn a new `GameObject` instance using
    the data provided, and then return the spawned object to the requestor. We will
    first check our Prefab-to-pool map to check whether a pool already exists for
    this Prefab. If not, we immediately create one. In either case, we then ask `PrefabPool`
    to spawn us a new object. `PrefabPool` will either end up respawning an object
    that was despawned earlier or instantiate a new one (if there aren't any inactive
    instances left).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawn()`方法将提供一个`prefab`引用、一个初始`位置`和一个初始`旋转`。我们需要确定`prefab`引用属于哪个`PrefabPool`（如果有的话），要求它使用提供的数据生成一个新的`GameObject`实例，然后将生成的对象返回给请求者。我们首先检查我们的Prefab-to-pool映射，看看是否已经为这个Prefab创建了一个池。如果没有，我们立即创建一个。在任何情况下，我们都会要求`PrefabPool`为我们生成一个新的对象。`PrefabPool`最终会重新生成一个之前已销毁的对象，或者如果没有剩余的非活跃实例，它会实例化一个新的对象。'
- en: This class doesn't particularly care how `PrefabPool` creates the object. It
    just wants the instance generated by the `PrefabPool` class so that it can be
    entered into the GameObject-to-pool map and returned to the requestor.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并不关心`PrefabPool`如何创建对象。它只想获取由`PrefabPool`类生成的实例，以便将其添加到GameObject-to-pool映射中，并返回给请求者。
- en: 'For convenience, we can also define an overload that places the object at the
    world''s center. This is useful for GameObjects that aren''t visible and just
    need to exist in the scene:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还可以定义一个重载，将对象放置在世界的中心。这对于不可见且只需存在于场景中的GameObject很有用：
- en: '[PRE39]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that no actual spawning and despawning are taking place, yet. This task
    will eventually be implemented within the `PrefabPool` class.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前还没有实际发生生成和销毁。这个任务最终将在`PrefabPool`类中实现。
- en: Despawning involves being given `GameObject` and then figuring out which `PrefabPool`
    is managing it. This could be achieved by iterating through our `PrefabPool` objects
    and checking whether they contain the given `GameObject` instance. However, if
    we end up generating a lot of Prefab pools, then this iterative process can take
    a while. We will always end up with as many `PrefabPool` objects as we have Prefabs
    (at least, so long as we manage all of them through the pooling system). Most
    projects tend to have dozens, hundreds, if not thousands, of different Prefabs.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁涉及接收 `GameObject` 并确定管理它的 `PrefabPool`。这可以通过遍历我们的 `PrefabPool` 对象并检查它们是否包含给定的
    `GameObject` 实例来实现。然而，如果我们最终生成了大量的 Prefab 池，那么这个迭代过程可能需要一段时间。我们最终会有与 Prefab 数量一样多的
    `PrefabPool` 对象（至少，只要我们通过池化系统管理所有这些对象）。大多数项目通常有数十、数百，甚至数千个不同的 Prefab。
- en: 'So, the GameObject-to-pool map is maintained to ensure that we always have
    rapid access to `PrefabPool` that originally spawned the object. It can also be
    used to quickly check whether the given `GameObject` instance is even managed
    by the pooling system to begin with. Here is the method definition for the despawning
    method, which takes care of these tasks:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GameObject 到池的映射被维护，以确保我们始终可以快速访问最初生成对象的 `PrefabPool`。它还可以用来快速检查给定的 `GameObject`
    实例是否从一开始就被池化系统管理。以下是销毁方法的定义，它负责这些任务：
- en: '[PRE40]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the `Despawn()` method of both `PrefabPoolingSystem` and `PrefabPool`
    returns a Boolean that can be used to check whether the object was successfully
    despawned.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PrefabPoolingSystem` 和 `PrefabPool` 的 `Despawn()` 方法都返回一个布尔值，可以用来检查对象是否成功销毁。
- en: As a result, thanks to the two maps we're maintaining, we can quickly access
    the `PrefabPool` instance that manages the given reference, and this solution
    will scale for any number of Prefabs that the system manages.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，多亏了我们维护的两个映射，我们可以快速访问管理给定引用的 `PrefabPool` 实例，并且这个解决方案可以扩展到系统管理的任何数量的 Prefab。
- en: Prefab pools
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prefab 池
- en: 'Now that we have a system that can handle multiple Prefab pools automatically,
    the only thing left is to define the behavior of the pools. As mentioned previously,
    we will want the `PrefabPool` class to maintain two data structures: one for active
    (spawned) objects that have been instantiated from the given Prefab and another
    for inactive (despawned) objects.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以自动处理多个 Prefab 池的系统，剩下要定义的就是池的行为。如前所述，我们希望 `PrefabPool` 类维护两个数据结构：一个用于活动（已生成）对象，这些对象是从给定的
    Prefab 实例化的，另一个用于非活动（已销毁）对象。
- en: Technically, the `PrefabPoolingSystem` class already maintains a map of which
    Prefab is governed by which `PrefabPool`, so we can actually save a little memory
    by making the `PrefabPool` class dependent upon the `PrefabPoolingSystem` class
    to give it the reference to the Prefab it is managing. Consequently, the two data
    structures would be the only member variables `PrefabPool` needs to keep track
    of.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`PrefabPoolingSystem` 类已经维护了一个映射，记录了哪个 Prefab 由哪个 `PrefabPool` 管理，因此我们可以通过使
    `PrefabPool` 类依赖于 `PrefabPoolingSystem` 类来提供它所管理的 Prefab 的引用，从而节省一点内存。因此，这两个数据结构将是
    `PrefabPool` 需要跟踪的唯一成员变量。
- en: 'However, for each spawned `GameObject`, it must also maintain a list of all
    of its `IPoolableComponent` references to invoke the `Spawned()` and `Despawned()`
    methods on them. Acquiring these references can be a costly operation to perform
    at runtime, so it would be best to cache the data in a simple struct:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于每个生成的 `GameObject`，它还必须维护一个包含所有 `IPoolableComponent` 引用的列表，以便在它们上调用 `Spawned()`
    和 `Despawned()` 方法。在运行时获取这些引用可能是一个昂贵的操作，因此最好将这些数据缓存在一个简单的 `struct` 中：
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This `struct` will contain a reference to `GameObject` and the precached list
    of all of its `IPoolableComponent` components.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `struct` 将包含对 `GameObject` 的引用以及所有其 `IPoolableComponent` 组件的预缓存列表。
- en: 'Now, we can define the member data of our `PrefabPool` class:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的 `PrefabPool` 类的成员数据：
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The data structure for the active list should be a dictionary to do a quick
    lookup for the corresponding `PoolablePrefabData` component from any given `GameObject`
    reference. This will be useful during object despawning.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 活动列表的数据结构应该是一个字典，以便从任何给定的 `GameObject` 引用快速查找相应的 `PoolablePrefabData` 组件。这在对象销毁时将非常有用。
- en: Meanwhile, the inactive data structure is defined as `Queue`, but it will work
    equally well as `List`, `Stack`, or really any data structure that needs to regularly
    expand or contract, where we only need to pop items from one end of the group,
    since it does not matter which object it is. It only matters that we retrieve
    one of them. `Queue` is useful in this case because we can both retrieve and remove
    the object from the data structure in a single call to `Dequeue()`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，非活动数据结构被定义为`Queue`，但它也可以同样好地工作作为`List`、`Stack`或任何需要定期扩展或收缩的数据结构，其中我们只需要从组的一端弹出项目，因为哪个对象不重要。重要的是我们能够检索到其中一个。`Queue`在这种情况下很有用，因为我们可以在单个`Dequeue()`调用中从数据结构中检索并移除对象。
- en: Object spawning
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象生成
- en: 'Let''s define what it means to spawn `GameObject` in the context of our pooling
    system: at some point, `PrefabPool` will get a request to spawn `GameObject` from
    a given Prefab, at a particular position and rotation. The first thing we should
    check is whether or not we have any inactive instances of the Prefab. If so, then
    we can dequeue the next available one from `Queue` and respawn it. If not, then
    we need to instantiate a new `GameObject` from the Prefab using `GameObject.Instantiate()`.
    At this moment, we should also create a `PoolablePrefabData` object to store the
    `GameObject` reference and acquire the list of all `MonoBehaviours` that implement
    `IPoolableComponent` that are attached to it.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的池化系统上下文中定义一下“生成`GameObject`”的含义：在某个时刻，`PrefabPool`将接收到一个请求，从特定的预制件生成`GameObject`，并指定其位置和旋转。我们首先应该检查是否有任何非活动状态的预制件实例。如果有，那么我们可以从`Queue`中取出下一个可用的实例并重新生成它。如果没有，那么我们需要使用`GameObject.Instantiate()`从预制件中实例化一个新的`GameObject`。在这个时候，我们还应该创建一个`PoolablePrefabData`对象来存储`GameObject`引用并获取所有附加到其上的实现`IPoolableComponent`的`MonoBehaviours`列表。
- en: Either way, we can now activate `GameObject`, set its position and rotation,
    and call the `Spawned()` method on all of its `IPoolableComponent` references.
    Once the object has been respawned, we can add it to the list of active objects
    and return it to the requestor.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们现在都可以激活`GameObject`，设置其位置和旋转，并在所有`IPoolableComponent`引用上调用`Spawned()`方法。一旦对象被重新生成，我们就可以将其添加到活动对象列表中，并将其返回给请求者。
- en: 'The following is the definition of the `Spawn()` method that defines this behavior:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对定义此行为的`Spawn()`方法的定义：
- en: '[PRE43]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instance prespawning
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例预先生成
- en: Since we are using `GameObject.Instantiate()` whenever the `PrefabPool` has
    run out of despawned instances, this system does not completely rid us of runtime
    object instantiation, hence heap memory allocation. It's important to prespawn
    the expected number of instances that we will need during the lifetime of the
    current scene so that we minimize or remove the need to instantiate more during
    runtime.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们每次`PrefabPool`耗尽已销毁的实例时都会使用`GameObject.Instantiate()`，因此这个系统并不能完全消除我们运行时对象实例化以及堆内存分配的需求。在当前场景的生命周期中，预先生成我们预期需要的实例数量非常重要，这样我们就可以最小化或消除在运行时需要更多实例化的需求。
- en: Note that we shouldn't prespawn too many objects. It would be wasteful to prespawn
    100 explosion particle effects if the most we will ever expect to see in the scene
    at any given time is three or four. Conversely, spawning too few instances will
    cause excessive runtime memory allocations, and the goal of this system is to
    push the majority of allocation to the start of a scene's lifetime. We need to
    be careful about how many instances we maintain in memory so that we don't waste
    more memory space than necessary.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不应该预先生成太多的对象。如果我们预期在任何给定时间内场景中最多只能看到三到四个爆炸粒子效果，那么预先生成100个爆炸粒子效果将是浪费的。相反，生成太少的实例会导致过度的运行时内存分配，而这个系统的目标是尽可能将大多数分配推到场景生命周期的开始。我们需要小心地维护内存中的实例数量，以避免浪费比必要的更多内存空间。
- en: 'Let''s define a method in our `PrefabPoolingSystem` class that we can use to
    quickly prespawn a given number of objects from a Prefab. This essentially involves
    spawning `N` objects and then immediately despawning them all:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`PrefabPoolingSystem`类中定义一个方法，我们可以用它快速从预制件预先生成指定数量的对象。这本质上涉及生成`N`个对象，然后立即销毁它们：
- en: '[PRE44]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We would use this method during scene initialization to prespawn a collection
    of objects to use in the level. Take, for example, the following code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在场景初始化期间使用此方法预先生成一组对象以在关卡中使用。例如，以下代码：
- en: '[PRE45]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Object despawning
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象销毁
- en: Finally, there is the act of despawning the objects. As mentioned previously,
    this primarily involves deactivating the object, but we also need to take care
    of various bookkeeping tasks and invoking `Despawned()` on all of its `IPoolableComponent`
    references.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是对象销毁的行为。如前所述，这主要涉及禁用对象，但我们还需要处理各种账务任务，并在所有`IPoolableComponent`引用上调用`Despawned()`。
- en: 'Here is the method definition for `PrefabPool.Despawn()`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`PrefabPool.Despawn()`方法的定义：
- en: '[PRE46]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we verify that the object is being managed by the pool and then we grab
    the corresponding `PoolablePrefabData` instance to access the list of `IPoolableComponent`
    references. Once `Despawned()` is invoked on all of them, we deactivate the object,
    remove it from the active list, and push it into the inactive queue so that it
    can be respawned later.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们验证对象是否由池管理，然后获取相应的`PoolablePrefabData`实例以访问`IPoolableComponent`引用的列表。一旦在所有这些对象上调用`Despawned()`，我们就禁用对象，将其从活动列表中移除，并将其推入非活动队列，以便稍后重新生成。
- en: Prefab pool testing
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件池测试
- en: 'The following class definition allows us to perform a simple hands-on test
    with the `PrefabPoolingSystem` class; it will support three Prefabs and prespawn
    five instances of each during application initialization. We can press the *1*,
    *2*, *3*, or *4* keys to spawn an instance of each type and then press *Q*, *W*,
    *E*, and *R* to despawn a random instance of each type, respectively:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类定义允许我们对`PrefabPoolingSystem`类进行简单的实际测试；它将在应用程序初始化期间支持三个预制件，并为每个预制件预先生成五个实例。我们可以按*1*、*2*、*3*或*4*键生成每种类型的一个实例，然后按*Q*、*W*、*E*和*R*键分别销毁每种类型的随机实例：
- en: '[PRE47]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once we spawn more than five instances of any of the Prefabs, it will need to
    instantiate a new one in memory, costing us some memory allocation. However, if
    we observe the Memory Area in the Profiler window, while we only spawn and despawn
    instances that already exist, then we will notice that absolutely no new allocations
    take place.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为任何预制件生成超过五个实例，它将需要在内存中实例化一个新的实例，这会消耗一些内存分配。然而，如果我们观察Profiler窗口中的内存区域，当我们只生成和销毁已存在的实例时，我们会注意到绝对没有新的分配发生。
- en: Prefab pooling and scene loading
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件池化和场景加载
- en: 'There is one important caveat to this system that has not yet been mentioned:
    the `PrefabPoolingSystem` class will outlast the scene''s lifetime since it is
    a static class. This means that when a new scene is loaded, the pooling system''s
    dictionaries will attempt to maintain references to any pooled instances from
    the previous scene, but Unity forcibly destroys these objects regardless of the
    fact that we are still keeping references to them (unless they were set to `DontDestroyOnLoad()`),
    and so the dictionaries will be full of `null` references. This would cause some
    serious problems for the next scene.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统有一个重要但尚未提到的注意事项：`PrefabPoolingSystem`类将超出场景的生命周期，因为它是一个静态类。这意味着当加载新场景时，池化系统的字典将尝试维持对前一个场景中任何池化实例的引用，但Unity会强制销毁这些对象，无论我们是否仍然保留对这些对象的引用（除非它们被设置为`DontDestroyOnLoad()`），因此字典将充满`null`引用。这会给下一个场景带来一些严重问题。
- en: 'We should, therefore, create a method in `PrefabPoolingSystem` that resets
    the pooling system in preparation for this likely event. The following method
    should be called before a new scene is loaded so that it is ready for any early
    calls to `Prespawn()` in the next scene:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该在`PrefabPoolingSystem`中创建一个方法，以便为这个可能的事件重置池化系统。在加载新场景之前应该调用以下方法，以确保它为下一个场景中`Prespawn()`的早期调用做好准备：
- en: '[PRE48]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that if we also invoke a garbage collection during scene transitions, there's
    no need to explicitly destroy the `PrefabPool` objects these dictionaries were
    referencing. Since these were the only references to the `PrefabPool` objects,
    they will be deallocated during the next garbage collection. If we aren't invoking
    garbage collection between scenes, then the `PrefabPool` and `PooledPrefabData`
    objects will remain in memory until that time.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们还在场景转换期间调用垃圾回收，就没有必要明确销毁这些字典所引用的`PrefabPool`对象。因为这些是`PrefabPool`对象的唯一引用，它们将在下一次垃圾回收期间被回收。如果我们不在场景之间调用垃圾回收，那么`PrefabPool`和`PooledPrefabData`对象将保留在内存中，直到那时。
- en: Prefab pooling summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件池化总结
- en: 'This pooling system provides a decent solution to the problem of runtime memory
    allocations for GameObjects and Prefabs, but, as a quick reminder, we need to
    be aware of the following caveats:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此池化系统为GameObject和Prefab的运行时内存分配问题提供了一个不错的解决方案，但作为一个快速提醒，我们需要注意以下注意事项：
- en: We need to be careful about properly resetting important data in respawned objects
    (such as `Rigidbody` velocity)
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要小心正确重置重生对象中的重要数据（例如`Rigidbody`速度）。
- en: We must ensure that we don't prespawn too few, or too many, instances of a Prefab
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须确保我们不会预先生成太多或太少Prefab的实例。
- en: We should be careful of the order of execution of `Spawned()` and `Despawned()`
    methods on `IPoolableComponent` and not assume that they will be called in a particular
    order
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该小心`IPoolableComponent`上的`Spawned()`和`Despawned()`方法的执行顺序，不要假设它们将以特定的顺序被调用。
- en: We must call `Reset()` on `PrefabPoolingSystem` when loading a new scene to
    clear any `null` references to objects, which may no longer exist
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当加载新场景时，我们必须在`PrefabPoolingSystem`上调用`Reset()`以清除任何不再存在的对象的`null`引用。
- en: 'There are several other features that we could implement. These will be left
    as academic exercises if we wish to extend this system in the future:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一些其他功能。如果希望在将来扩展此系统，这些功能将被留作学术练习：
- en: Any `IPoolableComponent` added to the `GameObject` after initialization will
    not have their `Spawned()` or `Despawned()` methods invoked since we only collect
    this list when `GameObject` is first instantiated. We could fix this by changing
    `PrefabPool` to keep acquiring `IPoolableComponent` references every time `Spawned()`
    and `Despawned()` are invoked at the cost of additional overhead during spawning/despawning.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始化后添加到`GameObject`的任何`IPoolableComponent`都不会调用其`Spawned()`或`Despawned()`方法，因为我们只在`GameObject`首次实例化时收集这个列表。我们可以通过将`PrefabPool`更改为每次`Spawned()`和`Despawned()`被调用时都获取`IPoolableComponent`引用来修复这个问题，但这可能会在生成/销毁期间增加额外的开销。
- en: Any `IPoolableComponent` attached to children of the Prefab's root will also
    not be counted. This could be fixed by changing `PrefabPool` to use `GetComponentsInChildren<T>`
    at the cost of additional overhead if we're using Prefabs with deep hierarchies.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到Prefab根节点子节点的任何`IPoolableComponent`也不会被计算。这可以通过将`PrefabPool`更改为使用`GetComponentsInChildren<T>`来修复，但这可能会增加额外的开销，如果我们使用具有深层层次结构的Prefab。
- en: Prefab instances that already exist in the scene will not be managed by the
    pooling system. We could create a component that needs to be attached to such
    objects and that notifies the `PrefabPoolingSystem` class of its existence in
    its `Awake()` callback, which passes the reference along to the corresponding
    `PrefabPool`.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中已经存在的Prefab实例将不会被池化系统管理。我们可以创建一个需要附加到此类对象上的组件，并在其`Awake()`回调中通知`PrefabPoolingSystem`类其存在，并将引用传递给相应的`PrefabPool`。
- en: We could implement a way for `IPoolableComponent` to set a priority during acquisition
    and directly control the order of execution for their `Spawned()` and `Despawned()`
    methods.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以实现一种方法，让`IPoolableComponent`在获取时设置一个优先级，并直接控制其`Spawned()`和`Despawned()`方法的执行顺序。
- en: We could add counters that keep track of how long objects have been sitting
    in the Inactive list relative to total scene lifetime and print out the data during
    shutdown. This could tell us whether or not we're prespawning too many instances
    of a given Prefab.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加计数器，跟踪对象在Inactive列表中相对于整个场景生命周期的持续时间，并在关闭时打印出数据。这可以告诉我们是否预先生成了太多给定Prefab的实例。
- en: This system will not interact kindly with Prefab instances that set themselves
    to `DontDestroyOnLoad()`. It might be wise to add a Boolean to every `Spawn()`
    call to say whether the object should persist or not and keep them in a separate
    data structure that is not cleared out during `Reset()`.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个系统不会友好地与设置为`DontDestroyOnLoad()`的Prefab实例交互。可能明智的做法是为每个`Spawn()`调用添加一个布尔值，以说明对象是否应该持续存在，并将它们保存在一个在`Reset()`期间不会被清除的单独数据结构中。
- en: We could change `Spawn()` to accept an argument that allows the requestor to
    pass custom data to the `Spawned()` function of `IPoolableObject` for initialization
    purposes. This could use a system similar to how custom message objects were derived
    from the `Message` class for our messaging system in [Chapter 2](https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&action=edit#post_44),
    *Scripting Strategies*.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将`Spawn()`函数修改为接受一个参数，允许请求者传递自定义数据到`IPoolableObject`的`Spawned()`函数，用于初始化目的。这可以采用与[第2章](https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&action=edit#post_44)中我们消息系统的`Message`类派生自定义消息对象类似的方法，*脚本策略*。
- en: IL2CPP optimizations
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IL2CPP优化
- en: 'Unity Technologies have released a few blog posts on interesting ways to improve
    the performance of IL2CPP in some circumstances, but they can be difficult to
    manage. If you''re using IL2CPP and need to eke out the last little bit of performance
    from our application that we can, then check out the blog series at the following
    links:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Technologies发布了一些关于在特定情况下提高IL2CPP性能的有趣方法的博客文章，但它们可能难以管理。如果你使用IL2CPP并且需要从我们的应用程序中榨取最后一点性能，那么请查看以下链接中的博客系列：
- en: '[https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/](https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/](https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/)'
- en: '[https://blogs.unity3d.com/2016/08/04/il2cpp-optimizations-faster-virtual-method-calls/](https://blogs.unity3d.com/2016/08/04/il2cpp-optimizations-faster-virtual-method-calls/)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.unity3d.com/2016/08/04/il2cpp-optimizations-faster-virtual-method-calls/](https://blogs.unity3d.com/2016/08/04/il2cpp-optimizations-faster-virtual-method-calls/)'
- en: '[https://blogs.unity3d.com/2016/08/11/il2cpp-optimizations-avoid-boxing/](https://blogs.unity3d.com/2016/08/11/il2cpp-optimizations-avoid-boxing/)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.unity3d.com/2016/08/11/il2cpp-optimizations-avoid-boxing/](https://blogs.unity3d.com/2016/08/11/il2cpp-optimizations-avoid-boxing/)'
- en: WebGL optimizations
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL优化
- en: 'Unity Technologies have also released several blog posts covering WebGL applications,
    which includes some crucial information about memory management that all WebGL
    developers should know. These can be found at the following links:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Technologies还发布了几篇关于WebGL应用的博客文章，其中包含所有WebGL开发者都应该了解的关于内存管理的关键信息。这些文章可以在以下链接中找到：
- en: '[https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/](https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/](https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/)'
- en: '[https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/](https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/](https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/)'
- en: Summary
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered a humongous amount of theory and language concepts in this chapter,
    which have hopefully shed some light on how the internals of the Unity engine
    and C# language work. These tools try their best to spare us from the burden of
    complex memory management, but there is still a whole host of concerns we need
    to keep in mind as we develop our game. Between the compilation processes, multiple
    memory domains, the complexities of value types versus reference types, passing
    by value versus passing by reference, boxing, object pooling, and various quirks
    within the Unity API, you have a lot of things to worry about. However, with enough
    practice, you will learn to overcome them without needing to keep referring to
    giant tomes such as this!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的理论和语言概念，希望这些内容能帮助大家了解Unity引擎和C#语言的内部工作原理。这些工具尽力减轻我们复杂内存管理的负担，但在开发游戏的过程中，我们仍需关注一系列问题。在编译过程、多个内存域、值类型与引用类型的复杂性、按值传递与按引用传递、装箱、对象池以及Unity
    API中的各种怪癖等方面，你有很多事情需要担心。然而，通过足够的实践，你将学会克服这些问题，而无需不断查阅像这样的大部头！
- en: With this chapter, we have covered all of the possible optimization areas in
    classic Unity. However, with the 2019.1 release, Unity officially introduced the
    **Data-Oriented Technology Stack** (**DOTS**), a set of new fundamental APIs to
    access a completely new optimization level, especially in modern massively multi-threading
    systems. Follow me to the next chapter, where we will explore this new frontier.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们已经涵盖了经典Unity中所有可能的优化区域。然而，随着2019.1版本的发布，Unity官方引入了**面向数据的技术堆栈**（**DOTS**），一套全新的基本API，用于访问一个全新的优化级别，尤其是在现代大规模多线程系统中。跟随我进入下一章，我们将探索这个新的前沿领域。
