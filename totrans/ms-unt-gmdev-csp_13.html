<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-121"><a id="_idTextAnchor127" class="calibre6 pcalibre1 pcalibre"/>8</h1>
<h1 id="_idParaDest-122" class="calibre5"><a id="_idTextAnchor128" class="calibre6 pcalibre1 pcalibre"/> Implementing External Assets, APIs, and Pre-Built Components with C# in Unity</h1>
<p class="calibre3">Welcome to <a href="B22017_08.xhtml#_idTextAnchor127" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 8</em></a>, where we will delve into essential aspects of game development using C#. We will begin by exploring the integration of pre-built assets, a fundamental skill for enhancing game visuals and performance. Then, we will delve into the integration of rendering pipelines, which is crucial for optimizing game visuals and achieving better performance. After that, we will discuss the significance of backend services in game development, focusing on authentication logic as a prime example of their importance. Lastly, we will explore analytics APIs and their pivotal role in understanding player behavior and optimizing game performance. Throughout this chapter, I’ll demonstrate how to implement these key components into our game, empowering you to create immersive and engaging gaming experiences.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Leveraging pre-built assets with C#</li>
<li class="calibre11">Integrating backend services with C#</li>
<li class="calibre11">Integrating analytics APIs with C#</li>
</ul>
<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor129" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">All the code files of this chapter can be found at: <a href="B22017_08.xhtml#_idTextAnchor127" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2008</a>.</p>
<h1 id="_idParaDest-124" class="calibre5"><a id="_idTextAnchor130" class="calibre6 pcalibre1 pcalibre"/>Leveraging pre-built assets with C#</h1>
<p class="calibre3">In the vast world <a id="_idIndexMarker474" class="calibre6 pcalibre1 pcalibre"/>of game development, time is as valuable as the pixels on our screens. Every moment counts, and each bit of code shapes the worlds players will explore. This is where third-party assets come in handy—they are efficient tools that enhance creativity in the changing landscape of game design.</p>
<p class="calibre3">Imagine this: you’re a new game developer with a bright vision. You dream of vast landscapes, detailed character animations, and sounds that take players to faraway lands. However, the journey from idea to reality is full of challenges, and time is hard to come by.</p>
<p class="calibre3">Third-party assets, often underappreciated in game development, play a crucial role. These readily available resources form the backbone of game creation, bringing virtual worlds to fruition. From grand landscapes to subtle environmental details, third-party assets simplify the complex task of asset creation, allowing us to focus on refining gameplay and improving player experiences.</p>
<p class="calibre3"><em class="italic">But why are they so important?</em> Firstly, third-party assets offer a wealth of resources created by experts. Whether you need stunning environments, realistic characters, or chilling sound effects, the vast array of third-party assets has it all. These assets fuel creativity, sparking imagination and helping us turn ideas into reality quickly.</p>
<p class="calibre3">Furthermore, the benefits go beyond convenience. By using pre-built assets, we can focus on the core of our games—the gameplay itself. Free from creating assets, they can craft immersive worlds, compelling stories, and unforgettable experiences that capture players’ hearts and endure over time.</p>
<p class="calibre3">In this section, we’ll explore the utilization of pre-built assets available in Unity’s Package Manager, such as <strong class="bold">URP</strong>, which provides advanced rendering options. Let’s begin our exploration.</p>
<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor131" class="calibre6 pcalibre1 pcalibre"/>Universal Render Pipeline (URP)</h2>
<p class="calibre3">In this <a id="_idIndexMarker475" class="calibre6 pcalibre1 pcalibre"/>section, we’ll explore the <strong class="bold">Universal Render Pipeline </strong>(<strong class="bold">URP</strong>), a powerful tool that helps create stunning visuals and optimize performance in our Unity projects.</p>
<p class="calibre3">URP is a rendering solution provided by Unity Technologies. It’s designed to strike a balance between visual quality and performance, making it suitable for a wide range of platforms and devices, including mobile, consoles, and PCs.</p>
<p class="calibre3">URP offers a<a id="_idIndexMarker476" class="calibre6 pcalibre1 pcalibre"/> flexible and efficient rendering pipeline that allows for the creation of visually appealing games while ensuring smooth performance across different hardware configurations. Whether you’re creating a stylized indie game or a realistic AAA title, URP provides the tools and features needed to bring your vision to life.</p>
<h3 class="calibre9">Choosing between Unity’s render pipelines – URP versus HDRP</h3>
<p class="calibre3">Unity offers<a id="_idIndexMarker477" class="calibre6 pcalibre1 pcalibre"/> two distinct rendering pipelines, URP and the <strong class="bold">High-Definition Render Pipeline </strong>(<strong class="bold">HDRP</strong>), each tailored to different <a id="_idIndexMarker478" class="calibre6 pcalibre1 pcalibre"/>needs and requirements in game development. Let’s explore the key differences between the two and the reasons why you might choose one over the other for your game.</p>
<p class="calibre3">In the following table, I’ve outlined a comparison between Unity’s render pipelines, highlighting key points to assist you in determining the most suitable pipeline for your project.</p>
<table class="no-table-style" id="table001-3">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Aspect</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">URP</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">HDRP</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Graphics Fidelity</p>
</td>
<td class="no-table-style2">
<p class="calibre3">URP is designed for optimized rendering performance while maintaining a balance between visual quality and efficiency. It supports features such as real-time lighting, shadows, and post-processing effects.</p>
</td>
<td class="no-table-style2">
<p class="calibre3">HDRP aims to deliver high-quality visuals and graphical fidelity, especially for high-end platforms such as PCs and consoles. It offers advanced rendering features such as physically based rendering and volumetric lighting.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Platform Compatibility</p>
</td>
<td class="no-table-style2">
<p class="calibre3">URP is optimized for cross-platform development, making it suitable for a diverse range of devices and platforms, including mobile devices, consoles, and PCs.</p>
</td>
<td class="no-table-style2">
<p class="calibre3">HDRP is tailored for high-end platforms and may require more powerful hardware to achieve optimal performance. It may not be as suitable for mobile devices or lower-end PCs due to its higher demands</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Art Style and Visual Direction</p>
</td>
<td class="no-table-style2">
<p class="calibre3">URP is versatile and accommodates a wide range of art styles and visual directions, including stylized, cartoonish, or realistic art styles. It allows for visually appealing results across different genres and themes.</p>
</td>
<td class="no-table-style2">
<p class="calibre3">HDRP is well suited for projects aiming for photorealistic graphics and immersive visual experiences. It offers advanced rendering features and high-fidelity effects enhancing realism and immersion.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Development Time and Resources</p>
</td>
<td class="no-table-style2">
<p class="calibre3">URP provides a balance between visual quality and development efficiency with a streamlined workflow and easier setup. It is accessible to developers with limited resources or time constraints.</p>
</td>
<td class="no-table-style2">
<p class="calibre3">HDRP offers advanced features and graphical capabilities, but it may require additional development time and resources to fully leverage its potential. It needs careful optimization and tuning for desired performance.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3">In summary, the<a id="_idIndexMarker479" class="calibre6 pcalibre1 pcalibre"/> choice between URP and HDRP depends on various factors, including your project’s target platforms, desired graphical fidelity, art style, and available development resources. If you prioritize performance, cross-platform compatibility, and a balance between visual quality and efficiency, URP may be the preferable option. On the other hand, if your project demands high-end visuals, photorealism, and advanced graphical effects, HDRP may be the better choice, provided you have the necessary resources and hardware to support it.</p>
<p class="calibre3">Now that we have understood the contrast between the two distinct rendering pipelines in Unity, let’s proceed to install URP.</p>
<h3 class="calibre9">Installing URP into our project</h3>
<p class="callout-heading">Important note</p>
<p class="callout">Before upgrading to a custom render pipeline, it’s essential to back up your project.</p>
<p class="calibre3">We’ve <a id="_idIndexMarker480" class="calibre6 pcalibre1 pcalibre"/>already chosen the URP package for our project. However, if it hasn’t been configured in your project yet, you can simply access <strong class="bold">Package Manager</strong> and select the <strong class="bold">Universal RP</strong> option, as you can see in <em class="italic">Figure 8</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 8.1 – Installing the URP package" src="img/B22017_08_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Installing the URP package</p>
<p class="calibre3">When you click on <strong class="bold">Install</strong>, Unity will install the package and its dependencies.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are migrating from the built-in pipeline to URP or High-Definition RP, there are specific instructions to adhere to. You’ll need to adjust all materials to utilize the new shaders provided by these packages. However, given that our game has been utilizing these packages from the outset, imported files such as model materials will already be configured to use the shaders provided by those packages.</p>
<p class="calibre3">Since<a id="_idIndexMarker481" class="calibre6 pcalibre1 pcalibre"/> migrating from the built-in is not our primary objective, I won’t delve into upgrading to URP. You can explore additional possibilities by referring to the official documentation:</p>
<ul class="calibre10">
<li class="calibre11">If you are using URP version 13.1 or newer, there is a built-in converter available. Please refer to this page for more information on how to utilize this converter: <strong class="source-inline1">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/features/rp-converter.html</strong>.</li>
<li class="calibre11">If you are using a URP version prior to 13.1, you need to refer to this link: <strong class="source-inline1">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.0/manual/upgrading-your-shaders.html</strong>.</li>
</ul>
<p class="calibre3">In the next subsection, we will discover the power of Unity’s URP, a versatile package offering optimized rendering, custom shaders, and enhanced lighting for creating visually stunning projects across multiple platforms.</p>
<h3 class="calibre9">Exploring URP in Unity – features and functionality</h3>
<p class="calibre3">The URP <a id="_idIndexMarker482" class="calibre6 pcalibre1 pcalibre"/>package in Unity provides developers with a range of features and functionalities to enhance the rendering capabilities of their projects. Here are some key aspects of the<a id="_idIndexMarker483" class="calibre6 pcalibre1 pcalibre"/> URP package and its usage:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Optimized rendering pipeline</strong>: URP offers an optimized rendering pipeline designed to balance performance and visual quality across various platforms and devices. It includes features such as deferred and forward rendering paths, allowing us to choose the rendering technique that best suits their project’s requirements.</li>
<li class="calibre11"><strong class="bold">Lightweight rendering</strong>: URP is designed to be lightweight, making it suitable for projects targeting mobile devices, lower-end hardware, and performance-conscious applications. It optimizes rendering processes to achieve smooth performance while maintaining visual fidelity.</li>
<li class="calibre11"><strong class="bold">Shader graph integration</strong>: URP seamlessly integrates with Unity’s Shader Graph tool, allowing us to create custom shaders and visual effects without writing code. Shader Graph empowers us to design complex materials, lighting effects, and post-processing effects through a node-based interface.</li>
<li class="calibre11"><strong class="bold">Custom rendering features</strong>: URP provides support for custom rendering features<a id="_idIndexMarker484" class="calibre6 pcalibre1 pcalibre"/> through <strong class="bold">Scriptable Render Pipeline</strong> (<strong class="bold">SRP</strong>) extensions. We can extend<a id="_idIndexMarker485" class="calibre6 pcalibre1 pcalibre"/> and customize the rendering <a id="_idIndexMarker486" class="calibre6 pcalibre1 pcalibre"/>pipeline by implementing custom render passes, post-processing effects, and shader variants.</li>
<li class="calibre11"><strong class="bold">Enhanced lighting system</strong>: URP includes a flexible lighting system that supports real-time lighting, shadows, and reflections. It offers features such as per-object and per-pixel lighting, dynamic shadows, and light probes for realistic lighting effects.</li>
<li class="calibre11"><strong class="bold">Post-processing effects</strong>: URP includes built-in support for post-processing effects, allowing us to enhance the visual quality of their scenes. It provides a range of post-processing effects such as bloom, depth of field, color grading, and ambient occlusion.</li>
<li class="calibre11"><strong class="bold">Cross-platform compatibility</strong>: URP is designed for cross-platform compatibility, enabling us to create games and applications for various platforms, including mobile devices, consoles, and PCs. It optimizes rendering performance across different hardware configurations and platform specifications.</li>
</ul>
<p class="calibre3">In summary, the URP package in Unity provides us with a lightweight, flexible, and optimized rendering solution for creating visually stunning and performance-efficient projects. From lighting and shading to post-processing effects and custom rendering features, URP empowers us to bring their creative visions to life while ensuring optimal performance across different platforms and devices.</p>
<p class="calibre3">Next, we’ll explore more advanced topics, such as render callbacks and custom render features.</p>
<h3 class="calibre9">Mastering visual modifications in Unity – advanced techniques with URP and C#</h3>
<p class="calibre3">Introducing <a id="_idIndexMarker487" class="calibre6 pcalibre1 pcalibre"/>advanced techniques in URP using C# can greatly modify the visual quality and performance of your Unity projects. Two key features that we can explore and discuss in this section are Custom Render Passes and Render Pipeline Callbacks:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Custom </strong><strong class="bold">Render Passes</strong>:<ul class="calibre16"><li class="calibre11">Custom Render Passes allow you to inject custom rendering logic into the render pipeline, enabling you to implement specialized effects or optimizations beyond the built-in features of URP.</li><li class="calibre11">With Custom Render Passes, you have fine-grained control over the rendering process at various stages, such as before or after opaque rendering, before or after transparent rendering, or even in between specific render queues.</li><li class="calibre11">You can use Custom Render Passes to implement effects like outline rendering, screen-space effects, custom post-processing, or optimizations such as rendering additional buffers for custom shaders or computations.</li></ul></li>
<li class="calibre11"><strong class="bold">Render </strong><strong class="bold">Pipeline Callbacks</strong>:<ul class="calibre16"><li class="calibre11">Render Pipeline Callbacks provide a mechanism for hooking into specific events and stages within the render pipeline to execute custom C# code.</li><li class="calibre11">Using Render Pipeline Callbacks, you can perform tasks such as modifying materials, adjusting rendering settings dynamically, or injecting custom rendering logic at specific points in the rendering process.</li><li class="calibre11">Render Pipeline Callbacks can be used to implement advanced features such as dynamic material modifications based on game events, procedural generation of textures or geometry, or applying custom shader effects based on runtime conditions.</li></ul></li>
</ul>
<p class="calibre3">Next, let’s explore an example that demonstrates the application of these advanced techniques within our project.</p>
<h3 class="calibre9">Illustration of implementing advanced techniques</h3>
<p class="calibre3">Here is a<a id="_idIndexMarker488" class="calibre6 pcalibre1 pcalibre"/> step-by-step guide, illustrated with examples, on how to utilize these advanced techniques to create and control the outline effect:</p>
<ol class="calibre15">
<li class="calibre11">Before creating the renderer feature, ensure that your project is configured to use the URP renderer data in your <strong class="bold">Quality and Graphics</strong> settings within the <strong class="bold">Project Settings</strong>. Right-click in your <strong class="bold">Project</strong> tab and navigate to <strong class="bold">Create | Rendering | URP Renderer Feature</strong> to generate a new feature script. You can name it <strong class="source-inline1">OutlineEffect</strong>:</li>
</ol>
<div><div><img alt="Figure 8.2 – Creating an URP Renderer Feature script" src="img/B22017_08_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Creating an URP Renderer Feature script</p>
<ol class="calibre15">
<li value="2" class="calibre11">Next, we open the <strong class="source-inline1">OutlineEffect</strong> script and make modifications as outlined in the<a id="_idIndexMarker489" class="calibre6 pcalibre1 pcalibre"/> following code block:<pre class="source-code">
public class OutlineEffect : ScriptableRendererFeature
{
    class OutlineRenderPass : ScriptableRenderPass
    {
        public List&lt;Material&gt; outlineMaterials;
        public OutlineRenderPass(List&lt;Material&gt; materials)
        {
            this.outlineMaterials = materials;
            renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
        }
        // This method is called before executing the render pass..
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {
        }
        // Here you can implement the rendering logic.
        // Use &lt;c&gt;ScriptableRenderContext&lt;/c&gt; to issue drawing commands or execute command buffers
        // https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.html
        // You don't have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get("OutlineRenderPass");
            // Set the render target to the camera's depth buffer
            cmd.SetRenderTarget(renderingData.cameraData.renderer.cameraDepthTargetHandle);
            // Clear the depth buffer to ensure the outline is rendered correctly
            cmd.ClearRenderTarget(false, true, Color.clear);
            var settings = new DrawingSettings(new ShaderTagId("UniversalForward"), new SortingSettings(renderingData.cameraData.camera));
            var filterSettings = new FilteringSettings(RenderQueueRange.opaque);
            context.DrawRenderers(renderingData.cullResults, ref settings, ref filterSettings);
            // Draw objects with outline materials
            // Draw objects with outline materials
            foreach (Material material in outlineMaterials)
            {
                var drawSettings = new DrawingSettings(new ShaderTagId("Outline"), new SortingSettings(renderingData.cameraData.camera))
                {
                    overrideMaterial = material
                };
                var filterSettingsOutline = new FilteringSettings(RenderQueueRange.opaque);
                context.DrawRenderers(renderingData.cullResults, ref drawSettings, ref filterSettingsOutline);
            }
            context.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
        }
        // Cleanup any allocated resources that were created during the execution of this render pass.
        public override void OnCameraCleanup(CommandBuffer cmd)
        {
        }
    }
    OutlineRenderPass outlinePass;
    public List&lt;Material&gt; outlineMaterials;
    /// &lt;inheritdoc/&gt;
    public override void Create()
    {
        outlinePass = new OutlineRenderPass(outlineMaterials);
        outlinePass.renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
    }
    // Here you can inject one or multiple render passes in the renderer.
    // This method is called when setting up the renderer once per-camera.
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        renderer.EnqueuePass(outlinePass);
    }
}</pre><p class="calibre3">Let’s break down<a id="_idIndexMarker490" class="calibre6 pcalibre1 pcalibre"/> the previous code to explain what each part does:</p><ul class="calibre16"><li class="calibre11">The <code>OutlineEffect</code> class defines a custom renderer feature that adds an outline effect to objects in the scene by utilizing a custom render pass (<code>OutlineRenderPass</code>) with a list of outline materials. The <code>OutlineRenderPass</code> class implements the rendering logic for applying the outline effect to objects during the rendering process.</p></li> <li class="calibre11">Next, you<a id="_idIndexMarker492" class="calibre6 pcalibre1 pcalibre"/> can integrate the feature into your URP data scriptable object. You can customize the settings according to your game’s requirements. For our demonstration, I’ve retained the default settings, as depicted in <em class="italic">Figure 8</em><em class="italic">.3</em>:</li>
</ol>
<div><div><img alt="Figure 8.3 – Adding OutlineEffect Feature" src="img/B22017_08_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Adding OutlineEffect Feature</p>
<p class="calibre3">You can<a id="_idIndexMarker493" class="calibre6 pcalibre1 pcalibre"/> include additional features to achieve your desired visual effects. Furthermore, you can refer to Unity’s official documentation for further details using the following link: <code>https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/index.html</code>.</p>
<p class="calibre3">In the following figure, you will observe the disparity before and after applying the feature:</p>
<div><div><img alt="Figure 8.4 –OutlineEffect feature effect" src="img/B22017_08_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4 –OutlineEffect feature effect</p>
<p class="calibre3">Discover the significant impact and benefits of leveraging the render pass feature for optimizing rendering and enhancing visual effects.</p>
<h3 class="calibre9">What is the purpose of utilizing the render pass feature?</h3>
<p class="calibre3">Using <a id="_idIndexMarker494" class="calibre6 pcalibre1 pcalibre"/>render passes in conjunction with the URP offers several benefits for implementing an outline effect:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Modularity and extensibility</strong>: By utilizing render passes, you can modularize your rendering pipeline and separate specific rendering tasks into distinct passes. This makes your rendering pipeline more flexible and easier to maintain. You can add or remove passes as needed without affecting other parts of the pipeline.</li>
<li class="calibre11"><strong class="bold">Performance optimization</strong>: Render passes in URP allow you to control the order in which rendering tasks are executed. This enables you to optimize performance by efficiently batching and sorting objects, reducing overdraw, and minimizing unnecessary render calls. For the outline effect, you can ensure that only<a id="_idIndexMarker495" class="calibre6 pcalibre1 pcalibre"/> the necessary objects are rendered with the outline material, reducing the computational overhead.</li>
<li class="calibre11"><strong class="bold">Integration with URP’s rendering pipeline</strong>: URP provides a streamlined rendering pipeline optimized for performance across various platforms. By integrating your custom rendering effects, such as the outline effect, into URP’s pipeline using render passes, you ensure compatibility and consistency with URP’s rendering features and optimizations.</li>
<li class="calibre11"><strong class="bold">Consistency across platforms</strong>: URP is designed to provide consistent rendering results across different platforms and devices, including desktop, mobile, and consoles. By leveraging URP’s features, you can ensure that your outline effect behaves predictably and performs optimally across a wide range of target platforms.</li>
<li class="calibre11"><strong class="bold">Shader graph integration</strong>: URP seamlessly integrates with Unity’s Shader Graph tool, allowing you to create custom shaders visually without writing code. You can use Shader Graph to design the outline shader and easily incorporate it into your render pass, making the implementation process more accessible and intuitive.</li>
</ul>
<p class="calibre3">Overall, while it’s possible to apply the outline effect directly without utilizing URP’s render pass feature, integrating it with URP offers advantages in terms of performance optimization, modularity, consistency, and compatibility with Unity’s rendering pipeline. It provides a more robust and flexible solution for implementing custom rendering effects in your Unity projects.</p>
<p class="calibre3">Game development benefits from pre-built assets and C# scripts, saving time and enhancing creativity. Unity’s URP optimizes visuals and performance. Understanding URP versus HDRP aids pipeline selection. URP setup involves package installation and configuration. URP features include lightweight rendering, Shader Graph integration, and advanced techniques such as Custom Render Passes. Render passes in URP offer modularity and performance optimization.</p>
<p class="calibre3">In the upcoming section, we’ll explore integrating backend services, understanding their significance in game development, and the reasons for their necessity. Additionally, I’ll illustrate their usage through an example featuring one of the availabl<a id="_idTextAnchor132" class="calibre6 pcalibre1 pcalibre"/>e services.</p>
<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor133" class="calibre6 pcalibre1 pcalibre"/>Integrating backend services with C#</h1>
<p class="calibre3">In this<a id="_idIndexMarker496" class="calibre6 pcalibre1 pcalibre"/> section, we will understand how the integration of backend APIs with C# provides us with a potent tool to enrich our projects with robust functionalities. Through the utilization of these APIs, we can seamlessly link their Unity projects to external services, facilitating features such as user authentication, data storage, and leaderboards.</p>
<p class="calibre3">Let’s explore backend services and understand their significance in games.</p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor134" class="calibre6 pcalibre1 pcalibre"/>Backend services</h2>
<p class="calibre3">Backend services<a id="_idIndexMarker497" class="calibre6 pcalibre1 pcalibre"/> refer to the set of functionalities and infrastructure components that support the operation of software applications, including games, from the server-side perspective. In the context of game development, backend services encompass various features and capabilities designed to enhance gameplay experiences, manage player data, and facilitate online interactions. Here are some key aspects of backend services in game development:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Data storage</strong>: Provides<a id="_idIndexMarker498" class="calibre6 pcalibre1 pcalibre"/> storage solutions for game-related data, including player profiles, game progress, achievements, inventory, and other persistent game state information. This data is typically stored in databases or cloud storage systems, ensuring reliability, scalability, and accessibility across different platforms and devices.</li>
<li class="calibre11"><strong class="bold">User authentication</strong>: Offers <a id="_idIndexMarker499" class="calibre6 pcalibre1 pcalibre"/>authentication mechanisms to verify the identity of players and ensure secure access to game features and content. Authentication processes typically involve user registration, login, and session management, employing encryption and secure protocols to protect user credentials and prevent unauthorized access.</li>
<li class="calibre11"><strong class="bold">Multiplayer functionality</strong>: Enables the implementation of multiplayer features<a id="_idIndexMarker500" class="calibre6 pcalibre1 pcalibre"/> in games, allowing players to connect, interact, and compete with each other in real time. This includes functionalities such as matchmaking, lobby management, game session orchestration, and synchronization of player actions across networked environments.</li>
<li class="calibre11"><strong class="bold">Real-time communication</strong>: Facilitate real-time communication between game <a id="_idIndexMarker501" class="calibre6 pcalibre1 pcalibre"/>clients and servers, supporting features such as in-game chat, messaging, notifications, and real-time updates. These communication channels enable players to engage with each other, receive important game updates, and participate in collaborative or competitive gameplay experiences.</li>
<li class="calibre11"><strong class="bold">Analytics and insights</strong>: Provides analytics tools and capabilities to track player<a id="_idIndexMarker502" class="calibre6 pcalibre1 pcalibre"/> behavior, monitor game performance, and gain insights into player engagement, retention, and monetization patterns. Analytics data helps us make informed decisions, optimize game mechanics, and tailor experiences to meet player preferences.</li>
<li class="calibre11"><strong class="bold">Live operations and content management</strong>: Supports live operations and content <a id="_idIndexMarker503" class="calibre6 pcalibre1 pcalibre"/>management, allowing us to deploy updates, patches, and new content to games seamlessly. This<a id="_idIndexMarker504" class="calibre6 pcalibre1 pcalibre"/> includes features such as <strong class="bold">content delivery networks</strong> (<strong class="bold">CDNs</strong>), version control, A/B testing, and live event management, enabling dynamic and evolving gameplay experiences.</li>
</ul>
<p class="calibre3">In summary, backend services form the foundation of modern game development, providing essential infrastructure and functionalities to support online multiplayer gaming, manage player data, analyze player behavior, and deliver engaging and immersive gameplay experiences across different platforms and devices.</p>
<h3 class="calibre9">Introduction of backend service providers and their features</h3>
<p class="calibre3">Several <a id="_idIndexMarker505" class="calibre6 pcalibre1 pcalibre"/>backend service providers offer comprehensive solutions tailored to the needs of game developers, each with its own set of features and capabilities. Here are some available services, and these are the most commonly used options at the time of writing this book:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Firebase</strong>: Developed<a id="_idIndexMarker506" class="calibre6 pcalibre1 pcalibre"/> by Google, Firebase offers a suite<a id="_idIndexMarker507" class="calibre6 pcalibre1 pcalibre"/> of backend services including real-time database, authentication, cloud storage, and hosting. It provides seamless integration with Unity, making it an ideal choice for us seeking a robust and scalable backend solution.</li>
<li class="calibre11"><strong class="bold">PlayFab</strong>: PlayFab<a id="_idIndexMarker508" class="calibre6 pcalibre1 pcalibre"/> offers a comprehensive backend<a id="_idIndexMarker509" class="calibre6 pcalibre1 pcalibre"/> platform specifically designed for game developers. Its features include player authentication, data storage, in-game analytics, virtual currency management, and live operations tools. PlayFab’s flexible APIs and SDKs support easy integration with Unity, empowering us to build engaging multiplayer experiences and live service features.</li>
<li class="calibre11"><strong class="bold">Amazon Web Services (AWS)</strong>: AWS provides a wide range of cloud-based services <a id="_idIndexMarker510" class="calibre6 pcalibre1 pcalibre"/>including databases, authentication, content delivery, and analytics. With offerings such as Amazon <a id="_idIndexMarker511" class="calibre6 pcalibre1 pcalibre"/>DynamoDB, Amazon Cognito, and Amazon GameLift, AWS offers scalable solutions for game developers looking to build, deploy, and manage backend infrastructure with flexibility and reliability.</li>
</ul>
<p class="calibre3">We’ll use PlayFab in this chapter and in the next section, we will implement it in our project accordingly. Let’s begin integrating PlayFab.</p>
<h3 class="calibre9">Integrating PlayFab</h3>
<p class="calibre3">In this <a id="_idIndexMarker512" class="calibre6 pcalibre1 pcalibre"/>guide, I’ll walk you through the process of implementing PlayFab and setting it up in your project. Then, we’ll create a sample authentication logic to demonstrate its usage.</p>
<p class="calibre3">To begin, you’ll need <a id="_idIndexMarker513" class="calibre6 pcalibre1 pcalibre"/>to download the PlayFab Unity package. I’ve utilized PlayFab SDK 2.188 for this purpose, which you can obtain from the following link: <a href="https://github.com/PlayFab/UnitySDK/releases" class="calibre6 pcalibre1 pcalibre">https://github.com/PlayFab/UnitySDK/releases</a>. Once you download it, follow these steps:</p>
<ol class="calibre15">
<li class="calibre11">In<em class="italic"> </em><em class="italic">Figure 8</em><em class="italic">.5</em>, as you can see, we’re extracting the PlayFab SDK into our project. Simply click <strong class="bold">Import</strong> to initiate the process of importing files and compiling them.</li>
</ol>
<div><div><img alt="Figure 8.5 – Importing PlayFab SDK" src="img/B22017_08_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Importing PlayFab SDK</p>
<ol class="calibre15">
<li value="2" class="calibre11">Wait for<a id="_idIndexMarker514" class="calibre6 pcalibre1 pcalibre"/> Unity to finish compiling, then <a id="_idIndexMarker515" class="calibre6 pcalibre1 pcalibre"/>navigate to <strong class="bold">Assets</strong> | <strong class="bold">PlayFabSDK</strong> | <strong class="bold">Shared</strong> | <strong class="bold">Public</strong> | <strong class="bold">Resources</strong>. From there, you can select the Scriptable Object <strong class="bold">PlayFabSharedSettings</strong> to configure it for your project. In <em class="italic">Figure 8</em><em class="italic">.6</em>, you can observe the settings of PlayFab that we can configure:</li>
</ol>
<div><div><img alt="Figure 8.6 – PlayFab Shared Settings" src="img/B22017_08_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6 – PlayFab Shared Settings</p>
<ol class="calibre15">
<li value="3" class="calibre11">For <strong class="bold">Request Type</strong>, you can select <strong class="bold">Unity Web Request</strong> or choose the option appropriate<a id="_idIndexMarker516" class="calibre6 pcalibre1 pcalibre"/> for your project. However, for<a id="_idIndexMarker517" class="calibre6 pcalibre1 pcalibre"/> our project, I will opt for <strong class="bold">Unity </strong><strong class="bold">Web Request</strong>.</li>
<li class="calibre11">We will include the <strong class="bold">Title ID</strong> value, which you can obtain from your PlayFab game project dashboard. If you don’t have a project yet, you can create one and use its key in your project. <em class="italic">Figure 8</em><em class="italic">.7</em> shows where you can locate the ID needed for PlayFab settings.</li>
</ol>
<div><div><img alt="Figure 8.7 – PlayFab title ID" src="img/B22017_08_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7 – PlayFab title ID</p>
<ol class="calibre15">
<li value="5" class="calibre11">Next, access <a id="_idIndexMarker518" class="calibre6 pcalibre1 pcalibre"/>the project to retrieve the <a id="_idIndexMarker519" class="calibre6 pcalibre1 pcalibre"/>secret key; to do that, click on the settings icon and select <strong class="bold">Title settings</strong>:</li>
</ol>
<div><div><img alt="Figure 8.8 – PlayFab Title settings" src="img/B22017_08_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8 – PlayFab Title settings</p>
<ol class="calibre15">
<li value="6" class="calibre11">The<a id="_idIndexMarker520" class="calibre6 pcalibre1 pcalibre"/> preceding step will open the settings<a id="_idIndexMarker521" class="calibre6 pcalibre1 pcalibre"/> tabs and from here, we can navigate to the <strong class="bold">Secret Keys</strong> tab to retrieve the secret key, as depicted in <em class="italic">Figure 8</em><em class="italic">.9</em>:</li>
</ol>
<div><div><img alt="Figure 8.9 –  Title secret key" src="img/B22017_08_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9 –  Title secret key</p>
<ol class="calibre15">
<li value="7" class="calibre11">Click on <strong class="bold">Show</strong> to reveal the secret key. You can then copy it and paste it into the <strong class="bold">Developer Secret Key</strong> field in the PlayFab settings in our game.</li>
</ol>
<p class="calibre3">That’s it! You<a id="_idIndexMarker522" class="calibre6 pcalibre1 pcalibre"/> now have the PlayFab SDK integrated into<a id="_idIndexMarker523" class="calibre6 pcalibre1 pcalibre"/> your project. In the next steps, we will begin using it and learn through an example. While this example is just a sample, it will cover the full flow of using this package. There are numerous possibilities for utilizing this package, so feel free to explore their documentation for further insights: <a href="B22017_08.xhtml#_idTextAnchor138" class="calibre6 pcalibre1 pcalibre">https://learn.microsoft.com/en-us/gaming/playfab/</a>.</p>
<h3 class="calibre9">Developing a sample login system</h3>
<p class="calibre3">There are <a id="_idIndexMarker524" class="calibre6 pcalibre1 pcalibre"/>various methods for user login in games, such as using email, guest accounts, and, for mobile platforms, utilizing Play services for Android and Game Center for iOS. PlayFab offers a variety of options to facilitate user login based on the game platform.</p>
<p class="calibre3"> For this system, we can establish a well-organized structure by following these steps:</p>
<ol class="calibre15">
<li class="calibre11">We will begin by creating an interface for the login method. In the following code block, you will find a login method along with callbacks for the login state:<pre class="source-code">
using PlayFab.ClientModels;
using PlayFab;
public interface ILogin
{
    void Login(System.Action&lt;LoginResult&gt; onSuccess, System.Action&lt;PlayFabError&gt; onFailure);
}</pre></li> <li class="calibre11">Next, we can create a class for each login method. For guest login, we will utilize the device ID for authentication. In the following code block, we have implemented the <strong class="source-inline1">ILogin</strong> interface with the <strong class="source-inline1">DeviceLogin</strong> class and incorporated <a id="_idIndexMarker525" class="calibre6 pcalibre1 pcalibre"/>the logic for logging in with the device ID.<pre class="source-code">
using PlayFab.ClientModels;
using PlayFab;
public class DeviceLogin : ILogin
{
    private string deviceId;
    public DeviceLogin(string deviceId)
    {
        this.deviceId = deviceId;
    }
    public void Login(System.Action&lt;LoginResult&gt; onSuccess, System.Action&lt;PlayFabError&gt; onFailure)
    {
        var request = new LoginWithCustomIDRequest
        {
            CustomId = deviceId,
            CreateAccount = true // Create account if not exists
        };
        PlayFabClientAPI.LoginWithCustomID(request, onSuccess, onFailure);
    }
}</pre><p class="calibre3">You can<a id="_idIndexMarker526" class="calibre6 pcalibre1 pcalibre"/> follow these steps and create additional login logic, especially if you are targeting mobile platforms, as there will be alternative login methods specific to mobile devices.</p></li> <li class="calibre11">Then, we can create a <strong class="source-inline1">LoginManager</strong> class, which will be responsible for invoking the appropriate login method, as demonstrated in the following code block:<pre class="source-code">
using PlayFab.ClientModels;
using PlayFab;
using UnityEngine;
public class LoginManager
{
    private ILogin loginMethod;
    public void SetLoginMethod(ILogin method)
    {
        loginMethod = method;
    }
    public void Login(System.Action&lt;LoginResult&gt; onSuccess, System.Action&lt;PlayFabError&gt; onFailure)
    {
        if (loginMethod != null)
        {
            loginMethod.Login(onSuccess , onFailure);
        }
        else
        {
            Debug.LogError("No login method set!");
        }
    }
}</pre></li> <li class="calibre11">For the<a id="_idIndexMarker527" class="calibre6 pcalibre1 pcalibre"/> next step, we will implement a <strong class="source-inline1">PlayfabManager</strong> script to manage the login methods and handle user input, subsequently triggering appropriate actions:<pre class="source-code">
using PlayFab.ClientModels;
using PlayFab;
using UnityEngine;
public class PlayFabManager
{
    private LoginManager loginManager;
    private string savedEmailKey = "SavedEmail";
    private string userEmail;
    private void Start()
    {
        loginManager = new LoginManager();
        // Check if email is saved
        if (PlayerPrefs.HasKey(savedEmailKey))
        {
            string savedEmail = PlayerPrefs.GetString(savedEmailKey);
            // Auto-login with saved email
            EmailLoginButtonClicked(savedEmail, "SavedPassword");
        }
    }
    // Example method for triggering email login
    public void EmailLoginButtonClicked(string email, string password)
    {
        userEmail = email;
        loginManager.SetLoginMethod(new EmailLogin(email, password));
        loginManager.Login(OnLoginSuccess, OnLoginFailure);
    }
    // Example method for triggering device ID login
    public void DeviceIDLoginButtonClicked(string deviceID)
    {
        loginManager.SetLoginMethod(new DeviceLogin(deviceID));
        loginManager.Login(OnLoginSuccess, OnLoginFailure);
    }
    private void OnLoginSuccess(LoginResult result)
    {
        Debug.Log("Login successful!");
        // You can handle success here, such as loading player data
        // Save email for future auto-login
        if (!string.IsNullOrEmpty(userEmail))
            PlayerPrefs.SetString(savedEmailKey, userEmail);
        // Load player data
        LoadPlayerData(result.PlayFabId);
    }
    private void OnLoginFailure(PlayFabError error)
    {
        Debug.LogError("Login failed: " + error.ErrorMessage);
    }
    private void LoadPlayerData(string playFabId)
    {
        var request = new GetUserDataRequest
        {
            PlayFabId = playFabId
        };
        PlayFabClientAPI.GetUserData(request, OnDataSuccess, OnDataFailure);
    }
    private void OnDataSuccess(GetUserDataResult result)
    {
        // Process player data here
        Debug.Log("Player data loaded successfully");
    }
    private void OnDataFailure(PlayFabError error)
    {
        Debug.LogError("Failed to load player data: " + error.ErrorMessage);
    }
}</pre><p class="calibre3">In <code>PlayFabManager</code>, you’ll discover methods to log in using email and device ID, along with callbacks indicating login status. Additionally, I’ve included an example of how to handle successful user logins by loading their data. This enables us to execute further logic based on the data stored in PlayFab.</p></li> </ol>
<p class="calibre3">That <a id="_idIndexMarker528" class="calibre6 pcalibre1 pcalibre"/>concludes this example, which may seem simple but encompasses the complete process of utilizing PlayFab. This package offers extensive capabilities, including leaderboard management, remote settings configuration, analytics, and matchmaking. As mentioned earlier, explore their documentation for further insights and possibilities: <a href="B22017_08.xhtml#_idTextAnchor138" class="calibre6 pcalibre1 pcalibre">https://learn.microsoft.com/en-us/gaming/playfab/</a>.</p>
<p class="calibre3">In conclusion, we have gained insight into the significance of backend services for our games. We successfully integrated PlayFab into our project and learned to develop a login system through this process.</p>
<p class="calibre3">In the next section, we will delve into analytics APIs, their benefits in games, and the reasons behind their necessity in our game development endeavors.</p>
<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor135" class="calibre6 pcalibre1 pcalibre"/>Integrating analytics APIs with C#</h1>
<p class="calibre3">Analytics APIs <a id="_idIndexMarker529" class="calibre6 pcalibre1 pcalibre"/>are software interfaces that enable us to integrate analytics functionality into our applications, including games. These APIs allow us to collect, analyze, and interpret data <a id="_idIndexMarker530" class="calibre6 pcalibre1 pcalibre"/>related to user interactions, behaviors, and performance metrics within our games. Here are some key aspects <a id="_idIndexMarker531" class="calibre6 pcalibre1 pcalibre"/>of analytics APIs:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Data collection</strong>: Analytics APIs facilitate the collection of various types of data generated by user interactions within the game. This includes information such as player actions, session durations, in-game purchases, progression milestones, and user demographics.</li>
<li class="calibre11"><strong class="bold">Event tracking</strong>: We can use analytics APIs to track specific events or actions within the game, such as level completions, item acquisitions, quest achievements, and social interactions. By defining and tracking custom events, we can gain insights into how players engage with different aspects of the game.</li>
<li class="calibre11"><strong class="bold">Performance monitoring</strong>: Analytics APIs provide tools for monitoring and analyzing the performance of the game, including metrics related to frame rates, loading times, network latency, and device specifications. This data helps us identify performance bottlenecks, optimize game performance, and ensure smooth gameplay experiences for players.</li>
<li class="calibre11"><strong class="bold">User behavior analysis</strong>: Analytics APIs enable us to analyze user behavior patterns <a id="_idIndexMarker532" class="calibre6 pcalibre1 pcalibre"/>and trends, helping them understand how players navigate the game, which features they engage with the most, and what factors influence their retention and engagement. This information informs game design decisions and helps us tailor the game experience to better meet player expectations.</li>
<li class="calibre11"><strong class="bold">Retention and monetization analysis</strong>: Analytics APIs allow us to track player retention rates over time and analyze factors that contribute to player churn. Additionally, we can analyze monetization metrics, such as revenue per user, conversion rates, and <strong class="bold">average revenue per paying user</strong> (<strong class="bold">ARPPU</strong>), to optimize<a id="_idIndexMarker533" class="calibre6 pcalibre1 pcalibre"/> monetization strategies and maximize revenue opportunities.</li>
<li class="calibre11"><strong class="bold">Real-time reporting and insights</strong>: Analytics APIs provide real-time reporting and visualization tools that enable us to access actionable insights and make<a id="_idIndexMarker534" class="calibre6 pcalibre1 pcalibre"/> data-driven decisions. Interactive dashboards, charts, and reports allow us to monitor <strong class="bold">key performance indicators</strong> (<strong class="bold">KPIs</strong>), track progress toward goals, and identify opportunities for improvement.</li>
</ul>
<p class="calibre3">In summary, analytics APIs<a id="_idIndexMarker535" class="calibre6 pcalibre1 pcalibre"/> empower us to gain valuable insights into player behavior, performance, and monetization, enabling them to optimize game design, enhance player experiences, and drive business success. By integrating analytics functionality into their games, we can make informed decisions and continuously improve the quality and performance of their games.</p>
<h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor136" class="calibre6 pcalibre1 pcalibre"/>Integrating GameAnalytics</h2>
<p class="calibre3"><strong class="bold">GameAnalytics</strong> is a<a id="_idIndexMarker536" class="calibre6 pcalibre1 pcalibre"/> popular package for Unity game development that provides analytics and insights into player behavior and game performance. It <a id="_idIndexMarker537" class="calibre6 pcalibre1 pcalibre"/>allows us to track various metrics, such as player progression, retention rates, in-game events, and monetization data, to optimize their games and improve player engagement.</p>
<p class="calibre3">Here are some key features<a id="_idIndexMarker538" class="calibre6 pcalibre1 pcalibre"/> and capabilities of the GameAnalytics package<a id="_idIndexMarker539" class="calibre6 pcalibre1 pcalibre"/> for Unity:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Event tracking</strong>: GameAnalytics enables us to track custom events within their games, such as level completions, item purchases, achievements unlocked, and tutorial progress. This data helps us understand how players interact with their games and identify areas for improvement.</li>
<li class="calibre11"><strong class="bold">User analytics</strong>: The package provides insights into user behavior and demographics, including active users, session lengths, retention rates, and user segmentation. We can analyze this data to tailor their games to specific player preferences and demographics.</li>
<li class="calibre11"><strong class="bold">Monetization tracking</strong>: GameAnalytics allows us to track in-app purchases, advertising revenue, and other monetization metrics. By analyzing revenue data alongside player behavior, we can optimize their monetization strategies and maximize revenue generation.</li>
<li class="calibre11"><strong class="bold">Real-time dashboards</strong>: The package offers real-time dashboards and reporting tools that visualize game analytics data, making it easy for us to monitor game performance and make data-driven decisions. We can customize dashboards to focus on specific metrics and KPIs.</li>
<li class="calibre11"><strong class="bold">Integration with Unity</strong>: GameAnalytics provides a Unity SDK that seamlessly integrates with Unity projects, allowing for easy implementation and tracking of analytics events and metrics. The SDK supports both Unity Editor and runtime environments, enabling us to test and analyze their games throughout the development lifecycle.</li>
<li class="calibre11"><strong class="bold">Cross-platform support</strong>: GameAnalytics supports multiple platforms, including PC, mobile, console, and web, allowing us to track analytics data across <a id="_idIndexMarker540" class="calibre6 pcalibre1 pcalibre"/>various<a id="_idIndexMarker541" class="calibre6 pcalibre1 pcalibre"/> devices and platforms. This cross-platform support enables us to gain insights into player behavior across different environments.</li>
</ul>
<p class="calibre3">Overall, GameAnalytics is a valuable tool for gaining insights into player behavior, optimizing game performance, and maximizing revenue through data-driven decisions. Its user-friendly interface, robust feature set, and cross-platform support make it a popular choice among game developers worldwide.</p>
<p class="calibre3">In the subsequent <a id="_idIndexMarker542" class="calibre6 pcalibre1 pcalibre"/>steps, we will integrate GameAnalytics and configure our initial event:</p>
<ol class="calibre15">
<li class="calibre11">We will utilize Version 7.8 of the GameAnalytics Unity SDK, which you can download using the following link: <a href="B22017_08.xhtml#_idTextAnchor137" class="calibre6 pcalibre1 pcalibre">https://download.gameanalytics.com/unity/7.8.0/GA_SDK_UNITY.unitypackage</a>.</li>
<li class="calibre11">After downloading the package, implement it into your project by clicking on <strong class="bold">Import</strong>, as illustrated in <em class="italic">Figure 8</em><em class="italic">.10</em>.</li>
</ol>
<div><div><img alt="Figure 8.10 – Importing the GameAnalytics package" src="img/B22017_08_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Importing the GameAnalytics package</p>
<ol class="calibre15">
<li value="3" class="calibre11">After<a id="_idIndexMarker543" class="calibre6 pcalibre1 pcalibre"/> waiting for Unity to compile the files, navigate to <strong class="bold">Window | GameAnalytics | Select Settings</strong>, as demonstrated in <em class="italic">Figure 8</em><em class="italic">.11</em>.</li>
</ol>
<div><div><img alt="Figure 8.11 – Opening the GameAnalytics settings" src="img/B22017_08_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Opening the GameAnalytics settings</p>
<ol class="calibre15">
<li value="4" class="calibre11">Following <a id="_idIndexMarker544" class="calibre6 pcalibre1 pcalibre"/>the preceding step will display the GameAnalytics settings. Then, you can log in with your account or sign up and create a project if you haven’t already done so, as illustrated in <em class="italic">Figure 8</em><em class="italic">.12.</em></li>
</ol>
<div><div><img alt="Figure 8.12 – GameAnalytics settings" src="img/B22017_08_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.12 – GameAnalytics settings</p>
<ol class="calibre15">
<li value="5" class="calibre11">After successfully logging in and having a project in your GameAnalytics dashboard, you’ll find the option to link your project and implement it with the appropriate<a id="_idIndexMarker545" class="calibre6 pcalibre1 pcalibre"/> platform, be it Android, iOS, or Windows. For our game, I selected Windows as we are working on a PC game. In <em class="italic">Figure 8</em><em class="italic">.13</em>, you’ll see information related to the project, such as the game and organization, and the important elements, the game key and secret key, which are automatically added upon successful login.</li>
</ol>
<div><div><img alt="Figure 8.13 – Link our game with GameAnalytics" src="img/B22017_08_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Link our game with GameAnalytics</p>
<p class="calibre3">Then, you need to add the GameAnalytics game object to our scene. Remember, it’s a persistent game object, so there’s no need to implement it in all scenes. Simply add one game object.</p>
<ol class="calibre15">
<li value="6" class="calibre11">You <a id="_idIndexMarker546" class="calibre6 pcalibre1 pcalibre"/>should navigate to <strong class="bold">Window | GameAnalytics | Create GameAnalytics Object</strong>, and the game object will be added to your scene, as shown in <em class="italic">Figure 8</em><em class="italic">.14</em>.</li>
</ol>
<div><div><img alt="Figure 8.14 – Adding a GameAnalytics object to our scene" src="img/B22017_08_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Adding a GameAnalytics object to our scene</p>
<p class="calibre3">Now, we need to begin implementing events into our code, which will depend on what you need to track. Allow me to provide you with an example for clarification.</p>
<h2 id="_idParaDest-130" class="calibre7"><a id="_idTextAnchor137" class="calibre6 pcalibre1 pcalibre"/>Example of GameAnalytics usage</h2>
<p class="calibre3">You <a id="_idIndexMarker547" class="calibre6 pcalibre1 pcalibre"/>can now initialize GameAnalytics and start using events in your code, as demonstrated in the following code block:</p>
<pre class="source-code">
    private void Start()
    {
        GameAnalytics.Initialize();
    }</pre> <p class="calibre3">We can add this in the <code>GameManager</code> script as an example, or if you have a script to handle the initialization of services in your game.</p>
<p class="calibre3">You can utilize it as shown in the following code block. Don’t forget to include the <code>GameAnalyticsSDK</code> namespace:</p>
<pre class="source-code">
// Call this method when the player completes a level
 public void LevelCompleted(int levelNum)
 {
     // Track the event using GameAnalytics
     GameAnalytics.NewDesignEvent("LevelComplete", levelNum);
 }</pre> <p class="calibre3">And there are various types of events available for better data collection. For more detailed information, you can refer to the GameAnalytics documentation: <a href="B22017_08.xhtml#_idTextAnchor136" class="calibre6 pcalibre1 pcalibre">https://docs.gameanalytics.com/event-types</a>.</p>
<p class="calibre3">You need to build the scene containing the GameAnalytics game object first to start sending events. It may take a few minutes before results start appearing on the website.</p>
<p class="calibre3">You can visit your game on the GameAnalytics website and then navigate to the real-time section to view the data, as depicted in <em class="italic">Figure 8</em><em class="italic">.15</em>.</p>
<div><div><img alt="Figure 8.15 – Real-time data from our game" src="img/B22017_08_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Real-time data from our game</p>
<p class="calibre3">Now<a id="_idIndexMarker548" class="calibre6 pcalibre1 pcalibre"/> that we’ve integrated an analytics API, specifically GameAnalytics, into our project, we’ve successfully incorporated it and put it to use.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you’ve integrated any package, don’t spend too much time on its possibilities initially. Simply integrate it, check for errors, create a sample, and then explore its full potential gradually. Don’t complicate things unnecessarily at the outset.</p>
<p class="calibre3">Incorporating third-party assets is a valuable skill for any developer. Many successful games rely on external resources to save time and ensure top-notch quality that might be challenging to achieve independently.</p>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor138" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we delved into the integration of pre-built assets and APIs using C# in Unity, a pivotal aspect of game development. We began by exploring the utilization of pre-built assets to enhance game visuals and optimize performance, followed by the integration of rendering pipelines to achieve better visual fidelity. The discussion then shifted to the importance of backend services, highlighting the significance of authentication logic as an example of their utility in game development. Additionally, we explored analytics APIs and their role in understanding player behavior and optimizing game performance, demonstrating how to implement them effectively into our game projects.</p>
<p class="calibre3">Looking ahead to <a href="B22017_09_split_000.xhtml#_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 9</em></a>, we will focus on optimizing game performance using Unity’s profiling tools. You’ll learn to leverage tools like the Profiler, Frame Debugger, and Memory Profiler to identify and address performance bottlenecks, optimize rendering, and manage memory usage. Through hands-on exercises and practical insights, you’ll gain mastery over optimization techniques to ensure your game runs smoothly and efficiently. Get ready to elevate your game’s performance in the upcoming chapter!</p>
</div>
</body></html>