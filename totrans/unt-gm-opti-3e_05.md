# 批量处理的益处

在 3D 图形和游戏中，批量处理是一个非常通用的术语，用来描述将大量零散的数据分组在一起，并将它们作为一个单一的大数据块进行处理的过程。这种情况对于 CPU，尤其是 GPU 来说非常理想，因为它们可以通过多个核心同时处理多个任务。单个核心在内存的不同位置之间切换需要时间，所以需要减少这种切换的次数，这样会更好。

在某些情况下，批量处理的行为指的是大量网格、顶点、边、UV 坐标以及其他用于表示 3D 对象的不同数据类型；然而，这个术语同样可以指批量处理音频文件、精灵、纹理文件和其他大型数据集的行为。

因此，为了消除任何混淆，当在 Unity 中提到批量处理时，通常是指它提供的两种主要的批量处理网格数据的机制：**动态批量处理**和**静态批量处理**。这些方法本质上是一种几何合并的不同形式，我们将多个对象的网格数据合并在一起，并通过一个指令将它们全部渲染出来，而不是分别准备和绘制每一个。

将多个网格批量合并成一个单一网格的过程是可行的，因为网格对象没有必要必须填充连续的 3D 空间体积。渲染管线对接受那些没有通过边连接在一起的顶点集合感到非常满意，因此我们可以将多个可能产生多个渲染指令的独立网格合并成一个单一网格，从而通过一个指令来渲染它。

多年来，关于动态批量处理和静态批量处理系统激活的条件以及我们可能看到性能提升的地方存在很多混淆。毕竟，在某些情况下，如果使用不当，批量处理实际上可能会降低性能。对这些系统的正确理解将给我们提供所需的知识，以显著提高我们应用程序的图形性能。

本章旨在消除关于这些系统存在的许多错误信息。通过解释、探索和示例，我们将看到这两种批量处理方法是如何运作的。这将使我们能够做出明智的决定，并利用其中大部分来提高我们应用程序的性能。

在本章中，我们将涵盖以下主题：

+   渲染管线简介及绘制调用概念

+   Unity 的材料和着色器如何协同工作以渲染我们的对象

+   使用帧调试器可视化渲染行为

+   动态批量处理的工作原理及其优化方法

+   静态批量处理的工作原理及其优化方法

# 绘制调用

在我们讨论动态批处理和静态批处理之前，让我们首先了解它们都在渲染管线中试图解决的问题。我们将尽量减少对技术细节的分析，因为我们将在第六章“动态图形”中更详细地探讨这个主题。

这些批处理方法的主要目标是减少渲染当前视图中所有对象所需的绘制调用数量。在最基本的形式上，绘制调用是从 CPU 发送到 GPU 的请求，要求它绘制一个对象。

**绘制调用**是这一过程的行业通用术语，尽管在 Unity 中有时它们被称为 SetPass 调用，因为一些底层方法被这样命名。将其视为在启动当前渲染过程之前配置选项。我们将在这本书的其余部分中称其为绘制调用。

在请求绘制调用之前，系统需要执行几个操作。完整的列表太长，不适合这本书，并且取决于 Unity 上启用的特定功能；然而，我们可以将它们归类为两个重要的步骤：

1.  将资产和网格上传到 GPU

1.  使用上传的资产设置网格的渲染。

在第一步中，网格和纹理数据必须从 CPU 内存（RAM）推送到 GPU 内存（VRAM），这通常发生在场景初始化期间，但仅限于场景文件已知的纹理和网格。如果我们使用尚未出现在场景中的纹理和网格数据在运行时动态实例化对象，那么它们必须在实例化时加载。场景无法提前知道我们计划在运行时实例化的 Prefab，因为许多 Prefab 都隐藏在条件语句后面，而且我们应用程序的行为很大程度上取决于用户输入。

在第二步中，CPU 必须通过配置处理绘制调用目标对象所需的选项和渲染功能来准备 GPU。

为了处理 CPU 和 GPU 之间所有的这些交互，我们使用底层的图形 API，这可能是 DirectX、OpenGL、OpenGLES、Metal、WebGL 或 Vulkan，具体取决于我们针对的平台和使用的特定图形设置。这些 API 调用通过一个称为**驱动程序**的库进行，该库维护一系列复杂且相互关联的设置、状态变量和数据集，这些可以从我们的应用程序中进行配置和执行。可用的功能根据我们使用的图形卡和针对的图形 API 版本而有很大差异。多年来（尤其是对于像 DirectX 和 OpenGL 这样的旧 API）创建的设置、功能和兼容性级别之间的数量之多，简直令人难以置信。幸运的是，在一定的抽象级别上，所有这些 API 都倾向于以类似的方式运行，这意味着 Unity 可以通过一个通用接口支持许多不同的图形 API。

为了指代在渲染对象之前必须配置的这些庞大的设置数组，以便准备渲染管线，我们通常使用一个单一的术语：渲染状态。直到这些渲染状态选项保持不变，GPU 将保持最后设置的渲染状态，并相应地渲染所有传入的对象。

改变任何渲染状态设置可能是一个耗时的过程。例如，如果我们将渲染状态设置为使用蓝色纹理文件，然后我们尝试渲染一个巨大的网格，它将非常快速地渲染，整个网格看起来是蓝色的。在这个时候，我们可以渲染九个完全不同的网格，并且它们都会被渲染成蓝色，因为我们没有改变 GPU 在渲染状态中应该使用的纹理。如果我们想使用 10 种不同的纹理渲染 10 个网格，那么这将会花费更长的时间，因为我们需要在每个网格发送绘制调用指令之前，为每个网格准备带有新纹理的渲染状态。

用于渲染当前对象的纹理在图形 API 中实际上是一个全局变量，在并行系统中更改全局变量说起来容易做起来难。在一个如 GPU 这样的大规模并行系统中，我们必须有效地等待直到所有当前的工作都达到了相同的同步点（换句话说，最快的核心需要停止并等待最慢的追上来，浪费的处理器时间本可以用于其他任务）我们才能进行渲染状态更改，此时我们需要再次启动所有并行工作。这种持续的等待会浪费很多时间，因此我们越少要求渲染状态更改，图形 API 就越能快速处理我们的请求。

可以触发渲染状态同步的事物包括但不限于将新的纹理立即推送到 GPU、更改着色器、光照信息、阴影、透明度以及我们能够想到的几乎所有图形设置。

一旦我们配置了渲染状态，CPU 必须决定绘制哪个网格，使用哪些纹理和着色器，以及根据其位置、旋转和缩放（所有这些都在一个称为**变换**的 4 x 4 矩阵中表示，这也是`Transform`组件名称的由来）在哪里绘制对象，然后向 GPU 发送指令以绘制它。为了保持 CPU 和 GPU 之间的通信非常动态，Unity 会将新的指令推入一个称为**命令缓冲区**的队列。这个队列包含 CPU 创建的指令，GPU 在完成前一个指令后，会从中拉取一个新的命令。

批处理如何提高此过程性能的技巧在于，新的绘制调用并不一定意味着我们需要配置新的渲染状态。如果两个对象共享完全相同的渲染状态信息，那么 GPU 可以立即开始渲染新对象，因为最后一个对象完成后，相同的渲染状态仍然保持不变。这消除了由于渲染状态同步而浪费的时间。它还减少了需要推入命令缓冲区的指令数量，从而减少了 CPU 和 GPU 的工作负载。

# 材料和着色器

在 Unity 中，渲染状态主要通过**材料**向我们暴露。材料是着色器的容器，是一些简短的程序，它们定义了 GPU 应该如何渲染传入的顶点和纹理数据。单独的着色器本身并不具备完成任何有价值工作的必要状态知识。着色器需要输入，例如漫反射纹理、法线贴图和光照信息，并有效地指定需要设置哪些渲染状态变量以渲染传入的数据。

着色器之所以这样命名，是因为许多年前，它们的原始实现是仅处理对象的照明和着色（在原本没有阴影的地方应用阴影）。自那时以来，它们的目的已经极大地扩展了，现在它们有了一个更通用的目的，即作为许多不同类型并行任务的编程访问点，但旧的名字仍然保留。

每个着色器都需要一个材料，每个材料都必须有一个着色器。即使是新导入到场景中且未分配材料的网格，也会自动分配一个默认（隐藏）材料，这会给它们一个基本的漫反射着色器和白色着色，因此无法绕过这种关系。

注意，单个材料只能支持单个着色器。在同一个网格上使用多个着色器需要为网格的不同部分分配不同的材料。

因此，如果我们想最小化渲染状态变化的频率，那么我们可以通过减少场景中使用的材质数量来实现。这将同时带来两个性能提升：CPU 在每一帧中将花费更少的时间生成和传输指令到 GPU，GPU 也不需要频繁地停止和重新同步状态变化。

让我们从简单的场景开始，以便可视化材质和批处理的行为。然而，在我们开始之前，我们应该禁用一些渲染选项，因为它们可能会增加额外的绘制调用，这可能会分散注意力：

1.  导航到编辑 | 项目设置 | 质量，将阴影设置为禁用阴影（或选择默认的最快质量级别）

1.  导航到编辑 | 项目设置 | 玩家，打开其他设置选项卡，如果已启用，禁用静态批处理和动态批处理

接下来，我们将创建一个包含单个方向光、四个立方体和四个球体的场景，其中每个对象都有其独特的材质、位置、旋转和缩放，如图所示：

![](img/f0ffd2af-7cea-4679-a9d6-df66521986c2.png)

在前面的截图中，我们可以在游戏窗口的“统计”弹出窗口中的“批处理”值中看到 9 个总批次数。这个值紧密地代表了渲染场景所使用的绘制调用次数。当前视图将消耗这些批次数中的一个，用于渲染场景的背景，这可以是设置为 Skybox 或纯色。这是由相机对象的清除标志设置决定的。

剩下的八个批次数用于绘制我们的八个对象。在每种情况下，绘制调用都涉及到使用材质的属性准备渲染管线，并要求 GPU 在当前变换下渲染给定的网格。我们通过为每个材质提供一个独特的纹理文件来渲染，确保每个材质都是唯一的。因此，每个网格需要不同的渲染状态，因此我们八个网格中的每一个都需要独特的绘制调用。

如前所述，我们可以通过减少系统更改渲染状态信息的频率来理论上最小化绘制调用次数；因此，部分目标是减少我们使用的材质数量。然而，如果我们将所有对象配置为使用相同的材质，我们仍然不会看到任何好处，批次数将保持在九个：

![](img/b18b9038-34e9-460b-959c-fee468759166.png)

这是因为我们实际上并没有减少渲染状态变化的次数，也没有有效地分组网格信息。不幸的是，渲染管线并不足够智能，无法意识到我们在覆盖相同的渲染状态值，然后要求它反复渲染相同的网格。

# 帧调试器

在我们深入探讨批处理如何帮助我们节省绘制调用之前，让我们探索一个有用的工具，它可以帮助我们确定批处理如何影响我们的场景——帧调试器。

我们可以通过从主窗口中选择“窗口”|“分析”|“帧调试器”，或者在 Profiler 的渲染区域中的“分解视图选项”中点击帧调试器按钮来打开 Frame Debugger。两种方法都会打开帧调试窗口。

在帧调试窗口中点击启用按钮将允许我们逐个观察场景的构建过程。以下截图显示了帧调试器的用户界面，左侧面板列出了 GPU 指令，右侧面板提供了更详细的信息：

![图片](img/e500043a-5d55-4adb-a9ff-f1dc9fc8cb74.png)

在此窗口中有很多信息可以提供给我们有用的信息，如果我们想调试单个绘制调用的行为，但最有用的区域是左侧面板中的绘图部分，它列出了场景中的所有绘制调用。

本节中的每个项目代表一个独特的绘制调用以及它所渲染的内容。这个工具的一个非常实用的功能是能够点击这些项目中的任何一个，并立即在游戏窗口中观察到渲染到该点的场景所需的绘制调用。这让我们可以直观地看到两个连续绘制调用之间的差异。这可以让我们轻松地确定哪些对象被特定的绘制调用所渲染。这有助于通过查看在绘制调用期间出现的对象数量来确定是否将一组对象批量处理在一起。

Frame Debugger（帧调试器）中存在的一个奇怪的问题（在 Unity 2019 的早期构建中仍然存在）是，如果我们正在观察一个使用天空盒的场景，并在绘图部分点击各种项目，那么在游戏窗口中只能观察到最终的场景呈现。我们需要通过将摄像机的清除标志设置暂时禁用天空盒，将其设置为纯色，来查看在游戏窗口中绘制调用进展的情况。

如前所述的帧调试器截图所示，一个绘制调用用于清除屏幕（标记为清除的项目），然后我们的八个网格在八个单独的绘制调用中渲染（标记为`RenderForward.RenderLoopJob`的项目）。

注意，左侧面板中每个项目的数字实际上代表一个图形 API 调用，其中绘制调用只是 API 调用的一种类型。这些可以在`Camera.Render`、`Camera.ImageEffects`和`RenderTexture.ResolveAA`项目中看到。任何 API 调用都可能像绘制调用一样昂贵，但我们在复杂场景中将要进行的绝大多数 API 调用都将采用绘制调用的形式，因此通常最好在担心诸如后期处理效果之类的 API 通信开销之前，先关注最小化绘制调用。

# 动态批量处理

动态批量处理具有以下三个重要特性：

+   批量在运行时生成（批量是动态生成的）

+   批处理中的对象可能从一帧到下一帧变化，具体取决于当前对主摄像机视图可见的网格（批处理内容是动态的）。

+   即使可以在场景中移动的对象也可以批处理（它适用于动态对象）。

这些属性使我们得出了动态批处理的名字。

如果我们回到玩家设置页面并启用动态批处理，我们应该看到批处理数量从九个下降到六个。动态批处理自动识别我们的对象共享材质和网格信息，因此将其中一些合并成更大的批处理以进行处理。我们还应该在帧调试器中看到不同的项目列表，表明网格现在正在动态批处理：

![图片](img/3de2be33-03df-4f2b-b6a4-03578a390e2d.png)

如我们从帧调试器中看到的那样，我们的四个盒子已被合并成一个名为动态批处理的单个绘制调用，但我们的四个球体仍然使用四个单独的绘制调用进行渲染。这是因为四个球体不符合动态批处理的要求，尽管它们都使用了相同的材质。我们还有许多其他要求必须满足。

您可以在 Unity 文档中找到成功动态批处理网格所需的要求列表，地址如下：[`docs.unity3d.com/Manual/DrawCallBatching.html`](http://docs.unity3d.com/Manual/DrawCallBatching.html)。

以下列表涵盖了为给定网格启用动态批处理的要求：

+   所有网格实例必须使用相同的材质引用。

+   只有`ParticleSystem`和`MeshRenderer`组件可以动态批处理。`SkinnedMeshRenderer`组件（用于动画角色）和所有其他可渲染组件类型不能批处理。

+   每个网格的顶点数限制为 300 个；然而，着色器使用的总顶点属性数不得超过 900 个。这意味着对于复杂的着色器，每个网格的最大顶点数可能少于 300 个（有关更多详细信息，请参阅*顶点属性*部分）。

+   对象不得在变换上包含镜像（即，具有正缩放的`GameObject` A 和具有负缩放的`GameObject` B 不能一起批处理）。

+   网格实例应引用相同的光照贴图文件。

+   材料的着色器不应依赖于多个遍历。

+   网格实例不得接收实时阴影。

+   整个批处理中网格索引的总数有一个上限，这取决于所使用的图形 API 和平台，大约为 32,000-64,000 个索引（具体信息请参阅文档/之前提到的博客文章）。

需要注意的是，查看网格的原始数据文件可能包含的顶点属性信息少于 Unity 加载到内存中的信息，因为引擎将网格数据从几种原始数据格式之一转换为内部格式的方式。因此，不要假设我们的 3D 建模工具告诉我们的网格使用的属性数量将是最终的数量。验证属性数量的最佳方法是钻入项目窗口中的网格对象，直到找到`MeshFilter`组件，然后在检查器的预览子部分中查看出现的 verts 值。

# 顶点属性

顶点属性简单来说就是包含在网格文件中的每顶点信息，每个通常表示为一组多个浮点值。这包括但不限于顶点的位置（相对于网格的根），法线向量（一个指向物体表面的向量，通常用于光照计算），一组或更多纹理 UV 坐标（用于定义一个或多个纹理如何包裹网格），以及可能还有每个顶点的颜色信息（通常用于自定义光照或用于平面着色、低多边形风格的对象）。只有使用少于 900 个总顶点属性的网格才能包含在动态批处理中。

注意术语**材质引用**，因为如果我们恰好使用了两个设置相同的不同材质，渲染管线并不足够智能以意识到这一点，它们将被视为不同的材质，因此将无法参与动态批处理。其余的大部分要求已经解释过了；然而，其中一些要求并不完全直观或从其描述中不清楚，这需要一些额外的解释。

在伴随的着色器中使用每个顶点更多的属性数据将消耗我们 900 个属性预算中的一部分，因此会减少网格在无法再用于动态批处理之前允许拥有的顶点数量。例如，一个简单的漫反射着色器可能每个顶点只使用三个属性：位置、法线和一组 UV 坐标。因此，动态监控将能够支持使用此着色器的网格，该着色器总共包含 300 个顶点；然而，一个更复杂的着色器，每个顶点需要 5 个属性，将只能支持使用不超过 180 个顶点的网格进行动态批处理。此外，请注意，即使我们在着色器中每个顶点使用少于 3 个属性，动态批处理仍然只支持最大 300 个顶点的网格，因此只有相对简单的对象才适合动态批处理。

这些限制是为什么即使所有对象共享相同的材质引用，我们的场景在启用动态批处理的情况下也只保存了 3 个绘制调用。Unity 自动生成的立方体网格仅包含 8 个顶点，每个顶点都有位置、法线和 UV 数据，总共 24 个属性。这远低于 300 个顶点的限制和 900 个顶点属性的限制。然而，自动生成的球体网格包含 515 个顶点，因此总共有 1,545 个顶点属性。这些网格显然超过了 300 个顶点和 900 个顶点属性的限制，因此不能进行动态批处理。

![图片](img/20f98009-4a01-491a-8e46-d5b47322ab86.png)

如果我们在帧调试器中点击其中一个绘制调用项，会出现一个标记为“为什么这个绘制调用不能与上一个一起批处理”的部分。大多数情况下，下面的解释文本会告诉我们我们未满足哪些要求（或者至少是它检测到的第一个）以及哪些可能对调试批处理行为有用。

# 网格缩放

文档明确指出，使用负缩放对动态批处理有奇怪的影响。负缩放通常是快速镜像场景中网格的一种方法，这可以让我们避免为仅在一个轴上翻转的对象创建和导入一个完全不同的网格。这个技巧通常用于一对门，或者只是为了使场景看起来更加多样化。然而，如果我们只在一个或三个轴上负缩放网格，那么它将被放入与在零或两个轴上负缩放的网格不同的动态批处理中。三个值（`x`、`y`或`z`）中哪个是负的并不重要，重要的是负值的总数是奇数还是偶数。

批量拆分在幕后工作的另一个奇怪特性是，对象的渲染顺序可以决定哪些对象会被一起批处理。如果上一个对象原本会出现在与当前不同的批处理组中，那么它就不能被批处理。再次强调，这最好通过一个例子来解释。假设我们再次有五个对象：*V* 缩放为 `(1, 1, 1)`，*W* 缩放为 `(-1, 1, 1)`，*X* 缩放为 `(-1, -1, 1)`，*Y* 缩放为 `(-1, -1, -1)`，最后 *Z* 缩放与 *V* 相似，为 `(1, 1, 1)`。对象 *V* 和 *Z* 具有共同的统一缩放，所以我们可能期望它们会被一起批处理。然而，如果所有这些对象都按照前面的顺序渲染到场景中，那么对象 *V* 将会被渲染，Unity 将会测试对象 *W* 和 *V* 是否可以共享一个批处理。它们不能，因为对象 *W* 的奇数负缩放，所以不会进行批处理。然后 Unity 将比较对象 *X* 与对象 *W*，以检查它们是否可以批处理，但它们不能，因为 *W* 有奇数负缩放而 *X* 有偶数负缩放。对象 *W-Y* 和 *Y-Z* 之间的后续比较也会因为相同的原因失败。最终结果是，所有五个对象都将使用五个单独的绘制调用进行渲染，并且没有机会将对象 *V* 和 *Z* 合并。请注意，这种奇怪的效果仅在使用负缩放时才会出现。

很可能，这全是检测有效批处理组所使用的算法的副产品，因为将网格在二维中镜像在数学上等同于围绕镜像轴旋转网格 180 度，而将网格在一维或三维上镜像没有旋转的等价物。因此，我们观察到的行为可能是动态批处理系统自动为我们转换对象，尽管这并不完全清楚。无论如何，希望这为我们准备了许多我们可能在生成动态批处理时遇到的各种奇怪情况。

# 动态批处理总结

当我们想要渲染大量简单的网格时，动态批处理是一个非常有用的工具。系统的设计使其在大量使用几乎外观相同的简单网格时变得理想。动态批处理的一些可能的用例可能如下：

+   我们希望渲染一个充满岩石、树木和灌木的大型森林

+   我们希望渲染一个由许多简单、常见元素（如电脑、走廊部件、管道等）组成的建筑、工厂或太空站

+   我们希望构建一个包含许多动态、非动画对象的游戏，这些对象具有简单的几何形状和粒子效果（例如，会想到 *Geometry Wars* 这样的游戏）

如果阻止两个对象动态批处理在一起的唯一要求是它们使用不同的纹理文件，请注意，只需一点开发时间和努力，就可以合并纹理并重新生成网格 UV，以便它们可以一起动态批处理（通常称为**图集化**）。这可能会影响纹理质量或纹理文件的整体大小（我们将在第六章“动态图形”中深入了解 GPU 内存带宽时理解其缺点），但这值得考虑。

可能唯一可能阻碍性能的动态批处理情况是，如果我们设置了一个包含数百个简单对象的场景，其中每个批次只包含几个对象。在这些情况下，检测和生成如此多的小批次的开销可能会比我们通过为每个网格单独进行绘制调用所节省的时间更多。即便如此，这种情况也不太可能发生。

如果说有什么的话，我们更有可能因为忘记了一个基本要求而简单地假设动态批处理正在进行，从而对我们的应用程序造成性能损失。我们可能会通过推送网格的新版本意外地突破顶点限制，在 Unity 将原始对象（具有`.obj`扩展名）文件转换为它自己的内部格式的过程中，它会产生比我们预期的更多的顶点属性。我们也可能通过调整一些着色器代码或添加额外的通道而超出限制，而没有意识到这将使其不符合动态批处理的要求。我们甚至可能设置对象以启用阴影或光照探针，这又违反了另一个要求。

当这些意外发生时，除了更改后绘制调用次数增加，导致图形性能进一步下降之外，不会有任何警告信号。在我们的场景中保持健康的动态批处理数量需要我们持续关注我们的绘制调用次数，并查看帧调试器数据，以确保我们没有在最近的变化中意外地使对象不符合动态批处理的要求。然而，正如往常一样，我们只需要担心我们的绘制调用性能，如果我们已经证明它正在造成性能瓶颈。

最终，每种情况都是独特的，因此尝试我们的网格数据、材料和着色器以确定哪些可以动态批处理，哪些不可以，是非常有价值的。同时，时不时地对我们的场景进行测试，以确保我们使用的绘制调用次数保持合理。

# 静态批处理

Unity 提供了一种名为**静态批处理**的第二个批处理机制。这种批处理功能在几个方面与动态批处理相似，即要批处理的对象是在运行时根据相机可见的内容确定的，并且这些批次的内含物会随帧而变化。然而，有一个非常重要的区别：它只适用于标记为静态的对象，因此得名静态批处理。

静态批处理系统有其自己的要求：

+   如其名所示，网格必须被标记为静态（具体来说，是批处理静态）。

+   必须为每个正在静态批处理的网格预留额外的内存。

+   在静态批处理中可以组合的顶点数有一个上限，这个上限因图形 API 和平台而异，大约是 32,000-64,000 个顶点（具体信息请查看文档/之前提到的博客文章）。

+   网格实例可以来自任何源网格，但它们必须共享相同的材质引用。

让我们更详细地介绍一些这些要求。

# 静态标记

静态批处理只能应用于启用了静态标记的对象，或者更具体地说，是批处理静态子标记（这些子标记被称为 StaticEditorFlags）。点击`GameObject`旁边的静态选项旁边的小向下箭头将显示一个下拉列表，其中包含 StaticEditorFlags，可以改变对象在静态过程中的行为。

这种情况的明显副作用是，对象的变换不能改变，因此，任何希望使用静态批处理的对象都不能移动、旋转或缩放。

# 内存需求

静态批处理所需的额外内存量将根据批处理网格中复制的数量而变化。静态批处理通过将所有标记和可见网格的数据复制到一个单独的大型网格数据缓冲区中，并通过单个绘制调用将其传递到渲染管线，同时忽略原始网格来实现。如果所有静态批处理的网格都是唯一的，那么与正常渲染对象相比，这不会给我们带来额外的内存使用，因为存储网格所需的内存空间相同。

然而，由于数据实际上是复制的，这些静态批处理的副本给我们带来了额外的内存，相当于网格数量的倍数乘以原始网格的大小。通常，渲染一个、十个或一百万个相同对象的克隆给我们带来的内存使用量是相同的，因为它们都引用相同的网格数据。在这种情况下，对象之间的唯一区别是每个对象的变换；然而，由于静态批处理需要将数据复制到大型缓冲区中，这种引用就丢失了，因为原始网格的每个副本都复制到缓冲区中，并带有独特的数据集，其中硬编码的变换被嵌入到顶点位置中。

因此，使用静态批处理渲染 1,000 个相同的树对象，将比不使用静态批处理渲染相同的树消耗 1,000 倍多的内存。如果静态批处理使用不当，这会导致一些显著的内存消耗和性能问题。

# 材质引用

我们已经知道，共享材质引用是减少渲染状态变化的一种方法，因此这个要求相当明显。此外，有时我们会静态批处理需要多个材质的网格。在这种情况下，使用不同材质的所有网格将分别组成自己的静态批处理，以适应每个独特的材质。

这个要求的缺点是，在最理想的情况下，静态批处理只能使用与所需材质数量相等的绘制调用来渲染所有静态网格。

# 静态批处理注意事项

由于它处理批处理解决方案的方式（通过将网格组合成单个更大的网格），静态批处理系统有一些需要注意的问题。这些问题从轻微的不便到严重的缺点不等，具体取决于场景：

+   从统计窗口中，直到运行时才能看到绘制调用节省的效果

+   在运行时场景中引入标记为批处理静态的对象不会自动包含在静态批处理中

让我们更详细地探讨这些问题。

# 静态批处理的编辑模式调试

尝试确定静态批处理对我们场景的整体影响可能会有些棘手，因为在编辑模式下并没有进行任何静态批处理。所有的魔法都是在运行时发生的，这使得在没有手动测试的情况下很难确定静态批处理能提供哪些好处。我们应该使用帧调试器来验证我们的静态批处理是否被正确生成，并且它们是否包含预期的对象。

如果我们直到项目生命周期的后期才实现这个功能，这可能会特别有问题，那时我们可能会花费大量时间启动、调整和重新启动场景，以确保我们得到预期的绘制调用节省。因此，最好在构建新场景的过程中尽早开始静态批处理优化。

不言而喻，静态批处理创建工作并非完全微不足道，如果需要创建许多批处理以及/或许多大型对象进行批处理，这也可能极大地增加场景初始化时间。

# 在运行时实例化静态网格

在运行时添加到场景中的任何新对象都不会自动被静态批处理系统合并到任何现有的批处理中，即使它们被标记为批处理静态。这样做会导致在重新计算网格和与渲染管线同步之间产生巨大的运行时开销，因此 Unity 甚至不会尝试自动执行。

在大多数情况下，我们应该尝试将我们希望进行静态批处理的任何网格保留在原始场景文件中；然而，如果需要动态实例化，或者我们正在使用额外的场景加载，那么我们可以使用`StaticBatchUtility.Combine()`方法来控制静态批处理资格。这个实用方法有两个重载：要么我们提供一个根`GameObject`，在这种情况下，所有具有网格的子`GameObject`实例都将被转换为新的静态批处理组，要么我们提供一个`GameObject`实例列表和一个根`GameObject`，它将自动将它们作为子对象附加到根对象，并以相同的方式生成新的静态批处理组。

我们应该分析这个函数的使用情况，因为它在需要合并许多顶点时可能相当昂贵。它也不会将给定的网格与任何现有的静态批处理组合并，即使它们具有相同的材质。这意味着我们无法通过实例化或以累加方式加载使用与场景中已存在的静态批处理组相同材质的静态网格来节省绘制调用（它只能与在`Combine()`调用中分组在一起的网格合并）。

注意，如果我们使用`StaticBatchUtility.Combine()`方法批处理的对象中任何一个在批处理之前没有被标记为静态，那么这些对象将保持非静态，但网格本身将是静态的。这意味着我们可能会意外地移动`GameObject`实例、其`Collider`组件以及任何其他重要对象，但网格将保持在同一位置。在静态批处理对象中，小心不要意外地将静态和非静态状态混合。

# 静态批处理摘要

静态批处理是一个强大但危险的工具。如果我们不谨慎使用，我们很容易因为内存消耗（可能导致应用程序崩溃）和渲染成本而造成巨大的性能损失。它还需要大量的手动调整和配置，以确保批处理被正确生成，并且我们没有意外引入使用各种静态标志的不希望出现的副作用。然而，它确实有一个显著的优势，即它可以用于不同形状和巨大尺寸的网格，这是动态批处理无法提供的。

# 摘要

很明显，动态批处理和静态批处理系统并不是万能的解决方案。我们不能盲目地将它们应用到任何给定的场景中并期望得到改进。如果我们的应用程序和场景恰好符合一组特定的参数，那么这些方法在减少 CPU 负载和渲染瓶颈方面非常有效。然而，如果它们不符合，那么我们需要做一些额外的工作来准备我们的场景以满足批处理功能的要求。最终，只有对这些批处理系统及其工作方式有良好的理解，我们才能确定在哪里以及何时应用这个功能，而且，希望这一章已经为我们提供了做出明智决策所需的所有信息。

你将在第六章“动态图形”中学习更多关于渲染管线和性能提升技术。但现在，让我们转向一个不同的主题，探讨一些通过智能管理我们的艺术资产所能实现的更微妙性能提升。
