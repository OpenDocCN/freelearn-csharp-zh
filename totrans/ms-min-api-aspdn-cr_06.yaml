- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Validation and Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter of the book, we will discuss how to perform data validation
    and mapping with minimal APIs, showing what features we currently have, what is
    missing, and what the most interesting alternatives are. Learning about these
    concepts will help us to develop more robust and maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping data to and from APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. Refer to the *Technical requirements* section in
    [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023), *Exploring Minimal APIs and Their
    Advantages*, for instructions on how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using your console, shell, or bash terminal to create the API, remember
    to change your working directory to the current chapter number (`Chapter06`).
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Handling validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Person` object has both the `FirstName` and `LastName` properties defined,
    an email address is valid, or an appointment date isn’t in the past.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In controller-based projects, we can perform these checks, also termed `ApiController`
    attribute that is placed on a controller makes model validation errors automatically
    trigger a `400 Bad Request` response if one or more validation rules fail. Therefore,
    in controller-based projects, we typically don’t need to perform explicit model
    validation at all: if the validation fails, our endpoint will never be invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ApiController` attribute enables the automatic model validation behavior
    using the `ModelStateInvalidFilter` action filter.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, minimal APIs do not provide built-in support for validation.
    The `IModelValidator` interface and all related objects cannot be used. Thus,
    we don’t have a `ModelState`; we can’t prevent the execution of our endpoint if
    there is a validation error and must explicitly return a `400 Bad Request` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, let’s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the endpoint will be invoked even if the `Person` argument does
    not respect the validation rules. There is only one exception: if we use `400
    Bad Request` response. As mentioned in [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023),
    *Exploring Minimal APIs and Their Advantages*, nullable reference types are enabled
    by default in .NET 6.0 projects.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to accept a `null` body (if ever there was a need), we need to declare
    the parameter as `Person?`. But, as long as there is a body, the endpoint will
    always be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: So, with minimal APIs, it is necessary to perform validation inside each route
    handler and return the appropriate response if some rules fail. We can either
    implement a validation library compatible with the existing attributes so that
    we can perform validation using the classic data annotations approach, as described
    in the next section, or use a third-party solution such as `FluentValidation`,
    as we will see in the *Integrating FluentValidation* section.
  prefs: []
  type: TYPE_NORMAL
- en: Performing validation with data annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to use the common validation pattern based on data annotations, we
    need to rely on `IsValid` methods, which are provided by the `ValidationAttribute`
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is a simplification of what ASP.NET Core actually does to handle
    validations. However, this is the way validation in controller-based projects
    works.
  prefs: []
  type: TYPE_NORMAL
- en: While we can also manually implement a solution of this kind with minimal APIs,
    if we decide to use data annotations for validation, we can leverage a small but
    interesting library, `MiniValidation`, which is available on GitHub ([https://github.com/DamianEdwards/MiniValidation](https://github.com/DamianEdwards/MiniValidation))
    and NuGet ([https://www.nuget.org/packages/MiniValidation](https://www.nuget.org/packages/MiniValidation)).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, `MiniValidation` is available on NuGet as a prerelease.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add this library to our project in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MiniValidation`. Be sure to check the **Include prerelease** option and click
    **Install**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 2**: Open the **Package Manager Console** if you’re inside Visual
    Studio 2022, or open your console, shell, or bash terminal, go to your project
    directory, and execute the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can validate a `Person` object using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `MiniValidator.TryValidate` static method provided by `MiniValidation`
    takes an object as input and automatically verifies all the validation rules that
    are defined on its properties. If the validation fails, it returns `false` and
    populates the `out` parameter with all the validation errors that have occurred.
    In this case, because it is our responsibility to return the appropriate response
    code, we use `Results.ValidationProblem`, which produces a `400 Bad Request` response
    with a `ProblemDetails` object (as described in [*Chapter 3*](B17902_03.xhtml#_idTextAnchor038),
    *Working with Minimal APIs*) and also contains the validation issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as an example, we can invoke the endpoint using the following invalid
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response we will obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this way, besides the fact that we need to execute validation manually, we
    can implement the approach of using data annotations on our models in the same
    way we were accustomed to in previous versions of ASP.NET Core. We can also customize
    error messages and define custom rules by creating classes that inherit from `ValidationAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The full list of validation attributes available in ASP.NET Core 6.0 is published
    at [https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations](https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations).
    If you’re interested in creating custom attributes, you can refer to [https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes](https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Although data annotations are the most used solution, we can also handle validations
    using a so-called fluent approach, which has the benefit of completely decoupling
    validation rules from the model, as we’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating FluentValidation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In every application, it is important to correctly organize our code. This is
    also true for validation. While data annotations are a working solution, we should
    think about alternatives that can help us write more maintainable projects. This
    is the purpose of `FluentValidation` – a library, part of the **.NET Foundation**,
    that allows us to build validation rules using a fluent interface with lambda
    expressions. The library is available on GitHub ([https://github.com/FluentValidation/FluentValidation](https://github.com/FluentValidation/FluentValidation))
    and NuGet ([https://www.nuget.org/packages/FluentValidation](https://www.nuget.org/packages/FluentValidation)).
    This library can be used in any kind of project, but when working with ASP.NET
    Core, there is an ad-hoc NuGet package ([https://www.nuget.org/packages/FluentValidation.AspNetCore](https://www.nuget.org/packages/FluentValidation.AspNetCore))
    that contains useful methods that help to integrate it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: .NET Foundation is an independent organization that aims to support open source
    software development and collaboration around the .NET platform. You can learn
    more at [https://dotnetfoundation.org](https://dotnetfoundation.org).
  prefs: []
  type: TYPE_NORMAL
- en: As stated before, with this library, we can decouple validation rules from the
    model to create a more structured application. Moreover, `FluentValidation` allows
    us to define even more complex rules with a fluent syntax without the need to
    create custom classes based on `ValidationAttribute`. The library also natively
    supports the localization of standard error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s see how we can integrate `FluentValidation` into a minimal API project.
    First, we need to add this library to our project in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FluentValidation.DependencyInjectionExtensions` and click **Install**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 2**: Open **Package Manager Console** if you’re inside Visual Studio
    2022, or open your console, shell, or bash terminal, go to your project directory,
    and execute the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can rewrite the validation rules for the `Person` object and put them
    in a `PersonValidator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`PersonValidator` inherits from `AbstractValidator<T>`, a base class provided
    by `FluentValidation` that contains all the methods we need to define the validation
    rules. For example, we *fluently* say that we have a rule for the `FirstName`
    property, which is that it must not be empty and it can have a maximum length
    of `30` characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to register the validator in the service provider so that
    we can use it in our route handlers. We can perform this task with a simple instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `AddValidatorsFromAssemblyContaining` method automatically registers all
    the validators derived from `AbstractValidator` within the assembly containing
    the specified type. In particular, this method registers the validators and makes
    them accessible through dependency injection via the `IValidator<T>` interface,
    which in turn, is implemented by the `AbstractValidator<T>` class. If we have
    multiple validators, we can register them all with this single instruction. We
    can also easily put our validators in external assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything is in place, remembering that with minimal APIs we don’t
    have automatic model validation, we must update our route handler in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have added an `IValidator<Person>` argument in the route handler parameter
    list, so now we can invoke its `ValidateAsync` method to apply the validation
    rules against the input `Person` object. If the validation fails, we extract all
    the error messages and return them to the client with the usual `Results.ValidationProblem`
    method, as described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, let’s see what happens if we try to invoke the endpoint using
    the following input as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, `FluentValidation` provides translations for standard
    error messages, so this is the response you get when running on an Italian system.
    Of course, we can completely customize the messages with the typical fluent approach,
    using the `WithMessage` method chained to the validation methods defined in the
    validator. For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll talk about localization in further detail in [*Chapter 9*](B17902_09.xhtml#_idTextAnchor125),
    *Leveraging Globalization and Localization*.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a quick example of how to define validation rules with `FluentValidation`
    and use them with minimal APIs. This library allows many more complex scenarios
    that are comprehensively described in the official documentation available at
    [https://fluentvalidation.net](https://fluentvalidation.net).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to add validation to our route handlers, it is important
    to understand how we can update the documentation created by **Swagger** with
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation information to Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regardless of the solution that has been chosen to handle validation, it is
    important to update the OpenAPI definition with the indication that a handler
    can produce a validation problem response, calling the `ProducesValidationProblem`
    method after the endpoint declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, a new response type for the `400 Bad Request` status code will
    be added to Swagger, as we can see in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The validation problem response added to Swagger ](img/Figure_6.1_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The validation problem response added to Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the **JSON schemas** that are shown at the bottom of the Swagger
    UI can show the rules of the corresponding models. One of the benefits of defining
    validation rules using data annotations is that they are automatically reflected
    in these schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The validation rules for the Person object in Swagger ](img/Figure_6.2_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The validation rules for the Person object in Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, validation rules defined with `FluentValidation` aren’t automatically
    shown in the JSON schema of Swagger. We can overcome this limitation by using
    `MicroElements.Swashbuckle.FluentValidation`, a small library that, as usual,
    is available on GitHub ([https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation](https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation))
    and NuGet ([https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation](https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation)).
    After adding it to our project, following the same steps described before for
    the other NuGet packages we have introduced, we just need to call the `AddFluentValidationRulesToSwagger`
    extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the JSON schema shown in Swagger will reflect the validation rules,
    as with the data annotations. However, it’s worth remembering that, at the time
    of writing, this library does not support all the validators available in `FluentValidation`.
    For more information, we can refer to the GitHub page of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This ends our overview of validation in minimal APIs. In the next section,
    we’ll analyze another important theme of every API: how to correctly handle the
    mapping of data to and from our services.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data to and from APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with APIs that can be called by any system, there is one golden
    rule: *we should never expose our internal objects to the callers*. If we don’t
    follow this decoupling idea and, for some reason, need to change our internal
    data structures, we could end up breaking all the clients that interact with us.
    Both the internal data structures and the objects that are used to dialog with
    the clients must be able to evolve independently from one another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This requirement for dialog is the reason why **mapping** is so important.
    We need to transform input objects of one type into output objects of a different
    type and vice versa. In this way, we can achieve two objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolve our internal data structures without introducing breaking changes with
    the contracts that are exposed to the callers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the format of the objects used to communicate with the clients without
    the need to change the way these objects are handled internally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, mapping means transforming one object into another, literally,
    by copying and converting an object’s properties from a source to a destination.
    However, mapping code is boring, and testing mapping code is even more boring.
    Nevertheless, we need to fully understand that the process is crucial and strive
    to adopt it in all scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s consider the following object, which could represent a person saved
    in a database using Entity Framework Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have set endpoints for getting a list of people or retrieving a specific
    person.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thought could be to directly return `PersonEntity` to the caller.
    The following code is highly simplified, enough for us to understand the scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if we need to modify the schema of the database, adding, for example,
    the creation date of the entity? In this case, we need to change `PersonEntity`
    with a new property that maps the relevant date. However, the callers also get
    this information now, which we probably don’t want to be exposed. Instead, if
    we use a so-called **data transformation object** (**DTO**) to expose the person,
    this problem will be redundant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This means that our API should return an object of the `PersonDto` type instead
    of `PersonEntity`, performing a conversion between the two objects. At first sight,
    the exercise appears to be a useless duplication of code, as the two classes contain
    the same properties. However, if we consider the fact that `PersonEntity` could
    evolve with new properties that are necessary for the database, or change structure
    with a new semantic that the caller shouldn’t know, the importance of mapping
    becomes clear. An example is storing the city in a separate table and exposing
    it through an `Address` property. Or suppose that, for security reasons, we don’t
    want to expose the exact birth date anymore, only the age of the person. Using
    an ad-hoc DTO, we can easily change the schema and update the mapping without
    touching our entity, having a better separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, mapping can be bidirectional. In our example, we need to convert
    `PersonEntity` to `PersonDto` before returning it to the client. However, we could
    also do the opposite – that is, convert the `PersonDto` type that comes from a
    client into `PersonEntity` to save it to a database. All the solutions we’re talking
    about are valid for both scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We can either perform mapping manually or adopt a third-party library that provides
    us with this feature. In the following sections, we’ll analyze both approaches,
    understanding the pros and cons of the available solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Performing manual mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we said that mapping essentially means copying the
    properties of a source object into the properties of a destination and applying
    some sort of conversion. The easiest and most effective way to perform this task
    is to do it manually.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we need to take care of all the mapping code by ourselves.
    From this point of view, there is nothing much more to say; we need a method that
    takes an object as input and transforms it into another as output, remembering
    to apply mapping recursively if a class contains a complex property that must
    be mapped in turn. The only suggestion is to use an extension method so that we
    can easily call it everywhere we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full example of this mapping process is available in the GitHub repository:
    [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution guarantees the best performance because we explicitly write all
    mapping instructions without relying on an automatic system (such as reflection).
    However, the manual method has a drawback: every time we add a property in the
    entity that must be mapped to a DTO, we need to change the mapping code. On the
    other hand, some approaches can simplify mapping, but at the cost of performance
    overhead. In the next section, we look at one such approach using `AutoMapper`.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping with AutoMapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AutoMapper` is probably one the most famous mapping framework for .NET. It
    uses a fluent configuration API that works with a convention-based matching algorithm
    to match source values to destination values. As with `FluentValidation`, the
    framework is part of the .NET Foundation and is available either on GitHub ([https://github.com/AutoMapper/AutoMapper](https://github.com/AutoMapper/AutoMapper))
    or NuGet ([https://www.nuget.org/packages/AutoMapper](https://www.nuget.org/packages/AutoMapper)).
    Again, in this case, we have a specific NuGet package, [https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection](https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection),
    that simplifies its integration into ASP.NET Core projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a quick look at how to integrate `AutoMapper` in a minimal API project,
    showing its main features. The full documentation of the library is available
    at [https://docs.automapper.org](https://docs.automapper.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the first thing to do is to add the library to our project, following
    the same instructions we used in the previous sections. Then, we need to configure
    `AutoMapper`, telling it how to perform mapping. There are several ways to perform
    this task, but the recommended approach is to create classes that are inherited
    from the `Profile` base class provided by the library and put the configuration
    into the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all we need to start: a single instruction to indicate that we want
    to map `PersonEntity` to `PersonDto`, without any other details. We have said
    that `AutoMapper` is convention-based. This means that, by default, it maps properties
    with the same name from the source to the destination, while also performing automatic
    conversions into compatible types, if necessary. For example, an `int` property
    on the source can be automatically mapped to a `double` property with the same
    name on the destination. In other words, if source and destination objects have
    the same property, there is no need for any explicit mapping instruction. However,
    in our case, we need to perform some transformations, so we can add them fluently
    after `CreateMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the `ForMember` method, we can specify how to map destination properties,
    `dst.Age` and `dst.City`, using conversion expressions. We still don’t need to
    explicitly map the `Id`, `FirstName`, or `LastName` properties because they exist
    with these names at both the source and destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the mapping profile, we need to register it at startup
    so that ASP.NET Core can use it. As with `FluentValidation`, we can invoke an
    extension method on `IServiceCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this line of code, we automatically register all the profiles that are
    contained in the specified assembly. If we add more profiles to our project, such
    as a separate `Profile` class for every entity to map, we don’t need to change
    the registration instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, we can now use the `IMapper` interface through dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After retrieving `PersonEntity`, for example, from a database using Entity Framework
    Core, we call the `Map` method on the `IMapper` interface, specifying the type
    of the resulting object and the input class. With this line of code, `AutoMapper`
    will use the corresponding profile to convert `PersonEntity` into a `PersonDto`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: With this solution in place, mapping is now much easier to maintain because,
    as long as we add properties with the same name on the source and destination,
    we don’t need to change the profile at all. Moreover, `AutoMapper` supports list
    mapping and recursive mapping too. So, if we have an entity that must be mapped,
    such as a property of the `AddressEntity` type on the `PersonEntity` class, and
    the corresponding profile is available, the conversion is again performed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of this approach is a performance overhead. `AutoMapper` works
    by dynamically executing mapping code at runtime, so it uses reflection under
    the hood. Profiles are created the first time they are used and then they are
    cached to speed up subsequent mappings. However, profiles are always applied dynamically,
    so there is a cost for the operation that is dependent on the complexity of the
    mapping code itself. We have only seen a basic example of `AutoMapper`. The library
    is very powerful and can manage quite complex mappings. However, we need to be
    careful not to abuse it – otherwise, we can negatively impact the performance
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validation and mapping are two important features that we need to take into
    account when developing APIs to build more robust and maintainable applications.
    Minimal APIs do not provide any built-in way to perform these tasks, so it is
    important to know how we can add support for this kind of feature. We have seen
    that we can perform validations with data annotations or using `FluentValidation`
    and how to add validation information to Swagger. We have also talked about the
    significance of data mapping and shown how to either leverage manual mapping or
    the `AutoMapper` library, describing the pros and cons of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how to integrate minimal APIs with a
    **data access layer**, showing, for example, how to access a database using Entity
    Framework Core.
  prefs: []
  type: TYPE_NORMAL
