- en: Chapter 2. Implementing Continuations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing task results to a continuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue "WhenAny" and "WhenAll"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying when a continuation will run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a continuation for exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling a continuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a continuation to chain multiple tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a continuation to update a UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are writing an application that has tasks and that execute in parallel,
    it is common to have some parallel tasks that depend on the results of other tasks.
    These tasks should not be started until the earlier tasks, known as antecedents,
    have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, to write truly scalable software, you should not have threads that
    block. Calling `Wait` or querying `Task.Result`, when the task has not finished
    running, will cause your threads to block. Fortunately, there is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the introduction of the **Task Parallel Library** (**TPL**), this type
    of interdependent thread execution was done with callbacks, where a method was
    called, and one of its parameters was a delegate to execute when the task completed.
    This provided a viable solution to the dependency problems but quickly became
    very complex in the real-world application. This is especially true if, for example,
    you had a task that needed to run after several other tasks had completed.
  prefs: []
  type: TYPE_NORMAL
- en: With the TPL, a simpler solution exists in the form of continuation tasks. These
    tasks are linked to their antecedents, and are automatically started after the
    earlier tasks have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: What makes continuations so powerful is that, you can create continuations that
    run when a task or a group of tasks completes throws an exception, or gets cancelled.
    As you will see in this chapter, continuations can even provide a means to synchronize
    the asynchronous method results with the user interface running on another thread.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the chapter with a basic, simple continuation that runs when a
    single task completes. From there, we will look at using continuations to control
    a collection of tasks, using continuations to handle exceptions, and using continuations
    to chain multiple tasks together. We will finish the chapter by creating a **Windows
    Presentation Foundation** (**WPF**) application, using a continuation to marshal
    data created in a task back to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its simplest form, a continuation is an action that runs asynchronously after
    a target task, called an antecedent, completes.
  prefs: []
  type: TYPE_NORMAL
- en: In the first recipe of this chapter, we will build a basic continuation. We
    will accomplish this by using the `Task.ContinueWith(Action<Task>)` method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go to Visual Studio and create a console application that runs a task
    continuation after our word count task completes. The steps to create a console
    application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation1` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your program class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s put a try/catch block and some basic exception handling. The `Main`
    method of the program class, at this point, should look as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `try` block, create a `WebClient` object and set the user-agent
    header as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, in the body of the `try` block, let's create an anonymous `Task` (no name),
    followed by a `.ContinueWith()` right after the closing parenthesis of the `Task`.
    The antecedent `Task` doesn't return any results in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we need to create the body of the `Task` and the continuation. The
    `Task` will execute one of our familiar word counts. The continuation will be
    used to clean up the reference to the `WebClient` object after the antecedent
    task completes. After the continuation, prompt the user to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn't a lot to explain about this basic continuation, but there are a
    couple of small points to note.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we created an anonymous `Task` and made the call to `ContinueWith`
    right after the closing parenthesis of the task as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We could just as well have created a named task and made the call to `ContinueWith`
    in a separate statement shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Also, notice that we can wait for a continuation using the `Wait()` method;
    in the same way we could wait for a `Task` (however, you will not normally do
    this in practice. It causes the thread to block waiting for the continuation to
    complete. In general, you want to avoid causing your threads to block). In fact,
    tasks and continuations aren't much different and have many of the same instance
    methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Passing task results to a continuation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can pass the results returned from an antecedent
    `Task` to a continuation.
  prefs: []
  type: TYPE_NORMAL
- en: Our antecedent `Task` is going to read in the contents of a book as a string
    and display a word count to the user. The continuation, which will run after the
    antecedent completes, will take the string array returned by the antecedent and
    perform a LINQ query which will find the five most frequently used words.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start Visual Studio and build a Console Application that shows how to
    pass results from the antecedent to a continuation. The steps are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation2` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your program class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To begin with, let''s put some basic stuff in the class. We will need a character
    array of delimiters so that we can parse out the words properly. Also, we need
    a try/catch block and some basic exception handling. The `Main` method of the
    Program class, at this point, should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s create a task called `task1` that returns an array of strings as
    its result. The purpose of `task1` will be to create `System.Net.WebClient` which
    will read in the text of the book as a string. Once the string is parsed and put
    into a string array, we will display the word count to the user by using the `Count`
    method of the array, and then return the array in the tasks result so that it
    can be used in our continuation. Create the task inside the `try` block. The body
    of the `try` block should now look something like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we are going to create our continuation using the `Task.ContinueWith()`
    method. Our continuation will have a `Task<string[]> state` parameter. The body
    of the continuation will perform a Linq query on the string array to sort all
    of the words contained in the array by the number of times the words occur. We
    will then execute another Linq operation to take the top five most frequently
    used words and write them to the console. Finally, we will want to wait on the
    continuation to complete with the `Wait()` method. Create the task continuation
    right after the body of the antecedent task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OK, the last step for this recipe is to let the user know that our application
    is finished and prompt them to exit. Put that code right after the continuation.
    It should be the last lines in the `try` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    similar to the following screenshot:![How to do it…](img/0225OT_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The continuation in this recipe was created using the `ContinueWith` method
    of an existing task instance as we did in the previous recipe. In this recipe
    however, we use a Lambda expression to pass in a `Task<string[]>` parameter representing
    the antecedent `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the continuation accesses the result of the antecedent using the
    `Task.Result` property. If this looks familiar, it should. You access the results
    of a task in nearly the same way in a continuation as you would in any piece of
    your code, that is, by accessing the `Result` property of a `Task`. The Parallel
    Extensions team has made the coding experience very consistent across all parallel
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we wait for the continuation to complete before prompting the user to
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: Continue "WhenAny" and "WhenAll"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will move from continuing single tasks to setting up continuations
    for groups of tasks. The two methods we will be looking at are `WhenAny` and `WhenAll`.
    Both methods are static members of the `Task.Factory` class, and take an array
    of tasks and `Action<Task>` as their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: First we will look at the `WhenAny` continuations. The basic idea here is that
    we have a group of tasks and we only want to wait for the first and fastest of
    the group to complete its work before moving on. In our case, we will be downloading
    the text of three different books, and performing a word count on each. When the
    first task completes we will display the word count of the winner to the user.
  prefs: []
  type: TYPE_NORMAL
- en: After that we will change to `WhenAll` and display the results of all three
    word counts to the user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build a solution that shows how to conditionally continue a task. The
    steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation3` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your program class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Main` method of your program class, let's create a character
    array of delimiters we can use to split our words with, a string constant for
    the user agent header of our web client, and a `Dictionary<string, string>` method
    to hold our book titles and URLs. The dictionary will serve as the state object
    parameter for our tasks, which will be created in a `foreach` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a try/catch block with some basic error handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `try` block, let's create a new list of `Task<KeyValuePair<string,
    string>>`. Of course, this will be the list of our tasks. Each task will take
    a `KeyValuePair` from the dictionary we created in step 3 as their state parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create our task in a `foreach` loop. Each task will read the text
    of a book from a string, split the string into a character array, and do a word
    count. Our antecedent tasks return a `KeyValuePair<string, int>` with the book
    title and the word count for each book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create the continuation by calling the `Task.Factory.WhenAny` method.
    The continuations will just display the title and word count of the winner to
    the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, after the catch block, prompt the user to exit and wait for the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following. Your winner may vary.![How to do it…](img/0225OT_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before moving on, let's change our code a bit and continue when all of our tasks
    complete. All we need to do is change our method call from `Task.Factory.WhenAny`
    to `Task.Factory.WhenAll`, change the name of the continuation parameter from
    `antecedent` to `antecedents` to reflect plurality, and create a `foreach` loop
    in the body of the continuation to loop through the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The continuations in this recipe are created a bit differently from the continuations
    that we have created in previous tasks. Instead of calling the instance method
    `ContinueWith` on a `Task` variable, we are calling the `ContinueWhenAny` and
    `ContinueWhenAll` static methods on `Task.FactoryClass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ContinueWhenAny` and `ContinueWhenAll` methods have a different parameter
    lists than `Task.ContinueWith`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ContinueWhenAny` takes an array of `Task` as its first parameter and a single
    `Action<Task>` delegate as its second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`ContinueWhenAll` takes the same array of `Task` as its first parameter and
    `Action<Task[]>` as its second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Specifying when a continuation will run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful features of task continuations is the ability to create
    multiple continuations for a task, and specify the exact conditions under which
    each continuation will be invoked by using the `Task.TaskContinuationOptions`
    enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a continuation for a task, you can use `Task.ContinueWith` overload
    that takes the `TaskContinuationOptions` enumeration to specify that the continuation
    will only run if the antecedent `Task` completed, was cancelled, or is faulted.
    The enumeration also has members that specify when a continuation should not run.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be looking at two simple tasks, each with two continuations.
    One of the continuations for each task will run when the task completes, and one
    will run when the task is cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s create a console application that continues tasks conditionally.
    The steps to create a console application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation4` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your program class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `Main` method, create two `CancellationTokenSource` objects
    and get a `CancellationToken` from each one of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a try/catch block with some basic error handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `try` block, let's create two simple tasks. Both tasks just write
    a message to the console. Also create two continuations for each task using `TaskContinuationOptions.OnlyOnRanToCompletion`
    and `Task ContinuationOption.OnlyOnFaulted`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, after the `catch` block, let's cancel the token and wait for user input
    before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this very simple example, we started by creating two `CancellationTokenSource`
    objects and getting a cancellation token source from each. If we had created a
    `CancellationTokenSource` object and passed the token into both tasks, both tasks
    would have been cancelled when we cancelled the token. In our case, we just wanted
    to cancel one of the two tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks themselves are very simple. They just wait for a bit to give us some
    time to cancel the token and display a message to the console. We pass one `CancellationToken`
    into each task as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Both of the continuations just display a message to the console, and both are
    created with a member of the `Task.TaskContinuationOptions` enumerator. The first
    continuation is fired when the task runs to completion and the second continuation
    fires when the task is cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We cancel the token for `task2`, but not for `task1` and the corresponding continuation
    for each executes, and we can see the message written on to the console.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TaskContinuationOptions` enumeration has several members which control
    under which condition a continuation is triggered. The following table contains
    a list of these members. Note that this is not a complete list of continuation
    options. The complete list of continuation options can be found at [http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx).
    The `OnlyOnFaulted` member will have its own recipe later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '| `NotOnRanToCompletion` | The continuation should not be scheduled if the
    task ran to completion. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotOnFaulted` | The continuation should not be scheduled if the task faulted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NotOnCancelled` | The continuation should not be triggered if the task was
    cancelled. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnlyOnRanToCompletion` | The continuation should be scheduled if the task
    ran to completion. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnlyOnFaulted` | The continuation should be scheduled if the task faulted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OnlyOnCancelled` | The continuation should be triggered if the task was
    cancelled. |'
  prefs: []
  type: TYPE_TB
- en: The `TaskContinuationOptions` enumeration can be treated as a bit field and
    a bitwise combination can be performed on its members.
  prefs: []
  type: TYPE_NORMAL
- en: Using a continuation for exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Handling task exceptions using try/catch* recipe, in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Task Parallel Library"), *Getting Started With
    Task Parallel Library* we looked at how to handle exceptions in task. In addition
    to the techniques used in that recipe, you can also use continuations to handle
    task exceptions. By using a continuation, we can handle errors in a cleaner, less
    inline way. An exception handling continuation allows for centralizing exception
    handling logic in cases where you would want to provide logging or other exception
    related code.
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept is to use the `Task.TaskContinuationOptions` enumeration so
    we can create a continuation that will be scheduled if the task ran to completion,
    and another continuation that will be scheduled if the task is put into a faulted
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe we need to turn off the **Visual Studio 2012 Exception Assistant**.
    The Exception Assistant appears whenever a run-time exception is thrown and intercepts
    the exception before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    Ready](img/0225OT_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s go to Visual Studio and see how to use a continuation for exception
    handling. The steps are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation5` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives at the top of your program class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of your program class, create a `Task`. The task doesn't
    need to accept a state parameter or return anything. In the body of the `Task`,
    create the try/finally blocks. In order to have a resource to dispose of, create
    a new WebClient in the `try` block, and then throw an exception. In the `finally`
    block, call the dispose method of the WebClient. Other than that, the exact details
    don't matter much.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Immediately following the `Task`, use `TaskContinuationOptions.OnlyOnRanToCompletion`
    to create a trivial continuation to run when the task completes successfully.
    This continuation only needs to write a message to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next use `TaskContinuationOptions.OnlyOnFaulted` to create a continuation that
    only runs when `task1` throws a fault. After the continuation, add `Console.Readline`
    to wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the one shown in the following screenshot:![How to do it…](img/0225OT_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a continuation that will run when a `Task` is in a faulted state, works
    the same as setting any of the other enumerations in `TaskContinuationOptions`
    on a continuation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to properly clean up resources used by the `Task`, we created `try/finally`
    blocks in our task and disposed of the WebClient in the `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our exception handling continuation checks to see if the `AggregateException`
    is null before looping through the `InnerExceptions` collection, and writing the
    result to the console. The null check isn''t strictly necessary because the antecedent
    task needs to be in a faulted state before the continuation is scheduled, but
    it is a good defensive coding practice none the less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Cancelling a continuation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cancelling a continuation follows the same basic rules as cancelling a `Task`.
    If a `Task` and its continuation are two parts of the same operation, you can
    pass the same cancellation token to both the `Task` and the continuation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will have a simple `Task` that creates a list of numbers and
    a continuation that squares the numbers and return a result. After a few seconds
    of running, we will use the token to cancel both the `Task` and the continuation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since cancelling a `Task` or continuation raises and `OperationCanceledException`
    we need to turn off the Visual Studio 2012 Exception Assistant. The Exception
    Assistant appears whenever a runtime exception is thrown, and intercepts the exception
    before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    Ready](img/0225OT_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s build a console application so that we can see how to cancel a
    continuation. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation6` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `using` directives to the top of your program class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of your program class, let's start by creating our `CancellationTokenSource`
    and getting a token. We will pass this token to both the antecedent `Task` and
    the continuation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next let's add try/catch/finally blocks to the `Main` method, just under the
    previous lines. Add some basic error handling to the `catch` block and dispose
    of the `CancellationTokenSource` in the `finally` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `try` block, create a task that accepts an object state parameter.
    The parameter will determine the size of our number list. We will cast it to `Int32`
    and create a `for` loop to add numbers to our list. Also, pass the token created
    in step 1 to the task constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `Task`, let's create our continuation. The continuation will receive
    the results from the antecedent `Task`, loop through the list, and square the
    numbers. Pass the same `CancellationToken` into the continuations constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end of the `try` block, we need to sleep the thread a bit to give the
    `Task` and continuation some time to run, and then we will cancel the token. Finally
    we will call the `Wait` method on `task1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Last, after the end of the `finally` block, write a message to the console that
    we are finished and wait for the user input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an antecedent task throws an `OperationCancelledException` in response
    to a cancellation request, as long as the continuation uses the same `CancellationToken`,
    the cancellation request will be treated as an acknowledgement of co-operative
    cancellation and both the antecedent task and the continuation will go into a
    cancelled state.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty easy to accomplish. We just need to get a `CancellationToken`
    from a `CancellationTokenSource`, and pass the token to the constructors for both
    the antecedent `Task` and the continuation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Inside the body of the loops in our `Task` and the continuation, we need to
    poll for cancellation and throw an `OperationCancelledException` if the token
    gets cancelled. This can be done in one line of code with the `ThrowIfCancellationRequested`
    method of the `CancellationToken` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we just need to make sure we are handling `AggregateExceptions` in our
    `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Using a continuation to chain multiple tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another feature of continuations is that you can continue continuations in order
    to chain tasks together to any length. The pipeline pattern can be implemented
    with a series of tasks and continuations. You can think of a pipeline as an assembly
    line in a factory. At the frontend of a pipeline, a producer task generates the
    data to be operated on, and each of the chained consumer stages operates on or
    changes the produced data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will return to our word count example to create a simple three
    stage pipeline using continuations with `TaskContinuationOptions.OnlyOnRanToCompletion`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up Visual Studio, and let''s see how to chain tasks together into a pipeline.
    The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Continuation7` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your program class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start this application by adding try/catch blocks in the `Main` method
    of the program class. In the `catch` block add some handling for any `AggregateException`
    raised by the tasks. At the end of the `catch` block, write a message to the console
    to tell the user we are finished and wait for input to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create a `producer` task that reads in the text of a book, and
    returns a string array, which the consumer continuations will consume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first consumer will perform a Linq query on the results of the producer
    to find the five most commonly used words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The task and continuations we used in this example are pretty much the same
    as the tasks we have created in other recipes. The primary difference is how we
    chained them together and the length of the chain. Our antecedent task produces
    and returns a string array, and then we have a continuation that finds the five
    most commonly used words, finally we continue the continuation to find the longest
    word.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also use `TaskContinuationOptions.OnlyOnRanToCompletion` because
    we only want the consumers to be scheduled to run when the previous task succeeded.
    To be a more complete solution, we would want to use `TaskContinuationOptions.OnlyOnFaulted`
    to set up a continuation for the failure path as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using a continuation to update a UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common challenge when developing multithreaded WPF applications is that the
    UI controls have thread affinity, meaning they can only be updated by the thread
    that created them. This is usually the main thread of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL, however, offers a clean way to marshal the results from a TPL task
    to the correct thread for updating the UI. It accomplishes this with the `TaskScheduler.FromCurrentSynchronizationContext`
    method which creates a `TaskScheduler` associated with the current `SyncronizationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to create a WPF application which will start a task
    to get the word count of a book. The task will have a continuation that is created
    in the correct synchronization context by calling `TaskScheduler.FromCurrentSynchronizationContext`.
    The continuation will perform the UI update.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a WPF application and see how we can use the TPL marshal data to
    the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `Continuation8` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml.cs` file and ensure the following `using` directives
    to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to `MainWindow.xaml` and replace the XAML with the following code to
    create the UI layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/0225OT_02_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now add a `Label` from the toolbox to your window. Change the **Name** property
    to `lblWordCount` and remove the default value from the **Content** property.![How
    to do it…](img/0225OT_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OK, now double click on the **Get Word Count** button on your form to open up
    `Mai``nWindow.xaml.cs` in the `Button_Click_1` event handler. This is where we
    will create our task and continuation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Button_Click_1` event handler, create a `Task` that reads the content
    of a book into a string array. The `Task` will return a string array result which
    will be used in a continuation to display the word count to the UI. The `Task`
    will be continued with a continuation created with `TaskScheduler.FromCurrentSynchronizationContext`
    called in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application windows
    should look something as shown in the following screenshot:![How to do it…](img/0225OT_02_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tasks run on instances of the `TaskScheduler` class. Two implementations of
    `TaskScheduler` are included as part of the .NET Framework 4.5\. One is the default
    scheduler, which is integrated with the .NET ThreadPool. The other is the type
    of `TaskScheduler` returned from the static method `TaskScheduler.FromCurrentSynchronizationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '`SynchronizationContext` provides two methods, `Send` and `Post`, both of which
    accept a delegate to be executed. `Send` synchronously invokes the delegate, and
    `Post` asynchronously invokes the delegate.'
  prefs: []
  type: TYPE_NORMAL
- en: UI controls should only be accessed by the thread that created them, usually
    the main UI thread. So, if a thread working in the background wants to update
    something in the UI, it needs to marshal that data back to the UI thread so that
    the controls can be accessed safely. In WPF, you would do this with the target
    thread's `Dispatcher` and corresponding `Invoke/BeginInvoke` methods. With the
    .NET 4.5 TPL, a new type may be derived from `SynchronizationContext` such that
    its `Send` method synchronously marshals a delegate to the right thread for execution,
    and `Post` does the same but asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: UI frameworks like WPF publish an instance of their `SynchronizationContext`
    derived class to `SynchronizationContext.Current`. Your code can then get `SynchronizationContext.Current`
    and use it to marshal work.
  prefs: []
  type: TYPE_NORMAL
- en: '`TaskScheduler.FromCurrentSynchronizationContext` creates a `TaskScheduler`
    that wraps the `SynchronizationContext` returned from `SynchronizationContext.Current`.
    In doing so, this gives you a `TaskScheduler` that will execute `Tasks` on the
    current `SynchronizationContext`. This means you can create tasks that are able
    to access UI controls safely by running them on the right scheduler.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we can create a `Task` or continuation with a derived `TaskScheduler`,
    we can create the continuation with a scheduler that will execute the continuation
    on the proper context to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
