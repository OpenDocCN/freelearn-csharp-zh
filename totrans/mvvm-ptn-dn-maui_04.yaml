- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Binding in .NET MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the fundamentals of data binding in .NET
    MAUI. Data binding is not only a core feature of .NET MAUI but also a crucial
    component for effectively building applications using the MVVM design pattern.
    It creates a robust link between your View and ViewModel, facilitating efficient
    communication and synchronization between the two.
  prefs: []
  type: TYPE_NORMAL
- en: As we delve deeper into the realm of data binding, it’s essential to grasp some
    advanced techniques and features. These are the building blocks that empower you
    to create dynamic user interfaces as efficiently as possible. They allow us to
    design user interfaces that are not only more interactive but also easier to manage
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ValueConverters and `StringFormat`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element and relative binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiled bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, combined with what we’ve covered in the previous
    one, you will have a well-rounded and thorough understanding of data binding in
    .NET MAUI. This knowledge will enable you to effectively apply these techniques
    in your applications. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be adding functionality to the *Recipes!* app.
    All the required assets needed to follow along, including all the code used in
    this chapter, can be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter04](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: ValueConverters and StringFormat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, the data in your ViewModel doesn’t perfectly match the format
    expected by the UI. For example, you may have a `DateTime` object in your ViewModel
    that you want to display in a specific string format in your View, or an enumeration
    that should be represented as a more user-friendly string.
  prefs: []
  type: TYPE_NORMAL
- en: This is where **ValueConverters** and **StringFormat** come into play. Both
    of these techniques act as intermediaries, transforming and adapting your ViewModel
    data into a format suitable for display or interaction in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll delve into how to create and use ValueConverters to effectively
    manage these data transformations, and how formatting can further refine the presentation
    of your data, ensuring it is meaningful and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using ValueConverters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ValueConverter acts as an intermediary between the source (typically the
    ViewModel) and the target (the View). It provides a way to transform or convert
    data as it passes from source to target or vice versa (*Figure 4**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Usage of a converter](img/B20941_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Usage of a converter'
  prefs: []
  type: TYPE_NORMAL
- en: A common scenario might involve a ViewModel property that is a certain type,
    such as an enumeration or a complex object, which needs to be displayed differently
    in the UI. A ValueConverter can convert data from one type to another that is
    compatible and appropriate for the UI. Similarly, user input received in the UI
    may need to be converted back into a different format before being stored in the
    ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueConverters are classes that implement the `Microsoft.Maui.Controls.IValueConverter`
    interface, which defines two methods – `Convert` and `ConvertBack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Convert` method is responsible for transforming a value from the binding
    source to the binding target. It takes the original value, the target type, an
    optional parameter, and culture information as parameters. This method performs
    a conversion and returns an object that represents the transformed data. The transformed
    data is then used to update the property on the View. It is important to ensure
    that the returned object matches the expected type of the binding target property
    or a compatible type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the method’s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This is the source data that needs to be converted. This is usually
    data from your ViewModel that you want to display in your View. Because this can
    be anything, it is provided as `object`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetType`: This is the type of the binding target property. It’s what the
    method should return the data as. For example, if you’re binding to a property
    in your View that is of the `Microsoft.Maui.Graphics.Color` type, then `targetType`
    would be `Microsoft.Maui.Graphics.Color`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameter`: This is an optional `parameter` that can be used to pass additional
    information to the converter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`culture`: This is the `System.Globalization.CultureInfo` culture that should
    be used in the converter. This is especially important when dealing with dates,
    times, and numbers, as these can be represented differently in different cultures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConvertBack` method is used to reverse the conversion process, transforming
    data from the binding target back to the binding source. In many cases, the `ConvertBack`
    method is not implemented as it only has purpose on `TwoWay` and `OneWayToSource`
    data bindings, where the data on the View needs to be converted before it’s passed
    to the ViewModel. The return value and parameters are analogous to the `Convert`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This might all be a little abstract at this point, so let’s take a look at building
    and using a ValueConverter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ValueConverter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate the flexibility and power of ValueConverters, we’re going to
    enhance our app by introducing a rating indicator for our recipes. Simply displaying
    a numeric value isn’t the most appealing or intuitive way to represent a recipe’s
    rating. Therefore, we’ll utilize a ValueConverter to replace these numbers with
    star icons, creating a visually engaging and user-friendly rating representation.
    Our custom ValueConverter, `RatingToStarsConverter`, will convert a double value
    into a string. In conjunction with a specific font, this string will display as
    star icons. But before we can dive into building our converter, we need to take
    care of some preparatory steps first:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to create `RecipeRatingsSummaryViewModel`. Right-click the
    `ViewModels` folder and select `RecipeRatingsSummaryViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, we are only adding an `AverageRating` property of the `double` type
    to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are also including a value to indicate the maximum amount of stars that
    can be given by a user. Next, let’s add an additional property called `RatingDetail`
    to `RecipeDetailViewModel` and assign it a new instance by default:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An efficient approach to displaying icons in an application is through the
    use of a specialized icon font. These fonts, which are readily available both
    for free and for purchase, allow you to easily incorporate various icons into
    your application. The principle is simple: incorporate the desired icon font into
    your app, then assign this font as `FontFamily` on the `Label` class where you
    wish to display the icon. From there, all that’s left is to set the `Text` property
    on the `Label` class to the value that corresponds to the icon you wish to display.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s include Google’s Material Design Icon font in our app so that we can
    use this font to display the recipe’s rating later on. You can find the `MaterialIcons-Regular.ttf`
    font file in the `Chapter 04``/Assets/Fonts` folder or you can download it from
    [https://github.com/google/material-design-icons/tree/master/font](https://github.com/google/material-design-icons/tree/master/font):'
  prefs: []
  type: TYPE_NORMAL
- en: In the Visual Studio `Resources/Fonts` folder in the **Recipes.Mobile** project
    and select **Open Folder in** **File Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `MaterialIcons-Regular.ttf` font file over to this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Visual Studio, you should see the newly added font file in the **Solution
    Explorer**. The file’s **Build Action** should have automatically been set to
    **MauiFont**, as shown in *Figure 4**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2: MaterialIcons-Regular.ttf file properties](img/B20941_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: MaterialIcons-Regular.ttf file properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to be able to use this font in our MAUI app, we need to add it through
    `MauiAppBuilder`. Go to `MauiProgram.cs` and add it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will allow us to use this font by setting the `FontFamily`
    property of a `Label` class or any control that displays text to `MaterialIconsRegular`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that all of this is in place, we can finally start writing our first ValueConverter:
    `RatingToStarsConverter`. This converter should convert the rating of a recipe
    into little star icons.'
  prefs: []
  type: TYPE_NORMAL
- en: RatingToStarsConverter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`RatingToStarsConverter` should convert any double value into a string value
    that represents stars. This is exactly what converters are for – taking in an
    object of a particular data type (double) and returning an object of another data
    type (string). For the visualization of the star icons, we can use the icon font
    we added earlier. [https://fonts.google.com/icons?icon.set=Material+Icons](https://fonts.google.com/icons?icon.set=Material+Icons)
    provides an overview of all the available icons that exist in the font that we
    just added. By clicking an icon, you can see different ways to target it. We are
    interested in the code value. The star icon we want to use has a code of `e838`
    and the icon for a half star is identified by the `e839` code. Packed with this
    knowledge, let’s see how we can create `RatingToStarsConverter`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Converters`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Converters` folder and select **Add** | **Class…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of our converter, `RatingToStarsConverter`, and click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the class implement the `Microsoft.Maui.Controls.IValueConverter` interface,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start implementing the `Convert` method. As this converter could
    be used in any binding statement, the first thing that we need to do is check
    if the binding source is indeed a value of the `double` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `value` parameter is not the type that we expect, or it doesn’t fall
    within the expected range, we are returning a default value – in this case, `string.Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we’ve validated the provided `value`, we can add the rest of the logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on the rating value we receive, we will return a string that contains
    icons defined in the `MaterialIcons` font we added to our project. For full stars,
    we must generate a collection of `fullStar` icons. The `string.Join` method then
    consolidates these individual icon strings into a single string. If the rating
    includes a decimal value of 0.5 or higher, we also append a `halfStar` icon to
    the string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That’s all we need to do in `RatingToStarsConverter`. We don’t need to implement
    the `ConvertBack` method as this particular converter will not be used in `TwoWay`
    or `OneWayToSource` scenarios. When not implementing the `ConvertBack` method,
    it’s good practice to add a comment indicating it’s intentionally not implemented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we want to use our newly created converter, so we need to head over to
    `RecipeDetailPage`. The first thing we need to do there is add the namespace of
    the converter to our XAML, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By declaring this XML namespace, we can reference anything within the `Recipes.Mobile.Converters`
    namespace directly in this XAML page using the `conv` prefix. The prefix can be
    anything you choose. To declare it, simply type `xmlns:` (XML namespace), followed
    by your chosen prefix, and then set it equal to the CLR namespace you wish to
    reference. This technique allows for cleaner and more organized code, as you can
    use this prefix to reference classes and components from the specified namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add an instance of `RatingToStarsConverter` to our page so
    that we can use it later on in our binding statements. The following code block
    shows how we can add an instance of the converter as a resource to the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By giving the resource a `Key` value, we can reference it later on in our XAML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can now implement the binding of the `RatingDetail.AverageRating`
    property and use `RatingToStarsConverter` as the converter for this binding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: About resources, StaticResource, and DynamicResource
  prefs: []
  type: TYPE_NORMAL
- en: The converter we’ve just added to the resources is now accessible on this particular
    page. It’s important to note that the scope of this resource is local to this
    page only. That means if you want to use this converter on other pages, you would
    have to declare it in their resources too.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to use this converter across multiple pages, consider adding it
    to your `App.xaml` resources instead. By doing this, the converter becomes globally
    accessible throughout your app, eliminating the need to redeclare it on each page.
    This leads to cleaner and more maintainable code, especially for resources such
    as converters, which are often used throughout an application.
  prefs: []
  type: TYPE_NORMAL
- en: The `StaticResource Markup Extension` looks up a resource in a resource dictionary
    and assigns it to the property that it is set on. This resource lookup is performed
    only once when the page or control that uses `StaticResource` is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The `DynamicResource Markup Extension`, on the other hand, is used when the
    value can change and the UI needs to be updated to reflect this change. It maintains
    a link between the property and the resource, so when the resource changes, the
    property is updated too. `DynamicResource` is perfect for scenarios such as theme
    switching, where the values in the resource dictionary can be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can express the converter to use from the code if you define
    your data binding from code-behind. For this to work, you need to name the label
    you want to show the rating on `lblRating`, using the `x:Name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetBinding` method accepts an optional converter parameter that allows
    you to specify the converter that should be used. When you run the app, you should
    see stars representing the recipe’s rating, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: RatingToStartsConverter in action](img/B20941_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: RatingToStartsConverter in action'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enhance the user interface and user experience of our app a notch further.
    To achieve this, we’ll assign unique colors to the rating indicator based on the
    average rating of a recipe.
  prefs: []
  type: TYPE_NORMAL
- en: RatingToColorConverter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With `RatingToColorConverter`, we should be able to give the stars that represent
    the recipe’s rating a color depending on the average rating. Additionally, we
    want to display four stars consistently in the background, regardless of the recipe’s
    average score. *Figure 4**.4* shows exactly what we want to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Rating indicator using different colors](img/B20941_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Rating indicator using different colors'
  prefs: []
  type: TYPE_NORMAL
- en: This visual cue serves as a rating scale that helps users immediately comprehend
    where a recipe stands in terms of rating. As the background stars need to be in
    a different color from the ones indicating the actual score, our new ValueConverter
    must accept a parameter to distinguish between foreground and background colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s get started! Like we did before, we need to add a converter and implement
    the `IValueConverter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the **Converters** folder in the **Recipe.Mobile** project and select
    **Add** | **Class…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `RatingToColorConverter` as the name and click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class implement the `IValueConverter` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Convert` method, we can check the parameter that is being passed in.
    When the `"background"` value is passed as a parameter to this converter, we want
    to return a slightly different color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have this information, we can go ahead and implement the rest of this
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on the provided rating, this converter returns a particular color.
    On top of that, if the converter parameter is `"background"`, a slightly different
    color accent is returned that should serve as a background color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code block shows how we can add this converter as a resource
    to `RecipeDetailPage`. This allows us to use the converter on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that in place, we can use the defined key, `"ratingToColorConverter"`,
    to reference this converter in our data binding statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, replace the label we had previously showing the `Rating` property
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By placing both labels in `Grid`, the labels will overlap and as a result, the
    first one will act as the backdrop for the rating indicator. This label’s `Text`
    property is bound to the `RatingSummary.MaxRating` property and indicates the
    upper bound of the ratings. `RatingToStarsIconConverter` will transform this value
    into star icons. Additionally, its `TextColor` property is bound to the `RatingSummary.AverageRating`
    property of the ViewModel, using our newly created `RatingToColorConverter` to
    decide its color. Note that we’ve set the `ConverterParameter` property of the
    `Binding Markup Extension` to `"background"`. This parameter is forwarded to the
    converter, signaling that we need a color suitable for a background icon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second `Label` class’s `Text` and `TextColor` properties are also bound
    to the `RatingSummary.AverageRating` property of `RecipeDetailViewModel`. `RatingToColorConverter`
    is used as the converter for the `TextColor` property, providing a color based
    on the recipe’s rating. Because we didn’t use `ConverterParameter` here, the converter
    understands that it needs to produce a color intended for the foreground.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These two simple ValueConverters provide a nice visualization for the recipe’s
    rating. When running the app, we should see a nice colorful visualization of the
    recipe’s rating, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Rating indicator using different colors](img/B20941_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Rating indicator using different colors'
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t implemented the `ConvertBack` method of the ValueConverters in these
    examples as they only serve a purpose in `TwoWay` or `OneWayToSource` data bindings.
    Let’s have a quick look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: InverseBoolConverter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A very common and simple converter is `InverseBoolConverter`: it just takes
    a `bool` value and returns the inverse. An implementation of `InverseBoolConverter`
    typically also includes an implementation for its `ConvertBack` method. This is
    particularly relevant because, in the context of two-way data binding, an action
    on the UI can trigger an update to the bound bool value. By providing a `ConvertBack`
    implementation, we ensure that changes in the UI are correctly mirrored back to
    the ViewModel, keeping the data synchronized. Let’s see how we can create a converter
    with an implemented `ConvertBack` method:'
  prefs: []
  type: TYPE_NORMAL
- en: To create `InverseBoolConverter`, create a new class called `InverseBoolConverter`
    and let it implement the `IValueConverter` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s write an `Inverse` method that returns a `bool` value and takes a `value`
    parameter of the `object` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts a `value` parameter of the `object` type. Inside this method,
    we check if the provided value is a `bool` value. If it is, we return `inverse`;
    if it’s not, we return `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This method can now be used by both the `Convert` and `ConvertBack` methods
    as both methods should inverse the given `bool` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see this converter in action, we can go to `RecipeDetailViewModel`, update
    the `ShowAllergenInformation` property to `HideAllergenInformation`, and change
    its default value to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the meaning of this property is now the opposite of what it was, we
    need to update the bindings on our UI. This is exactly where our new `InverseBoolConverter`
    comes in. After we’ve added `InverseBoolConverter` to the resources of `RecipeDetailPage`,
    we can update the XAML to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`InverseBoolConverter` will inverse the `HideExtendedAllergenList` property’s
    value. The `Convert` method will be invoked in the `OneWay` data binding scenario,
    whereas the `ConvertBack` method will be called when tapping `CheckBox`, triggering
    an update of `IsCheckedProperty`, which – through the `OneWayToSource` data binding
    – needs to update the property on the ViewModel.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ValueConverters are a powerful feature in data binding that enables seamless
    transformation of data between the ViewModel and the View. They provide a clean,
    maintainable way to control the display of data and handle discrepancies between
    the format of data in the ViewModel and how it needs to be displayed or inputted
    in the View.
  prefs: []
  type: TYPE_NORMAL
- en: Keep converters simple
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that on screens with a lot of converters, these converters can
    be invoked a lot of times, especially in collections. As such, it is advised to
    keep converters as simple as possible and consider their performance.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, mastering ValueConverters will greatly enhance your ability
    to build dynamic, data-driven applications with .NET MAUI. In [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086),
    *Community Toolkits*, we will see that the .NET MAUI Community Toolkit is packed
    with converters that are up for grabs for you to use in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to transform how data from the ViewModel needs to be
    displayed is by providing `StringFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: StringFormat
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Despite being less powerful than ValueConverters, providing `StringFormat` to
    your data binding offers a quick and straightforward way to modify the presentation
    of your data directly within your data binding expressions, saving you from the
    overhead of creating a separate converter for simple transformations. It leverages
    the standard .NET formatting conventions to shape the bound data into a specific
    string format. It’s particularly useful when the bound data is of a primitive
    or built-in .NET data type, such as `DateTime`, `int`, `float`, `double`, and
    so on, and you want to format that data in a specific way for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first example, let’s show the calories of the recipe on `RecipeDetailPage`,
    as shown in *Figure 4**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Showing the calories and cooking time](img/B20941_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Showing the calories and cooking time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at how simple this is to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the optional `Calories` and `ReadyInMinutes` properties to `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as we want to show these properties on the screen, we need to indicate
    what this value means. We don’t just want to show the raw values. For that, we
    could use multiple labels or a converter to enrich these raw values with additional
    context. Alternatively, we could use `StringFormat`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Much like how we use the `string.Format` method in .NET, we can use the `StringFormat`
    property of `Binding Markup Extension`. In the format string, we can use a placeholder
    (`{0}`) to indicate where the bound value should be inserted. This approach provides
    a straightforward way to integrate bound values into formatted string expressions.
  prefs: []
  type: TYPE_NORMAL
- en: And the similarity with `string.Format` doesn’t stop there. We can even use
    numeric, timespan, and date and time format strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let’s add a `LastUpdated` timestamp to `RecipeDetailPage`.
    Let’s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a property called `LastUpdated` to `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can go to `RecipeDetailPage` and bind this value to a new label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, we might want to show the average ratings textually on the screen
    as well, limiting it to 1 decimal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the app, specifically focusing on these two labels. Here is what
    they look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Leveraging StringFormat](img/B20941_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Leveraging StringFormat'
  prefs: []
  type: TYPE_NORMAL
- en: ValueConverters and `StringFormat` not only facilitate the translation of data
    from the ViewModel into something more suitable for our UI, but also allow for
    the creation of more dynamic, responsive, and user-friendly applications. By using
    ValueConverters, we can handle complex conversions, while `StringFormat` helps
    us effortlessly format strings right in our bindings. Both of these mechanisms
    empower us to handle data transformations seamlessly, without overloading our
    ViewModel with UI-related concerns. Remember, effective data binding is not only
    about linking data; it’s also about presenting data in the most intuitive way
    possible to our users.
  prefs: []
  type: TYPE_NORMAL
- en: But what about when things don’t go exactly as planned? What if the data we’re
    binding to is null? This is where `TargetNullValue` and `FallbackValue` in our
    bindings to handle such cases and ensure a more robust, fail-safe user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Fallbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are occasions where data binding can fail; the binding source cannot be
    resolved (yet) or the returned value is null. Although ValueConverters and additional
    code could tackle many such situations, we can also enhance the resilience of
    our data bindings by setting fallback values. This can easily be done by setting
    the `TargetNullValue` or `FallbackValue` property in our binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: TargetNullValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TargetNullValue` property can be used in situations where we want to handle
    the situation where the resolved binding source target returns `null`. In other
    words, the binding engine can resolve the bound property, but this property returns
    a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, the `Calories` property on `RecipeDetailViewModel` is defined as
    a nullable `int`. This makes it essential for us to handle any potential null
    values in our data binding elegantly. If we leave the binding statement as-is,
    the label would show `"Calories: kcal"` if the `Calories` property is `null`.
    Not very clean-looking, right? Let’s fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <Label Text="{Binding ReadyInMinutes, StringFormat='Ready
  prefs: []
  type: TYPE_NORMAL
- en: 'in: {0} minutes'', TargetNullValue=''No cooking time'
  prefs: []
  type: TYPE_NORMAL
- en: 'RecipeDetailPage. And because there might not always be an image added to a
    recipe, we need to make sure we provide a TargetNullValue property so that a default
    image is shown. Let’s take a look at how we could implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the `Chapter 04``/Assets/caesarsalad.png` and `Chapter
    04``/Assets/fallback.png` images to the `Resources/Images` folder of the `Recipes.Mobile`
    project. The easiest way to do this is by using your operating system’s file manager
    to copy the files over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `Image` property to `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Next, add the following XAML to `RecipeDetailPage.xaml`, just above the
    **Add**/**Remove as** **favorite** buttons:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the value on `RecipeDetailViewModel` is set to `caesarsalad.png`, the
    app will show this image on the screen. However, if you assign `null` to it, the
    `fallback.png` image will be shown as it is defined as `TargetNullValue`. *Figure
    4**.8* shows what this looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8: Showing the recipe’s image (left) or a fallback value (right)](img/B20941_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Showing the recipe’s image (left) or a fallback value (right)'
  prefs: []
  type: TYPE_NORMAL
- en: Not too complex, right? It does get a little bit more complicated when a ValueConverter
    is involved. If the bound property is `null`, this `null` value will get passed
    into the ValueConverter. Only if said converter returns null will `TargetNullValue`
    be used. If the ValueConverter were to return a non-null value, `TargetNullValue`
    would not be used. While it is possible to define `TargetNullValue` as `StaticResource`
    or use the `x:Static Markup Extension` to assign it a static value, it is not
    possible to set its value with a binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `AverageRating` property of `RecipeRatingsSummaryViewModel`,
    we could assign this a null value by default and update the `TextColor` binding
    statements to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: public object Convert(object value, Type targetType, object
  prefs: []
  type: TYPE_NORMAL
- en: parameter, CultureInfo culture)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: var hex = value switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: _ => "#EBEBEB"
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return Color.FromArgb(hex);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <Label FontSize="8"
  prefs: []
  type: TYPE_NORMAL
- en: Text="{Binding RatingDetail.AverageRating,
  prefs: []
  type: TYPE_NORMAL
- en: StringFormat='{0:0.#} avg. rating',
  prefs: []
  type: TYPE_NORMAL
- en: Label class displaying "Ratings not available" when the binding engine is unable
    to resolve the RatingDetail.AverageRating property. Just like with the TargetNullValue
    property, when FallbackValue is being used, the StringFormat property will be
    ignored. Additionally, a converter defined on this binding statement would also
    be ignored when using the FallbackValue value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to combine the two, both `TargetNullValue` and `FallbackValue`,
    we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <HorizontalStackLayout>
  prefs: []
  type: TYPE_NORMAL
- en: <Label Text="Show extended allergen list?"
  prefs: []
  type: TYPE_NORMAL
- en: VerticalOptions="Center" />
  prefs: []
  type: TYPE_NORMAL
- en: <CheckBox x:Name="cbShowAllergens" IsChecked="False" />
  prefs: []
  type: TYPE_NORMAL
- en: </HorizontalStackLayout>
  prefs: []
  type: TYPE_NORMAL
- en: <VerticalStackLayout Margin="10,0,0,0" IsVisible="{Binding
  prefs: []
  type: TYPE_NORMAL
- en: IsChecked, Source={Reference cbShowAllergens}}">
  prefs: []
  type: TYPE_NORMAL
- en: <Label Text="ToDo, add extended allergen list" />
  prefs: []
  type: TYPE_NORMAL
- en: </VerticalStackLayout>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <Button
  prefs: []
  type: TYPE_NORMAL
- en: Command="{Binding AddAsFavoriteCommand}"
  prefs: []
  type: TYPE_NORMAL
- en: IsVisible="{Binding IsEnabled, Source={RelativeSource
  prefs: []
  type: TYPE_NORMAL
- en: Self}}"
  prefs: []
  type: TYPE_NORMAL
- en: Text="Add as favorite" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <Button
  prefs: []
  type: TYPE_NORMAL
- en: BackgroundColor="LightSlateGray"
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: TextColor="{Binding BackgroundColor,
  prefs: []
  type: TYPE_NORMAL
- en: Source={RelativeSource AncestorLevel=2,
  prefs: []
  type: TYPE_NORMAL
- en: TextColor property of the button is now bound to the BackgroundColor property
    of its second ancestor (AncestorLevel=2), which is of the VerticalStackLayout
    type (AncestorType={x:Type VerticalStackLayout}). Keep in mind that whenever the
    structure of the page changes, there might be no other ancestor of this type at
    the second level.
  prefs: []
  type: TYPE_NORMAL
- en: TemplatedParent relative binding mode
  prefs: []
  type: TYPE_NORMAL
- en: A `Control Template` is an XAML markup snippet that defines how a control should
    be rendered. When you’re inside a control template, you can use `TemplatedParent`
    to bind to the properties of the control that’s using the template. We will dive
    into this in more detail in [*Chapter 11*](B20941_11.xhtml#_idTextAnchor182),
    *Creating* *MVVM-Friendly Controls*.
  prefs: []
  type: TYPE_NORMAL
- en: Relative bindings in XAML offer a powerful way to connect properties of different
    elements within our user interface. One of its strongest aspects is its ability
    to traverse up the visual tree, enabling access to binding contexts of other elements.
    This feature becomes especially useful when the current element’s binding context
    isn’t sufficient or when we need to link a property to an element outside of its
    immediate scope.
  prefs: []
  type: TYPE_NORMAL
- en: In many UI scenarios, a certain state is defined by a combination of multiple
    properties. While it’s certainly possible to create an additional property in
    the ViewModel that aggregates these properties for binding, there is a better,
    more elegant way to deal with this. Let’s have a look at multi-bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-bindings
  prefs: []
  type: TYPE_NORMAL
- en: Multi-binding is a powerful feature in XAML data binding that allows you to
    bind a single target property to multiple source properties and then apply logic
    to produce one single value. This technique is particularly useful when a target
    property’s value depends on more than one source property. The simplest example
    of this is using `StringFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-binding StringFormat
  prefs: []
  type: TYPE_NORMAL
- en: A typical multi-binding scenario is where you would like to display multiple
    values in one label. We could, of course, create a property on the ViewModel that
    concatenates those values, or we could define this as a Multi-binding with `StringFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we want to show the author of the recipe next to the **Last
    updated** timestamp that we already have on our page (*Figure 4**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Showing the author next to the Last updated timestamp](img/B20941_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Showing the author next to the Last updated timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add an `Author` property to our ViewModel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Next, replace the label that shows the `LastModified` timestamp with the
    following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `MultiBinding` class allows us to set multiple bindings. The `StringFormat`
    property of `MultiBinding` allows us to construct a single string value from multiple
    bindings. This operates much like the `string.Format` method, utilizing different
    placeholders (`{0}`, `{1}`, `{2}`, and so on) that correspond to each binding.
    This makes it easier to construct complex string values from multiple data sources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Binding properties
  prefs: []
  type: TYPE_NORMAL
- en: What you define as `Binding` inside `MultiBinding` is the same thing as `Binding
    Markup Extension`, which we used in our data bindings previously. It has properties
    such as `Converter`, `ConverterParameter`, `StringFormat`, `TargetNullValue`,
    `FallbackValue`, and others that can be individually configured for each `Binding`
    within `MultiBinding`, allowing for fine-grained control over each component of
    `MultiBinding`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-binding goes beyond just concatenating strings in a specific format. Let’s
    have a look at the `Converter` property of `MultiBinding`.
  prefs: []
  type: TYPE_NORMAL
- en: IMultiValueConverter
  prefs: []
  type: TYPE_NORMAL
- en: The `MultiBinding` class has a property called `Converter` that’s of the `Microsoft.Maui.Controls.IMultiValueConverter`
    type. This interface is similar to `IValueConverter` but with a significant distinction.
    The `Convert` method in `IMultiValueConverter` accepts an array of objects, representing
    all the individual bound values, rather than a single object as in `IValueConverter`.
    Likewise, the `ConvertBack` method of `IMultiValueConverter` returns an array
    of objects, not just one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `RatingIndicator` in `RecipeDetailView`. The colors of the
    stars should not only depend on the average rating but also the total of reviews.
    If the recipe has less than 15 reviews, we’ll show a generic default color. Only
    when the recipes have more reviews will we use the color scale we used earlier.
    To make that work, we’ll use `MultiBinding` to bind to both `AverageRating` and
    `TotalReviews` from `RecipeRatingsSummaryViewModel` and `IMultiValueConverter`
    to decide the color of the stars:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to add an additional property called `TotalReviews`
    to our `RecipeRatingsSummaryViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 2.  Next, we can create the `RatingAndReviewsToColorConverter` class, which
    implements the `IMultiValueConverter` interface. For that, we need to right-click
    the `Converter` folder, select **Add** | **Class…**, and enter the name of the
    converter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make the class implement `IMultiValueConverter` and add the following code
    to the `Convert` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this `Convert` method, we have access to the array of bound values. This
    allows us to write logic by taking every given value into account. In this scenario,
    we are expecting the total number of reviews to be the first value and the rating
    to be the second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.  Now, we can add this converter as a resource to our `RecipeDetailPage`,
    just like we did before with other ValueConverters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '5.  Finally, we can use `RatingAndReviewsToColorConverter` in a `MultiBinding`
    class on the `Label` class’s `TextColor` property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`IMultiValueConverter`, in conjunction with `MultiBinding`, offers a dynamic
    and flexible approach to dealing with complex binding scenarios. By accepting
    an array of inputs and processing them into a singular output, it allows us to
    handle multi-source dependencies in our UI.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to look into in the context of data binding is compiled
    bindings. This feature appears to be a little less known, despite it having a
    lot of advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled bindings
  prefs: []
  type: TYPE_NORMAL
- en: Compiled bindings are a more performant way of creating bindings and they are
    verified at compile-time instead of at runtime. Typically, the data binding engine
    uses reflection to get or set property values on the objects being bound. This
    approach is flexible and powerful because it allows the binding engine to interact
    with any object, regardless of its type. However, it also has some performance
    implications because reflection is slower than direct property access, and it
    can lead to errors that are only detectable at runtime if a property name is misspelled
    or if the property doesn’t exist. In contrast, compiled bindings are checked at
    compile time, which means they can catch errors before the app is even run. Furthermore,
    because the bindings are compiled into the app, the runtime performance is improved
    as there’s no need for the binding resolution process that takes place with traditional
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling compiled bindings is pretty simple: with the `x:DataType` attribute,
    we can specify the type of the object that the XAML element and its children will
    bind to. So, basically, on our `RecipeDetailPage`, we could add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With this, we indicate that the type of `BindingContext` will be `Recipes.Client.Core.ViewModels.RecipeDetailViewModel`,
    enabling the XAML compiler to validate bindings at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a caveat that will prevent us from compiling and running
    the application from the bat. In our existing XAML code, we’ve explicitly set
    `BindingContext` of `HorizontalStackLayout` to the `IngredientsList` property.
    This confuses the XAML compiler as it assumes elements inside `HorizontalStackLayout`
    are still bound to `RecipeDetailViewModel`, which isn’t the case. This misunderstanding
    results in an error message in Visual Studio (*Figure 4**.10*). This error message
    is evidence that, by adding the `x:DataType` attribute, bindings are now validated
    and compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Binding error](img/B20941_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Binding error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, fixing this error might not be as straightforward as you might think:
    it’s not only adding setting the `x:DataType` attribute on `VerticalStackLayout`
    to `IngredientsListViewModel` – the binding itself also needs to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With these adjustments in place, we can build and run our app as before. But
    now, our app benefits from the performance improvements of compiled bindings.
    Need more proof that bindings are now compiled? Try misspelling the name of a
    bound property in a binding statement. As shown in *Figure 4**.11*, Visual Studio
    will promptly alert you about the nonexistent property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Property not found on the specified type](img/B20941_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Property not found on the specified type'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled bindings give you design-time checks and will even give you IntelliSense
    when writing binding statements. But most importantly, they also lead to faster
    page load times and better app performance overall.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: Data binding is a powerful concept in XAML that makes it easier to separate
    our view logic from our business logic. It’s a huge enabler for doing MVVM in
    .NET MAUI. It is a complex subject and it can be challenging to fully master every
    aspect of it. It involves understanding a variety of concepts and techniques,
    from simple data bindings to multi-bindings and converters, and from element and
    relative bindings to high-performance compiled bindings.
  prefs: []
  type: TYPE_NORMAL
- en: However, don’t be overwhelmed. Like any complex subject, understanding data
    binding comes with time and practice. The more you work with it, the more comfortable
    you’ll become, and many aspects of it will eventually become second nature.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the ultimate objective is to efficiently apply the MVVM pattern. In
    this context, data binding plays a crucial role in connecting your ViewModel’s
    data and business logic with the UI. The knowledge you’ve gathered in this chapter
    has brought you one step closer to that goal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll be looking at community toolkits that can facilitate
    implementing the MVVM pattern in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Multi-binding*: [https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/multibinding](https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/multibinding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Relative* *bindings*: [https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings](https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compiled* *bindings*: [https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings](https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
