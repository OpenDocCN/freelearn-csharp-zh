- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building a Location Tracking App Using GPS and Maps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPS 和地图构建位置跟踪应用
- en: In this chapter, we will create a location tracking app that saves the location
    of the user and displays it as a heat map. We will learn how to run tasks in the
    background on iOS, macOS, and Android devices. We will extend the .NET MAUI `Map`
    control to display the map with the saved locations directly in the map.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个位置跟踪应用，该应用将保存用户的地理位置并以热图的形式显示。我们将学习如何在 iOS、macOS 和 Android 设备上后台运行任务。我们将扩展
    .NET MAUI 的 `Map` 控件，以便直接在地图中显示保存的地理位置。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Tracking the location of a user in the background on an iOS device and a macOS
    device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 iOS 设备和 macOS 设备上后台跟踪用户的地理位置
- en: Tracking the location of a user in the background on an Android device
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 设备上后台跟踪用户的地理位置
- en: How to show maps in a .NET MAUI app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 .NET MAUI 应用中显示地图
- en: How to extend the functionality of .NET MAUI maps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扩展 .NET MAUI 地图的功能
- en: Let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, you’ll need to have Visual Studio for Mac
    or Windows installed, as well as the .NET MAUI components. See *Chapter 1*, *Introduction
    to .NET MAUI*, for more details on how to set up your environment. To build an
    iOS app using Visual Studio for Windows, you must have a Mac connected. If you
    don’t have access to a Mac at all, you can just complete the Android part of this
    project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此项目，您需要安装 Visual Studio for Mac 或 Windows，以及 .NET MAUI 组件。有关如何设置环境的更多详细信息，请参阅
    *第 1 章*，*.NET MAUI 简介*。如果您使用 Visual Studio for Windows 构建 iOS 应用，您必须连接一台 Mac。如果您根本无法访问
    Mac，您只需完成此项目的 Android 部分。
- en: You can find the full source for the code in this chapter at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章中找到代码的完整源代码，链接为 [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition)。
- en: Important information for Windows users
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户的重要信息
- en: At the time of writing, there was no `Map` control for the Windows platform
    in .NET MAUI. This is due to the lack of a `Map` control in the underlying WinUI
    platform. For the latest information on `Map` support in Windows, visit the `Map`
    documentation at [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，.NET MAUI 在 Windows 平台上没有 `Map` 控件。这是由于底层 WinUI 平台上缺少 `Map` 控件。有关 Windows
    上 `Map` 支持的最新信息，请访问 [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map)
    的 `Map` 文档。
- en: Project overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Many apps can be made richer by adding a map and location services. In this
    project, we will build a location tracking app that we will call `MeTracker`.
    This app will track the position of the user and save it to an SQLite database
    so that we can visualize the result in the form of a heat map. To build this app,
    we will learn how to set up processes in the background on iOS, macOS, and Android.
    Luckily for us, the iOS and macOS implementations are identical; however, the
    Android implementation is very different. For the map, we will use the .NET MAUI
    `Maps` component and extend its functionality to build a heat map.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加地图和位置服务，许多应用可以变得更加丰富。在本项目中，我们将构建一个名为 `MeTracker` 的位置跟踪应用。此应用将跟踪用户的地理位置并将其保存到
    SQLite 数据库中，以便我们可以以热图的形式可视化结果。为了构建此应用，我们将学习如何在 iOS、macOS 和 Android 上设置后台进程。幸运的是，iOS
    和 macOS 的实现是相同的；然而，Android 的实现非常不同。对于地图，我们将使用 .NET MAUI 的 `Maps` 组件并扩展其功能以构建热图。
- en: Due to the lack of `Map` support on Windows, and just for some variety, this
    chapter will use Visual Studio for Mac screenshots and references. If you don’t
    have a Mac, don’t worry; you can still complete the project for Android on your
    Windows development machine. If you need help with the steps, look at some of
    the earlier chapters for equivalent steps.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Windows 平台上缺少 `Map` 支持，以及为了增加一些多样性，本章将使用 Visual Studio for Mac 的截图和参考。如果您没有
    Mac，不要担心；您仍然可以在 Windows 开发机器上完成 Android 项目的开发。如果您需要帮助，可以查看一些早期章节中的等效步骤。
- en: The estimated build time for this project is 180 minutes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的预计构建时间为 180 分钟。
- en: Building the MeTracker app
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 MeTracker 应用
- en: 'It’s time to start building the app. Use the following steps to create a project
    from a template:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建应用了。使用以下步骤从模板创建项目：
- en: 'Open Visual Studio for Mac and click **New**:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio for Mac 并点击 **新建**：
- en: '![Figure 7.1 – Visual Studio for Mac start screen](img/B19214_07_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Visual Studio for Mac 启动屏幕](img/B19214_07_1.jpg)'
- en: Figure 7.1 – Visual Studio for Mac start screen
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Visual Studio for Mac 启动屏幕
- en: 'In the **Choose a template for your new project** dialog, use the **.NET MAUI
    App** template, which is under **Multiplatform** | **App**; then, click **Continue**:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选择新项目的模板** 对话框中，使用位于 **多平台** | **应用** 下的 **.NET MAUI App** 模板；然后，点击 **继续**：
- en: "![Figure 7.2 – New project\uFEFF](img/B19214_07_2.jpg)"
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 新项目](img/B19214_07_2.jpg)'
- en: Figure 7.2 – New project
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 新项目
- en: 'In the **Configure your new .NET MAUI App** dialog, ensure the **.NET 7.0**
    target framework is selected, then click **Continue**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **配置你的新 .NET MAUI 应用** 对话框中，确保已选择 **.NET 7.0** 目标框架，然后点击 **继续**：
- en: '![Figure 7.3 – Choosing a target framework](img/B19214_07_3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 选择目标框架](img/B19214_07_3.jpg)'
- en: Figure 7.3 – Choosing a target framework
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 选择目标框架
- en: 'In the `MeTracker`, and then click **Create**:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MeTracker` 中，然后点击 **创建**：
- en: "![Figure 7.4 – Naming the new app\uFEFF](img/B19214_07_4.jpg)"
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 命名新应用](img/B19214_07_4.jpg)'
- en: Figure 7.4 – Naming the new app
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 命名新应用
- en: 'If you run the app now, you should see something like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该会看到以下类似的内容：
- en: '![Figure 7.5 – MeTracker app on macOS](img/B19214_07_5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – MeTracker 应用在 macOS 上](img/B19214_07_5.jpg)'
- en: Figure 7.5 – MeTracker app on macOS
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – MeTracker 应用在 macOS 上
- en: Now that we have created a project from a template, it’s time to start coding!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从一个模板中创建了一个项目，是时候开始编码了！
- en: Creating a repository to save the locations of the users
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于保存用户位置的仓库
- en: The first thing we will do is create a repository that we can use to save the
    locations of the users.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个仓库，我们可以用它来保存用户的地理位置。
- en: Creating a model for the location data
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为位置数据创建模型
- en: 'Before we create a repository, we will create a model class that will represent
    a user location. Follow these steps to do so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建仓库之前，我们将创建一个表示用户位置的模型类。按照以下步骤进行操作：
- en: Create a new `Models` folder that we can use for all our models.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于所有模型的 `Models` 文件夹。
- en: Create a `Location` class in the `Models` folder and add properties for `Id`,
    `Latitude`, and `Longitude`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中创建一个 `Location` 类，并添加 `Id`、`Latitude` 和 `Longitude` 属性。
- en: 'Create two constructors – one that’s empty and one that takes `latitude` and
    `longitude` as arguments. Use the following code to do so:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个构造函数 – 一个为空，另一个接受 `latitude` 和 `longitude` 作为参数。使用以下代码进行操作：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have created a model, we can start creating a repository.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个模型，我们可以开始创建仓库。
- en: Creating a repository
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建仓库
- en: 'First, we will create an interface for the repository. Follow these steps to
    do so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为仓库创建一个接口。按照以下步骤进行操作：
- en: Create a new folder called `Repositories`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Repositories` 的新文件夹。
- en: In our new folder, create an interface called `ILocationRepository`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新文件夹中，创建一个名为 `ILocationRepository` 的接口。
- en: 'Write the following code in the new file that we created for the interface:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们为接口创建的新文件中编写以下代码：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have an interface, we need to create an implementation of it. Follow
    these steps to do so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了接口，我们需要创建它的实现。按照以下步骤进行操作：
- en: Create a new `LocationRepository` class in the `Repositories` folder.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Repositories` 文件夹中创建一个新的 `LocationRepository` 类。
- en: 'Implement the `ILocationRepository` interface and add the `async` keyword to
    the `SaveAsync` method using the following code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ILocationRepository` 接口，并在 `SaveAsync` 方法中添加 `async` 关键字，使用以下代码：
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A word on the Async suffix
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Async 后缀的说明
- en: You will see in this and many other chapters in this book the use of `Async`
    as a suffix on methods. Appending a suffix of `Async` to all asynchronous methods
    is a .NET convention. How do we know whether a method is asynchronous in an interface
    where you can’t see the `async` keyword? It will most likely return a `Task` or
    `ValueTask` object. There are some cases where an asynchronous method will return
    `void`; however, that is frowned upon, as Stephen Cleary explains in his article
    at [https://msdn.microsoft.com/en-us/magazine/jj991977.aspx](https://msdn.microsoft.com/en-us/magazine/jj991977.aspx),
    so you won’t see it used in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在本书的许多章节中看到方法后使用 `Async` 作为后缀。在所有异步方法上附加 `Async` 后缀是 .NET 的一个约定。我们如何知道接口中的方法是否是异步的，因为我们看不到
    `async` 关键字？它很可能会返回一个 `Task` 或 `ValueTask` 对象。在某些情况下，异步方法将返回 `void`；然而，这并不被看好，正如
    Stephen Cleary 在他的文章 [https://msdn.microsoft.com/en-us/magazine/jj991977.aspx](https://msdn.microsoft.com/en-us/magazine/jj991977.aspx)
    中解释的那样，所以你不会在本书中看到它的使用。
- en: 'To store the data, we will use an SQLite database and the **object-relational
    mapper** (**ORM**) known as SQLite-net so that we can write code against a domain
    model instead of using SQL to perform operations against the database. This is
    an open source library that was created by Frank A. Krueger. Let’s set this up
    by going through the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储数据，我们将使用SQLite数据库和名为**对象关系映射器**（**ORM**）的SQLite-net，这样我们就可以针对领域模型编写代码，而不是使用SQL对数据库进行操作。这是一个由Frank
    A. Krueger创建的开源库。让我们通过以下步骤来设置它：
- en: 'Add a reference to `sqlite-net-pcl` by right-clicking the `Dependencies` node
    in **Solution Explorer**:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**解决方案资源管理器**中的`Dependencies`节点上右键单击来添加对`sqlite-net-pcl`的引用：
- en: '![Figure 7.6 – Adding the NuGet package](img/B19214_07_6.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 添加NuGet包](img/B19214_07_6.jpg)'
- en: Figure 7.6 – Adding the NuGet package
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 添加NuGet包
- en: Select **Manage NuGet Packages…** from the context menu to open the **NuGet**
    **Packages** window.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择**管理NuGet包…**以打开**NuGet** **包**窗口。
- en: 'Check the `sqlite-net-pcl` into the search box as shown next:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，在搜索框中检查`sqlite-net-pcl`：
- en: '![Figure 7.7 – Adding the sqlite-net-pcl package](img/B19214_07_7.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 添加sqlite-net-pcl包](img/B19214_07_7.jpg)'
- en: Figure 7.7 – Adding the sqlite-net-pcl package
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 添加sqlite-net-pcl包
- en: Finally, check the box next to `sqlite-net-pcl` and click **Add Package**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，勾选`sqlite-net-pcl`旁边的复选框，然后点击**添加包**。
- en: 'Go to the `Location` model class and add `PrimaryKeyAttribute` and `Auto` **IncrementAttribute**
    attributes to the `Id` property. When we add these attributes, the `Id` property
    will be a primary key in the database, and a value for it will be automatically
    created. The `Location` class should now look like the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Location`模型类，并将`PrimaryKeyAttribute`和`Auto` **IncrementAttribute**属性添加到`Id`属性。当我们添加这些属性时，`Id`属性将成为数据库中的主键，并且将自动为其创建一个值。现在`Location`类应该看起来如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Write the following code in the `LocationRepository` class to create a connection
    to the SQLite database. An `if` statement is used to check whether we have already
    created a connection. If we have, we won’t create a new one; instead, we will
    use the connection that we’ve already created:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LocationRepository`类中编写以下代码以连接到SQLite数据库。使用`if`语句检查我们是否已经创建了连接。如果我们已经有了，我们不会创建一个新的；相反，我们将使用我们已创建的连接：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, it’s time to implement the `SaveAsync` method, which will take a `location`
    object as a parameter and store it in the database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现`SaveAsync`方法了，它将接受一个`location`对象作为参数并将其存储在数据库中。
- en: We will use the `CreateConnectionAsync` method in the `SaveAsync` method to
    ensure that a connection is created when we try to save data to the database.
    When we know that we have an active connection, we can just use the `InsertAsync`
    method and pass the `location` parameter of the `SaveAsync` method as an argument.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`SaveAsync`方法中使用`CreateConnectionAsync`方法来确保在我们尝试将数据保存到数据库时创建一个连接。当我们知道我们有一个活动的连接时，我们就可以直接使用`InsertAsync`方法，并将`SaveAsync`方法的`location`参数作为参数传递。
- en: 'Edit the `SaveAsync` method in the `LocationRepository` class so that it looks
    like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`LocationRepository`类中的`SaveAsync`方法，使其看起来像这样：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That wraps up the repository for now, so let’s move on to the location tracking
    service.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个仓库就到这里，接下来让我们继续到位置跟踪服务。
- en: Creating a service for location tracking
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建位置跟踪服务
- en: To track a user’s location, we need to write code according to the platform.
    .NET MAUI has methods for getting the location of a user, but it cannot be used
    in the background. To be able to use the code that we will write for each platform,
    we need to create an interface. For the `ILocationRepository` interface, there
    is just one implementation that will be used on both platforms (iOS and Android),
    whereas for the location tracking service, we will have one implementation for
    each platform.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪用户的位置，我们需要根据平台编写代码。.NET MAUI有获取用户位置的方法，但不能在后台使用。为了能够使用我们将为每个平台编写的代码，我们需要创建一个接口。对于`ILocationRepository`接口，只有一个实现将在两个平台（iOS和Android）上使用，而对于位置跟踪服务，我们将为每个平台提供一个实现。
- en: 'Go through the following steps to create an `ILocationTrackingService` interface:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个`ILocationTrackingService`接口：
- en: Create a new folder called `Services`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Services`的新文件夹。
- en: Create a new `ILocationTrackingService` interface in the `Services` folder.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Services”文件夹中创建一个新的`ILocationTrackingService`接口。
- en: 'In the interface, add a method called `StartTracking`, as shown in the following
    code snippet:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口中添加一个名为`StartTracking`的方法，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make sure we can run and test our app while we implement the location tracking
    service for each platform, we will use a partial class. The main part of the class
    will be in the shared code section of the project and the platform-specific portions
    of the class will be in the platform-specific folders. We will come back to each
    implementation later in this chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们可以在为每个平台实现位置跟踪服务的同时运行和测试我们的应用程序，我们将使用部分类。类的主要部分将在项目的共享代码部分，而类的特定平台部分将在特定平台文件夹中。我们将在本章后面部分回到每个实现。
- en: 'Create a class called `LocationTrackingService` in the `Services` folder, as
    shown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中创建一个名为 `LocationTrackingService` 的类，如下所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are using an interface to abstract our implementation. We are also using
    a partial class to abstract each specific implementation, but providing a base
    implementation so that we don’t have to have an implementation for every platform
    immediately. However, the two methods (partial classes and base class inheritance)
    do not play together with the same method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用接口来抽象我们的实现。我们还使用部分类来抽象每个特定的实现，但提供基础实现，这样我们就不必立即为每个平台实现。然而，这两种方法（部分类和基类继承）并不能与相同的方法一起使用。
- en: 'An implementation of the `StartTracking` interface method requires the `public`
    keyword, which would look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `StartTracking` 接口方法需要一个 `public` 关键字，它看起来像这样：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, make it partial, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其设置为部分类，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The compiler complains that there is no initial definition of the partial method
    – that is, one that has no implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器抱怨没有部分方法的初始定义——也就是说，没有实现的方法。
- en: 'Remove the empty definition, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 删除空定义，如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The compiler now complains because it has an accessibility modifier, `public`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器现在抱怨因为它有一个可访问性修饰符，`public`。
- en: There is just no making the compiler happy in this case. Therefore, to avoid
    these issues, we implement the `StartTracking` interface method by calling a `StartTrackingInternal`
    partial method. We will visit the implementation of `StartTrackingInternal` for
    each platform later in this chapter; for now, the app should compile and run,
    even though we haven’t implemented `StartTrackingInternal`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，根本无法让编译器满意。因此，为了避免这些问题，我们通过调用 `StartTrackingInternal` 部分方法来实现 `StartTracking`
    接口方法。我们将在本章后面部分访问每个平台的 `StartTrackingInternal` 的实现；现在，即使我们没有实现 `StartTrackingInternal`，应用程序也应该可以编译和运行。
- en: Now that we have the interface and base implementation of the location tracking
    service, we can turn our attention to the app logic and user interface.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了位置跟踪服务的接口和基础实现，我们可以将注意力转向应用程序逻辑和用户界面。
- en: Setting up the app logic
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序逻辑
- en: Now that we have created the interfaces, we need to track the location of the
    user and save it locally on the device. It’s time to write some code so that we
    can start tracking a user. We still don’t have any code that tracks the location
    of the user, but it will be easier to write this if we have already written the
    code that starts the tracking process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了接口，我们需要跟踪用户的位置并将其保存在设备上本地。是时候编写一些代码，以便我们可以开始跟踪用户了。我们还没有任何跟踪用户位置的代码，但如果我们已经编写了启动跟踪过程的代码，这将更容易编写。
- en: Creating a view with a map
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建带有地图的视图
- en: 'To start with, we will create a view with a simple map that is centered on
    the position of the user. Let’s set this up by going through the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个带有简单地图的视图，该地图以用户的位置为中心。让我们通过以下步骤来设置它：
- en: Create a new folder called `Views`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views` 文件夹中创建一个名为 `Views` 的新文件夹。
- en: 'In the `Views` folder, create a XAML-based `ContentPage` template and name
    it `MainView`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views` 文件夹中，创建一个基于 XAML 的 `ContentPage` 模板，并将其命名为 `MainView`：
- en: "![Figure 7.8 – Adding the .NET MAUI XAML Con\uFEFF\uFEFFtentPage component](img/B19214_07_8.jpg)"
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 添加 .NET MAUI XAML ContentPage 组件](img/B19214_07_8.jpg)'
- en: Figure 7.8 – Adding the .NET MAUI XAML ContentPage component
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 添加 .NET MAUI XAML ContentPage 组件
- en: 'Add a reference to `Microsoft.Maui.Controls.Maps` by right-clicking the `Dependencies`
    node in **Solution Explorer**:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **解决方案资源管理器** 中的 `Dependencies` 节点右键单击来添加对 `Microsoft.Maui.Controls.Maps`
    的引用：
- en: '![Figure 7.9 – Adding the NuGet package](img/B19214_07_9.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 添加 NuGet 包](img/B19214_07_9.jpg)'
- en: Figure 7.9 – Adding the NuGet package
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 添加 NuGet 包
- en: Select **Manage NuGet Packages…** from the context menu to open the **NuGet
    package** **manager** window.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择 **管理 NuGet 包…** 以打开 **NuGet 包** **管理器** 窗口。
- en: 'Type `Microsoft.Maui.Controls.Maps` into the search box as shown next:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中键入 `Microsoft.Maui.Controls.Maps`，如下所示：
- en: "![Figure 7.10 – Addin\uFEFFg the .NET MAUI Maps package](img/B19214_07_10..jpg)"
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 添加 .NET MAUI Maps 包](img/B19214_07_10..jpg)'
- en: Figure 7.10 – Adding the .NET MAUI Maps package
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 添加 .NET MAUI Maps 包
- en: Finally, check the box next to `Microsoft.Maui.Controls.Maps` and click **Add
    Package**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，勾选 `Microsoft.Maui.Controls.Maps` 旁边的复选框，然后单击 **添加包**。
- en: 'Add the Map initialization code by opening the `MauiProgram.cs` file and making
    the highlighted change:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开 `MauiProgram.cs` 文件并做出高亮更改来添加 Map 初始化代码：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the namespace for `Microsoft.Maui.Controls.Maps` to `MainView` using the
    following highlighted code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下高亮代码在 `MainView` 中添加 `Microsoft.Maui.Controls.Maps` 命名空间：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we can use the map in our view. Because we want `Map` to cover the whole
    page, we can add it to the root of `ContentPage.`
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的视图中使用地图了。因为我们想让 `Map` 覆盖整个页面，所以我们可以将其添加到 `ContentPage` 的根目录。
- en: 'Add `Map` to `ContentPage` with a name so that we can access it from the code-behind
    file. Name it `Map`, as shown in the following code snippet:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Map` 添加到 `ContentPage` 并为其命名，以便我们可以从代码隐藏文件中访问它。命名为 `Map`，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we can start the app to see the `Map` control for the first time, we
    need to set the shell to use our new `MainView` template instead of the default
    `MainPage` template. But first, we will delete the `MainPage.xaml` and `MainPage.xaml.cs`
    files that we created when we started the project since we won’t be using them
    here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够启动应用程序并首次看到 `Map` 控件之前，我们需要将外壳设置为使用我们新的 `MainView` 模板而不是默认的 `MainPage`
    模板。但首先，我们将删除我们在启动项目时创建的 `MainPage.xaml` 和 `MainPage.xaml.cs` 文件，因为我们在这里不会使用它们：
- en: Delete the `MainPage.xaml` and `MainPage.xaml.cs` files in the project since
    we will be setting our `MainView` template as the first view that the user sees.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将设置 `MainView` 模板为用户看到的第一个视图，因此请删除项目中的 `MainPage.xaml` 和 `MainPage.xaml.cs`
    文件。
- en: 'Edit the `AppShell.xaml` file, as shown in the following highlighted code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `AppShell.xaml` 文件，如下所示的高亮代码：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Could we have used the existing `MainPage` template as it was? Sure – it really
    doesn’t make any difference to the compiler what the XAML file is named or where
    it is located, but for consistency and by MVVM convention in .NET MAUI, we put
    our *pages* in the `Views` folder and suffix page names with `Views`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使用现有的 `MainPage` 模板呢？当然可以——对于编译器来说，XAML 文件的名字或位置并没有任何区别，但为了保持一致性，并且按照 .NET
    MAUI 的 MVVM 习惯，我们将我们的 *页面* 放在 `Views` 文件夹中，并在页面名称后缀加上 `Views`。
- en: 'Choosing either Mac Catalyst or an iOS simulator and running the app will produce
    the result shown in *Figure 7**.11*. Android won’t work until we have completed
    the next section:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Mac Catalyst 或 iOS 模拟器并运行应用程序将产生 *图 7*.11 中所示的结果。Android 不会工作，直到我们完成下一节：
- en: '![Figure 7.11 – Running the app after adding the Map control](img/B19214_07_11..jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 添加 Map 控件后运行应用程序](img/B19214_07_11..jpg)'
- en: Figure 7.11 – Running the app after adding the Map control
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 添加 Map 控件后运行应用程序
- en: Now that we have a page with the `Map` control on it, we will need to make sure
    we have permission from the user to use location information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个带有 `Map` 控件的页面，我们需要确保我们已从用户那里获得使用位置信息的权限。
- en: Declaring platform-specific location permissions
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明特定平台的定位权限
- en: To use the `Map` control, we need to declare that we require permission to location
    information. The `Map` control will make the runtime request if it is required.
    iOS/Mac Catalyst and Android each have their own way of declaring the required
    permissions. We will start with iOS/Mac Catalyst, following which we will do Android.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Map` 控件，我们需要声明我们需要位置信息的权限。如果需要，`Map` 控件将进行运行时请求。iOS/Mac Catalyst 和 Android
    各自有声明所需权限的方式。我们将从 iOS/Mac Catalyst 开始，之后我们将进行 Android。
- en: 'Open the `info.plist` file in the `Platforms/iOS` folder into **Property List
    Editor** by double-clicking on it. Add two new entries to the file, highlighted
    in the next screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击将其打开到 **属性列表编辑器** 中，在 `Platforms/iOS` 文件夹中的 `info.plist` 文件中。向文件中添加两个新条目，如下一个屏幕截图所示的高亮部分：
- en: '![Figure 7.12 – Editing info.plist for iOS](img/B19214_07_12..jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 编辑 iOS 的 info.plist 文件](img/B19214_07_12..jpg)'
- en: Figure 7.12 – Editing info.plist for iOS
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 编辑 iOS 的 info.plist 文件
- en: 'Make the same changes in the `info.plist` file in the `Platforms/MacCatalyst`
    folder, as shown next:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Platforms/MacCatalyst` 文件夹中的 `info.plist` 文件中做出相同的更改，如下所示：
- en: '![Figure 7.13 – Editing info.plist for Mac Catalyst](img/B19214_07_13..jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 编辑 Mac Catalyst 的 info.plist 文件](img/B19214_07_13..jpg)'
- en: Figure 7.13 – Editing info.plist for Mac Catalyst
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 编辑 Mac Catalyst 的 info.plist 文件
- en: Windows users
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户
- en: To edit the `info.plist` files on Windows, you need to open the file in a text
    editor by right-clicking the file, selecting **Open With…**, and then choosing
    **XML Editor**. Then, add the entries highlighted in the next code snippet.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上编辑`info.plist`文件，您需要通过右键单击文件，选择**打开方式…**，然后选择**XML编辑器**来在文本编辑器中打开文件。然后，添加下一代码片段中突出显示的条目。
- en: 'Editing the `info.plist` file using the **Property List Editor** results in
    the changes highlighted next:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**属性列表编辑器**编辑`info.plist`文件会导致以下高亮显示的更改：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To track the location of the user in the background with Android, we need to
    declare five permissions, as shown in the following table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android中后台跟踪用户的位置，我们需要声明五个权限，如下表所示：
- en: '| ACCESS_COARSE_LOCATION | To get an approximate location for the user |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| ACCESS_COARSE_LOCATION | 获取用户的大致位置 |'
- en: '| ACCESS_FINE_LOCATION | To get a precise location for the user |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ACCESS_FINE_LOCATION | 获取用户的确切位置 |'
- en: '| ACCESS_NETWORK_STATE | We need this because the location services in Android
    use information from a network to determine the location of the user |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| ACCESS_NETWORK_STATE | 我们需要这个权限，因为Android中的位置服务使用网络信息来确定用户的位置 |'
- en: '| ACCESS_WIFI_STATE | We need this because the location services in Android
    use information from a Wi-Fi network to determine the location of the user |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ACCESS_WIFI_STATE | 我们需要这个权限，因为Android中的位置服务使用Wi-Fi网络的信息来确定用户的位置 |'
- en: '| RECEIVE_BOOT_COMPLETED | So that the background job can start again after
    the device is rebooted |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| RECEIVE_BOOT_COMPLETED | 这样后台任务在设备重启后可以再次启动 |'
- en: 'The following steps will declare the required permissions for our app:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将声明我们应用所需的权限：
- en: Open the `MainActivity.cs` file in the `Platforms/Android` folder.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Platforms/Android`文件夹中打开`MainActivity.cs`文件。
- en: 'After the `using` declarations’ block method, add the following `assembly`
    attributes, highlighted next:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`using`声明块的末尾添加以下`assembly`属性，如下所示：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we don’t declare `Android.Manifest.Permission.AccessNetworkState`
    because it is part of the .NET MAUI template.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们没有声明`Android.Manifest.Permission.AccessNetworkState`，因为它包含在.NET MAUI模板中。
- en: Now that we have declared all the permissions that we require, we can enable
    the map services on Android.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了我们所需的全部权限，我们可以在Android上启用地图服务。
- en: 'Android requires an **API key** for **Google Maps** to work with maps. The
    Microsoft documentation regarding how to obtain an API key can be found at [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map?view=net-maui-7.0#get-a-google-maps-api-key](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map?view=net-maui-7.0#get-a-google-maps-api-key).
    Follow those instructions to obtain your Google Maps key, then use your key in
    the following steps to configure the Google Maps API key in the app:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Android需要**API密钥**才能使**Google Maps**与地图一起工作。有关如何获取API密钥的Microsoft文档可以在[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map?view=net-maui-7.0#get-a-google-maps-api-key](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map?view=net-maui-7.0#get-a-google-maps-api-key)找到。按照这些说明获取您的Google
    Maps密钥，然后按照以下步骤在应用中使用您的密钥来配置Google Maps API密钥：
- en: Open `AndroidManifest.xml`, which is in the `Platforms/Android` folder, by right-clicking
    on the file and selecting **Open With…**, then selecting **XML (****Text) Editor**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击文件并选择**打开方式…**，然后选择**XML (****文本) 编辑器**来打开位于`Platforms/Android`文件夹中的`AndroidManifest.xml`文件。
- en: 'Insert a metadata element as a child of the application element, as shown in
    the following highlighted code, replacing `"{YourKeyHere}"` with the key you obtained
    from Google:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序元素下插入一个元数据元素，如下所示的高亮代码中所示，将`"{YourKeyHere}"`替换为从Google获得的密钥：
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Recent versions of Android and iOS have changed how permissions are handled.
    Certain permissions such as location are not granted without explicit approval
    from the user while the app is running. It is also possible that the user can
    deny permissions. Let’s look at how to handle runtime permission requests in the
    next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Android和iOS的最近版本已经改变了权限的处理方式。在应用运行时，某些权限，如位置权限，如果没有用户的明确批准则不会授予。也有可能用户会拒绝权限。让我们在下一节中看看如何处理运行时权限请求。
- en: Requesting location permission at runtime
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行时请求位置权限
- en: 'Before we can use the location of the user, we need to request permissions
    from the user. .NET MAUI has cross-platform permission APIs, and we just need
    a tiny bit of code to make handling the request a little nicer. To implement the
    permission request handling, follow these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用用户的位置之前，我们需要从用户那里请求权限。.NET MAUI有跨平台的权限API，我们只需要一点代码来使处理请求更加优雅。要实现权限请求处理，请按照以下步骤操作：
- en: Create a new class called `AppPermissions` in the root of the project.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为`AppPermissions`的新类。
- en: 'Edit the new file to look like the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑新文件以看起来像以下内容：
- en: '[PRE18]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This creates a type named `AppPermission` that derives from the default .NET
    MAUI `LocationWhenInUse` permission class.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个名为`AppPermission`的类型，它从默认的.NET MAUI `LocationWhenInUse`权限类继承。
- en: The `CheckRequiredPermission` method is used to ensure our app has the right
    permissions before we attempt any operations that might fail if we don’t. Its
    implementation is to call the .NET MAUI `CheckSyncStatus` method with our `AppPermission`
    type. It returns a `PermissionStatus` type, which is an enum. We are mostly interested
    in the `Denied` and `Granted` values.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CheckRequiredPermission` 方法用于确保在我们尝试任何可能会失败的操作之前，我们的应用程序拥有正确的权限。其实现是调用.NET
    MAUI的`CheckSyncStatus`方法并使用我们的`AppPermission`类型。它返回一个`PermissionStatus`类型，这是一个枚举。我们主要对`Denied`和`Granted`值感兴趣。'
- en: The `CheckAndRequestRequiredPermission` method handles the intricacies of requesting
    access from the user. The first step is to simply check and see whether the permission
    has already been granted, and if it has, return the status. Next, if we are on
    iOS and the permission has been denied, it cannot be requested again, so you must
    instruct the user on how to grant permission to the app by using the settings
    panel. Android includes in the request behavior the ability to nag the user if
    they have denied access. This behavior is exposed through .NET MAUI with the `ShouldShowRationale`
    method. It will return `false` for any platform that does not support this behavior,
    and on Android, it will return `true` the first time the user denies access and
    `false` if the user denies it a second time. Finally, we request access to the
    `AppPermission` type from the user. Again, .NET MAUI is hiding all the platform
    implementation details from us, making checking and requesting access to certain
    resources very straightforward.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CheckAndRequestRequiredPermission` 方法处理从用户请求访问的复杂性。第一步是简单地检查权限是否已经被授予，如果是，则返回状态。接下来，如果我们处于iOS并且权限已被拒绝，则无法再次请求，因此您必须指导用户如何通过设置面板授予应用程序权限。Android在请求行为中包括如果用户拒绝访问则骚扰用户的能力。此行为通过.NET
    MAUI的`ShouldShowRationale`方法公开。对于不支持此行为的任何平台，它将返回`false`；在Android上，如果用户第一次拒绝访问，它将返回`true`，如果用户第二次拒绝，则返回`false`。最后，我们从用户那里请求对`AppPermission`类型的访问。同样，.NET
    MAUI正在隐藏所有平台实现细节，使得检查和请求访问某些资源变得非常直接。'
- en: Now that we have the `AppPermissions` class in place, we can use it to request
    the current location of the user, and center that map on that location.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了`AppPermissions`类，我们可以使用它来请求用户的当前位置，并将地图中心定位在该位置。
- en: Centering the map on the current user location
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在当前用户位置上居中地图
- en: 'We will center the map on the position of the user in the constructor of `MainView.xaml.cs`.
    Because we want to fetch the user’s location asynchronously and this needs to
    be executed on the main thread, we will use `MainThread.BeginInvokeOnMainThread`
    to run an anonymous method on the main thread. Once we have the location, we can
    use the `MoveToRegion` method of `Map`. We can set this up by going through the
    following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`MainView.xaml.cs`的构造函数中使地图以用户的位置为中心。因为我们想异步获取用户的位置，并且这需要在主线程上执行，所以我们将使用`MainThread.BeginInvokeOnMainThread`在主线程上运行一个匿名方法。一旦我们有了位置，我们就可以使用`Map`的`MoveToRegion`方法。我们可以通过以下步骤来设置它：
- en: Open `MainView.xaml.cs`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainView.xaml.cs`。
- en: 'Add the highlighted code shown in the following code snippet to the constructor
    of the `MainView.xaml.cs` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段中突出显示的代码添加到`MainView.xaml.cs`类的构造函数中：
- en: '[PRE19]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you run the application now, it should look something like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，它应该看起来像以下内容：
- en: '![Figure 7.14 – Map centered on user location](img/B19214_07_14..jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – 以用户位置为中心的地图](img/B19214_07_14..jpg)'
- en: Figure 7.14 – Map centered on user location
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 以用户位置为中心的地图
- en: Now that we have the map displaying our current location, let’s start building
    the logic of the rest of the app, starting with our `ViewModel` class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了显示我们当前位置的地图，让我们开始构建应用程序其余部分的逻辑，从我们的 `ViewModel` 类开始。
- en: Creating a ViewModel class
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 ViewModel 类
- en: 'Before we create an actual `ViewModel` class, we will create an abstract base
    view model that all view models can inherit from. The idea behind this base view
    model is that we can write common code in it. In this case, we will implement
    the `INotifyPropertyChanged` interface by using the `CommunityToolkit.Mvvm` NuGet
    package. To add the package, follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建实际的 `ViewModel` 类之前，我们将创建一个所有视图模型都可以继承的抽象基视图模型。这个基视图模型背后的想法是我们可以在其中编写通用代码。在这种情况下，我们将通过使用
    `CommunityToolkit.Mvvm` NuGet 包来实现 `INotifyPropertyChanged` 接口。要添加包，请按照以下步骤操作：
- en: 'Add a reference to `CommunityToolkit.Mvvm` by right-clicking the `Dependencies`
    node in **Solution Explorer**:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **Solution Explorer** 中的 `Dependencies` 节点右键单击添加对 `CommunityToolkit.Mvvm`
    的引用：
- en: '![Figure 7.15 – Adding the NuGet package](img/B19214_07_15..jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 添加 NuGet 包](img/B19214_07_15..jpg)'
- en: Figure 7.15 – Adding the NuGet package
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 添加 NuGet 包
- en: Select **Manage NuGet Packages…** from the context menu to open the **NuGet
    package** **manager** window.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择 **Manage NuGet Packages…** 以打开 **NuGet package** **manager** 窗口。
- en: 'Type `CommunityToolkit.Mvvm` into the search box, as shown next:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `CommunityToolkit.Mvvm`，如下所示：
- en: '![Figure 7.16 – Adding the CommunityToolkit.Mvvm package](img/B19214_07_16..jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 添加 CommunityToolkit.Mvvm 包](img/B19214_07_16..jpg)'
- en: Figure 7.16 – Adding the CommunityToolkit.Mvvm package
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 添加 CommunityToolkit.Mvvm 包
- en: Finally, check the box next to `CommunityToolkit.Mvvm` and click **Add Package**.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，勾选 `CommunityToolkit.Mvvm` 旁边的复选框，然后单击 **Add Package**。
- en: 'Now, we can create a `ViewModel` class by going through the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下步骤创建一个 `ViewModel` 类：
- en: Create a folder called `ViewModels` in the project.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建一个名为 `ViewModels` 的文件夹。
- en: Create a new class called `ViewModel`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ViewModel` 的新类。
- en: 'Modify the template code to match the following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改模板代码以匹配以下内容：
- en: '[PRE20]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to create the actual view model that will use `ViewModel`
    as a base class. Let’s set this up by going through the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个实际使用 `ViewModel` 作为基类的视图模型。让我们通过以下步骤来设置它：
- en: Create a new `MainViewModel` class in the `ViewModels` folder.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中创建一个新的 `MainViewModel` 类。
- en: Make the `MainViewModel` class inherit `ViewModel`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 `MainViewModel` 类继承 `ViewModel`。
- en: Add a read-only field of the `ILocationTrackingService` type and name it `locationTrackingService`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个只读字段，类型为 `ILocationTrackingService`，命名为 `locationTrackingService`。
- en: Add a read-only field of the `ILocationRepository` type and name it `locationRepository`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个只读字段，类型为 `ILocationRepository`，命名为 `locationRepository`。
- en: Create a constructor with `ILocationTrackingService` and `ILocationRepository`
    as parameters.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 `ILocationTrackingService` 和 `ILocationRepository` 作为参数的构造函数。
- en: 'Set the values of the fields that we created in *steps 3* and *4* with the
    values from the parameters, as shown in the following code snippet:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数的值设置我们在 *步骤 3* 和 *步骤 4* 中创建的字段的值，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make the app start tracking the location of a user, we need to run the code
    that starts the tracking process on the main thread. Follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序开始跟踪用户的地理位置，我们需要在主线程上运行启动跟踪过程的代码。按照以下步骤操作：
- en: In the constructor of the newly created `MainViewModel` class, add an invocation
    to the main thread using `MainThread.BeginInvokeOnMainThread`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的 `MainViewModel` 类的构造函数中，使用 `MainThread.BeginInvokeOnMainThread` 向主线程添加调用。
- en: 'Call `locationService.StartTracking` in the action that we pass to the `BeginInvokeOnMainThread`
    method. This is shown in the following highlighted code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传递给 `BeginInvokeOnMainThread` 方法的操作中调用 `locationService.StartTracking`。这在上面的高亮代码中显示：
- en: '[PRE22]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we need to inject a `MainViewModel` class into the constructor of
    `MainView` and assign the `MainViewModel` instance to the binding context of the
    view. This will allow what data binding we’ve done to be processed, and the properties
    of `MainViewModel` will be bound to the controls in the user interface. Follow
    these steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `MainViewModel` 类注入到 `MainView` 的构造函数中，并将 `MainViewModel` 实例分配给视图的绑定上下文。这将允许我们完成的数据绑定被处理，并且
    `MainViewModel` 的属性将被绑定到用户界面中的控件。按照以下步骤操作：
- en: Go to the constructor of the `Views/MainView.xaml.cs` file.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Views/MainView.xaml.cs` 文件的构造函数。
- en: Add `MainViewModel` as a parameter of the constructor and call it `viewModel`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MainViewModel` 作为构造函数的参数并命名为 `viewModel`。
- en: 'Set `BindingContext` as the instance of `MainViewModel`, as shown in the following
    code snippet:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BindingContext` 设置为 `MainViewModel` 的实例，如下代码片段所示：
- en: '[PRE23]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In order for .NET MAUI to locate the classes we have implemented in this section
    so far, we need to add them to the **dependency injection** (**DI**) container.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 .NET MAUI 定位到我们在此部分已实现的类，我们需要将它们添加到 **依赖注入** （**DI**） 容器中。
- en: Adding classes to the DI container
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将类添加到 DI 容器中
- en: 'Since we have added a parameter to the constructor of the view, the .NET MAUI
    `View` framework won’t be able to construct the view automatically. So, we need
    to add `MainView`, `MainViewModel`, `LocationTrackingService`, and `LocationRepository`
    instances to the DI container. To do that, follow these steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们向视图的构造函数中添加了一个参数，.NET MAUI `View` 框架将无法自动构建视图。因此，我们需要将 `MainView`、`MainViewModel`、`LocationTrackingService`
    和 `LocationRepository` 实例添加到 DI 容器中。为此，请按照以下步骤操作：
- en: Open the `MauiProgram.cs` file.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件。
- en: 'Add the following highlighted lines to the `CreateMauiApp` method:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的行添加到 `CreateMauiApp` 方法中：
- en: '[PRE24]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we will be able to run the app again. We haven’t changed any of the interfaces,
    so it should look and behave the same as before. If it doesn’t, go back through
    the previous section carefully to make sure you have all the code correct.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次能够运行应用程序。我们没有更改任何接口，所以它应该看起来和表现与之前相同。如果它没有，请仔细回顾前面的部分，确保所有代码都是正确的。
- en: Let’s add some code so that we can track the user’s location over time using
    background location tracking.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些代码，以便我们可以使用后台位置跟踪跟踪用户的位置随时间的变化。
- en: Background location tracking on iOS and Mac Catalyst
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS 和 Mac Catalyst 的后台位置跟踪
- en: The code for location tracking is something that we need to write for each platform.
    For iOS and Mac Catalyst, we will use `CLLocationManager` from the `CoreLocation`
    namespace.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 位置跟踪的代码是我们需要为每个平台编写的。对于 iOS 和 Mac Catalyst，我们将使用 `CoreLocation` 命名空间中的 `CLLocationManager`。
- en: Enabling location updates in the background
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用后台位置更新
- en: 'When we want to perform tasks in the background in an iOS or Mac Catalyst app,
    we need to declare what we want to do in the `info.plist` file. The following
    steps show how we go about this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在 iOS 或 Mac Catalyst 应用程序中执行后台任务时，我们需要在 `info.plist` 文件中声明我们想要执行的操作。以下步骤展示了我们如何进行这一操作：
- en: Open `info.plist`; you will need to do this for both `Platforms/iOS/info.plist`
    and `Platforms/MacCatalyst/info.plist`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `info.plist`；您需要为 `Platforms/iOS/info.plist` 和 `Platforms/MacCatalyst/info.plist`
    都这样做。
- en: 'Add the following highlighted entry using the **Property List Editor** by selecting
    **Required background modes** from the dropdown and **App registers for location
    updates**, as shown in the following screenshot:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **属性列表编辑器** 通过从下拉菜单中选择 **Required background modes** 并选择 **App registers
    for location updates**，按照以下截图所示添加以下突出显示的条目：
- en: '![Figure 7.17 – Adding location updates](img/B19214_07_17..jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 添加位置更新](img/B19214_07_17..jpg)'
- en: Figure 7.17 – Adding location updates
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 添加位置更新
- en: 'We can also enable background modes directly in the `info.plist` file if we
    open it with an XML editor. In this case, we will add the following XML:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 XML 编辑器直接在 `info.plist` 文件中启用后台模式。在这种情况下，我们将添加以下 XML：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Subscribing to location updates
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅位置更新
- en: Now that we have prepared the `info.plist` file for location tracking, it is
    time to write the actual code that will track the location of the user. If we
    don’t set `CLLocationManager` to not pause location updates, location updates
    can be paused automatically by iOS or Mac Catalyst when the location data is unlikely
    to change. In this app, we don’t want that to happen because we want to save the
    location multiple times so that we can establish whether a user visits a particular
    location frequently.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为位置跟踪准备好了 `info.plist` 文件，是时候编写实际跟踪用户位置的代码了。如果我们没有将 `CLLocationManager`
    设置为不暂停位置更新，iOS 或 Mac Catalyst 在位置数据不太可能改变时可以自动暂停位置更新。在这个应用程序中，我们不希望发生这种情况，因为我们想多次保存位置，以便我们可以确定用户是否频繁访问特定位置。
- en: 'If you recall from earlier, we already defined the service as a partial class
    with a partial method; now, we will finish the service by implementing the platform-specific
    pieces of the service. Let’s set this up:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们之前已经将服务定义为部分类和部分方法；现在，我们将通过实现服务的平台特定部分来完成服务。让我们设置如下：
- en: Create a new folder named `Services` in the `Platforms/iOS` folder.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Platforms/iOS` 文件夹中创建一个名为 `Services` 的新文件夹。
- en: Create a new class named `LocationTrackingService` in the `Services` folder.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中创建一个名为 `LocationTrackingService` 的新类。
- en: 'Modify the class to match the following:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类以匹配以下内容：
- en: '[PRE26]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add a private field for `CLLocationManager`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `CLLocationManager` 添加一个私有字段。
- en: Create an instance of `CLLocationManager` in the `StartTrackingInternal` method.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StartTrackingInternal` 方法中创建一个 `CLLocationManager` 的实例。
- en: Set `PausesLocationUpdatesAutomatically` to `false`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PausesLocationUpdatesAutomatically` 设置为 `false`。
- en: Before we can start tracking the location of the user, we need to set the accuracy
    of the data that we want to receive from `CLLocationManager`. We will also add
    an event handler to handle location updates.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们可以开始跟踪用户的位置之前，我们需要设置我们从 `CLLocationManager` 收到的数据的精度。我们还将添加一个事件处理程序来处理位置更新。
- en: Set `DesiredAccuracy` to `CLLocation.``Accuracy``BestForNavigation`. One of
    the constraints when running the app in the background is that `DesiredAccuracy`
    needs to be set to either `Accuracy``Best` or `Accuracy``BestForNavigation`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DesiredAccuracy` 设置为 `CLLocation.AccuracyBestForNavigation`。在应用程序在后台运行时，`DesiredAccuracy`
    需要设置为 `AccuracyBest` 或 `AccuracyBestForNavigation` 之一。
- en: Set `AllowBackgroundLocationUpdates` to `true` (as shown in the following code
    snippet) so that the location updates will continue, even when the app is running
    in the background.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AllowBackgroundLocationUpdates` 设置为 `true`（如以下代码片段所示），这样即使应用程序在后台运行，位置更新也会继续。
- en: 'Your changes should look like this:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的更改应如下所示：
- en: '[PRE27]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is to ask the user for permission to track their location. We
    will request permission to track their location all the time, but the user has
    the option of only giving us permission to track their location when they are
    using the app. Because the user also has the option of denying us permission to
    track their location, we need to check this before we start. Let’s set this up:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是请求用户允许跟踪他们的位置。我们将请求始终跟踪用户的位置，但用户可以选择只在他们使用应用程序时才给我们权限跟踪他们的位置。因为用户也有权拒绝我们跟踪他们的位置，所以在开始之前我们需要检查这一点。让我们设置它：
- en: 'Add an event handler for `LocationsUpdated` just after the `// Add code here`
    comment. It should look like the code highlighted in the following snippet:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `// Add code here` 注释之后添加 `LocationsUpdated` 的事件处理程序。它应类似于以下片段中高亮的代码：
- en: '[PRE28]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After the event handler, call the `RequestAlwaysAuthorization` method of the
    instance that we recently created in `CLLocationManager`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件处理程序之后，调用我们最近在 `CLLocationManager` 中创建的实例的 `RequestAlwaysAuthorization` 方法：
- en: '[PRE29]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, call the `StartUpdatingLocation` method of `locationManager`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用 `locationManager` 的 `StartUpdatingLocation` 方法：
- en: '[PRE30]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The higher the accuracy is, the higher the battery consumption. If we only want
    to track where the user has been and not how popular a place is, we could also
    set `AllowDeferredLocationUpdatesUntil`. This way, we can specify that the user
    has to move a specific distance before the location is updated. We can also specify
    how often we want the location to be updated using the `timeout` argument. The
    most power-efficient solution to track how long a user has been at a place is
    to use the `StartMonitoringVisits` method of `CLLocationManager`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 精度越高，电池消耗就越高。如果我们只想跟踪用户去过哪里，而不关心一个地方有多受欢迎，我们也可以设置 `AllowDeferredLocationUpdatesUntil`。这样，我们可以指定用户必须移动一定距离后才会更新位置。我们还可以使用
    `timeout` 参数指定我们希望位置更新的频率。要跟踪用户在一个地方停留了多久，最节能的解决方案是使用 `CLLocationManager` 的 `StartMonitoringVisits`
    方法。
- en: 'Now, it’s time to handle the `LocationsUpdated` event. Let’s go through the
    following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理 `LocationsUpdated` 事件了。让我们按以下步骤进行：
- en: Add a private field called `locationRepository` that is of the `ILocationRepository`
    type.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `locationRepository` 的私有字段，其类型为 `ILocationRepository`。
- en: 'Add a constructor that has `ILocationRepository` as a parameter. Set the value
    of the parameter to the `locationRepository` field. Your class should resemble
    the following code snippet:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有 `ILocationRepository` 作为参数的构造函数。将参数的值设置为 `locationRepository` 字段。您的类应类似于以下代码片段：
- en: '[PRE31]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Read the latest location of the `Locations` property of `CLLocationsUpdatedEventArgs`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `CLLocationsUpdatedEventArgs` 的 `Locations` 属性的最新位置。
- en: Create an instance of `MeTracker.Models.Location` and pass the latitude and
    longitude of the latest location to it.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `MeTracker.Models.Location` 的实例，并将最新位置的纬度和经度传递给它。
- en: Save the location using the `SaveAsync` method of `ILocationRepository`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ILocationRepository` 的 `SaveAsync` 方法保存位置。
- en: 'The code should be placed after the `// Final block of code goes here` comment.
    It should look like the code shown in bold in the following fragment:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应放置在 `// Final block of code goes here` 注释之后。它应类似于以下片段中加粗的代码：
- en: '[PRE32]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that, we have completed the tracking part of the app for iOS. The implementation
    is identical for Mac Catalyst; you can either repeat the steps in this section
    for Mac Catalyst (but create the file as `Platforms/MacCatalyst/Services` instead
    of `Platforms/iOS/Services`) or copy the `Platforms/iOS/Services/LocationTrackingService.cs`
    file to the `Platforms/MacCatalyst/Services` folder.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了 iOS 应用程序的跟踪部分。对于 Mac Catalyst 的实现是相同的；你可以重复本节中的步骤为 Mac Catalyst（但将文件创建为
    `Platforms/MacCatalyst/Services` 而不是 `Platforms/iOS/Services`），或者将 `Platforms/iOS/Services/LocationTrackingService.cs`
    文件复制到 `Platforms/MacCatalyst/Services` 文件夹中。
- en: Now, we will implement background tracking for Android, following which we will
    visualize the location tracking data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现 Android 的后台跟踪，之后我们将可视化位置跟踪数据。
- en: Background location tracking with Android
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 后台位置跟踪
- en: The Android way to carry out background updates is very different from how we
    implemented it with iOS. With Android, we need to create a `JobService` class
    and schedule it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现后台更新的方式与我们用 iOS 实现的方式非常不同。在 Android 中，我们需要创建一个 `JobService` 类并对其进行调度。
- en: Creating a background job
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建后台作业
- en: 'To track the location of users in the background, we need to create a background
    job. A background job is used by the OS to allow developers to execute code even
    when the app is not in the foreground or visible on the screen. Follow these steps
    to create a background job to capture a user’s location:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要在后台跟踪用户的位置，我们需要创建一个后台作业。后台作业由操作系统使用，允许开发者在应用不在前台或屏幕上可见时执行代码。按照以下步骤创建一个后台作业以捕获用户的位置：
- en: Create a new folder named `Services` in the `Platforms/Android` folder.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Platforms/Android` 文件夹中创建一个名为 `Services` 的新文件夹。
- en: Create a new class called `LocationJobService` in the `Services` folder.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Platforms/Android` 文件夹中创建一个名为 `LocationJobService` 的新类。
- en: Make the class inherit from `Android.App.Job.JobService` as a base class.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类继承自 `Android.App.Job.JobService` 作为基类。
- en: Add `using Android.App.Job` and `using Android.App.Job` declarations to the
    top of the file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加 `using Android.App.Job` 和 `using Android.App.Job` 声明。
- en: 'Implement the `OnStartJob` and `OnStopJob` abstract methods, as shown in the
    following code snippet:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `OnStartJob` 和 `OnStopJob` 抽象方法，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the Android services in the app need to be added to the `AndroidManifest.xml`
    file. We don''t have to do this manually; instead, we can add an attribute to
    the `LocationJobService` class, which will then be generated in the `AndroidManifest.xml`
    file. We will use the `Name` and `Permission` properties to set the required information,
    as shown in the following code snippet:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的所有 Android 服务都需要添加到 `AndroidManifest.xml` 文件中。我们不必手动进行此操作；相反，我们可以在 `LocationJobService`
    类中添加一个属性，然后它将在 `AndroidManifest.xml` 文件中生成。我们将使用 `Name` 和 `Permission` 属性来设置所需的信息，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Scheduling a background job
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度后台作业
- en: When we have created a job, we need to schedule it. We will do this from `LocationTrackingService`
    in the `Platforms/Android` folder. To configure the job, we will use the `JobInfo.Builder`
    class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个作业后，我们需要对其进行调度。我们将从 `Platforms/Android/LocationTrackingService` 文件夹中进行操作。为了配置作业，我们将使用
    `JobInfo.Builder` 类。
- en: We will use the `SetPersisted` method to ensure that the job starts again after
    a reboot. This is why we added the `RECEIVE_BOOT_COMPLETED` permission earlier.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `SetPersisted` 方法来确保在重启后作业会再次启动。这就是为什么我们之前添加了 `RECEIVE_BOOT_COMPLETED`
    权限。
- en: To schedule a job, at least one constraint is needed. In this case, we will
    use `SetOverrideDeadline`. This will specify that the job needs to run before
    the specified time (in milliseconds) has elapsed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要调度一个作业，至少需要一个约束。在这种情况下，我们将使用 `SetOverrideDeadline`。这将指定作业需要在指定时间（以毫秒为单位）过去之前运行。
- en: The `SetRequiresDeviceIdle` method can be used to make sure that a job only
    runs when the device is not being used by a user. We could pass `true` to the
    method if we want to make sure that we don’t slow down the device when the user
    is using it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetRequiresDeviceIdle` 方法可以用来确保作业仅在设备未被用户使用时运行。如果我们想确保在用户使用设备时不会减慢设备速度，我们可以将
    `true` 传递给该方法。'
- en: The `SetRequiresBatteryNotLow` method can be used to specify that a job should
    not run when the battery level is low. We recommend that this always be set to
    `true` if you don’t have a good reason to run the job when the battery is low.
    This is because we don’t want our applications to drain the user’s battery.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetRequiresBatteryNotLow` 方法可以用来指定当电池电量低时不应运行作业。如果你没有在电池电量低时运行作业的合理理由，我们建议始终将其设置为
    `true`。这是因为我们不希望我们的应用程序耗尽用户的电池电量。'
- en: 'So, let’s implement `LocationTrackingService`. Follow these steps to do so:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现 `LocationTrackingService`。按照以下步骤进行：
- en: Create a new class named `LocationTrackingService` in the `Platforms/Android/Services`
    folder.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Platforms/Android/Services` 文件夹中创建一个名为 `LocationTrackingService` 的新类。
- en: 'Modify the class to look like the following:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类，使其看起来如下：
- en: '[PRE35]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create a `JobInfo.Builder` class based on an ID that we’ll specify (we will
    use `1` here) and the component name (which we’ll create from the application
    context and the Java class) in the `StartTrackingInternal` method. The component
    name is used to specify which code will run during the job.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StartTrackingInternal` 方法中，基于我们将指定的 ID（这里我们将使用 `1`）和组件名称（我们将从应用程序上下文和 Java
    类中创建）创建一个 `JobInfo.Builder` 类。组件名称用于指定在作业期间将运行哪些代码。
- en: Use the `SetOverrideDeadline` method and pass `1000` to it to make the job run
    before 1 second has elapsed from when the job was created.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SetOverrideDeadline` 方法并将 `1000` 传递给它，以确保作业在作业创建后 1 秒内运行。
- en: Use the `SetPersisted` method and pass `true` to make the job persist even after
    the device is rebooted.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SetPersisted` 方法并传递 `true`，使作业即使在设备重新启动后也能持续。
- en: Use the `SetRequiresDeviceIdle` method and pass `false` so that the job will
    run even when a user is using the device.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SetRequiresDeviceIdle` 方法并传递 `false`，这样即使用户正在使用设备，作业也会运行。
- en: Use the `SetRequiresBatteryLow` method and pass `true` to make sure that we
    don’t drain the user’s battery. This method was added in Android API level 26.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SetRequiresBatteryLow` 方法并传递 `true`，以确保我们不会耗尽用户的电池。此方法是在 Android API 级别
    26 中添加的。
- en: 'The code for `LocationTrackingService` should now look like this:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LocationTrackingService` 的代码现在应该看起来像这样：'
- en: '[PRE36]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last step in the `StartTrackingInternal` method is to schedule the job
    with the system using `JobScheduler`. The `JobScheduler` service is an Android
    system service. To get an instance of a system service, we will use the application
    context. Follow these steps to do so:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartTrackingInternal` 方法中的最后一步是使用 `JobScheduler` 系统安排作业。`JobScheduler` 服务是一个
    Android 系统服务。为了获取系统服务的实例，我们将使用应用程序上下文。按照以下步骤进行：'
- en: Use the `GetSystemService` method on `Application.Context` to get the `JobScheduler`
    service.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GetSystemService` 方法在 `Application.Context` 上获取 `JobScheduler` 服务。
- en: Cast the result to `JobScheduler`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果转换为 `JobScheduler`。
- en: 'Use the `Schedule` method on the `JobScheduler` class and pass the `JobInfo`
    object to schedule the job, as shown in the following code snippet:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `JobScheduler` 类上使用 `Schedule` 方法并传递 `JobInfo` 对象来安排作业，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that the job is scheduled, we can start receiving location updates; let’s
    work on that next.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在作业已经安排好了，我们可以开始接收位置更新；让我们继续这个工作。
- en: Subscribing to location updates
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅位置更新
- en: Once we have scheduled the job, we can write the code to specify what the job
    should do – that is, track the location of a user. To do this, we will use `LocationManager`,
    which is a `SystemService` class. With `LocationManager`, we can either request
    a single location update or we can subscribe to location updates. In this case,
    we want to subscribe to location updates.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安排了作业，我们可以编写代码来指定作业应该做什么——即跟踪用户的地理位置。为此，我们将使用 `LocationManager`，这是一个 `SystemService`
    类。使用 `LocationManager`，我们可以请求单个位置更新或订阅位置更新。在这种情况下，我们想要订阅位置更新。
- en: 'We will start by creating an instance of the `ILocationRepository` interface.
    We will use this to save the locations to the SQLite database. Let’s set this
    up:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建 `ILocationRepository` 接口的一个实例。我们将使用它将位置保存到 SQLite 数据库中。让我们设置一下：
- en: Create a constructor for `LocationJobService`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `LocationJobService` 创建一个构造函数。
- en: Create a `private` read-only field for the `ILocationRepository` interface called
    `locationRepository`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `ILocationRepository` 接口创建一个名为 `locationRepository` 的 `private` 只读字段。
- en: 'Use `Services.GetService<T>` in the constructor to create an instance of `ILocationRepository`,
    as shown in the following code snippet:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中使用 `Services.GetService<T>` 创建 `ILocationRepository` 的实例，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Before we subscribe to location updates, we will add a listener. To do this,
    we will use the `Android.Locations.ILocationListener` interface.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们订阅位置更新之前，我们将添加一个监听器。为此，我们将使用 `Android.Locations.ILocationListener` 接口。
- en: 'Follow these steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Add the `Android.Locations.ILocationListener` interface to `LocationJobService`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Android.Locations.ILocationListener` 接口添加到 `LocationJobService`。
- en: 'Add the following namespace declarations to the top of the file:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命名空间声明添加到文件顶部：
- en: '[PRE39]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Implement the interface and remove all instances of `throw` `new NotImplemented`
    **Exception();**. This is added to the methods when you let Visual Studio generate
    an implementation of the interface.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口并移除所有 `throw new NotImplemented Exception();` 实例。这是在您让 Visual Studio 生成接口实现时添加到方法中的。
- en: 'The method implementations should look like those in the following code snippet:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方法实现应类似于以下代码片段：
- en: '[PRE40]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `OnLocationChanged` method, map the `Android.Locations.Location` object
    to the `Model.Location` object.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnLocationChanged` 方法中，将 `Android.Locations.Location` 对象映射到 `Model.Location`
    对象。
- en: 'Use the `SaveAsync` method on the `LocationRepository` class, as shown in the
    following code snippet:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `LocationRepository` 类上的 `SaveAsync` 方法，如下代码片段所示：
- en: '[PRE41]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we have created a listener, we can subscribe to location updates.
    Follow these steps to do so:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个监听器，我们可以订阅位置更新。按照以下步骤进行：
- en: Create a `static` field of the `LocationManager` type named `locationManager`.
    Make sure it has the same lifetime as the app.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `locationManager` 的 `LocationManager` 类型的 `static` 字段。确保它具有与应用程序相同的生命周期。
- en: 'It is possible in Android that `JobService` will start before `MainView` is
    displayed and we request location permissions. To prevent any errors due to missing
    permissions, we will check for them first:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android 中，`JobService` 可能会在 `MainView` 显示之前启动，并且我们请求位置权限。为了避免因权限缺失而导致的任何错误，我们将首先检查权限。
- en: '[PRE42]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We run `CheckRequiredPermissionsAsync` inside a `Task.Run` instance because
    it’s an `async` call, and we can’t add `async` to the method because the return
    type is incompatible. The call to `Wait` turns the `async` call into a synchronous
    one. If the result is `Granted`, then we can continue.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 `Task.Run` 实例中运行 `CheckRequiredPermissionsAsync`，因为它是一个 `async` 调用，我们不能将
    `async` 添加到方法中，因为返回类型不兼容。对 `Wait` 的调用将 `async` 调用转换为同步调用。如果结果是 `Granted`，则我们可以继续。
- en: Go to the `StartJob` method in `LocationJobService`. Get `LocationManager` by
    using `GetSystemService` on `ApplicationContext`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `LocationJobService` 中的 `StartJob` 方法。通过在 `ApplicationContext` 上调用 `GetSystemService`
    获取 `LocationManager`。
- en: 'To subscribe for location updates, use the `RequestLocationUpdates` method,
    as shown in the following code snippet:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要订阅位置更新，使用如下代码片段所示的 `RequestLocationUpdates` 方法：
- en: '[PRE43]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first argument that we pass to the `RequestLocationUpdates` method ensures
    that we get locations from the GPS. The second ensures that at least `1000` milliseconds
    will elapse between location updates. The third argument ensures that the user
    moves at least `0.1` meters to get a location update. The last argument specifies
    which listener we should use. Because the current class implements the `Android.Locations.ILocationListener`
    interface, we will pass `this`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `RequestLocationUpdates` 方法的第一个参数确保我们从 GPS 获取位置。第二个参数确保位置更新之间至少有 `1000`
    毫秒的间隔。第三个参数确保用户至少移动 `0.1` 米以获取位置更新。最后一个参数指定我们应使用哪个监听器。因为当前类实现了 `Android.Locations.ILocationListener`
    接口，所以我们将传递 `this`。
- en: Now that we have collected location data on from the user and stored it in our
    SQLite database, we can now display that data on a map.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从用户那里收集了位置数据并将其存储在我们的 SQLite 数据库中，我们现在可以在地图上显示这些数据。
- en: Creating a heat map
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建热图
- en: To visualize the data that we have collected, we will create a heat map. We
    will add lots of dots to the map and make them different colors, based on how
    much time a user spends in a particular place. The most popular places will have
    a warm color, while the least popular places will have a cold color.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们收集的数据，我们将创建一个热图。我们将在地图上添加很多点，并根据用户在特定地点花费的时间长短使它们呈现不同的颜色。最受欢迎的地方将呈现暖色调，而最不受欢迎的地方将呈现冷色调。
- en: Before we add the dots to the map, we need to get all locations from the repository.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将点添加到地图之前，我们需要从存储库中获取所有位置。
- en: Adding the GetAllAsync method to LocationRepository
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 LocationRepository 添加 GetAllAsync 方法
- en: 'In order to visualize the data, we need to write some code so that location
    data can be read from the database. Let’s set this up:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化数据，我们需要编写一些代码，以便可以从数据库中读取位置数据。让我们设置如下：
- en: Open the `ILocationRepository.cs` file.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ILocationRepository.cs` 文件。
- en: 'Add a `GetAllAsync` method that returns a list of `Location` objects, using
    the following code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个返回 `Location` 对象列表的 `GetAllAsync` 方法，如下代码所示：
- en: '[PRE44]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Open the `LocationRepository.cs` file, which implements `ILocationRepository`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开实现 `ILocationRepository` 的 `LocationRepository.cs` 文件。
- en: 'Implement the new `GetAllAsync` method and return all the saved locations in
    the database, as shown in the following code snippet:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现新的 `GetAllAsync` 方法，并返回数据库中所有保存的位置，如下代码片段所示：
- en: '[PRE45]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Preparing the data for visualization
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备可视化数据
- en: 'Before we can visualize the data on the map, we need to prepare the data. The
    first thing we will do is create a new model that we can use for the prepared
    data. Let’s set this up:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在地图上可视化数据之前，我们需要准备数据。我们首先要做的是创建一个新的模型，我们可以用它来准备数据。让我们设置一下：
- en: In the `Models` folder, create a new class called `Point`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中，创建一个名为 `Point` 的新类。
- en: 'Add properties for `Location`, `Count`, and `Heat`, as shown in the following
    code snippet:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Location`、`Count` 和 `Heat` 属性，如下代码片段所示：
- en: '[PRE46]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`MainViewModel` will store the locations that we will find later on. Let’s
    add a property for storing points.'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MainViewModel` 将存储我们稍后找到的位置。让我们为存储点添加一个属性。'
- en: Open the `MainViewModel` class.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainViewModel` 类。
- en: Add a `private` field called `points`, which is of the `List<Point>` type.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `points` 的 `private` 字段，其类型为 `List<Point>`。
- en: 'Add the `ObservableProperty` attribute to the `points` field, as shown in the
    following code snippet:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ObservableProperty` 属性添加到 `points` 字段，如下代码片段所示：
- en: '[PRE47]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have storage for our points, we must add some code so that we can
    add locations. We will do this by implementing the `LoadDataAsync` method of the
    `MainViewModel` class and making sure that it is called on the main thread, right
    after location tracking has started.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了点的存储，我们必须添加一些代码，以便我们可以添加位置。我们将通过实现 `MainViewModel` 类的 `LoadDataAsync`
    方法来完成此操作，并确保它在位置跟踪开始后立即在主线程上调用。
- en: 'The first thing we will do is group the saved locations so that all locations
    within 200 meters will be handled as one point. We will track how many times we
    have logged a position within that point so that we can decide which color the
    point will be on the map. Let’s set this up:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将保存的位置分组，以便所有在 200 米范围内的位置都将作为一个点处理。我们将跟踪在该点内记录位置的次数，以便我们可以决定点在地图上的颜色。让我们设置一下：
- en: Add an `async` method called `LoadDataAsync`. This returns a `Task` object to
    `Main``ViewModel`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `LoadDataAsync` 的 `async` 方法。此方法返回一个 `Task` 对象给 `MainViewModel`。
- en: 'Call the `LoadDataAsync` method from the constructor after the call to the
    `StartTracking` method on `ILocationTrackingService`, as shown in the following
    code snippet:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `ILocationTrackingService` 上的 `StartTracking` 方法之后，从构造函数中调用 `LoadDataAsync`
    方法，如下代码片段所示：
- en: '[PRE48]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first step of the `LoadDataAsync` method is to read all tracked locations
    from the SQLite database. When we have all the locations, we will loop through
    them and create points.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadDataAsync` 方法的第一步是从 SQLite 数据库中读取所有跟踪的位置。当我们拥有所有位置后，我们将遍历它们并创建点。'
- en: 'To calculate the distance between a location and a point, we will use the `CalculateDistance`
    method, as shown in the following code snippet:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算位置和点之间的距离，我们将使用 `CalculateDistance` 方法，如下代码片段所示：
- en: '[PRE49]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we have a list of points, we can calculate the heat color for each point.
    We are going to use the **hue**, **saturation**, and **lightness** (**HSL**) representation
    of a color, as described here:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个点的列表时，我们可以计算每个点的热色。我们将使用颜色的 **色调**、**饱和度**和**亮度**（**HSL**）表示，如下所述：
- en: '**Hue**: Hue is a degree on the color wheel that goes from 0 to 360, with 0
    being red and 240 being blue. Because we want our most popular places to be red
    (hot) and our least popular places to be blue (cold), we will calculate a value
    between 0 and 240 for each point, based on how many times the user has been to
    that point. This means that we will only use two-thirds of the scale.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色调**：色调是色轮上的一个度数，从 0 到 360，0 为红色，240 为蓝色。因为我们希望最热门的地点是红色（热），最不热门的地点是蓝色（冷），我们将根据用户访问该地点的次数计算一个介于
    0 和 240 之间的值，这意味着我们只会使用三分之二的刻度。'
- en: '`1` in the code).'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （代码中的 `1`）。
- en: '`0.5` in the code).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （代码中的 `0.5`）。
- en: 'The first thing that we need to do is find out how many times the user has
    been to the most popular and least popular places. Let’s take a look:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是找出用户访问最热门和最不热门地点的次数。让我们看一下：
- en: First, check that the list of points is not empty.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查点的列表不为空。
- en: Get the `Min` and `Max` values for the `Count` property in the list of points.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取点列表中 `Count` 属性的 `Min` 和 `Max` 值。
- en: Calculate the difference between the minimum and the maximum values.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算最小值和最大值之间的差异。
- en: 'The code should be added after the `// Next section of code goes here` comment
    at the bottom of the `LoadDataAsync` method, as shown in the following code snippet:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该在`LoadDataAsync`方法底部的`// Next section of code goes here`注释之后添加，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can calculate the heat for each point, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算每个点的热值，如下所示：
- en: Loop through all the points.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有点。
- en: 'The following code should be added after the `// Last section of code goes
    here` comment, at the bottom of the `LoadDataAsync()` method (this is highlighted
    in the following code snippet):'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在`LoadDataAsync()`方法底部的`// Last section of code goes here`注释之后添加以下代码（以下代码片段已突出显示）：
- en: '[PRE51]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That’s all we need to do to set up location tracking in the `MeTracker` project.
    Now, let’s turn our attention to visualizing the data we receive.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为`MeTracker`项目设置位置跟踪所需做的全部工作。现在，让我们将注意力转向可视化我们接收到的数据。
- en: Adding data visualizations
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加数据可视化
- en: In .NET MAUI, the `Map` control can render additional information over the map.
    This includes pins and custom shapes, which are called `MapElements`. We could
    simply add each location that is stored in the repository as a pin; however, to
    get the heat map, we want to add a colored dot to the map for each location, so
    we will use `MapElements` for each location.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，`Map`控件可以在地图上渲染额外的信息。这包括图钉和自定义形状，被称为`MapElements`。我们可以简单地添加存储在存储库中的每个位置作为图钉；然而，为了得到热图，我们想在地图上的每个位置添加一个彩色圆点，所以我们将为每个位置使用`MapElements`。
- en: If the `MapElements` property were `BindableProperty` , we could use a converter
    to map the `MainViewModel` `Points` property to the map’s `MapElements` property
    in a binding. But `MapElements` is not a bindable property, so it won’t be that
    easy.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MapElements`属性是`BindableProperty`，我们就可以使用转换器将`MainViewModel`的`Points`属性映射到地图的`MapElements`属性进行绑定。但是`MapElements`不是一个可绑定的属性，所以这不会那么简单。
- en: Let’s start by creating a custom map control.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个自定义地图控件。
- en: Creating a custom control for the map
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建地图的自定义控件
- en: To show the heat map on our map, we will create a new control. Since `Map` is
    a sealed class, we won’t be able to subclass it directly; instead, we will encapsulate
    the `Map` control inside `ContentView` with `BindableProperty` to get access to
    the `Points` data from `ViewModel`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的地图上显示热图，我们将创建一个新的控件。由于`Map`是一个密封类，我们无法直接继承它；相反，我们将使用`BindableProperty`将`Map`控件封装在`ContentView`中，以便从`ViewModel`访问`Points`数据。
- en: 'Follow these steps to create the custom control:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建自定义控件：
- en: Create a new folder called `Controls`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Controls`的新文件夹。
- en: Create a new class called `CustomMap`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomMap`的新类。
- en: 'Add `ContentView` as a base class to the new class, as shown in the following
    code snippet:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ContentView`作为基类添加到新类中，如下面的代码片段所示：
- en: '[PRE52]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we need to add the `Map` control to the custom control. Follow these steps
    to add the `Map` control:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`Map`控件添加到自定义控件中。按照以下步骤添加`Map`控件：
- en: 'Derive the `CustomMap` control from the .NET MAUI `Map` control, as highlighted
    in the following code snippet:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从.NET MAUI的`Map`控件派生出`CustomMap`控件，如下面的代码片段所示：
- en: '[PRE53]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Initialize the map in the constructor, as shown with the new changes highlighted:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化地图，如下所示（新更改已突出显示）：
- en: '[PRE54]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we want to have properties that we want to bind data to, we need to create
    a `BindableProperty` class. This should be a public static field in the class.
    We also need to create a regular property to hold the value. The naming of the
    properties is really important. The name of `BindableProperty` needs to be `{NameOfTheProperty}Property`;
    for example, the name of `BindableProperty` that we will create in the following
    steps will be `PointsProperty` because the name of the property is `Points`. A
    `BindableProperty` is created using the static `Create` method on the `BindableProperty`
    class. This requires at least four arguments, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将数据绑定到属性，我们需要创建一个`BindableProperty`类。这应该是类中的一个公共静态字段。我们还需要创建一个常规属性来保存值。属性的命名非常重要。`BindableProperty`的名称需要是`{NameOfTheProperty}Property`；例如，我们将在以下步骤中创建的`BindableProperty`的名称将是`PointsProperty`，因为属性的名称是`Points`。`BindableProperty`是通过`BindableProperty`类的静态`Create`方法创建的。这至少需要四个参数，如下所示：
- en: '`propertyName`: This is the name of the property as a string.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyName`：这是属性名称的字符串。'
- en: '`returnType`: This is the type that will be returned from the property.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnType`：这是属性将返回的类型。'
- en: '`declaringType`: This is the type of the class that `BindableProperty` is declared
    in.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declaringType`：这是`BindableProperty`声明的类的类型。'
- en: '`defaultValue`: This is the default value that will be returned if no value
    is set. This is an optional argument. If it is not set, .NET MAUI will use `null`
    as a default value.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue`：这是如果没有设置值将返回的默认值。这是一个可选参数。如果没有设置，.NET MAUI 将使用 `null` 作为默认值。'
- en: 'The `set` and `get` methods for the property will call methods in the base
    class to set or get values from `BindableProperty`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性的 `set` 和 `get` 方法将调用基类中的方法来设置或从 `BindableProperty` 获取值：
- en: 'Create `BindableProperty` called `PointsProperty`, as shown in the following
    code snippet:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PointsProperty` 的 `BindableProperty`，如下面的代码片段所示：
- en: '[PRE55]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a property of the `List<Models.Point>` type called `Points`. Remember
    to cast the result of `GetValue` so that it’s the same type as the property. We
    need to do this because `GetValue` will return the value as a `type` object:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Points` 的 `List<Models.Point>` 类型的属性。记住将 `GetValue` 的结果转换为与属性相同的类型。我们需要这样做，因为
    `GetValue` 将返回一个 `type` 对象作为值：
- en: '[PRE56]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In order to display `Points`, we need to convert them to `MapElements`. This
    is accomplished using a `BindingProperty` event called `PropertyChanged`. `PropertyChanged`
    is fired every time `BindingProperty` changes. To add the event and convert `Points`
    to `MapElements`, add the following highlighted code to the class:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示 `Points`，我们需要将它们转换为 `MapElements`。这是通过一个名为 `PropertyChanged` 的 `BindingProperty`
    事件来完成的。每当 `BindingProperty` 发生变化时，都会触发 `PropertyChanged`。要添加事件并将 `Points` 转换为
    `MapElements`，请将以下突出显示的代码添加到类中：
- en: '[PRE57]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that we’ve created a custom map control, we will use it to replace the
    `Map` control in `MainView`. Follow these steps:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个自定义地图控件，我们将使用它来替换 `MainView` 中的 `Map` 控件。请按照以下步骤操作：
- en: In the `MainView.xaml` file, declare the namespace for the custom control.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainView.xaml` 文件中，声明自定义控件的命名空间。
- en: Replace the `Map` control with the new control that we have created.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们创建的新控件替换 `Map` 控件。
- en: 'Add a binding to the `Points` property in `MainViewModel`, as shown in the
    following code snippet:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中将 `Points` 属性绑定，如下面的代码片段所示：
- en: '[PRE58]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This concludes this section on how to extend the `Maps` control. The final step
    for our app is to refresh the map when the app resumes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于如何扩展 `Maps` 控件的这一部分。我们应用程序的最终步骤是在应用程序恢复时刷新地图。
- en: Refreshing the map when the app resumes
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序恢复时刷新地图
- en: 'The last thing we will do is make sure that the map is up to date with the
    latest points when the app is resumed. The easiest way to do this is to set the
    `MainPage` property in the `App.xaml.cs` file to a new instance of `AppShell`,
    in the same way as the constructor, as shown in the following code snippet:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的最后一件事是确保在应用程序恢复时地图与最新的点保持最新。最简单的方法是在 `App.xaml.cs` 文件中将 `MainPage` 属性设置为
    `AppShell` 的新实例，就像构造函数一样，如下面的代码片段所示：
- en: '[PRE59]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `MeTracker` app is now complete – try it out. A sample screenshot is shown
    in *Figure 7**.18*:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `MeTracker` 应用程序已经完成 – 尝试使用它。一个示例截图显示在 *图 7.18*：
- en: '![](img/B19214_07_18.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19214_07_18.jpg)'
- en: Figure 7.18 – MeTracker on iOS and Android
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – iOS 和 Android 上的 MeTracker
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built an app for iOS, Mac Catalyst, and Android that tracked
    the location of a user. When we built the app, we learned how to use maps in .NET
    MAUI and how to use location tracking when it’s running in the background. We
    also learned how to extend .NET MAUI with custom controls. With this knowledge,
    we can create applications that perform other tasks in the background. We also
    learned how to extend most controls in .NET MAUI.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为 iOS、Mac Catalyst 和 Android 开发了一个应用程序，该应用程序跟踪用户的地理位置。在构建应用程序时，我们学习了如何在
    .NET MAUI 中使用地图以及如何在后台运行时进行位置跟踪。我们还学习了如何使用自定义控件扩展 .NET MAUI。有了这些知识，我们可以创建执行其他后台任务的程序。我们还学习了如何扩展
    .NET MAUI 中的大多数控件。
- en: 'Here are some ways you could extend this app even further:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以进一步扩展这个应用程序：
- en: Right now, the app updates the map location when the app resumes. How could
    you update the map when the location changes?
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，应用程序在应用程序恢复时更新地图位置。当位置发生变化时，您如何更新地图？
- en: Add a view that lists all locations from the database. Allow the user to remove
    a location from the list.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个视图，列出数据库中的所有位置。允许用户从列表中删除位置。
- en: The next project will be a weather app. In the next chapter, we will use an
    existing weather service API to retrieve weather data and then display that data
    in the app.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目将是一个天气应用程序。在下一章中，我们将使用现有的天气服务 API 获取天气数据，然后在应用程序中显示这些数据。
