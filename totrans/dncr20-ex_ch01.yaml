- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about tools used to perform development
    tasks for .NET Core 2.0 on Windows and Linux operating systems. Also, we will
    learn how to set up Linux and virtualization using VirtualBox and Hyper-V. This
    chapter will cover how to install .NET Core 2.0 and tools for Windows and Linux
    (Ubuntu). We will learn about the **virtual machine** (**VM**) setup for Ubuntu
    and create your first simple .NET Core 2.0 running application code. We will configure
    the VM to manage your first application. The purpose of this chapter is to get
    a general idea of the required tools and how to install .NET core 2.0 SDK for
    Windows and Linux, and give you basic F# understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the required tools for Windows and Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing .NET Core 2.0 and tools (Windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an Ubuntu Linux VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing .NET Core 2.0 and tools (Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating simple running code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading required tools for Windows and Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the prerequisites to be downloaded for both
    Windows and Linux operating systems to start development with .NET Core 2.0\.
    We will start with Windows and then move to Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Downloads for Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft offers the Visual Studio **integrated development environment** (**IDE**)
    for developers to develop computer programs for Microsoft Windows, as well as
    websites, web applications, web services, and mobile applications. Microsoft gives
    us the choice to pick from four Visual Studio adaptations—Community, Professional,
    Enterprise, and Code. You can download one of these, depending on your individual
    prerequisite. How these versions differ from each other is explained next.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)
    in the browser of your choice. You will see four choices. Select the Visual Studio
    product based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'All versions of Visual Studio 2017 are available for Windows and Macintosh
    operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Community**: This is a free, open source version of Visual
    Studio with limited features. This is for the individual developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Professional**: This version has professional developer tools,
    services, and subscription benefits for small teams (five members).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Enterprise**: This version supports all Visual Studio features
    and is meant for end-to-end solution development to meet the demanding quality
    and scaling needs of teams of all sizes. It is great for enterprise organizations.
    Some of the key features that come with this version are testing tools, architectural
    layer diagrams, live dependency validation, architecture validation, code clone
    detection, IntelliTrace, .NET memory dump analysis, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: This is a free, open source version and cross-platform
    (Linux, macOS, Windows) editor that can be extended with plugins to meet your
    needs. It includes support for debugging, embedded Git control, syntax highlighting,
    extension support, intelligent code completion, snippets, and code refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a note that Visual Studio is an IDE, while Visual Studio Code is an editor,
    just like Notepad is an editor. So Visual Studio Code is much more lightweight,
    fast, and fluid with great support for debugging and has embedded Git control.
    It is a cross-platform editor and supports Windows, Linux, and Macintosh. Debugging
    support is good and has rich IntelliSense and refactoring. Like most editors,
    it is keyboard-centric. It is a file and folders-based editor and doesn't need
    to know the project context, unlike an IDE. There is no File | New Project support
    in Visual Studio Code as you would be used to in Visual Studio IDE. Instead, Visual
    Studio Code offers a terminal, through which we can run dotnet command lines to
    create new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for development in Windows, we can use either of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we choose Visual Studio 2017, all we need to do is download Visual Studio
    2017 version 15.3 from [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads).
    It comes bundled with the .NET Core 2.0 SDK and its templates and so we will be
    ready for development immediately after installing it. Also with Visual Studio
    2017, F# tools automatically get installed once we create an F# project or open
    an F# project for the very first time. So, the F# development setup is taken care
    of as well. We will see the installation of Visual Studio 2017 in the *Installing
    .NET Core 2.0 and tools (Windows)* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If we choose Visual Studio Code for development, we need to download Visual
    Studio Code from [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    and the .NET Core 2.0.0 SDK from [https://www.microsoft.com/net/core#windowscmd](https://www.microsoft.com/net/core#windowscmd)
    . We will look at the installation of Visual Studio Code in the *Installing .NET
    Core 2.0 and tools (Windows)* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Downloads for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, Microsoft Visual Studio Code is a cross-platform
    editor, and it supports Linux operating systems. So, we are going to use Visual
    Studio Code to create all the example applications on Linux in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start downloading the tools required to stop our development of .NET
    Core 2.0 applications on the Linux operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio Code from [https://code.visualstudio.com/](https://code.visualstudio.com/). We
    are going to install the Ubuntu 32-bit version, so we will download the Visual
    Studio Code 32-bit version. Select the Linux x86 .deb stable package for download,
    as shown in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd3b09a2-0088-4160-9a8a-3f0f0d44778d.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have a Linux machine handy, you can skip the next download step. If you
    wish to try development on the Linux platform and have a Windows machine to work
    with, then the next two steps are for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download VirtualBox from [https://www.virtualbox.org/](https://www.virtualbox.org/).
    It is Oracle''s open source general-purpose full virtualizer. At the time of writing
    this chapter, the latest version of VirtualBox is 5.1\. The version 5.1.26 was
    released on July 27, 2017\. Using this, we will set up a Linux (Ubuntu) virtual
    machine on the Windows host machine. Click on Download VirtualBox `5.1.` It will
    open a page that has options on VirtualBox binaries. We can select an option based
    on the machine on which we are installing it. We are installing it on a Windows
    machine, so we will click on Windows hosts. In a similar way, we can select different
    platforms. On clicking Windows hosts, it will download the VirtualBox executable
    `VirtualBox-5.1.26-117224-Win.exe`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/61e988ca-8ed5-44f4-8dc2-d788287dbbb1.png)'
  prefs: []
  type: TYPE_IMG
- en: VirtualBox needs the Ubuntu **International Standards Organization** (**ISO**)
    image to create the Ubuntu VM, so next we need to download the ISO image of Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the ISO image of Ubuntu by navigating to [https://www.ubuntu.com](https://www.ubuntu.com).
    By default, the virtual machine software uses 32-bit Linux, so we will select
    32-bit. Hover over the Downloads menu and click on the highlighted Desktop link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06faca8a-c433-4ec0-8eef-95fda0c6567c.png)'
  prefs: []
  type: TYPE_IMG
- en: It will take us to the downloads page for the desktop. Click Download on Ubuntu
    for the desktop. It will start the download of Ubuntu 17.04 ISO. An ISO image
    of approximately 1.5 GB will be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download .NET Core 2.0 SDK from [https://www.microsoft.com/net/download/linux](https://www.microsoft.com/net/download/linux):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1447c9e-07fc-4ddc-bc33-a195c281f2c2.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with the downloads for our setup in Linux. In the next
    section, we will learn how to install and set up these tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu 17.04**: As of writing this chapter, this is the latest version, and
    its code name is **Zesty Zapus**, released on April 13, 2017\. Ubuntu releases
    carry a version number in the form of `XX.YY`, with `XX` representing the year
    and `YY` representing the month of the official release. For example, the latest
    version released in April 2017 is represented by 17 (year) and 04 (month). Ubuntu
    code names use an adjective animal combination, that is an adjective word followed
    by the name of an animal, typically one that''s unique. At the time of writing,
    Ubuntu 17.10 is due to be released in October 2017; examples covered here used
    the Ubuntu 17.04 version.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing .NET Core 2.0 and tools (Windows)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are done with the downloads, it''s time to install. As seen in
    the last section on Windows, we have two options for development in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 version 15.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on your choice, you can follow the appropriate installation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio 2017 version 15.3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Double-click on the executable file downloaded for Visual Studio 2017 version
    15.3 in the earlier section. This will start the installation. C# comes by default
    in every Visual Studio installation, so there is nothing to do for C#. Visual
    Studio 2017 also comes with F# support in all its editions: Community, Professional,
    and Enterprise. F# is an optional component though. The installer includes it
    as a selectable workload, or you can select it manually in the Individual components
    tab, under the Development activities category. Select F# language support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40121a2-39ee-4b89-8043-45f8b6a8c1ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Visual Studio 2017 version 15.3 comes with the .NET Core SDK. Select .NET Core
    cross-platform development under Workloads during the Visual Studio 2017 version
    15.3 installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0559c9f4-6be3-4749-b440-9e8decac83a9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For other versions of Visual Studio, download the .NET Core 2.0 SDK from [https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core),
    or update Visual Studio to 2017 15.3 and select .NET Core cross-platform development
    under Workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install Visual Studio Code by double-clicking the Visual Studio Code setup
    executable from its download location. It''s a simple installation for Windows. Once
    Visual Studio Code is installed, launch it. The following screenshot shows the
    user interface layout of Visual Studio Code. It follows the conventional editor
    style and displays files and folders you have access to on the left side and the
    code content in the editor on the right side. It can be roughly divided into seven
    sections, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe03fcab-ec66-4669-a23e-6cc4927d1e13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Menu bar**: The standard menu bar for doing various operations in the editor,
    such as opening a file/folder, editing, viewing and installing extensions, changing
    themes, debugging, running and configuring tasks, and getting help.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Activity bar**: Groups the most commonly performed activities on the leftmost
    side of the editor. It lets the user switch between the views. It is customizable
    and lets the user choose the views to be displayed in the bar, by right-clicking
    on the bar and selecting/unselecting the views. The bar itself can be hidden in
    the same way. By default, it has five views, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37501094-9eb2-412c-af94-1c9871a30aa0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**EXPLORER**: This view lets your browse, open, and manage all the files and
    folders in your project. You can create, delete, and rename files and folders,
    as well as move files and folders from here. You can also open the files/folders
    in Terminal (Command Prompt in Windows) from here by right-clicking and selecting Open
    in Command Prompt. You can find the file/folder location as well from here.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SEARCH**: This view lets you search and replace globally across your open
    folder.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOURCE CONTROL**: This lets you work with Git source control by default.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DEBUG**: This view displays the breakpoints, variables, and call stack for
    debugging.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXTENSIONS**: This is used to install and manage extensions in Visual Studio
    Code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Side bar**: This contains the view selected from the activity bar.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Command Palette**: As stated earlier, Visual Studio Code is keyboard-centric,
    so anyone who loves using a keyboard is going to have a great time working on
    Visual Studio Code. The *Ctrl *+ *Shift *+ *P* key combination brings up what
    is called a Command Palette. We can access all the functionality of Visual Studio
    Code from here. To make effective use of Visual Studio Code, it is highly recommended
    that the reader makes himself/herself well versed with the commands from the help
    menu item links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad6810b3-2259-47e5-a467-02876b7ef96a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Editor**: The editor is where the content of the file is displayed and the
    user can edit it. Visual Studio Code provides a feature called Split Editor (open
    to the side in Linux). Go to the View menu in the menu bar and select Split Editor
    (alternatively you can type the command *Ctrl* +*\*). This will create a new editor
    region, where you can edit a group of files. These regions are called editor groups.
    The open editors can also be seen in the Explorer view in the sidebar. Visual
    Studio Code allows up to three editor groups, designated as LEFT, CENTER, and
    RIGHT**,** as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7664a48d-5c8d-4cd1-8f9e-25a63919783f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Panels**: Displays the TERMINAL, OUTPUT, PROBLEMS, and DEBUG CONSOLE panes
    below the editor. To see it in action, go to the View menu and click any of the
    menu items from PROBLEMS, OUTPUT, DEBUG CONSOLE, and TERMINAL. Alternatively,
    you can also press their corresponding commands. We will see more on panels when
    we write our first application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Status Bar**: Displays information about the opened project and files being
    edited, such as errors, warnings, current line and column number, encoding, and
    file type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we are familiar with Visual Studio Code, its layout, and basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Help menu and explore in detail the features that Visual Studio Code
    offers. The Interactive Playground highlights a number of features in Visual Studio
    Code and also lets you interactively try them out. The Help menu also has Documentation,
    Introductory Videos, Tips and Tricks, which are very handy.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Visual Studio Code is an editor and therefore we need to add support
    for the language we want to work with through extensions. Visual Studio Code is
    very rich in extensions. For our example and for the purpose of learning .NET
    Core 2.0, we will install extensions for C# and F#, as we will be working with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with C#, as after a fresh install we do not have support for C#
    and hence there would be no IntelliSense to work with on the editor. To install
    C#, let''s switch to Extension View and search for `C#`. We will choose C# for
    Visual Studio Code (powered by OmniSharp)**,** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/828306d3-72fc-4b35-a66a-a1d348ce5dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Install and then click on Reload and Visual Studio Code will start supporting
    C# along with its IntelliSense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, search `F#` and Install it. We will be using the Ionide-fsharp extension,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72c491b3-1f54-4104-81b9-3c974e688265.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With Visual Studio Code, we need to install .NET Core SDK - 2.0.0 (x64) also,
    as Visual Studio Code doesn''t install it. Double-click on the executable of .NET
    Core 2.0 SDK to install it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07de42a5-167b-471f-a8d5-7e750de63b49.png)'
  prefs: []
  type: TYPE_IMG
- en: And with this, we are done with the installation of our prerequisites for development
    on the Windows platform. Next, we will set up a Linux (Ubuntu) VM and perform
    the installation of prerequisites there. If you are using a Windows platform and
    do not wish to set up a Linux VM, the next section can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: The Visual Studio Code user interface was developed on the Electron framework,
    which is an open source framework used to build cross-platform desktop applications
    with JavaScript, HTML, and CSS. The editor is powered by Microsoft's Monaco Editor
    and gets its intelligence from OmniSharp/Roslyn and TypeScript. As all of these
    are open source, you can search them and see the source code in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Ubuntu Linux VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how to set up Linux (Ubuntu) on a virtual machine,
    so that a Windows user can also develop and test their .NET Core 2.0 applications
    in Linux. To do so, let’s start with the VirtualBox setup. Oracle provides an
    open source VirtualBox executable, which we downloaded in the previous section.
    The following are the steps we need to follow to set up VirtualBox:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the VirtualBox executable. It will open a wizard. Before installation,
    click on Disk usage and check Disk Space Requirement. It is recommended that the
    virtual machine for Ubuntu Linux is set up with at least 2 GB RAM and 25 GB free
    hard drive space. So, instead of choosing the default drive (the `C` drive in
    our case, where Windows is installed), select another drive if it exists (for
    example, the `D` drive) so that you can easily allocate more space, and it also
    prevents any impact on the host operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The VirtualBox setup needs approximately 241 MB of disk space to install. It's
    recommended to create a new folder (for example, `VirtualBox`) to easily identify
    and track the VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep clicking the Next button until the last page. At the end, a warning will
    be displayed that the installation of VirtualBox will reset the network connection
    and temporarily disconnect the machine from the network. This is alright if you
    are working on the same physical machine. So, click on the Yes button and continue,
    and then click on the Install button and finish the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95a398fd-5cbd-4d6d-bf8f-3c8147979cc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the preceding installation is done, open the VirtualBox manager to create
    a new virtual machine. Click on New and give the Name of the machine (for example, `Ubuntu`,
    as shown), and select the Type as Linux and the Version as Ubuntu (32 bit):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd7acfaf-bf11-4c0d-b328-b61641c1cd5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to specify the memory size. More memory is good, but we should consider
    our disk space before selecting it. A minimum of 2 GB system memory is required
    for Ubuntu 17.04\. Select Create and then select VDI (VirtualBox Disk Image) as
    Hard disk file type. Select a Dynamically allocated hard disk. It will use space
    on your physical hard disk as it fills up (up to the maximum fixed size). Set
    the disk space maximum size to `25 GB` and click on Create. It will create a virtual
    machine with the Ubuntu operating system (32-bit) and 4 GB RAM, and the full details
    will be displayed on the final page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d742522-be93-434b-876a-d8cab1bef381.png)'
  prefs: []
  type: TYPE_IMG
- en: Ubuntu setup using Hyper-V
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Windows machines, we can use Hyper-V to create a Linux virtual machine.
    Let''s start with the basic settings and important configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, enable Hyper-V Management Tools and Hyper-V Platform from Windows Features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddb31de5-3f7c-4d1d-99e2-2550885beb15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the default virtual directory. By default, Hyper-V uses the same drive
    as that on which the OS is installed but this is not a good practice. We should
    change the default drive the drive on which the operating system is not installed,
    such as the `D` drive in our case.  It''s a good practice to keep Windows and
    system files separate from other files. To make configuration changes, open Hyper-V
    Manager and then Hyper-V Settings. Instead of the default selection, change it
    to some other drive (`D` in our case). Create a new folder named `Virtual Machine`
    on this new drive location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**   ![](img/94579428-5761-4be4-8405-d64efd81ef2f.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual switch. A virtual switch is used to join computers and to
    create networks. We can create three types for virtual switches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'External: An accessible network where the virtual machines are hosted on the
    same physical computer and all external servers from which the host machine can
    connect.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal: Creates a virtual switch that can be used only by the virtual machines
    that run on the same physical computer, and between virtual machines and the physical
    computer. An internal virtual switch doesn't provide connectivity to a physical
    network connection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Private: Creates a virtual switch that can be used only by the virtual machines
    that run on the same physical computer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a Private or External type of virtual switch. This will be used for
    the virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/350600c5-f394-4ac2-9838-66ebf7b3a637.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open Network and Sharing Center on your host machine and then open the external
    virtual switch properties. You will find Hyper-V Extensible Virtual Switch**.** This
    provides network connectivity to the virtual machine. Enable this or the virtual
    machine won''t be able to connect to the host machine network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/324987f8-430f-4c1f-a74a-e238614f6a51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new virtual machine, and choose the name and location for the virtual
    machine. Select Generation 1 on the next page and select External Virtual Switch.
    Select the Install an operating system from a bootable CD/DVD-ROM option and select
    Image file (.iso), which we downloaded earlier for Ubuntu. Continue clicking the Next
    button in the wizard and the Ubuntu virtual machine will be created. Click on
    Start and connect to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff990b4c-d99d-457a-bc2c-6006f55bf2e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After connection, we will be able to see the following screen. Select Install
    Ubuntu and set the language as English. Choose the Erase disk and install Ubuntu option
    and then click Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee5c0e55-4258-4719-814b-ca2126e86f49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide the username and password that you want and click Continue. Restart
    the system once the installation is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/529ab54e-cfc4-48ba-95bd-b78818a339a9.png)'
  prefs: []
  type: TYPE_IMG
- en: After restarting the virtual machine, it will display a login page. Enter the
    password that you provided while installing Ubuntu. On successful login, it will
    open the homepage, from where we can start Visual Studio Code and .NET Core 2.0
    SDK installation on this Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing .NET Core 2.0 and tools (Linux)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Visual Studio Code in Linux, download the .deb (32 bit) file from
    [http://code.visualstudio.com/download](http://code.visualstudio.com/download),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/044c93b4-fbe6-4fea-a9bb-b278f6b9cf75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the folder location the `.deb` file has been downloaded to. Right-click
    and select **Open in Terminal.** This will open Terminal from this location. Run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`<fileName>`: Enter the filename that was downloaded, which is `code_1.15.1-1502903950_i386.deb`
    in our case, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ae57513-5ff0-4f69-8c53-680e2451b271.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the `Downloads` folder, and select Open in Terminal. It will
    display the following terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10059e49-68ed-4234-ba3f-0c1d577ea2a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It may show error messages stating that dependencies have not been installed.
    Run the following command to install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will complete the installation of Visual Studio Code in this Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s install the .NET Core 2.0 SDK. Open the folder location where the `dotnet-sdk-2.0.0`
    file is downloaded. Right-click and select Open in Terminal. It will open Terminal
    from this location. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! We are all set to run Visual Studio Code! Please refer to the *Installing
    Visual Studio Code* section of this chapter to get an overview of Visual Studio
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: Open Extensions View from the Visual Studio Code activity bar. Search `F#` and
    install the Ionide-fsharp extension for F# language support, as we discussed in
    the *Installing Visual Studio Code* section under the *Install .NET Core 2.0 and
    tools (Windows)* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, search `C#` and install the C# for Visual Studio Code (powered by OmniSharp)
    extension for C# language support.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple running code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create our very first .NET Core 2.0 application. We will create it using
    Visual Studio Code as well as Visual Studio 2017 in Windows, and with Visual Studio
    Code in Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Core 2.0 SDK installs the templates for creating the class library,
    console, web, MVC, razor, web API, and so on, for applications based on .NET Core
    2.0\. As our first application, we will create a simple MVC application on .NET
    Core 2.0, and get familiar with the application code and the .NET Core 2.0 command-line
    integration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating this application in Windows using Visual Studio 2017,
    and then we will create the same application from Visual Studio Code, first in
    Windows and then in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application in Windows through Visual Studio 2017 version 15.3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio 2017.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to File | New | Project. In the New Project dialog, you should see the .NET
    Core template inside `Visual C#`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c81643bf-0a80-41e3-b8c7-afb300454989.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on .NET Core and select ASP.NET Core Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `HelloDotNetCore2` and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will show a New ASP.NET Core Web Application dialog. Ensure .NET Core and
    ASP.NET Core 2.0 are selected in the two dropdowns displayed in this dialog, as
    we are discussing .NET Core 2.0 here. The first dropdown signifies the target
    framework of the application and the second dropdown is the version of ASP.NET
    Core that we are using. You have the option to choose .NET Framework as the target
    framework in the first dropdown, but then the resulting application would not
    be cross-platform. If the application has to be cross-platform, it should target
    .NET Core. The second dropdown has the different versions of ASP.NET Core that
    have been released so far, such as 1.0, 1.1, and 2.0\. We will keep it as ASP.NET
    Core 2.0\. You will also notice that with ASP.NET Core 2.0, the number of templates
    has increased from the previous version. Apart from Empty, Web API, and Web Application,
    which were present in ASP.NET 1.1, we also have templates for Web Application
    (Model-View-Controller),  Angular, React.js, and React.js and Redux. We will choose
    Web Application (Model-View-Controller) as our template. There is support for
    a Docker container but let''s keep it unchecked for the time being. We will discuss
    Docker in detail in a later chapter. Also, keep the Authentication as No Authentication.
    We will explore authentication options in detail in a later chapter. Click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eddf3a01-4596-402b-96d8-4a356f44f97c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And *voila*! Visual Studio creates the `HelloDotNetCore2` project for us and
    restores the required packages to build in the background. You can check this
    by inspecting the Package Manager Console output. Your very first ASP.NET Core
    2.0 is ready to be run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/78b10a2d-85bc-4d67-9616-715a2ab4674b.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Debug or press *F5* to run the application. We will see a detailed walk-
    through of all the project artifacts in the next chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating application in Windows through Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio is the IDE and is aware of projects and templates. As stated earlier,
    Visual Studio Code is a file and folder-based editor and hence it is not aware
    of projects and templates. So to create the same application through Visual Studio
    Code, we will make use of the .NET command line. Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio Code, go to View, and click on TERMINAL. It will open Command
    Prompt/the PowerShell terminal in the bottom section of Visual Studio Code. If
    you see the PowerShell terminal, type `cmd` so that it turns into Command Prompt.
    This is an optional step if you are comfortable with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try and explore the commands available to create a new project, so let''s
    type `dotnet --help` . This is the help command for dotnet and will let us know
    about the options that we have available for creating a .NET Core 2.0 MVC application
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39ef1123-d7fc-4dfd-a637-78be2ce4bdc0.png)'
  prefs: []
  type: TYPE_IMG
- en: The SDK lists all the possible commands and options that can be used with explanations.
    So keep in mind, any time you need any help with .NET commands, SDK is there to
    help us. Just ask for help by typing `dotnet --help` in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: From the command list, it looks like the command of interest to us is the `new` command,
    as its description reads that this command initializes .NET projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s ask SDK how to use the new command by typing `dotnet new --help`.
    This will let us know the command that we need to run to create a new MVC application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05500d06-5272-4274-9b29-70743e27cf50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the preceding help text, let''s enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new MVC project named `HelloDotNetCore2` in the C# language,
    in the folder named `HelloDotNetCore2` at the location of the terminal. Now let''s
    build and run the application by typing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command navigates to the newly created folder, `HelloDotNetCore2`.
    Then, we build the application with the second command and run it through the
    third command. The `dotnet build` command is just to show that we have a build
    command as well. The `dotnet run` command actually builds and runs the application.
    Now, go to the browser of your choice and navigate to `http://localhost:5000`
    to see the application running in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1035eb4c-283d-4272-9add-af8161a32f1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, you can go to the Explorer view in the activity bar, open the
    `HelloDotNetCore2` folder, and press *F5*. This will also build the application
    and launch it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Steps for creating the application in Ubuntu through Visual Studio Code are
    the same as in Windows, but instead of Command Prompt, we have Bash.
  prefs: []
  type: TYPE_NORMAL
- en: F# primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# is a functional programming language. Functional programming treats programs
    as mathematical expressions. It focuses on functions and constants that don't
    change, rather than variables and states. F# is a Microsoft programming language
    for concise and declarative syntax. Let's begin with a brief history of how this
    language came into existence. The first attempt at functional programming was **Haskell
    .NET**. F# development began in 2005 and after that, various versions came along. At
    the time of writing this chapter, F# 4.1 is the latest version; it was released
    in March 2017\. This comes with Visual Studio 2017 and supports .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The F# language can be used for the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: To solve mathematical problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For graphic design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For financial modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For compiler programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For CPU design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also used for CRUD applications, web pages GUI games, and other programs.
  prefs: []
  type: TYPE_NORMAL
- en: F# keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keywords and their use in the F# language are outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Keyword** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract` | Indicates that either it has no implementation or is a virtual
    and has default implementation. |'
  prefs: []
  type: TYPE_TB
- en: '| `begin` | In verbose syntax, indicates the start of a code block. |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | Indicates an implementation of an abstract method; used together
    with an abstract method declaration to create a virtual method. |'
  prefs: []
  type: TYPE_TB
- en: '| `elif` | Used in conditional branching. A short form of else-if. |'
  prefs: []
  type: TYPE_TB
- en: '| `end` | Used in type definitions and type extensions, indicates the end of
    a section of member definitions.In verbose syntax, used to specify the end of
    a code block that starts with the `begin` keyword. |'
  prefs: []
  type: TYPE_TB
- en: '| `exception` | Used to declare an exception type. |'
  prefs: []
  type: TYPE_TB
- en: '| `finally` | Used together with `try` to introduce a block of code that executes
    regardless of whether an exception occurs. |'
  prefs: []
  type: TYPE_TB
- en: '| `fun` | Used in lambda expressions, and is also known as anonymous functions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `function` | Used as a shorter alternative to the `fun` keyword and a match
    expression in a lambda expression that has pattern matching on a single argument.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `inherit` | Used to specify a base class or base interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `interface` | Used to declare and implement interfaces. |'
  prefs: []
  type: TYPE_TB
- en: '| `let` | Used to associate or bind a name to a value or function. |'
  prefs: []
  type: TYPE_TB
- en: '| `member` | Used to declare a property or method in an object type. |'
  prefs: []
  type: TYPE_TB
- en: '| `mutable` | Used to declare a variable; that is, a value that can be changed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `override` | Used to implement a version of an abstract or virtual method
    that differs from the base version. |'
  prefs: []
  type: TYPE_TB
- en: '| `rec` | Used to indicate that a function is recursive. |'
  prefs: []
  type: TYPE_TB
- en: '| `select` | Used in query expressions to specify what fields or columns to
    extract. Note that this is a contextual keyword, which means that it is not actually
    a reserved word and it only acts like a keyword in an appropriate context. |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | Used to indicate a method or property that can be called without
    an instance of a type, or a value member that is shared among all instances of
    a type. |'
  prefs: []
  type: TYPE_TB
- en: '| `struct` | Used to declare a structure type. Also used in generic parameter
    constraints. Used for OCaml compatibility in module definitions. |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | Used to declare a class, record, structure, discriminated union,
    enumeration type, unit of measure, or type abbreviation. |'
  prefs: []
  type: TYPE_TB
- en: '| `val` | Used in a signature to indicate a value, or in a type to declare
    a member, in limited situations. |'
  prefs: []
  type: TYPE_TB
- en: '| `yield` | Used in a sequence expression to produce a value for a sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: This reference is taken from the Microsoft official website, and a detailed
    explanation and description can be found at [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference.](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference)
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the F# language, we have two types of comments for a single line and for
    multiple lines. This is the same as C#. The following are the two types of comments:'
  prefs: []
  type: TYPE_NORMAL
- en: A single-line comment which starts with the `//` symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example: `// returns an integer exit code`
  prefs: []
  type: TYPE_NORMAL
- en: A multi-line comment which starts with (`*` and ends with `*`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example:  `(*Learn more about F# at http://fsharp.org *)`
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# has a rich data type system. We can broadly classify them as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integral types**: `sbyte`, `byte`, `int16`, `uint16`, `int32`, `uint32`,
    `int64`, and `bigint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating point types**: `float32`, `float`, and `decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text types**: `char` and `string `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other types**: `bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types are also referred to as fundamental primitive types in F#. Apart
    from these, F# has an exhaustive list of predefined types as well, such as lists,
    arrays, records, enumerations, tuples,  units, sequences, and so on. It is recommended
    that a person learning F# goes through the official Microsoft documentation on
    F# at [https://docs.microsoft.com/en-us/dotnet/fsharp/.](https://docs.microsoft.com/en-us/dotnet/fsharp/)
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# uses the `let` keyword for the declaration of a variable, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The compiler automatically detects this as a value type. If we pass a float
    value, the compiler will be able to understand that without declaring a data type.
    Variables in F# are immutable, so once a value is assigned to a variable, it can't
    be changed. They are compiled as static read-only properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variables `x`, `y`, and `z` are all of type `int32` and are immutable, meaning
    their value cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print their values. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding code executes, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to modify the value of `x` from `50` to `60` and check
    that `z` reflects the updated sum; we will write the code as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On executing this code, we get the following errors, and rightly so because
    `x` and `z` are immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way of doing it would be to use mutable variables for the declaration,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On printing the values again, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# has the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these operators in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arithmetic operators supported by the F# language are outlined in the following
    table. Assuming variable `X = 10` and variable `Y = 40` , we have the following
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Adds two values | `X + Y  = 50` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtracts the second value from the first | `X - Y = -30` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplies both values | `X * Y = 400` |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Divides two values | `Y / X = 4` |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Modulus operator and gives the value of the remainder after an integer
    division | `Y % X = 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | Exponentiation operator; raises one variable to the power of another
    | `Y**X = 40^(10)` |'
  prefs: []
  type: TYPE_TB
- en: Comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following table shows all the comparison operators supported by F# . These
    operators return `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take `X = 20` and `Y = 30`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Verifies the values of two variables are equal; if not, then the condition
    becomes `false`. | `(X == Y)` returns `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `<>`  | Verifies the values of two variables are equal; if values are not
    equal then the condition becomes `true`. | `(X <> Y)` returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `>`  | Verifies the value of the left variable is greater than the value
    of the right variable; if not, then the condition becomes `false`. | `(X > Y)` returns `false`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<`  | Verifies the value of the left variable is less than the value of
    the right variable; if yes, then the condition becomes `true`. | `(X < Y)` returns `true`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Verifies the value of the left variable is greater than or equal to
    the value of the right variable; if not, then condition becomes `false`. | `(X
    >= Y)` returns `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Verifies the value of the left variable is less than or equal to the
    value of the right variable; if yes, then the condition becomes `true`. | `(X
    <= Y)` returns `true` |'
  prefs: []
  type: TYPE_TB
- en: Boolean operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows all the Boolean operators supported by the F# language.
    Let''s take variable `X` as `true` and `Y` as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Boolean AND operator. If both the bool values are `true` means `1`,
    then the condition is `true`. | `(X && Y)` is `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Boolean OR operator. If either of the two bool values is
    `true` means `1`, then the condition is `true`. | `(X &#124;&#124; Y)` is `true`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `not` | Boolean NOT operator. If the condition is `true`, then the logical
    NOT operator will become `false` and vice versa. | `not (X && Y)` is `true` |'
  prefs: []
  type: TYPE_TB
- en: Bitwise operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bitwise operators work on bits and perform bit-by-bit operations. The truth
    tables for `&&&` (bitwise AND), `|||` (bitwise OR), and `^^^` (bitwise exclusive
    OR) are shown as follows. In the following table, the first variable is `X` and
    the second variable is `Y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`X`** | `Y` | `X &&& Y` | `X &#124;&#124;&#124; Y` | `X ^^^ Y` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: It also supports `~~~`(Unary, effect of flipping bits) , `<<<` (left shift operator),
    and `>>>`(right shift operator).
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The F# language has the following (`if...else` and loop) types of decision-making
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows all the ways of implementing `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Statement** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `if`/`then` statement |  An `if`/`then` statement consists of a Boolean expression
    followed by one or more statements. |'
  prefs: []
  type: TYPE_TB
- en: '| `if`/`then`/`else` statement | An `if`/`then` statement can be followed by
    an optional `else` statement, which executes when the Boolean expression is `false`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `if`/`then`/`elif`/`else` statement | An `if`/`then`/`elif`/`else` statement
    allows you to have multiple `else` statements. |'
  prefs: []
  type: TYPE_TB
- en: '| Nested `if` statements | You can use one `if` or `else if` statement inside
    another `if` or `else if` statements. |'
  prefs: []
  type: TYPE_TB
- en: Loop statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# provides the following types of loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Loop type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `for…to` and `for…downto` expressions | The `for...to` expression is used
    to iterate in a loop over a range of values of a loop variable. The `for…downto`
    expression reduces the value of a loop variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `for…in` expression | This form of `for` loop is used to iterate over collections
    of items; that is, loops over collections and sequences. |'
  prefs: []
  type: TYPE_TB
- en: '| `while…do` loop | Repeats a statement or group of statements while the given
    condition is true. It tests the condition before executing the loop body. |'
  prefs: []
  type: TYPE_TB
- en: '| nested loops | We can use one or more loop inside any other `for` or `while`
    loop. |'
  prefs: []
  type: TYPE_TB
- en: F# functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# functions act like variables. We can declare and use them in the same way
    as we use variables in C#. A function definition starts with the `let` keyword, followed
    by the function name and parameters, a colon, its type, and the right-side expression,
    showing what the function does. The syntax is follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`functionName` is an identifier of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters` gives the list of parameters separated by spaces. We can also
    specify an explicit type for each parameter and if not specified, the compiler
    tends to presume it from the function body as variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`functionbody` comprises an expression, or a compound expression, which has
    number of expressions. The final expression in the function body is the return
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returnType` is a colon followed by a type and it is optional. If the `returnType`
    is not specified, then the compiler determines it from the final expression in
    the function body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following example for our syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Calling a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function can be called by passing the function name followed, by a space,
    and then arguments (if any) separated by spaces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform many tasks using F# functions, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new function and link that function with a type as it acts
    as a variable type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let square x = x*x`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can perform some calculations as well, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `let square x = x*x` ``'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can assign a value. Taking the same example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let square x = x*x`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can pass a function as a parameter to another function like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let squareValue = List.map square[1;2;3] // using square function`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can return a function as a result of another function example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let squareValue = List.map square[1;2;3]`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: File sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of files in a project matters in an F# solution. The file used in
    any function should be placed above the file where the function is used, because
    F# has a forward-only model of compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike C#, where the file sequence doesn''t matter, the sequencing of files
    does matter in F#. For example, consider that `Program.fs` is using `DotNetCorePrint.fs`.
    So, `DotNetCorePrint.fs` should be placed above `Program.fs` in the solution;
    otherwise, it will throw a compilation error. To move a file up or down, we can
    right-click on the file and select Move Up or the keys *Alt* + the up arrow to
    move the file. The ordering of the files in Solution Explorer can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/785d689b-0614-4bef-a938-625773a91d84.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic input/output syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to see how to write and read in F#. To read and write into
    the console, we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: To write: `System.Console.Write("Welcome!")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read: `` `System.Console.Read()` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To print: `printfn "Hello"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s compare F# with C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '|                                 **F#** | **C#** |'
  prefs: []
  type: TYPE_TB
- en: '| The F# user is free from the obligation of defining types; for example: `let
    square x = x* x`The compiler can identify (`integer * integer`) or (`float * float`)
    when we pass a value. | The C# user is bound to provide a type:`Public int square(int
    x){ return x = x*x ; }` |'
  prefs: []
  type: TYPE_TB
- en: '| F# has immutable data, and the value never changes; for example: `let number
    = [3;2;1]``let moreNumber = 4:: number`In the preceding example, to add one more
    number, (`4`), we need to create a new list of items using `number`, and add the
    new record, `4` in this case. The same list doesn''t get modified for safer asynchronous
    execution and a simplified understanding of a function. | C# has mutable as well
    as immutable data. Strings are immutable, the rest are all mutable, for example:`var
    number = new List<int> {1,2,3}; number.Add(4);`In the preceding example, we created
    a list and added a new item to the same list. The list gets modified. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: F# compiles code in an order. It is favoured for data processing and algorithmic
    computation. It doesn't work on visibility; it works sequentially. | C# code works
    on visibility. The sequence doesn't matter. |
  prefs: []
  type: TYPE_NORMAL
- en: '| The order of files in a project matters in the F# solution. A file used in
    any method should be placed above the file where the method has been used. |'
  prefs: []
  type: TYPE_TB
- en: The order doesn't matter in C#. |
  prefs: []
  type: TYPE_NORMAL
- en: '| F# has precise syntax; it focuses on *what not* and *how*; for example:`let
    square x = x*x``let squared = List.map square[1;2;3]  // using square function`Right-click
    execute &#124; result `1;4;9`F# uses declarative syntax, not imperative syntax
    as in C#. F# helps us to minimize accidental complexity, meaning complexity that
    is not a part of the problem, but which we introduced as part of the solution,
    for example:`let rec quicksort = function &#124; [] -> [] &#124; x :: xs ->  let
    smaller = List.filter((>)x) xs let larger = List.filter ((<=)x) xs`Quicksort smaller
    `@ [x] @` quicksort larger:`Let sorted = quicksort [4;5;4;7;9;1;6;1;0;-99;10000;3;2]``rec`
    is used for a recursive function. It is assigned in the sorted result. Run it
    and you will get a sorted result. It is a very simple sorting function with less
    complexity than C#, which has a high chance of errors. | C# code implementation
    is more about how to implement. It sometimes increases unnecessary complexity
    as part of the solution to a problem.Quick sort has a very complex algorithm and
    a high chance of increasing accidental complexity. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed downloading Visual Studio Code, .NET Core 2.0,
    an Ubuntu 17.04 ISO image, and the tools required to start .NET Core application
    creation, as well as how to install them on Windows and Linux machines. We also
    discussed how to set up a Ubuntu Linux virtual machine and introduced the F# language.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll be introduced to native libraries in .NET Core,
    used to extend console capabilities. We will discuss Interop with existing libraries
    and ncurses.
  prefs: []
  type: TYPE_NORMAL
