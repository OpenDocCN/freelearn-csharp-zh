<html><head></head><body>
<div><div><h1 id="_idParaDest-131"><em class="italic"><a id="_idTextAnchor130"/>Chapter 8</em>: Parallel Data Structures and Parallel LINQ</h1>
<p>.NET provides many useful features and data constructs for developers who are introducing parallelism to their projects. This chapter will explore these features, including <code>SpinLock&lt;T&gt;</code> <strong class="bold">synchronization primitive</strong>, and <strong class="bold">Parallel LINQ</strong> (<strong class="bold">PLINQ</strong>). These features can improve the performance of your applications while maintaining safe threading practices.</p>
<p>Most .NET developers are familiar with LINQ frameworks, including LINQ to Objects, LINQ to SQL, and LINQ to XML. There are even open source .NET LINQ libraries, such as LINQ to Twitter (<a href="https://github.com/JoeMayo/LinqToTwitter">https://github.com/JoeMayo/LinqToTwitter</a>). We will take those LINQ skills and leverage them in parallel programming with PLINQ. Every LINQ developer can be a PLINQ developer after reading this chapter. Read ahead for some useful examples of working with PLINQ in C#.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>Introducing PLINQ</li>
<li>Converting LINQ queries to PLINQ</li>
<li>Preserving data order and merging data with PLINQ</li>
<li>Data structures for parallel programming in .NET</li>
</ul>
<p>By the end of this chapter, you will have a new appreciation for LINQ when it comes to parallel programming.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later.</li>
<li>.NET 6.</li>
<li>To complete the WPF sample, you will need to install the .NET desktop development workload for Visual Studio.</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08</a>.</p>
<p>Let’s get started by discussing LINQ, PLINQ, and why the query language can be a great way to improve your parallel programming with C#.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Introducing PLINQ</h1>
<p>PLINQ <a id="_idIndexMarker416"/>is a set of .NET extensions for<a id="_idIndexMarker417"/> LINQ that allow part of the LINQ query to execute in parallel by leveraging the thread pool. The PLINQ implementation provides parallel versions of all of the available LINQ query operations.</p>
<p>Like<a id="_idIndexMarker418"/> LINQ queries, PLINQ queries<a id="_idIndexMarker419"/> offer deferred execution. This means that the objects are not queried until they need to be enumerated. If you aren’t familiar with LINQ’s deferred execution, we will look at a simple example to illustrate the concept. Consider these two LINQ queries:</p>
<pre class="source-code">internal void QueryCities(List&lt;string&gt; cities)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    <strong class="bold">// Query is executed with ToList call</strong></pre>
<pre class="source-code">    List&lt;string&gt; citiesWithS = cities.Where(s =&gt; </pre>
<pre class="source-code">        s.StartsWith('S')).ToList();</pre>
<pre class="source-code">    <strong class="bold">// Query is not executed here</strong></pre>
<pre class="source-code">    IEnumerable&lt;string&gt; citiesWithT = cities.Where(s =&gt; </pre>
<pre class="source-code">        s.StartsWith('T'));</pre>
<pre class="source-code">    <strong class="bold">// Query is executed here when enumerating</strong></pre>
<pre class="source-code">    foreach (string city in citiesWithT)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        // Do something with citiesWithT</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>In the example, the <a id="_idIndexMarker420"/>LINQ query that populates <code>citiesWithS</code> is executed immediately because of the call to <code>ToList()</code>. The second query that populates <code>citiesWithT</code> is not immediately executed. The execution is deferred until the <code>IEnumerable</code> values are required. The <code>citiesWithT</code> values are not required until we iterate over them in the <code>foreach</code> loop. The same principle holds true for <a id="_idIndexMarker421"/>PLINQ queries.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are unfamiliar with LINQ concepts or the LINQ method syntax, the book <em class="italic">C# 10 and .NET 6 – Modern Cross-Platform Development – Sixth Edition</em> by <em class="italic">Mark J. Price</em> has a chapter dedicated to explaining LINQ syntax and several of its implementations. It is an excellent book for every .NET developer. You can find out more about the book here: <a href="https://subscription.packtpub.com/product/mobile/9781801077361">https://subscription.packtpub.com/product/mobile/9781801077361</a>.</p>
<p>PLINQ is<a id="_idIndexMarker422"/> similar to LINQ in other ways, too. You can create PLINQ queries on any collection that<a id="_idIndexMarker423"/> implements <code>IEnumerable</code> or <code>IEnumerable&lt;T&gt;</code>. You can use all of the familiar LINQ operations such as <code>Where</code>, <code>FirstOrDefault</code>, <code>Select</code>, and so on. The primary difference is that PLINQ attempts to leverage the power of parallel programming by part or all of a query across multiple threads. Internally, PLINQ partitions the in-memory data into multiple segments and performs the query on each segment in parallel.</p>
<p>There are several factors that impact the performance gained by using PLINQ. Let’s explore those next.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>PLINQ and performance</h2>
<p>When <a id="_idIndexMarker424"/>deciding which LINQ queries are good candidates to leverage the power of PLINQ, you must consider a number of factors. The primary factor to consider is whether the magnitude or complexity of the work to be performed is great enough to offset the overhead of threading. You should be operating on a large dataset and be performing an expensive operation on each item in the collection. The LINQ example that checked the first letter of a string is not a very good candidate for PLINQ, especially if the source collection only contains a handful of items.</p>
<p>Another factor in the performance to potentially be gained with PLINQ is the number of cores available on the system where the queries will be running. The greater the number of cores that PLINQ can leverage, the better the potential gain. PLINQ can break down a large dataset into more units of work to be executed in parallel with many cores at its disposal.</p>
<p>Ordering and grouping data can incur a larger amount of overhead than it would in a traditional LINQ query. The<a id="_idIndexMarker425"/> PLINQ data is segmented, but grouping and ordering must be performed across the entire collection. PLINQ is best suited for queries where the data sequence is not important.</p>
<p>We will discuss some other factors that impact query performance in the <em class="italic">Preserving data order and merging data with PLINQ</em> section. Now, let’s start creating our first PLINQ queries.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Creating a PLINQ query</h2>
<p>The<a id="_idIndexMarker426"/> majority of the functionality of PLINQ is exposed through members of the <code>System.Linq.ParallelEnumerable</code> class. This class contains implementations of all of the LINQ operators that are available to in-memory object queries. There are some additional operators in this class that are specific to PLINQ queries. The two most important operators to understand are <code>AsParallel</code> and <code>AsSequential</code>. The <code>AsParallel</code> operator indicates that all subsequent LINQ operations should be attempted to be performed in parallel. In contrast, the <code>AsSequential</code> operator indicates to PLINQ that the LINQ operations that follow it should be performed in sequence.</p>
<p>Let’s look at an example that uses both of these PLINQ operators. Our query will be operating on <code>List&lt;Person&gt;</code> with the following definition:</p>
<pre class="source-code">internal class Person</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    public string FirstName { get; set; } = "";</pre>
<pre class="source-code">    public string LastName { get; set; } = "";</pre>
<pre class="source-code">    public int Age { get; set; }</pre>
<pre class="source-code">}</pre>
<p>Let’s<a id="_idIndexMarker427"/> consider that we are working with a dataset of thousands or even millions of people. We want to leverage PLINQ to query only the adults aged 18 or older from the data and then group them by their last name. We want to execute only the <code>Where</code> clause of the query in parallel. The <code>GroupBy</code> operation will be performed sequentially. This method will do exactly that:</p>
<pre class="source-code">internal void QueryAndGroupPeople(List&lt;Person&gt; people)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    <strong class="bold">var results = people.AsParallel().Where(p =&gt; p.Age &gt; 17)</strong></pre>
<pre class="source-code"><strong class="bold">        .AsSequential().GroupBy(p =&gt; p.LastName);</strong></pre>
<pre class="source-code">    foreach (var group in results)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Console.WriteLine($"Last name {group.Key} has </pre>
<pre class="source-code">            {group.Count()} people.");</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    <strong class="bold">// Sample output:</strong></pre>
<pre class="source-code"><strong class="bold">    // Last name Jones has 4220 people.</strong></pre>
<pre class="source-code"><strong class="bold">    // Last name Xu has 3434 people.</strong></pre>
<pre class="source-code"><strong class="bold">    // Last name Patel has 4798 people.</strong></pre>
<pre class="source-code"><strong class="bold">    // Last name Smith has 3051 people.</strong></pre>
<pre class="source-code"><strong class="bold">    // Last name Sanchez has 3811 people.</strong></pre>
<pre class="source-code"><strong class="bold">    // ...</strong></pre>
<pre class="source-code">}</pre>
<p>The <code>GroupBy</code> LINQ method will return <code>IEnumerable&lt;IGrouping&lt;string, Person&gt;&gt;</code> with each <code>IGrouping&lt;string, Person&gt;</code> instance containing all of the people with the same <code>LastName</code>. Whether or not this <code>GroupBy</code> operation would be faster <a id="_idIndexMarker428"/>to run in parallel or sequentially depends on the makeup of the data. You should always test your application to determine whether introducing parallelism is improving the performance when working with production data. We will cover ways to performance-test your code in <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>.</p>
<p>Next, let’s look at how PLINQ queries can be written with the <strong class="bold">method syntax</strong> that we have used thus far or by using LINQ <strong class="bold">query syntax</strong>.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Query syntax versus method syntax</h2>
<p>LINQ<a id="_idIndexMarker429"/> queries can be coded either by using method syntax or query syntax. Method syntax is where you string multiple methods together to build a query. This is what we have been doing throughout this section. Query syntax is slightly different, and it is akin to T-SQL query syntax. Let’s examine the same PLINQ query written both ways.</p>
<p>Here is a simple PLINQ query to return only adults from a list of people written with method syntax:</p>
<pre class="source-code">var peopleQuery1 = people.AsParallel().Where(p =&gt; p.Age &gt; 17);</pre>
<p>Here is the exact same PLINQ query written with query syntax:</p>
<pre class="source-code">var peopleQuery2 = from person in people.AsParallel()</pre>
<pre class="source-code">                    where person.Age &gt; 17</pre>
<pre class="source-code">                    select person;</pre>
<p>You should use whichever syntax you prefer. Throughout the rest of this chapter, we will be using method syntax for the examples.</p>
<p>In the next section, we will continue to explore the operations available in PLINQ and create some parallel versions of LINQ queries.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Converting LINQ queries to PLINQ</h1>
<p>In this<a id="_idIndexMarker430"/> section, we will look at some additional PLINQ<a id="_idIndexMarker431"/> operators and show you how you can leverage them to turn existing LINQ queries into PLINQ queries. Your existing queries may have requirements for preserving the order of data. Perhaps your existing code doesn’t use LINQ at all. There could be an opportunity there to convert some logic in <code>foreach</code> loops into PLINQ operations.</p>
<p>The way to convert a LINQ query to a PLINQ query is by inserting an <code>AsParallel()</code> statement into the query, as we did in the previous section. Everything that follows <code>AsParallel()</code> will run in parallel until an <code>AsSequential()</code> statement is encountered.</p>
<p>If your queries require that the original order of objects be preserved, you can include an <code>AsOrdered()</code> statement:</p>
<pre class="source-code">var results = people.AsParallel().AsOrdered()</pre>
<pre class="source-code">    .Where(p =&gt; p.LastName.StartsWith("H"));</pre>
<p>However, this will not be as performant as queries that do not preserve the sequence of data. To explicitly tell PLINQ to not preserve data order, use the <code>AsUnordered()</code> statement:</p>
<pre class="source-code">var results = people.AsParallel().AsUnordered()</pre>
<pre class="source-code">    .Where(p =&gt; p.LastName.StartsWith("H"));</pre>
<p>The unordered version of the query will perform much better if the order of your data is not important; you should never use <code>AsOrdered()</code> with PLINQ.</p>
<p>Let’s consider another example. We will start with a method that iterates over a list of people with a <code>foreach</code> loop and calls a method named <code>ProcessVoterActions</code> for each person aged 18 or older. We’re going to assume that this method is processor-intensive and also uses some I/O to save the voter information in a database. Here is the starting code:</p>
<pre class="source-code">internal void ProcessAdultsWhoVote(List&lt;Person&gt; people)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    foreach (var person in people)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (person.Age &lt; 18) continue;</pre>
<pre class="source-code">        ProcessVoterActions(person);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private void ProcessVoterActions(Person adult)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    // Add adult to a voter database and process their </pre>
<pre class="source-code">        data.</pre>
<pre class="source-code">}</pre>
<p>This will not<a id="_idIndexMarker432"/> leverage parallel processing at all. We could<a id="_idIndexMarker433"/> improve on this by using LINQ to filter out the children under 18 and then call <code>ProcessVoterActions</code> with a <code>Parallel.ForEach</code> loop:</p>
<pre class="source-code">internal void ProcessAdultsWhoVoteInParallel(List&lt;Person&gt; </pre>
<pre class="source-code">    people)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var adults = people.Where(p =&gt; p.Age &gt; 17);</pre>
<pre class="source-code">    Parallel.ForEach(adults, ProcessVoterActions);</pre>
<pre class="source-code">}</pre>
<p>This will certainly improve the performance if <code>ProcessVoterActions</code> takes some time to run for each person. However, with PLINQ, we can improve the performance even further:</p>
<pre class="source-code">internal void ProcessAdultsWhoVoteWithPlinq(List&lt;Person&gt; </pre>
<pre class="source-code">    people)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var adults = people.AsParallel().Where(p =&gt; p.Age &gt; 17);</pre>
<pre class="source-code">    adults.ForAll(ProcessVoterActions);</pre>
<pre class="source-code">}</pre>
<p>Now, the <code>Where</code> query will run in parallel. This will certainly help performance if we expect to <a id="_idIndexMarker434"/>have thousands or millions of objects in<a id="_idIndexMarker435"/> the <code>people</code> collection. The <code>ForAll</code> extension method is another PLINQ operation that runs in parallel. It is meant to be used to perform an operation in parallel on each object in the query results.</p>
<p>The performance of <code>ForAll</code> will also be superior to the <code>Parallel.ForEach</code> operation in the previous example. One difference is the deferred execution of PLINQ. These calls to <code>ProcessVoterActions</code> will not be performed until the <code>IEnumerable</code> result is iterated over. The other advantage is the same advantage over performing a standard <code>foreach</code> loop with <code>IEnumerable</code> after completing a PLINQ query on your data. The data must be merged back from the multiple threads before it can be enumerated by either <code>foreach</code> or <code>Parallel.ForEach</code>. With a <code>ForAll</code> operation, the data can remain segmented by PLINQ and merged once at the end. This diagram illustrates the difference between <code>Parallel.ForEach</code> and <code>ForAll</code>:</p>
<div><div><img alt="Figure 8.1 – Advantages of PLINQ, data segmentation, and ForAll " height="984" src="img/Figure_8.1_B18552.jpg" width="1140"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Advantages of PLINQ, data segmentation, and ForAll</p>
<p>Before we explore more details about data order and merging data, let’s discuss how to handle exceptions when working with PLINQ.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Handling exceptions with PLINQ queries</h2>
<p>Implementing<a id="_idIndexMarker436"/> good exception handling in your .NET projects<a id="_idIndexMarker437"/> is important. It’s one of the fundamental practices of software development. When working with parallel programming in general, exception handling can be more complicated. This is also true with PLINQ. When any exception is unhandled within a parallel operation inside a PLINQ query, the query will throw an exception of type <code>AggregateException</code>. So, at the very minimum, all of your PLINQ queries should run within a <code>try</code>/<code>catch</code> block that catches the <code>AggregateException</code> exception type.</p>
<p>Let’s take our <a id="_idIndexMarker438"/>PLINQ <code>ForAll</code> example with <code>ProcessVoterActions</code> and add <a id="_idIndexMarker439"/>some exception handling:</p>
<ol>
<li>We’re going to run this example in a .NET console application, so create a new project in Visual Studio and add a class named <code>Person</code>:<pre>internal class Person
{
    public string FirstName { get; set; } = "";
    public string LastName { get; set; } = "";
    public int Age { get; set; }
}</pre></li>
<li>Next, add a new class named <code>PlinqExceptionsExample</code>.</li>
<li>Now add a private method to <code>PlinqExceptionsExample</code> named <code>ProcessVoterActions</code>. We’re going to throw <code>ArgumentException</code> for any person older than <code>120:</code><pre>private void ProcessVoterActions(Person adult)
{
    if (adult.Age &gt; 120)
    {
        throw new ArgumentException("This person is 
            too old!", nameof(adult));
    }
    // Add adult to a voter database and process their 
data.
}</pre></li>
<li>Next, add <a id="_idIndexMarker440"/>the <code>ProcessAdultsWhoVoteWithPlinq</code> method:<pre>internal void ProcessAdultsWhoVoteWithPlinq
    (List&lt;Person&gt; people)
{
    try
    {
        var adults = people.AsParallel().Where(p =&gt; 
            p.Age &gt; 17);
        adults.ForAll(ProcessVoterActions);
    }
    catch (AggregateException ae)
    {
        foreach (var ex in ae.InnerExceptions)
        {
            Console.WriteLine($"Exception encountered 
                while processing voters. Message: 
                    {ex.Message}");
        }
    }
}</pre></li>
</ol>
<p>This method’s <a id="_idIndexMarker441"/>logic remains the same. It’s filtering out the children with a PLINQ <code>Where</code> clause and calling <code>ProcessVoterActions</code> as a delegate to <code>ForAll</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are following along with the sample code on GitHub for this chapter (<a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets</a>), you will need to uncomment the lines of code in <em class="italic">Step 5</em>. You should also comment out the lines in the <code>Main</code> method that follow those lines to prevent other samples from executing.</p>
<ol>
<li value="5">Finally, open <code>Program.cs</code> and add some code to create an instance of <code>List&lt;Person&gt;</code> in an inline function called <code>GetPeople</code>. It can contain as many <a id="_idIndexMarker442"/>people as you like, but at least one of <a id="_idIndexMarker443"/>them needs to have an age greater than <code>120</code>. Call <code>ProcessAdultsWhoVoteWithPlinq</code>, passing the data from <code>GetPeople</code>:<pre>using LINQandPLINQsnippets;
var exceptionExample = new PlinqExceptionsExample();
exceptionExample.ProcessAdultsWhoVoteWithPlinq
    (GetPeople());
Console.ReadLine();
static List&lt;Person&gt; GetPeople()
{
    return new List&lt;Person&gt;
    {
        new Person { FirstName = "Bob", LastName = 
            "Jones", Age = 23 },
        new Person { FirstName = "Sally", LastName = 
            "Shen", Age = 2 },
        new Person { FirstName = "Joe", LastName = 
            "Smith", Age = 45 },
        new Person { FirstName = "Lisa", LastName = 
            "Samson", Age = 98 },
        new Person { FirstName = "Norman", LastName = 
            "Patterson", Age = 121 },
        new Person { FirstName = "Steve", LastName = 
            "Gates", Age = 40 },
        new Person { FirstName = "Richard", LastName = 
            "Ng", Age = 18 }
    };
}</pre></li>
<li>Now, run the <a id="_idIndexMarker444"/>program and observe the console output. If <a id="_idIndexMarker445"/>Visual Studio breaks at the exception, just click <strong class="bold">Continue</strong>:</li>
</ol>
<div><div><img alt="Figure 8.2 – Receiving an exception in the console " height="691" src="img/Figure_8.2_B18552.jpg" width="1079"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Receiving an exception in the console</p>
<p>The problem with handling the exception from outside the PLINQ query is that the entire query is stopped. It isn’t able to run to completion. If you have an exception that shouldn’t stop the entire process, you should handle it from within the code inside the query and continue processing the remaining items.</p>
<p>If you handle<a id="_idIndexMarker446"/> exceptions inside <code>ProcessVoterActions</code>, you <a id="_idIndexMarker447"/>have a chance to process them gracefully and continue.</p>
<p>Next, we are going to explore some examples of how to preserve the order of your data and handle different options for merging segments back together.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Preserving data order and merging data with PLINQ</h1>
<p>When fine-tuning <a id="_idIndexMarker448"/>PLINQ queries for your applications, there are some extension methods that impact the sequencing of data that you can leverage. Preserving the original order of your items may be something that is required. We have touched on the <code>AsOrdered</code> method in this chapter, and we will experiment with it in this section. When PLINQ operations have been completed and items are returned as part of the final enumeration, the data is merged from the segments that were <a id="_idIndexMarker449"/>created to operate on multiple threads. The merge behavior can be controlled by setting <code>ParallelMergeOptions</code> with the <code>WithMergeOptions</code> extension method. We will discuss the behavior of the three available merge options provided.</p>
<p>Let’s get started by creating some samples with the <code>AsOrdered</code> and <code>AsUnordered</code> extension methods.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>PLINQ data order samples</h2>
<p>In this section, we will<a id="_idIndexMarker450"/> create five methods that each accept the same set of data and perform the same filtering on the input data. However, the ordering in each PLINQ query will be handled differently. We are going to be working with the same <code>Person</code> class from the previous section. So, you can either work with the same project or create a new .NET console application project and add the <code>People</code> class from the previous example. Let’s get started:</p>
<ol>
<li value="1">First, open<a id="_idIndexMarker451"/> the <code>Person</code> class and add a new <code>bool</code> property named <code>IsImportant</code>. We are going to use this to add a second data point for filtering in the PLINQ queries:<pre>internal class Person
{
    public string FirstName { get; set; } = "";
    public string LastName { get; set; } = "";
    public int Age { get; set; }
    <strong class="bold">public bool IsImportant { get; set; }</strong>
}</pre></li>
<li>Next, add a new class to the project named <code>OrderSamples</code>.</li>
<li>Now it’s time to start adding the queries. In this first query, we are not specifying <code>AsOrdered</code> or <code>AsUnordered</code>. By default, PLINQ should not be attempting to preserve the original order of the data. In each of these queries, we are returning each <code>Person</code> object with <code>Age</code> less than 18 and with <code>IsImportant</code> set to <code>true</code>:<pre>internal IEnumerable&lt;Person&gt; 
    GetImportantChildrenNoOrder(List&lt;Person&gt; people)
{
    return people.AsParallel()
        .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 18);
}</pre></li>
<li>In the second example, we are explicitly adding <code>IsUnordered</code> to the query after <code>AsParallel</code>. The behavior should be the same as the first query, with PLINQ not concerning itself with the original order of the items:<pre>internal IEnumerable&lt;Person&gt; 
    GetImportantChildrenUnordered(List&lt;Person&gt; people)
{
    return people.AsParallel().AsUnordered()
        .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 18);
}</pre></li>
<li>The third example<a id="_idIndexMarker452"/> breaks up the filters into two separate <code>Where</code> clauses; <code>IsSequential</code> is added after the first <code>Where</code> clause. How do you think this will impact the item sequence? We will find out when we run the program:<pre>internal IEnumerable&lt;Person&gt; 
    GetImportantChildrenUnknownOrder(List&lt;Person&gt; 
        people)
{
    return people.AsParallel().Where(p =&gt; 
        p.IsImportant)
        .AsSequential().Where(p =&gt; p.Age &lt; 18);
}</pre></li>
<li>In the fourth example, we are using <code>AsParallel().AsOrdered()</code> to signal to PLINQ that we want the original order of items to be preserved:<pre>internal IEnumerable&lt;Person&gt; 
    GetImportantChildrenPreserveOrder(List&lt;Person&gt; 
        people)
{
    return people.AsParallel().AsOrdered()
        .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 18);
}</pre></li>
<li>In the fifth and final example, we are adding a <code>Reverse</code> method after <code>AsOrdered</code>. This should preserve the original order of items in reverse:<pre>internal IEnumerable&lt;Person&gt; 
    GetImportantChildrenReverseOrder(List&lt;Person&gt; 
        people)
{
    return people.AsParallel().AsOrdered().Reverse()
        .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 18);
}</pre></li>
<li>Next, open <code>Program.cs</code> and add two local functions. One will create a list of <code>Person</code> objects <a id="_idIndexMarker453"/>to pass to each method. The other will iterate over <code>List&lt;Person&gt;</code> to output each <code>FirstName</code> to the console:<pre>static List&lt;Person&gt; GetYoungPeople()
{
    return new List&lt;Person&gt;
    {
        new Person { FirstName = "Bob", LastName = 
            "Jones", Age = 23 },
        new Person { FirstName = "Sally", LastName = 
            "Shen", Age = 2, IsImportant = true },
        new Person { FirstName = "Joe", LastName = 
            "Smith", Age = 5, IsImportant = true },
        new Person { FirstName = "Lisa", LastName = 
            "Samson", Age = 9, IsImportant = true },
        new Person { FirstName = "Norman", LastName = 
            "Patterson", Age = 17 },
        new Person { FirstName = "Steve", LastName = 
            "Gates", Age = 20 },
        new Person { FirstName = "Richard", LastName = 
            "Ng", Age = 16, IsImportant = true }
    };
}
static void OutputListToConsole(List&lt;Person&gt; list)
{
    foreach (var item in list)
    {
        Console.WriteLine(item.FirstName);
    }
}</pre></li>
<li>Finally, we will<a id="_idIndexMarker454"/> add the code to call each method. The timestamp, including milliseconds, is being output to the console before each method call and again at the end. You can run the application multiple times to inspect the performance of each method call. Try running it on PCs with more or fewer cores and different-sized datasets to see how that impacts the output:<pre>using LINQandPLINQsnippets;
var timeFmt = "hh:mm:ss.fff tt";
var orderExample = new OrderSamples();
Console.WriteLine($"Start time: {DateTime.Now.ToString
    (timeFmt)}. AsParallel children:");
OutputListToConsole(orderExample.GetImportantChildrenN
    oOrder(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: {DateTime.Now
    .ToString(timeFmt)}. AsUnordered children:");
OutputListToConsole(orderExample.GetImportantChildrenU
    nordered(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: {DateTime.Now
    .ToString(timeFmt)}. Sequential after Where 
        children:");
OutputListToConsole(orderExample.GetImportantChildren
    UnknownOrder(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: {DateTime.Now
    .ToString(timeFmt)}. AsOrdered children:");
OutputListToConsole(orderExample.GetImportantChildrenP
    reserveOrder(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: {DateTime.Now
    .ToString(timeFmt)}. Reverse order children:");
OutputListToConsole(orderExample.GetImportantChildrenR
    everseOrder(GetYoungPeople()).ToList());
Console.WriteLine($"Finish time: {DateTime.Now
    .ToString(timeFmt)}");
Console.ReadLine();</pre></li>
<li>Now, run the <a id="_idIndexMarker455"/>program and examine the output:</li>
</ol>
<div><div><img alt="Figure 8.3 – Comparing the order of items from five PLINQ queries " height="691" src="img/Figure_8.3_B18552.jpg" width="894"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Comparing the order of items from five PLINQ queries</p>
<p>You can see from <a id="_idIndexMarker456"/>the output that the order of items is only predictable in the last two examples where we have specified <code>AsOrdered()</code> and <code>AsOrdered().Reverse()</code>. The impact of the different PLINQ operations is difficult to measure on such a small dataset. If you run this several times, you are likely to see different results in the timing. Try adding larger datasets on your own to experiment with the performance.</p>
<p>Next, let’s discuss merging segments and test the different options in a sample.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Using WithMergeOptions in PLINQ queries</h2>
<p>When<a id="_idIndexMarker457"/> we discuss merging data in PLINQ, it is<a id="_idIndexMarker458"/> the merge that happens as each segment of an operation completes its actions, and the results are merged back into the result on the calling thread. Most of the time, you will not need to specify any merge options. For times when you may need to do so, it’s important to understand the behavior of each of the options. Let’s review each of the members of the <code>ParallelMergeOptions</code> enumeration.</p>
<h3>ParallelMergeOptions.NotBuffered</h3>
<p>Think <a id="_idIndexMarker459"/>of the <code>NotBuffered</code> option as streaming data. Each item is returned from the query immediately after it has finished processing. There are some PLINQ operations that cannot support this option and will ignore it. For instance, the <code>OrderBy</code> and <code>OrderByDescending</code> operations cannot return items until the sorting has completed on the merged data. These are always <code>FullyBuffered</code>. However, queries that use <code>AsOrdered</code> can use this option. Use this option if your application needs to consume items in a streaming manner.</p>
<h3>ParallelMergeOptions.AutoBuffered</h3>
<p>The <code>AutoBuffered</code> option<a id="_idIndexMarker460"/> returns sets of items as they are collected. The size of the item set and how frequently it is returned to clear the buffer are not configurable or known to your code. If you want to make your data available in this manner, this option may suit your needs. Once again, the <code>OrderBy</code> and <code>OrderByDescending</code> operations will not accept this option. This is the default for most PLINQ operations and is the fastest overall in most scenarios. The <code>AutoBuffered</code> option allows PLINQ the most flexibility to buffer items as necessary based on current system conditions.</p>
<h3>ParallelMergeOptions.FullyBuffered</h3>
<p>The <code>FullyBuffered</code> option<a id="_idIndexMarker461"/> will not make any results available until they have all been processed and buffered by the query. The option will take the longest to make the first item available, but many times, it is the fastest to provide the entire dataset.</p>
<h3>ParallelMergeOptions.Default</h3>
<p>There is<a id="_idIndexMarker462"/> also the <code>ParallelMergeOptions.Default</code> value, which will act the same as not calling <code>WithMergeOptions</code> at all. You should choose your merge option based on how the data needs to be consumed. If you have no strict requirements, it is usually best to not set merge options.</p>
<h3>WithMergeOptions in action</h3>
<p>Let’s create<a id="_idIndexMarker463"/> examples of using the same <code>Person</code> query with each merge option and with no merge options set at all:</p>
<ol>
<li value="1">Start by adding a <code>MergeSamples</code> class to the console application project you previously created. First, add the following three methods to test the types of merges:<pre>internal IEnumerable&lt;Person&gt; 
    GetImportantChildrenNoMergeSpecified(List&lt;Person&gt; 
        people)
{
    return people.AsParallel()
        .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 18)
            .Take(3);
}
internal IEnumerable&lt;Person&gt; GetImportantChildren
    DefaultMerge(List&lt;Person&gt; people)
{
    return people.AsParallel().WithMergeOptions
         (ParallelMergeOptions.Default)
             .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 
                 18).Take(3);
}
internal IEnumerable&lt;Person&gt; GetImportant
    ChildrenAutoBuffered(List&lt;Person&gt; people)
{
    return people.AsParallel().WithMergeOptions
       (ParallelMergeOptions.AutoBuffered).Where(p =&gt; 
           p.IsImportant &amp;&amp; p.Age &lt; 18).Take(3);
}</pre></li>
<li>Next, add<a id="_idIndexMarker464"/> the following two methods to the <code>MergeSamples</code> class:<pre>internal IEnumerable&lt;Person&gt; GetImportant
    ChildrenNotBuffered(List&lt;Person&gt; people)
{
    return people.AsParallel().WithMergeOptions
        (ParallelMergeOptions.NotBuffered)
            .Where(p =&gt; p.IsImportant &amp;&amp; p.Age &lt; 
                18).Take(3);
}
internal IEnumerable&lt;Person&gt; GetImportantChildren
    FullyBuffered(List&lt;Person&gt; people)
{
    return people.AsParallel().WithMergeOptions
       (ParallelMergeOptions.FullyBuffered).Where(p =&gt; 
           p.IsImportant &amp;&amp; p.Age &lt; 18).Take(3);
}</pre></li>
</ol>
<p>Each of the methods in the last two steps performs a PLINQ query that filters for <code>IsImportant</code> equal to <code>true</code> and <code>Age</code> less than <code>18</code>. It then performs a <code>Take(3)</code> operation to return only the first three items from the query.</p>
<ol>
<li value="3">Add code to <code>Program.cs</code> to call each method and output the timestamp before each call, as well as a final timestamp at the end. This is the same process we used when calling the methods to test ordering in the previous section:<pre>using LINQandPLINQsnippets;
var timeFmt = "hh:mm:ss.fff tt";
var mergeExample = new MergeSamples();
Console.WriteLine($"Start time: {DateTime.Now.ToString
    (timeFmt)}. NoMerge children:");
OutputListToConsole(mergeExample.GetImportantChildrenN
    oMergeSpecified(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: 
    {DateTime.Now.ToString(timeFmt)}. DefaultMerge 
        children:");
OutputListToConsole(mergeExample.GetImportantChildren
    DefaultMerge(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: {DateTime.Now.ToString
    (timeFmt)}. AutoBuffered children:");
OutputListToConsole(mergeExample.GetImportantChildren
   AutoBuffered(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: 
    {DateTime.Now.ToString(timeFmt)}. NotBuffered 
        children:");
OutputListToConsole(mergeExample.GetImportantChildren
    NotBuffered(GetYoungPeople()).ToList());
Console.WriteLine($"Start time: 
    {DateTime.Now.ToString(timeFmt)}. FullyBuffered 
        children:");
OutputListToConsole(mergeExample.GetImportantChildren
    FullyBuffered(GetYoungPeople()).ToList());
Console.WriteLine($"Finish time: {
        DateTime.Now.ToString(timeFmt)}");
Console.ReadLine();</pre></li>
<li>Now, run <a id="_idIndexMarker465"/>the program and examine the output:</li>
</ol>
<div><div><img alt="Figure 8.4 – Reviewing the output of the PLINQ merge options methods " height="573" src="img/Figure_8.4_B18552.jpg" width="890"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Reviewing the output of the PLINQ merge options methods</p>
<p>The first option with no merge option specified takes the longest to run, but often, the first time you run a PLINQ query, it will be slower than subsequent executions. The remaining queries are all very fast. You should test these queries on some large sets of data from your own databases and see how the timings differ for different PLINQ operators and different merge options. You can even take timings between the output of each item to see how quickly the first item is returned for <code>NotBuffered</code> versus <code>FullyBuffered</code>.</p>
<p>Before we review everything that we have learned in this chapter, let’s discuss a few .NET objects and data structures that complement parallel programming and PLINQ queries.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Data structures for parallel programming in .NET</h1>
<p>When <a id="_idIndexMarker466"/>working with parallel programming in .NET, and with PLINQ, you should take advantage of the data structures, types, and primitives that .NET provides. In this section, we will touch on concurrent collections and <strong class="bold">synchronization primitives</strong>.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Concurrent collections</h2>
<p>Concurrent collections are<a id="_idIndexMarker467"/> useful when working with parallel <a id="_idIndexMarker468"/>programming. We will cover them in great detail in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, but let’s quickly discuss how we can leverage them when working with PLINQ queries.</p>
<p>If you are simply selecting and sorting data with PLINQ, it is not necessary to incur the overhead that is added with the collections in the <code>System.Collections.Concurrent</code> namespace. However, if you are calling a method with <code>ForAll</code> that modifies items in your source data, you should use one of these current collections, such as <code>BlockingCollection&lt;T&gt;</code>, <code>ConcurrentBag&lt;T&gt;</code>, or <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>. They can also guard against any simultaneous <code>Add</code> or <code>Remove</code> operations on the collections.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Synchronization primitives</h2>
<p>If you are unable to introduce <a id="_idIndexMarker469"/>concurrent collections into your<a id="_idIndexMarker470"/> existing code base, another option to provide concurrency and performance is synchronization primitives. We covered many of these types in <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>. These types in the <code>System.Threading</code> namespace, including <code>Barrier</code>, <code>CountdownEvent</code>, <code>SemaphoreSlim</code>, <code>SpinLock</code>, and <code>SpinWait</code>, provide the right balance of thread safety and performance. Other locking mechanisms, such as <code>lock</code> and <code>Mutex</code>, can be more expensive to implement, causing a greater performance impact.</p>
<p>If we want to guard one of our PLINQ queries that uses <code>ForAll</code> with <code>SpinLock</code>, we can simply wrap the method in a <code>try</code>/<code>finally</code> block and use the <code>Enter</code> and <code>Exit</code> calls on <code>SpinLock</code>. Take<a id="_idIndexMarker471"/> this example where we were checking where a person had an age greater than <code>120</code>. Let’s<a id="_idIndexMarker472"/> imagine that the code also modifies the age:</p>
<pre class="source-code">private SpinLock _spinLock = new SpinLock();</pre>
<pre class="source-code">internal void ProcessAdultsWhoVoteWithPlinq2(List&lt;Person&gt; </pre>
<pre class="source-code">    people)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var adults = people.AsParallel().Where(p =&gt; p.Age &gt; 17);</pre>
<pre class="source-code">    adults.ForAll(ProcessVoterActions2);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private void ProcessVoterActions2(Person adult)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var hasLock = false;</pre>
<pre class="source-code">    if (adult.Age &gt; 120)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        try</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            _spinLock.Enter(hasLock);</pre>
<pre class="source-code">            adult.Age = 120;</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        finally</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            if (hasLock) _spinLock.Exit();</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>To read more about<a id="_idIndexMarker473"/> synchronization primitives, check out this section in Microsoft Docs: <a href="https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives">https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives</a>.</p>
<p>Now, let’s wrap up by reviewing what we have learned in this chapter on parallel programming and PLINQ.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Summary</h1>
<p>In this chapter, we learned about the power of PLINQ to introduce parallel processing to our LINQ queries. We started by looking at how PLINQ differs from standard LINQ queries. Next, we explored how to introduce PLINQ into existing code by converting some standard LINQ queries. It is important to understand how PLINQ is impacting the performance of your applications, and we examined some timings in our sample applications. (Later, in <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>, we will discuss some tools to test your application performance while testing it locally.) We covered some optimizations you can make to your queries with merge options and data ordering. Finally, we wrapped up by touching on some other .NET data structures and types to help provide type safety and performance to your applications. </p>
<p>In the next chapter, we will explore each of the concurrent collections in the <code>System.Collections.Concurrent</code> namespace in depth. The concurrent collections are key to ensuring that your parallel and concurrent code maintains type safety when operating on shared data.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Questions</h1>
<ol>
<li value="1">Which PLINQ method signals that the query should start processing in parallel?</li>
<li>Which PLINQ method signals that the query should not process in parallel any longer?</li>
<li>Which method tells PLINQ to preserve the original order of the source data?</li>
<li>Which PLINQ method will execute a delegate in parallel on each item in the query?</li>
<li>What performance impact does <code>AsOrdered()</code> have on a PLINQ query?</li>
<li>Which PLINQ operations cannot be used with <code>ParallelMergeOptions.NotBuffered</code>?</li>
<li>Is PLINQ always faster than an equivalent LINQ query?</li>
<li>Which PLINQ merge option would you select if you want results to stream back from the query as they become available?</li>
</ol>
</div>
</div>
</body></html>