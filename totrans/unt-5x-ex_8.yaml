- en: Chapter 8. Continuing with Intelligent Enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This last chapter continues with the previous one and completes the AI project
    by focusing on the theory and related coding underpinning an intelligent enemy.
    The enemy will demonstrate three main behaviors: patrolling, chasing, and attacking.
    In this chapter, we will dive into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to plan and code an AI system for enemy characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to code Finite State Machines (FSMs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create the line-of-sight functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting project and assets can be found in the book companion files in
    the `Chapter08/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enemy AI – range of sight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now start developing enemy AI by thinking about our functional requirements.
    The enemies in the scene will begin in patrol mode, wandering the level from place
    to place searching for the player character. If the player is spotted, the enemy
    will change from patrolling and begin chasing the player, attempting to move closer
    to them for an attack. If the enemy reaches within attacking range of the player,
    the enemy will change from chasing to attacking. If the player outruns the enemy
    and successfully loses them, the enemy should stop chasing and return to patrolling
    again, searching for the player as they were doing initially. This, in sum, describes
    our needed enemy AI behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this behavior, we'll need to code the line of sight functionality
    for the enemy. The enemy relies on being able to see the player character or determining
    whether the player is visible to the enemy at any one moment. This helps the enemy
    decide whether they should patrol or chase the player character. To code this,
    refer to the following code from the source file, `LineSight.cs`. This script
    file should be attached to the enemy character created so far from the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 8.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `LineSight` class should be attached to any enemy character object. Its
    purpose is to calculate whether a direct line of sight is available between the
    player and enemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CanSeeTarget` variable is a Boolean (`True`/`False`), which is updated
    on a per frame basis to describe whether the enemy can see the player *right now*
    (for this frame). `True` means that the player is in sight of the enemy, and `false`
    means that the player is not visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FieldOfView` variable is a floating point value that determines an angular
    margin on either side of the enemy eye-point, inside which objects (like the player)
    can be seen. The higher this value, the more chance the enemy has of seeing the
    player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InFOV` function returns `true` or `false` to indicate whether the player
    is within the enemy field of view. This ignores whether the player is occluded
    behind a wall or solid object (like a pillar). It simply takes the position of
    the enemy eyes, determines a vector to the player, and measures the angle between
    the forward vector and player. It compares this to the field of view, and returns
    `true` if the angle between enemy and player is less than the `FieldOfView` variable.
    In short, this function can tell you whether the enemy would see the player if
    there were a clear line of sight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ClearLineOfSight` function returns `true` or `false` to indicate whether
    there are any physical obstacles (Colliders), such as walls or props, between
    the enemy eye point and player. This does not consider whether the player is within
    the enemy field of view. This function, in combination with the `InFOV` function,
    can determine whether the enemy has a clear line of sight to the player and is
    within the field of view, and thus, whether the player is visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnTriggerStay` and `OnTriggerExit` functions are called when the player
    is within a trigger volume surrounding the enemy and when the player leaves this
    volume respectively. As we'll see, a sphere collider can be attached to the enemy
    character object to represent its horizon of view. This means the total distance,
    or radius, inside which the enemy could see the player, provided they were within
    the field of view and a clear line of sight existed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, attach the `LineSight.cs` script file to the enemy character in the scene
    as well as a Sphere Collider component (marked as a Trigger) to approximate the
    viewing horizon of the enemy. See *Figure 8.1*. Leave the **Field of View** setting
    at `45`, although this can be increased, if needed, to around `90` to tweak the
    effectiveness of the enemy viewing range.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.1](img/B05118_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Adding a horizon to the NPC'
  prefs: []
  type: TYPE_NORMAL
- en: The **Eye Point** field is, by default, set to **None**, which represents a
    null value. This should refer to a specific location on the enemy character that
    acts as the eye point—the place from which the character can see. To create this
    point, add a new and empty game object to the scene using the application menu,
    **GameObject** | **Create Empty**. Name the object `Eye Point`, activate its visibility
    from the **Inspector** using a Gizmo icon (so that it can be visible even when
    deselected), and then add it as a child object to the enemy. Afterward, position
    the object to the character eye point, making sure that the forward vector is
    facing in the same direction. See *Figure 8.2:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.1](img/B05118_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Adding an EyePoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag and drop the Eye Point object from the **Hierarchy** panel to the
    **Eye Point** field for the LineSight component in the **Inspector**. This specifies
    the Eye Point object as the eye point for the enemy character. This will be used
    in determining whether the enemy can see the player. Having a separate eye point
    object like this is useful as opposed to using the character position, which is
    typically at the feet location and not the eye. See *Figure 8.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.1](img/B05118_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Defining the eye point for an NPC'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `LineSight` script determines the player location by first finding
    the player object in the scene using the **Player** tag. Consequently, make sure
    that the **Player** is tagged or labeled using the **Player** tag. See *Figure
    8.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.1](img/B05118_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Tagging the player object'
  prefs: []
  type: TYPE_NORMAL
- en: Now take your game for a test run. When you approach the NPC object, the **Can
    See Target** field will be enabled. See *Figure 8.5*. Good work! The line of sight
    functionality is now completed. Let's move on!
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.1](img/B05118_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Testing the line of sight functionality'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Finite State Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the AI for an NPC object, in addition to the line of sight code that
    we already have, we need to use **Finite State Machines** (**FSMs**). An FSM is
    not a *thing* or feature of Unity, nor is it a tangible aspect of the C# language.
    Rather, an FSM is a concept, framework, or idea that we can apply in code to achieve
    specific AI behaviors. It comes from a specific way of thinking about intelligent
    characters. Specifically, we can summarize the NPC for our level as existing within
    one of three possible states at any one time. These are patrol (when the enemy
    is wandering around), chase (when the enemy is running after the player), and
    attack (when the enemy has reached the player and is attacking). Each of these
    modes is a State and requires a unique and specific behavior and the enemy can
    be in only one of these three states at any one time. The enemy cannot, for example,
    be patrolling and chasing simultaneously or patrolling and attacking, because
    this wouldn't make sense within the logic of the world and game.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the states themselves, there is a rule set or group of connections
    between the states that determines when one state should change or move into another.
    For example, an NPC should only move from patrolling to chasing if they can see
    the player and they are not already attacking. Similarly, the NPC should only
    move from attacking to patrolling if they cannot see the player and they are not
    already patrolling or chasing. Thus, the combination of the States and rules governing
    their connections form a Finite State Machine. Consequently, any implementation
    in code that represents this behavior functionally is an FSM. There is no right
    or wrong way to code an FSM per se. There are simply different ways, some of which
    are better or worse for particular ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll code the FSM using Coroutines. Let''s start by creating
    the main structure. Refer to the following code in the file, `AI_Enemy.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on Coroutines can be found at the online Unity documentation
    at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  prefs: []
  type: TYPE_NORMAL
- en: Code Sample 8.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AI_Enemy` class created so far does not represent the full and complete
    FSM but just the skeleton for its beginning. It illustrates the general structure.
    It features a single coroutine for each state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CurrentState` variable defines a property that selects the active state,
    terminating all existing coroutines and initiating the relevant one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each state coroutine will run on a frame-safe infinite loop for as long as the
    state is active, allowing the enemy object to update its behavior, as we'll see
    shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before proceeding, make sure that the `AI_Enemy` script is attached to the
    NPC object. See *Figure 8.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.2](img/B05118_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Attaching the AI script to the NPC character'
  prefs: []
  type: TYPE_NORMAL
- en: The Patrol state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first of the three states to implement for the NPC AI is the Patrol State.
    In the previous chapter, we configured an animated patrol object, which the NPC
    should follow continuously during this state. The patrol object moves around the
    level from a predefined animation asset, changing from one position to the next.
    However, previously, the NPC simply followed this object without end, whereas
    the Patrol State requires the NPC to consider whether the player can be seen on
    its route. If it can, the state should change. To support this functionality,
    the Patrol State and Start function of the `AI_Enemy` class has been coded, as
    featured in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 8.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Start` function sets the initial state of the enemy character to Patrol.
    The coroutine AIPatrol handles this state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AIPatrol coroutine loops infinitely for as long as the `Patrol` state is
    active. Remember that an infinite loop is not necessarily a bad thing when used
    in a coroutine and in combination with a yield statement. This allows prolonged
    behaviors to be coded neatly and easily over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SetDestination` function is called to send `NavMeshAgent` to the specified
    destination. This is followed by a `pathPending` check, which is a variable of
    the `NavMeshAgent`. This check waits until the `pathPending` variable is false,
    indicating that a full traversable path has been calculated from the source to
    the destination. For short and simple journeys, a path may be calculated almost
    immediately, but for paths that are more complex, this can take much longer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the Patrol state, we constantly check the `LineSight` component to determine
    whether the enemy has a direct line of sight to the player. If so, the enemy changes
    from the `Patrol` state to the `Chase` state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the yield return null statement will pause a coroutine until the
    next frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, drag and drop the `AIEnemy` script to the NPC character in the scene,
    if you haven''t already. The `Patrol` mode is configured to track a moving object,
    that is, the enemy will follow a moving destination. A moving destination was
    created in the previous chapter using the **Animation** window to move an object
    around the scene over time, jumping from one place to another. See *Figure 8.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.3](img/B05118_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Creating movable objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve movable objects, create one or more destination object in the scene
    and assign them a **Dest** tag. Remember that the `start` function for `AIEnemy`
    searches the scene for all objects tagged as **Dest** and it uses these as destination
    points. See *Figure 8.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.3](img/B05118_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Tagging destination objects'
  prefs: []
  type: TYPE_NORMAL
- en: The Chase state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Chase state is the second of the three in the enemy FSM. This state connects
    to both the Patrol and Attack states directly. It can be reached in one of two
    ways. If a patrolling NPC establishes a direct line of sight to the player, then
    the NPC changes from patrolling to chasing. Conversely, if an attacking NPC falls
    outside the reach of the player (perhaps because he is running away), the NPC
    resorts to chasing again. From the chasing state itself, it''s possible to move
    either to the Patrol or Attack state, with the inverse conditions as those, which
    lead to chase. That is, if the NPC loses sight of the player, it returns to patrolling
    and, if the NPC reaches within attacking distance of the player, it switches to
    attacking. Consider the following code sample, which amends the `AIEnemy` class
    to support the chase behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 8.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AIChase` coroutine is started when the Chase state is entered and, like
    the Patrol state, it repeats on a frame-safe infinite loop for as long as the
    state is active.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remainingDistance` member variable of the `NavMeshAgent` is used to determine
    whether the NPC has reached within attacking distance of the player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CanSeeTarget` Boolean variable of the `LineSight` class indicates whether
    the player is visible and is influential in choosing whether the NPC should return
    to patrolling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excellent work! Now give the code a test run in the editor and you have an enemy
    character than can patrol and chase. Splendid!
  prefs: []
  type: TYPE_NORMAL
- en: The Attack state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third and final state for the NPC is the Attack state, during which the
    NPC is continually attacking the player. This state can only be reached from the
    Chase state. During a chase, the NPC must determine whether they have reached
    within attacking distance. If so, the NPC must change from chasing to attacking.
    If, during an attack, the player leaves the attacking distance, then the NPC must
    change from attacking to chasing. Consider the following code sample, which includes
    the complete `EnemyAI` class, with all coded and completed states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 8.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AIAttack` coroutine runs on a frame-safe infinite loop for as long as the
    Attack state is active (the enemy will be attacking during this state).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MaxDamage` variable specifies how much damage the enemy deals to the player
    per second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AIAttack` coroutine relies on the `Health` component to inflict damage.
    This is an additional custom component that encodes health. Both the player and
    enemy should have a health component to represent their health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Health script (`Health.cs`) is referenced by the `AIEnemy` class (the Attack
    State) to inflict damage on the player. For this reason, the player character
    needs a `Health` component attached. The code for this component is included in
    the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Health` script is pretty simple. It maintains a numerical health value
    that, when reduced to `0` or below, will destroy the host game object. This should
    at least be attached to the player character, allowing the NPC to inflict damage
    on approach. It could, however, also be attached to the NPC objects, allowing
    the player to reciprocate an attack. See *Figure 8.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.5](img/B05118_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Configuring player health'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we''re almost ready to test this project. First, make a prefab from
    the enemy object, if you''ve not already done so, by dragging and dropping the
    NPC game object from either the **Scene** view or **Hierarchy** panel to the **Project**
    panel. Then, add as many enemies as you want to the level. See *Figure 8.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.5](img/B05118_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Creating an NPC prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test the level by pressing the play icon on the toolbar and you should
    have a complete environment in which intelligent enemies can seek, chase, and
    attack the player with a significant degree of believability. In some cases, you
    may need to tweak or refine the enemy FOV to better match your surroundings and
    character type. Good work! See *Figure 8.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 8.5](img/B05118_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The completed level'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excellent! You've now reached the end of the AI project as well as the end of
    the book. In completing this project, you've assembled a complete terrain, an
    NPC prefab, and a series of scripts that work together strategically to create
    the appearance of intelligence, and this is *good enough* for AI. For games, AI
    refers to nothing more than *intelligent-looking* objects and the techniques that
    create them. Great! Furthermore, in reaching the end of this book and completing
    all four projects, you are now equipped with a varied and critically important
    skillset to develop professional-grade games in both 2D and 3D.
  prefs: []
  type: TYPE_NORMAL
