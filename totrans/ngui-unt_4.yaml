- en: Chapter 4. C# with NGUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about C# scripting with NGUI. We will learn how
    to handle events and interact with them. We''ll use them to:'
  prefs: []
  type: TYPE_NORMAL
- en: Play animations and Tweens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change labels using localized text through code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add keyboard keys for our UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create notifications and tool tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also see some of the NGUI's code-oriented components, such as event
    forwarding and message sending.
  prefs: []
  type: TYPE_NORMAL
- en: Events methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using C# with NGUI, there are some methods that you will regularly use
    when you need to know if your object is currently hovered upon, pressed, or clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attach a script to any object with a collider on it (for example, a
    button or a 3D object), you can add the following useful methods in the script
    to catch events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnHover(bool state)`: This method is called when the object is hovered or
    unhovered. The `state` bool gives the hover state; if `state` is `true`, the cursor
    just entered the object''s collider. If `state` is `false`, the cursor has just
    left the collider''s bounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPress(bool state)`: This method works in the exact same way as the previous
    `OnHover()` method, except it is called when the object is pressed. It works with
    a touch or click. If you need to know which mouse button was used to press the
    object, use the `UICamera.currentTouchID` variable; if this int is equal to -1,
    it''s a left-click. If it''s equal to -2, it''s a right-click. Finally, if it''s
    equal to -3, it''s a middle-click.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnClick()`: This method is similar to `OnPress()`, except that this method
    is exclusively called when the click is validated, meaning when an `OnPress(true)`
    event occurs followed by an `OnPress(false)` event. It works with mouse click
    and touch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `OnDoubleClick()` method, which works in the same way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnDrag(Vector2 delta)`: This method is called at each frame when the mouse
    or touch moves between the `OnPress(true)` and `OnPress(false)` events. The `Vector2`
    `delta` argument gives you the object''s movement since the last frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDrop(GameObject droppedObj)`: This method is called when an object is dropped
    on the GameObject on which this script is attached. The dropped GameObject is
    passed as the `droppedObj` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSelect()`: This method is called when the user clicks on the object. It
    will not be called again until another object is clicked on or the object is deselected
    (click on nothing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnInput(string text)`: This method is called when the user types in text while
    an object is selected. The `text` parameter gives the entered text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTooltip(bool state)`: This method is called when the cursor is over the
    object for more than the duration defined by the **Tooltip Delay** inspector parameter
    of **UICamera**. If the **Sticky Tooltip** Boolean of **UICamera** is checked,
    the tool tip will remain visible until the cursor moves outside the Collider''s
    Bounds, otherwise the tool tip disappears as soon as the cursor moves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnScroll(float delta)`: This method is called when the mouse''s scroll wheel
    is moved while the object is hovered—the delta parameter gives you the amount
    and direction of the scroll.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnKey(KeyCode key)`: This method is called when the user clicks on a key while
    the object is selected. The pressed key is stored in the `key` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you attach your script on a 3D object to catch these events, make sure it
    is on a layer included in `Event` `Mask` of `UICamera`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tool tip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now use the `OnTooltip()` event to show a tool tip for our powers, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a tool tip](img/8667OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will also make sure it is localized using methods integrated with NGUI.
  prefs: []
  type: TYPE_NORMAL
- en: The tool tip reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will create our tool tip that will be shown when needed. These are
    the steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select and duplicate our **Help** GameObject with *Ctrl* + *D*. Then perform
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this new duplicate as `Tooltip`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Depth** in **UIPanel** to `4`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Clipping** in **UIPanel** to **None**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its **Box Collider** component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its **UIDrag** `Object` component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its **UIAnchor** component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select our new **Background**, which is a child GameObject of **Tooltip**.
    Then perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Depth** value to `0`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Pivot** parameter to **Top Left** (left arrow + up arrow).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Dimensions** to `200` x `50`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Label**, which is a child GameObject of **Tooltip**. Then perform
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Depth**to `1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its text to `This is a Tooltip`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its **Overflow** parameter to **Resize Height**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its **Tween Position** component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its **UILocalize** component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Pivot** parameter to **Top Left** (left arrow + up arrow).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Transform** position to {`15`, `-15`, `0`}.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Dimensions** parameter to `200` x `20`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select our **Tooltip** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach a **Tooltip** to the selected object by navigating to **Component**
    | **NGUI** | **UI** and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Label** GameObject from **Tooltip** to its **Text** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Window** GameObject from **Tooltip** to its **Background** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ok. Our tool tip is ready to be displayed. The fact that we have set the **Pivot**
    parameter of **Label** under **Tooltip** to **Top left**, with a position of {`15`,
    `-15`, `0`}, will force a margin between the text and the background sprite.
  prefs: []
  type: TYPE_NORMAL
- en: The **Overflow** parameter will let the text be resized in height only, which
    will make our tool tip coherent even if we have a long tool tip—the **Background**
    sprite will automatically resize to fit the **Label** GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the tool tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must now show the tool tip when needed. In order to do that, we just need
    to use the `OnTooltip()` event, in which we will create a new tool tip with localized
    text.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** view, select both our **Time** and **Bomb** prefabs and create
    and add a new `TooltipManager.cs` C# script to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now open this new `TooltipManager.cs` script and declare the following
    enum, which will define which type of tool tip it must display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, now add the following `OnTooltip()` method that will create a tool tip
    with localized text depending on its current type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Save the script. As you can see, we use a useful `Localization.instance.Get(string
    key)` method that returns localized text of the corresponding `key` parameter
    that is passed. You can now change a label to localized text through code anytime!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use `Localization.instance.Get(string key)`, your label must not have a **UILocalize**
    component attached to it; otherwise, the value of **UILocalize** will overwrite
    anything you assign to the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, we have added the code to show our tool tip with localized text. Now we
    have to add these localized strings to the `English.txt` file using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, add the following lines in the `French.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save these files and go back to Unity to assign the **TooltipManager** type''s
    variables by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** view, select our **Bomb** prefab and set its **Type** field
    in **TooltipManager** to `Bomb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** view, select our **Time** prefab and set its **Type** field
    in **TooltipManager** to **Time**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the play button. When you leave your cursor on the **Bomb** or **Time**
    power in the **Available powers** slot, our localized tool tip appears! I actually
    have the feeling that the delay is too long. Let's correct this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select our **Camera** GameObject from **UI Root (2D)** and set its **Tooltip
    Delay** value in **UICamera** to `0.3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's better—our localized tool tip appears within 0.3 seconds of hovering.
  prefs: []
  type: TYPE_NORMAL
- en: Tween methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can see all available Tweens by simply typing in `Tween` inside any method
    in your favorite IDE. You will see a list of `Tween` classes thanks to autocompletion,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tween methods](img/8667OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The strong point of these classes is that they work in one line and don't have
    to be executed for each frame; you just have to call their `Begin()` method!
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will apply Tweens on widgets since we only have that in the scene.
    But keep in mind that it works in the exact same way with other GameObjects since
    NGUI widgets are GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: Main menu apparition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use the `TweenPosition` class to make our main menu appear from the top
    of the screen on start. We will first use a simple Tween in only one line and
    then we will add an easing effect with a delay to make it nicer.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Tween
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add a **Tween Position** component to our **Container** GameObject in
    **MainMenu**, but we need to see how we create a **Tween** in code. The following
    is how we do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our **Container** GameObject from **MainMenu** and create and add a new
    `AppearFromAbove.cs` C# script to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open this new `AppearFromAbove.cs` script and edit the `Start()` method
    so that it first sets the `position` value in `Container` to a higher value than
    the screen''s height. Then Tween it back to {`0`, `0`, `0`} in 1 second as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the play button. We now have our main menu coming down from the top
    of the screen with only two lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: Smooth Tween
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We created a simple Tween, but you can also configure your Tween to add a smoothing
    method and a delay, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it now by replacing our `Start()` method''s code with the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the play button. We have added a nice `EaseInOut` method to our Tween.
    The menu''s vertical movement is now smoother, and all of this has been added
    through code. The following is a list of the different Tween methods that can
    add effects to Tweens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Linear`: This will create a simple linear tween—no smoothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EaseIn`: This will make the tween smooth during the beginning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EaseOut`: This will make the tween smooth during the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EaseInOut`: This will make the tween smooth both at the beginning and at the
    end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BounceIn`: This will give the tween bounce effect at the beginning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BounceOut`: This will give the tween bounce effect at the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know how to use the `TweenPosition` class, you are capable of using
    other Tweens such as TweenScale, TweenRotation, TweenColor or any other available
    Tween, because they work the same way!
  prefs: []
  type: TYPE_NORMAL
- en: Using keys for navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UI we have created works with the mouse. We can easily add key navigation
    for keyboard and controllers. A **UIButton Keys** component exists for that purpose.
    You have to add it to any UI element you want to be accessible with keys (the
    default **Inspector** window is as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using keys for navigation](img/8667OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try it now with our **Play**, **Exit**, and **Options** buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our **Exit**, **Options**, and **Play** GameObjects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a **Button Keys** component to them by navigating to **Component** |
    **NGUI** | **Interaction**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pop up will appear, as shown in the following screenshot, asking you if you
    want to replace or add a collider:![Using keys for navigation](img/8667OT_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's because they already have a **Box Collider** component. Click on **Replace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Play** button and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check its **Starts Selected** Boolean.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Exit** button into the **Selected On Left** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Exit** button into the **Selected On Right** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Options** button into the **Selected On Down** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Exit** button and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Play** button into the **Selected On Left** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Play** button into the **Selected On Right** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Options** button into the **Selected On Down** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Options** button and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Exit** button into the **Selected On Left** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Play** button into the **Selected On Right** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Play** button into the **Selected On Up** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on play. Our **Play** button is selected by default, and if you use your
    keyboard arrows, you will be able to navigate through those three buttons and
    validate with *Return*.
  prefs: []
  type: TYPE_NORMAL
- en: Error notification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want the user to enter a nickname in the input field and select a power before
    he or she can launch the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the user can launch the game regardless of the input and selected
    power value. Let''s correct this by preventing the game''s launch and notifying
    the user, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error notification](img/8667OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use a TweenScale through code that will gradually scale up the notification
    from {0, 0, 0} to {1, 1, 1} by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our **Tooltip** GameObject in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate it with *Ctrl* + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename this new duplicate as `Notification` and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Depth** parameter in **UIPanel** to 5.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its **UITooltip** component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Transform** position to {`0`, `-355`, `0`}.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select our **Label** GameObject in `Notification` and perform the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its text to `This is a Notification`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Overflow** parameter to **Shrink Content**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Pivot** parameter to **Center** (middle button + middle button).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Dimensions** to `550` x `80`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a **Localize** component to it by navigating to **Component** | **NGUI**
    | **UI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select our **Background** GameObject in `Notification` and perform the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Pivot** parameter to **Center** (middle button + middle button).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Dimensions** parameters to `600` x `100`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select our **Notification** GameObject and set its **Transform** scale to {`0`,
    `0`, `1`}.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and attach a new `NotificationManager.cs` C# script to it and open this
    new `NotificationManager.cs` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ok. We have our **Notification** GameObject ready with a scale of {`0`, `0`,
    `1`}. Let's use the new `NotificationManager.cs` script to launch a TweenScale
    through code when the **Notification** GameObject is activated.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an enum to define which notification type will be displayed. This
    time, we will use the **UILocalize** component for localized text and change the
    `key` parameter through code instead of using the `Localization.instance.Get()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, declare these variables in the `NotificationManager.cs` script as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Save the script. We will stock the instance of `NotificationManager` on the
    scene in the script to be able to access it from any other script easily.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's assign our `Loc` variable using the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: Select our **Notification** GameObject and drag our **Label** GameObject in
    **Notification** in to the **Loc** field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, now return to our `NotificationManager.cs` script. We will first create
    an `Awake()` method with our static instance variable''s initialization and disable
    our **Notification** GameObject to make it invisible when the game starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our `Awake()` method is written, let''s create an `OnEnable()` method
    that will declare the `TweenScale` object and set the corresponding `key` parameter
    for the `UILocalize` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget that if you change a `key` parameter when the **UILocalize** component
    is already active, you must call its `Localize()` method to update it.
  prefs: []
  type: TYPE_NORMAL
- en: Good. Click on the play button. Activate our **Notification** GameObject while
    Unity is running the play mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that our **Notification** GameObject appears smoothly. Let''s add
    a `Show()` method to display it through code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous method shows our notification by activating its corresponding GameObject.
    The `OnEnable()` method will perform the tween and localization.
  prefs: []
  type: TYPE_NORMAL
- en: 'On its last line, the `Show()` method starts the `Remove()` coroutine. Let''s
    add the following `Remove()` coroutine that will make the notification disappear
    after a given duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Great. Now we can add the right localization strings in `English.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add the correct strings in `French.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can now call our `Show()` method if the player presses the play button with
    no nickname entered, or if he or she does not select a power.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we will remove the current **Load Level On Click** component
    from our **Play** button and attach a new `LaunchValidator.cs` script to it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our `Play` button GameObject and remove its **Load Level On Click** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and attach a new `LaunchValidator.cs` C# script to it and open this new
    `LaunchValidator.cs` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this new script, we will need our nickname''s **UIInput** component. Let''s
    declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Save the script. Let's assign this variable right now in the **Inspector** window.
    Then select our **Play** GameObject and drag our **Input** GameObject from **Nickname**
    in the **Nickname Input** field in its **Launch Validator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to our `LaunchValidator.cs` script. We will now add an `OnClick()`
    method to add a nickname and power validation before we actually load the game,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Click on the play button. Perfect, we now have notifications that prevent the
    game from launching if the user has no nickname entered or has no power selected!
  prefs: []
  type: TYPE_NORMAL
- en: Saving the nickname
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Creating Widgets"), *Creating Widgets*,
    we entered `Nickname` in the **Auto-save Key** parameter of the nickname''s **UIInput**
    component. It works like this: if the user enters a nickname and presses *Return*,
    the input''s label `string` value is saved in the `PlayerPrefs()` method in the
    `Nickname` key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the issue: the nickname is saved if, and only if, the user presses
    *Return*. That''s a problem—most of the users will enter a name and select their
    power directly without pressing *Return*—I''m sure you''ve done it yourself too.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to save the string in the `PlayerPrefs()` method even when the user
    clicks on the **Play** button without pressing *Return*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must add a line at the end of the `OnClick()` method of our `LaunchValidator.cs`
    script, which will save the nickname''s input `value` before the game scene is
    loaded. Just before the `Application.LoadLevel("Game")` line, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now the user's nickname is saved before launching the game, no matter what!
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Notify` parameter in the **Inspector** window we used in previous chapters
    to call methods on a precise event is usually enough for sending messages. However,
    you may need to send a message to another GameObject and maybe to its children
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s where the **UIButton Message** component comes in handy. We will use
    this to make our **MainMenu** GameObject scale down before the game actually quits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select our **Exit** GameObject and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a **Button Message** component to it by navigating to **Component** |
    **NGUI** | **Interaction**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Container** GameObject from `MainMenu` into its **Target** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `CloseMenu` in the **Function Name** parameter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select our **Container** GameObject in **MainMenu** and open its attached `AppearFromAbove.cs`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this script, add a simple `CloseMenu()` method containing the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to delay the execution of the `Application.Quit()` method, otherwise
    we won''t see our **Tween**. We do this using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select our **GameManager** GameObject and perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open its attached `GameManager.cs` script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the line in the `ExitPressed()` method with the following line:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new `QuitNow()` method to actually exit the application as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and click on the play button. When you exit the application,
    our **Menu** will automatically disappear. That's because the `Invoke()` method
    enables us to call a function with `delay` as the second parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s add this nice scaling effect also when the player launches the game
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our **Play** button GameObject and open its attached `LaunchValidator.cs`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need our **Container** GameObject from **MainMenu**. Declare it as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to Unity and assign this new **menuContainer** variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select our **Play** button GameObject and drag our **Container** GameObject
    from **MainMenu** to its **MenuContainer** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to our `LaunchValidator.cs` script. We simply have to replace the `Application.LoadLevel("Game")`
    line with the following lines:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Ok, now we can add a new `LaunchNow()` method to actually launch the game scene
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great, on exit or game launch, the menu scales out, which makes a nicer transition.
    We have also learned how to use a **UIButton Message** component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We didn't need the **Include Children** Boolean checked. But it's interesting
    to note that you can send a message to the target and all its children at once.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another component may be useful in some cases: **UIForward Events**. This component
    gives you the ability to send the events of the GameObject it''s attached to to
    another GameObject in the scene. It can be useful, for example, to create a multiple
    selection. Let''s try it to make it more clear. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our **Bomb** GameObject in **Grid**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach a **Forward Events** component to it by navigating to **Component**
    | **NGUI** | **Interaction** and then perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag our **Time** GameObject from **Grid** to the `Target` field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **OnHover** Boolean.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **OnPress** Boolean.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **OnDrag** Boolean.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the play button. If you hover, press, and drag the **Bomb** power,
    the **Time** power will also react the same way! That is what event forwarding
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you see how it works, you can remove the **UIForward Events** component
    from our **Bomb** GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used C# with NGUI to create localized tool tips and error
    notifications. We learned how to use Tween classes to make our main menu appear
    and disappear smoothly with methods that ease Tweens.
  prefs: []
  type: TYPE_NORMAL
- en: We also know how to use keys for navigation in our UI, and our nickname is now
    saved when the game launches. You now know how to send messages and forward events
    using NGUI components, which may be useful to you in the future.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to create a new `Game.unity` scene and build a complete scrollable
    viewport, which is the subject of [Chapter 5](ch05.html "Chapter 5. Building a
    Scrollable Viewport"), *Building a Scrollable Viewport*.
  prefs: []
  type: TYPE_NORMAL
