<html><head></head><body>
        

                            
                    <h1 class="header-title">Optimizing for Performance and Comfort</h1>
                
            
            
                
<p class="calibre3">As we've mentioned throughout these chapters, the success of your VR app will be negatively impacted by any discomfort your users feel. It is a fact that VR can cause motion sickness. </p>
<p class="calibre3">The symptoms of motion sickness are nausea, sweating, headaches, even vomiting. It can take hours, perhaps an overnight sleep, to recover. In real life, humans are susceptible to motion sickness: riding a roller coaster, a bumpy airplane, a rocking boat. It's caused when one part of the balance-sensing system thinks your body is moving but other parts don't.</p>
<p class="calibre3">In VR, this could occur when the eyes see motion but your body doesn't sense it. We've considered ways you can design your VR apps to avoid this. With locomotion, always give the user control over their first person movement. Try to avoid riding-the-rails experiences and especially avoid free-falling. Include using a horizon line or dashboard in the foreground so at least the player feels they're grounded in a cockpit if not on solid ground. </p>
<p class="calibre3">The opposite is also true: when you body feels motion but your eyes don't see it.  Even very subtle discord can have a bad effect. In VR, a major culprit is latency. If you move your head but the view you see doesn't keep up with the movement, that can cause nausea. </p>
<p class="calibre3">Although this chapter is at the end of this book, we do not mean to suggest that performance issues be left for the end of your project implementation. The old adage "first get it to work, then get it to work faster" doesn't necessarily apply to VR development. You need to pay attention to performance and comfort throughout your development process, which we will address as the main topics in this chapter:</p>
<ul class="calibre11">
<li class="calibre12">Optimizing your artwork and 3D models</li>
<li class="calibre12">Optimizing your scene and lighting</li>
<li class="calibre12">Optimizing your code</li>
<li class="calibre12">Optimizing the rendering with shaders and settings</li>
</ul>
<p class="calibre3">Key tools in analyzing and diagnosing performance issues are the built-in Unity Profiler and Stats windows. We will start with a quick introduction to these.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Unity Profiler and Stats</h1>
                
            
            
                
<p class="calibre3">Optimizing can be a lot of work, and there is a learning curve to get the hang of it. The good news is that it can be accomplished incrementally. Tackle the more obvious, bigger bang-for-the-buck things first. You can accomplish a lot with little or no visual degradation after a bit of experimentation.</p>
<p class="calibre3">The Unity Editor includes two built-in tools to assess performance: the Stats window and the Profiler window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Stats window</h1>
                
            
            
                
<p class="calibre3">The Stats window shows real-time rendering statistics when you press Play in the Unity Editor. Reviewing and understanding these statistics is your first line in evaluating and improving the performance of your app, and can help you decide which optimization strategies, including those covered in this chapter, to tackle first.</p>
<p class="calibre3">In the Game window, enable Stats by pressing the Stats button. A screenshot is shown here:</p>
<div><img class="image-border21" src="img/8472ef1b-22cf-4eed-8592-8332d6ed18ae.png"/></div>
<p class="calibre3">The actual statistics displayed will vary depending on your current build target (see <a href="http://docs.unity3d.com/Manual/RenderingStatistics.html" class="calibre10">http://docs.unity3d.com/Manual/RenderingStatistics.html</a>), including:</p>
<ul class="calibre11">
<li class="calibre12">Graphics FPS (frames per seconds) and time per frame</li>
<li class="calibre12">CPU time per frame</li>
<li class="calibre12">Tris (triangles)/Verts (vertices)</li>
<li class="calibre12">Batches</li>
</ul>
<p class="calibre3">In VR, you want to pay close attention to the frames per second. The minimum acceptable rate varies depending on your target device, but generally for desktop devices you should keep it at or above 90 FPS, while 60 FPS (or 75 FPS) is considered an absolute minimum. The Sony PlayStation VR accepts 60 FPS but uses hardware to automatically double the rate to 120 FPS to compensate. Windows Mixed Reality HMD will throttle the frame rate between 90 and 60 depending on the graphics processor hardware on your computer, allowing laptops with slower mobile GPU to run VR. Phone-based mobile VR devices can target 60 FPS.</p>
<p>When in Editor Play mode, the FPS is not necessarily the same as you'd experience running a built executable in your device, so it should be used as an indicator, not necessarily an actual value. But, thankfully, it does not include any editor-only processing such as drawing the Scene view.</p>
<p class="calibre3">Examining the CPU time per frame and comparing that with the overall graphics time per frame will tell you whether your game is CPU bound or GPU bound. That is, which process is the bottleneck, slowing you down the most. The CPU is used for physics calculations, geometry culling, and other operations that prepare the data for rendering in the GPU. The GPU runs the shaders and actually generates the pixel values for display. Knowing if you're CPU or GPU bound can help dictate where to focus your optimization efforts to improve your game performance. </p>
<p class="calibre3">The Tris (triangles) and Verts (vertices) values show the size of your geometric models' meshes that are drawn. Only the visible faces of your meshes are counted, so your scene could include much more.  That is, the values in Stats are the geometry the camera is looking at, not including any vertices outside the view, and after any occluded surfaces have been removed. As you move the camera or as objects in the scene move, the numbers will change. As we'll see in the next topic, reducing the poly count of your models can lead to significant gains in performance.</p>
<p class="calibre3">The Batches value is an indicator of how hard your GPU is working. The more batches, the more rendering the GPU must perform each frame. The number of batches, not the size of a batch, is the bottleneck. You can reduce batches by reducing the geometry in your scene. Since it's faster to have fewer (albeit larger) batches than lots of small ones, you can tell Unity to optimize the graphics by combining more geometry into larger batches, and pump that through the GPU pipeline.</p>
<p>When profiling and optimizing, write down (or take screenshots of) the stats and label them, perhaps in a spreadsheet, to log your progress and measure the effectiveness of each technique that you try.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of the Profiler</h1>
                
            
            
                
<p class="calibre3">The Unity Profiler is a performance instrumentation tool that reports how much processing time is spent in various areas of your game, including rendering and scripts. It records the statistics over time during gameplay and shows them in a timeline graph. Clicking lets you drill down into the details. See <a href="http://docs.unity3d.com/Manual/Profiler.html" class="calibre10">http://docs.unity3d.com/Manual/Profiler.html</a> and the following screenshot:</p>
<div><img class="calibre24" src="img/ffb8bf9d-6826-42fa-8580-c642473f0db7.png"/></div>
<p class="calibre3">The Profiler compacts a lot of information into a small space, so you should recognize its various parts to understand better what you're seeing. Along the top of the window is the Profiler controls toolbar, which enables you to turn profiling on and off (Record) and navigate through profiled frames. The white vertical line in the profile Tracks is the playhead, indicating the current frame being examined.</p>
<p>The Deep Profile button lets you drill down into more detail, recording all function calls in your scripts. This can be useful to see exactly where time is spent in your game code. Note that deep profiling incurs a lot of overhead and causes your game to run very slowly.</p>
<p class="calibre3">Underneath the toolbar are the profile tracks. Scroll down the Tracks pane to reveal more.  You can add and remove tracks using the Add Profiler select list. </p>
<p class="calibre3">Each track includes stats for many parameters pertaining to that category of processing. For example, CPU Usage includes Scripts and Physics; the Rendering one include Batches and Triangles. The visual graph allows you to readily detect anomalies. When troubleshooting, look for stretches and spikes where the data exceeds your expected thresholds. </p>
<p>You can profile your game running in the Unity Editor, or remote profile your game running in a separate player, such as a mobile device.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimizing your art</h1>
                
            
            
                
<p class="calibre3">Some decisions that impact performance the most are your intentionally creative ones. Maybe you want hyper-realistic graphics with high-fidelity sound because <em class="calibre14">its gotta be so awesome!</em> Realizing you must dial that down may constitute a difficult design compromise. However, it's also likely that with a little creative <em class="calibre14">outside-the-box</em> thinking and experimentation, you can achieve (nearly) identical visual results with much better performance. The one thing that you have most control over in your project is the content of your scenes. </p>
<p>Quality is not only how it looks, but also how it feels. Optimizing for user experience is as fundamental a design decision as any.</p>
<p class="calibre3">In general, try to minimize the number of vertices and faces in your model's meshes. Avoid complex meshes. Remove faces that will never be seen, such as the ones inside of solid objects. Clean up duplicate vertices and remove doubles. This will most likely be done in the same 3D modeling application you used to create them in the first place. For example, Blender has the tools for this. Also, there are third-party tools that you can purchase to simplify model meshes.</p>
<p>Be sure to check out Unity's Import Settings for your FBX models. There are option to compress and optimize your meshes, for example. See <a href="https://docs.unity3d.com/Manual/FBXImporter-Model.html" class="calibre20">https://docs.unity3d.com/Manual/FBXImporter-Model.html</a>.</p>
<p class="calibre3">Let's demonstrate what we mean. We are going to set up a scene with a high polygon count model, replicate that model 1000 times, examine it in the Profiler, and try some optimization techniques.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the scene</h1>
                
            
            
                
<p class="calibre3">To begin, we'll need a high-poly model. We found one of a pair of sunglasses on Turbosquid with over 5,800 triangles, and which includes a transparent material for the lenses (<a href="https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082" class="calibre10">https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082</a>). Please download the FBX file now. A copy is also included with the files for this book, for convenience. We will refer to this as <kbd class="calibre13">Sunglasses-original.fbx</kbd> to distinguish it from other versions we'll modify along the way.</p>
<p class="calibre3">Then, go into Unity, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene (File | New Scene), then save it (File | Save Scene As) and name it <kbd class="calibre13">Optimization</kbd></li>
<li class="calibre12">Import the model into your Project <kbd class="calibre13">Assets Models</kbd> folder (Assets | Import New Asset)</li>
<li class="calibre12">Create a ground plane for reference (Create | 3D  Object | Plane), named <kbd class="calibre13">Ground Plane</kbd>, reset its Transform, and create or assign it a material with a neutral color (such as our <kbd class="calibre13">Ground Material</kbd> with Albedo <kbd class="calibre13">#908070FF</kbd>)</li>
<li class="calibre12">Create a cube (Create | 3D Object | Cube), Positioned at (<kbd class="calibre13">-1, 1, 1</kbd>), and give it a colored material (such as  our <kbd class="calibre13">Red Material</kbd> with Albedo <kbd class="calibre13">#E52A2AFF</kbd>)</li>
<li class="calibre12">Move the <kbd class="calibre13">Main Camera</kbd> to Position (<kbd class="calibre13">0, 0.5, -2</kbd>)</li>
</ol>
<p class="calibre3">Now add a copy of the sunglasses:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of the <kbd class="calibre13">Sunglasses-original</kbd> model into the scene</li>
<li class="calibre12">Set its Position (<kbd class="calibre13">0, 1, 0</kbd>), Rotation (<kbd class="calibre13">90, 180, 15</kbd>), and Scale (<kbd class="calibre13">10, 10, 10</kbd>)</li>
</ol>
<p class="calibre3">As a baseline, let's look at its Stats and Profile, and make a note of the values:</p>
<ol class="calibre15">
<li class="calibre12">In the Game window, press Stats</li>
<li class="calibre12">Also, open the Profiler window (Window | Profile)</li>
<li class="calibre12">Press Play</li>
</ol>
<p class="calibre3">The Game window has the following scene and Stats window, showing the graphics hovering around 420 FPS, CPU main 2.4ms, with 22.6k Tris:</p>
<div><img src="img/606e83c4-8de1-4c75-a9fd-a10524379c10.png" class="calibre95"/></div>
<p class="calibre3">The corresponding Profiler window is shown next. You can see in the Rendering timeline where I moved the HMD around:</p>
<div><img src="img/a6c71367-764e-431f-9aa4-5bc42d401d5c.png" class="calibre24"/></div>
<p class="calibre3">This scene is too simple to gather much in the way of meaningful statistics. Let's create 1000 copies of the sunglasses in the scene; follow these steps:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty game object and name it <kbd class="calibre13">SunglassesReplicator</kbd></li>
<li class="calibre12">Create a new C# script on it, named <kbd class="calibre13">SunglassesReplicator</kbd>, and write it as follows:</li>
</ol>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class SunglassesReplicator : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public GameObject prefab;<br class="title-page-name"/>    public Vector3Int dup = new Vector3Int(10, 10, 10);<br class="title-page-name"/>    public Vector3 delta = new Vector3(2, 2, 2);<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        Vector3 position = transform.position;<br class="title-page-name"/>        for (int ix = 0; ix &lt; dup.x; ix++)<br class="title-page-name"/>        {<br class="title-page-name"/>            for (int iy = 0; iy &lt; dup.y; iy++)<br class="title-page-name"/>            {<br class="title-page-name"/>                for (int iz = 0; iz &lt; dup.z; iz++)<br class="title-page-name"/>                {<br class="title-page-name"/>                    position.x = transform.position.x + ix * delta.x;<br class="title-page-name"/>                    position.y = transform.position.y + iy * delta.y;<br class="title-page-name"/>                    position.z = transform.position.z + iz * delta.z;<br class="title-page-name"/>                    GameObject glasses = Instantiate(prefab);<br class="title-page-name"/>                    glasses.transform.position = position;<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">The script takes a <kbd class="calibre13">prefab</kbd> object and instantiates it the <kbd class="calibre13">dup</kbd> number of times (<kbd class="calibre13">10</kbd>) in each of the X, Y, and Z axes, offsetting each by <kbd class="calibre13">delta</kbd> units (<kbd class="calibre13">2</kbd>), generating a total of 1000 instances of the prefab.</p>
<p class="calibre3">Save the script, then back in Unity, set up and assign the replicator parameters as follows:</p>
<ol class="calibre15">
<li class="calibre12">Make a prefab of your sunglasses. Drag the <kbd class="calibre13">Sunglasses-original</kbd> from Hierarchy into your Project <kbd class="calibre13">Assets prefabs</kbd> folder </li>
<li class="calibre12">Select the <kbd class="calibre13">SunglassesReplicator</kbd> in Hierarchy again and drag the prefab from Project Assets onto its Prefab slot</li>
<li class="calibre12">Set the <kbd class="calibre13">SunglassesReplicator</kbd> Position to (<kbd class="calibre13">-10, 1, 0</kbd>) as the origin of our stack of sunglasses</li>
</ol>
<p class="calibre3">Press Play and the generated sunglasses Borg is shown in the Scene window:</p>
<div><img src="img/66cdabb4-35c6-495c-97e5-4d3ea06b8099.png" class="calibre96"/></div>
<p class="calibre3">The Stats now report over 36 million tris and a frame rate under 60 FPS. Ugh! The corresponding Profiler timeline is shown here:</p>
<div><img src="img/6acd84f0-0c62-40a1-b67e-29b6dc19761d.png" class="calibre24"/></div>
<p class="calibre3">OK, now that we have a poorly performing scene, let's see what we can do about it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Decimating models</h1>
                
            
            
                
<p class="calibre3">One thing we can do is try to simplify the models that we imported into Unity. If you select the <kbd class="calibre13">SunGlasses-original</kbd> object in your Project Assets, you can see it consists of two meshes: the <kbd class="calibre13">Frame</kbd> with 4176 tris, and the <kbd class="calibre13">Lens</kbd> with 1664 tris. We should reduce the number of faces on the mesh, or <em class="calibre14">decimate</em> the model. Presently, we will use the separate free and open source Blender application (<a href="https://docs.unity3d.com/Manual/LevelOfDetail.html" class="calibre10">https://www.blender.org/</a>).</p>
<p>Note that the original FBX file of this model downloaded from Turbosquid is in FBX 6 ASCII format, which is not compatible with Blender 2.7+. The version of the file provided with this book was converted using Autodesk FBX Converter 2013 (<a href="http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&amp;id=22694909" class="calibre20">http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&amp;id=22694909</a>).</p>
<p class="calibre3">Follow these steps to decimate the model in Blender:</p>
<ol class="calibre15">
<li class="calibre12">Open Blender, and delete all to clear the default scene (keyboard A | A again | X | Delete)</li>
<li class="calibre12">Import the source Sunglasses fbx file (File | Import | FBX)</li>
<li class="calibre12">Select the sunglasses' frame model mesh (right-click)</li>
<li class="calibre12">On the right, choose the Modify tool (wrench icon)</li>
<li class="calibre12">Select Add Modifier | Decimate</li>
<li class="calibre12">Set Ratio to <kbd class="calibre13">0.1</kbd>, as shown here:</li>
</ol>
<div><img src="img/4f409db7-ea4b-4662-9a5b-1f87f337d137.png" class="calibre97"/></div>
<ol start="7" class="calibre15">
<li class="calibre12">Then, press Apply</li>
<li class="calibre12">Select the sunglass' lens model mesh (right-click)</li>
<li class="calibre12">Decimate it also to Ratio <kbd class="calibre13">0.1</kbd> and Apply</li>
<li class="calibre12">Delete the camera, light, and background objects (select with mouse, keyboard X to delete)</li>
<li class="calibre12">Export as FBX (File | Export | FBX) and give it a new name, such as <kbd class="calibre13">SunGlasses-decimated.fbx</kbd></li>
</ol>
<p class="calibre3">Now back in Unity, import the model and use it in our replicator as follows:</p>
<ol class="calibre15">
<li class="calibre12">Import the new <kbd class="calibre13">SunGlasses-decimated.fbx</kbd> file (Assets | Import New Asset) into your <kbd class="calibre13">Models</kbd> folder</li>
<li class="calibre12">Drag a copy of this model, <kbd class="calibre13">SunGlasses-decimated</kbd>, into the scene</li>
<li class="calibre12">Copy/paste the transform from the original (using Transform Copy Component from the original, and Paste Component Values on the decimated version)</li>
</ol>
<ol start="4" class="calibre15">
<li class="calibre12">Save this as a prefab (drag <kbd class="calibre13">SunGlasses-decimated</kbd> from Hierarchy into your Project <kbd class="calibre13">Assets Prefabs</kbd> folder)</li>
<li class="calibre12">Set this one in the <kbd class="calibre13">SunglassesReplicator</kbd> (drag the prefab from Project Assets onto the replicator's Prefab slot)</li>
</ol>
<p class="calibre3">Press Play and as expected, we are now running about 3.4M tris, about 10% of  what we had before, and we've boosted the FPS some, consistently more than 60 FPS. Better, but not good enough.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transparent materials</h1>
                
            
            
                
<p class="calibre3">Another killer of graphics processing and frame rate is the use of transparency and other rendering techniques that require each pixel to be rendered multiple times. For the sunglasses lens to appear transparent, Unity will render the solid objects behind it first, then render the semi-transparent lens pixels on top, effectively merging the pixel values. Possibly dozens of lenses stacked in front of one another causes a considerable amount of processing work. </p>
<p class="calibre3">Let's see what happens when we replace the transparent lens material with an opaque one:</p>
<ol class="calibre15">
<li class="calibre12">In your Project <kbd class="calibre13">Assets Materials</kbd> folder, create a new Material and name it <kbd class="calibre13">Lens_Opaque</kbd></li>
<li class="calibre12">For its Albedo color, choose an opaque gray, such as <kbd class="calibre13">#333333FF</kbd></li>
<li class="calibre12">Drag a copy of <kbd class="calibre13">Sunglasses-source</kbd> to Hierarchy and rename it <kbd class="calibre13">Sunglasses-opaque</kbd></li>
<li class="calibre12">Unfold it and select the <kbd class="calibre13">Lens</kbd> child object</li>
<li class="calibre12">Drag the <kbd class="calibre13">Lens_Opaque</kbd> material onto the Lens</li>
<li class="calibre12">Select the <kbd class="calibre13">Sunglasses-opaque</kbd> and drag it into the <kbd class="calibre13">Prefabs</kbd> folder, creating a new prefab </li>
<li class="calibre12">With <kbd class="calibre13">SunglassesReplicator</kbd> selected, drag the <kbd class="calibre13">Sunglasses-opaque</kbd> prefab onto its Prefab slot</li>
</ol>
<p class="calibre3">When you press Play now, we have 1000 of the opaque sunglasses and we get a much better frame rate, about 80 FPS.</p>
<p class="calibre3">What happens if we combine these two techniques? Let's use the opaque material on the decimated lenses. Like we just did, create another version of the prefab, named <kbd class="calibre13">Sunglasses-decimated-opaque</kbd>, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of <kbd class="calibre13">Sunglasses-decimated</kbd> to Hierarchy and rename it <kbd class="calibre13">Sunglasses-decimated-opaque</kbd></li>
<li class="calibre12">Unfold it and select the <kbd class="calibre13">Lens</kbd> child object</li>
<li class="calibre12">Drag the <kbd class="calibre13">Lens_Opaque</kbd> material onto the Lens</li>
<li class="calibre12">Select the <kbd class="calibre13">Sunglasses-decimated-opaque</kbd> and drag it into the <kbd class="calibre13">Prefabs</kbd> folder, creating a new prefab with the opaque lenses</li>
<li class="calibre12">With <kbd class="calibre13">SunglassesReplicator</kbd> selected, drag the <kbd class="calibre13">Sunglasses-decimated-opaque</kbd> prefab onto its Prefab slot</li>
</ol>
<p class="calibre3">Pressing Play we consistently get about 100 FPS, as shown in the Profiler timeline:</p>
<div><img src="img/18ff4448-d9eb-44df-aa46-deebc8b5793c.png" class="calibre24"/></div>
<p class="calibre3">Terrific! We have the frame rate we want. But... that's not the look we want either. We have opaque lenses, but we expect translucent ones. And, disappointingly, the low poly versions of the glasses look... low poly. That's just not acceptable. Perhaps there's a compromise.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Levels of detail</h1>
                
            
            
                
<p class="calibre3">Reviewing our scene, we realize that the high-poly sunglasses are really only needed for the ones closest to you. As they recede further into the distance, the low-poly version is just fine. Likewise, the transparency on the lenses is really mostly needed on the ones near you. The sunglasses in the distance, and those occluded by other glasses, do not really need transparency. Unity understands this and provides a component to automatically manage levels of detail, called <strong class="calibre5">LOD Group</strong> (see <a href="https://docs.unity3d.com/Manual/LevelOfDetail.html" class="calibre10">https://docs.unity3d.com/Manual/LevelOfDetail.html</a>).</p>
<p class="calibre3">Let's use this now. We'll create a group of sunglasses, with each of our versions for levels of detail:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, create an Empty game object, name it <kbd class="calibre13">SunglassesLOD</kbd>, and reset its Transform</li>
<li class="calibre12">Drag a copy of the <kbd class="calibre13">Sunglasses-original</kbd> prefab as a child of <kbd class="calibre13">SunglassesLOD</kbd></li>
<li class="calibre12">Drag a copy of the <kbd class="calibre13">Sunglasses-decimated</kbd> prefab as a child also</li>
<li class="calibre12">And drag a copy of the <kbd class="calibre13">Sunglasses-decimated-opaque</kbd> too</li>
<li class="calibre12">Select the parent <kbd class="calibre13">Sunglasses</kbd> object and Add Component | LOD Group</li>
</ol>
<p class="calibre3">Look at the LOD Group component in Inspector. Notice it has several ranges for when to use each model based on camera distance, labeled LOD0, LOD1, and LOD2. The range is a percentage of the object's bounding box height relative to the screen height. When closest, the LOD0 objects are active. Further away, those will be deactivated and the LOD1 ones will be active, and so on.</p>
<p class="calibre3">Let's assign the LOD groups now:</p>
<ol class="calibre15">
<li class="calibre12">Select LOD0</li>
<li class="calibre12">Drag the <kbd class="calibre13">Sunglasses-original</kbd> game object from Hierarchy onto the Add button</li>
<li class="calibre12">Select LOD1</li>
<li class="calibre12">Drag the <kbd class="calibre13">Sunglasses-decimated</kbd> game object onto the Add button</li>
<li class="calibre12">Select LOD2</li>
<li class="calibre12">Drag the <kbd class="calibre13">Sunglasses-decimated-opaque</kbd> object onto Add also</li>
</ol>
<p class="calibre3">A screen capture of the Inspector is shown here:</p>
<div><img src="img/ebf71c76-3614-4e92-b3ad-8bd0d99824da.png" class="calibre98"/></div>
<p class="calibre3">Notice there is a little camera icon on the top edge of the LODn groups. You  can select and slide it across to preview the LOD activations based on camera distance. You can also configure the active range of each LOD (percentage) by sliding the edge of each area box. </p>
<p class="calibre3">Now, let's try it in our scene:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">SunglassesLOD</kbd> object into your Project Prefabs folder</li>
<li class="calibre12">Select <kbd class="calibre13">SunglassesReplicator</kbd> in Hierarchy and drag the <kbd class="calibre13">SunglassesLOD</kbd> prefab onto its Prefab slot</li>
</ol>
<p class="calibre3">Press Play. The Profiler timeline is shown next. There's essentially no difference from our most optimized version, but we get the high-poly models and transparent lenses when we need them:</p>
<div><img src="img/a31c6277-9e26-40bc-abc2-7265d7cd3979.png" class="calibre24"/></div>
<p class="calibre3">Next is a screen capture of the Game view using SunglassesLOD. Closest to us are the high-poly glasses. The middle are low-poly, but with transparent lenses. Further away are low-poly and opaque versions of the model:</p>
<div><img src="img/fb109066-c9c6-4c71-9670-c56a3f07bde1.png" class="calibre99"/></div>
<p>There are a number LOD tools available in the Unity Asset Store to help manage levels of detail and even generate decimated meshes from your models. Unity itself is toying with such a tool, AutoLOD, available free on GitHub (<a href="https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/" class="calibre20">https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/</a>). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimizing your scene with static objects</h1>
                
            
            
                
<p class="calibre3">In addition to your art objects, the next step in optimization might be how your scene itself is organized. If we tell Unity that specific objects will not move in the scene, it can precompute a lot of the rendering in advance rather than at runtime. We do this by defining these game objects as <em class="calibre14">static</em>, and then <em class="calibre14">baking</em> them into specific contexts. </p>
<p class="calibre3">We used static objects in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" class="calibre10">Chapter 4</a>, <em class="calibre14">Gazed-Based Control</em>, when we set up a <kbd class="calibre13">Navmesh</kbd> for Ethan to run through. His walkable <em class="calibre14">nav</em> area was defined by the flat ground plane minus any large static objects that might get in his way, baked into a <em class="calibre14">navmesh</em>.</p>
<p class="calibre3">Statics can also be used to help precompute the scene rendering. Baked lightmaps and shadowmaps precompute lighting and shadows. Baked occlusions divide the scene into static volumes that can be readily culled when out of view, saving processing by possibly eliminating many objects from consideration at once. Let's try some examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the scene</h1>
                
            
            
                
<p class="calibre3">To demonstrate the use of static game objects, we cannot use the dynamically instantiated sunglasses by <kbd class="calibre13">SunglassesReplicator</kbd>. But given we have this script, we'll use it to our advantage now:</p>
<ol class="calibre15">
<li class="calibre12"> In Hierarchy, select <kbd class="calibre13">SunglassesReplicator</kbd> and drag the <kbd class="calibre13">Sunglasses-original</kbd> prefab from Project Assets onto its Prefab slot</li>
<li class="calibre12">Press Play</li>
<li class="calibre12">While playing, in the Hierarchy, select all the <kbd class="calibre13">Sunglasses-original(Clone)</kbd> objects (there's 1000 of them!). Right-click and select Copy</li>
<li class="calibre12">Stop the play mode</li>
<li class="calibre12">In Hierarchy, create an Empty game object and name it <kbd class="calibre13">SunglassesBorg</kbd>.</li>
<li class="calibre12">Paste the cloned sunglasses as children of <kbd class="calibre13">SunglassesBorg</kbd></li>
<li class="calibre12">Disable the <kbd class="calibre13">SunglassesReplicator</kbd> object, as we no longer want to use it</li>
</ol>
<p>If you had the need to do this more than once, you could write an <em class="calibre2">Editor Script</em>. For example, maybe you need a BorgMaker menu option in the Editor's main menubar. It could prompt you with a dialog box asking for the prefab object, duplication counts, and offset parameters, much like our <kbd class="calibre26">SunglassesReplicator</kbd>. Writing scripts that customize and extend the Unity Editor is common practice. If you're interested, see the <em class="calibre2">Manual: Extending the Editor</em> (<a href="https://docs.unity3d.com/Manual/ExtendingTheEditor.html" class="calibre20">https://docs.unity3d.com/Manual/ExtendingTheEditor.html</a>) and the <em class="calibre2">Editor Scripting Intro</em> tutorial (<a href="https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro" class="calibre20">https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lighting and baking</h1>
                
            
            
                
<p class="calibre3">The use of lights in your scene affects frame rate. You have a great deal of control over the number of lights, types of lights, their placement, and settings. Read up on it in the Unity manual, which can be found at <a href="http://docs.unity3d.com/Manual/LightPerformance.html" class="calibre10">http://docs.unity3d.com/Manual/LightPerformance.html</a>.</p>
<p class="calibre3">Use baked lightmaps whenever possible, which precalculates the lighting effects into a separate image rather than at runtime. Use real-time shadows sparingly. When an object casts shadows, a shadow map is generated, which will be used to render the other objects that might receive shadows. Shadows have a high rendering overhead and generally require high-end GPU hardware. </p>
<p class="calibre3">Let's see the impact of using baked lightmaps on our scene:</p>
<ol class="calibre15">
<li class="calibre12">Select <kbd class="calibre13">SunglassesBorg</kbd> and click its Static checkbox in the upper right of Inspector</li>
<li class="calibre12">When prompted, answer Yes, change children</li>
</ol>
<p>If you get an error, "Mesh doesn't have UVs suitable for lightmapping," select the imported fbx model in your Project window, choose Generate Lightmap UVs, and Apply. </p>
<p class="calibre3">Depending on your Lighting settings, the lightmaps may begin generating right away.  Review and modify the lightmap settings as follows:</p>
<ol class="calibre15">
<li class="calibre12">Open the Lighting window (Window | Lighting)</li>
<li class="calibre12">With Auto Generate checked, it will start generating lightmaps any time your scene changes</li>
</ol>
<ol start="3" class="calibre15">
<li class="calibre12">Or, uncheck it and click Generate Lighting to build them manually</li>
</ol>
<p class="calibre3">Here is a screen capture of the Game window running with 1000 high-poly Sunglasses with transparency. We're getting 90 FPS now, and as I move the non-static red cube around, it still renders with transparency and shadows present:</p>
<div><img src="img/75ce6640-0463-4187-b607-caa25432e429.png" class="calibre100"/></div>
<p class="calibre3">In the Lighting window, there are also settings for Realtime Lighting (enabled by default), Baked Global Illumination (enabled by default), Lightmapper subsystem (Enlighten by default), and Fog effects (disabled by default), all of which affect the quality and performance of your scene.</p>
<p class="calibre3">Here are some more tips when dealing with lighting:</p>
<ul class="calibre11">
<li class="calibre12">Avoid dynamic shadows, just use a "blurry blob" underneath moving things by using a Projector (see <a href="https://docs.unity3d.com/Manual/class-Projector.html" class="calibre10">https://docs.unity3d.com/Manual/class-Projector.html</a>).</li>
<li class="calibre12">Check your project’s Quality Settings (Edit | Project Settings | Quality). Use fewer Pixel Lights (on mobile, limit to 1 or 2). Use High Resolution on Hard and Soft Shadows. </li>
<li class="calibre12">You can have as many baked lights as you want. Baked lighting produces high quality results, whereas real-time shadows can appear blocky.</li>
<li class="calibre12">When baking, you can improve lightmap quality by increasing the baked resolution (a 40-100 pixel resolution is reasonable).</li>
<li class="calibre12">Use light probes with baked lighting to illuminate dynamic objects.</li>
<li class="calibre12">Use reflection probes for reflective surfaces. These can be static (baked) or dynamic (real-time).</li>
</ul>
<p class="calibre3">Light probes (either real-time or baked) and the choice of shaders (and the shader options), can make your scene look really amazing. However, they can also have a significant effect on the performance. Balancing aesthetics and graphics performance is an art and a science. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Occlusion culling</h1>
                
            
            
                
<p class="calibre3">As we've seen, the more you try to reduce the number of objects that need to be rendered, the better. Whether or not you are using high- or low-poly models, Unity still needs to figure out which faces are in view. When there are a lot of objects, perhaps we could help Unity out by giving it some clues.</p>
<p class="calibre3">Occlusion culling disables the rendering of objects when they are not seen by the camera because they are obscured (occluded) by other objects. (See <a href="http://docs.unity3d.com/Manual/OcclusionCulling.html" class="calibre10">http://docs.unity3d.com/Manual/OcclusionCulling.html</a>.) It examines your scene and, using the bounding boxes (extents) of each object, divides the world space into a hierarchy of cubes. When Unity needs to determine if an object is within view, it will throw away any objects who's culling box is obviously outside of the view, and continue through the hierarchy.</p>
<p class="calibre3">To demonstrate, we'll replicate a few copies of our <kbd class="calibre13">SunglassesBorg</kbd> and set up occlusion culling:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, select <kbd class="calibre13">SunglassesBorg</kbd>, right-click, then Duplicate three times</li>
<li class="calibre12">For the first copy, set the Y-Rotation to <kbd class="calibre13">90</kbd>, then move it off to Position X = <kbd class="calibre13">20</kbd></li>
<li class="calibre12">For the second copy, set Y-Rotation to <kbd class="calibre13">-90</kbd> and move it to Position X = <kbd class="calibre13">-20</kbd></li>
<li class="calibre12">For the third copy, set Y-Rotation to <kbd class="calibre13">180</kbd> and move it Position Z = <kbd class="calibre13">-20</kbd></li>
</ol>
<p class="calibre3">When I press Play, with so many objects, we are down to about a 50 FPS frame rate.</p>
<p class="calibre3">Now, with the following changes, we can address our performance problem:</p>
<ol class="calibre15">
<li class="calibre12">All four Borgs are already Static, but verify that the Static: Occluder and Occludee are checked (inspect the Static drop-down list)</li>
<li class="calibre12">Open the Occlusion Culling window (Window | Occlusion Culling)</li>
<li class="calibre12">Click Bake</li>
</ol>
<p>Note that we could have, but didn't, distinguish Occludees versus Occluders in our scene. Occludees are objects that get occluded. Ocluders are ones that may be in front, occluding the others. Translucent objects that do not occlude should be marked as Occludees, but not Occluders.</p>
<p class="calibre3">This may take a while. Here is a top-down Scene view with the generated culling volumes:</p>
<div><img src="img/ce571836-350e-4eeb-bb9a-0fc105b9c30c.png" class="calibre24"/></div>
<p class="calibre3">Now when I press Play, the performance is back up to 90 FPS again (more or less, depending on where you're looking, as a user in the scene).</p>
<p>Another way to reduce the details in a scene is by using Global Fog, which is based on distance. Objects further away than the fog limits will not be drawn. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimizing your code</h1>
                
            
            
                
<p class="calibre3">Another area prone to performance problems and ripe for optimization is your script code. Throughout this book, we have used various coding best practices, without necessarily explaining why. (On the other hand, some examples in this book are not necessarily efficient, in favor of simplicity and explanation.) In <a href="77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml" class="calibre10">Chapter 8</a>, <em class="calibre14">Playing with Physics and Fire</em>, for example, we implemented an object pool memory manager to avoid repeatedly instantiating and destroying game objects that causes memory <strong class="calibre5">garbage collection</strong> (<strong class="calibre5">GC</strong>) issues, which in turn slows down your app. </p>
<p class="calibre3">In general, try to avoid code that repeats a lot of computation over and over. Try to pre-compute as much work as you can and store the partial results in variables. </p>
<p class="calibre3">At some point, you may have to use a profiling tool to see how your code is performing under the hood. If the Profiler indicates that a large amount of time is spent in the scripts that you've written, you should consider another way to refactor the code so that it's more efficient. Often, this is related to memory management, but it could be math or physics. (See <a href="http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html" class="calibre10">http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html</a>.)</p>
<p>Please follow coding best practices, but otherwise avoid going out of your way with premature optimization. One mistake people make is putting too much effort into optimizing areas of their code that don't need it, sacrificing readability and maintainability in the process. Use the Profiler to analyze where the performance bottlenecks are and focus your optimization efforts there first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Unity life cycle</h1>
                
            
            
                
<p class="calibre3">Like all video game engines, when your game runs, Unity is executing a giant loop, repeating over and over each frame update. Unity provides many <em class="calibre14">hooks</em> to tap into events at just about every step in the game loop. Depicted below is the life cycle flowchart, taken from the Unity Manual page Execution Order of Event Functions (<a href="https://docs.unity3d.com/Manual/ExecutionOrder.html" class="calibre10">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>). The two event functions you are most familiar with, <kbd class="calibre13">Start</kbd> and <kbd class="calibre13">Update</kbd>, are highlighted with the red arrows. The green dots highlight a number of other events we'll reference in this conversation:</p>
<div><img src="img/ebe8a3a5-399a-4859-8d10-8ea0792291e8.png" class="calibre101"/></div>
<p class="calibre3">Starting at the top of this chart, when your game starts, each GameObject's component, which is derived from the <kbd class="calibre13">MonoBehaviour</kbd> class, will be woke with a call to <kbd class="calibre13">Awake</kbd>. Unless you need to use <kbd class="calibre13">Awake</kbd> or <kbd class="calibre13">OnEnable</kbd>, we typically initialize objects in <kbd class="calibre13">Start</kbd>. Skipping down to the Game Logic section, <kbd class="calibre13">Update</kbd> is called on each frame iteration. Note the loop line/arrows. (The physics engine has its own loop timing, for dealing with RigidBodies, which may be more frequent than the frame updates. You hook into it with <kbd class="calibre13">FixedUpdate</kbd>.) The <kbd class="calibre13">OnDestroy</kbd> event is called to decommission the object.</p>
<p class="calibre3">For the current discussion, the important thing to notice is which events are within the game loop, and which are outside. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing efficient code</h1>
                
            
            
                
<p class="calibre3">We want to keep all of the code within the game loop (such as<kbd class="calibre13">FixedUpdate</kbd>, <kbd class="calibre13">Update</kbd>, and <kbd class="calibre13">LateUpdate</kbd>) as lean as possible. Move any initialization into <kbd class="calibre13">Awake</kbd>, <kbd class="calibre13">OnEnable</kbd>, or <kbd class="calibre13">Start</kbd>. We also want to precompute and cache any computationally expensive work in the initialization functions.</p>
<p class="calibre3">For example, a call to <kbd class="calibre13">GetComponent</kbd> is expensive. As we've seen in many scripts in this book, it is a best practice to get references to any components that Update will need, outside the game logic loop, in <kbd class="calibre13">Start</kbd>. The following code, used in <a href="f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml" class="calibre10">Chapter 7</a>, Lo<em class="calibre14">comotion and Comfort</em>, gets the <kbd class="calibre13">CharacterController</kbd> component in <kbd class="calibre13">Start</kbd>, caches it in a variable, and then references it in <kbd class="calibre13">Update</kbd>, rather than calling <kbd class="calibre13">GetComponent</kbd> every frame:</p>
<pre class="calibre18">public class GlideLocomotion : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>    private Camera camera;<br class="title-page-name"/>    private CharacterController controller;<br class="title-page-name"/><br class="title-page-name"/>    void Start ()<br class="title-page-name"/>    {<br class="title-page-name"/>        camera = Camera.main;<br class="title-page-name"/>        character = GetComponent&lt;CharacterController&gt;();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        character.SimpleMove(camera.transform.forward * 0.4f);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Any time you declare an <kbd class="calibre13">Update()</kbd> function in your script (or any other event function), Unity will call it, even if it's empty. Therefore, you should remove any unused <kbd class="calibre13">Updates</kbd> even though they're part of the default template when you create a new C# <kbd class="calibre13">MonoBehaviour</kbd> script.</p>
<p class="calibre3">Likewise, if you have code in <kbd class="calibre13">Update</kbd> that does not need to be called every frame, turn off the calculations using a state variable (and an <kbd class="calibre13">if</kbd> statement) when they are not needed, for example:</p>
<pre class="calibre18">    public bool isWalking;<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (isWalking)<br class="title-page-name"/>        {<br class="title-page-name"/>            character.SimpleMove(camera.transform.forward * 0.4f);<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding expensive API calls</h1>
                
            
            
                
<p class="calibre3">Other than moving expensive API calls out of Update into an initialization function, there are some APIs that should be avoided altogether if possible. Here are a few.</p>
<p class="calibre3">Avoid <kbd class="calibre13">Object.Find()</kbd>. To obtain a reference to a game object in your scene, do not call <kbd class="calibre13">Find</kbd>. Not only is <kbd class="calibre13">Find</kbd> by name expensive, as it must search the Hierarchy tree, but it is brittle (might break) if you rename the object it is looking for. If you can, define a <kbd class="calibre13">public</kbd> variable to reference the object and associate it in the Editor Inspector. If you must find the object at runtime, use Tags or perhaps Layers to limit the search to a known fixed set of candidates. </p>
<p class="calibre3">Avoid <kbd class="calibre13">SendMessage()</kbd>. The legacy use of <kbd class="calibre13">SendMessage</kbd> is computationally expensive (because it makes use of runtime <em class="calibre14">reflection</em>). To trigger functions in another object, use Unity Events instead. </p>
<p class="calibre3">Avoid fragmenting memory and garbage collection. Temporary allocations of data and objects may cause memory to fragment. Unity will periodically go through the memory heap to consolidate free blocks, but this is expensive and can cause frames to skip in your app.</p>
<p>For more suggestions and a deeper discussion, see the Unity best practices guide, <em class="calibre2">Understanding Optimization in Unity</em> (<a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html" class="calibre20">https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html</a>).</p>
<p>Another area of optimization is Unity Physics. In previous chapters, we briefly mentioned using layers for ray casting, to limit the objects Unity needs to search, for example, for gaze-based selection in VR. Likewise, physics collision detection can be limited to objects on specific layers by defining a Layer Collision Matrix. See the manual page on Optimizing Physics Performance (<a href="https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html" class="calibre20">https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html</a>) and the Physics Best Practices tutorial (<a href="https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices" class="calibre20">https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimizing the rendering</h1>
                
            
            
                
<p class="calibre3">There are a number of important performance considerations that are specific to how Unity does its rendering. Some of these may be common for any graphics engine. Some recommendations may change as newer versions of Unity emerge, the technology advances, and algorithms get replaced.</p>
<p class="calibre3">There are many articles offering recommendations for which setting to use to optimize your VR apps, and it's not unusual for one's advice to contradict another's. Here are some good ones:</p>
<ul class="calibre11">
<li class="calibre12">Use the Forward Rendering path. This is the default in Graphics Settings.</li>
<li class="calibre12">Use <kbd class="calibre13">4X</kbd> MSAA (multi-sampling anti-aliasing). This is a low-cost anti-aliasing technique that helps remove jagged edges and shimmering effects in Quality Settings.</li>
<li class="calibre12">Use Single Pass Stereo Rendering. It performs efficient rendering of parallax perspective for each eye in a single pass in Player Settings. </li>
<li class="calibre12">Enable Static Batching and Dynamic Batching in Player Settings. These are discussed later.</li>
</ul>
<p class="calibre3">Note that some rendering settings are device- or platform-specific, and found in the Player Settings (Edit | Project Settings | Player). Others have been abstracted by Unity into project Quality Settings (Edit | Project Settings | Quality). Still others are in the Graphics Settings (Edit | Project Settings | Graphics).</p>
<p>The phrase <em class="calibre2">Player Settings</em> in Unity does not refer to the user (player) nor a first-person character (player rig). Rather it's referring to the platform executable that <em class="calibre2">plays</em> your app. More like a media player, such as a video player that plays mp4s, the Unity <em class="calibre2">player</em> runs your game after it has been compiled. The Player Settings configure the generated executable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Life's a batch</h1>
                
            
            
                
<p class="calibre3">Perhaps, the biggest bang for the buck is a feature in Unity that groups different meshes into a single batch, which is then shoveled into the graphics hardware all at once. This is much faster than sending the meshes separately. Meshes are actually first compiled into an OpenGL vertex buffer object, or VBO, but that's a low-level detail of the rendering pipeline.</p>
<p class="calibre3">Each batch takes one draw call. Reducing the number of draw calls in a scene is more significant than the actual number of vertices or triangles. For mobile VR, for example, stay around 50 (up to 100) draw calls.</p>
<p class="calibre3">There are two types of batching, <strong class="calibre5">static batching</strong> and <strong class="calibre5">dynamic batching</strong><em class="calibre14">,</em> enabled in Player Settings.</p>
<p class="calibre3">For static batching, simply mark the objects as static by checking off the Static checkbox in the Unity Inspector for each object in the scene. Marking an object static tells Unity that it will never move, animate, or scale. Unity will automatically batch together the meshes that share the same material into a single, large mesh.</p>
<p class="calibre3">The caveat here is meshes must share the same Material settings: the same texture, shader, shader parameters, and the material pointer object. How can this be? They're different objects! This can be done by combining multiple textures into a single macro-texture file or TextureAtlas and then UV-mapping as many models as will fit. It's a lot like a sprite image used for 2D and web graphics. There are third-party tools that help you build these.</p>
<p>A useful analytic tool for checking resources in your scene, including active textures, materials and meshes, is the Unity Resource Checker, found here: <a href="https://github.com/handcircus/Unity-Resource-Checker" class="calibre20">https://github.com/handcircus/Unity-Resource-Checker</a>.</p>
<p class="calibre3">Dynamic batching is similar to static batching. For objects that are not marked Static, Unity will still try to batch them, albeit it will be a slower process since it needs to think about it frame by frame (the CPU cost). The shared Material requirement still holds, as well as other restrictions such as vertex count (less than 300 vertices) and uniform Transform Scale rules. (See <a href="http://docs.unity3d.com/Manual/DrawCallBatching.html" class="calibre10">http://docs.unity3d.com/Manual/DrawCallBatching.html</a>.)</p>
<p>When managing textures in scripts, use <kbd class="calibre26">Renderer.sharedMaterial</kbd> rather than <kbd class="calibre26">Renderer.material</kbd> to avoid creating duplicate materials. Objects receiving a duplicate material will opt out of the batch.</p>
<p class="calibre3">Currently, only Mesh Renderers and Particle Systems are batched. This means that skinned meshes, cloth, trail renderers, and other types of rendering components are not.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multipass pixel filling</h1>
                
            
            
                
<p class="calibre3">Another concern in the rendering pipeline is sometimes referred to as the pixel fill-rate. If you think about it, the ultimate goal of rendering is to fill each pixel on the display device with the correct color value. If it has to paint any pixels more than once, that's more costly. For example, watch out for transparent particle effects, such as smoke, that touch many pixels with mostly transparent quads.</p>
<p class="calibre3">For VR, Unity paints into a frame buffer memory that is larger than the physical display dimensions, which is then post-processed for ocular distortion correction (barrel effect) and chromatic aberration correction (color separation), before getting tossed onto the HMD display. In fact, there may be multiple overlay buffers that get composited before the post-processing.</p>
<p class="calibre3">This multipass pixel filling is how some advanced renderers work, including lighting and material effects such as multiple lights, dynamic shadows, and transparency (Transparent and Fade Render modes) - the Unity Standard Shader as well. Basically, all the good stuff!</p>
<p class="calibre3">VBO batches with materials that require multipass pixel filling get submitted multiple times, thus increasing the net number of draw calls. Depending on your project, you may choose to either optimize the heck out of it and avoid multipass pixel filling altogether, or carefully curate the scenes with an understanding of what should have a high performance and what should have a high fidelity.</p>
<p class="calibre3">You can use Light Probes to inexpensively simulate dynamic lighting of your dynamic objects. Light probes are baked cubemaps that store information about direct, indirect, and even emissive light at various points in your scene. As a dynamic object moves, it interpolates samples of the nearby light probes to approximate the lighting at that specific position. This is a cheap way of simulating realistic lighting on dynamic objects without using expensive real-time lights. (See <a href="http://docs.unity3d.com/Manual/LightProbes.html" class="calibre10">http://docs.unity3d.com/Manual/LightProbes.html</a>.)</p>
<p>Unity 2018 introduces a new Scriptable Render Pipeline, providing a way of configuring and controlling rendering from C# scripts. Unity 2018 includes alternative built-in pipelines for lightweight rendering (such as for mobile and VR apps), and high definition rendering (such as for high fidelity physically based renders), and there's an opportunity for the community to build and share more. Use of these pipelines may supersede information and recommendations made here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">VR-optimized shaders</h1>
                
            
            
                
<p class="calibre3">Shaders are small programs that are compiled to run in the GPU. They process your 3D vectors and polygons (triangles), prepared by the game engine on the CPU, along with lighting information, texture maps, and other parameters, to generate pixels on the display. </p>
<p class="calibre3">Unity comes with a rich set of shaders. The Default Surface Shader is a powerful and optimized one that supports textures, normal maps, height maps, occlusion maps, emission map, specular highlights, reflections, and more.</p>
<p class="calibre3">Unity also includes a set of mobile optimized shaders that are popular for mobile (and desktop) VR development. While they may not provide as high-quality lighting and rendering support, they are designed to perform well on mobile devices and should be considered in any developer's toolbox, even on desktop VR apps.</p>
<p class="calibre3">VR device manufacturers and developers have released their own custom shaders that optimize graphics processing in ways they see fit. </p>
<p class="calibre3"><strong class="calibre5">Daydream Renderer</strong> (<a href="https://developers.google.com/vr/develop/unity/renderer" class="calibre10">https://developers.google.com/vr/develop/unity/renderer</a>) is a Unity package designed for high-quality rendering optimized for the Daydream platform. It supports normal maps, specular highlights with up to eight dynamic lights, "hero shadows" with significant performance improvements over Unity's standard shaders.</p>
<p class="calibre3">Valve (Steam) released the VR shaders used in their impressive demo project, <em class="calibre14">The Lab</em>, as a Unity Package (<a href="https://assetstore.unity.com/packages/tools/the-lab-renderer-63141" class="calibre10">https://assetstore.unity.com/packages/tools/the-lab-renderer-63141</a>). It supports up to 18 dynamic shadowing lights in a single pass with MSAA. </p>
<p class="calibre3">The Oculus OVRPlugin, included with Unity, contains a number of Oculus-specific shaders, used by their prefabs and script components.</p>
<p class="calibre3">Third-party developers also provide shaders with their tools and utilities. As mentioned in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" class="calibre10">Chapter 2</a>, <em class="calibre14">Content, Objects, and Scale</em>, the Google Poly Toolkit for Unity include shaders for models downloaded from Poly, including artwork created with TiltBrush.</p>
<p class="calibre3">And you can experiment and write your own shader. In <a href="df997d92-d63c-4701-9786-da7ba54082b6.xhtml" class="calibre10">Chapter 10</a>, <em class="calibre14">Using All 360 Degrees,</em> we looked at the Unity <strong class="calibre5">ShaderLab</strong> language when we wrote our own inward shader. Unity 2018 introduces a new <strong class="calibre5">Shader Graph</strong> tool for visually building shaders instead of using code. It's intended to be "simple enough that new users can become involved in shader creation."</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Runtime performance and debugging</h1>
                
            
            
                
<p class="calibre3">Graphics hardware architectures continue to evolve towards performance that benefits rendering pipelines of virtual reality (and augmented reality). VR introduces requirements that weren't so important for traditional video gaming. Latency and dropped frames (where rendering a frame takes longer than the refresh rate) took a back seat to high-fidelity AAA rendering capabilities. VR needs to render each frame in time and do it twice: once for each eye. Driven by the requirements of this emerging industry, semiconductor and hardware manufacturers are building new and improved devices, which will inevitably impact how content developers think about optimization.</p>
<p class="calibre3">That said, most likely you should develop and optimize for the lower specs that you want to target. If such optimizations necessitate undesirable compromises, consider separate versions of the game for high- versus low-end platforms. VR device manufacturers have started publishing minimum/recommended hardware specifications, which take much of the guesswork out of it. Start with the recommended Unity settings of your target device and adjust as needed. </p>
<p class="calibre3">For instance, for mobile VR, it is recommended that you tune for CPU-bound rather than GPU-bound usage. Some games will make the CPU work harder, others will impact the GPU. Normally, you should favor CPU over GPU. The Oculus Mobile SDK (GearVR) has an API that is used to throttle the CPU and GPU to control heat and battery drain.</p>
<p class="calibre3">Running in the editor is not the same as running on a mobile device. But, you can still use the Profiler while running in the device.</p>
<p class="calibre3">It can be useful to have a developer mode in your app that shows a heads up display (HUD) with current <strong class="calibre5">frames per second</strong> (<strong class="calibre5">FPS</strong>) and other vital statistics at runtime. To make your how FPS HUD display, add a UI Canvas to your scene with a child Text object. The following script updates the text string with the FPS value:</p>
<pre class="calibre18">public class FramesPerSecondText : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    private float updateInterval = 0.5f;<br class="title-page-name"/>    private int framesCount;<br class="title-page-name"/>    private float famesTime;<br class="title-page-name"/>    private Text text;<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        text = GetComponent&lt;Text&gt;();<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        framesCount++;<br class="title-page-name"/>        framesTime += Time.unscaledDeltaTime;<br class="title-page-name"/>        if (framesTime &gt; updateInterval)<br class="title-page-name"/>        {<br class="title-page-name"/>            float fps = framesCount / framesTime;<br class="title-page-name"/>            text.text = string.Format("{0:F2} FPS", fps);<br class="title-page-name"/>            framesCount = 0;<br class="title-page-name"/>            framesTime = 0;<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Some VR devices also provide their own tools, which we will look at next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Daydream</h1>
                
            
            
                
<p class="calibre3">Daydream developer options include the <kbd class="calibre13">GvrInstalPreviewMain</kbd> prefab that lets you use your Daydream device with the Unity Editor Play mode.</p>
<p class="calibre3">The <em class="calibre14">Daydream Performance HUD</em> (<a href="https://developers.google.com/vr/develop/unity/perfhud" class="calibre10">https://developers.google.com/vr/develop/unity/perfhud</a>) is built into Android. To enable it:</p>
<ol class="calibre15">
<li class="calibre12">Launch the Daydream application on your phone</li>
<li class="calibre12">Tap the gear icon on the top right of the screen </li>
<li class="calibre12">Tab Build Version six times to make the Developer Options item appear</li>
<li class="calibre12">Select Developer Options | Enable performance heads-up display</li>
</ol>
<p class="calibre3">Then, run a VR app and you will see the performance overlay.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Oculus</h1>
                
            
            
                
<p class="calibre3">Oculus offers a suite of performance analysis and optimization tools (<a href="https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/" class="calibre10">https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/</a>), which includes extensive documentation and a workflow guide for developers. Good stuff! It also includes an Oculus Debug Tool, Lost Frame Capture Tool, Performance Profiler, and a Performance Head-Up Display (<a href="https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/" class="calibre10">https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/</a>).</p>
<p class="calibre3">To activate the Performance Head-Up Display, you run it from the Oculus Debug Tool as follows:</p>
<ol class="calibre15">
<li class="calibre12">Go to <kbd class="calibre13">Program Files\Oculus\Support\oculus-diagnostics\</kbd>.</li>
<li class="calibre12">Double-click <kbd class="calibre13">OculusDebugTool.exe</kbd>.</li>
<li class="calibre12">They recommend you first turn off Asynchronous Spacewarp (ASW) to get a good sense of your app's performance without ASW. Find Asynchronous Spacewarp and choose Disabled from the select list.</li>
<li class="calibre12">Find Visible HUD and choose the type you'd like to see: Performance, Stereo Debug, Layer, or None.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="calibre3">Latency and low frames-per-second rates are not acceptable and can cause motion sickness in VR. We are bound by the capabilities and limitations of the hardware devices we run on and their SDKs. In this chapter, we dove into some of the more technical aspects of making great VR, considering four separate areas that affect performance: the artwork, the scene, the code, and the rendering pipeline. </p>
<p class="calibre3">We started the chapter by introducing the built-in Unity Profiler and Stats windows, our primary weapons in this battle. To illustrate the impacts of designing models and materials, we built a scene with 1000 high-poly Sunglasses with transparent lenses, examined the performance stats, and then tried several ways to improve the frame rate: decimating the models (making them low poly), removing transparency in the materials, and managing level of detail (LOD) in the scene. Then, we considered things we can do at the scene level, using static objects, baked lightmaps, and occlusion culling.</p>
<p class="calibre3">Next, we looked at basic practices for optimizing your C# scripts. A key to this is understanding the Unity life cycle, game loop, and expensive API functions, encouraging you to make the frame <kbd class="calibre13">Update</kbd> processing as lean as possible. Then, we looked at the rendering pipeline, gaining some insight into how it works and how to use recommended Quality, Graphics and Player settings, VR optimized shaders, and runtime tools to analyze and improve performance.   </p>
<p class="calibre3">It should be abundantly clear by now that developing for VR has many facets (pun intended). You work hard to create an awesome scene with beautiful models, textures, and lighting. You try to provide a thrilling interactive experience for your visitors. At the same time, you should also be thinking about the requirements of your target platform, rendering performance, frames per second, latency, and motion sickness. It's never too early to focus on performance. It's a mistake to start too late. Follow recommended best practices that are easy to implement, while keeping your code and object hierarchy clean and maintainable. However, take a thoughtful, scientific approach to troubleshooting and performance tuning, using the Profiler and other tools to analyze your project so you can zero in on the root causes rather than spend time on areas that may yield little net effect.</p>
<p>We developers rapidly become immune to all but the most obvious rendering errors, and as a result we are the worst people at testing our own code. It introduces a new and exciting variation of the coder's defense that "it works on my machine" - in this case, "it works for my brain." -Tom Forsyth, Oculus</p>
<p class="calibre3">Developing for VR is a moving target. The platform hardware, software SDKs, and the Unity 3D engine itself are all changing and improving rapidly. Books, blog posts, and YouTube videos can be readily superseded as products improve and new developer insights emerge. On the other hand, great strides have already been made to establish best practices, preferred Unity settings, and optimized device SDKs that address the needs of VR developers. </p>
<p class="calibre3">As VR goes mainstream, it is coming into its own as a new medium for expression, communication, education, problem solving, and storytelling. Your grandparents needed to learn to type and read. Your parents needed to learn PowerPoint and browse the web. Your children will build castles and teleport between virtual spaces. VR will not replace the real world and our humanity; it will enhance it.</p>


            

            
        
    </body></html>