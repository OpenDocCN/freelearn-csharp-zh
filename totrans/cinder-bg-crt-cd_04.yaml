- en: Chapter 4. Prepare Your Brushes – Drawing Basic Shapes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 准备你的画笔 - 绘制基本形状
- en: In this chapter, we will learn how to use Cinder for drawing different basic
    shapes. The shapes are basic but you can create fairly complicated images by combining
    these shapes. We will go through the available drawing methods one by one and
    try them out.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Cinder 绘制不同的基本形状。这些形状是基本的，但通过组合这些形状，你可以创建相当复杂的图像。我们将逐一介绍可用的绘图方法，并尝试使用它们。
- en: Preparing your workspace
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的工作空间
- en: 'Open TinderBox (`yourCinderPath/tools/TinderBox`) and create a new project
    with the name `BasicShapes`. This time enter `BasicShapes` as **Naming Prefix**.
    Create it somewhere safe and open up `xcode/BasicShapes.xcodeproj`. Windows users
    should open the project file from `vc10\BasicShapes.sln`. Open `BasicShapesApp.cpp`
    in the editor and navigate to a place in code that looks similar to the following
    snippet:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 TinderBox (`yourCinderPath/tools/TinderBox`) 并创建一个名为 `BasicShapes` 的新项目。这次将
    `BasicShapes` 作为 **命名前缀** 输入。在安全的地方创建它，并打开 `xcode/BasicShapes.xcodeproj`。Windows
    用户应从 `vc10\BasicShapes.sln` 打开项目文件。在编辑器中打开 `BasicShapesApp.cpp` 并导航到类似于以下代码片段的位置：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the implementation of the main drawing method of the application. Just
    one line of code is executed here (`gl::clear( Color( 0, 0, 0 ) );`) and as it
    is already said in the comment preceding it that it clears out the color buffer
    with black, and it essentially means everything that has been drawn before in
    the previous `draw()` loop is replaced with black.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序主要绘图方法的实现。这里只执行了一行代码（`gl::clear( Color( 0, 0, 0 ) );`），正如它前面的注释所说，它使用黑色清除颜色缓冲区，这本质上意味着在之前的
    `draw()` 循环中绘制的一切都被黑色替换。
- en: The `draw()` method is being executed once per frame. The default frame rate
    in Cinder is 30 frames per second. So the background is cleared 30 times per second.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 方法每帧执行一次。Cinder 的默认帧率为每秒 30 帧。因此，背景每秒清除 30 次。'
- en: 'Let''s try to change the color of the background! As you can see, you have
    to pass a `Color` parameter to the `gl::clear()` function. In this case the `Color`
    object consists of three parameters that define the color in the RGB color system.
    In the `Color( 0, 0, 0 )` parameter there are three zeroes inside the brackets.
    The first one defines the amount of red color, second is for green, and third
    is for blue respectively. Let''s say we want the background to be red. Then, we
    have to pass `1` as the first parameter for the color. It should look similar
    to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试改变背景的颜色！正如你所见，你必须向 `gl::clear()` 函数传递一个 `Color` 参数。在这种情况下，`Color` 对象由三个参数组成，这些参数定义了
    RGB 颜色系统中的颜色。在 `Color( 0, 0, 0 )` 参数中，括号内有三个零。第一个定义了红色量，第二个是绿色，第三个是蓝色。假设我们想让背景是红色，那么我们必须将颜色的第一个参数传递为
    `1`。它应该看起来类似于以下内容：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Compile and run the project to see if we succeeded. You should see a window
    with a bright-red background. Colors in Cinder are defined as numbers from 0 to
    1\. So if you don''t want the background to be so bright, try this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目以查看我们是否成功。你应该会看到一个背景为鲜红色的窗口。在 Cinder 中，颜色被定义为从 0 到 1 的数字。所以如果你不想背景这么亮，试试这个：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile and run the project again. You should see a lesser bright-red background
    now. Nice! Now let's give yellow color to the background. We will need to change
    two of the `Color` parameters to do this as there is no separate parameter for
    the amount of yellow color in the RGB color system. When we look at the color
    wheel, we can see that yellow resides there between red and green. When we examine
    the space between these colors closely, you will see that, red becomes orange,
    orange becomes yellow, and yellow becomes green.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译并运行项目。现在你应该看到一个亮度较低的鲜红色背景。太好了！现在让我们将背景颜色改为黄色。为此，我们需要更改两个 `Color` 参数，因为在
    RGB 颜色系统中没有单独的黄色量参数。当我们看色轮时，我们可以看到黄色位于红色和绿色之间。当我们仔细检查这两种颜色之间的空间时，你会看到，红色变成橙色，橙色变成黄色，黄色变成绿色。
- en: 'So we have to mix the two colors in the same amount to get the yellow color.
    In code it will look similar to the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须以相同的比例混合这两种颜色以得到黄色。在代码中，它看起来类似于以下内容：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compile and run the project. Good work! You will now see a nice, bright yellow
    background. Let''s do one last adjustment to it and change it to white. To do
    so, we have to set all the RGB components to their maximum values. As we know
    from the world of physics that white color consists of all the visible light wavelengths
    and when we shoot a white light beam through a glass prism, we get a rainbow—a
    full visible color spectrum. When we combine all the colors of the spectrum together
    in the same amount, we get white:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目。做得好！你现在将看到一个漂亮、明亮的黄色背景。让我们对其进行最后一次调整，将其改为白色。要做到这一点，我们必须将所有RGB组件设置为最大值。正如我们从物理学世界中知道的那样，白色颜色由所有可见光波长组成，当我们通过玻璃棱镜射出白光束时，我们得到彩虹——完整的可见光光谱。当我们以相同的数量将光谱中的所有颜色组合在一起时，我们得到白色：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have a nice white background. Let's draw something on it!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个漂亮的白色背景。让我们在上面画些东西！
- en: Drawing lines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条
- en: 'Let''s change our background to black again and add the following lines of
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把背景再次改为黑色，并添加以下代码行：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compile and run the project to see what happens. You should see a relatively
    short white line on the screen. This is what the function `gl::drawLine()` just
    did. As we can see, there are two parameters that have to be passed to it. The
    first one represents the start coordinates of the line, the second one defines
    the end coordinates of the line. These two points are defined as `Vec2f` objects.
    It is possible to tell from the name of these objects that they are vectors that
    store two float values. These are vectors that can be used in a two-dimensional
    space. `Vec2f(0,0)` represents a point in the two-dimensional space that resides
    at the top-left corner of the screen. Let''s draw two diagonal lines across the
    whole window. Add the following code instead of `gl::drawLine( Vec2f(0,0), Vec2f(100,100)
    );`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '编译并运行项目以查看发生了什么。你应该在屏幕上看到一条相对较短的白色线条。这正是函数`gl::drawLine()`刚刚执行的操作。正如我们所见，必须向其传递两个参数。第一个参数代表线的起始坐标，第二个参数定义了线的结束坐标。这两个点被定义为`Vec2f`对象。从这些对象的名字中我们可以看出，它们是存储两个浮点值的向量。这些向量可以在二维空间中使用。`Vec2f(0,0)`代表位于屏幕左上角的两维空间中的点。让我们在整个窗口上画两条对角线。将以下代码替换为`gl::drawLine(
    Vec2f(0,0), Vec2f(100,100) );`:'
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see we used two new methods here, `getWindowWidth()` and `getWindowHeight()`,
    which are meant for determining the window size while the application is running.
    It is a very handy way of drawing graphics that can be independent from the window
    size. Instead of changing the parameters manually each time we decide to change
    our application window size. We can just place the `getWindowWidth()` and `getWindowHeight()`
    methods in place of the parameters and the graphics will be adjusted automatically
    whenever the application window is being resized.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里使用了两种新的方法，`getWindowWidth()`和`getWindowHeight()`，它们旨在确定应用程序运行时的窗口大小。这是一种非常方便的绘制图形的方法，可以独立于窗口大小。我们不必每次决定更改我们的应用程序窗口大小时手动更改参数。我们只需将`getWindowWidth()`和`getWindowHeight()`方法放在参数的位置，图形将在应用程序窗口被调整大小时自动调整。
- en: Compile and run the application and try to change the size of the window by
    dragging its lower-right corner—the lines should adjust to the new window size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序，并尝试通过拖动其右下角来改变窗口的大小——线条应该调整到新的窗口大小。
- en: 'Doing this is good but what if we need the lines to be in a color other than
    white? How about cyan? No problem! Add the following line of code before the `drawLine()`
    calls:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事很好，但如果我们需要线条不是白色，而是青色呢？没问题！在`drawLine()`调用之前添加以下代码行：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com) . If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/](http://www.packtpub.com/)support
    and register to have the files e-mailed directly to you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/](http://www.packtpub.com/)支持并注册，以便将文件直接通过电子邮件发送给您。
- en: 'That was not so hard. We just have to remember to change the color (if we want
    to) before we call a function that is supposed to draw something. So if we want
    to draw one line in red and another in cyan, we do it in the following way:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难。我们只需要记住在调用一个应该绘制东西的函数之前改变颜色（如果我们想的话）。所以如果我们想用红色画一条线，用青色画另一条线，我们就这样做：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So now we know how to change the color of the lines. How about changing the
    thickness? No problem! Place the following line of code before the line draw calls:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们知道了如何改变线条的颜色。那么改变粗细呢？没问题！在绘制线条的调用之前放置以下代码行：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So now our lines are being drawn with the thickness of `10` pixels. Compile
    and run the project to see how it looks. Now you should see the lines as shown
    in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在我们的线条正在以 `10` 像素的粗细绘制。编译并运行项目以查看效果。现在你应该看到如下截图所示的线条：
- en: '![Drawing lines](img/9564_04_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![绘制线条](img/9564_04_01.jpg)'
- en: 'The following is the full draw method, if you failed to understand something
    before (I have changed the line width to `2` in the following code):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完全的绘制方法，如果你之前没有理解某些内容（我在以下代码中将线宽更改为 `2`）：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Drawing circles
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制圆圈
- en: 'How about adding some circles to the composition? Add the following lines after
    the last `drawLine` call:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在作品中添加一些圆怎么样？在最后一个 `drawLine` 调用之后添加以下行：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After you compile and run the application, you should see a circle in the middle
    of the screen. The `drawSolidCircle()` function takes two parameters. First is
    the position of the center of the circle. Second is the radius of the circle.
    We define the position by using the `Vec2f` object again. As you can see, we use
    `getWindowWidth()` and `getWindowHeight()` again. This time we need them to get
    the center coordinates of the screen. We get it by dividing the window's width
    and height by `2`. Again, by using these methods we make sure that our circle
    will be drawn in the middle of the screen no matter what size the window is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译并运行应用程序后，你应该在屏幕中间看到一个圆圈。`drawSolidCircle()` 函数接受两个参数。第一个是圆心的位置。第二个是圆的半径。我们再次使用
    `Vec2f` 对象来定义位置。正如你所见，我们再次使用了 `getWindowWidth()` 和 `getWindowHeight()`。这次我们需要它们来获取屏幕的中心坐标。我们通过将窗口的宽度和高度除以
    `2` 来得到它。再次，通过使用这些方法，我们确保无论窗口的大小如何，我们的圆都会在屏幕中间绘制。
- en: 'There is a shorter way to do this though that is by using the `getWindowCenter()`
    method. If we use it, we get the same result but the code looks a bit more clear:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一种更简单的方法来做这件事，那就是使用 `getWindowCenter()` 方法。如果我们使用它，我们会得到相同的结果，但代码看起来更清晰一些：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s change the color of the circle to something else. You can chose your
    own color, but I will use magenta this time. Add the following line of code right
    before the `drawSolidCircle()` function call:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变圆的颜色。你可以选择你自己的颜色，但这次我将使用洋红色。在 `drawSolidCircle()` 函数调用之前添加以下代码行：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try to experiment with the position, radius, and color of the circle. Try to
    draw more than one shape and also try giving them different colors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实验圆的位置、半径和颜色。尝试绘制多个形状，并尝试给它们不同的颜色。
- en: 'What if we want to draw just the outline of the circle? Cinder has a separate
    function for this called `drawStrokedCircle()`. After the `drawSolidCircle()`
    function add another line of code as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想绘制圆的轮廓呢？Cinder 有一个专门用于此的函数，称为 `drawStrokedCircle()`。在 `drawSolidCircle()`
    函数之后添加另一行代码，如下所示：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similar to the `drawSolidCircle()` function, `drawStrokedCircle()` also takes
    two parameters—position and radius. The difference is just that it draws just
    the outline. The outline has the same thickness that we defined earlier with the
    help of the `glLineWidth()` function. Let''s change it to something else by adding
    the following line of code just before the `drawStrokedCircle()` line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `drawSolidCircle()` 函数类似，`drawStrokedCircle()` 也接受两个参数——位置和半径。区别仅在于它只绘制轮廓。轮廓的粗细与我们之前通过
    `glLineWidth()` 函数定义的相同。让我们通过在 `drawStrokedCircle()` 行之前添加以下代码行来将其更改为其他颜色：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compile and run the project, and see what happens. You should see a screen
    similar to the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目，看看会发生什么。你应该看到如下截图所示的屏幕：
- en: '![Drawing circles](img/9564_04_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![绘制圆圈](img/9564_04_02.jpg)'
- en: 'There is a hidden third parameter for the `drawSolidCircle()` and `drawStrokedCircle()`
    functions. As the circles are drawn by using triangles, each time a circle is
    being drawn, it has to be decided how many triangles to use. Cinder does it automatically
    but it is possible to define the triangle count by ourselves. So let''s change
    the amount of triangle segments:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `drawSolidCircle()` 和 `drawStrokedCircle()` 函数，有一个隐藏的第三个参数。由于圆是通过三角形绘制的，每次绘制圆时，都必须决定使用多少个三角形。Cinder
    会自动完成这项工作，但我们也可以自己定义三角形数量。所以让我们改变三角形段的数量：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the highlighted parts of the code. We told the circle drawing functions
    to draw circles by using just five triangles. By doing this we get pentagons instead
    of circles. Compile and run the project to see it yourself!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码中高亮的部分。我们告诉圆形绘制函数只使用五个三角形来绘制圆形。通过这样做，我们得到了五边形而不是圆形。编译并运行项目，亲自看看吧！
- en: Try to experiment with all the properties to get the most out of it. You can
    draw almost any kind of regular polygon shape with this function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整所有属性以充分利用它。你可以使用这个函数绘制几乎任何类型的规则多边形形状。
- en: Drawing rectangles
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: Now that we know how to draw lines and circles, let's move to another geometric
    primitive that we can use—the rectangle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何绘制线条和圆形，让我们转向另一个我们可以使用的几何原始形状——矩形。
- en: As in the case of a circle, there is one function for drawing a filled rectangle
    and one function for drawing just the outline. They are `drawSolidRect()` and
    `drawStrokedRect()` respectively.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像圆形的情况一样，有一个函数用于绘制填充矩形，还有一个函数用于仅绘制轮廓。它们分别是 `drawSolidRect()` 和 `drawStrokedRect()`。
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we draw two rectangles, one filled (or solid) and one as an outline. Note
    that we pass just one parameter of the type `Rectf` to both the functions. The
    simplest version of `Rectf` is being constructed by using the coordinates of top-left
    and bottom-right corners of the rectangle. Most of the drawing APIs use x and
    y coordinates of the top-left corner and the width and height of the rectangle,
    so it could be a bit difficult to get used to this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们绘制了两个矩形，一个填充（或实心）和一个轮廓。请注意，我们向两个函数传递了类型为 `Rectf` 的单个参数。`Rectf` 的最简单版本是通过使用矩形的左上角和右下角的坐标来构建的。大多数绘图
    API 使用左上角的 x 和 y 坐标以及矩形的宽度和高度，所以这可能有点难以适应。
- en: Other useful drawing functions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的绘图函数
- en: 'These are the very basic drawing functions, and actually you can do a lot with
    them if you use them in a creative way. But here are a couple of other functions
    that are worth checking out. They are given in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非常基本的绘图函数，实际上如果你以创造性的方式使用它们，你可以做很多事情。但这里还有一些其他值得检查的函数。它们在以下代码片段中给出：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Experiment with the properties of these functions to fully understand what
    they mean. Compile and run the project and you should see an image similar to
    the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过调整这些函数的属性来完全理解它们的含义。编译并运行项目，你应该会看到一个类似于以下截图的图像：
- en: '![Other useful drawing functions](img/9564_04_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![其他有用的绘图函数](img/9564_04_03.jpg)'
- en: Try to re-size the window by dragging the bottom right corner. You will see
    the difference between graphics that are drawn relative to the window's size and
    the ones that are not. Keep this in mind when creating your own application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过拖动右下角来调整窗口的大小。你会看到相对于窗口大小绘制的图形和不是相对于窗口大小绘制的图形之间的区别。在创建自己的应用程序时，请记住这一点。
- en: 'The following is the full code for drawing all the shapes, in case you did
    not understand which line of code goes where:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为绘制所有形状的完整代码，以防你不知道哪一行代码对应哪个位置：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's it! This is one of the simplest way to draw basic shapes with Cinder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！这是用 Cinder 绘制基本形状最简单的方法之一。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we went through the most essential drawing functions in Cinder.
    You can draw a lot with these. However, there are limitations of what can be done
    with them. If you need to draw something really complex and it has to perform
    well or extremely well, consider obtaining some OpenGL knowledge.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Cinder 中最关键的绘图函数。你可以用这些函数绘制很多东西。然而，它们在可以完成的事情方面有一些限制。如果你需要绘制一些非常复杂的东西，并且它必须表现良好或非常好，考虑获取一些
    OpenGL 知识。
- en: Here you can find a full list of drawing functions that are currently available
    in Cinder at [http://libcinder.org/docs/v0.8.4/namespacecinder_1_1gl.html](http://libcinder.org/docs/v0.8.4/namespacecinder_1_1gl.html).
    On the web page, scroll down to the functions section and look at functions that
    start with "draw".
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://libcinder.org/docs/v0.8.4/namespacecinder_1_1gl.html](http://libcinder.org/docs/v0.8.4/namespacecinder_1_1gl.html)
    找到 Cinder 当前可用的完整绘图函数列表。在网页上，滚动到函数部分，查看以 "draw" 开头的函数。
- en: We will use some of the functions from this list in the next chapters, so this
    is not the only place where we use drawing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中使用这个列表中的某些函数，所以这并不是我们使用绘制的唯一地方。
