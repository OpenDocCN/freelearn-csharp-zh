<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-282"><a id="_idTextAnchor283"/>13</h1>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor284"/>The One with the Deployment Dramas</h1>
			<p><em class="italic">Deployment </em><em class="italic">and Distribution</em></p>
			<p>Allow me to make a confession: I love writing code. The whole process that starts with a vague idea, followed by writing the first lines of code, then finding issues and debugging the code, gives me a thrill. There is something magical about creating something out of thin air and seeing it come to life before my eyes.</p>
			<p>But there comes a moment when the software is “good enough” and it needs to move into production. After all, we write software with a purpose: it needs to be used. And that usually means moving it away from your development machine to a production environment.</p>
			<p>There are many challenges in this process. But don’t worry: we will tackle all of them! We will discuss the following topics:</p>
			<ul>
				<li>What does deployment mean?</li>
				<li>How do you use the Publish wizard from Visual Studio?</li>
				<li>What is CI/CD, and how do I use it in Azure DevOps or GitHub?</li>
				<li>How do I build an installer?</li>
				<li>How do I deploy with Docker?</li>
			</ul>
			<p>So, if you are ready to let the world see the fruits of your labor but are unsure how to get that out there, this is the chapter for you.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor285"/>Technical requirements</h1>
			<p>You will find all the code in this chapter in our repository at <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13</a>.</p>
			<p>If you want to follow along with the CI/CD samples in Azure, you’ll need an Azure subscription. You can sign up for a free trial for Azure at <a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a>.</p>
			<p>To have a go with GitHub Actions, you’ll need to sign up for a GitHub account. You can get a free one here: <a href="https://github.com/signup">https://github.com/signup</a>.</p>
			<p>If you want to follow along when we talk about the setup projects, you must install <strong class="bold">Visual Studio Extension Microsoft Visual Studio Installer Projects 2022</strong>. You can find this by going to the <strong class="bold">Extensions</strong> menu item and choosing <strong class="bold">Manage extensions</strong>. From there, in the <strong class="bold">Online</strong> tab, search for that extension.</p>
			<p>With this tool, you can follow along and build your own installers.</p>
			<p>If you want to work with the Docker sample, install Docker Desktop. You can find it here: <a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a>.</p>
			<p>All the software mentioned here is free or has a free trial.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor286"/>From development to production</h1>
			<p>There will come a moment when you’re developing your application when you decide it is time for other people to try out the fruits of your labor. This means moving your application from your development machine to another environment. This could be another developer’s machine or a production system.</p>
			<p>Depending on the complexity of your system, moving the bits away could involve anything from a simple file copy to building a complex installer application. You also have to think about ways to remove your application from their system and about ways to update or upgrade your application. All these tasks are gathered under the term <em class="italic">deployment</em>.</p>
			<p>Deployment should be as seamless as possible. The users should be able to take your application and prepare it for use effortlessly. This means all the hard work lies with us.</p>
			<p>Creating a deployment scenario involves thinking about the following aspects:</p>
			<ul>
				<li>Copying your binaries</li>
				<li>Copying the binaries your system depends on</li>
				<li>Copying additional files</li>
				<li>Setting user rights</li>
				<li>Copying settings and altering them</li>
				<li>Creating and copying secrets</li>
				<li>Altering system settings such as paths</li>
				<li>Registering your application in the host environment</li>
			</ul>
			<p>Uninstalling your applications means reversing this process: in an ideal world, an uninstall leaves no trace of your application and the associated files on the host machine.</p>
			<p>Upgrading and updating is a mix of these scenarios: deploying new code, changing settings, and removing things you no longer need in the latest version.</p>
			<p>If all you have is a simple, standalone console application, deployment is a breeze: just copy the files needed. Suppose you’re deploying a complex system, such as a background worker; this needs configuration settings to connect to external systems. In that case, you have a lot more work to do. But there is good news: for each of those and other scenarios, there are strategies to follow. And that is what the rest of this chapter is all about. So, do a final build of your app, do a quick local test, and let’s deploy our work!</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor287"/>Publishing and file copy</h1>
			<p>The<a id="_idIndexMarker1065"/> easiest way to deploy an application is to use Visual Studio’s Publish mechanism. Let’s assume I have a simple console application. I don’t have any configuration settings that I need to change when running on a production environment. So, I can just copy what I have.</p>
			<p>Let’s assume we have a simple console application. You’ve tested it, and you’re ready to deliver. There are two options: use <strong class="bold">Visual Studio</strong> or use the <strong class="bold">CLI</strong>.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor288"/>Publish using Visual Studio</h2>
			<p>In <a id="_idIndexMarker1066"/>Visual Studio, in<a id="_idIndexMarker1067"/> the <strong class="bold">Solution Explorer</strong> area, right-click on your project and select <strong class="bold">Publish</strong>. You’ll see the following dialog:</p>
			<div><div><img alt="Figure 13.1: Publishing via Visual Studio" src="img/B20924_14_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Publishing via Visual Studio</p>
			<p>There are a<a id="_idIndexMarker1068"/> couple of options to choose from:</p>
			<ul>
				<li><strong class="bold">Azure</strong>: This <a id="_idIndexMarker1069"/>means deploying your system to Azure so that it runs there.</li>
				<li><strong class="bold">ClickOnce</strong>: ClickOnce is a technique for building a simple installer. Updates and uninstallation are part of the mechanism. However, ClickOnce is meant for Windows applications that the users start. Therefore, this is not a solution for us system programmers. For that reason, I will not cover ClickOnce here.</li>
				<li><strong class="bold">Docker Container Registry</strong>: This is a great way to package and deploy systems. We will discuss this later.</li>
				<li><strong class="bold">Folder</strong>: This is the simplest way to publish as it just copies all files needed to a folder.</li>
				<li><strong class="bold">Import Profile</strong>: If you’ve already defined deployment methods, you can use those settings here by importing them.</li>
			</ul>
			<p>In this case, we’ll choose <strong class="bold">Folder</strong>. Upon doing so, you’ll get a new dialog asking if you want to use <strong class="bold">ClickOnce</strong> for the folder deployment or whether you wish to deploy to the filesystem. Choose <strong class="bold">Folder</strong> to pick the latter. At this point, you can enter the path to which you <a id="_idIndexMarker1070"/>want to publish. For now, leave it as the default setting. Click <strong class="bold">Finish</strong>.</p>
			<p>Although you <a id="_idIndexMarker1071"/>clicked <code>FolderProfile.pubxml</code>, and you can find it in the <strong class="bold">Solution Explorer</strong> area in your project under <strong class="bold">Properties</strong> &gt; <strong class="bold">PublishProfiles</strong>.</p>
			<p>Visual Studio will open the profile and show you what it looks like. From here, we can click the big <strong class="bold">Publish</strong> button; however, we might want to tweak the profile before doing that. Click <strong class="bold">More Actions</strong> and choose <strong class="bold">Edit</strong>. This results in the following dialog:</p>
			<div><div><img alt="Figure 13.2: The Profile settings dialog" src="img/B20924_14_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: The Profile settings dialog</p>
			<p>You can tweak the profile a lot here. Let’s walk through the options:</p>
			<ul>
				<li><strong class="bold">Configuration</strong>: You can choose any configuration you might have defined in your project. By default, these are the <strong class="bold">Debug</strong> and <strong class="bold">Release</strong> configurations. I suggest that you use <strong class="bold">Release</strong> for deployments.</li>
				<li><strong class="bold">Target framework</strong>: Here, you can choose any compatible and installed framework you want for your application. Just leave this set to what you used when <a id="_idIndexMarker1072"/>you were building your system.</li>
				<li><strong class="bold">Deployment mode</strong>: Here, you can choose between <strong class="bold">Framework-dependent</strong> and <strong class="bold">Self-contained</strong>. If you pick <strong class="bold">Framework-dependent</strong>, the application will assume the .NET runtime is installed on the target machine. However, if you select <strong class="bold">Self-contained</strong>, all needed assemblies will be part of the publication. Your package<a id="_idIndexMarker1073"/> will be much bigger since it contains everything you need from the .NET runtime. However, it does not rely on others to install the .NET runtime.</li>
				<li><strong class="bold">Target runtime</strong>: This is where you decide on the architecture of the target. If you know what architecture that machine is, you can choose it from the drop-down menu. This results in more optimized code but restricts where you can use it. For instance, if you decide to use Win-X64, you cannot deploy your code to a Linux machine. If you do not want to make that decision, leave it set to <strong class="bold">Portable</strong>.</li>
				<li><strong class="bold">Target location</strong>: This is the location where the files will be copied.</li>
			</ul>
			<p>Suppose you decided to go with the <strong class="bold">Self-contained</strong> option. In that case, you get three additional choices: <strong class="bold">Produce Single file</strong>, <strong class="bold">Enable ReadyToRun compilation</strong>, and <strong class="bold">Trim </strong><strong class="bold">unused code</strong>.</p>
			<p>The first option is self-explanatory: you get one big file instead of dozens of small files. <strong class="bold">ReadyToRun</strong> is a form<a id="_idIndexMarker1074"/> of <strong class="bold">ahead-of-time</strong> (<strong class="bold">AOT</strong>) compilation. This means the code is pre-compiled and thus starts faster. It is not a real AOT compilation: the resulting files contain both the compiled code and the IL. Still, it saves startup time. The <strong class="bold">Trim unused code</strong> option removes all code from the runtime you don’t need. Selecting this option makes the final package a lot smaller.</p>
			<p>Make your changes and then click <strong class="bold">Save</strong>. After that, click <strong class="bold">Publish</strong>. When Visual Studio is finished, go to the folder you picked as the destination and inspect what has happened (<em class="italic">hint</em>: you can click on the <strong class="bold">Target location</strong> value in the <strong class="bold">Publish Profile</strong> dialog to open an <strong class="bold">Explorer</strong> window and go to the location directly).</p>
			<p>All that’s left is to <a id="_idIndexMarker1075"/>copy the resulting files to the target machine. Then, you can run it on that machine to see if everything is working fine and you are ready.</p>
			<p>Congratulations: you just deployed your application!</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor289"/>Publishing using the CLI</h2>
			<p>The Visual Studio wizard<a id="_idIndexMarker1076"/> is very good at helping you build the profile. Still, if you already know what you’re doing or want to make publishing <a id="_idIndexMarker1077"/>part of a pipeline, you can use the CLI to do the same.</p>
			<p>The base command is simple – in the directory where you have your <code>.csproj</code> file, just run the following command:</p>
			<pre class="console">
dotnet publish</pre>			<p>This command takes all the default settings in the dialog box and uses them to publish your application. Of course, you can change what <code>publish</code> does: all you have to do is supply the correct parameters. The following table shows the most common ones and their possible values. Most parameters have two variants – a full parameter name (often preceded by two dashes) and a shorthand (often preceded by one dash):</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-12">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Parameter</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Possible Values</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>o</code>/<code>--output</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The output directory to place the published artifacts in</p>
						</td>
						<td class="No-Table-Style">
							<p>The directory where you want to place the published application</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>--</code><code>sc</code>/<code>--self-contained</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes the runtime with your application</p>
						</td>
						<td class="No-Table-Style">
							<p>-</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>f</code>/<code>--framework</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The target framework you want to deploy to</p>
						</td>
						<td class="No-Table-Style">
							<p><code>net6.0</code></p>
							<p><code>net7.0</code></p>
							<p><code>net8.0</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>r</code>/<code>--runtime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The target runtime to publish for</p>
						</td>
						<td class="No-Table-Style">
							<p><code>win-x64</code></p>
							<p><code>linux-x64</code></p>
							<p><code>linux-arm</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>c</code>/<code>--configuration</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The build configuration</p>
						</td>
						<td class="No-Table-Style">
							<p><code>Release</code></p>
							<p><code>Debug</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.1: dotnet publish options</p>
			<p>If you <a id="_idIndexMarker1078"/>decide to build a self-contained deployment, you can add three more parameters:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-10">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Parameter</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>p:PublishSingleFile=true</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates a single file</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>p:PublishReadyToRun=true</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Compiles to Ready To Run AOT binaries</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>p:PublishTrimmed=true</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Removes all unnecessary code from the binaries</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.2: Self-Contained extra options</p>
			<p>You could <a id="_idIndexMarker1079"/>specify that you do not want these options by setting them to <code>False</code>, but I suggest that you omit that parameter.</p>
			<p>So, to publish your console application to a specific folder, create a self-contained deployment in a single file that’s ready to run, and trim all unnecessary code for a <code>win-x64</code> architecture running on <code>net.80</code>. To do so, issue the following code (all on a single line):</p>
			<pre class="console">
dotnet publish
  -o d:\temp\publish
  --self-contained
  -f net8.0
  -r win-x64
  -c Release
  -p:PublishSingleFile=true
  -p:PublishReadyToRun=true
  -p:PublishTrimmed=true</pre>			<p>Now, if you <a id="_idIndexMarker1080"/>go to the <code>d:\temp\publish</code> folder, you can <a id="_idIndexMarker1081"/>take the file there, copy that to your production machines, and run it. At this point, you can sit back, knowing your hard work is finally being used.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor290"/>Using Azure DevOps and GitHub</h1>
			<p>If your code is meant to be used in the cloud, such as on Azure or AWS, you can use Azure DevOps and GitHub. Which one you pick depends on where you currently have your source code. Both DevOps <a id="_idIndexMarker1082"/>and GitHub allow for <strong class="bold">continuous integration and continuous deployment</strong> (<strong class="bold">CI/CD</strong>) scenarios.</p>
			<p class="callout-heading">CI/CD</p>
			<p class="callout">The idea with CI/CD is that when you change your source code, the system notices this and builds your software. Then, it can run tests optionally (in my view, it is not optional, but mandatory). After, it automatically deploys the new binaries to the production environment. This way of working means that you can do a lot of minor, incremental updates to your system and get early feedback on what you did. If this fits your use case, it is a great tool!</p>
			<p>Let’s look at Azure DevOps first.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor291"/>Deploying to Azure</h2>
			<p>I assume <a id="_idIndexMarker1083"/>you have an Azure DevOps project set up, have defined the working process, and have a repo available to host your code.</p>
			<p>You can connect Visual Studio to that project if you have done so. In my case, I have created a simple Function App. A Function App is a service that runs in Azure. In this case, I have decided to use a simple HTTP-based trigger. In other words, the function responds to a REST API call and returns a string with a pleasant greeting. This chapter is not about writing Azure Functions but about deploying code, so I won’t dive into the details of how the code works. For now, it’s a REST API that you call with a parameter called <code>name</code>; it returns a friendly greeting containing that name. That’s it.</p>
			<p>But to make things more interesting, I have called my program <code>MyFileConverterFunctionApp</code>. Trust me: it doesn’t do anything interesting.</p>
			<p>If you have the code up and running locally, it is time to prepare your system for deployment. There are two steps we need to take.</p>
			<ul>
				<li>Create a publish profile</li>
				<li>Publish the system to Azure</li>
			</ul>
			<p>Let’s get started.</p>
			<h3>Building the publish profile for Azure DevOps</h3>
			<p>Before <a id="_idIndexMarker1084"/>I show you how to deploy your application to Azure, let’s review the prerequisites if you want to follow along. First, you need a project<a id="_idIndexMarker1085"/> to deploy. But besides this obvious prerequisite, these are the things you’ll need:</p>
			<ul>
				<li>An Azure account.</li>
				<li>A resource group (mine is called <code>SystemsProgrammingRg</code>).</li>
				<li>A Key Vault to store secrets.</li>
				<li>A storage account. We’ll need this for deployment later.</li>
			</ul>
			<p>Once you have these, you’re ready to start the deployment process.</p>
			<p>In Visual Studio, right-click on your project’s name and select <strong class="bold">Publish</strong>. You’ll be taken to the following screen:</p>
			<div><div><img alt="Figure 13.3: Default publishing dialog" src="img/B20924_14_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: Default publishing dialog</p>
			<p>Yes, this is <a id="_idIndexMarker1086"/>the same dialog we saw previously. However, this time, select <strong class="bold">Azure</strong> as your target.</p>
			<p>The<a id="_idIndexMarker1087"/> following dialog will ask you what kind of service you want to deploy. I chose <strong class="bold">Azure Function App (Windows)</strong>. You could go for a Linux deployment. Don’t worry about the container options for now; we will discuss Docker and containers later in this chapter.</p>
			<p>Then, we need to tell Visual Studio about the final location of our application. Likely, you won’t have a Function App you can use (that wasn’t part of the prerequisites, after all), so you can create one now. You’ll be presented with a dialog asking you about your environment and preferences. Mine looks like this:</p>
			<div><div><img alt="Figure 13.4: Creating a new Function App in Visual Studio" src="img/B20924_14_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4: Creating a new Function App in Visual Studio</p>
			<p>I’ve blacked out my<a id="_idIndexMarker1088"/> Azure account details <a id="_idIndexMarker1089"/>since I want you to use yours. You need to choose the options that are best for you. This dialog is also where you must specify the storage account I told you to create (in my case, it is <code>dvstorageaccountsp</code>). I also decided to add <strong class="bold">Application Insights</strong>. Using <strong class="bold">Application Insights</strong> helps me monitor and troubleshoot my application if needed.</p>
			<p>When you click <strong class="bold">Create</strong>, the system will build your environment. This takes a while, but we can move to the next screen when it is done. This next screen gives you an overview of all app services<a id="_idIndexMarker1090"/> in the given resource group and all <a id="_idIndexMarker1091"/>the deployment slots. Since we haven’t deployed yet, this list is empty. Click <strong class="bold">Next</strong>:</p>
			<div><div><img alt="Figure 13.5: Choosing what to generate as a publishing mechanism" src="img/B20924_14_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5: Choosing what to generate as a publishing mechanism</p>
			<p>We can choose whether to use a publish profile or GitHub Actions here. We will look at GitHub Actions shortly, so let’s go with <strong class="bold">Publish</strong> for now. Visual Studio will generate the Publish profile for us.</p>
			<p>When that is done, we’ll get an overview, including a nice, big, inviting <strong class="bold">Publish</strong> button:</p>
			<div><div><img alt="Figure 13.6: Overview of the Publish profile" src="img/B20924_14_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6: Overview of the Publish profile</p>
			<p>Let’s click that <strong class="bold">Publish</strong> button!</p>
			<p>Again, this<a id="_idIndexMarker1092"/> takes a little while, but when your code <a id="_idIndexMarker1093"/>has been published, you’ll get a hyperlink that allows you to go to the resource. You can click that, but it won’t be exciting. It’s just a web page saying your Function App is up and running.</p>
			<p>To see what happened, go to the Azure portal, find your resource group, and locate the Function App we created. There, you can test the function right inside the Azure web portal. Or better yet, open Visual Studio Code (if you have that installed), create a new file called <code>test.http</code>, and add the following code:</p>
			<pre class="source-code">
GET https://myfileconverterfunctionapp.azurewebsites.net/api/Function1
Content-Type: application/json
{
     "name": "dennis"
}
###</pre>			<p>Replace my URL <a id="_idIndexMarker1094"/>with yours, and click the <strong class="bold">Send Request</strong> link at the top of the first line. This will call the <a id="_idIndexMarker1095"/>server. You’ll get some results that should look similar to the following:</p>
			<pre class="console">
HTTP/1.1 200 OK
Connection: close
Content-Type: text/plain; charset=utf-8
Date: Mon, 17 Jun 2024 07:07:01 GMT
Content-Encoding: gzip
Transfer-Encoding: chunked
Vary: Accept-Encoding
This HTTP triggered function executed successfully.</pre>			<p>Your data will be different, but the important part is that we get the <code>HTTP/1.1 200 OK</code> result. This shows that our app works!</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor292"/>Enabling continuous integration in Azure DevOps</h2>
			<p>Pushing to <a id="_idIndexMarker1096"/>Azure directly from your <a id="_idIndexMarker1097"/>development environment is convenient. Once you’ve set up the publishing profile, right-click on your program and click <strong class="bold">Publish</strong> to move your changes to Azure.</p>
			<p>There is a better way of doing this, though: you can enable CI/CD so that any change you make is automatically deployed.</p>
			<p class="callout-heading">Branching and CI/CD</p>
			<p class="callout">In all my samples, I use a single branch: <code>main</code>. I push changes from <code>main</code> on my machine directly to the online source repositories and let the systems build from that. In a real-world scenario, that is a terrible idea. You should pick up a branching strategy that allows for a good separation between the daily work and the deployments. You need things such as pull requests and merging strategies to preserve the quality of the work. Please don’t do what I’ve done here and have only a single branch.</p>
			<p>So, how do we achieve this magic? How do we get our changes “auto-magically” in our production environment? The answer is to use pipelines.</p>
			<p>In your <a id="_idIndexMarker1098"/>Azure DevOps environment, go to the project. You’ll see a <strong class="bold">Pipelines</strong> tab in the left sidebar. Click that. You’ll greeted<a id="_idIndexMarker1099"/> with a page saying you haven’t got any pipelines yet. Let’s change that. Click the <strong class="bold">Create Pipeline</strong> button. You’ll be taken to the following screen:</p>
			<div><div><img alt="Figure 13.7: Creating an Azure DevOps pipeline" src="img/B20924_14_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7: Creating an Azure DevOps pipeline</p>
			<p>In this case, select <strong class="bold">Azure Repos Git</strong>. When you click that, you’ll get a dialog asking for your project. Select the repository containing the code you want to deploy automatically.</p>
			<p>Once you have done that, you’re done. Yes – it was that easy.</p>
			<p>You can <a id="_idIndexMarker1100"/>now run the pipeline manually to see if<a id="_idIndexMarker1101"/> everything works. Building your solution will take a couple of minutes, but when it’s done, you’ll see something like this:</p>
			<div><div><img alt="Figure 13.8: Successful pipeline run" src="img/B20924_14_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8: Successful pipeline run</p>
			<p>To test if your code has been published, rerun the test from Visual Studio Code (or whatever tool you use to test REST calls).</p>
			<p>Now, it is time for the cool stuff.</p>
			<p>In Visual Studio, make a change to the code. You could do something simple, such as change the text the function returns.</p>
			<p>Save your <a id="_idIndexMarker1102"/>changes and push them to your repository. Once you’ve done that, go to Azure DevOps and find the pipeline – you’ll see that it’s already running! Just wait a few minutes until it is done and rerun your tests. You should see that your results have been propagated to the production environment.</p>
			<p>That’s what I call easy deployment!</p>
			<p>In case you<a id="_idIndexMarker1103"/> were wondering, the pipeline gets all the necessary information from your Publish profile. Remember when I said it was easier to do this if you publish manually first? Now you know why! You should look at the generated YAML files to see how things work. If you’re ready to take your deployment skills to the next level, I suggest that you search for this online. Dozens of books have been written on this topic, so I’m sure you can find what you’re looking for.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor293"/>Enabling CI from GitHub</h2>
			<p>Azure DevOps<a id="_idIndexMarker1104"/> is a great way to collaborate with people in the same organization. However, if you want to work with people across organizations, GitHub might be a better choice. GitHub is more geared toward open collaboration, such as open source projects. But that doesn’t mean you can’t have the same continuous integration as you have with Azure DevOps: you can achieve the same thing with GitHub Actions.</p>
			<p>Instead of having our source code in Azure DevOps, we host it in GitHub. Originally, GitHub was nothing more than a bunch of repositories, but they have expanded a lot since then. One of the more astonishing things they have added is GitHub actions.</p>
			<p>Actions are the equivalent of the pipelines we just looked at. The syntax is different, and they support many more environments than the default pipelines in Azure, but the idea remains the same.</p>
			<p>GitHub offers wizards to help you write your Actions, but there is a straightforward way to get our first Action up and running.</p>
			<p>Create a new Azure Function project in Visual Studio, but this time store it in your GitHub account. Once you’ve done that, test it locally and publish it to Azure. I always do this to make sure it works.</p>
			<p>Once the<a id="_idIndexMarker1105"/> publishing is done, create a test for your code using Visual Studio Code or your preferred test tool.</p>
			<p>Now, let’s set up CI/CD from GitHub!</p>
			<p>In the Azure portal, navigate to your function. Then, in the left sidebar, select <strong class="bold">Deployment Center</strong>. Then, under <strong class="bold">Source</strong>, select <strong class="bold">GitHub</strong>. After doing that, you can enter your details. You must log in to GitHub and select the correct organization, repository, and source branch you want to publish.</p>
			<p>You’ll also need to specify how you wish to authenticate. The GitHub action needs to log in to Azure to deploy your code, so the wizard will create an account for you. Use a user-assigned identity to make this happen. The identity will be created automatically. Once this has happened, click <strong class="bold">Save</strong>.</p>
			<p>And that is it – you’ve just set up your first GitHub Action! If you don’t believe me, go to your GitHub account, select your project, and go to <strong class="bold">Actions</strong>. You should see the action there, and it should show that it has already run as well!</p>
			<div><div><img alt="Figure 13.9: First Action" src="img/B20924_14_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9: First Action</p>
			<p>To check that it works as intended, you can change your code, commit the changes to the repository, and see the Action come to life. You can click on the run to see the details. When<a id="_idIndexMarker1106"/> you’re done, it will have updated the code in your Azure environment. Test it and see the changes!</p>
			<p>Of course, a lot of our code doesn’t run on Azure. As system programmers, we often have to deploy to local hardware. In that case, these techniques won’t work. We have to figure out a better way. And there is: using installers!</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor294"/>Building installers with Visual Studio</h1>
			<p>Installers <a id="_idIndexMarker1107"/>are nothing new – they were the only way to get an application on your system for a long time. Installers were primarily used to install Windows-based <a id="_idIndexMarker1108"/>applications on the users’ machines. They aren’t used that often anymore since this has become obsolete for most use cases. But installers are a great and simple way to get the job done if you wish to install a background worker process and need to do some custom work.</p>
			<p class="callout-heading">Installers and Wix</p>
			<p class="callout">The standard Microsoft Installer project works just fine. Still, many developers have moved away in favor of using Wix. Wix is a third-party solution for building installers. It is incredibly versatile, and thus, it is pretty hard to start using. Many books, articles, and how-tos are available to help you get up and running. But in our case, we don’t need that complexity. The standard installer is enough for most system programmers. But if you want more control, I urge you to dive into Wix and see what it can do for you.</p>
			<p>Suppose you installed the <strong class="bold">Microsoft Visual Studio Installer Projects 2022</strong> extension in Visual Studio. In that case, you can add an installer project to your solution.</p>
			<p>Let’s do that!</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor295"/>Building a simple installer</h2>
			<p>In the <strong class="bold">New Project</strong> dialog, select <a id="_idIndexMarker1109"/>the <strong class="bold">Setup Wizard</strong> template. This will start a typical “next, next, finish” type wizard. There are five steps to follow.</p>
			<p>The first one looks like this:</p>
			<div><div><img alt="Figure 13.10: Setup Wizard (1 of 5)" src="img/B20924_14_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10: Setup Wizard (1 of 5)</p>
			<p>The rest of<a id="_idIndexMarker1110"/> the screens are self-explanatory. The first real question asks you whether you want to build a setup program for a Windows application, a setup program for a web application, or whether you want to create a redistributable package. We want the first option: a setup for a Windows application since that is what a background worker system still is.</p>
			<p>Then, the wizard will want to know what you want to install. From the dropdown, select the <strong class="bold">Publish Items from…</strong> option. Those are all the executables and dependencies, so we want those.</p>
			<p>After, you’ll be asked if there are any other files you want to include. There aren’t, so just click <strong class="bold">Next</strong>. The last step is a summary of the previous steps. Review this page and click <strong class="bold">Finish</strong>.</p>
			<p>And that’s it!</p>
			<p>Before we can test it, we need to set some properties. Select your project in the <strong class="bold">Solution Explorer</strong> area and look at the <strong class="bold">Properties</strong> window. Here, you can fill in all the details you think <a id="_idIndexMarker1111"/>matter to you. Mine looks like this:</p>
			<div><div><img alt="Figure 13.11: Setting up project properties" src="img/B20924_14_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11: Setting up project properties</p>
			<p>You should at least change the <code>C:\Program Files (x86)</code> folder. If that’s not what you want, change the <code>TargetPlatform</code> property from <code>C:\Program Files</code> the default folder. Of course, you should only do that when your application is indeed 64-bit (the <strong class="bold">x64</strong> option) instead of the older 32-bit (<strong class="bold">x86</strong>) format.</p>
			<p class="callout-heading">Why is 64-bit X64, but 32-bit X86?</p>
			<p class="callout">Sometimes, people get confused by these names. People seem to get that X64 means 64-bit, but why on earth is 32-bit called X86? The answer is rather simple: X64 indeed is just 64-bit, but the X86 refers to the original Intel 8086 processor from long ago, when machines ran 16-bit or at most 32-bit software. It’s just a weird thing that you now know and can brag about to your friends!</p>
			<p>It’s time to test it all out!</p>
			<p>Right-click<a id="_idIndexMarker1112"/> on your <strong class="bold">Setup</strong> project, select <strong class="bold">Build</strong>, and see if everything builds. If it does, you can right-click on the project again, but select <strong class="bold">Install</strong> this time. If all goes well, your system will be installed! You can navigate to the folder you chose during installation and see your files there.</p>
			<p>To clean up, you only have to click <strong class="bold">uninstall</strong> in Visual Studio.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor296"/>Writing a Custom Action</h2>
			<p>This is nice, but it’s not enough. Especially for us system programmers, several other things need to<a id="_idIndexMarker1113"/> be done during or after installation. For instance, a worker process must be registered as a Windows service to start automatically. Or let’s say we have a secret that must be encrypted before we can store it in a settings file. How would we do that? The answer is we write a Custom Action.</p>
			<p><em class="italic">A Custom Action is some code in an external assembly that gets deployed with the Installer and called at the </em><em class="italic">right time.</em></p>
			<p>It’s not hard to write them: it’s all done in C#. And we know that language!</p>
			<p>First, let’s discuss what we want to do.</p>
			<p>In the previous chapter, we discussed secrets. We discovered we can use the .NET system to generate keys to encrypt and decrypt data. That key would only work on that machine since it is tied to the installed version of Windows for that particular user. That means we must encrypt any secret in the <code>appsettings</code> file on the target machine.</p>
			<p>So, suppose we deploy an unencrypted secret in a settings file. In that case, we must make sure that we encrypt the target machine during installation.</p>
			<p>In my sample, I am just replacing a placeholder with a new <code>GUID</code> to show how it’s done. But the principle stands.</p>
			<p>Add a new Class Library to the solution. However, there is one caveat: select the <strong class="bold">.NET Framework</strong> version of the Class Library. The MSI installer uses the “old” .NET framework, so <a id="_idIndexMarker1114"/>any add-ons must be built with that technology.</p>
			<p>Add a reference to <strong class="bold">System.Configuration.Install</strong> to the class library project, as I did here:</p>
			<div><div><img alt="Figure 13.12: Adding the System.Configuration.Install reference" src="img/B20924_14_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12: Adding the System.Configuration.Install reference</p>
			<p>Add a new item to the class library that’s of the <code>Installer</code> type. You can do that by right-clicking on the project and selecting <code>Installer</code>.  Call it <code>SecretsInstaller</code>. This can be seen in the following screenshot:</p>
			<div><div><img alt="Figure 13.13: Adding an installer class" src="img/B20924_14_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13: Adding an installer class</p>
			<p>Change the<a id="_idIndexMarker1115"/> code so that it looks like this:</p>
			<pre class="source-code">
[RunInstaller(true)]
public partial class SecretsInstaller : Installer
{
     public override void Install(IDictionary stateSaver)
     {
           base.Install(stateSaver);
           var secret = Guid.NewGuid().ToString();
           var targetDir =
                 Context.Parameters["targetdir"];
           var appSettingsPath =
                 Path.Combine(targetDir, "appsettings.json");
           if (File.Exists(appSettingsPath))
           {
                 var appSettingsContent =
                       File.ReadAllText(appSettingsPath);
                 appSettingsContent =
                       appSettingsContent.Replace(
                             "SECRET_PLACEHOLDER",
                             secret);
                 File.WriteAllText(
                       appSettingsPath,
                       appSettingsContent);
           }
     }
}</pre>			<p>This code <a id="_idIndexMarker1116"/>gets called by <code>Installer</code>. Here, I found the <code>appsettings.json</code> file, loaded it in memory, found the <code>SECRET_PLACEHOLDER</code> string, and replaced it with a <code>Guid</code> value. Finally, I wrote it back to the file.</p>
			<p>The interesting part is the line where I get the path to the file. I return to that one later, so keep that in mind.</p>
			<p>We need to register this class with <code>Installer</code>. Add a new <code>Installer</code> class to our class library, <code>ProjectInstaller</code>, and change the constructor. This code is even simpler than the last one:</p>
			<pre class="source-code">
[RunInstaller(true)]
public partial class ProjectInstaller : Installer
{
     public ProjectInstaller()
     {
           InitializeComponent();
           var secretsInstaller = new SecretsInstaller();
           Installers.Add(secretsInstaller);
     }
}</pre>			<p>In the <a id="_idIndexMarker1117"/>constructor, we create an instance of the <code>SecretsInstaller</code> class and add it to our <code>Installer</code>. This is a list of classes the install system looks at and then calls <code>Install</code> on.</p>
			<p>That is all the code we need to write. Let’s use it!</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor297"/>Incorporating the custom action in the setup</h2>
			<p>Go back<a id="_idIndexMarker1118"/> to <strong class="bold">Setup program</strong>. Right-click on the project, select <strong class="bold">Add…</strong>,  then <strong class="bold">Project output</strong>. Select the primary output of the <strong class="bold">Custom Action</strong> project. This ensures our DLL is part of the files that are being installed on the target machine.</p>
			<p>Right-click on <strong class="bold">Setup program</strong> again but select <strong class="bold">View</strong>, then <strong class="bold">Custom Actions…</strong>.</p>
			<p>You should see a screen with four categories. This determines when the custom action should be called. These options are as follows:</p>
			<ul>
				<li><strong class="bold">Install</strong>: This is when all files are installed</li>
				<li><strong class="bold">Commit</strong>: This is when the setup has finalized everything</li>
				<li><strong class="bold">Rollback</strong>: When the setup fails, this is called</li>
				<li><strong class="bold">Uninstall</strong>: When the user decides to install, these actions are performed</li>
			</ul>
			<p>In our case, we need to use <strong class="bold">Install</strong>. Right-click on that and select <strong class="bold">Add Custom Action</strong>. Once again, you’ll be presented with a dialog showing the target machine’s file structure. These are all the locations where our files can end up. Since we added our project output of the custom action to the regular installation, we can find it in the <strong class="bold">Application Folder</strong> area. Select the primary output from your Custom Action and click <strong class="bold">OK</strong>:</p>
			<div><div><img alt="Figure 13.14: Adding the Custom Action assembly" src="img/B20924_14_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14: Adding the Custom Action assembly</p>
			<p>Don’t leave the <a id="_idIndexMarker1119"/>Custom Action view yet. Click on the new item in the <strong class="bold">Install</strong> section, and look at the <strong class="bold">Properties</strong> area. Here, you can add all sorts of items, but the most important is <strong class="bold">CustomActionData</strong>.</p>
			<p>This is data from outside that gets passed as parameters to our custom action. Remember when I said I would get back to how I would get the path to the target directory? This is where I do that. Add the following line to that property:</p>
			<pre class="source-code">
/targetdir="[TARGETDIR]\ "</pre>			<p>Yes. A “backslash, space, closing quote” is at the end of that line. Don’t leave those out. Trust me: I spent hours determining why my actions didn’t work. The reason: I forgot that extra slash and space. It just doesn’t work without it.</p>
			<p>And that’s all there is to it!</p>
			<p>You can now build and then run <strong class="bold">Install</strong>.</p>
			<p>Look up the folder where the installation took place and marvel at the changes in the JSON file!</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor298"/>Using Docker</h1>
			<p>The most <a id="_idIndexMarker1120"/>used excuse developers use when someone complains the system doesn’t work as expected is “But it works on my machine!” Of course, the only suitable response is, “We do not ship your machine; we ship software.”</p>
			<p>Docker aims to be a solution to that problem.</p>
			<p>Docker is a highly complex topic. If you’re unaware of what it can do, please skip this part of this chapter until you’re more familiar with it. In short, Docker can act like a complete virtual machine. This principle means you can develop on that virtual machine, test on that virtual machine, and then deploy that virtual machine. In other words, if it works on that machine, it will work everywhere. The reason it will work everywhere is that with Docker, we ship your machine. Well, the virtual one, at least.</p>
			<p>Visual Studio has completely embraced Docker. The IDE comes packed with handy add-ons and wizards to help you use Docker.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor299"/>Adding Docker support to your background worker</h2>
			<p>If you<a id="_idIndexMarker1121"/> create a new project, such as a background worker, you can choose to add Docker support. But if you already have a project, you must add support later. It’s not hard to do: just right-click on the project, select <strong class="bold">Add</strong>, and then click <strong class="bold">Docker support</strong>. You can choose between <strong class="bold">Windows</strong> and <strong class="bold">Linux</strong>:</p>
			<div><div><img alt="Figure 13.15: Adding Docker to an existing project" src="img/B20924_14_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15: Adding Docker to an existing project</p>
			<p class="callout-heading">Docker – using Windows or Linux?</p>
			<p class="callout">If you’ve been working with Visual Studio for some time, you will likely choose Windows over Linux. After all, you probably know that platform very well. Why should you move to Linux? However, containerization comes from the Linux world: it is baked into the core of the operating system. Linux is a far better platform for containers than Windows. If you don’t need Windows features, I suggest that you take Linux as the base container. Your apps will benefit from that if you decide to use Docker.</p>
			<p>When you do this, a lot of things happen:</p>
			<ul>
				<li>A new file called <code>Dockerfile</code> is added to the project</li>
				<li>The <code>launchSettings.json</code> file is changed to add Docker</li>
				<li>In the background, all the necessary support images are installed</li>
				<li>The default start action is set to <strong class="bold">Container</strong> (Dockerfile)</li>
			</ul>
			<p>If you <a id="_idIndexMarker1122"/>start debugging, Visual Studio will build the Docker image with your binaries and start a container. You can add breakpoints to your code, and Visual Studio will also ensure the debugger is deployed in the container. Hence, it knows how to tunnel the debug information back and forth. The whole process is streamlined: you hardly notice you’re running on a Docker image instead of your host machine.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor300"/>Deploying your Docker images</h2>
			<p>Once <a id="_idIndexMarker1123"/>you’ve finished working on your code base and are ready to deploy it, you must figure out where to deploy it. There are three options:</p>
			<ul>
				<li>Use Docker Hub. This is the standard repository where you can store your images.</li>
				<li>Use Azure/AWS/Google Cloud to store your images. These are much more secure since you control these environments. For instance, you can create a container registry in Azure and then upload your images. Everybody in your organization can then pull that image and run it locally.</li>
				<li>Use your own repository. Suppose you don’t want to depend on a cloud provider but want complete control over where your images are. In that case, you can build your own repository.</li>
			</ul>
			<p>The third option is the most used one for our scenarios. Of course, you can use Docker Hub or Azure. Nothing is getting in your way. It’s just that for the things we build, the third option is probably the best.</p>
			<p>Building an actual<a id="_idIndexMarker1124"/> repository is hard. But the good news is that someone else has already done it. And they have put it in a Docker image. So, all we have to do is download that image and start it up.</p>
			<p>But before we do that, we need to think about security. There are many ways to secure the repository, but the easiest (and least secure) way is to assign a username/password. You need some code to generate those, but don’t worry: there’s a Docker image for that.</p>
			<p>First, create a folder named <code>C:\Auth</code>. Then, run the following command:</p>
			<pre class="console">
docker run --rm --entrypoint htpasswd httpd:2 -Bbn yourusername yourpassword &gt; C:\auth\htpasswd</pre>			<p>This command downloads the <code>http:2</code> image and runs it, gives it a username of <code>yourusername</code> and a password of <code>yourpassword</code> (I suggest that you use other values for those parameters), and stores the result in the <code>htpasswd</code> file in the <code>c:\auth</code> folder.</p>
			<p>Now, we can start the repository. Run the following command, all on one line:</p>
			<pre class="console">
docker run -d -p 5000:5000
  --name registry
  -v c:\auth:/auth
  -e "REGISTRY_AUTH=htpasswd"
  -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"
  -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd"               registry:2</pre>			<p>This command pulls the <code>registry:2</code> image from Docker Hub and starts it. It connects the internal folder, <code>/auth</code>, to our <code>c:\auth</code> directory and gives it some parameters.</p>
			<p>And that’s all there is to it.</p>
			<p>To use the repo, you must log in:</p>
			<pre class="console">
docker login localhost:5000</pre>			<p>Now, you <a id="_idIndexMarker1125"/>can tag and push your images there. In my case, my C# worker process image from Visual Studio is called <code>image13workerfordocker</code>.</p>
			<p>You can tag it by running the following command:</p>
			<pre class="console">
docker tag image13workerfordocker:dev localhost:5000/image13workerfordocker:dev</pre>			<p>Again, this is all one line. Now, I can push it to my local repository, like this:</p>
			<pre class="console">
docker push localhost:5000/image13workerfordocker:dev</pre>			<p>If I want to reuse my image, I can pull it:</p>
			<pre class="console">
docker pull localhost:5000/imagework13fordocker:dev</pre>			<p>I can use this repository just like I can with the ones at Docker Hub, Azure, AWS, or Google.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor301"/>Production-ready Docker repository</h2>
			<p>What I’ve <a id="_idIndexMarker1126"/>shown you here is just to show you the uttermost beginnings. The repository isn’t secure or stable and doesn’t even survive a reboot.</p>
			<p>There are several things you need to do if you want to use this in a real production environment:</p>
			<ul>
				<li>Harden the security by using TLS</li>
				<li>Install a volume so that you can store the images instead of using a container (hint: map a volume to <code>/var/lib/registry</code>)</li>
				<li>Use actual authentication instead of the single username/password I have just shown you</li>
				<li>Deploy the repository in a fail-safe environment such as Kubernetes</li>
			</ul>
			<p>But even with this setup, you can have your own repository. This will ensure that if the code works on your machine, it works everywhere!</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor302"/>Next steps</h1>
			<p>In this chapter, we discussed many ways you can get your software from your machine to other machines. Some were easy, others were hard. To be honest, this chapter was more about helping you start thinking about deployment. Each topic could fill hundreds of pages. For instance, I mentioned Wix. Well, dozens of books have been written on Wix alone. We discussed CI/CD in Azure in a couple of pages. It turns out people make a complete career out of that topic. We also looked at Docker: people spend weeks, if not months, getting up to speed on that topic.</p>
			<p>There are many ways you can get your code out there, and this chapter only scratched the surface.</p>
			<p>I wanted to show you the most common ones that fit scenarios we will most likely run into. It is up to you to determine which is the best for your use case and then dive deeper into it.</p>
			<p>But before I let you go, I need to say something about the dialog regarding Docker. The dialog asked if you wanted to use Linux or Windows. I suggest that you choose Linux as often as you can. If you think, “But I know very little about Linux,” don’t worry. The next chapter will tell you all you need to know about that operating system. So, let’s have a look, shall we?</p>
		</div>
	</body></html>