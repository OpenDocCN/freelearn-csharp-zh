<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Debugging</h1></div></div></div><p>Debugging is the process of finding, identifying, and fixing bugs (errors or mistakes) in your code, and there are many<a id="id135" class="indexterm"/> ways to achieve this. To script effectively, you'll need to be aware of the most common workflows and toolsets available to you for debugging in Unity. Before considering them further, however, it's important to be aware of the general<a id="id136" class="indexterm"/> limitations of debugging and what it cannot achieve. Debugging is not a magical cure-all to remove all bugs and guarantee an error-free application. The computer scientist Edsger W. Dijkstra said, <span class="emphasis"><em>"Program testing can be used to show the presence of bugs, but never to show their absence"</em></span>. The crucial point is that during testing, you might encounter one or more errors. These errors can be identified, tested, and repaired through debugging. Yet, your tests—though perhaps extensive and careful—will never cover every possible case or scenario on every hardware platform under all conditions, as these combinations could be practically infinite. So, you can never be absolutely certain to have found all the possible bugs. Even on the release day, there could still be bugs in your game, which your testing couldn't detect. Of course, there might actually be no bugs remaining at all, but you cannot know this with absolute certainty. So, debugging is not about achieving an error-free application. Its aims are more modest. It's about systematically testing your game in many common and reasonable situations to find and correct as many errors as you encounter or, at least, as many severe errors as your time and budget permits. In any case, debugging is a critical part of scripting, because without it, you will have no way of tracing and fixing errors. Debugging techniques range from simple to complex, and in this chapter, we'll cover a broad spectrum of them.</p><div class="section" title="Compilation errors and the console"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Compilation errors and the console</h1></div></div></div><p>Debugging typically refers to<a id="id137" class="indexterm"/> error-busting techniques for runtime use; that is, it refers to the things you can do to find and correct errors when your game is running. This understanding of debugging, of course, presupposes that your code is already valid and<a id="id138" class="indexterm"/> compiled. The implicit assumption is that you can write valid statements in C# and compile code, and you just want to find runtime errors that occur as a result of program logic. Thus, the focus is not on syntax but on logic, and this is indeed true. However, in this section, I'll speak very briefly about code compilation, about writing valid code, and using the console to find and correct errors of validity. This is important, both to introduce the <span class="strong"><strong>Console</strong></span> window generally and also to establish a firm basis of thinking about debugging in more depth. Consider the following code sample 2-1 script file (<code class="literal">ErrorScript.cs</code>):</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class ErrorScript : MonoBehaviour 
05 {
<span class="strong"><strong>06 int MyNumber = 5;</strong></span>
07 
08 // Use this for initialization
09 void Start () {
10 
<span class="strong"><strong>11        mynumber = 7;</strong></span>
12 }
13 
14 // Update is called once per frame
15 void Update () {
<span class="strong"><strong>16        mynumber = 10;</strong></span>
17 }
18 }</pre></div><p>To compile the preceding code sample 2-1, simply save the script file in MonoDevelop (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>S</em></span>) and then refocus the Unity Editor window. From here, compilation will happen automatically. If it doesn't, you<a id="id139" class="indexterm"/> can also right-click on the script file from the <span class="strong"><strong>Project</strong></span> panel and choose <span class="strong"><strong>Reimport</strong></span> from the context menu. For the code sample 2-1, two errors are generated, and these will be shown in the <span class="strong"><strong>Console</strong></span> window. If you don't already have the <span class="strong"><strong>Console</strong></span> window open, it could be shown by selecting the <span class="strong"><strong>Console</strong></span> option from <span class="strong"><strong>Window</strong></span> from the application menu. The <span class="strong"><strong>Console</strong></span> window is highly important, and you'll almost always want it open somewhere in the interface. This is where<a id="id140" class="indexterm"/> Unity as an engine communicates with you as a developer. Thus, if your code has compile errors, Unity would list them to <span class="strong"><strong>Console</strong></span>, letting you know what they are.</p><p>The code sample 2-1 generates two compile-time errors, as shown in the following screenshot. These happen because lines 11 and 16 refer to the variable <code class="literal">mynumber</code> that doesn't exist, although <code class="literal">MyNumber</code> does (case sensitivity). Compile-time errors such as these are critical because they render your code invalid. This means you cannot compile your code and run your game until the errors are corrected.</p><div class="mediaobject"><img src="graphics/0655OT_02_01.jpg" alt="Compilation errors and the console"/><div class="caption"><p>Viewing compilation errors in the Console window</p></div></div><p>If compilation errors are not shown in <span class="strong"><strong>Console</strong></span> as expected, then make sure that the errors filter is enabled. To enable this, click on the error filter icon (a red exclamation mark icon) in the top-right corner of the <span class="strong"><strong>Console</strong></span> window. The <span class="strong"><strong>Console</strong></span> window features three filters, comments (<span class="strong"><strong>A</strong></span>), warnings (<span class="strong"><strong>B</strong></span>), and errors (<span class="strong"><strong>C</strong></span>), as shown in the following screenshot, to hide and show specific <a id="id141" class="indexterm"/>messages. These toggle the visibility of each message type in the <span class="strong"><strong>Console</strong></span> window. Comments refer to the messages that you, as a programmer, explicitly print to the <span class="strong"><strong>Console</strong></span> window from your code using the <code class="literal">Debug.Log</code> statement. We'll see examples of this shortly (you can also use the <code class="literal">Print</code> function). Warnings refer<a id="id142" class="indexterm"/> to potential issues or wastages detected in your code. These are syntactically valid and will compile even if ignored by you, but they might cause problems or have unintended and wasteful results. Errors refer to any compile-time errors found in your code that affect its compilation validity, such as with code sample 2-1.</p><div class="mediaobject"><img src="graphics/0655OT_02_02.jpg" alt="Compilation errors and the console"/><div class="caption"><p>Enabling/disabling the Console window filters</p></div></div><p>When the console fills with more than one error, the errors are typically listed in the order in which they were detected by the compiler, that is, from top to bottom. It's considered best practice to tackle errors in order, because earlier errors can cause later ones. Thus, resolving earlier errors can, potentially, resolve later ones. To resolve an error, start by double-clicking on the error from the <span class="strong"><strong>Console</strong></span> window, and MonoDevelop will open automatically, highlighting the line where the error itself was found or where the error was first detected. It is important to note that MonoDevelop will take you to the line where the error was first detected, although resolving the error will not always involve editing that line specifically. Depending on the issue, you will need to change to a different line than the<a id="id143" class="indexterm"/>one highlighted. If you double-click on the top error (first error) in <span class="strong"><strong>Console</strong></span>, as generated by the code sample 2-1, MonoDevelop will open and<a id="id144" class="indexterm"/> highlight line 11. You can fix this error in two ways: either by renaming <code class="literal">mynumber</code> to <code class="literal">MyNumber</code> in line 11 or by renaming the variable <code class="literal">MyNumber</code> to <code class="literal">mynumber</code> in line 6. Now, consider the following code sample 2-2:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class ErrorScript : MonoBehaviour 
05 {
06 int MyNumber = 5;
07 
08 // Use this for initialization
09 void Start () {
10 	
11       MyNumber = 7;
12 }
13 
14 // Update is called once per frame
15 void Update () {
16       MyNumber = 10;
17 }
18 }</pre></div><p>Code sample 2-2 fixes the errors in code sample 2-1. However, it leaves us with a warning instead (as shown in the following screenshot). This indicates that the variable <code class="literal">MyNumber</code> is never used. It's assigned a value in lines 11 and 16, but this assignment is never of any ultimate<a id="id145" class="indexterm"/> consequence for the application. Here, this warning could be ignored and the code would remain valid. Warnings should be seen primarily as recommendations <a id="id146" class="indexterm"/>made by the compiler about your code. How you handle them is ultimately your choice, but I recommend that you try to eliminate both errors and warnings wherever practical.</p><div class="mediaobject"><img src="graphics/0655OT_02_03.jpg" alt="Compilation errors and the console"/><div class="caption"><p>Try to eliminate both errors and warnings</p></div></div></div></div>
<div class="section" title="Debugging with Debug.Log &#x2013; custom messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Debugging with Debug.Log – custom messages</h1></div></div></div><p>Perhaps, the oldest and <a id="id147" class="indexterm"/>most well-known debugging technique in Unity is to use <code class="literal">Debug.Log</code> statements to print diagnostic messages to <span class="strong"><strong>Console</strong></span>, thus illustrating program flow and object properties. This technique is versatile and appealing because it can be used in practically every<a id="id148" class="indexterm"/> <span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>) and not just MonoDevelop. Further, all the Unity objects, including vector and color objects, have a convenient<a id="id149" class="indexterm"/> <code class="literal">ToString</code> function that allows their internal members (such as <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, and <span class="emphasis"><em>Z</em></span>) to be printed to a human-readable string—one that can be easily sent to the console for debugging purposes. For example, consider the following code sample 2-3. This code sample demonstrates an important debugging workflow, namely, printing a status <a id="id150" class="indexterm"/>message about an object at its instantiation. This script, when attached to a scene object, prints its world position to <span class="strong"><strong>Console</strong></span>, along with a descriptive message:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class CubeScript : MonoBehaviour 
05 {
06 // Use this for initialization
07 void Start () {

08        Debug.Log ("Object created in scene at position: " + <span class="strong"><strong>transform.position.ToString()</strong></span>);<span class="strong"><strong>transform.position.ToString()</strong></span>);

09 }
10 }</pre></div><p>The following screenshot demonstrates the output of this code in <span class="strong"><strong>Console</strong></span> when attached to a cube <code class="literal">GameObject</code>. The <code class="literal">Debug.Log</code> message is printed in the main console message list. If the message is selected with the mouse, <span class="strong"><strong>Console</strong></span> will also indicate a script file and line associated with the statement.</p><div class="mediaobject"><img src="graphics/0655OT_02_04.jpg" alt="Debugging with Debug.Log – custom messages"/><div class="caption"><p>Debug.Log messages can convert objects to strings, and the Console window also indicates an associated script file and line</p></div></div><p>The main limitations of <code class="literal">Debug.Log</code> as a debugging technique relate to code cleanliness and program complexity. First, the <code class="literal">Debug.Log</code> statements require you to explicitly add code to your source files. When you're done debugging, you'll need to either remove the <code class="literal">Debug.Log</code> statements manually or leave them there, which is wasteful and results in confusion, especially if you have to add the additional <code class="literal">Debug.Log</code> statements in many other places. Second, though <code class="literal">Debug.Log</code> is useful to target specific problems or monitor specific variables over time, it's ultimately awkward to get a higher-level picture of your code and its execution to trace errors whose presence you detect but whose location is entirely unknown. These<a id="id151" class="indexterm"/> criticisms, however, shouldn't be regarded as advice to avoid using the <code class="literal">Debug.Log</code> statements entirely. They should be considered only to use them appropriately. <code class="literal">Debug.Log</code> works best when an error or problem can be traced to a prime suspect object, and you want to observe or monitor its values to see how they change or update, especially during events such as <code class="literal">OnStart</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<span class="strong"><strong>Removing the Debug.Log statements</strong></span>
</p><p>When your <a id="id152" class="indexterm"/>game is ready to build and ship, remember to remove or comment away any <code class="literal">Debug.Log</code> statements for extra cleanliness.</p></div></div></div>
<div class="section" title="Overriding the ToString method"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Overriding the ToString method</h1></div></div></div><p>The following code sample 2-3 demonstrates the convenience of the <code class="literal">ToString</code> method when used in conjunction with the <code class="literal">Debug.Log</code> debugging. <code class="literal">ToString</code> lets you convert an object to a human-readable string that can be output to <span class="strong"><strong>Console</strong></span>. In C#, every class inherits the <code class="literal">ToString</code> method<a id="id153" class="indexterm"/> by default. This means that using inheritance and polymorphism, you can override the <code class="literal">ToString</code> method of your class that customizes it as required and produce a more readable and accurate debug string that represents your class members. Consider the following code sample 2-4 that overrides <code class="literal">ToString</code>. If you get into the habit of overriding <code class="literal">ToString</code> for every class you make, your classes will become easier to debug:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//--------------------------------------------
//Sample enemy Ogre class
public class EnemyOgre : MonoBehaviour 
{
//--------------------------------------------
//Attack types for OGRE
public enum AttackType {PUNCH, MAGIC, SWORD, SPEAR};
 
//Current attack type being used
public AttackType CurrentAttack = AttackType.PUNCH;
 
//Health
public int Health = 100;
 
//Recovery Delay (after attacking)
public float RecoveryTime = 1.0f;
 
//Movement speed of Ogre - metres per second
public float Speed = 1.0f;
 
//Name of Ogre
public string OgreName = "Harry";
//--------------------------------------------
//Override ToString method
<span class="strong"><strong>public override string ToString ()</strong></span>
{
    //Return a string representing the class

          return <span class="strong"><strong>string.Format</strong></span> ("***Class EnemyOgre*** OgreName: {0} | Health: {1} | Speed: {2} | CurrentAttack: {3} | RecoveryTime: {4}", 
          OgreName, Health, Speed, CurrentAttack, RecoveryTime);
}
	
//--------------------------------------------
void Start()
{
 
            Debug.Log (ToString());
}
   //--------------------------------------------
}
//--------------------------------------------</pre></div><p>The output of the <a id="id154" class="indexterm"/>preceding code can be seen in the <span class="strong"><strong>Console</strong></span> window, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_05.jpg" alt="Overriding the ToString method"/><div class="caption"><p>Overriding the ToString method to customize debug messages for a class</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>
<span class="strong"><strong>String.Format</strong></span>
</p><p>Line 30 of the code sample 2-3 uses the <a id="id155" class="indexterm"/>
<code class="literal">String.Format</code> function to build a complete string. This function is useful when you need to make one long string that includes both literal statements and variable values, which could be different types. By inserting the tokens <code class="literal">{0}, {1}, {2}…</code> inside the string argument, the <code class="literal">Format</code> function will <a id="id156" class="indexterm"/>substitute them for the subsequent function arguments in the order in which they are provided; that is, <code class="literal">String.Format</code> will concatenate your string argument at the location of the tokens, with string versions of your function arguments. Thus, the string <code class="literal">{0}</code> will be replaced with <code class="literal">OgreName.ToString()</code>. For more information on <code class="literal">String.Format</code>, see the <a id="id157" class="indexterm"/>online documentation at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx</a>.</p></div></div><p>You can section off and isolate blocks of code between the release and debug versions that allow you to run debug-specific code when specific flags are enabled. When debugging games, for example, you'll frequently develop two sets or variations of code: the release code and the debug code. Imagine a common scenario where to find and resolve a bug in the code, you resort to inserting the <code class="literal">Debug.Log</code> statements that print out the values of variables and states of classes. You might even insert additional lines, such as <code class="literal">if</code> statements and <a id="id158" class="indexterm"/>loops, to test out alternative scenarios and explore how objects react. After amending the code for a while, the problem seems repaired, so you remove the additional debug code and continue testing as you did earlier. However, later, you discover that the problem has returned, or a similar one has arisen. So now you wish you'd kept the debug code after all, because it'd be useful again. You might promise yourself that next time, you'll simply comment out the debug code as opposed to deleting it entirely. This will let you simply remove the commenting should the code be needed again. However, of course, having to comment and uncomment code is also tedious, especially if there're many lines, and they are scattered across multiple files and parts of files. You can, however, resolve this problem and similar ones using custom global defines. In essence, a global define is a special preprocessor flag that you can enable or disable to conditionally compile or exclude blocks of your code. By setting the flag to <code class="literal">true</code>, Unity will automatically compile one version of your code, and by setting it to <code class="literal">false</code>, Unity will compile the other version. This will allow you to maintain two versions or variations of your code in only one set of source files: one for debug and one for release. Let's see this in practice in Unity. Consider the following code sample 2-5:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class CubeScript : MonoBehaviour 
05 {
06 // Use this for initialization
07 void Start ()
08 {
<span class="strong"><strong>09        #if SHOW_DEBUG_MESSAGES</strong></span>
10        //runs ONLY if the Define SHOW_DEBUG_MESSAGES is active
11        Debug.Log ("Pos: " + transform.position.ToString());
12       #endif
13 
14       //runs because it's outside the #if #endif block
15        Debug.Log ("Start function called");
16 }
17 }</pre></div><p>Lines 09–12 feature the core functionality using the preprocessor directives <code class="literal">#if</code> and <code class="literal">#endif</code> conditional. This conditional is not executed at runtime like a regular <code class="literal">if</code> statement, but at compile time. At compile time, Unity will decide whether the global define <code class="literal">SHOW_DEBUG_MESSAGES</code> is specified or active. If, and only if, it is, then lines 10 and 11 will be compiled, otherwise the compiler will ignore these lines, treating them as comments. Using this feature, you can isolate all debug code within an <code class="literal">#if #endif</code> block that checks for a debug define and activates and deactivates the code on the basis of the <code class="literal">SHOW_DEBUG_MESSAGES</code> define, which applies project-wide to all source files. The question that then remains is how is the define set. To set the global define, navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span> from the application menu. Then, enter the define name in the <span class="strong"><strong>Scripting Define Symbols</strong></span> field, making sure that you press the <span class="emphasis"><em>Enter</em></span> key after entering the name to <a id="id159" class="indexterm"/>confirm the change, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_02_06.jpg" alt="Overriding the ToString method"/><div class="caption"><p>Adding global custom defines from the Unity Editor, which lets you conditionally compile code</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>
<span class="strong"><strong>Removing defines and adding multiple defines</strong></span>
</p><p>Simply entering the name of your global define in the <span class="strong"><strong>Scripting Define Symbols</strong></span> field is<a id="id160" class="indexterm"/> enough for it to take effect and apply across your code. You can delete the name to remove the define, but you can also prefix the name with <code class="literal">/</code> (for example, <code class="literal">/SHOW_DEBUG_MESSAGE</code>) to disable the define, thus making it <a id="id161" class="indexterm"/>easier to re-enable it later. You can also add multiple defines, separating each with the semicolon symbol (for example, <code class="literal">DEFINE1;DEFINE2;DEFINE3…</code>).</p></div></div></div>
<div class="section" title="Visual debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Visual debugging</h1></div></div></div><p>Debugging with abstract or textual representations of data (such as <code class="literal">Debug.Log</code>) is often adequate but not <a id="id162" class="indexterm"/>always optimal. Sometimes, a picture is worth a thousand words. So, for example, when coding the line-of-sight functionality for enemies and other characters that allow them to see the player and other objects whenever they come in range, it's useful to get a live and graphical representation of where the line of sight actually is in the viewport. This line of functionality is drawn in terms of lines or as a wireframe cube. Similarly, if an object is following a path, it'd be great to draw this path in the viewport that displays it as a colored line. The purpose of this is not to create visual aids that will really show in the final game but simply to ease the debugging process that lets us get a better idea of how the game is working. These kinds of helpers or gizmos are a part of visual debugging. Unity already provides us with many gizmos automatically, such as the wireframe bounding box for colliders and frustum for cameras. However, we also have the ability to create our own gizmos for our own objects. This section explores gizmos further.</p><p>As mentioned earlier, many Unity objects, such as colliders, trigger volumes, NavMesh Agents, cameras, and lights, already offer their own visual aids and gizmos when they are selected. These are shown by default in the <span class="strong"><strong>Scene</strong></span> viewport unless you switch them off or reduce their size to zero. So, if you've added a native Unity object and don't see a gizmo in the <span class="strong"><strong>Scene</strong></span> viewport, then be sure to check the <span class="strong"><strong>Gizmo</strong></span> panel that is accessible from the <span class="strong"><strong>Scene</strong></span> toolbar via the <span class="strong"><strong>Gizmo</strong></span> button. Enable all the gizmos you want to see and adjust the <span class="strong"><strong>Size</strong></span> slider that increases or decreases the gizmo size (choose a size that is best for you), as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_07.jpg" alt="Visual debugging"/><div class="caption"><p>Enabling gizmos in the Scene view</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>
<span class="strong"><strong>Gizmos in the Game tab</strong></span>
</p><p>Gizmos don't show by default in the <span class="strong"><strong>Game</strong></span> tab. You can, however, change this behavior easily using the <span class="strong"><strong>Gizmo</strong></span> button in the top-right corner of the <span class="strong"><strong>Game</strong></span> tab toolbar. This menu <a id="id163" class="indexterm"/>works just like the <span class="strong"><strong>Gizmos</strong></span> menu for the <span class="strong"><strong>Scene</strong></span> tab, as shown in the preceding screenshot.</p></div></div><p>Consider the following<a id="id164" class="indexterm"/> code sample 2-6. This is a sample class that can be attached to an object and it relies on the Unity gizmo class to draw a custom range of helper <a id="id165" class="indexterm"/>gizmos. More information can be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Gizmos.html">http://docs.unity3d.com/ScriptReference/Gizmos.html</a>. Here, this sample class draws a bounding wireframe sphere of a specified radius centered on the object that represents its range of attack. In addition, it draws a line-of-sight vector that represents the object's forward direction, providing a visual indication of the way the object is facing. All of these gizmos are drawn inside the <code class="literal">OnDrawGizmos</code> event of <code class="literal">MonoBehaviour</code> on the condition that the variable <code class="literal">DrawGizmos</code> is <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class GizmoCube : MonoBehaviour
{
//Show debugging info?
<span class="strong"><strong>    public bool DrawGizmos = true;</strong></span>
 
    //Called to draw gizmos. Will always draw.
    //If you want to draw gizmos for only selected object, then call

    //OnDrawGizmosSelected
<span class="strong"><strong>    void OnDrawGizmos() </strong></span>
    {
        if(!DrawGizmos) return;
 
         //Set gizmo color
         Gizmos.color = Color.blue;
 
        //Draw front vector - show the direction I'm facing
<span class="strong"><strong>        Gizmos.DrawRay(transform.position, transform.forward.normalized *  4.0f);</strong></span>
 
          //Set gizmo color
          //Show proximity radius around cube
          //If cube were an enemy, they would detect the player within this radius
 
Gizmos.color = Color.red;
<span class="strong"><strong>          Gizmos.DrawWireSphere(transform.position, 4.0f);</strong></span>
 
          //Restore color back to white
          Gizmos.color = Color.white;
   }
}</pre></div><p>The following <a id="id166" class="indexterm"/>screenshot shows how to draw gizmos that helps with debugging:</p><div class="mediaobject"><img src="graphics/0655OT_02_08.jpg" alt="Visual debugging"/><div class="caption"><p>Drawing gizmos</p></div></div></div>
<div class="section" title="Error logging"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Error logging</h1></div></div></div><p>When you compile and build your game to distribute to testers, whether they're collected together in an office or scattered across the globe, you'll need a way to record errors and exceptions as and when they happen during gameplay. One way to do this is through logfiles. Logfiles are human-readable text files that are generated on the local computer by the game at runtime, and they record the details of errors as they occur, if any occur at all. The amount of information<a id="id167" class="indexterm"/> you record is a matter for careful consideration, as logging too much detail can obfuscate the file and too little can render the file useless. However, once a balance is reached the tester will be able to send you the log for inspection, and this will, hopefully, allow you to quickly pin-point errors in your code and repair them effectively, that is without introducing new errors! There are many ways to implement logging behavior in Unity. One way is using the native <code class="literal">Application</code> class to receive exception notifications by way of delegates. Consider the following code sample 2-7:</p><div class="informalexample"><pre class="programlisting"> 01 //------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
<span class="strong"><strong> 04 using System.IO;</strong></span>
 05 //------------------------------------------------
 06 public class ExceptionLogger : MonoBehaviour 
 07 {
 08      //Internal reference to stream writer object
 09      private System.IO.StreamWriter SW;
 10 
 11      //Filename to assign log
 12      public string LogFileName = "log.txt";
 13 
 14      //------------------------------------------------
 15      // Use this for initialization
 16      void Start () 
 17      {
 18             //Make persistent
 19             DontDestroyOnLoad(gameObject);
 20 
 21      //Create string writer object

 22       SW = new System.IO.StreamWriter(Application.persistentDataPath + "/" + LogFileName);

 23 
 24      Debug.Log(Application.persistentDataPath + "/" + LogFileName);

 25       }
 26       //------------------------------------------------
 27      //Register for exception listening, and log exceptions
 28      void OnEnable() 
 29      {
<span class="strong"><strong> 30            Application.RegisterLogCallback(HandleLog);</strong></span>
 31      }
 32      //------------------------------------------------
 33      //Unregister for exception listening
 34      void OnDisable() 
 35      {
 <span class="strong"><strong>36           Application.RegisterLogCallback(null);</strong></span>
 37      }
 38       //------------------------------------------------
 39       //Log exception to a text file

 <span class="strong"><strong>40       void HandleLog(string logString, string stackTrace, LogType type)</strong></span>

 41      {
 42      //If an exception or error, then log to file
 43      if(type == LogType.Exception || type == LogType.Error)
 44             {

 45 <span class="strong"><strong>                 SW.WriteLine</strong></span>("Logged at: " + System.DateTime.Now.ToString() + " - Log Desc: " + logString + " - Trace: " + stackTrace + " - Type: " + type.ToString());

 46             }
 47       }
 48       //------------------------------------------------
 49       //Called when object is destroyed
 50       void OnDestroy()
 51       {
 52             //Close file
 53             SW.Close();
 54       }
 55       //------------------------------------------------
 56 }
 57 //------------------------------------------------</pre></div><p>The following <a id="id168" class="indexterm"/>are the comments for code sample 2-7:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 22</strong></span>: A new <code class="literal">StreamWriter</code> object is created to write debug strings to a file on the computer. The file is created inside <code class="literal">Application.persistentDataPath</code>; this points to a system location that is always writable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 30</strong></span>: The <code class="literal">Application.RegisterLogCallBack</code> method is invoked with a function reference to <code class="literal">HandleLog</code> as an argument. This relies on delegates. In short, a reference to the <code class="literal">HandleLog</code> function is passed, and this will be called when an error or exception occurs that allows us to write details to a logfile.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 45</strong></span>: The <code class="literal">WriteLine</code> method of <code class="literal">StreamWriter</code> is called to print textual data to the logfile when an error occurs. The error information is provided by Unity through the <code class="literal">HandleLog</code> arguments: <code class="literal">logString</code>, <code class="literal">stackTrace</code>, and <code class="literal">LogType</code>. The <code class="literal">StreamWriter</code> class is part of the Mono Framework, which is an open source implementation of the Microsoft NET Framework. More information on <code class="literal">StreamWriter</code> can<a id="id169" class="indexterm"/> be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx</a>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>One of the quickest ways to test out your error logger is to create a divide by zero error. Don't forget to insert a <code class="literal">Debug.Log (Application.persistentDataPath);</code> line somewhere in your code to print the logfile path to the <span class="strong"><strong>Console</strong></span> window. This can help you quickly find the logfile on your system via Windows Explorer or Mac Finder. Note that the <code class="literal">persistentDataPath</code> variable is used as opposed to an absolute path, because it varies from operating system to operating system.</p></div></div></li></ul></div><p>The following<a id="id170" class="indexterm"/> screenshot shows how to print errors to a text-based logfile:</p><div class="mediaobject"><img src="graphics/0655OT_02_09.jpg" alt="Error logging"/><div class="caption"><p>Printing errors to a text-based logfile can make debugging and bug fixing easier</p></div></div><p>What are delegates in C#? Imagine that you're able to create a variable and assign it a function reference instead of a regular value. Having done this, you can invoke the variable just like a function to call the referenced function at a later time. You can even reassign the variable to reference a new and different function later. This, in essence, is how delegates work. If you're familiar with C++, delegates are practically equivalent to the function pointers. Thus, delegates are special types that can reference and invoke functions. They're ideal to create extensible callback systems and event notifications. For example, by keeping a list or array of delegate types, potentially, many different classes can register themselves as listeners for callbacks by adding themselves to the list. More information on C# can be<a id="id171" class="indexterm"/> found at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/ms173171.aspx">http://msdn.microsoft.com/en-gb/library/ms173171.aspx</a>. Consider the following code sample 2-8 for an example of the delegate usage in C# with Unity:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//---------------------------------------------------
public class DelegateUsage : MonoBehaviour 
{
 //Defines delegate type: param list
 public delegate void EventHandler(int Param1, int Param2);
//---------------------------------------------------
//Declare array of references to functions from Delegate type - max 10 events

public EventHandler[] EH = new EventHandler[10];
//---------------------------------------------------
/// &lt;summary&gt;
/// Awake is called before start. Will add my Delegate HandleMyEvent to list
/// &lt;/summary&gt;
void Awake()
{
    //Add my event (HandleMyEvent) to delegate list
    EH[0] = HandleMyEvent;
}
//---------------------------------------------------
/// &lt;summary&gt;
/// Will cycle through delegate list and call all events
/// &lt;/summary&gt;
 void Start()
 {
    //Loop through all delegates in list
    foreach(EventHandler e in EH) 
    {
          //Call event here, if not null
          if(e!=null)
               e(0,0); //This calls the event
    }
 }
//---------------------------------------------------
/// &lt;summary&gt;
/// This is a sample delegate event. Can be referenced by Delegate Type EventHandler
/// &lt;/summary&gt;
/// &lt;param name="Param1"&gt;Example param&lt;/param&gt;
/// &lt;param name="Param2"&gt;Example param&lt;/param&gt;
 void HandleMyEvent (int Param1, int Param2)
 {
    Debug.Log ("Event Called");
 }
//---------------------------------------------------</pre></div></div>
<div class="section" title="Editor debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Editor debugging</h1></div></div></div><p>It's sometimes claimed that <a id="id172" class="indexterm"/>Unity has no debugging tools built into the editor, but this is not quite true. With Unity, you can play your game and edit the scene at the same time while the game is running. You can even observe and edit properties in the Object Inspector, both private and public, as we saw earlier. This can give you a complete and graphical picture of your game at runtime; and allow you to detect and observe a wide range of potential errors. This form of debugging should not be underestimated. To get the most from in-editor debugging, activate the <span class="strong"><strong>Debug</strong></span> mode from the Object Inspector by clicking on the context menu icon in the top-right corner of the inspector and then choose <span class="strong"><strong>Debug</strong></span> from the menu, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_10.jpg" alt="Editor debugging"/><div class="caption"><p>Accessing the Debug mode from the Object Inspector</p></div></div><p>Next, make sure that your viewports are configured appropriately so that they allow you to see both the <span class="strong"><strong>Scene</strong></span> and <span class="strong"><strong>Game</strong></span> views simultaneously during the <span class="strong"><strong>Play</strong></span> mode, along with the <span class="strong"><strong>Stats</strong></span> panel. To achieve this, disable the <span class="strong"><strong>Maximize on Play</strong></span> button from the <span class="strong"><strong>Game</strong></span> tab toolbar if it's activated. Then, arrange the <span class="strong"><strong>Scene</strong></span> and <span class="strong"><strong>Game</strong></span> tabs side-by-side in the interface, or else arrange them across multiple monitors if you have more than one. Multiple monitors are strongly recommended if your budget allows, but a single monitor can work well too, provided you invest extra time arranging and sizing each window to best meet your needs. In addition, you'll generally want the <span class="strong"><strong>Console</strong></span> window visible and the <span class="strong"><strong>Project</strong></span> panel hidden to prevent accidental selection and movement of assets, as shown in the following<a id="id173" class="indexterm"/> screenshot. Remember that you can also <a id="id174" class="indexterm"/>customize the Unity GUI Layout. For more information see <a class="ulink" href="http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html">http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html</a>.</p><div class="mediaobject"><img src="graphics/0655OT_02_11.jpg" alt="Editor debugging"/><div class="caption"><p>Debugging games from the editor using a single monitor layout</p></div></div><p>Once you're ready for in-editor debugging, click on the play button on the toolbar and use pause if you ever need to stop game events to inspect a specific object and its values from the Object Inspector. Remember that you can still use the transform (position, rotation, and scale) tools in-game to reposition the player or enemies, thus trying out new values and seeing which ones work and which ones do not. Most importantly, however, all edits to the scene in the <span class="strong"><strong>Game</strong></span> mode, via the Object Inspector or transform tools, are temporary and will revert back after the <span class="strong"><strong>Play</strong></span> mode ends. For this reason, if you need to make permanent changes to settings, then you would need to make them in the <span class="strong"><strong>Edit</strong></span> mode. You can, of course, copy and paste values between the <span class="strong"><strong>Play</strong></span> and <span class="strong"><strong>Edit</strong></span> modes using the <span class="strong"><strong>Component</strong></span> context menu at any time, as shown in the following screenshot. Remember that the hot key (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>P</em></span>) toggles between the <span class="strong"><strong>Play</strong></span> mode and (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span> between paused and unpaused). A full list of Unity hot<a id="id175" class="indexterm"/> keys is listed at <a class="ulink" href="http://docs.unity3d.com/Manual/UnityHotkeys.html">http://docs.unity3d.com/Manual/UnityHotkeys.html</a>.</p><div class="mediaobject"><img src="graphics/0655OT_02_12.jpg" alt="Editor debugging"/><div class="caption"><p>Copying and pasting component values via the Component context menu</p></div></div></div>
<div class="section" title="Using the profiler"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Using the profiler</h1></div></div></div><p>One additional tool that's used partly for debugging and partly for optimization is the <span class="strong"><strong>Profiler</strong></span> window, which is available only in Unity Pro by clicking on the <span class="strong"><strong>Profiler</strong></span> tab in <span class="strong"><strong>Window</strong></span> in the application menu, as shown in the following screenshot. In short, the profiler gives you a statistical top-down view of how time and workload is distributed across the different parts of your game and across system hardware components, such as the CPU and graphics card. Using profiler, you can determine, for example, how much time is consumed by camera<a id="id176" class="indexterm"/> rendering in the scene compared to physics calculations or to audio functionality, as well as to other categories. It lets you measure performance, compare numbers, and assess where performance can be improved. The profiler is not really a tool that alerts you to the presence of bugs in your code specifically. However, if you're experiencing performance problems in running the game, such as lags and freezes, then it could guide you to where optimizations can be made. For this reason, the profiler is a tool to which you'll turn if you decide that performance is an issue for your game and you need an educated, studied analysis of where to start implementing improvements.</p><div class="mediaobject"><img src="graphics/0655OT_02_13.jpg" alt="Using the profiler"/><div class="caption"><p>The profiler is typically used to diagnose performance issues</p></div></div><p>When you run your game with the <span class="strong"><strong>Profiler</strong></span> window open, the graph will populate with statistics about the most recent frames. The profiler doesn't usually record information about all the frames since the game began, but only the most recent ones as will fit into memory sensibly. There is a toggleable "deep profile" method available in the upper toolbar of the <span class="strong"><strong>Profiler</strong></span> <a id="id177" class="indexterm"/>window, which allows you (in theory) to get extra information about your game, but I'd recommend that you avoid this mode. It can cause performance issues with the Unity Editor when running asset-heavy and code-heavy games, and it can even freeze the editor altogether. Instead, I'd recommend that you only use the default mode. When using this mode, in most cases, you'll want to disable the visualization of <span class="strong"><strong>VSync</strong></span> from the <span class="strong"><strong>CPU Usage</strong></span> area to get a better view of other performance statistics, including <span class="strong"><strong>Rendering</strong></span> and <span class="strong"><strong>Scripts</strong></span>, as shown in the following screenshot. To do this, simply click on the <span class="strong"><strong>VSync</strong></span> icon in the graph index area:</p><div class="mediaobject"><img src="graphics/0655OT_02_14.jpg" alt="Using the profiler"/><div class="caption"><p>Disabling the VSync display from the CPU usage area in the Profiler window</p></div></div><p>The horizontal axis of the graph represents frames—the most recent frames added to the memory buffer. This axis keeps populating with new data while the game is running. The vertical axis represents time or computational expense: higher values are expressive of a more demanding and slower frame time. After the graph is filled with some data during the <span class="strong"><strong>Play</strong></span> mode, you can pause the game to examine its state. Select the frames from the graph to view more information on game performance during that frame. When you do this, the <span class="strong"><strong>Hierarchy</strong></span> panel in the bottom half of the <span class="strong"><strong>Profile</strong></span> window fills with function data about the code that is being executed on the selected frame. When viewing the graph, it's good practice<a id="id178" class="indexterm"/> to watch for sudden increases (peaks or spikes), as shown in the following screenshot. These indicate frames of sudden and intense activity. Sometimes, they can be one-off occurrences that are either unavoidable due to hardware operations or that happen legitimately and are not the source of performance problems, such as scene transitions or loading screens.</p><p>However, they can indicate trouble too, especially if they happen regularly. So, when diagnosing performance issues, looking for spikes is a good place to start your investigation.</p><div class="mediaobject"><img src="graphics/0655OT_02_15.jpg" alt="Using the profiler"/><div class="caption"><p>Selecting a frame from the profiler graph</p></div></div><p>The <span class="strong"><strong>Hierarchy</strong></span> view lists all the main functions and events in code that executes on the selected frame. For each<a id="id179" class="indexterm"/> function, there are several crucial properties such as <span class="strong"><strong>Total</strong></span>, <span class="strong"><strong>Self</strong></span>, <span class="strong"><strong>Time ms</strong></span>, and <span class="strong"><strong>Self ms</strong></span>, which are shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_16.jpg" alt="Using the profiler"/><div class="caption"><p>Examining function calls during selected frames</p></div></div><p>Let' s discuss these crucial properties in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Total and Time ms</strong></span>: The <span class="strong"><strong>Total</strong></span> column represents the proportion of frame time consumed by the function. The value of <span class="strong"><strong>49.1%</strong></span>, for example, means that 49.1 percent of the total time required for the selected frame was consumed by the function, including any time taken to call subfunctions (functions called within the function). The <span class="strong"><strong>Time ms</strong></span> column expresses the frame consumption time in absolute terms, measured in milliseconds. Together, these two values give you both a relative and absolute measure of how expensive calling the function is on each frame and in total.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Self and Self ms</strong></span>: The <span class="strong"><strong>Total</strong></span> and <span class="strong"><strong>Total ms</strong></span> settings measure the expense of the function for the selected frame, but they include the total time spent inside other functions that were invoked from within the function. Both <span class="strong"><strong>Self</strong></span> and <span class="strong"><strong>Self ms</strong></span> exclude this time and express only the total time spent within the function, minus any <a id="id180" class="indexterm"/>additional time waiting for other functions to complete. These values are often the most important when seeking to pinpoint a specific function that causes performance problems.</li></ul></div><p>More information on the <a id="id181" class="indexterm"/>Unity Profiler can be found at <a class="ulink" href="http://docs.unity3d.com/Manual/ProfilerWindow.html">http://docs.unity3d.com/Manual/ProfilerWindow.html</a>.</p></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; getting started"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Debugging with MonoDevelop – getting started</h1></div></div></div><p>Earlier, we encountered the <code class="literal">Debug.Log</code> method of debugging to print helper messages to the console at critical moments in the code to help us see how the program executes. This method, while functional, however, suffers some significant drawbacks. First off, when writing larger programs with many <code class="literal">Debug.Log</code> statements it's easy to effectively "spam" the console with <a id="id182" class="indexterm"/>excessive messages. This makes it difficult to differentiate between the ones you need and the ones you don't. Second, it's generally a bad practice to change your code by inserting the <code class="literal">Debug.Log</code> statements simply to monitor program flow and find errors. Ideally, we should be able to debug without changing our code. Therefore, we have compelling reasons to find <a id="id183" class="indexterm"/>alternative ways to debug. MonoDevelop can help us here. Specifically, in the latest releases of Unity, MonoDevelop can natively attach itself to a running Unity process. In doing this, we get access to a range of common debugging tools, the kind encountered when developing other types of software, such as breakpoints and traces. Presently, the connectivity between MonoDevelop and Unity can be buggy however, for some users on some systems. However, when working as intended, MonoDevelop can offer a rich and useful debugging experience that allows us to move beyond simply writing the <code class="literal">Debug.Log</code> statements.</p><p>To start debugging with MonoDevelop, let's consider breakpoints. When debugging code, you'll likely need to observe the program flow when it reaches a specified line. A breakpoint lets you mark one or more lines in a source file from MonoDevelop, and when the program runs in Unity, its execution will pause at the first breakpoint. At this pause, you get the opportunity to examine the code and the status of variables as well as to inspect and edit their values. You can also continue execution with stepping. This lets you push execution forward to the next line, following the normal program logic line-by-line. You get the opportunity of inspecting your code in each line as it passes. Let's see an example case. The following code sample 2-9 shows a simple script file. When attached to an object, it retrieves a list of all objects in the scene (including itself) and then<a id="id184" class="indexterm"/> sets their position to the world origin (0, 0, 0) when the <span class="strong"><strong>Start</strong></span> function is executed, which occurs at level startup:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
 
public class DebugTest : MonoBehaviour 
{
   // Use this for initialization
void Start () 
    {
         //Get all game objects in scene
         Transform[] Objs = Object.FindObjectsOfType&lt;Transform&gt;();
 
         //Cycle through all objects
         for(int i=0; i&lt;Objs.Length; i++)
         {
               //Set object to world origin
<span class="strong"><strong>               Objs[i].position = Vector3.zero;</strong></span>
         }
    }
 }</pre></div><p>Let's set a breakpoint in the highlighted line via MonoDevelop. This will pause the program execution whenever it reaches this line. To set the breakpoint, position your mouse cursor on the highlighted line, right-click on the left-hand gray margin, and choose <span class="strong"><strong>New Breakpoint</strong></span>. Otherwise, use the MonoDevelop application menu to choose the <span class="strong"><strong>New Breakpoint</strong></span> option in <span class="strong"><strong>Run</strong></span>, or you can also press the <span class="emphasis"><em>F9</em></span> key (or you can left-click on the line number), as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_17.jpg" alt="Debugging with MonoDevelop – getting started"/><div class="caption"><p>Creating a new breakpoint in MonoDevelop</p></div></div><p>The breakpoint line will be highlighted in red. To get this breakpoint to work properly with Unity when the <a id="id185" class="indexterm"/>game runs, you'll need to attach MonoDevelop to the running Unity process. To do this, make sure that the Unity Editor is running alongside MonoDevelop and then choose the <span class="strong"><strong>Attach to Process</strong></span> option from <span class="strong"><strong>Run</strong></span> from the MonoDevelop application menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_02_18.jpg" alt="Debugging with MonoDevelop – getting started"/><div class="caption"><p>Attach to Process</p></div></div><p>The <span class="strong"><strong>Attach to Process</strong></span> dialog appears, and the <span class="strong"><strong>Unity Editor</strong></span> should be listed as <span class="strong"><strong>Process Name</strong></span> to which MonoDevelop can be attached. The <span class="strong"><strong>Debugger</strong></span> drop-down list in the bottom-left corner of the<a id="id186" class="indexterm"/> window should be specified as <span class="strong"><strong>Unity Debugger</strong></span>. Select the <span class="strong"><strong>Unity Editor</strong></span> option and then choose the <span class="strong"><strong>Attach</strong></span> button, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_19.jpg" alt="Debugging with MonoDevelop – getting started"/><div class="caption"><p>Select Unity Editor from the Attach to Process dialog</p></div></div><p>When MonoDevelop is attached to Unity as a process, two new bottom-aligned panes will dock themselves to the MonoDevelop interface, and these include the <span class="strong"><strong>Watch</strong></span> window and the <span class="strong"><strong>Immediate</strong></span> window, as shown in the following screenshot. These windows offer additional<a id="id187" class="indexterm"/> debugging information and views when your game runs in the Unity Editor, as we'll see in the next section.</p><div class="mediaobject"><img src="graphics/0655OT_02_20.jpg" alt="Debugging with MonoDevelop – getting started"/><div class="caption"><p>Two new panes dock themselves to MonoDevelop when attaching to a Unity process</p></div></div><p>Next, return to the Unity Editor and make sure that the script file <code class="literal">DebugTest.cs</code>, as shown in code sample 2-9, is attached to an object in the scene and that the scene includes other objects (any objects, such as cubes or cylinders). Then, run your game using the play button from the Unity toolbar, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_21.jpg" alt="Debugging with MonoDevelop – getting started"/><div class="caption"><p>Running from the Unity Editor in preparation for debugging with MonoDevelop</p></div></div><p>When you press the play button on the Unity toolbar with MonoDevelop attached, the execution of Unity will freeze when the breakpoint is reached (the break mode). The focus will switch to the MonoDevelop window with the breakpoint line highlighted in yellow inside the source<a id="id188" class="indexterm"/> file that indicates the current step of execution, as shown in the following screenshot. During this mode, you cannot use the Unity Editor, and you cannot switch between viewports or even edit settings inside the Object Inspector as you can with in-editor debugging. MonoDevelop is waiting exclusively for your input to resume execution. The next few sections will consider some useful debugging tools that you can use in the break mode.</p><div class="mediaobject"><img src="graphics/0655OT_02_22.jpg" alt="Debugging with MonoDevelop – getting started"/><div class="caption"><p>Entering the break mode from within MonoDevelop</p></div></div></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; the Watch window"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Debugging with MonoDevelop – the Watch window</h1></div></div></div><p>A <span class="strong"><strong>Watch</strong></span> window allows you to view the value of a variable that's active in memory in the current step, and this includes both local and global variables. One way to quickly add a watch for a variable while it is<a id="id189" class="indexterm"/> in the break mode is to highlight it in the code editor and then hover your mouse over it. When you do this, leaving the mouse hovered <a id="id190" class="indexterm"/>for a few seconds, a pop-up window appears automatically. This window allows the full inspection of a variable, as shown in the following screenshot. You can contract and expand the members of a class and examine the state of all its variables.</p><div class="mediaobject"><img src="graphics/0655OT_02_23.jpg" alt="Debugging with MonoDevelop – the Watch window"/><div class="caption"><p>Inspecting a variable with hover watches in the break mode</p></div></div><p>You can inspect practically all variable values for any active object using this hover method. However, typically, you'll want to place a more permanent watch on a variable and even a group of variables<a id="id191" class="indexterm"/> so that you can see their values collated together in a list. For this, you can use the <span class="strong"><strong>Watch</strong></span> window docked in the<a id="id192" class="indexterm"/> bottom-left corner of the MonoDevelop interface. To add a new watch in this window, right-click inside the <span class="strong"><strong>Watch</strong></span> list and choose <span class="strong"><strong>Add watch</strong></span> from the context menu, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_24.jpg" alt="Debugging with MonoDevelop – the Watch window"/><div class="caption"><p>Adding a watch to the Watch window</p></div></div><p>On adding a new watch, you can enter any valid expression or variable name in the <span class="strong"><strong>Name</strong></span> field, and the resultant<a id="id193" class="indexterm"/> value will be shown in the <span class="strong"><strong>Value</strong></span> column, as shown in the following screenshot. The values shown in the <span class="strong"><strong>Watch</strong></span> field are valid for the current line of execution only, and they<a id="id194" class="indexterm"/> will change as the program progresses. Remember that you can add a watch for any valid variable that can be referenced in the current scope, including <code class="literal">name</code>, <code class="literal">tag</code>, <code class="literal">transform.position</code>, and so on.</p><div class="mediaobject"><img src="graphics/0655OT_02_25.jpg" alt="Debugging with MonoDevelop – the Watch window"/><div class="caption"><p>Adding a watch to the Watch window</p></div></div><p>You can use the <span class="strong"><strong>Watch</strong></span> window to examine any valid variables and expressions, whether they pertain to the active class or line of code. This means you can see the value for global variables and any variables related to other classes or objects, as long as they're valid and in memory. However, if you're only interested in viewing local variables, that is, variables whose scope is relevant to the block of code being executed in the current step, then you could use<a id="id195" class="indexterm"/> the <span class="strong"><strong>Locals</strong></span> window instead of <span class="strong"><strong>Watch</strong></span>. This window automatically adds watches for all the local variables. You don't need to <a id="id196" class="indexterm"/>add them manually. Here, the <span class="strong"><strong>Locals</strong></span> window is by default tabbed next to the <span class="strong"><strong>Watch</strong></span> window:</p><div class="mediaobject"><img src="graphics/0655OT_02_26.jpg" alt="Debugging with MonoDevelop – the Watch window"/><div class="caption"><p>Inspecting local variables only with the Locals window</p></div></div><p>If you don't see any of the relevant <span class="strong"><strong>Debug</strong></span> windows in the MonoDevelop interface, such as the <span class="strong"><strong>Watch</strong></span> window or the <span class="strong"><strong>Locals</strong></span> window, you can show or hide them manually by clicking on the <span class="strong"><strong>Debug Windows</strong></span> option in <span class="strong"><strong>View</strong></span> from the MonoDevelop application menu:</p><div class="mediaobject"><img src="graphics/0655OT_02_27.jpg" alt="Debugging with MonoDevelop – the Watch window"/></div><p>One great thing about the <span class="strong"><strong>Watch</strong></span> and <span class="strong"><strong>Locals</strong></span> windows is that they offer read and write access to variables. This means that you're not restricted to simply viewing variable values, but you can write to them as well, changing the variable from within MonoDevelop. To do<a id="id197" class="indexterm"/> this, simply double-click on<a id="id198" class="indexterm"/> the <span class="strong"><strong>Value</strong></span> field from either the <span class="strong"><strong>Watch</strong></span> or <span class="strong"><strong>Locals</strong></span> window and then enter a new value for the variable:</p><div class="mediaobject"><img src="graphics/0655OT_02_28.jpg" alt="Debugging with MonoDevelop – the Watch window"/><div class="caption"><p>Editing values from the Watch window</p></div></div></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; continue and stepping"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Debugging with MonoDevelop – continue and stepping</h1></div></div></div><p>After reaching a breakpoint and inspecting your code, it's likely that you'll want to exit from the break mode and continue<a id="id199" class="indexterm"/> program execution in some way. You might want to continue program execution, which effectively hands program control back to Unity. This allows the execution to continue as normal, until it meets the next breakpoint, if any. This method effectively resumes execution as normal, and it'll never pause again unless a new breakpoint is encountered. To<a id="id200" class="indexterm"/> continue in this way from MonoDevelop, press the <span class="emphasis"><em>F5</em></span> key or press the play button from the MonoDevelop toolbar. Otherwise, choose the <span class="strong"><strong>Continue Debugging</strong></span> option in <span class="strong"><strong>Run</strong></span> from the MonoDevelop application menu, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_29.jpg" alt="Debugging with MonoDevelop – continue and stepping"/><div class="caption"><p>Exiting the break mode and resuming with Continue Debugging</p></div></div><p>There are many occasions, however, where you don't want to continue execution in this way. Instead, you want to step execution over the lines of code, line by line, evaluating each line as it progresses and examining the program flow to see how variables change and are affected by<a id="id201" class="indexterm"/> statements. The step mode effectively lets you observe the program flow as it happens. There are three main kinds of steps in debugging: step over, step into, and step out. Step over instructs the debugger to move to the next line of code and then to pause again, awaiting your inspection as though the next line were a new breakpoint. If an external function call is encountered in the next line, the debugger would invoke the function as usual and then step to the<a id="id202" class="indexterm"/> next line without stepping into the function. In this way, the function is "stepped over". The function still happens, but it happens in the continue mode, and the next step or breakpoint is set in the next line after the function. To step over, press <span class="emphasis"><em>F10</em></span>, choose the <span class="strong"><strong>Step Over</strong></span> command in <span class="strong"><strong>Run</strong></span> from the application menu, or press the <span class="strong"><strong>Step Over</strong></span> button in the MonoDevelop toolbar, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_30.jpg" alt="Debugging with MonoDevelop – continue and stepping"/><div class="caption"><p>Stepping over code moves execution to the next statement without stepping into an external function</p></div></div><p>If an external function call is encountered, the <span class="strong"><strong>Step Into</strong></span> (<span class="emphasis"><em>F11</em></span>) command allows debugging to enter this function. This effectively sets the next breakpoint in the first line of the entered function that allows debugging to resume in the next step. This can be useful if you need to<a id="id203" class="indexterm"/> observe how many functions are working together. If, at any point, you want to exit the entered function by <a id="id204" class="indexterm"/>moving it forward in the continue mode, you could use the <span class="strong"><strong>Step Out</strong></span> (<span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F11</em></span>) command, and the execution would resume in the next line in the outer function.</p></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; call stack"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec36"/>Debugging with MonoDevelop – call stack</h1></div></div></div><p>More complex programs typically involve lots of functions and function calls. During execution, functions can invoke other functions, and these functions can go on to invoke yet more functions in an intricate chain of functions within functions. This means that when setting breakpoints inside<a id="id205" class="indexterm"/> functions, you can never know how the function was invoked initially when it's actually called at runtime. The breakpoint tells you that program execution has reached the specified line, but it doesn't tell you how execution arrived there in the first place. Sometimes, it might be <a id="id206" class="indexterm"/>easy to deduce, but at other times it can be much harder, especially when functions are invoked within loops, conditionals, and nested loops and conditionals. Consider the following code sample 2-10, which has been amended from the earlier code sample 2-9. This class contains several functions that invoke other functions:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
 using System.Collections;
 
 public class DebugTest : MonoBehaviour 
 {
    // Use this for initialization
    void Start () 
    {
          //Get all game objects in scene
          Transform[] Objs = Object.FindObjectsOfType&lt;Transform&gt;();
 
         //Cycle through all objects
         for(int i=0; i&lt;Objs.Length; i++)
         {
                //Set object to world origin
                Objs[i].position = Vector3.zero;
         }
 
         //Enter Function 01
         Func01();
    }
    //-------------------------------------
    //Function calls func2
<span class="strong"><strong>    void Func01()</strong></span>
    {
           Func02();
    }
    //-------------------------------------
    //Function calls func3
    <span class="strong"><strong>void Func02()</strong></span>
    {
           Func03();
    }
    //-------------------------------------
    //Function prints message
    <span class="strong"><strong>void Func03()</strong></span>
    {
<span class="strong"><strong>          Debug.Log ("Entered Function 3");</strong></span>
    }
    //-------------------------------------
 }</pre></div><p>If a breakpoint is set in line 38 of code sample 2-10 (highlighted), execution will pause when this line is reached. By reading this sample, we can see that one route to that function is by the<a id="id207" class="indexterm"/> <code class="literal">Start</code> function<a id="id208" class="indexterm"/> calling <code class="literal">Func01</code>, <code class="literal">Func01</code> calling <code class="literal">Func02</code>, and then <code class="literal">Func02</code> finally calling <code class="literal">Func03</code>. But how do we know that this is the only route? It's technically possible, for example, for another class and function elsewhere in the project to invoke <code class="literal">Func03</code> directly. So, how can we know the route by which we've reached this function in this step while debugging? Based on the tools examined so far, we can't. However, we can use the <span class="strong"><strong>Call Stack</strong></span> window. This window, displayed by default in the bottom-right corner of the MonoDevelop interface, lists all the function calls that were made to reach the active function for the current step that leads back to the first or initial function call. It gives us a breadcrumb trail of function names that leads from the active function to the first or initial function. Thus, <span class="strong"><strong>Call Stack</strong></span> lists function names upside down, the active or most recent function being at the top<a id="id209" class="indexterm"/> of the stack that leads <a id="id210" class="indexterm"/>downwards to the earliest or first function at the bottom of the stack. You can also access the functions at their locations to assess the variables in their scope, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_31.jpg" alt="Debugging with MonoDevelop – call stack"/><div class="caption"><p>Using Call Stack to trace how a function was initiated during program execution</p></div></div></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; the Immediate window"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec37"/>Debugging with MonoDevelop – the Immediate window</h1></div></div></div><p>For games, the <span class="strong"><strong>Immediate</strong></span> window acts like the <span class="strong"><strong>Console</strong></span> window, as found in many first-person shooter games such as <span class="emphasis"><em>Unreal</em></span>, <span class="emphasis"><em>Half Life</em></span>, or <span class="emphasis"><em>Call of Duty</em></span>. The <span class="strong"><strong>Immediate</strong></span> window is docked by default in the bottom-right corner of the MonoDevelop interface. It becomes active in the break mode. Using it, we <a id="id211" class="indexterm"/>can enter expressions <a id="id212" class="indexterm"/>and statements that are evaluated immediately as though they were part of the source code for this step. We can get and set the values for active variables as well as perform additional operations. We can write any valid expression, such as <code class="literal">2+2</code> and <code class="literal">10*5</code>. The result of these expressions is output in the next line in the <span class="strong"><strong>Immediate</strong></span> window, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_32.jpg" alt="Debugging with MonoDevelop – the Immediate window"/><div class="caption"><p>Evaluating expressions inside the Immediate window</p></div></div><p>Of course, you're not<a id="id213" class="indexterm"/> simply restricted to writing isolated statements that involve basic arithmetical operations, such as addition and subtraction. You <a id="id214" class="indexterm"/>can write full expressions that include active variables:</p><div class="mediaobject"><img src="graphics/0655OT_02_33.jpg" alt="Debugging with MonoDevelop – the Immediate window"/><div class="caption"><p>Writing more advanced expressions in the Immediate window</p></div></div><p>Overall, the <span class="strong"><strong>Immediate</strong></span> window is especially useful to test code, write alternative scenarios in the <span class="strong"><strong>Immediate</strong></span> window, and see how they evaluate.</p></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; conditional breakpoints"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec38"/>Debugging with MonoDevelop – conditional breakpoints</h1></div></div></div><p>Breakpoints are critical for debugging<a id="id215" class="indexterm"/>, and represents the <a id="id216" class="indexterm"/>starting point at which application execution pauses into a debug state. Often, they'll be just what you need to set a breakpoint and start debugging! However, there are times when breakpoints, in their default configuration, can become annoying. One example is when a breakpoint is set inside a loop. Sometimes, you only want the breakpoint to take effect or pause execution after a loop has exceeded a specified number of iterations, as opposed to taking effect from the beginning and on every iteration afterwards. By default, a <a id="id217" class="indexterm"/>breakpoint inside a loop will pause the execution on every iteration, and if the loop is long, such pausing behavior can quickly become tiresome. To resolve this, you can set breakpoint conditions that specify the states that must be true for the<a id="id218" class="indexterm"/> breakpoint to take effect. To set a breakpoint condition, right-click on the breakpoint and choose <span class="strong"><strong>Breakpoint Properties</strong></span> from the context menu, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_34.jpg" alt="Debugging with MonoDevelop – conditional breakpoints"/><div class="caption"><p>Accessing Breakpoint Properties to set a condition</p></div></div><p>Selecting <span class="strong"><strong>Breakpoint Properties</strong></span> will display the <span class="strong"><strong>Breakpoint Properties</strong></span> dialog where conditions for the breakpoint can be specified. In the <span class="strong"><strong>Condition</strong></span> section, choose the <span class="strong"><strong>Break when condition is true</strong></span> option and then use the <span class="strong"><strong>Condition expression</strong></span> field to specify the condition that determines the breakpoint. For loop conditions, the expression <code class="literal">i&gt;5</code> will trigger the breakpoint when the loop iterator has exceeded <code class="literal">5</code>. Of course, the variable <code class="literal">i</code> should be substituted for your own variable names.</p><div class="mediaobject"><img src="graphics/0655OT_02_35.jpg" alt="Debugging with MonoDevelop – conditional breakpoints"/><div class="caption"><p>Setting conditions for a breakpoint</p></div></div></div>
<div class="section" title="Debugging with MonoDevelop &#x2013; tracepoints"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec39"/>Debugging with MonoDevelop – tracepoints</h1></div></div></div><p>Tracepoints can offer you a neater alternative to using <code class="literal">Debug.Log</code> statements that, as we've seen, force us to amend the code we're debugging. Tracepoints work like breakpoints, in that they mark lines <a id="id219" class="indexterm"/>within your source file. They don't change the code itself, but (unlike breakpoints) they don't pause the program execution when encountered by the debugger. Instead, they perform a specified instruction<a id="id220" class="indexterm"/> automatically. Typically, they print a debug statement to the <span class="strong"><strong>Application Output</strong></span> window in MonoDevelop, though not to the Unity's <span class="strong"><strong>Console</strong></span>. To set a breakpoint in line 16 of code sample 2-10, position your cursor on line 16 and select <span class="strong"><strong>Add Tracepoint</strong></span> in <span class="strong"><strong>Run</strong></span> from the application menu (or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F9</em></span>), as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_36.jpg" alt="Debugging with MonoDevelop – tracepoints"/><div class="caption"><p>Adding Tracepoint to the selected line in MonoDevelop</p></div></div><p>On selecting the <span class="strong"><strong>Add Tracepoint</strong></span> option, MonoDevelop will show the <span class="strong"><strong>Add Tracepoint</strong></span> dialog. The <span class="strong"><strong>Trace Text</strong></span> field allows you to input the text to be printed to the <span class="strong"><strong>Application Output</strong></span> window when the tracepoint is encountered at runtime. You can also insert the curly braces opening and<a id="id221" class="indexterm"/> closing symbols to define the regions<a id="id222" class="indexterm"/> in the string where expressions should be evaluated. This lets you print the values of variables into the debug string, such as <code class="literal">"Loop counter is {i}"</code>, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_02_37.jpg" alt="Debugging with MonoDevelop – tracepoints"/><div class="caption"><p>Setting Tracepoint Text</p></div></div><p>After clicking on <span class="strong"><strong>OK</strong></span>, the<a id="id223" class="indexterm"/> tracepoint is added to the selected line. Inside MonoDevelop, the line will be marked with a diamond shape as opposed to a circle; this diamond shape indicates a breakpoint:</p><div class="mediaobject"><img src="graphics/0655OT_02_38.jpg" alt="Debugging with MonoDevelop – tracepoints"/><div class="caption"><p>Inserting a tracepoint</p></div></div><p>After setting the tracepoint in the selected line in the code editor and running the application via the attachment with MonoDevelop, the game will run as normal, directly from the Unity Editor. However, when the tracepoint is encountered, the application will not pause or enter the break <a id="id224" class="indexterm"/>mode as it would with breakpoints. Instead, the tracepoint will automatically output its printed statements to MonoDevelop's <span class="strong"><strong>Application Output</strong></span> window, without causing a pause. By default, this window is docked at the bottom of the MonoDevelop interface:</p><div class="mediaobject"><img src="graphics/0655OT_02_39.jpg" alt="Debugging with MonoDevelop – tracepoints"/><div class="caption"><p>Tracepoints can print statements such as Debug.Log to the Application Output window in MonoDevelop</p></div></div><p>Tracepoints are an effective and helpful alternative to using the <code class="literal">Debug.Log</code> statements inside Unity, and you don't need<a id="id225" class="indexterm"/> to amend your code in any way to use them as you do with <code class="literal">Debug.Log</code>. Unfortunately, they don't print directly to Unity's <span class="strong"><strong>Console</strong></span>. Instead, they appear inside the <span class="strong"><strong>Application Output</strong></span> window in <a id="id226" class="indexterm"/>MonoDevelop. However, as long as you recognize this, working with tracepoints can be a powerful and useful method to find and remove bugs.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec40"/>Summary</h1></div></div></div><p>This chapter considered the process of debugging, which is centrally about finding and removing errors from your game. There are many methods to achieve this end, especially in Unity. Specifically, the methods considered here included the <code class="literal">Debug.Log</code> statement, perhaps the simplest of all debugging methods. Using this technique, <code class="literal">Debug.Log</code> statements are inserted into your code in critical lines, and these print diagnostic messages to Unity's <span class="strong"><strong>Console</strong></span>. Next, we looked at is custom defines: using them, you can section off and isolate blocks of your code between the release and debug versions; this allows you to run debug-specific code when specific flags are enabled. Then, we looked at error logging. This chapter demonstrated how to create an error logger class that integrates with native Unity's application class, using delegates. We also saw the profiler; the Unity profiler is a pro-only feature that gives us a high-level statistical insight into how processing is distributed over time and system resources. In addition, we explored in-editor debugging and visual debugging to gain a clearer visual insight into our scene, and factors that affect object behavior. Finally, we saw MonoDevelop debugging, which does not require us to edit our code. These include breakpoints, tracepoints, steps, and watches. Next up, we'll explore how to work with <code class="literal">GameObjects</code>.</p></div></body></html>