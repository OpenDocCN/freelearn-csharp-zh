- en: Anti-Patterns and Misconceptions on Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns show us the proper way to implement Dependency Injection. In the last
    chapter, we got an insight into every pattern available in the DI Ecosystem and
    explored their usage, their pros, their cons, and which one to select when. If
    these patterns are followed correctly, we achieve a loosely coupled architecture
    which will be easier to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: However, while applying these patterns, we generally neglect some principles,
    which leads us to problems in the future. That might happen either to the ignorance
    about pattern' behavior or simply due to laziness.
  prefs: []
  type: TYPE_NORMAL
- en: At that point, a pattern becomes an anti-pattern, as it does not solve the problem;
    rather it gives birth to more bugs and maintenance becomes a headache.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, don't worry if you find anti-patterns in your project
    because we will learn the steps to refactor each anti-pattern to a proper Pattern
    by selecting any technique from the patterns we discussed in the last chapter.
    If you directly came to this chapter, I suggest you complete the previous chapter
    (which covers everything you should know about DI Patterns in detail) first before
    moving ahead.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about such scenarios in projects with examples
    to understand how a pattern can behave as an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: When DI becomes an anti-pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying anti-patterns in the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems anti-patterns introduce to apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solutions and refactoring steps for each type of anti-pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When does Dependency Injection become an anti-pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are heading towards exploring anti-patterns followed by developers in projects
    with DI in place. However, have you envisaged the scenario where DI itself becomes
    an anti-pattern! Yes, it can be an anti-pattern sometimes. The cases are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a controller that is depending on a `Service` for some database
    operation. For instance, `UsersController` would need an `IUsersService` type
    as a dependency for `User` table-related operations. We configured `UsersService`
    for the dependency and it got registered with the container. Now, help yourself
    a little bit and ask the following question.
  prefs: []
  type: TYPE_NORMAL
- en: '*Are you going to change the dependency to any other implementation of* **`IUsersService`***? *If
    your answer is *No*, then hold back and think a bit. The reason is, if you won''t
    change the implementation for the dependency either dynamically through code or
    configurations, then DI is not going to play an important role. For example, if
    you save data to a database/XML/text file, you might have different implementations
    and swapping is needed in certain conditions, then DI will definitely come in
    handy. But if you only save to the database and nothing else, there is no necessity
    to have extra codes for injecting dependencies. It does not make much sense.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Are you going to need a dependency as soon as you start the app? *DI recommends
    that we register everything at one place called the Composition Root. However,
    imagine a `Service` called `CompanyService` whose instance is needed only when
    I want to add a `User` to a company. For example, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Normally we have admins in a company who manages user records. Imagine a scenario,
    where the admin is logged in and wants to assign a few users to a certain company.
    In this case, there is a `boolean` coming from the model named `AddUserToCompany`.
    If that is `true`, we need to assign the user to the company. This means a lazy
    instantiation and it is looking pretty good.
  prefs: []
  type: TYPE_NORMAL
- en: So, here, it's meant to get a `CompanyService` instance quickly and work with
    it. However, if you have chosen DI, then the `CompanyService` instance stays in
    the container (because you register it at the Composition Root) till you actually
    use it inside the code, which often does not happen. Sometimes, it doesn't happen
    at all if the user logged in as a normal user and not an admin.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a small example. You can visualize a complex application with these
    types of scenarios that might create a nasty impact with DI in place. Sometimes
    it's better to have lazy instantiation instead of having them in a container which
    consumes memory space unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Like a pattern, if DI is selected unnecessarily or used incorrectly, that leads
    to an anti-pattern itself. If you are never going to inject different dependencies
    for one implementation, then no need to use DI. Let's now explore anti-patterns,
    which we might encounter while using DI in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four major types of anti-pattern found in projects where DI is implemented
    and those are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Control Freak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bastard Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constrained Construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service Locator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze each type and see how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Control Freak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control Freak is opposite to Inversion of Control. When a class holds its dependencies
    and tries to manage them itself without any interference from others, it will
    be tagged as a **Control Freak**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows Control Freak at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb44cae7-c5fc-46ae-9bed-747d3b101475.png)'
  prefs: []
  type: TYPE_IMG
- en: When we said that *it tries to manage the dependencies itself*, what do we mean
    by that? Remember in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml), *Object
    Lifetime*, if a class wants to manage a dependency, that means it wants to instantiate
    it, then manage its lifetime and kill or dispose of it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation, yes, that is done by our well-known keyword `new`.  The class
    instantiates every dependency with the `new` keyword inside it, then works with
    the objects and disposes of them through a `destructor` or `finalizer`. As a result,
    it is creating a tightly coupled system as soon as it does so. Moreover, it makes
    unit testing difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class either creates the object itself or asks some other class to do so
    on its behalf. Let''s understand the scenario with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that instantly comes into play is `new SqlEmplyeeRepository()`.
    Now, this service is tightly coupled with `SqlEmployeeRepository`. Suppose you
    want to use another repository class instead of this, then we have to change the
    service code and recompile. There is no such plugin point to say *I am providing
    you with this repository, please use it*.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fix this problem, the developer might think of different patterns, which
    eventually complicates the scene. We can see the following types of factory used
    commonly:'
  prefs: []
  type: TYPE_NORMAL
- en: Concrete Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating `EmployeeRepositoryFactory` is another excuse (and a lazy approach)
    to have a `Create()` method that will create a `SqlEmployeeRepository` instance
    by the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We removed this block from `EmployeeService` but added another class which
    is working very similar to the previous one. We can then use the factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `EmployeeService` constructor, we use the `new` keyword to get a
    factory instance and then call `Create()` to get the `SqlEmployeeRepository` instance
    and assign it to the `repository` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Did we achieve anything useful? Not at all. We just added another bunch of code
    to the `Service`, doing the same thing (using the `new` keyword to instantiate)
    in an indirect way through the factory. Basically, the factory uses the same `new`
    keyword to instantiate the `SqlEmployeeRepository` class. That is what we wanted
    to avoid, but we could not achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract Factory behaves as an encapsulating component that encapsulates complex
    logic including dependencies associated with it. It can transfer the control from
    the consumer because it does not totally allow the consumer to control the lifetime
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Derived Factory is responsible for the creation and management of the required
    repository instead of the initially designed factory. Consider the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That means we are trying to hide which repository will be served. We are trying
    to achieve loose coupling by hiding the actual supplied type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to assign the `repository` variable, we have to inherit this class
    and create one child of it returning `SqlEmployeeRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we decoupled the instantiation of the `repository` from the main
    service. The same question again arises. Did we achieve anything useful? I don''t
    think so. That is because this new architecture  again achieved at the cost of
    one instantiation inside the `EmployeeService `(with the `new` keyword):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although you were able to hide the `SqlEmplyeeRepository` from the factory by
    making it abstract, you made no change to the way things are handled inside the
    `EmployeeService` constructor. You are now instantiating `SqlEmployeeService`.
  prefs: []
  type: TYPE_NORMAL
- en: Static Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next approach is to avoid factory instantiation by introducing the `static`
    pattern. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This would prevent us from creating an object and using it directly. Let''s
    see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Horray! We finally removed the `new` keyword. Alright, looks like we are done.
    Oh, wait! We still have `SqlEmployeeRepository` instantiated using `new` inside `Create()`.
    But there is a simple solution to reading this type of repository from the `config`
    or something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks promising at first glance, but it is actually something else. All
    classes become tightly coupled. This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f36aaab7-6112-4fb2-814c-497ae3b09222.png)'
  prefs: []
  type: TYPE_IMG
- en: '`EmployeeService` depends upon the `EmployeeRepositoryFactory` for the `EmployeeRepository`
    instance, which means that clients of the service need to refer to the factory,
    repository, and then the types of repository such as `SqlEmployeeRepository` and `AzureEmployeeRepository`
    returned by `CreateSql()` and `CreateAzure()`.'
  prefs: []
  type: TYPE_NORMAL
- en: These concrete classes got coupled, which can't produce a flexible design resulting
    in bad days for upcoming programmers of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already explored patterns in the last chapter. The best fit for Control
    Freak issues is Constructor Injection. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you abstracted out the concrete repository and also inserted the
    dependency through the constructor. More refactoring can be applied by introducing
    a factory class, which will be responsible for generating the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now using the DI Containers, you can register either the factory interface or
    the repository interface and resolve as required so that the dependency will be
    available for the service.
  prefs: []
  type: TYPE_NORMAL
- en: Control Freak is the most commonly found anti-pattern implemented in projects.
    While developers consider using DI in their project, they find it difficult sometimes
    and they are attracted to controlling the object creation instead of any other
    component doing it for them. The outcome will be awesome if they just ignore being
    a control freak and go with the DI flow.
  prefs: []
  type: TYPE_NORMAL
- en: The next anti-pattern is Bastard Injection. However, before going to that, we
    need to understand a manual approach to dependency management called **Poor Man's
    DI**.
  prefs: []
  type: TYPE_NORMAL
- en: Poor Man's DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Poor Man's DI; the name sounds very interesting, doesn't it! When you yourself
    try to take care of the registrations of dependencies at commonplace (which otherwise
    can be denoted as the Composition Root) instead of using a library (specifically
    a DI Container), that technique can be defined as Poor Man's DI.
  prefs: []
  type: TYPE_NORMAL
- en: The approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s find out how this can be done with a quick code example. Suppose `EmployeeService`
    has a dependency of the `EmployeeRepository` type, which we can directly provide
    into the constructor, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Consider this console app example, where `EmployeeService` is instantiated inside
    the `Main` method. It looks simple and beautiful. But it is not that effective
    if the dependency nesting runs deep.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if `EmployeeRepository` again needs some other dependency and then another
    one and so on. You might end up doing something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it becomes ugly and not so maintainable. Then you might think of simplifying
    this structure to some extent by introducing a default constructor for each class.
    So, the following is what you will do for `Service` and `Repository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same thing to all the nested classes. We added default constructors
    for all the classes; these a call internally to the parameterized constructors
    with a default dependency instance. It will definitely, reduce the code. Check
    the following reduced code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now there is no need to pass any dependency to these constructors. Moreover,
    if you pass any dependency of the expected type, that will also work because a
    parameterized constructor also exists. That means we got a very flexible structure
    for the class and we also reduced the instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we tried to make the instantiation flexible, testable, and simple, we
    did not realize the following disadvantages with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: A concrete reference was created in the default constructor when we did `new
    EmployeeRepository()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default dependency instance is tied with all the classes using the `new`
    operator. But the whole point of the dependency injection technique is to reduce
    the `new` keywords in the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also violated another principle in registering all dependencies in one place
    known as the Composition Root. Now, we have Composition Roots everywhere across
    the app in all classes. This is bad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine the situation of having 10 classes using the same dependency; now it
    would be very problematic to instantiate everything with the same `new` keyword
    again and again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have any facility to manage the lifetime of the dependencies created
    like this using the `new` keyword. You have to manually dispose of everything
    which can become a headache in a fully fledged application. Moreover, if you want
    to reuse one instance, you need to carefully deal with that. This might lead to
    inconsistent behavior and wrong data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how do we deal with this? Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, using a DI Container to register the dependencies solves the problem.
    We can remove the default constructor that is actually creating a tight coupling
    with the required types:'
  prefs: []
  type: TYPE_NORMAL
- en: The registration of dependencies can be restricted to one place unlike Poor
    Man's DI, where you instantiate concrete classes here and there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the registrations inside the Composition Root using a DI Container, we
    can make use of the facility to configure the app to use different types of dependency
    using different configuration options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get cleaner code for deeply nested dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a dependency to be used by many classes, it's just a matter of registering
    it to the container and sitting back and relaxing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can manage the lifetime of dependencies as you like. The instance can behave
    as a `Singleton` , `Transient` , or `Scoped` as you configure them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's recommended to use a DI Container to register and resolve dependencies
    instead of manually managing them in the Composition Root. So, the default constructor
    approach is denoted as Bastard Injection. In the next section, we will explore
    this a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Bastard Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, classes have more than one constructor. You might have a situation
    where you have referred to some class from another assembly in your default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how one class has two constructors: one default
    and one parameterized. The parameterized constructor handles the injection and
    makes the `ISomeClass` implementation available for the class to operate on. Thus,
    the default constructor that is creating an instance of `SomeClass` becomes unnecessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b599f09-8916-4f3f-85ac-54710d8b7933.png)'
  prefs: []
  type: TYPE_IMG
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simplicity, let''s consider the same example: `EmployeeService`, which
    needs a repository to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is a default constructor which ensures repository availability by creating
    an instance of `SqlEmployeeRepository`. The default repository is referred from
    another assembly, obviously, as the service and repository don't stay in one assembly
    together. That's why the default can be denoted as a **Foreign Default**.
  prefs: []
  type: TYPE_NORMAL
- en: While we thought of having a default repository just because we wanted to make
    the service usable as soon as it is instantiated, unknowingly we designed a tightly
    coupled system between the service and repository.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bastard Injection is bad just because of this Foreign Default. Also, it might
    be depending on something we don't even need inside the class. From the preceding
    example, it's quite clear that, if we use a DI Container, it will automatically
    wire up the resolved dependency to the other parameterized constructor. However,
    if we have these kinds of default constructor, then DI Container might get confused
    while selecting which one to target. Having just one constructor for injection
    ensures a smooth operation with the container.
  prefs: []
  type: TYPE_NORMAL
- en: When you encounter a default constructor generating coupling with a Foreign
    Default, you can consider eliminating that, as you decide to apply Constructor
    Injection. Having one constructor for DI is enough because it is the responsibility
    of the DI Container to make sure that Foreign Default is in place whenever the
    service is requested.
  prefs: []
  type: TYPE_NORMAL
- en: While you refactor the code and remove the default constructor, the compiler
    might complain. In that case, you need to move instantiation codes to the Composition
    Root. If the referred dependency is a *Local Default* (it resides inside the same
    assembly), then we still need to remove that constructor, because constructor
    ambiguity leads to an increase in the complexity of *Auto-Wiring*.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, we have already discussed local defaults in [Chapter 8](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml),
    *Patterns - Dependency Injection*. The easiest way to handle local defaults is
    to introduce *Property Injection*. The default constructor can be converted to
    a writable property.
  prefs: []
  type: TYPE_NORMAL
- en: Constrained Construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here comes yet another type of *Anti-Pattern,* that tries to hijack the constructor.
    So, the developer forces the dependency's constructor to have a particular signature,
    which creates the problem. The reason behind this might be the intention of defining
    the dependencies in external configuration files to achieve late binding.
  prefs: []
  type: TYPE_NORMAL
- en: Late binding can be referred to as reading the type of repository (the derived
    class of the repository) and connection string from the configuration file to
    instantiate some repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a late binding technique not only helps to isolate code from the dependency
    but also makes sure that the code is not recompiled if the configuration is updated.
    Using a commonplace or application root to define all dependencies doesn''t expose
    any problem, but recompiling is a must when we want to update dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b26c2b49-2055-4fa7-93d7-8a9bab80c914.png)'
  prefs: []
  type: TYPE_IMG
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine two repositories `EmployeeRepository` and `StaffRepository` used in
    an application. Both have constructors and you will pass the type of repository
    and connection string to both of them in order to create the repositories using
    these params. This is bad as you will now fetch the repository type and connection
    string from the config which might create issues if the `config`, does not have
    the required keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now after you fetch the repository type name from the `config`, you have to
    create a `System.Type` instance using that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Activator.CreateInstance` is used to call the constructor of the given type.
    The second param in this method is passed to the constructor of the type provided
    in the first param.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the type in the `config` is `SqlEmployeeRepository`. Basically, it
    assumes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SqlEmployeeRepository` derives from `EmployeeRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation should contain a constructor that can take a connection string
    as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the constraints, actually.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the object construction perspective, it might look perfect, but there
    are disadvantages. For instance, think of constructing the repositories with the
    same dependency such as a single context. With the `Activator.CreateInstance`,
    we can no doubt create instances of the type specified to it, which in our case
    will create instances of `EmployeeRepository` and `StaffRepository`. But we can
    never assign a single context to both of them, as everyone will create their individual
    context based on their constructors. The following diagram depicts what I want
    to convey:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f2672df-330e-436b-be6f-604db85e0e54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sharing of context can only happen if someone from the outside provides that
    to each of them instead of their creating the context themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9fddb65-626d-49b7-b507-867a49852a70.png)'
  prefs: []
  type: TYPE_IMG
- en: Sharing a single dependency across the classes becomes difficult in this situation.
    More than one instance of the same dependency will be created, which is unnecessary.
    This would consume memory and resources as well.
  prefs: []
  type: TYPE_NORMAL
- en: A single instance of a particular dependency should be carefully chosen while
    designing. If not handled with care, there might be an adverse effect on the application
    running in different threads. If you remember, we have already discussed the Singleton
    Lifetime in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml), *Object Lifetime, *where
    we talked about the pattern's benefits and usage.
  prefs: []
  type: TYPE_NORMAL
- en: The Someone can be considered to be a Factory which we are going to explore
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DI container comes to the rescue at the composition root to overcome these
    difficulties and resolve all the dependencies in one go. Thus, the injection can
    take place and everything works smoothly. There is no need to have individual
    constructors for the dependencies with connection strings.
  prefs: []
  type: TYPE_NORMAL
- en: Even without a DI Container, we can formulate our solution differently. Abstract
    Factory comes into the play when we think of centralizing the dependency construction.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the Factory, Service, and Repository should be in different assemblies.
    There is a strong reason behind that. We will explore it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating every dependency object inside the *Global asax* for ASP.NET
    app using `Activator.CreateInstance`, we will design in a different way so that
    there will be no need to recompile the app every time you want to use different
    types of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will design a Factory named `EmployeeServiceFactory` implementing `IEmployeeServiceFactory` using
    a particular repository. This factory will be responsible for creating the service.
    `Service` would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`EmployeeServiceFactory` contains a `CreateService()` method to create the
    service it is responsible for (`EmployeeService` in this case).'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to isolate the Factory from the app and `DataAccess` to remove
    coupling. So, the Factory should be in a different assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can store the assembly-qualified type name for a factory in a `.config`
    file. `Activator.CreateInstance` can then be used to create an instance of the
    `IEmployeeServiceFactory` implementation (that you will define in the config)
    because that has a default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With `employeeFactory` now you can fire `CreateService()`, which will return
    the `EmployeeService` instance by using the related repository `EmployeeRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to use another type of dependency for the service instead of `EmployeeRepository`,
    then you can update the related key in the `config`. But before that, you need
    to add another factory in the factory assembly to implement `IEmployeeServiceFactory` and
    operate on the new configured repository. In this way, you recompile the factory
    assembly without compiling the application again and everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Service Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember, in the *Control Freak* section, we discussed Static Factories.
    With certain modifications, a Static Factory can behave as a Service Locator.
    As the name suggests, it will locate or find your required service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb58b76b-a22f-41d5-bc18-e7063e0a4694.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Service Locator* is very useful in many cases, which is why developers consider
    it to be a pattern. But it has many disadvantages. That''s why we are listing
    this in this chapter instead of the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: I am not going to discourage you from using this technique, but I would like
    to shed some light on its pros and cons. This will definitely help you to make
    better design decisions according to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some noticeable properties of Locator include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The important logic behind *Locator* is that it allows dependencies or services
    to be injected into it easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Static Factory, when configured with services or dependencies, is usually
    considered a *Service Locator*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration of a Service Locator can happen at the Composition Root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service Locator configuration can be managed through code or reading-related
    settings from config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DI Container looks like a *S*ervice Locator. The principal duty of a Locator
    or Container in the DI Context is to resolve the dependency graph before every
    other operation starts. Ideally, resolving the graph should only happen at the
    Composition Root for proper implementation. The problem starts when you ask for
    dependencies or services in the application directly using the Locator or Container,
    instead of injecting them to the consumer. In this case, Locator will be tagged
    as an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Locator Process can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**While registering a service, Locator stores one instance of it in a Dictionary**: The
    registration is normally done using an interface. You basically inform the Locator
    about an interface and its concrete implementation. For example, you would say
    *Serve `EmployeeService` if `IEmployeeService` is requested, Serve `StudentService`
    if `IStudentService` is demanded*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Locator receives the request to serve one instance of a service registered
    by its interface**: So, when some code in your application wants to work with
    a `Student` entity, it will ask the Locator for an `IStudentInterface` implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Locator searches for the instance from the stored instances and then returns
    that to the client: **As you have already trained the Locator, it will just return
    the requested implementation of the interface by checking all the stored instances.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple Service Locator would resemble the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Register` method stores the service in the dictionary and `GetService`
    returns. We can use the locator to get the instance of a particular type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you have registered the service beforehand using the `Register` method, then
    you can get it from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, the pattern has some advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports late binding by altering the registration codes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adopts program against interfaces so that we can develop code in parallel
    and we can replace modules as per our requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns can be achieved. We can write maintainable code, though
    it is not so easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't get fooled by the advantages. It might look perfectly fine to you, but
    there are many disadvantages with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Service Locator acts as a proper pattern; however, you have to live with the
    following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Code reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It hampers the reusability of the class as dependencies are not centralized
    anymore with Locator. They might be scattered throughout the class by the Locator''s `GetService`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a995e4f8-b337-47e6-9b84-2d9a7e91033c.png)'
  prefs: []
  type: TYPE_IMG
- en: '`EmployeeService` now depends upon both `EmployeeRepository` and `ServiceLocator`.
    Ideally, it should just rely upon the repository to follow the DI principle.'
  prefs: []
  type: TYPE_NORMAL
- en: With both these dependencies in place, if someone wants to reuse `EmployeeService`,
    then they have to refer to both of them. If `ServiceLocator` stays in a different
    assembly, then the assembly reference is also required, which draws a very inefficient
    design. You will definitely agree with me if I say that it is a tightly coupled
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the consumer of the service won''t be able to identify the dependencies
    while instantiating the service. That is because Locator is used internally inside
    the constructor or the methods and not exposed, unlike the DI strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now you might argue, Why would the developer would try to know what's inside
    because the dependencies are internally handled inside the default constructor?
    But what will happen if you forgot to register the dependency to Locator? Don't
    say that you won't forget. Most likely it will happen because, while you instantiate
    the class, the dependency's existence is not clear through the constructor. Therefore,
    if the class is not telling you what it depends on, you won't be so careful in
    finding and registering it, which would throw up unexpected exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: I know what you are thinking now; apparently, the service is a type of Control
    Freak, isn't it? It is taking control of the dependencies using Locator.
  prefs: []
  type: TYPE_NORMAL
- en: The needy class means the class that depends on someone else. It no longer follows
    DI because the dependency is not injected; rather, it is fetched from Locator's `static` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is clearly identifiable when the developer wants to add more
    dependencies to the class that has already adopted the Locator Pattern. Either
    you follow the same principle to introduce more dependencies or remove the Service
    Locator pattern and implement DI. Compilation errors are a certainty in both these
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: For all the preceding reasons, Service Locator is considered an anti-pattern.
    Let's talk about a robust solution to address this anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, Constructor Injection is the best fit and comes to mind first when
    we decide to refactor Service Locator codes. Complete removal of Service Locator
    can be achieved through Constructor Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most cases, Locator is used everywhere in the code base to get an instance
    of the dependency. Follow these steps to refactor it towards DI:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify all the Locator calls in the code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce a member variable to the class to hold the dependency, if that is
    not present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the field `readonly` so that it can't be modified outside the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the field inside the constructor using the Locator. Now the Locator call
    is in one place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor parameter for the dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove Locator from the constructor block and directly assign the constructor
    parameter to the `readonly` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify all the instantiation made to the class and move the wiring to a Composition
    Root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After all these steps, the same `EmployeeService` with the Constructor Injection
    Pattern can be designed, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The service now asks its consumers to provide a dependency of type `IEmployeeRepository`
    implementation, which was not happening before.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter illustrated ways to implement DI. When we don't implement patterns
    correctly, we end up with a bad design for our app. We learned about mistakes
    we regularly make while implementing DI.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to DI anti-patterns, we discussed why and when we can consider
    DI as an anti-pattern itself!
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved ahead and touched upon all those common anti-patternscaused by
    misconceptions regarding Dependency Injection. We explored Control Freak, Bastard
    Injection, Constrained Construction, and (the most important) Service Locator.
  prefs: []
  type: TYPE_NORMAL
- en: Control Freak is the easiest one to discover. Whenever you see any class using
    the `new` keyword to instantiate its dependencies, that means it is trying to
    manage them without any external module controlling it. This is bad and should
    be avoided in the DI ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most dangerous one, which we should address first while refactoring.
    Other patterns are less damaging than this because it has a direct impact on loose
    coupling. Composition Root should be the place to instantiate everything needed
    for the application and then every possible dependency will be available by injection.
  prefs: []
  type: TYPE_NORMAL
- en: Bastard Injection can be seen with Foreign Defaults which is unnecessary from
    the DI point of view. We can easily move to Constructor Injection by removing
    codes related to Foreign Defaults.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Constrained Construction imposes restrictions on constructors
    to support late binding of services by taking types from configuration files,
    which in turn creates tight coupling. Adopting a DI Container or one Abstract
    Factory would help to eliminate constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not the least, we discussed Service Locator, which is arguably a proper
    Pattern. However, we explored its pros and cons and came to the conclusion that
    it is an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If you have reached this point, that means you have now have grasped the ways
    to implement DI and what to avoid. In the next chapter, we will be discussing
    more realistic problems in projects and how to deal with them.
  prefs: []
  type: TYPE_NORMAL
