- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Nothing Left but the Typing – Implementing the Wheelchair Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除了打字，别无他物 – 实施轮椅项目
- en: In the previous chapter, we learned about the advantages of creating a set of
    diagrams as a design plan for our next coding project. The whole point is to get
    the design in a format that can be discussed, argued, pondered, socialized, and
    changed. After the design is completed, the last step is to implement the diagrams
    as code. Our trio of software engineers has done just that with an ambitious new
    project designed to make a difference in the lives of potentially thousands of
    people who could benefit from access to a high-quality, low-cost wheelchair.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了创建一套图表作为我们下一个编码项目的规划设计的优点。整个目的就是将设计以可以讨论、争论、思考、社交和修改的格式呈现出来。设计完成后，最后一步是将图表实现为代码。我们的三位软件工程师刚刚完成了一个雄心勃勃的新项目，旨在改变可能数千人生活的质量，这些人将从使用高质量、低成本的轮椅中受益。
- en: I’ve often compared UML with sheet music. A good UML design can be handed off
    to a developer the same way a musical composer can hand off a score to a competent
    orchestra. In music, the orchestra will often make changes and improvisational
    improvements to the sheet music. Sometimes they do this to make the music fit
    the skill of the performers. Other times, they might need to change or adapt the
    music to fit the performance itself. Classical composer Johann Sebastian Bach
    was prolific. Among his most popular works are *The Brandenburg Concertos*. Bach
    assembled the collection in 1721\. In 1968, a different composer, Wendy Carlos,
    arranged *The Brandenburg Concertos* to be played entirely on analog synthesizers
    in her work *Switched on Bach*. The music didn’t change as much as the implementation
    details. It isn’t a stretch to think of programming as being a lot like playing
    music. It requires creativity and improvisation. A talented architect who has
    created a good diagram can be reasonably sure a competent development team will
    be able to implement the diagram and, if required, make some improvisations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常把UML与乐谱相比较。一个好的UML设计可以像音乐作曲家将乐谱交给一个有能力的乐团一样，交给开发者。在音乐中，乐团经常会根据表演者的技能对乐谱进行修改和即兴创作。有时他们这样做是为了使音乐更符合表演者的技能。有时，他们可能需要改变或调整音乐以适应表演本身。古典作曲家约翰·塞巴斯蒂安·巴赫作品丰富。他最受欢迎的作品中包括
    *布兰登堡协奏曲*。巴赫在1721年汇编了这个系列。在1968年，另一位作曲家温迪·卡罗斯将 *布兰登堡协奏曲* 改编成完全由模拟合成器演奏的形式，收录在她的作品
    *Switched on Bach* 中。音乐本身并没有太多变化，但实现细节却有所不同。将编程看作是像演奏音乐一样，并不夸张。它需要创造力和即兴发挥。一个创建了良好图表的建筑师可以合理地确信一个有能力的开发团队能够实现这个图表，并在必要时进行一些即兴创作。
- en: 'In this chapter, we are going to hand off Tom’s UML design diagrams for implementation.
    There is a big difference between designing the classes and implementing them.
    First, the diagrams leave some areas vague on purpose. This is done to allow the
    developer to make decisions about details that don’t really matter to the diagram.
    As an example, there are many diagrams in this book that leave out class details.
    Look at a diagram from the previous chapter in *Figure 7.1*:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把汤姆的UML设计图表交给开发者进行实现。设计类和实现它们之间有很大的区别。首先，图表故意留下了一些模糊的区域。这样做是为了让开发者对图表不重要的细节做出决定。例如，这本书中有许多图表省略了类细节。看看上一章的
    *图7.1*：
- en: '![Figure 7.1: The composite diagram from the last chapter leaves a lot of details
    up to the developer.  ](img/B18605_Figure_7.1.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：上一章的综合图表留下了许多细节由开发者决定。](img/B18605_Figure_7.1.jpg)'
- en: 'Figure 7.1: The composite diagram from the last chapter leaves a lot of details
    up to the developer.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：上一章的综合图表留下了许多细节由开发者决定。
- en: This isn’t done because the architect is lazy. It is done because those details
    don’t really matter to the structure of the design. Imagine building a house from
    a blueprint. The blueprint will probably specify where the walls go. It might
    even specify the materials to be used, the same way we sometimes dictate a particular
    type for an instance variable or return type. However, the smaller details, such
    as what kind of paint to use on the walls or the brand of shingles used on the
    roof, are all implementation details. The builder can make those decisions independently
    of the blueprint.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是因为架构师懒惰。这样做是因为那些细节并不真正影响设计的结构。想象一下按照蓝图建造一栋房子。蓝图可能会指定墙壁的位置。甚至可能指定要使用的材料，就像我们有时会指定实例变量或返回类型的特定类型一样。然而，一些较小的细节，比如墙壁上要使用什么颜色的油漆，或者屋顶上要使用什么品牌的瓦片，这些都是实现细节。建造者可以独立于蓝图做出这些决定。
- en: 'While focusing on the design from [*Chapter 6*](B18605_06.xhtml#_idTextAnchor110),
    *Step Away from the IDE! Designing with Patterns Before You Code*, we’ll cover
    the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在关注**第6章**[*Chapter 6*](B18605_06.xhtml#_idTextAnchor110)的设计，*Step Away from
    the IDE! Designing with Patterns Before You Code*时，我们将涵盖以下内容：
- en: Creating a new command -line project. So far, I have stayed away from IDE mechanics.
    I won’t be going into depth here either. It just feels right to start the chapter
    this way. If you’re new to C# development, and you haven’t noticed [*Appendix
    1*](B18605_Appendix_1.xhtml#_idTextAnchor178) at the end of the book, you should
    check that out because I show you some of these mechanics that might not be second
    nature to you
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的命令行项目。到目前为止，我一直避免涉及IDE机制。这里也不会深入探讨。以这种方式开始章节感觉是正确的。如果你是C#开发的初学者，并且没有注意到书末的[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)，你应该查看一下，因为我展示了你可能不认为是第二本能的一些这些机制。
- en: We’ll start by adding our base classes just like Tom did, but we don’t really
    need a two-pass system since we did all the organization work in the design phase.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将像汤姆一样先添加我们的基础类，但由于我们在设计阶段已经完成了所有组织工作，所以我们实际上不需要两遍系统。
- en: We’ll implement the Builder pattern.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现构建者模式（Builder pattern）。
- en: We’ll convert the Builder pattern implementation to a Singleton.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把构建者模式（Builder pattern）的实现转换为单例（Singleton）。
- en: We’ll implement the Composite pattern.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现组合模式（Composite pattern）。
- en: We’ll implement the Bridge pattern.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现桥接模式（Bridge pattern）。
- en: We’ll implement the Command pattern.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现命令模式（Command pattern）。
- en: 'Throughout the book, I assume you know how to create new C# projects in your
    favorite **integrated development environment** (**IDE)**. I do not usually spend
    any time on the mechanics of setting up and running projects. This chapter is
    a mild exception since the whole chapter really is an example of one big project.
    If you need more details, or you want to use an IDE other than Rider, and you’re
    not sure how to set up the projects, please see [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    of this book. Should you decide to try any of this out, you’ll need the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我假设你知道如何在你的首选**集成开发环境**（**IDE**）中创建新的C#项目。我通常不会在设置和运行项目的机制上花费任何时间。这一章是一个轻微的例外，因为整章实际上是一个大型项目的例子。如果你需要更多细节，或者你想使用除Rider之外的IDE，并且不确定如何设置项目，请参阅本书的**附录1**[*Appendix
    1*](B18605_Appendix_1.xhtml#_idTextAnchor178)。如果你决定尝试这些，你需要以下内容：
- en: A computer running the Windows operating system. I’m using Windows 10\. Since
    the projects are simple command-line projects, I’m pretty sure everything here
    would also work on a Mac or Linux, but I haven’t tested the projects on those
    operating systems.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Windows操作系统的计算机。我使用的是Windows 10。由于项目是简单的命令行项目，我相当确信这些内容在Mac或Linux上也能正常工作，但我还没有在这些操作系统上测试过这些项目。
- en: A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code
    with C# extensions. I’m using Rider 2021.3.3.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持的IDE，如Visual Studio、JetBrains Rider或带有C#扩展的Visual Studio Code。我使用的是Rider
    2021.3.3。
- en: Any version of the .NET SDK. Again, the projects are simple enough that our
    code shouldn’t be reliant on any particular version. I happen to be using the
    .NET Core 6 SDK.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何版本的.NET SDK。再次强调，项目足够简单，我们的代码不应该依赖于任何特定版本。我恰好使用的是.NET Core 6 SDK。
- en: You can find the completed project files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-7](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-7).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的完整项目文件[https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-7](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-7)。
- en: The crack of noon
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正午的裂缝
- en: Having spent the previous day and well into the night diagramming their project,
    Tom, Kitty, and Phoebe arrived at Bumble Bikes. At high noon the next day, the
    energy in the room was palpable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一天晚上一直忙于绘制项目图之后，汤姆、凯蒂和菲比来到了Bumble Bikes。第二天中午时分，房间里的气氛紧张而充满活力。
- en: Kitty walked in with a box under her arm. She had ordered a new keyboard, the
    kind with the loud blue clicky switches. She loved these keyboards because they
    reminded her of her father’s IBM Model M keyboard. She used to play with it when
    she was little. Kitty wanted to remember the inspiration for this project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂腋下夹着一个盒子走进来。她订购了一个新的键盘，那种有响亮蓝色点击开关的键盘。她喜欢这些键盘，因为它们让她想起了她父亲的IBM Model M键盘。她小时候经常玩它。凯蒂想记住这个项目的灵感来源。
- en: A short time ago, she and her sister, Phoebe, had started a successful bicycle
    manufacturing company. Their outlook was optimistic until their father was diagnosed
    with a rare degenerative muscular disease called dermatomyositis and he was newly
    confined to a wheelchair. Kitty and Phoebe’s mother had fought a long legal battle
    with their medical insurance provider, who refused to pay for the expensive wheelchair
    their father needed to cope with his disease. Phoebe took matters into her own
    hands and decided, nearly singlehandedly, that she could make a wheelchair for
    their father and everyone else who needed one. Naturally, Kitty followed her younger
    sister’s lead because she knew Phoebe was right. “*Today is the day,*” Kitty thought,
    *“we change the world.”* The new keyboard would keep her focus on her father and
    all the people she could help just by doing a little typing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，她和她的妹妹菲比成立了一家成功的自行车制造公司。她们的展望是乐观的，直到她们的父亲被诊断出患有罕见的进行性肌肉萎缩症——皮肤肌炎，并被新近困在轮椅上。凯蒂和菲比的妈妈与他们的医疗保险提供商进行了漫长的法律斗争，因为保险公司拒绝支付他们父亲需要的昂贵轮椅，以应对他的疾病。菲比亲自处理此事，几乎单枪匹马地决定她可以为他们的父亲以及所有需要的人制造轮椅。自然，凯蒂跟随她年轻的妹妹，因为她知道菲比是对的。“*今天是改变世界的一天，*”凯蒂想，“*我们今天要改变世界。*”新的键盘将让她专注于她的父亲以及她仅通过打字就能帮助的所有人。
- en: Tom showed up to the lab wearing his finest nerdy T-shirt; it bore a famous
    XKCD cartoon featuring two developers sword fighting with the lettering on the
    shirt stating that Tom was not slacking off; he was merely waiting for his code
    to compile. Phoebe arrived with a stack of pizzas and a palette of fizzy water.
    The advantage to starting work at noon is that it’s easy to get the supplies needed.
    As we all know, a programmer is merely a biological machine that converts pizza
    and caffeine into code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 汤姆穿着他最好的书呆子T恤来到实验室；上面印有一幅著名的XKCD漫画，描绘两位开发者手持剑在比武，T恤上的字迹写着汤姆并没有偷懒，他只是在等待代码编译。菲比带着一摞披萨和一瓶汽水到来。中午开始工作的好处是很容易弄到所需的用品。众所周知，程序员不过是一台生物机器，将披萨和咖啡因转化为代码。
- en: The trio got set up and Phoebe turned off the harsh overhead fluorescent lights.
    After a quick scrum session, they decided on a part of the application where they
    would get started. With any luck, they could have this done in a few days and
    this code might be the most important code the sisters, with Tom’s help, might
    ever write.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这三人准备就绪，菲比关掉了刺眼的顶灯。经过短暂的敏捷会议，他们决定从应用程序的哪个部分开始着手。如果一切顺利，他们几天内就能完成这项工作，这可能是姐妹俩在汤姆的帮助下可能写出的最重要的代码。
- en: Setting up the project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Kitty, Phoebe, and Tom hunker down in front of Kitty’s new keyboard. The three
    are intent on using pair programming. Pair programming occurs when two or more
    developers work together and one keyboard is shared. One person types as the others
    watch. The developers trade positions every so often. The developers who are not
    typing are responsible for watching and helping with research. Pair programming
    negates the need for code reviews and is shown to dramatically increase developer
    productivity. If you’re not familiar with the practice of pair programming, check
    out the book *Practical Remote Pair Programming* listed in the *Further reading*
    section of this chapter. Tom is intimately familiar with the design, but Kitty
    and Phoebe can type faster. Tom’s ability to type with his toes is truly amazing,
    but he accepted a long time ago that typing speed is not a value he brings to
    a team. Kitty and Phoebe have far less coding experience, but having spent the
    last few years writing research papers at separate universities, their typing
    has become quite fast. Kitty decides to take the keyboard first while Phoebe fuels
    up on pizza and fizzy water. Kitty opens her favorite IDE and creates a new **Console
    Application** project as shown in *Figure 7.2*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂、菲比和汤姆挤在奇蒂的新键盘前。他们三人决心使用结对编程。结对编程发生在两个或更多开发者一起工作并且共享一个键盘的情况下。一个人打字，其他人观看。开发者们时不时地交换位置。不打字的开发者负责观看并帮助进行研究。结对编程消除了代码审查的需要，并且显示出显著提高开发者生产力的效果。如果你不熟悉结对编程的实践，可以查看本章“进一步阅读”部分列出的书籍《实用远程结对编程》。汤姆对设计非常熟悉，但奇蒂和菲比打字更快。汤姆用脚打字的能力真正令人惊叹，但他很久以前就接受了打字速度并不是他能为团队带来的价值。奇蒂和菲比有较少的编码经验，但过去几年在各自的大学撰写研究论文，他们的打字速度已经变得相当快。奇蒂决定先拿键盘，而菲比则吃披萨和汽水补充能量。奇蒂打开她最喜欢的集成开发环境（IDE），创建了一个新的**控制台应用程序**项目，如图7.2所示。
- en: '![Figure 7.2: Creating a new command-line project. ](img/B18605_Figure_7.2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：创建一个新的命令行项目](img/B18605_Figure_7.2.jpg)'
- en: 'Figure 7.2: Creating a new command-line project.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：创建一个新的命令行项目。
- en: If you’re following along with a different IDE, and you’re not sure how to create
    a command-line project, check out [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    of this book. In it, I cover project creation mechanics for Visual Studio, Rider,
    and Visual Studio Code. I used Rider for this book because it has exceptional
    tools for cleaning and formatting code that come in handy when you’re writing
    a book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不同的IDE，并且不确定如何创建命令行项目，可以查看本书的[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)。其中，我涵盖了Visual
    Studio、Rider和Visual Studio Code的项目创建机制。我使用Rider编写这本书，因为它具有出色的代码清理和格式化工具，这在写书时非常有用。
- en: Once Kitty had created the project, she put Visio on one of the other monitors
    so she could see the UML diagrams for the project. The first diagram she opened
    was actually the very last diagram they had worked on. You can see it in *Figure
    7.3*. Tom had added a change to a central interface called `IManufacturable`.
    This is a very good place to start since everything else flows from this one interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦奇蒂创建了项目，她将Visio软件放在另一个显示器上，以便查看项目的UML图。她打开的第一个图实际上是他们最后工作的那个图。您可以在图7.3中看到它。汤姆对一个称为`IManufacturable`的中心接口进行了修改。这是一个非常好的起点，因为所有其他内容都从这个接口流出来。
- en: '![Figure 7.3: The IManufacturable interface and a class structure that implements
    make the perfect place to start. ](img/B18605_Figure_7.3.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：`IManufacturable`接口和实现它的类结构，这是一个完美的起点](img/B18605_Figure_7.3.jpg)'
- en: 'Figure 7.3: The IManufacturable interface and a class structure that implements
    make the perfect place to start.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：`IManufacturable`接口和实现它的类结构，这是一个完美的起点。
- en: 'Kitty adds a new file called `IManufacturable` and types the code indicated
    by the diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂添加了一个名为`IManufacturable`的新文件，并按照图示输入代码：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve seen these properties before in the `bicycle` project. The `Year` and
    `SerialNumber` properties are going to be set automatically by the constructor
    in the implementing class, so only a `get` method is needed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在`bicycle`项目中见过这些属性。`Year`和`SerialNumber`属性将由实现类中的构造函数自动设置，因此只需要一个`get`方法。
- en: 'Next, Kitty adds the abstract `Wheelchair` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，奇蒂添加了抽象的`Wheelchair`类：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The class is marked as `abstract` as per the diagram. Don’t forget that in
    UML, abstract classes display the class title *in italics*. This can be difficult
    to see with some of the fonts in UML modeling tools. The `Wheelchair` class implements
    the `IManufacturable` interface Kitty made a moment ago. Most IDEs can generate
    the missing members specified by the interface. Kitty generated the following
    code. She made `BuildStatus` nullable by adding the question mark next to the
    type definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图示，该类被标记为`abstract`。不要忘记在UML中，抽象类以斜体显示类标题。在使用某些UML建模工具的字体中，这可能很难看到。`Wheelchair`类实现了Kitty刚才制作的`IManufacturable`接口。大多数IDE可以生成接口指定的缺失成员。Kitty生成了以下代码。她在类型定义旁边添加了问号，使`BuildStatus`可空：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The constructor is almost identical to those used in the `bicycle` project.
    Since the class is abstract, it makes sense to expose the constructor as `protected`.
    Within the constructor, Kitty initializes everything she can:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数几乎与`bicycle`项目中使用的构造函数相同。由于该类是抽象的，因此将构造函数公开为`protected`是有意义的。在构造函数内部，Kitty初始化了她能初始化的一切：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `SerialNumber` attribute is a GUID. This is a system-generated string that
    is guaranteed to be unique. This makes it perfect for a serial number. The `Year`
    attribute is initialized to the current year.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`SerialNumber`属性是一个GUID。这是一个系统生成的唯一字符串。这使得它非常适合作为序列号。`Year`属性初始化为当前年份。'
- en: '*“Let’s wait on the frame* *and seat properties for now. They’re not primitives
    and we haven’t created classes for them yet,”* Tom said.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “我们先等等框架和座椅属性。它们不是原始类型，我们还没有为它们创建类，”Tom说。
- en: 'Tom’s design split wheelchairs into two types: unpowered chairs and powered
    chairs. Kitty adds the `UnpoweredChair` class next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Tom的设计将轮椅分为两种类型：手动轮椅和电动轮椅。Kitty接下来添加了`UnpoweredChair`类：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'She doesn’t make it very far. Like most class diagrams, the types needed for
    the `RightWheel`, `LeftWheel`, and `Casters` properties aren’t specified. “*We
    need the composite diagram for the types,*” Tom reminded her. That particular
    diagram can be seen in *Figure 7.4*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 她没有走得太远。像大多数类图一样，`RightWheel`、`LeftWheel`和`Casters`属性所需的类型没有指定。“*我们需要复合图来指定类型，*”Tom提醒她。那个特定的图可以在*图7.4*中看到：
- en: '![Figure 7.4: The Composite structure. ](img/B18605_Figure_7.4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：复合结构](img/B18605_Figure_7.4.jpg)'
- en: 'Figure 7.4: The Composite structure.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：复合结构。
- en: 'Tom’s design for the Composite pattern makes each part of the wheelchair out
    of an abstract class called `WheelchairComponent`. The wheels and casters in our
    current model need this abstract class defined before we can get the types correct.
    Kitty adds a new class called `WheelchairComponent`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Tom为复合模式设计的方案是将轮椅的每个部分都由一个名为`WheelchairComponent`的抽象类构成。在我们当前模型中，车轮和脚轮需要定义这个抽象类，我们才能正确地获取类型。Kitty添加了一个名为`WheelchairComponent`的新类：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to use the Composite pattern, we need a few properties. The point of
    the Composite pattern is to use a tree-like structure to process lists. Kitty
    and Phoebe want to be able to iterate recursively over their wheelchair model
    instance to report on the weight and cost for each component. These numbers can
    be summed at any level to determine the weight and cost of a single part or a
    subset of the chair. For example, it might be useful to know the weight and cost
    of the assembled frame. When we are working with bicycles, weight and cost are
    typical trade-offs. Cheaper components are heavier. Competitive cyclists are willing
    to pay more to shave grams off their total weight. Doing this can reduce the time
    of a long ride by a few seconds, which might be enough to win a race.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用复合模式，我们需要一些属性。复合模式的目的在于使用树状结构来处理列表。Kitty和Phoebe希望能够递归地遍历他们的轮椅模型实例，以报告每个组件的重量和成本。这些数字可以在任何级别上累加，以确定单个部件或椅子子集的重量和成本。例如，了解组装好的框架的重量和成本可能是有用的。当我们处理自行车时，重量和成本是典型的权衡。较便宜的组件更重。竞争性自行车手愿意支付更多以减少他们的总重量。这样做可以减少长途骑行的时间几秒钟，这可能会赢得比赛。
- en: Lightweight components for a wheelchair have the same concerns as bicycles;
    however, the motivation is driven by a different purpose. Kitty and Phoebe’s dad
    has a degenerative muscle disease. He specifically needs something lightweight
    if he’s going to be using an unpowered chair. Some wheelchair users have very
    strong upper bodies; others are not as strong. Lightweight materials are still
    balanced against cost, and the Composite pattern will help the engineering team
    analyze and improve the cost-to-weight ratio for the wheelchairs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 轮椅的轻量组件与自行车的关注点相同；然而，动机是由不同的目的驱动的。Kitty和Phoebe的父亲患有进行性肌肉疾病。如果他打算使用无动力椅子，他特别需要轻量级的物品。一些轮椅用户有非常强壮的上半身；而另一些人则不那么强壮。轻量材料仍然需要在成本和重量之间取得平衡，而组合模式将帮助工程团队分析和改进轮椅的成本与重量比。
- en: 'Since this class is abstract, its members are going to be `protected`, unless
    there’s a good reason for them to not be `protected`. Kitty adds properties for
    `Weight` and `Price` as floats:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类是抽象的，其成员将被设置为`protected`，除非有充分的理由不将其设置为`protected`。Kitty为`Weight`和`Price`属性添加了浮点数：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, Kitty adds the crucial part of the class. The Composite pattern needs
    a `Subcomponents` collection. Remember, components in the composite are either
    leaves or containers. Containers are nodes in the tree that have other nodes within
    them. During the design phase, Kitty and Tom drew a diagram of the composite’s
    tree structure on a whiteboard. You can see that again in *Figure 7.5*, with Tom’s
    design written on the left side and Kitty’s on the right.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Kitty添加了类的关键部分。组合模式需要一个`Subcomponents`集合。记住，组合中的组件要么是叶子，要么是容器。容器是树中的节点，其中包含其他节点。在设计阶段，Kitty和Tom在白板上绘制了组合的树状结构图。您可以在*图7.5*中再次看到它，Tom的设计写在左侧，Kitty的设计写在右侧。
- en: '![Figure 7.5: Tree-like structure for powered and unpowered chairs. ](img/figure-7-5.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：带动力和无动力的椅子树状结构](img/figure-7-5.jpg)'
- en: 'Figure 7.5: Tree-like structure for powered and unpowered chairs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：带动力和无动力的椅子树状结构。
- en: If you look at the axle on the unpowered chair, you will see that it has components
    within it. The axle is a container. The right caster, on the other hand, doesn’t
    contain any other components, so it is a leaf.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看无动力椅子的轴，您会看到其中包含组件。轴是一个容器。另一方面，右边的轮子不包含任何其他组件，因此它是一个叶子。
- en: 'Regardless of whether they are a container or a leaf, all classes in the structure
    use the same base class, which contains a collection to hold other components.
    In effect, everything has the potential to be a container, even if it is merely
    a leaf. Kitty adds the collection:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论它们是容器还是叶子，结构中的所有类都使用相同的基类，该基类包含一个用于存储其他组件的集合。实际上，一切都有可能成为容器，即使它仅仅是一个叶子。Kitty添加了该集合：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note: the collection type is the very class she’s writing. This allows the
    composite to be iterable. We will rely on Liskov substitution heavily by requiring
    this base class for our types, but will supply concrete classes when we actually
    implement the Builder pattern later.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：集合类型正是她正在编写的类。这使得组合模式可以迭代。我们将通过要求我们的类型使用这个基类而大量依赖Liskov替换原则，但在实际实现Builder模式时，我们将提供具体的类。
- en: 'Next, Kitty adds a constructor and initializes all the properties:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Kitty添加了一个构造函数并初始化了所有属性：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The diagram in *Figure 7.4* indicates a couple of methods. Kitty isn’t far
    enough along yet to worry about the specifics of these methods. For now, she just
    adds a line that throws `NotImplementedException` should anything try to access
    these methods. This is a very common placeholder:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.4*中的图表明了一些方法。Kitty还没有深入到需要担心这些方法的细节。目前，她只是添加了一条抛出`NotImplementedException`的语句，如果任何尝试访问这些方法。这是一个非常常见的占位符：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this done, Kitty can return to defining the `UnpoweredChair` class. She
    switches to the `UnpoweredChair.cs` file in her IDE. This time, she gets a little
    further. She adds the three properties required by the class diagram (*Figure
    7.3*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，Kitty可以回到定义`UnpoweredChair`类。她切换到IDE中的`UnpoweredChair.cs`文件。这一次，她前进了一小步。她添加了类图(*图7.3*)中所需的三个属性：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Kitty’s IDE indicates a problem with a yellow wavy line beneath each property.
    She hasn’t initialized any of them. This isn’t a huge problem because she knows
    she’s going to be using the Builder pattern later to fill in these details based
    on which chair model is being built.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty的IDE在每个属性下方显示了一个黄色波浪线，表明存在问题。她还没有初始化任何一个属性。这不是一个大问题，因为她知道她将使用Builder模式来填充这些细节，这些细节将基于正在构建的椅子型号。
- en: It was right about then that Kitty was startled by a loud voice behind her.
    “*PEEE-EW! That’s some smelly code you got there!*” Phoebe exclaimed. Apparently,
    having downed a few slices of pizza and a few cans of caffeinated fizzy water,
    she was ready to be tagged in.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这时，凯蒂被背后的一声大叫声吓了一跳。“*呸！你那里的代码真臭！*”菲比惊叫道。显然，她刚刚吃了几片披萨和几罐含咖啡因的汽水，准备接受挑战。
- en: “*What?*” Kitty asked sheepishly. Tom chimed in, “*I think she’s upset because
    you used the WheelchairComponent base class for your types.*”
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “*什么？*”凯蒂尴尬地问道。汤姆插话道，“*我想她生气是因为你为你的类型使用了WheelchairComponent基类*。”
- en: “*I thought that’s what we were doing*,” Kitty replied.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “*我以为我们正在做这个*，”凯蒂回答。
- en: “*Look again, Sis. The composite diagram* *has classes under the WheelchairComponent
    class* *that are more specific*,” Phoebe said. Kitty got up and Phoebe took her
    place.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “*再看看，姐姐。复合图* *在WheelchairComponent类下有更具体的类*，”菲比说。凯蒂站起来，菲比接替了她的位置。
- en: Wheelchair components
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮椅组件
- en: 'Phoebe sat down and made a show of stretching her neck and cracking her knuckles.
    If this were a fight scene in an action movie, this would be her opponent’s cue
    to be intimidated. Instead, the cursor blinked unafraid in the IDE. “*This is
    a good spot for me to fill in because I know a little bit more about the actual
    components,*” said Phoebe. She was right. Phoebe had spent many hours sourcing
    parts and figuring out how to make what she couldn’t buy while building bikes.
    In *Figure 7.4*, we can see there is a set of abstract components that all inherit
    from `WheelchairComponent`. The `WheelchairComponent` base class gives us the
    `Weight` and `Price` fields used in the composite pattern to help us iteratively
    compute the weight and price of a set of components. The diagram lists nine such
    components:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比坐下，假装伸脖子并敲打她的指关节。如果这是一部动作电影中的打斗场景，这将是对手感到威胁的提示。相反，光标在IDE中无畏地闪烁。“*这是一个很好的地方来填充，因为我对实际组件了解得更多*，”菲比说。她是对的。菲比花了很多小时寻找零件，并在组装自行车时想出如何制作她买不到的东西。在*图7.4*中，我们可以看到有一组抽象组件，它们都继承自`WheelchairComponent`。`WheelchairComponent`基类为我们提供了在组合模式中使用的`Weight`和`Price`字段，帮助我们迭代计算一组组件的重量和价格。图中列出了九个这样的组件：
- en: '`WheelchairSeat`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WheelchairSeat`'
- en: '`Axle`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Axle`'
- en: '`CasterAssembly`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CasterAssembly`'
- en: '`MechanicalWheel`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MechanicalWheel`'
- en: '`ElectricMotor`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElectricMotor`'
- en: '`WheelchairFrame`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WheelchairFrame`'
- en: '`Battery`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Battery`'
- en: '`TrackDriveSystem`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrackDriveSystem`'
- en: '`SteeringMechanism`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SteeringMechanism`'
- en: Phoebe will need to make a class for each item on the list. “*That’s a lot of
    components*,” Phoebe said. “*Can we focus on a minimum viable product here?”*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比需要为列表上的每一项创建一个类。“*这有很多组件*，”菲比说。“*我们能不能专注于最小可行产品？*”
- en: 'A **minimum viable product (MVP)** is a term from agile development. **Agile
    development** is a project management paradigm Kitty had learned in one of her
    product development courses. Agile methodologies are popular in software companies
    because they allow you to get a product to market quickly by focusing on the smallest
    product the company can sell. It then uses **iterative development** to build
    that product in a series of small bursts of effort. In this case, we have two
    wheelchair designs. The *Texas Tank* is seriously cool, but it will also be seriously
    expensive to make. The trio realizes they can make a huge impact by building the
    simple unpowered chair: the *Plano Wheelchair*. The faster this chair goes to
    market, the more people they can help. The team decides to focus on just making
    that chair. This cuts down her list to just these components:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小可行产品（MVP）**是敏捷开发中的一个术语。**敏捷开发**是凯蒂在她的产品开发课程中学到的一种项目管理范式。敏捷方法在软件公司中很受欢迎，因为它们允许你通过关注公司能卖出的最小产品来快速将产品推向市场。然后它使用**迭代开发**来分几个小阶段构建该产品。在这种情况下，我们有两种轮椅设计。*德克萨斯坦克*非常酷，但制作成本也会非常高。三人意识到，通过制作简单的非动力轮椅：*普兰诺轮椅*，他们可以产生巨大的影响。这个椅子越快上市，他们就能帮助更多的人。团队决定只专注于制作这张椅子。这使她的列表缩减到只有这些组件：'
- en: '`WheelchairSeat`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WheelchairSeat`'
- en: '`Axle`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Axle`'
- en: '`CasterAssembly`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CasterAssembly`'
- en: '`MechanicalWheel`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MechanicalWheel`'
- en: '`WheelchairFrame`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WheelchairFrame`'
- en: “*Why don’t you make a folder for those?* *It will make them easier to find
    later and our code will be a little less cluttered*,” Tom suggested. A focused
    expression settled over Phoebe’s countenance. She added a folder to her project
    called `WheelchairComponents`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: “*为什么不为这些文件创建一个文件夹呢？* *这样以后找起来会更容易，我们的代码也会稍微整洁一些*，”汤姆建议。一个专注的表情出现在菲比的脸上。她为自己的项目添加了一个名为`WheelchairComponents`的文件夹。
- en: 'Next, Phoebe added a class within the folder called `WheelchairSeat`. She also
    added the remaining classes from the list, each one being empty for now. At this
    point, her project resembles *Figure 7.6*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，菲比在文件夹内添加了一个名为`WheelchairSeat`的类。她还添加了列表中的剩余类，目前每个类都是空的。在这个时候，她的项目类似于*图7.6*：
- en: '![Figure 7.6:  The folder structure for the abstract wheelchair components.
    ](img/B18605_Figure_7.6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：抽象轮椅组件的文件夹结构。](img/B18605_Figure_7.6.jpg)'
- en: Figure 7.6:  The folder structure for the abstract wheelchair components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：抽象轮椅组件的文件夹结构。
- en: “*It probably makes sense to move the WheelchairComponent.cs file into that
    folder as well*,” Tom advised. Phoebe dragged the file from the project’s root
    folder into the subfolder with the other nine class files she had just created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “*可能有必要将WheelchairComponent.cs文件也移动到那个文件夹中，*”汤姆建议。菲比将文件从项目的根文件夹拖动到包含她刚刚创建的其他九个类文件的子文件夹中。
- en: “*Hey, open that file real quick. Let’s make sure the IDE changed the namespace
    for you,”* said Tom. *“Some IDEs do this and some don’t,*” he continued. Phoebe
    double-clicked the file in Rider. The IDE, in fact, did not change the code. Namespaces
    in C# are like packages in Java. Their job is to help you keep your code organized
    and to prevent name collisions in complicated projects. Tom doubted this project
    would be complicated enough to have such a name collision. A name collision occurs
    when you want to name two classes with the same name. This is illegal in C# if
    the classes are in the same namespace. The project’s namespace is usually created
    automatically when the project is created in your IDE.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “*嘿，快点打开那个文件。让我们确保IDE已经为你更改了命名空间，*”汤姆说。*“有些IDE会这样做，而有些则不会，*”他继续说道。菲比在Rider中双击了文件。实际上，IDE并没有更改代码。在C#中，命名空间就像Java中的包。它们的作用是帮助您组织代码，并在复杂的项目中防止名称冲突。汤姆怀疑这个项目不会复杂到需要这样的名称冲突。名称冲突发生在您想要用相同的名称命名两个类时。如果这些类在同一个命名空间中，这在C#中是不合法的。项目的命名空间通常在您在IDE中创建项目时自动创建。
- en: 'Changing the namespace in the `WheelchairComponent.cs` file isn’t crucial to
    the operation of the program. Since Tom and Phoebe have chosen to organize their
    code into folders, it is conventional to have the namespace match the folder structure.
    Phoebe modifies the `WheelchairComponent` class code to reflect the new folder
    location. This is done at the top of the file. The code before the operation reads
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WheelchairComponent.cs`文件中更改命名空间对于程序的操作并不关键。由于汤姆和菲比选择将代码组织到文件夹中，通常的做法是将命名空间与文件夹结构相匹配。菲比修改了`WheelchairComponent`类的代码，以反映新的文件夹位置。这是在文件顶部完成的。操作之前的代码如下所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Phoebe corrects it to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比将其更正为以下内容：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After she did this, her IDE immediately colored her `UnpoweredChair` class with
    red underlines alerting her to a syntax problem. It used `WheelchairComponent`,
    and we just changed the namespace. Fixing this is error is easy. We just need
    to add a `using` statement to the top of the file. However, doing so right now
    is pointless. Phoebe intends for this class to use the class files she just created
    instead of the abstract `WheelchairComponent` class, which is too generic to represent
    an actual component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 她这样做之后，她的集成开发环境（IDE）立即用红色下划线标记了她的`UnpoweredChair`类，提醒她存在一个语法问题。它使用了`WheelchairComponent`组件，而我们只是更改了命名空间。修复这个错误很容易。我们只需要在文件顶部添加一个`using`语句。然而，现在这样做是没有意义的。菲比打算让这个类使用她刚刚创建的类文件，而不是过于通用的抽象`WheelchairComponent`类，后者不足以代表一个实际组件。
- en: 'Phoebe switches her focus back to the `MechanicalWheel` component she created
    a moment ago. Right now, the class merely contains the boilerplate added by the
    IDE:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比将注意力转回到她刚才创建的`MechanicalWheel`组件。目前，这个类只包含IDE添加的样板代码：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Phoebe goes to work on it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比开始处理这个问题：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Phoebe adds three properties to describe an abstract wheel. “*Why are we making
    this class abstract?*” Kitty asked. Kitty was sitting off to the side, but the
    group had set up a monitor so that whoever was sitting out from typing could see
    all the action. Phoebe answered, “We’ll later *define more concrete wheels, but
    having this abstract is a smart defense against future change. We don’t want to
    tightly couple our UnpoweredChair class to a particular wheel. Instead, just about
    any type of mechanical wheel you can imagine can be implemented as a subclass
    to this one. Unless we come up with a radically new type of wheel, all wheels
    will have a radius. Most wheelchair wheels have spokes, but even if you had one
    that didn’t, you could set the spoke count to zero. Finally, most wheelchairs
    have some sort of tire. Some are solid and some use air. The ones that use air
    are called pneumatic tires and are similar to typical bicycle tires.”*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比为抽象轮子添加了三个属性。“*我们为什么要创建这个抽象类？*”凯蒂问道。凯蒂坐在一边，但小组已经设置了一个显示器，这样无论谁坐在打字之外都能看到所有的动作。菲比回答道：“我们稍后会定义更具体的轮子，但拥有这个抽象的是对未来变化的明智防御。我们不希望我们的无动力椅子类与特定的轮子紧密耦合。相反，几乎任何你能想象到的机械轮都可以作为这个轮子的子类实现。除非我们想出一种全新的轮子类型，所有的轮子都将有一个半径。大多数轮椅轮子都有辐条，但即使你没有，你也可以将辐条数设置为零。最后，大多数轮椅都有某种轮胎。有些是实心的，有些使用空气。使用空气的被称为充气轮胎，类似于典型的自行车轮胎。”
- en: '*“I get it!”* Kitty exclaimed. “*You’re going to use this class and the others
    like it from our list to define the structure of the UnpoweredChair class. Then
    you’re going to define concrete classes for the actual wheels we’ll be using.
    When the builder class constructs the wheelchair object, it can specify the concrete
    classes. The Liskov substitution allows us to substitute a parent class for a
    subclass, thus our design remains flexible*.”'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: “*我明白了！*”凯蒂大声说道。“*你打算使用这个类以及我们列表中的其他类来定义无动力椅子类的结构。然后你将定义实际使用的具体轮子的类。当构建类构建轮椅对象时，它可以指定具体的类。Liskov替换原则允许我们用父类替换子类，因此我们的设计保持灵活。”
- en: “*You’ve got it!”* Tom said. “*Now we need to do the same thing with the rest
    of the components*.”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “*你明白了！*”汤姆说。“*现在我们需要对其他所有组件做同样的事情。*”
- en: 'I need to break the fourth wall here for a minute: I am what you might call
    a detail junkie. I’m the kind of guy that likes to point out mistakes in TV shows
    and movies. I think it’s a safe assumption, given you are reading this book, that
    you have likely seen the TV show *Star Trek, The Next Generation*. If that was
    before your time, you now have a binge-watching assignment after you complete
    this book. Here are a few things I noticed in that show. In Season 1, Episode
    13, the android Data drinks spiked champagne, falling backward, and in the very
    next scene, he is face down. In Season 1, Episode 25, Riker orders Geordi to increase
    the speed of the starship Enterprise to Warp 6\. Geordi replies, *“Aye* *sir,
    full impulse.”* In Star Trek, “warp” refers to a logarithmic scale relative to
    the speed of light, while “impulse” refers to sublight speed. As I said, things
    like that bother me. I realize, having said that, I will probably be inundated
    with emails regarding my own inconsistencies within this book. Here’s my rule
    about that: you’re only allowed to do this if you tell all your friends to buy
    the book so you can have a nice chuckle over my errors. If all your friends buy
    the book, we’ll sell enough to do a second printing, and I can fix all the continuity
    mistakes. Of course, I’ll probably introduce some new ones during the revision
    process, so the cycle will continue. I’m okay with that if you are.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要在这里打破第四面墙一会儿：我可能被你们称作细节狂热者。我这类人喜欢指出电视剧和电影中的错误。鉴于你在读这本书，我敢肯定你很可能看过电视剧《星际迷航：下一代》。如果你没看过，那么在读完这本书后，你将有一个狂热观看的任务。以下是我在这部剧中注意到的几点。在第一季第13集中，机器人数据喝下了加了料的香槟，倒退着走，而在接下来的场景中，他脸朝下。在第一季第25集中，里克要求乔治提高星际飞船企业号的航速至
    warp 6。乔治回答道：“是，先生，全速前进。”在《星际迷航》中，“warp”指的是相对于光速的对数尺度，而“impulse”指的是亚光速。正如我所说的，这类事情会让我感到烦恼。我意识到，这么说后，我可能会收到大量关于我在这本书中自己不一致性的邮件。关于这一点，我的规则是：只有当你告诉所有你的朋友买这本书，这样你才能在看到我的错误时开心地大笑时，你才能这样做。如果你的所有朋友都买了这本书，我们就能卖出足够的数量来再版，我就能修正所有的连续性错误。当然，在修订过程中，我可能会引入一些新的错误，这样循环就会继续。如果你也这样想，我就没问题。
- en: Here, I’m trying to spare you the tedium of making this so realistic that there
    are hundreds of classes. Don’t forget that our focus is patterns. This isn’t an
    attempt to build a real wheelchair model that would pass muster with a mechanical
    engineer. I’ll be doing more of this as the chapter progresses. Direct your focus
    to the structure of the objects, not their contents. The parts important to the
    patterns are always going to be there; the rest just makes for a good story. Now
    that we’ve gotten that out of the way, let’s fast-forward a bit. All of the classes
    in the `WheelchairComponents` folder are going to be abstract classes that subclass
    `WheelchairComponent`. The other properties don’t affect the Composite pattern
    or any other part of our program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我试图避免让你感到乏味，因为要使它如此真实，以至于有数百个类。别忘了，我们的重点是模式。这不是尝试构建一个能够通过机械工程师审查的真正轮椅模型。随着章节的进展，我会做更多类似的事情。将你的注意力集中在对象的结构上，而不是它们的内含物上。对模式重要的部分始终都会存在；其余的只是构成一个好故事。现在我们已经解决了这个问题，让我们快速前进一点。`WheelchairComponents`文件夹中的所有类都将作为子类继承自`WheelchairComponent`的抽象类。其他属性不会影响组合模式或我们程序的任何其他部分。
- en: We now return you to your story already in progress.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将你带回已经进行中的故事。
- en: Phoebe continues filling out the remaining classes in the components list. We’ll
    go in alphabetical order focusing only on the components needed in an unpowered
    chair. The first class is the Axle class. Remember that in the Component pattern,
    each element is either a container or a leaf. Containers contain other containers
    and leaves. A leaf cannot contain anything. According to *Figure 7.5*, the `Axle`
    is a container which holds the left and right wheels.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比继续填写组件列表中剩余的类别。我们将按字母顺序进行，只关注在非动力轮椅中需要的组件。第一个类别是轴类。记住，在组件模式中，每个元素要么是容器，要么是叶子。容器包含其他容器和叶子。叶子不能包含任何东西。根据*图7.5*，`轴`是一个容器，它包含左右两个轮子。
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’ll add the two wheels as private fields.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加两个轮子作为私有字段。
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These next two properties define the axle, which is just a cylinder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个属性定义了轴，它只是一个圆柱体。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, Phoebe adds accessor methods for the `_leftWheel` and `_rightWheel` fields.
    First comes the left wheel. Note the `FixComposite()` method. This implements
    Tom’s original idea of having the Composite pattern baked directly into the object
    structure, in contrast with Kitty and Phoebe’s implementation in the bicycle project
    which used a separate object graph. We’ll create the `FixComposite()` method in
    just a moment.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，菲比为`_leftWheel`和`_rightWheel`字段添加了访问器方法。首先是左轮。注意`FixComposite()`方法。这个方法实现了汤姆最初的想法，即直接将组合模式嵌入到对象结构中，与凯蒂和菲比在自行车项目中的实现形成对比，后者使用了一个单独的对象图。我们将在稍后创建`FixComposite()`方法。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then comes the right wheel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是右轮。
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, with Tom’s guidance, Phoebe creates a method called `FixComposite()`.
    *“You need to put this on the abstract components.”*, Tom said. Phoebe added the
    following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在汤姆的指导下，菲比创建了一个名为`FixComposite()`的方法。汤姆说：“你需要把它放在抽象组件上。”菲比添加了以下代码：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*“I see what you’re doing!”*, Kitty said from her chair behind Phoebe. *“Each
    component manages the subcomponents inside it. Instead of making a separate object
    graph, you’re having the accessor methods rebuild the composite every time the
    left and right wheels change.”*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “我明白你在做什么！”凯蒂从坐在菲比后面的椅子上说。“每个组件管理它内部的子组件。你不需要创建一个单独的对象图，而是让访问器方法在左右轮子改变时重建组合。”
- en: '*“Why aren’t we putting it in the* `WheelchairComponent` *base class?”,* asked
    Phoebe. *“There are two reasons.”*, Tom said. *“First, this method is specific
    to the Axle. It contains these two specific components”* Phoebe interrupted, *“But
    we could make it abstract, and override it in the subclasses.”*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “我们为什么不在*`WheelchairComponent`*基类中放它？”菲比问道。“有两个原因。”汤姆说。“首先，这个方法特定于轴。它包含这两个特定的组件。”菲比打断说，“但我们也可以将其设为抽象的，并在子类中重写它。”
- en: '*“Let me finish, Phoebe”,* said Tom. He continued, *“The second reason is the
    interface segregation principle from SOLID. Only containers need this method.
    The leaves don’t have any sub-components, and so have no need to fix the list
    of subcomponents on the WheelchairComponent base class. The interface segregation
    principle holds that no class should be forced to implement an interface it doesn’t
    use, nor should it depend on a method it doesn’t need. If we make this an abstract
    method in the base class, the leaf classes will have to implement it. Any implementation
    we add with be contrived, and it will introduce a code smell to those classes.”*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: “让我说完，菲比，”汤姆说。他继续说，“第二个原因是SOLID原则中的接口隔离原则。只有容器需要这个方法。叶子没有任何子组件，因此不需要在`WheelchairComponent`基类上固定子组件列表。接口隔离原则认为，没有类应该被迫实现它不使用的接口，也不应该依赖于它不需要的方法。如果我们把这个做成基类中的抽象方法，叶子类将不得不实现它。我们添加的任何实现都将是有意为之的，并且会给这些类引入代码异味。”
- en: '*“Who is writing smelly code, now Phoebe?”*, Kitty chided as she enjoyed sweet
    revenge on her sister.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: “现在谁在写有异味的代码，菲比？”凯蒂一边说，一边享受着对妹妹的甜蜜报复。
- en: 'Phoebe shrugged off her sisters jab and continued working. Based on *Figure
    7.5*, she knows these classes need a `FixComponent()` method because they are
    containers:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比对妹妹的嘲讽置之不理，继续工作。根据*图7.5*，她知道这些类需要一个`FixComponent()`方法，因为它们是容器：
- en: '`Axle` (already written)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Axle`（已编写）'
- en: '`CasterAssembly`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CasterAssembly`'
- en: '`Wheelchair`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wheelchair`'
- en: '`WheelchairFrame`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WheelchairFrame`'
- en: '`Wheelchair` is the base class for all wheelchairs. It needs to inherit from
    `WheelchairComponent` because we need a top-level container. Phoebe makes extensive
    modifications to the Wheelchair class. When she’s finished, it looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wheelchair`是所有轮椅的基类。它需要从`WheelchairComponent`继承，因为我们需要一个顶级容器。菲比对`Wheelchair`类进行了大量修改。当她完成时，它看起来是这样的：'
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Phoebe has added the frame and the seat namespaces so we can specify the two
    components that go into the wheelchair. She continues by adding the `WheelchairComponents`
    reference right below the namespace.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比已经添加了框架和座椅命名空间，这样我们就可以指定进入轮椅的两个组件。她继续在命名空间下方添加`WheelchairComponents`引用。
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, she adds the `WheelchairComponent` as the base class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，她将`WheelchairComponent`作为基类添加：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, she adds the private fields for the seat and frame:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，她添加了座椅和框架的私有字段：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then she adds the accessor methods just like before with the `Axle` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后她像之前一样添加了访问器方法，使用`Axle`类：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, Phoebe adds the magical `FixComposite()` method which clears out the subcomponent
    list and adds the _seat and _frame fields. This is called from the accessor methods,
    so anytime these get changed, the composite is updated. Truthfully, since we’ll
    be using the Builder pattern to create these objects, there likely won’t be much
    call for changing the object once it gets created, but its nice to know you can.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，菲比添加了神奇的`FixComposite()`方法，它清除了子组件列表并添加了`_seat`和`_frame`字段。这个方法是从访问器方法中调用的，所以每次这些更改时，组合都会更新。说实话，由于我们将使用Builder模式来创建这些对象，一旦创建对象，可能不会有很多更改的需求，但知道你可以这样做是件好事。
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The rest of the class remains unchanged. Rather than cover every class Phoebe
    created, I encourage you to review her finished code in the `chapter-7` project
    in the book’s sample code. You’ll find most of this in the `WheelchairComponents`
    folder.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分保持不变。与其覆盖菲比创建的每个类，我鼓励你查看书中示例代码中的`chapter-7`项目。你会在`WheelchairComponents`文件夹中找到大部分内容。
- en: Finishing the wheelchair base classes
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成轮椅基类
- en: '*“Nice work, Phoebe. All that’s left* *is to clean up Kitty’s mess*,” Tom chided.
    Kitty stuck out her tongue. Phoebe giggled and opened the `UnpoweredChair` class.
    She now had all the types she needed to model the abstract classes. She updated
    the class code like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: “干得好，菲比。剩下要做的就是清理凯蒂的烂摊子了，”汤姆责备道。凯蒂伸出舌头。菲比咯咯地笑，打开了`UnpoweredChair`类。现在她有了所有需要的类型来建模抽象类。她像这样更新了类代码：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, the `using` statement is needed because we moved the `component` classes
    into the `WheelchairComponents` namespace. The next few lines remain unchanged:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，需要`using`语句，因为我们把`component`类移动到了`WheelchairComponents`命名空间。接下来的几行保持不变：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Phoebe’s next change is to set the correct types for the `RightWheel`, `LeftWheel`,
    and `CasterAssembly` properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比的下一个更改是设置`RightWheel`、`LeftWheel`和`CasterAssembly`属性的正确的类型：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finishing up the composite
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成组合
- en: '*“We should take* *a break soon,”* Phoebe said. “*We’ve got a lot* *done. We’ve
    got most, if not all, of our* *abstract base classes written. Those classes are
    the most important parts of our patterns. We’ve also almost finished the composite
    pattern. We just need to add the methods that recursively compute the weight and
    cost of each component.”*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我们很快应该休息一下，”* 菲比说。“*我们已经做了很多工作。我们几乎写完了大部分，如果不是全部的话，* *我们的抽象基类。这些类是我们模式中最重要的部分。我们几乎完成了组合模式。我们只需要添加递归计算每个组件重量和成本的方法。”* '
- en: “*To do that,”* Tom said, “w*e just need to make two small adjustments. Open
    the WheelchairComponent class.”*
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '“*为了做到这一点，”* 汤姆说，“*我们只需要做两个小的调整。打开WheelchairComponent类。”* '
- en: 'Phoebe complied. She remembered that Kitty had left the `DisplayCost` and `DisplayWeight`
    methods for later. They presently read as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比编译了。她记得基蒂把`DisplayCost`和`DisplayWeight`方法留到了以后。它们现在的样子如下：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Phoebe adds the implementation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比添加了实现：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As with the `BicycleComponent` implementation, first, we check to see whether
    there are any subcomponents. If not, we simply return:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与`BicycleComponent`实现一样，首先，我们检查是否有任何子组件。如果没有，我们简单地返回：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If there are, we print the name and weight:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有，我们打印出名称和重量：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we call the `DisplayWeight` method recursively:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们递归地调用`DisplayWeight`方法：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We do the same thing with `Price`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Price`做同样的事情：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Phoebe slumped in her chair. “*Phew! That* *was a lot of work,*” said Phoebe.
    “*I know. We have* *the structure for the Composite pattern, but we still need
    a builder to populate it*,” said Tom. “*Yeah,*” said Kitty. “*This structure is
    complicated. We can’t just make a Wheelchair object and add the chair, the frame,
    and some wheels like we can with simple composition. We need a way to assemble
    the hierarchy we drew on the board earlier (Figure 7.5).* The three took a break
    and rested up. They knew the next pattern they needed to make was the Builder
    pattern.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比瘫坐在椅子上。“*呼！这* *工作量很大，”* 菲比说。“*我知道。我们* *有组合模式的结构，但我们还需要一个Builder来填充它，”* 汤姆说。“*是的，”*
    基蒂说。“*这个结构很复杂。我们不能像简单组合那样创建一个轮椅对象，然后添加椅子、框架和一些轮子。我们需要一种方法来组装我们在板上之前画出的层次结构（图7.5）。*
    三个人休息了一下，补充了体力。他们知道下一个他们需要制作的模式是Builder模式。
- en: Implementing the Builder pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Builder模式
- en: Kitty had called Karina, their mother, and asked her to stop by, in order to
    give her a break from the non-stop hospital vigil. Phoebe shared some pizza and
    the four played a little Mario Kart on the Nintendo Switch to get their minds
    off their problems. After a few races, Tom, Kitty, and Phoebe were ready to get
    back to work. Karina returned to the hospital
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂给他们的母亲卡拉琳打了电话，让她过来休息一下，以便从连续不断的医院守候中解脱出来。菲比分享了一些披萨，四个人在任天堂Switch上玩了一会儿马里奥赛车，以此来分散他们的注意力。几场比赛后，汤姆、基蒂和菲比准备回去工作了。卡拉琳回到了医院
- en: “*This is going to be the hard part*,” Tom said. “*The Builder pattern implementation
    is going to be doing a lot of work. It needs to assemble the wheelchair object,
    assemble the composite, and ultimately handle the wheelchair’s paint job with
    the Bridge pattern.”*
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “*这将是最困难的部分，”* 汤姆说。“*Builder模式的实现将要做很多工作。它需要组装轮椅对象，组装组合，并最终使用桥接模式处理轮椅的喷漆工作。”*
- en: '“We should review our diagram,” said Kitty. It was her turn to type. She brought
    up the diagram they had drawn of the builder pattern. You can review it in *Figure
    7.7*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: “我们应该审查我们的图表，”基蒂说。轮到她输入了。她调出了他们绘制的Builder模式图表。你可以在*图7.7*中查看它：
- en: '![Figure 7.7: The Builder pattern design with everything on it, including the
    Composite and Bridge pattern elements. ](img/figure-7-7.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：包含所有内容的Builder模式设计，包括组合模式和桥接模式元素。](img/figure-7-7.jpg)'
- en: 'Figure 7.7: The Builder pattern design with everything on it, including the
    Composite and Bridge pattern elements.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：包含所有内容的Builder模式设计，包括组合模式和桥接模式元素。
- en: '*“I think I’ll make a folder to hold all the builder classes and interfaces.
    It seems like there are going to be a few of them,”* Kitty said. “*Good idea,”*
    said Tom. Kitty created a folder called `Builders`. Next, Kitty added the `IWheelchairBuilder`
    interface to the `Builders` folder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我想我会创建一个文件夹来存放所有的Builder类和接口。看起来会有几个。”* 基蒂说。“*好主意。”* 汤姆说。基蒂创建了一个名为`Builders`的文件夹。接下来，基蒂将`IWheelchairBuilder`接口添加到了`Builders`文件夹中：'
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Kitty implemented the code specified in the UML design:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂实现了UML设计中指定的代码：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Aside from the interface, the Builder pattern needs a `director` class. That
    is, it needs an abstract builder that implements the interface, and one or more
    concrete `builder` subclasses to build the concrete products. You can see each
    of these in *Figure 7.4*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接口之外，Builder模式还需要一个`director`类。也就是说，它需要一个实现接口的抽象构建器，以及一个或多个具体的`builder`子类来构建具体的产品。你可以在*图7.4*中看到这些。
- en: 'Kitty adds the director class next. She decides to call it `WheelchairBuilderDirector`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty接下来添加了导演类。她决定将其命名为`WheelchairBuilderDirector`：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The director holds a private instance of any class implementing `IWheelchairBuilder`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 导演持有任何实现`IWheelchairBuilder`的类的私有实例：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Kitty adds a constructor that specifies the builder she wants to use on instantiation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty添加了一个构造函数，指定了实例化时要使用的构建器：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Build` method specified in the diagram is designed to call the various
    methods on the `builder` class specified in `IWheelchairBuilder`. Remember, the
    director’s job is to call these in order. The complex logic behind building the
    object is controlled here in the director class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中指定的`Build`方法旨在调用`IWheelchairBuilder`中指定的`builder`类的各种方法。记住，导演的职责是有序地调用这些方法。构建对象背后的复杂逻辑在这里由导演类控制：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the director returns the built object using the `GetProduct` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，导演使用`GetProduct`方法返回构建好的对象：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*“So far, so good!”* said Tom. “*Let’s make a concrete builder for the Plano
    Wheelchair*.”'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “到目前为止，一切顺利！”Tom说。“让我们为Plano轮椅制作一个具体的构建器。”
- en: 'Kitty added a class called `PlanoWheelchairBuilder`. It looked like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty添加了一个名为`PlanoWheelchairBuilder`的类。它看起来像这样：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The pattern requires us to have a `private` field to hold the `Wheelchair`
    object as it is built:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式要求我们有一个`private`字段来保存正在构建的`Wheelchair`对象：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The pattern also requires a `Reset` method, which essentially re-initializes
    the `_wheelchair` field. In order to keep the class `Reset` method, then call
    it from the constructor, which you also need. Kitty prefers to make sure the constructor
    is always the first method in the class, so it comes first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式还要求一个`Reset`方法，它本质上重新初始化了`_wheelchair`字段。为了保持类的`Reset`方法，然后在构造函数中调用它，这也是你所需要的。Kitty更喜欢确保构造函数总是类中的第一个方法，所以它排在第一位：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, she adds the `Reset` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，她添加了`Reset`方法：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since this class implements the `IWheelchairBuilder` interface, we need the
    remainder of the required methods. Most IDEs will generate this for you. Kitty
    is using Rider, so she clicks her cursor into the class name line near the top
    of the class. It has some angry-looking red squiggly lines beneath it because
    she hasn’t implemented the methods required by the interface. She presses *Ctrl*
    + *.* (control-period) and she sees the option to generate the missing members
    with placeholder code. You can see what this looks like in *Figure 7.8*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类实现了`IWheelchairBuilder`接口，我们需要实现剩余的所需方法。大多数IDE都会为你生成这些方法。Kitty使用Rider，所以她将光标点击到类名行，位于类顶部附近。它下面有一些看起来很生气的红色波浪线，因为她还没有实现接口所需的方法。她按下*Ctrl*
    + *.*（控制点）并看到生成缺失成员的占位符代码的选项。你可以在*图7.8*中看到这个样子：
- en: '![Figure 7.8: Rider, like most IDEs, will autogenerate placeholder code for
    any missing members required by the interface. ](img/B18605_Figure_7.8.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8：Rider，像大多数IDE一样，将为接口所需的任何缺失成员自动生成占位符代码。](img/B18605_Figure_7.8.jpg)'
- en: 'Figure 7.8: Rider, like most IDEs, will autogenerate placeholder code for any
    missing members required by the interface.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：Rider，像大多数IDE一样，将为接口所需的任何缺失成员自动生成占位符代码。
- en: 'The code generated looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码看起来像这样：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code is long and uneventful, but it saves a lot of typing! Kitty just needs
    to fill in the implementation for each method. She can’t really do that yet. She
    needs concrete implementations of the various abstract wheelchair component classes,
    and those have yet to be created.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很长且平淡无奇，但它节省了很多打字！Kitty只需要填写每个方法的实现。她实际上还做不到这一点。她需要各种抽象轮椅组件类的具体实现，而这些还没有被创建。
- en: Another refactor
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一次重构
- en: '*“That’s a whole lot* *of placeholder code,”* Tom said. *“Maybe it’s time to
    add some concrete classes for the wheelchair components so we build a real wheelchair?”*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: “这真是大量的占位符代码，”Tom说。“也许该为轮椅组件添加一些具体的类，以便我们构建一个真正的轮椅了？”
- en: '*“OK,”* Kitty agreed. She started to think about structuring the concrete classes.
    There is going to be at least one concrete component for each of the abstract
    component classes. Assuming the wheelchair project is wildly successful, the list
    of concrete implementations is likely to grow, making the `WheelchairComponents`
    folder very crowded.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*“好的，”* 基蒂同意了。她开始思考如何构建具体的类。对于每个抽象组件类，至少将有一个具体的组件。假设轮椅项目非常成功，具体的实现列表可能会增长，使得`WheelchairComponents`文件夹非常拥挤。'
- en: '*“Tom, why don’t we split up the WheelchairComponents folder a little more?
    As we add concrete classes, I think it will be easier to find everything if we
    do it that way*,” Kitty said. *“Good idea,*” Tom replied.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*“汤姆，我们为什么不多分一点`WheelchairComponents`文件夹呢？随着我们添加具体类，我认为这样做会更容易找到所有东西，”基蒂说。*“好主意，”汤姆回答。'
- en: 'Kitty added a series of folders beneath the `WheelchairComponents` folder:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂在`WheelchairComponents`文件夹下添加了一系列文件夹：
- en: '`Axles`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Axles`'
- en: '`Casters`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Casters`'
- en: '`Frames`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frames`'
- en: '`Seats`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seats`'
- en: '`Wheels`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wheels`'
- en: Next, she moved the abstract classes for each component into their respective
    folder. In each case, she corrected the namespace for the class she moved.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，她将每个组件的抽象类移动到相应的文件夹中。在每种情况下，她纠正了她移动的类的命名空间。
- en: 'The `Axle` class goes in the `Axles` folder. The namespace code should be adjusted
    to this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axle`类放在`Axles`文件夹中。命名空间代码应调整为以下内容：'
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Caster Assembly` class goes in the `Casters` folder. The namespace code
    should be adjusted to this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caster Assembly`类放在`Casters`文件夹中。命名空间代码应调整为以下内容：'
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `WheelchairFrame` class goes in the `Frames` folder. The namespace code
    should be adjusted to this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`WheelchairFrame`类放在`Frames`文件夹中。命名空间代码应调整为以下内容：'
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `WheelchairSeat` class goes in the `Seats` folder. The namespace code should
    be adjusted to this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`WheelchairSeat`类放在`Seats`文件夹中。命名空间代码应调整为以下内容：'
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, the `MechanicalWheel` class is moved to the `Wheels` folder and its
    namespace is adjusted like so:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`MechanicalWheel`类移动到`Wheels`文件夹，并按如下调整其命名空间：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When this refactor is over, the code’s folder structure looks like *Figure 7.6*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当这次重构完成时，代码的文件夹结构看起来像*图7.6*。
- en: Adding concrete component classes
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加具体组件类
- en: Kitty’s next job is going to be adding component classes for each component
    type. We’ve established a base class and structure for each component. Next, we
    simply need to add the concrete classes that extend the base classes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂的下一项工作是添加每个组件类型的组件类。我们已经为每个组件建立了一个基类和结构。接下来，我们只需添加扩展基类的具体类。
- en: Axles
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Axles`'
- en: She starts in the `Axles` folder by adding a class called `StandardAxle`. The
    parts for the *Plano Wheelchair* are mechanically simple and common. Phoebe has
    provided a **bill of materials** (**BOM**) listing the components, along with
    the data required by the Composite pattern implementation. In the world of manufacturing,
    this is a list of parts normally exported to an Excel spreadsheet. Kitty and Tom
    can simply reference the spreadsheet to get the values needed in the concrete
    classes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 她从添加一个名为`StandardAxle`的类开始，放在`Axles`文件夹中。*Plano轮椅*的部件在机械上简单且常见。菲比提供了一个**材料清单**（**BOM**），列出了组件，以及复合模式实现所需的数据。在制造业中，这是一个通常导出到Excel电子表格的部件列表。基蒂和汤姆可以简单地参考电子表格来获取在具体类中需要的值。
- en: 'The `StandardAxle` class looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardAxle`类看起来如下：'
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Casters
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮子
- en: 'Next, Kitty adds a concrete class for the caster assembly to be used on the
    *Plano Wheelchair*. Unsurprisingly, she calls it `PlanoCasterAssembly`. Its contents
    are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，基蒂为将在*Plano轮椅*上使用的铸件添加了一个具体类。她将其命名为`PlanoCasterAssembly`。其内容如下：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Frames
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Frames`'
- en: 'It’s time to add a concrete class for the *Plano Wheelchair’s* frame. It’s
    called `PlanoWheelchairFrame`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为*Plano轮椅*的框架添加一个具体类了。它被称为`PlanoWheelchairFrame`：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Seats
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Seats`'
- en: 'A wheelchair wouldn’t be very useful without a place to sit. Kitty adds a class
    she calls `PlanoSeat`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 没有座位的地方，轮椅就不会很有用。基蒂添加了一个她称之为`PlanoSeat`的类：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Wheels
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Wheels`'
- en: 'Equally important to the construction of a wheelchair, beyond the seat, are
    the wheels. There are two of these. The large wheels on the side of the wheelchair
    are specified by a class called `StandardWheel`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于轮椅的构建来说，除了座位之外，轮子同样重要。这里有两组轮子。轮椅侧面的大型轮子由一个名为`StandardWheel`的类指定：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The second type of wheel we need is the smaller set that attaches to the swiveling
    casters on the front of the chair. Kitty called these `CasterWheel`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第二种轮子是较小的一组，它附着在椅子前面的旋转铸件上。基蒂将这些称为`CasterWheel`：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, Kitty’s folder structure resembles *Figure 7.9*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Kitty的文件夹结构类似于*图7.9*：
- en: '![Figure 7 .9: The WheelchairComponents folder after Kitty added all the concrete
    classes. ](img/B18605_Figure_7.9.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9：Kitty添加所有具体类后的WheelchairComponents文件夹](img/B18605_Figure_7.9.jpg)'
- en: 'Figure 7 .9: The WheelchairComponents folder after Kitty added all the concrete
    classes.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：Kitty添加所有具体类后的WheelchairComponents文件夹。
- en: Now that all the concrete classes for the *Plano Wheelchair* are in place, we
    can set up the Builder pattern code to build a full `Wheelchair` object.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有`Plano Wheelchair`的具体类都已经就位，我们可以设置Builder模式代码来构建一个完整的`Wheelchair`对象。
- en: Wrapping up the Builder pattern
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成Builder模式
- en: At this point, Kitty needs to finish the `PlanoWheelchairBuilder` class. If
    you recall, this was the class where she generated all that placeholder code earlier.
    She needs to replace the placeholder code with code using her new concrete classes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Kitty需要完成`PlanoWheelchairBuilder`类。如果你还记得，这是她之前生成所有占位符代码的类。她需要用她新的具体类替换占位符代码。
- en: 'Kitty starts with the frame because the frame is the foundation for all the
    other parts of the wheelchair. She changes the code in the `BuildFrame` method
    generated by the IDE:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty从框架开始，因为框架是轮椅所有其他部分的基石。她修改了IDE生成的`BuildFrame`方法中的代码：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There’s not much to the `BuildFrame` method. All it does is instantiate `PlanoWheelchairFrame`
    and set the `_wheelchair` frame property.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildFrame`方法没有太多内容。它所做的只是实例化`PlanoWheelchairFrame`并设置`_wheelchair`的框架属性。'
- en: 'Next, Kitty replaced the `BuildAxleAssembly` method. An `Axle` object, such
    as the `StandardAxle` class, per the Composite pattern, is a container. The team
    specified this in *Figure 7.5*. The `Axle` contains the left and right wheels,
    which are the `StandardWheel` type. As such, the code looks like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Kitty替换了`BuildAxleAssembly`方法。根据组合模式，`Axle`对象，如`StandardAxle`类，是一个容器。团队在*图7.5*中指定了这一点。`Axle`包含左右轮子，它们是`StandardWheel`类型。因此，代码看起来是这样的：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we’ve instantiated two `StandardWheel` objects and set them into `Axle`
    using the `StandardAxle` constructor. Lastly, we set the `_wheelchair`’s `Axle`,
    which is a property of the `Frame` property. This mirrors real life because an
    axle would be attached to the wheelchair’s frame, and the wheels, in turn, would
    be affixed to the axle.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化了两个`StandardWheel`对象，并使用`StandardAxle`构造函数将它们设置到`Axle`中。最后，我们设置了`_wheelchair`的`Axle`，它是`Frame`属性的一个属性。这反映了现实生活，因为轴会被固定在轮椅的框架上，而轮子反过来会被固定在轴上。
- en: 'In her mind’s eye, all Kitty sees is a wheelchair with two wheels awkwardly
    rocking back and forth. With the main wheels attached, Kitty decides to do the
    casters next. She alters the `BuildCasterAssembly` method like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在她的脑海中，Kitty看到的是一个带有两个轮子的轮椅，尴尬地来回摇晃。在主轮安装后，Kitty决定先做脚轮。她像这样修改了`BuildCasterAssembly`方法：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`PlanoCasterAssembly` consists of `CasterWheel`, which is passed into the `PlanoCasterAssembly`
    constructor. The assembly is then mounted to the frame on the left and right sides.
    As I review Kitty’s code, I can’t tell whether she’s cutting a corner here or
    not. She used the same instance of `PlanoCasterAssembly` on both sides. I’m sure
    it’s probably right. If it isn’t, I’m sure Phoebe would have let her know.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlanoCasterAssembly`由`CasterWheel`组成，它被传递到`PlanoCasterAssembly`构造函数中。然后，这个组件被安装到框架的左右两侧。在我审查Kitty的代码时，我无法判断她是否在这里偷工减料。她在这两侧使用了相同的`PlanoCasterAssembly`实例。我确信这可能是正确的。如果不是，我确信Phoebe会让她知道。'
- en: 'We have four wheels and a frame. We’re missing a seat. Kitty updates the `BuildSeat`
    method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个轮子和一个框架。我们还缺少一个座椅。Kitty更新了`BuildSeat`方法：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Like the frame, this one is straightforward. Just instantiate the `PlanoSeat`
    object and attach it to the frame. Kitty needs one more easy change. `GetProduct`
    should not return an instantiation of `PlanoWheelchair`. Instead, it should return
    the one we’ve built:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 就像框架一样，这个也很直接。只需实例化`PlanoSeat`对象并将其附加到框架上。Kitty还需要进行一个简单的更改。`GetProduct`不应该返回`PlanoWheelchair`的实例，而应该返回我们构建的那个：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: “*Wow, that’s really neat!”* Phoebe said. Phoebe had been wandering in and out
    of the lab, but all of a sudden, showed a renewed interest. *“I see what you mean
    by hiding the Composite pattern complexity inside the builder. Anyone working
    with the object can use normal composition, but we also get the benefit of the
    recursive price and weight functions,”* Phoebe said.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: “*哇，这真的很酷！*”菲比说。菲比一直在实验室里进进出出，但突然间，她表现出了一种新的兴趣。“*我明白你说的将组合模式复杂性隐藏在构建者内部的意思。任何与对象一起工作的人都可以使用正常的组合，但我们还获得了递归价格和重量函数的好处，*”菲比说。
- en: “*Are we still going to make it a singleton?”* Tom asked.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: “*我们还要将其变为单例吗？*”汤姆问。
- en: '*“I think we should* *try,”* Kitty said. “*It would be interesting to write
    some tests to see whether we gain any benefit from making this a singleton. But
    for now, let’s go ahead and turn the builder into a singleton*.”'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我认为我们应该* *尝试一下，*”凯蒂说。“*写一些测试来查看我们是否从将其变为单例中获得了任何好处，但现在，让我们继续将构建者变为单例*。”'
- en: Adding the Singleton pattern
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加单例模式
- en: “*Tag! I’m in!”* Phoebe exclaimed, as she nudged Kitty out of the typing chair
    and sat down at the keyboard. Phoebe made a show of cracking her knuckles and
    popping her neck. They were in the home stretch and Phoebe knew it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: “*标签！我进来了！*”菲比大声说，当她把凯蒂从打字椅上推开后，自己坐到了键盘前。菲比假装敲打她的手指关节，扭动她的脖子。他们已经到了最后阶段，菲比知道这一点。
- en: '“*The Singleton is pretty easy*,” Tom said. *“I remember* it,” said Phoebe.
    She continued, *“It seems like all I need to do is change the director class in
    the Builder pattern.*” Phoebe located the director class in the `Builders` folder
    and opened it in her IDE:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: “*单例很简单，*”汤姆说。“*我记得，*”菲比说。她继续说，“*看起来我只需要更改构建者模式中的导演类。”菲比在`Builders`文件夹中找到了导演类，并在她的IDE中打开了它：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Phoebe adds this line to create a field to hold the current instance. She makes
    it nullable because if the field is `null`, we need to create a new instance of
    this class and place it in the `_instance` field. The field is marked `static`
    to ensure it is unique in memory:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比添加了这一行来创建一个用于存储当前实例的字段。她将其标记为可空，因为如果字段是`null`，我们需要创建这个类的新实例并将其放置在`_instance`字段中。这个字段被标记为`static`以确保它在内存中是唯一的：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, Phoebe changes the constructor’s accessor to `private`. It should not
    be possible to instantiate the director directly. To use the class, you have to
    use the hallmark `GetInstance` method, which she’ll write next:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，菲比将构造函数的访问器改为`private`。直接实例化导演是不可能的。要使用这个类，你必须使用标志性的`GetInstance`方法，她将在下面写：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The last step to converting the builder’s director class is to add a public
    static method called `GetInstance`. We still need the `IWheelchairBuilder` parameter
    to be passed in just as we did on the original constructor. This method checks
    to see whether the `_instance` field is null. If it is, then this method will
    invoke the private constructor and set the `_instance` field to the result. If
    the `_instance` field is not null, the `GetInstance` method will simply return
    the instance it already has:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建者导演类转换为最后的步骤是添加一个名为`GetInstance`的公共静态方法。我们仍然需要将`IWheelchairBuilder`参数传递进来，就像我们在原始构造函数中所做的那样。这个方法检查`_instance`字段是否为空。如果是，那么这个方法将调用私有构造函数并将`_instance`字段设置为结果。如果`_instance`字段不为空，`GetInstance`方法将简单地返回它已经拥有的实例：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The rest of the class remains unchanged.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分保持不变。
- en: “*That wasn’t so tough,”* Phoebe said. “*I can imagine this object being expensive
    in terms of memory once the factories are producing wheelchairs as well as bicycles,”*
    Tom said. “*I’m on the fence*,” Phoebe replied. “*I’m not totally sure we need
    this, but I don’t think it will hurt anything. There’s just one thing left, and
    it’s my favorite!*” said Kitty, watching from behind Phoebe’s chair. “*You’re
    proud* *of your paint system, aren’t you Sis?”* asked Phoebe. Kitty just grinned
    and sat down behind her sister.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: “*这并不难，*”菲比说。“*我可以想象，一旦工厂开始生产轮椅和自行车，这个物体在内存方面可能会很昂贵，*”汤姆说。“*我在犹豫，*”菲比回答。“*我不完全确定我们是否需要这个，但我想这不会有什么坏处。只剩下一件事了，那就是我最喜欢的!*”凯蒂边说边从菲比的椅子后面看着。“*你很自豪你的油漆系统，对吧，姐姐？*”菲比问。凯蒂只是笑了笑，坐在她妹妹的后面。
- en: Painting the chairs with the Bridge pattern
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用桥接模式给椅子涂漆
- en: The last pattern we need to complete our wheelchair project is the Bridge pattern.
    Remember, the Bridge pattern is used when you have two related systems of complex
    classes. The bridge allows you to join the classes using composition. It gives
    you the benefit of being able to vary the complexity and maintain these complicated
    classes independently. Kitty and Phoebe used this system to add the ability to
    create custom paint jobs for their bicycles. They did this late in the game though,
    and the changes they had to make to accommodate those changes were problematic.
    They had to violate the open-closed principle.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成的最后一个模式来完善我们的轮椅项目是桥接模式。记住，桥接模式用于当你有两个相关的复杂类系统时。桥接模式允许你通过组合来连接这些类。它让你能够改变复杂性并独立维护这些复杂的类。Kitty和Phoebe使用这个系统为他们的自行车添加了定制喷漆的能力。但他们是在游戏后期才这样做，为了适应这些变化，他们不得不违反开闭原则。
- en: This time, with experience behind them, they can integrate the Bridge pattern
    for painting wheelchairs early in the implementation. The ability to specify colors
    for wheelchairs will be a big differentiator for Bumble Bikes since most manufacturers
    only sell black and gray chairs. This is fine for the loaner chair at your local
    hospital, but for people who use wheelchairs every day to get around in life,
    it’s nice to have a little fashion in the mix.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，有了经验，他们可以在实现早期就集成桥接模式来喷漆轮椅。为轮椅指定颜色的能力将成为Bumble Bikes的一个大区别，因为大多数制造商只销售黑色和灰色椅子。这对于你当地医院的借用椅子来说是可以的，但对于每天使用轮椅来生活的的人来说，有一点点时尚感是很好的。
- en: Kitty created the paint system for the bicycles to work in a similar fashion
    as an inkjet printer works. She devised a system that could mix any color using
    cyan, magenta, yellow, and black paint. This is called the **CMYK** color model,
    and it’s a standard in the printing industry.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty为自行车创建了一个喷漆系统，使其工作方式与喷墨打印机类似。她设计了一个系统，可以使用青色、品红色、黄色和黑色喷漆混合出任何颜色。这被称为 **CMYK**
    颜色模型，它是印刷行业的一个标准。
- en: Tom, who works with disabled children at a local pediatric hospital, had taken
    an informal survey on what the most popular colors might be for a wheelchair.
    Then he asked the kids to pick just one color for the initial product release.
    After some animated discussion, the kids decided on a shade of green. There was
    a woman who worked with the kids, named Judy. Everyone loved her, and she had
    sparkling green eyes. They decided to honor her by naming the color *Green Eyed
    Judy*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Tom在一家当地儿童医院与残疾儿童一起工作，他对轮椅可能最受欢迎的颜色进行了非正式调查。然后他要求孩子们为初始产品发布选择一个颜色。经过一番热烈的讨论，孩子们决定选择一种绿色的色调。有一个和孩子们一起工作的女人，名叫Judy。大家都喜欢她，她有一双闪亮的绿色眼睛。他们决定通过将颜色命名为
    *Green Eyed Judy* 来向她致敬。
- en: Phoebe got to work on implementing the Bridge pattern. In real life, it might
    be possible to reuse the bridge interfaces and classes from the bicycle package.
    The only downside is that you’d create a dependency between two products that
    don’t necessarily have anything to do with each other besides being two products
    made by the same company. For the purposes of this book, we’re just going to make
    a new set of classes in order to keep the wheelchair project self-contained.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Phoebe 开始实现桥接模式。在现实生活中，可能可以重用自行车包中的桥接接口和类。唯一的缺点是，你会在两个产品之间创建一个依赖关系，这两个产品除了都是由同一家公司制造之外，可能没有任何关系。为了这本书的目的，我们只是将创建一套新的类，以便使轮椅项目自给自足。
- en: Phoebe starts by creating a new directory called `Painters`. Next, she adds
    an interface called `IFramePainter`. This is the key to the Bridge pattern. This
    interface defines a complex system of classes that specify a color painting system.
    This is one side of the bridge.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Phoebe首先创建了一个名为 `Painters` 的新目录。然后，她添加了一个名为 `IFramePainter` 的接口。这是桥接模式的关键。这个接口定义了一个复杂的类系统，用于指定颜色喷漆系统。这是桥接模式的一侧。
- en: On the other side of the bridge is the wheelchair class. We can freely expand
    and modify either side of the bridge without affecting the other side.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式的另一侧是轮椅类。我们可以自由地扩展和修改桥接的任一侧，而不会影响另一侧。
- en: 'The `IFramePainter` interface looks like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFramePainter` 接口看起来是这样的：'
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The interface requires five properties. `PaintColorName` allows you to give
    a name to the color combination. The remaining four are the values for `Cyan`,
    `Magenta`, `Yellow`, and `Black`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接口需要五个属性。`PaintColorName` 允许你为颜色组合命名。剩下的四个属性是 `Cyan`、`Magenta`、`Yellow` 和 `Black`
    的值：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, Phoebe adds the requirements for two methods. This is for the benefit
    of the robotic machinery that will assemble and paint the wheelchair. The system
    needs to first mix the paint color, then apply it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，菲比添加了两个方法的要求。这是为了机器人机械组装和涂漆轮椅的利益。系统需要首先混合油漆颜色，然后应用：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The next thing we need is a concrete class to implement the interface. Phoebe
    remains focused on the *Plano Wheelchair*, and so makes a class called `PlanoWheelchairPainter`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要的是一个具体的类来实现这个接口。菲比依然专注于*Plano轮椅*，因此创建了一个名为`PlanoWheelchairPainter`的类：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Phoebe leaves the five properties mentioned earlier as auto-properties:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比将之前提到的五个属性作为自动属性：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `MixPaint` method is complicated and highly proprietary. Kitty and Phoebe’s
    lawyer won’t let me show you the real code. So, we’ll have to settle for some
    placeholder code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`MixPaint`方法很复杂，且高度专有。凯蒂和菲比的律师不允许我展示真正的代码。所以，我们只能用一些占位符代码来代替：'
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Likewise, the `PaintFrame` method refers to some proprietary robotics APIs,
    so once again, we’ll keep it simple by way of an example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`PaintFrame`方法引用了一些专有的机器人API，所以我们再次通过示例保持简单：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The next change we need to make is to add the interface through composition
    to the `Wheelchair` class. Phoebe opens the `Wheelchair` class and adds a property:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要做的更改是将接口通过组合添加到`Wheelchair`类中。菲比打开`Wheelchair`类并添加了一个属性：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There’s just one thing left to do. We need to add the bridge implementation
    to the builder so that when the builder builds a wheelchair, it gets painted in
    the same process. The builder really ties everything together!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事就是我们需要将桥接实现添加到构建器中，这样当构建器构建轮椅时，它会在相同的过程中进行涂漆。构建器真正地将一切联系在一起！
- en: 'The first change will be to the `IWheelchairBuilder` interface. Phoebe just
    adds one new method definition:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改将是`IWheelchairBuilder`接口。菲比只是添加了一个新的方法定义：
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'She adds the definition here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 她在这里添加了定义：
- en: '[PRE77]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The rest of the code hasn’t changed:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码没有变化：
- en: '[PRE78]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The interface updates, and suddenly Phoebe sees some red squiggly lines indicating
    a problem. Since she changed the interface, the `PlanoWheelchairBuilder` class
    is wrong because it doesn’t have the new method. Phoebe opens up the `PlanoWheelchairBuilder`
    class and adds the missing method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接口更新后，菲比突然看到一些红色的波浪线，表示有问题。由于她更改了接口，`PlanoWheelchairBuilder`类是错误的，因为它没有新的方法。菲比打开`PlanoWheelchairBuilder`类并添加了缺失的方法：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Phoebe instantiates a concrete `PlanoWheelchairPainter` class and sets it up
    with the new wheelchair paint color:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比实例化了一个具体的`PlanoWheelchairPainter`类，并使用新的轮椅油漆颜色进行设置：
- en: '[PRE80]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, she sets the property on the `_wheelchair` instance inside the builder.
    After that, she calls the methods to mix the paint color and paint the frame:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，她在构建器内部设置`_wheelchair`实例的属性。之后，她调用方法来混合油漆颜色并涂漆框架：
- en: '[PRE81]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: SLAP!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: SLAP！
- en: A loud sound echoed through the lab as Kitty and Phoebe high-fived each other.
    Tom let out a good old-fashioned Texan “*Yee haw!”*
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一阵响亮的声音在实验室中回荡，凯蒂和菲比互相击掌。汤姆发出了一阵传统的德克萨斯州“*Yee haw!*”
- en: Over the next week, the team would test, debug, and refactor the code. If everything
    went to plan, Bumble Bikes could be shipping their high-quality, low-cost wheelchairs
    to rehabilitation centers and pediatric hospitals all over the world.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一个星期里，团队将测试、调试和重构代码。如果一切按计划进行，Bumble Bikes就能将高质量、低成本的轮椅运往世界各地的康复中心和儿科医院。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Kitty, Phoebe, and Tom were delighted at their progress. There is no doubt they
    would continue to refine their software over the coming weeks to make the system
    product-ready. They managed to get a lot done in a short time because they planned
    their software by designing first and implementing second.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂、菲比和汤姆对他们的进展感到非常高兴。毫无疑问，他们将在接下来的几周内继续完善他们的软件，使其产品化。他们之所以能在短时间内完成很多工作，是因为他们先设计后实施，对软件进行了规划。
- en: You might have noticed a huge gap between the project proposed and what was
    delivered. We only worked on the *Plano Wheelchair* because the team decided this
    chair represented the minimum viable product. Neither the *Maverick* nor the flagship
    product, the *Texas Tank*, were built in this chapter. I left this as a challenge
    for you. Practice what you’ve learned and try implementing the *Maverick* and
    powered chair diagrams on your own.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了项目提案和交付内容之间巨大的差距。我们只专注于*Plano轮椅*，因为团队决定这张椅子代表了最小可行产品。 neither the *Maverick*
    nor the flagship product, the *Texas Tank*，在这一章中都没有被构建。我把这个留给你作为一个挑战。练习你所学的，并尝试自己实现*Maverick*和电动轮椅的图表。
- en: We also saw a lot of interplay between patterns. The Builder was leveraged in
    conjunction with the Bridge, Singleton, and Composite patterns. This resulted
    in all the complexity being handled in one place. When these patterns were introduced,
    they were presented one at a time. Now we see them fitting together like interlocking
    pieces of a puzzle.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了很多模式之间的相互作用。构建者模式与桥接模式、单例模式和组合模式结合使用。这导致所有复杂性都集中在一个地方处理。当这些模式被引入时，它们是一次性一个一个被提出的。现在我们看到它们就像拼图一样相互契合。
- en: Questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What was the point of making the Builder pattern’s director class a Singleton?
    Do you agree with the design decision? Why, or why not?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建者模式的导演类做成单例（Singleton）有什么意义？你同意这个设计决策吗？为什么，或者为什么不？
- en: What is the advantage of embedding the composite structure into the normal object
    graph of the wheelchair versus making a separate object graph as we did in [*Chapter
    4*](B18605_04.xhtml#_idTextAnchor078)with the bicycle project?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组合结构嵌入轮椅的正常对象图中与单独创建对象图相比，有什么优势？就像我们在[*第4章*](B18605_04.xhtml#_idTextAnchor078)中用自行车项目所做的那样？
- en: What is the process in your favorite IDE for generating missing members for
    an interface?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最喜欢的集成开发环境（IDE）中生成接口缺失成员的过程是怎样的？
- en: Further reading
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Practical Remote Pair Programming* by Adrian Bolboacă: [https://www.packtpub.com/product/practical-remote-pair-programming/9781800561366](https://www.packtpub.com/product/practical-remote-pair-programming/9781800561366)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '由Adrian Bolboacă所著的《*实用远程结对编程*》: [https://www.packtpub.com/product/practical-remote-pair-programming/9781800561366](https://www.packtpub.com/product/practical-remote-pair-programming/9781800561366)'
- en: Be sure to check out this book’s companion website at [https://csharppatterns.dev](https://csharppatterns.dev).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看这本书的配套网站：[https://csharppatterns.dev](https://csharppatterns.dev)。
