- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Exploring Graphs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索图
- en: In the previous chapter, you learned about trees. However, did you know that
    such data structures also belong to graphs? But what is a graph and how can you
    use one in your applications? You’ll find the answers to these and many other
    questions in this chapter!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了关于树的知识。然而，你知道这样的数据结构也属于图吗？但什么是图，你如何在应用中使用它？你将在本章中找到这些以及其他许多问题的答案！
- en: First, basic information about graphs will be presented, including an explanation
    of **nodes** and **edges**. As graphs are data structures that are commonly used
    in practice, you will also see some of their applications, such as for storing
    data of friends on social media or for finding a road in a city. Then, the topic
    of graph **representation** will be covered, namely using an adjacency list and
    matrix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将介绍关于图的基本信息，包括**节点**和**边**的解释。由于图是实践中常用的数据结构，你还将看到它们的一些应用，例如用于存储社交媒体上的朋友数据或用于在城市中寻找道路。然后，将介绍图**表示**的主题，即使用邻接表和矩阵。
- en: After this short introduction, you will learn how to implement a graph in the
    C# language. Moreover, you will learn about two modes of graph **traversal**,
    namely **depth-first search** (**DFS**) and **breadth-first search** (**BFS**).
    For both of them, the code and a detailed description will be shown.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这简短的介绍之后，你将学习如何在C#语言中实现图。此外，你还将了解两种图的遍历模式，即**深度优先搜索**（**DFS**）和**广度优先搜索**（**BFS**）。对于这两种方法，都会展示代码和详细的描述。
- en: Next, you will learn about the subject of **minimum spanning trees** (**MSTs**),
    as well as two algorithms for their creation, namely Kruskal’s and Prim’s. Such
    algorithms will be presented as descriptions, code snippets, and illustrations.
    Moreover, an example real-world application will be provided.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习关于**最小生成树**（**MSTs**）的主题，以及创建它们的两种算法，即Kruskal算法和Prim算法。这些算法将以描述、代码片段和示意图的形式展示。此外，还将提供一个实际应用的例子。
- en: Another interesting graph-related problem is the **coloring** of nodes, which
    will be taken into account in the following part of this chapter. Finally, the
    topic of finding the **shortest path** in a graph will be analyzed using Dijkstra’s
    algorithm.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的与图相关的问题是节点的**着色**，这将在本章的后续部分中考虑。最后，将使用Dijkstra算法分析在图中找到**最短路径**的主题。
- en: As you can see, the topic of graphs involves many interesting problems and only
    some of them will be mentioned in this book. However, the chosen subjects are
    suitable for presenting various graph-related aspects in the context of the C#
    language. Are you ready to dive into the topic of graphs? If so, start reading
    this chapter!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，图论涉及许多有趣的问题，而本书中仅提及其中的一些。然而，所选的主题适合在C#语言的环境中展示各种与图相关的方面。你准备好深入图论的话题了吗？如果是的话，就开始阅读这一章吧！
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的概念
- en: Applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用
- en: Representations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示
- en: Implementation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: Traversal
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历
- en: Minimum spanning tree
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小生成树
- en: Coloring
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色
- en: Shortest path
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短路径
- en: The concept of graphs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的概念
- en: 'Let’s start with the question *what is a graph?* Broadly speaking, **a graph
    is a data structure that consists of** **nodes** **(also called** **vertices****)
    and** **edges****. Each edge connects two nodes**. A graph data structure does
    not require any specific rules regarding connections between nodes, as shown in
    the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从问题“什么是图？”开始。广义上讲，**图是一种由** **节点** **（也称为** **顶点** **）和** **边** **组成的** **数据结构**。每条边连接两个节点。图数据结构不需要关于节点之间连接的任何特定规则，如下面的图所示：
- en: '![Figure 8.1 – Illustration of a graph](img/B18069_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 图的示意图](img/B18069_08_01.jpg)'
- en: Figure 8.1 – Illustration of a graph
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 图的示意图
- en: This concept seems very simple, doesn’t it? Let’s try to analyze the preceding
    graph to eliminate any doubts. It contains **9 nodes** with numbers between **1**
    and **9** as values. Such nodes are connected by **11 edges**, such as between
    nodes **2** and **4**. Moreover, a graph can contain **cycles** – for example,
    with nodes indicated by **2**, **3**, and **4** – as well as separate groups of
    nodes, which are not connected.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念看起来很简单，不是吗？让我们尝试分析前面的图，以消除任何疑问。它包含**9个节点**，其数值介于**1**和**9**之间。这些节点通过**11条边**相连，例如节点**2**和**4**之间。此外，图可以包含**环**
    – 例如，由节点**2**、**3**和**4**表示的环 – 以及不相连的节点组。
- en: However, what about the topic of parent and child nodes, which you know from
    learning about trees? As there are no specific rules about connections in a graph,
    such concepts are not used in this case.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于父节点和子节点的主题，你是从学习树的结构中知道的？由于图中没有关于连接的具体规则，因此在这种情况下不使用这些概念。
- en: Imagine a graph
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个图
- en: If you want to better visualize a graph, take your eyes off this book for a
    moment and look at a map showing the most important roads in your country, such
    as highways or expressways. Each fragment of such a road connects two towns and
    has a certain length. Once you have drawn such a structure on a piece of paper,
    you will see that thanks to it, you can find a route between two towns, along
    with the total distance of the entire route. Did you know you just created a graph?
    Individual towns are nodes, and the lines connecting them are edges. The distance
    between the two towns is the edge weight. It’s so simple when you can relate theory
    to practice, isn’t it? Now, it’s high time to put the map aside and focus on learning
    about the last data structure that will be covered in this book, namely the graph.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地可视化一个图，暂时放下这本书，看看展示你国家最重要道路的地图，比如高速公路或快速路。这样一条道路的每一部分连接两个城镇，并有一定的长度。一旦你在纸上画出这样的结构，你就会发现，由于它，你可以找到两个城镇之间的路线，以及整个路线的总距离。你知道你刚刚创建了一个图吗？单个城镇是节点，连接它们的线是边。两个城镇之间的距离是边的权重。当你能够将理论与实践联系起来时，事情变得如此简单，不是吗？现在，是时候把地图放一边，专注于学习这本书将要介绍的最后一个数据结构，即图。
- en: Some more comments are necessary for edges in a graph. In the preceding diagram,
    you can see a graph where all the nodes are connected with **undirected edges**
    – that is, **bidirectional edges**. They indicate that **it is possible to travel
    between nodes in both directions** – for example, from node **2** to **3** and
    from node **3** to **2**. Such edges are presented graphically as **straight lines**.
    When a graph contains undirected edges, it is an **undirected graph**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的边需要更多的注释。在先前的图中，你可以看到一个所有节点都通过**无向边**连接的图 – 也就是说，**双向边**。它们表示**可以在两个方向之间旅行**
    – 例如，从节点**2**到**3**，以及从节点**3**到**2**。这样的边在图形上表示为**直线**。当一个图包含无向边时，它是一个**无向图**。
- en: However, what about a scenario when you need to indicate that **traveling between
    nodes is possible only in one direction**? In such a case, you can use **directed
    edges** – that is, **unidirectional edges** – which are presented graphically
    as **straight lines with arrows indicating the direction of an edge**. If a graph
    contains directed edges, it can be named a **directed graph**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你需要表示**节点之间的旅行只能在一个方向上进行**时，情况会怎样？在这种情况下，你可以使用**有向边** – 也就是说，**单向边** – 它们在图形上表示为**带有指示边方向的箭头的直线**。如果一个图包含有向边，它可以被称为**有向图**。
- en: What about self-loops?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自环是什么？
- en: A graph can also contain **self-loops**. Each is an edge that connects a given
    node with itself. However, such a topic is outside the scope of this book and
    won’t be taken into account in the examples shown in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图也可以包含**自环**。每个自环都是连接给定节点与自身的边。然而，这样的主题超出了本书的范围，并且在本章的示例中不会考虑。
- en: 'An example directed graph is presented in the following diagram on the right,
    while an undirected one is shown on the left:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下右图展示了一个有向图的例子，而左图展示了一个无向图：
- en: '![Figure 8.2 – The difference between undirected and directed graphs](img/B18069_08_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 无向图和有向图的区别](img/B18069_08_02.jpg)'
- en: Figure 8.2 – The difference between undirected and directed graphs
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 无向图和有向图的区别
- en: As a short explanation, the directed graph (shown on the right in the preceding
    diagram) contains **8 nodes** connected by **15 unidirectional edges**. For example,
    they indicate that it is possible to travel between node **1** and **2** in both
    directions, but it is allowed to travel from the node **1** to **3** only in one
    direction, so it is impossible to reach node **1** from **3** directly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简短的解释，先前的图中右侧所示的有向图包含**8个节点**，通过**15条单向边**连接。例如，它们表示可以从节点**1**到**2**在两个方向上旅行，但只能从节点**1**到**3**单向旅行，因此无法直接从**3**到达**1**。
- en: The division between undirected and directed edges is not the only one. You
    can also specify **weights** (also referred to as **costs**) for particular edges
    to indicate the cost of traveling between nodes. Of course, such weights can be
    assigned to both undirected and directed edges. If weights are provided, an edge
    is named a **weighted edge**, and the whole graph is named a **weighted graph**.
    Similarly, if no weights are provided, **unweighted edges** are used in a graph.
    This graph is then called an **unweighted graph**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无向边和有向边之间的划分并非唯一。你也可以为特定的边指定**权重**（也称为**成本**），以表示节点之间旅行的成本。当然，这样的权重可以分配给无向边和有向边。如果提供了权重，则边被称为**加权边**，整个图被称为**加权图**。同样，如果没有提供权重，则图中使用**无权重边**。这种图被称为**无权重图**。
- en: 'Some example weighted graphs with undirected (on the left) and directed (on
    the right) edges are shown in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了具有无向（左侧）和有向（右侧）边的加权图的示例：
- en: '![Figure 8.3 – Difference between weighted undirected and weighted directed
    graphs](img/B18069_08_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 加权无向图和加权有向图之间的区别](img/B18069_08_03.jpg)'
- en: Figure 8.3 – Difference between weighted undirected and weighted directed graphs
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 加权无向图和加权有向图之间的区别
- en: This graphical presentation of a weighted edge shows the weight of an edge next
    to the line. For example, the cost of traveling from node **1** to **2**, as well
    as from node **2** to **1**, is equal to **3** in the case of the undirected graph,
    shown on the left in the preceding diagram. The situation is a bit more complicated
    in the case of the directed graph (on the right). Here, you can travel from node
    **1** to **2** with a cost equal to **9**, while traveling in the opposite direction
    (from node **2** to **1**) is much cheaper and costs only **3**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加权边的图形表示显示了边旁边线的权重。例如，在无向图中，从节点**1**到**2**以及从节点**2**到**1**的旅行成本等于**3**，如前图所示。在有向图（右侧）的情况下，情况要复杂一些。在这里，你可以以等于**9**的成本从节点**1**到**2**旅行，而相反方向的旅行（从节点**2**到**1**）要便宜得多，成本仅为**3**。
- en: Applications
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用
- en: 'At this point, you know some basic information about graphs, especially regarding
    nodes and various kinds of edges. However, why is the topic of graphs so important
    and why does it take up a whole chapter in this book? Could you use this data
    structure in your applications? The answer is obvious: yes! Graphs are commonly
    used while solving algorithmic problems and have numerous real-world applications.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了一些关于图的基本信息，特别是关于节点和不同类型的边。然而，为什么图的主题如此重要，为什么它占据了这本书的一整章？你能在你的应用中使用这种数据结构吗？答案很明显：是的！图在解决算法问题时被广泛使用，并且有无数的实际应用。
- en: 'To start, let’s think about a **structure of friends available on social media**.
    Each user has many contacts, but they also have many friends, and so on. What
    data structure should you choose to store such data? A graph is the simplest answer.
    In such a scenario, the nodes represent contacts, while the edges depict relationships
    between people. As an example, let’s take a look at the following diagram of an
    undirected and unweighted graph:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下社交媒体上可用的**朋友结构**。每个用户都有许多联系人，但他们也有许多朋友，等等。你应该选择哪种数据结构来存储这样的数据？图是最简单的答案。在这种情况下，节点代表联系人，而边表示人与人之间的关系。例如，让我们看一下以下无向无权重图的示意图：
- en: '![Figure 8.4 – Illustration of a graph representing a structure of friends](img/B18069_08_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 表示朋友结构的图形说明](img/B18069_08_04.jpg)'
- en: Figure 8.4 – Illustration of a graph representing a structure of friends
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 表示朋友结构的图形说明
- en: 'As you can see, **Jimmy Gold** has five contacts, namely **John Smith**, **Andy
    Wood**, **Eric Green**, **Ashley Lopez**, and **Paula Scott**. In the meantime,
    **Paula Scott** has two other friends: **Marcin Jamro** and **Tommy Butler**.
    By using a graph as a data structure, you can easily check whether two people
    are friends or whether they have a common contact.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**吉米·戈德**有五个联系人，即**约翰·史密斯**、**安迪·伍德**、**埃里克·格林**、**艾什莉·洛佩兹**和**保拉·斯科特**。同时，**保拉·斯科特**还有两个其他朋友：**马辛·雅姆罗**和**汤米·巴特勒**。通过使用图作为数据结构，你可以轻松地检查两个人是否是朋友，或者他们是否有共同联系人。
- en: 'Another common application of graphs involves the problem of **searching for
    the shortest path**. Let’s imagine a program that should find a path between two
    points in the city, taking into account the time necessary for driving particular
    roads. In such a case, you can use a graph to present a map of a city, where nodes
    depict intersections and edges represent roads. Of course, you should assign weights
    to edges to indicate the time that’s necessary to drive a given road. The topic
    of searching the shortest path can be understood as finding the list of edges
    from the source to the target node, with the minimum total cost. A diagram of
    a city map, based on a graph, is shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图的另一个常见应用涉及**寻找最短路径**的问题。让我们想象一个程序，它应该找到城市中两点之间的路径，考虑到驾驶特定道路所需的时间。在这种情况下，你可以使用图来表示城市地图，其中节点表示交叉口，边表示道路。当然，你应该给边分配权重，以表示驾驶给定道路所需的时间。寻找最短路径的主题可以理解为找到从源节点到目标节点的边的列表，其总成本最小。以下是基于图的城市场景图：
- en: '![Figure 8.5 – Illustration of a graph representing a city map](img/B18069_08_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 表示城市地图的图的示意图](img/B18069_08_05.jpg)'
- en: Figure 8.5 – Illustration of a graph representing a city map
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 表示城市地图的图的示意图
- en: As you can see, the directed and weighted graph was chosen. Directed edges make
    it possible to support both two-way and one-way roads, while weighted edges allow
    you to specify the time necessary to travel between two intersections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，选择了有向加权图。有向边使得可以支持双向和单向道路，而加权边允许你指定在两个交叉口之间旅行所需的时间。
- en: Representations
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示法
- en: At this point, you know what a graph is and when one can be used, but how can
    you represent one in the memory of a computer? There are two popular approaches
    to solve this problem, namely using an **adjacency list** and an **adjacency matrix**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道了什么是图以及何时可以使用它，但如何在计算机的内存中表示一个图呢？解决这个问题有两种流行的方法，即使用**邻接表**和**邻接矩阵**。
- en: Adjacency list
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'The first approach requires you to **extend the data of a node by specifying
    a list of its neighbors**. Thus, you can easily get all the neighbors of a given
    node just by iterating through the adjacency list of a given node. Such a solution
    is space-efficient because you only store the data of adjacent edges. Let’s take
    a look at the diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法要求你通过指定其邻居的列表来**扩展节点的数据**。因此，你只需遍历给定节点的邻接表，就可以轻松地获取给定节点的所有邻居。这种解决方案空间效率高，因为你只存储相邻边的数据。让我们看看下面的图示：
- en: "![Figure 8.6 – \uFEFFAdjacency list representing an undirected and unweighted\
    \ graph](img/B18069_08_06.jpg)"
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 表示无向无权图的邻接表](img/B18069_08_06.jpg)'
- en: Figure 8.6 – Adjacency list representing an undirected and unweighted graph
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 表示无向无权图的邻接表
- en: This example graph contains 8 nodes and 10 edges. For each node, a list of adjacent
    nodes (that is, **neighbors**) is created, as shown on the right-hand side of
    the diagram. For example, node **1** has two neighbors, namely nodes **2** and
    **3**, while node **5** has four neighbors, namely nodes **4**, **6**, **7**,
    and **8**. As you can see, the representation based on the adjacency list for
    an undirected and unweighted graph is straightforward, as well as easy to use,
    understand, and implement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例图包含8个节点和10条边。对于每个节点，创建了一个包含相邻节点（即**邻居**）的列表，如图表右侧所示。例如，节点**1**有两个邻居，即节点**2**和**3**，而节点**5**有四个邻居，即节点**4**、**6**、**7**和**8**。如你所见，无向无权图的邻接表表示法简单明了，易于使用、理解和实现。
- en: 'But how does the adjacency list work in the case of a directed graph? The answer
    is obvious because the list that’s assigned to each node just shows adjacent nodes
    that can be reached from the given node. Here’s an example diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但在有向图中，邻接表是如何工作的呢？答案很明显，因为分配给每个节点的列表只显示了可以从给定节点到达的相邻节点。以下是一个示例图：
- en: '![Figure 8.7 – Adjacency list representing a directed and unweighted graph](img/B18069_08_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 表示有向无权图的邻接表](img/B18069_08_07.jpg)'
- en: Figure 8.7 – Adjacency list representing a directed and unweighted graph
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 表示有向无权图的邻接表
- en: Let’s take a look at node **3**. Here, the adjacency list contains only one
    element – that is, node **4**. Node **1** is not included, because it cannot be
    reached directly from node **3**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看节点**3**。在这里，邻接表只包含一个元素——即节点**4**。节点**1**没有被包括在内，因为它不能从节点**3**直接到达。
- en: 'A bit more clarification may be useful in the case of a weighted graph. In
    such a case, it is also necessary to store weights for particular edges. You can
    achieve this by extending data stored in the adjacency list, as shown in the following
    diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权图的情况下，可能需要更多的解释。在这种情况下，还需要存储特定边的权重。你可以通过扩展邻接表中存储的数据来实现这一点，如下面的图所示：
- en: '![Figure 8.8 – Adjacency list representing a directed and weighted graph](img/B18069_08_08.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 表示有向加权图的邻接表](img/B18069_08_08.jpg)'
- en: Figure 8.8 – Adjacency list representing a directed and weighted graph
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 表示有向加权图的邻接表
- en: For example, the adjacency list for node **7** contains two elements, namely
    regarding an edge to node **5** (with a weight equal to **4**) and to node **8**
    (with a weight equal to **6**).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，节点**7**的邻接表包含两个元素，即关于到节点**5**（权重等于**4**）和到节点**8**（权重等于**6**）的边。
- en: Adjacency matrix
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: Another approach to graph representation involves the adjacency matrix, which
    uses **a two-dimensional array to show which nodes are connected by edges**. The
    matrix contains the same number of rows and columns, which is equal to the number
    of nodes. The main idea is to **store information about a particular edge in an
    element at a given row and column in the matrix**. The index of the row and the
    column depends on the nodes connected with the edge. For example, if you want
    to get information about an edge between nodes with indices **1** and **5**, you
    must check the element in the row with an index set to **1** and in the column
    with an index set to **5**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种图表示方法涉及邻接矩阵，它使用**一个二维数组来显示哪些节点通过边连接**。矩阵包含与节点数量相同的行和列。主要思想是在矩阵的特定行和列的元素中**存储有关特定边的信息**。行和列的索引取决于与边连接的节点。例如，如果你想获取节点索引为**1**和**5**之间的边的信息，你必须检查索引设置为**1**的行和索引设置为**5**的列中的元素。
- en: Such a solution provides you with a **quick way of checking whether two particular
    nodes are connected by an edge**. However, it may require you to store significantly
    more data than the adjacency list, especially if the graph does not contain many
    edges between nodes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案为你提供了一个**快速检查两个特定节点是否通过边连接的方法**。然而，它可能需要你存储比邻接表显著更多的数据，尤其是在节点之间没有许多边的情况下。
- en: 'To start, let’s analyze the basic scenario of an undirected and unweighted
    graph. In such a case, the adjacency matrix may only store Boolean values. The
    `true` value that’s placed in the element at the `i` row and the `j` column indicates
    that there is a connection between a node with an index equal to `i` and the node
    with an index set to `j`. If this sounds complicated, take a look at the following
    figure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分析无向无权图的基本场景。在这种情况下，邻接矩阵可能只存储布尔值。放置在`i`行`j`列的`true`值表示索引等于`i`的节点与索引设置为`j`的节点之间存在连接。如果这听起来很复杂，请看下面的图：
- en: '![Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph](img/B18069_08_09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 表示无向无权图的邻接矩阵](img/B18069_08_09.jpg)'
- en: Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 表示无向无权图的邻接矩阵
- en: Here, the adjacency matrix contains 64 elements (for 8 rows and 8 columns) because
    there are 8 nodes in the graph. The values of many elements in the array are set
    to `false`, which is represented by missing indicators. The remaining are marked
    with crosses, representing `true` values. For example, such a value in the element
    at the fourth row and third column means that there is an edge between nodes **4**
    and **3**, as shown in the preceding diagram.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，邻接矩阵包含64个元素（8行8列），因为图中包含8个节点。数组中许多元素被设置为`false`，用缺失的指示符表示。其余的用交叉标记，表示`true`值。例如，第四行第三列的这种值表示节点**4**和**3**之间存在边，如前面的图所示。
- en: Symmetric adjacency matrix
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对称邻接矩阵
- en: As the preceding graph is undirected, the adjacency matrix is symmetric. If
    there is an edge between nodes `i` and `j`, there is also an edge between nodes
    `j` and `i`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的图是无向图，邻接矩阵是对称的。如果节点`i`和`j`之间存在边，那么节点`j`和`i`之间也存在边。
- en: 'The following example involves a directed and unweighted graph. In such a case,
    the same rules can be used, but the adjacency matrix does not need to be symmetric.
    Let’s take a look at the illustration of the graph, presented together with the
    adjacency matrix:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例涉及一个有向和无权图。在这种情况下，可以使用相同的规则，但邻接矩阵不需要是对称的。让我们看一下图的插图，它与邻接矩阵一起展示：
- en: '![Figure 8.10 – Adjacency matrix representing a directed and unweighted graph](img/B18069_08_10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 - 表示有向和无权图的邻接矩阵](img/B18069_08_10.jpg)'
- en: Figure 8.10 – Adjacency matrix representing a directed and unweighted graph
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 - 表示有向和无权图的邻接矩阵
- en: Within the shown adjacency matrix, you can find data of 15 edges, represented
    by 15 elements with `true` values, indicated by crosses in the matrix. For example,
    the unidirectional edge from node **5** to **4** is shown as the cross at the
    fifth row and the fourth column.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的邻接矩阵中，你可以找到15条边的数据，这些数据由15个具有`true`值的元素表示，在矩阵中以交叉表示。例如，从节点**5**到**4**的单向边在矩阵的第5行和第4列显示为交叉。
- en: 'In both previous examples, you learned how to present an unweighted graph using
    an adjacency matrix. However, how you can store the data of the weighted graph,
    either undirected or directed? The answer is very simple – you just need to change
    the type of data stored in particular elements in the adjacency matrix from Boolean
    to numeric. Thus, you can specify the weight of edges, as shown in the following
    figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，你学习了如何使用邻接矩阵表示无权图。然而，你如何存储加权图的数据，无论是无向还是有向的呢？答案是简单的——你只需要将邻接矩阵中特定元素的数据类型从布尔型更改为数值型。因此，你可以指定边的权重，如下面的图所示：
- en: '![Figure 8.11 – Adjacency matrix representing a directed and weighted graph](img/B18069_08_11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 - 表示有向和加权图的邻接矩阵](img/B18069_08_11.jpg)'
- en: Figure 8.11 – Adjacency matrix representing a directed and weighted graph
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 - 表示有向和加权图的邻接矩阵
- en: To eliminate any doubt, let’s take a look at the edge between nodes **5** and
    **6** with the weight set to **2**. Such an edge is represented by the element
    at the fifth row and the sixth column. The value of the element is equal to the
    cost of traveling between nodes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除任何疑问，让我们看一下节点**5**和**6**之间的边，其权重设置为**2**。这样的边由第5行和第6列的元素表示。该元素的值等于节点之间旅行的成本。
- en: Implementation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: You already know some basic information about graphs, including nodes, edges,
    and two methods of representation, namely using an adjacency list and matrix.
    However, how you can use such a data structure in your applications? In this section,
    you will learn how to implement a graph using the C# language. To make your understanding
    of this content easier, two examples will be provided.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了一些关于图的基本信息，包括节点、边以及两种表示方法，即使用邻接表和矩阵。然而，你如何在应用程序中使用这样的数据结构呢？在本节中，你将学习如何使用C#语言实现图。为了使你对这一内容更容易理解，将提供两个示例。
- en: Node
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: 'To start with, let’s take a look at the code of a generic class representing
    a single node in a graph. Such a class is named `Node` and its code is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下表示图中单个节点的通用类代码。这样的类被命名为`Node`，其代码如下：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The class contains four properties. Since all of these elements perform important
    roles in the code snippets shown in this chapter, let’s analyze them in detail:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含四个属性。由于所有这些元素在本章中显示的代码片段中都扮演着重要的角色，让我们详细分析它们：
- en: The first property (`Index`) stores an index of a particular node in a collection
    of nodes in a graph to simplify the process of accessing a particular element.
    Thus, it is possible to easily get an instance of the `Node` class by using an
    index.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性（`Index`）存储了图中节点集合中特定节点的索引，以简化访问特定元素的过程。因此，可以通过使用索引轻松地获取`Node`类的实例。
- en: The next property is named `Data` and just stores some data in the node. It
    is worth mentioning that the type of such data is consistent with the type specified
    while creating an instance of the generic class.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个属性名为`Data`，它只是在节点中存储一些数据。值得注意的是，这种数据类型与创建泛型类实例时指定的类型一致。
- en: The `Neighbors` property represents the adjacency list for a particular node.
    Thus, it contains references to the `Node` instances representing adjacent nodes.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Neighbors`属性表示特定节点的邻接表。因此，它包含指向表示相邻节点的`Node`实例的引用。'
- en: The last property is named `Weights` and stores weights assigned to adjacent
    edges. In the case of a weighted graph, the number of elements in the `Weights`
    list is the same as the number of neighbors (`Neighbors`). If a graph is unweighted,
    the `Weights` list is empty.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个属性名为`Weights`，存储分配给相邻边的权重。在有向图中，`Weights`列表中的元素数量与邻居的数量（`Neighbors`）相同。如果图是无向的，`Weights`列表为空。
- en: 'Apart from the aforementioned properties, the class contains the overridden
    `ToString` method, which returns the textual representation of the object. Here,
    the string is returned in `"Index: [index]. Data: [data]. Neighbors: [``count]."`
    format.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '除了上述属性外，该类还包含重写的`ToString`方法，它返回对象的文本表示。在这里，字符串以`"Index: [index]. Data: [data].
    Neighbors: [count]."`格式返回。'
- en: Edge
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边
- en: 'As mentioned in the short introduction to the topic of graphs, a graph consists
    of nodes and edges. As a node is represented by an instance of the `Node` class,
    the generic `Edge` class can be used to represent an edge. The suitable part of
    the code is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在图论主题的简要介绍中提到的，一个图由节点和边组成。节点由`Node`类的实例表示，通用的`Edge`类可以用来表示边。合适的代码部分如下：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class contains three properties, namely representing nodes adjacent to the
    edge (`From` and `To`), as well as the weight of the edge (`Weight`). Moreover,
    the `ToString` method is overridden to present some basic information about the
    edge.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个属性，即表示与边相邻的节点（`From`和`To`），以及边的权重（`Weight`）。此外，重写了`ToString`方法，以展示关于边的一些基本信息。
- en: Graph
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图
- en: The next class is named `Graph` and represents a whole graph, with either directed
    or undirected edges, as well as either weighted or unweighted edges. The implementation
    consists of various properties and methods. These are described in detail here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类名为`Graph`，它代表一个完整的图，具有有向或无向边，以及加权或无加权边。实现包括各种属性和方法。这些将在下面详细描述。
- en: 'Let’s take a look at the basic version of the `Graph` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Graph`类的基本版本：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class contains two properties indicating whether edges are directed (`IsDirected`)
    and weighted (`IsWeighted`). Moreover, the `Nodes` property is declared, which
    stores a list of nodes existing in the graph.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含两个表示边是否为有向（`IsDirected`）和加权（`IsWeighted`）的属性。此外，声明了`Nodes`属性，它存储图中存在的节点列表。
- en: 'The next interesting member of the `Graph` class is the indexer, which takes
    two indices, namely indices of two nodes, to return an instance of the `Edge`
    class representing an edge between such nodes. The implementation is shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph`类的下一个有趣的成员是索引器，它接受两个索引，即两个节点的索引，以返回表示这些节点之间边的`Edge`类实例。实现如下：'
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Within the indexer, you get instances of the `Node` class representing two nodes
    (`nodeFrom` and `nodeTo`) according to the indices. As you want to find an edge
    from the first node (`nodeFrom`) to the second one (`nodeTo`), you need to try
    to find the second node in the collection of neighbor nodes of the first node
    using the `IndexOf` method. If such a connection does not exist, the `IndexOf`
    method returns a negative value, and `null` is returned by the indexer. Otherwise,
    you create a new instance of the `Edge` class and set the values of its properties,
    including `From` and `To`. If the data regarding the weight of particular edges
    is provided, the value of the `Weight` property of the `Edge` class is set as
    well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引器中，根据索引获取表示两个节点（`nodeFrom`和`nodeTo`）的`Node`类实例。由于你想找到从第一个节点（`nodeFrom`）到第二个节点（`nodeTo`）的边，你需要尝试使用`IndexOf`方法在第一个节点的邻接节点集合中找到第二个节点。如果不存在这样的连接，`IndexOf`方法返回一个负值，并且索引器返回`null`。否则，你创建一个`Edge`类的新实例并设置其属性值，包括`From`和`To`。如果提供了特定边的权重数据，`Edge`类的`Weight`属性值也会被设置。
- en: 'At this point, you know how to store data of nodes in the graph, but how can
    you add a new node? To do so, you can implement the `AddNode` method, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你知道如何在图中存储节点的数据，但如何添加一个新节点呢？要做到这一点，你可以实现`AddNode`方法，如下所示：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within this method, you create a new instance of the `Node` class and set a
    value of the `Data` property, according to the value of the parameter. Then, the
    newly created instance is added to the `Nodes` collection, and the `UpdateIndices`
    method (described later) is called to update the indices of all the nodes stored
    in the collection. Finally, the `Node` instance, representing the newly added
    node, is returned.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，您创建 `Node` 类的新实例并根据参数的值设置 `Data` 属性的值。然后，将新创建的实例添加到 `Nodes` 集合中，并调用（稍后描述的）`UpdateIndices`
    方法来更新集合中存储的所有节点的索引。最后，返回表示新添加节点的 `Node` 实例。
- en: 'You can remove the existing node as well. This operation is performed by the
    `RemoveNode` method, as shown in the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以删除现有的节点。此操作通过 `RemoveNode` 方法执行，如下代码片段所示：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method takes one parameter, namely an instance of the node that should
    be removed. First, you remove it from the collection of nodes. Then, you update
    the indices of the remaining nodes. Finally, you iterate through all the nodes
    in the graph to remove all edges that are connected with the node that has been
    removed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个参数，即应删除的节点实例。首先，您将其从节点集合中删除。然后，您更新剩余节点的索引。最后，您遍历图中所有节点以删除与已删除节点相连的所有边。
- en: 'As you already know, a graph consists of nodes and edges. Thus, the implementation
    of the `Graph` class should provide developers with a method for adding a new
    edge. Of course, it should support various variants of edges, either directed,
    undirected, weighted, or unweighted. The proposed implementation is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，图由节点和边组成。因此，`Graph` 类的实现应向开发者提供一个添加新边的方法。当然，它应支持边的各种变体，无论是有向、无向、加权还是无权。建议的实现方式如下：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `AddEdge` method takes three parameters, namely two instances of the `Node`
    class representing nodes connected by the edge (`from` and `to`), as well as the
    weight of the connection (`w`), which is set to `0` by default.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEdge` 方法接受三个参数，即表示通过边连接的两个节点实例（`from` 和 `to`），以及连接的权重（`w`），默认设置为 `0`。'
- en: In the first line within the method, you add the `Node` instance representing
    the second node to the list of neighbor nodes of the first one. If the weighted
    graph is considered, a weight of the aforementioned edge is added as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的第一行中，您将表示第二个节点的 `Node` 实例添加到第一个节点的邻居节点列表中。如果考虑加权图，则还会添加上述边的权重。
- en: The following part of the code is only taken into account when the graph is
    undirected. In such a case, you need to automatically add an edge in the opposite
    direction. To do so, you add the `Node` instance representing the first node to
    the list of neighbor nodes of the second one. If the edges are weighted, a weight
    of the aforementioned edge is added to the `Weights` list as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码部分仅在考虑无向图时才予以考虑。在这种情况下，您需要自动添加一个反向边。为此，您将表示第一个节点的 `Node` 实例添加到第二个节点的邻居节点列表中。如果边是加权的，则将上述边的权重添加到
    `Weights` 列表中。
- en: 'The process of removing an edge from the graph is supported by the `RemoveEdge`
    method. The code is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中删除边的操作由 `RemoveEdge` 方法支持。代码如下：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method takes two parameters, namely two nodes (`from` and `to`), between
    which there is an edge that should be removed. To start, you try to find the second
    node in the list of neighbor nodes of the first one. If it is found, you remove
    it. You should also remove the weight data if the weighted graph is considered.
    In the case of an undirected graph, you automatically remove a node in an opposite
    direction, namely between the `to` and `from` nodes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受两个参数，即两个节点（`from` 和 `to`），它们之间有一个应删除的边。首先，您尝试在第一个节点的邻居节点列表中找到第二个节点。如果找到，则将其删除。如果考虑加权图，还应删除权重数据。在无向图的情况下，您会自动删除一个反向节点，即在
    `to` 和 `from` 节点之间。
- en: 'The last public method is named `GetEdges` and makes it possible to get a collection
    of all the edges that are available in the graph. The proposed implementation
    is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个公共方法名为 `GetEdges`，它使得能够获取图中所有可用边的集合。建议的实现方式如下：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, a new list of edges is initialized. Then, you iterate through all the
    nodes in the graph using a `foreach` loop. Within it, you use a `for` loop to
    create instances of the `Edge` class. The number of instances should be equal
    to the number of neighbors of the current node (the `from` variable in the `foreach`
    loop). In the `for` loop, the newly created instance of the `Edge` class is configured
    by setting values of its properties, namely the first node (the `from` variable
    – that is, the current node from the `foreach` loop), the second node (to the
    currently-analyzed neighbor), and the weight. Then, the newly created instance
    is added to the collection of edges, represented by the `edges` variable. Finally,
    the result is returned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，初始化一个新的边列表。然后，使用 `foreach` 循环遍历图中的所有节点。在循环内部，使用 `for` 循环创建 `Edge` 类的实例。实例的数量应等于当前节点的邻居数量（`foreach`
    循环中的 `from` 变量）。在 `for` 循环中，通过设置属性值来配置新创建的 `Edge` 类实例，即第一个节点（`from` 变量，即 `foreach`
    循环中的当前节点），第二个节点（当前分析的邻居），以及权重。然后，将新创建的实例添加到由 `edges` 变量表示的边集合中。最后，返回结果。
- en: 'In various methods, you use the `UpdateIndices` method. Its code is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种方法中，您使用 `UpdateIndices` 方法。其代码如下：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method iterates through all the nodes in the graph and updates the values
    of the `Index` property to the consecutive number, starting from `0`. It is worth
    noting that the iteration is performed using the `ForEach` method, instead of
    using a `foreach` or `for` loop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历图中的所有节点，并将 `Index` 属性的值更新为连续数字，从 `0` 开始。值得注意的是，迭代是通过 `ForEach` 方法而不是 `foreach`
    或 `for` 循环来执行的。
- en: Now, you know how to create a basic implementation of a graph. The next step
    is to apply it to represent some example graphs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经知道了如何创建一个基本的图实现。下一步是将它应用到表示一些示例图。
- en: Example – undirected and unweighted edges
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 无向无权边
- en: 'Let’s try to use the previous implementation to create an undirected and unweighted
    graph according to the following diagram:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用之前的实现根据以下图创建一个无向无权图：
- en: '![Figure 8.12 – Illustration of the undirected and unweighted edges example](img/B18069_08_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 无向无权边示例的说明](img/B18069_08_12.jpg)'
- en: Figure 8.12 – Illustration of the undirected and unweighted edges example
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 无向无权边示例的说明
- en: 'As you can see, the graph contains 8 nodes and 10 edges. The implementation
    starts with the following line, which initializes a new undirected and unweighted
    graph:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该图包含 8 个节点和 10 条边。实现从以下行开始，初始化一个新的无向无权图：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Node<int> n1 = graph.AddNode(1);
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n1 = graph.AddNode(1);
- en: Node<int> n2 = graph.AddNode(2);
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n2 = graph.AddNode(2);
- en: Node<int> n3 = graph.AddNode(3);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n3 = graph.AddNode(3);
- en: Node<int> n4 = graph.AddNode(4);
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n4 = graph.AddNode(4);
- en: Node<int> n5 = graph.AddNode(5);
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n5 = graph.AddNode(5);
- en: Node<int> n6 = graph.AddNode(6);
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n6 = graph.AddNode(6);
- en: Node<int> n7 = graph.AddNode(7);
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n7 = graph.AddNode(7);
- en: Node<int> n8 = graph.AddNode(8);
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n8 = graph.AddNode(8);
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: graph.AddEdge(n1, n2);
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n1, n2);
- en: graph.AddEdge(n1, n3);
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n1, n3);
- en: graph.AddEdge(n2, n4);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n2, n4);
- en: graph.AddEdge(n3, n4);
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n3, n4);
- en: graph.AddEdge(n4, n5);
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n4, n5);
- en: graph.AddEdge(n5, n6);
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n6);
- en: graph.AddEdge(n5, n7);
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n7);
- en: graph.AddEdge(n5, n8);
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n8);
- en: graph.AddEdge(n6, n7);
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n6, n7);
- en: graph.AddEdge(n7, n8);
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n7, n8);
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Graph<int> graph = new()
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Graph<int> graph = new()
- en: '{ IsDirected = true, IsWeighted = true };'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '{ IsDirected = true, IsWeighted = true };'
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Node<int> n1 = graph.AddNode(1);
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n1 = graph.AddNode(1);
- en: Node<int> n2 = graph.AddNode(2);
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n2 = graph.AddNode(2);
- en: Node<int> n3 = graph.AddNode(3);
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n3 = graph.AddNode(3);
- en: Node<int> n4 = graph.AddNode(4);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n4 = graph.AddNode(4);
- en: Node<int> n5 = graph.AddNode(5);
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n5 = graph.AddNode(5);
- en: Node<int> n6 = graph.AddNode(6);
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n6 = graph.AddNode(6);
- en: Node<int> n7 = graph.AddNode(7);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n7 = graph.AddNode(7);
- en: Node<int> n8 = graph.AddNode(8);
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n8 = graph.AddNode(8);
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: graph.AddEdge(n1, n2, 9);
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n1, n2, 9);
- en: graph.AddEdge(n1, n3, 5);
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n1, n3, 5);
- en: graph.AddEdge(n2, n1, 3);
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n2, n1, 3);
- en: graph.AddEdge(n2, n4, 18);
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n2, n4, 18);
- en: graph.AddEdge(n3, n4, 12);
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n3, n4, 12);
- en: graph.AddEdge(n4, n2, 2);
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n4, n2, 2);
- en: graph.AddEdge(n4, n8, 8);
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n4, n8, 8);
- en: graph.AddEdge(n5, n4, 9);
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n4, 9);
- en: graph.AddEdge(n5, n6, 2);
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n6, 2);
- en: graph.AddEdge(n5, n7, 5);
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n7, 5);
- en: graph.AddEdge(n5, n8, 3);
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n5, n8, 3);
- en: graph.AddEdge(n6, n7, 1);
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n6, n7, 1);
- en: graph.AddEdge(n7, n5, 4);
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n7, n5, 4);
- en: graph.AddEdge(n7, n8, 6);
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n7, n8, 6);
- en: graph.AddEdge(n8, n5, 3);
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n8, n5, 3);
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: public List<Node<T>> DFS()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public List<Node<T>> DFS()
- en: '{'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: bool[] isVisited = new bool[Nodes.Count];
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: bool[] isVisited = new bool[Nodes.Count];
- en: List<Node<T>> result = [];
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: List<Node<T>> result = [];
- en: DFS(isVisited, Nodes[0], result);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: DFS(isVisited, Nodes[0], result);
- en: return result;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: private void DFS(bool[] isVisited, Node<T> node,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: private void DFS(bool[] isVisited, Node<T> node,
- en: List<Node<T>> result)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: List<Node<T>> result)
- en: '{'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: result.Add(node);
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: result.Add(node);
- en: isVisited[node.Index] = true;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: isVisited[node.Index] = true;
- en: foreach (Node<T> neighbor in node.Neighbors)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (Node<T> neighbor in node.Neighbors)
- en: '{'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (!isVisited[neighbor.Index])
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: if (!isVisited[neighbor.Index])
- en: '{'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: DFS(isVisited, neighbor, result);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: DFS(isVisited, neighbor, result);
- en: '}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Graph<int> graph = new()
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Graph<int> graph = new()
- en: '{ IsDirected = true, IsWeighted = true };'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '{ IsDirected = true, IsWeighted = true };'
- en: Node<int> n1 = graph.AddNode(1); (...)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n1 = graph.AddNode(1); (...)
- en: Node<int> n8 = graph.AddNode(8);
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Node<int> n8 = graph.AddNode(8);
- en: graph.AddEdge(n1, n2, 9); (...)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n1, n2, 9); (...)
- en: graph.AddEdge(n8, n5, 3);
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: graph.AddEdge(n8, n5, 3);
- en: List<Node<int>> nodes = graph.DFS();
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: List<Node<int>> nodes = graph.DFS();
- en: nodes.ForEach(Console.WriteLine);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: nodes.ForEach(Console.WriteLine);
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Index: 0\. Data: 1\. Neighbors: 2.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：0。数据：1。邻居：2。
- en: 'Index: 1\. Data: 2\. Neighbors: 2.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：1。数据：2。邻居：2。
- en: 'Index: 3\. Data: 4\. Neighbors: 2.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：3。数据：4。邻居：2。
- en: 'Index: 7\. Data: 8\. Neighbors: 1.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：7。数据：8。邻居：1。
- en: 'Index: 4\. Data: 5\. Neighbors: 4.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：4。数据：5。邻居：4。
- en: 'Index: 5\. Data: 6\. Neighbors: 1.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：5。数据：6。邻居：1。
- en: 'Index: 6\. Data: 7\. Neighbors: 2.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：6。数据：7。邻居：2。
- en: 'Index: 2\. Data: 3\. Neighbors: 1.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 索引：2。数据：3。邻居：1。
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'public List<Node<T>> BFS public method is added to the Graph class and is used
    to start the traversal of a graph. It calls the private BFS method, passing the
    first node as the parameter. Its code is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'public List<Node<T>> BFS public method is added to the Graph class and is used
    to start the traversal of a graph. It calls the private BFS method, passing the
    first node as the parameter. Its code is as follows:'
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The important part of the code is performed by the `isVisited` array, which
    stores Boolean values indicating whether particular nodes were already visited.
    The array is initialized at the beginning of the `BFS` method, and the value of
    the element related to the current node is set to `true`, which indicates that
    this node was visited.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的重要部分由`isVisited`数组执行，该数组存储布尔值，指示特定节点是否已被访问。该数组在`BFS`方法的开始时初始化，并将与当前节点相关的元素值设置为`true`，这表示该节点已被访问。
- en: Then, the list for storing traversed nodes (`result`) and the queue for storing
    nodes that should be visited next (`queue`) are created. Just after the initialization
    of the queue, the current node is added to it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建用于存储已遍历节点的列表（`result`）和用于存储下一个要访问的节点的队列（`queue`）。在队列初始化后，当前节点被添加到其中。
- en: 'The following operations are performed until the queue is empty: you get the
    first node from the queue (the `next` variable), add it to the collection of visited
    nodes, and iterate through the neighbors of the current node. For each of them,
    you check whether it has already been visited. If not, it is marked as visited
    by setting a proper value in the `isVisited` array, and the neighbor is added
    to the queue for analysis in one of the next iterations of the `while` loop.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作，直到队列为空：从队列中获取第一个节点（`next`变量），将其添加到已访问节点的集合中，并遍历当前节点的邻居。对于每一个，你检查它是否已被访问。如果没有，通过在`isVisited`数组中设置适当的值将其标记为已访问，并将邻居添加到队列中，以便在`while`循环的下一个迭代中进行分析。
- en: 'Finally, the list of the visited nodes is returned. If you want to test this
    algorithm, you can use the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回已访问节点的列表。如果你想测试这个算法，可以使用以下代码：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code calls the `BFS` public method to traverse the graph according
    to the BFS algorithm. The last line is responsible for iterating through the results
    to present the data of the nodes in the console, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用`BFS`公共方法根据BFS算法遍历图。最后一行负责遍历结果，以在控制台显示节点的数据，如下所示：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ve just learned about two algorithms for traversing a graph, namely DFS
    and BFS. To make your understanding of such topics easier, this chapter contains
    detailed descriptions, illustrations, and examples. Now, let’s proceed to another
    important topic, namely the minimum spanning tree, which has many real-world applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了两种图遍历算法，即DFS和BFS。为了使你对这类主题的理解更加容易，本章包含了详细的描述、插图和示例。现在，让我们继续探讨另一个重要主题，即最小生成树，它在现实世界中有很多应用。
- en: Where can you find more information?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: There are many online resources regarding traversing a graph. You can learn
    more about DFS at [https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search),
    while you can find more information about the BFS algorithm and its implementation
    at [https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图的遍历，有很多在线资源。你可以在[https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search)了解更多关于DFS的信息，同时你可以在[https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/)找到更多关于BFS算法及其实现的信息。
- en: Minimum spanning tree
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树
- en: 'While talking about graphs, it is beneficial to introduce the subject of a
    **spanning tree**. What is it? **A** **spanning tree is a subset of edges that
    connects all nodes in a graph without cycles**. Of course, it is possible to have
    many spanning trees within the same graph. For example, let’s take a look at the
    following diagram:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论图时，介绍**生成树**的主题是有益的。那是什么？**生成树是图的边的子集，它连接图中的所有节点而不形成环**。当然，同一个图中可以有多个生成树。例如，让我们看看以下图表：
- en: '![Figure 8.16 – Illustration of spanning trees within a graph](img/B18069_08_16.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 图中生成树的示意图](img/B18069_08_16.jpg)'
- en: Figure 8.16 – Illustration of spanning trees within a graph
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 图中生成树的示意图
- en: 'On the left-hand side is a spanning tree that consists of the following edges:
    (**1**, **2**), (**1**, **3**), (**3**, **4**), (**4**, **5**), (**5**, **6**),
    (**6**, **7**), and (**5**, **8**). The total weight is equal to 40\. On the right-hand
    side, another spanning tree is shown. Here, the following edges are chosen: (**1**,
    **2**), (**1**, **3**), (**2**, **4**), (**4**, **8**), (**5**, **8**), (**5**,
    **6**), and (**6**, **7**). The total weight is equal to 31.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是一个包含以下边的生成树：(**1**, **2**), (**1**, **3**), (**3**, **4**), (**4**, **5**),
    (**5**, **6**), (**6**, **7**), 和 (**5**, **8**). 总权重等于 40。在右侧，显示了另一个生成树。这里，选择的边是：(**1**,
    **2**), (**1**, **3**), (**2**, **4**), (**4**, **8**), (**5**, **8**), (**5**,
    **6**), 和 (**6**, **7**). 总权重等于 31。
- en: 'However, neither of the preceding spanning trees is the **minimum spanning
    tree (MST)** of this graph. What does it mean that a spanning tree is *minimum*?
    The answer is really simple: it is **a spanning tree with the minimum cost from
    all spanning trees available in the graph**. You can get the MST by replacing
    the edge (**6**, **7**) with (**5**, **7**). Then, the cost is equal to 30\. It
    is also worth mentioning that the number of edges in a spanning tree is equal
    to the number of nodes minus one.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述任何一个生成树都不是这个图的**最小生成树（MST）**。生成树是“最小”的意思是什么？答案是真的很简单：它是**在图中所有可能的生成树中具有最小成本的生成树**。你可以通过将边(**6**,
    **7**)替换为(**5**, **7**)来得到MST。然后，成本等于30。还值得一提的是，生成树中的边数等于节点数减一。
- en: Why is the topic of MST so important? Let’s imagine a scenario where you need
    to connect many buildings to a telecommunication cable. Of course, there are various
    possible connections, such as from one building to another, or using a hub. What’s
    more, environmental conditions can have a serious impact on the cost of the investment
    due to the necessity of crossing a road or even a river. Your task is to successfully
    connect all buildings to the telecommunication cable at the lowest possible cost.
    How should you design the connections? To answer this question, you just need
    to create a graph, where nodes represent connectors and edges indicate possible
    connections. Then, you find the MST, and that’s all!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么MST（最小生成树）这个主题如此重要？让我们想象一个场景，你需要将许多建筑连接到电信电缆。当然，有各种可能的连接方式，比如从一个建筑到另一个建筑，或者使用一个中心节点。更重要的是，环境条件可能会由于需要穿越道路甚至河流而严重影响投资成本。你的任务是成功地将所有建筑以最低的成本连接到电信电缆。你应该如何设计这些连接？要回答这个问题，你只需要创建一个图，其中节点代表连接器，边表示可能的连接。然后，你找到MST，这就完成了！
- en: Do you want some examples?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要一些例子吗？
- en: The aforementioned problem of connecting many buildings to the telecommunication
    cable is presented in the example at the end of this section regarding the MST.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节末尾关于MST的例子中，展示了将许多建筑连接到电信电缆的问题。
- en: The next question is how to find the MST. There are various approaches to solving
    this problem, including the application of Kruskal’s or Prim’s algorithms. These
    are presented and explained in the following sections.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是如何找到最小生成树（MST）。解决这个问题有各种方法，包括应用克鲁斯卡尔或普里姆算法。这些方法将在以下章节中介绍和解释。
- en: Kruskal’s algorithm
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法
- en: One of the algorithms for finding the MST was discovered by **Kruskal**. Its
    operation is very simple to explain. **The algorithm takes an edge with the minimum
    weight from the remaining ones and adds it to the MST, but only if adding it does
    not create a cycle**. The algorithm stops when all the nodes are connected.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 用于找到MST的一种算法是由**克鲁斯卡尔**发现的。它的操作非常简单易懂。**算法从剩余的边中选择具有最小权重的边并将其添加到MST中，但只有当添加它不会创建环时**。算法在所有节点都连接时停止。
- en: 'Let’s take a look at a diagram that presents the steps of finding the MST using
    **Kruskal’s algorithm**:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个展示使用**克鲁斯卡尔算法**找到MST步骤的图表：
- en: '![Figure 8.17 – Illustration of Kruskal’s algorithm](img/B18069_08_17.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图8.17 – 克鲁斯卡尔算法的示意图](img/B18069_08_17.jpg)'
- en: Figure 8.17 – Illustration of Kruskal’s algorithm
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 克鲁斯卡尔算法的示意图
- en: 'In **Step 1**, edge (**5**, **8**) is chosen because it has the minimum weight,
    namely **1**. Then, the following edges are selected: (**1**, **2**) in **Step
    2**, (**2**, **4**) in **Step 3**, (**5**, **6**) in **Step 4**, (**1**, **3**)
    in **Step 5**, as well as (**5**, **7**) and (**4**, **8**) in **Step 6**. It
    is worth noting that before taking the (**4**, **8**) edge, (**6**, **7**) is
    considered due to its lower weight (6 instead of 8). However, adding it to the
    MST will introduce a cycle formed by the (**5**, **6**), (**6**, **7**), and (**5**,
    **7**) edges. For this reason, such an edge is ignored and the algorithm chooses
    (**4**, **8**). Finally, the number of edges in the MST is 7\. The number of nodes
    is equal to 8, which means that the algorithm can stop operating and the MST has
    been found.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤1**中，选择边（**5**，**8**），因为它具有最小的权重，即**1**。然后，在**步骤2**中选择边（**1**，**2**），在**步骤3**中选择边（**2**，**4**），在**步骤4**中选择边（**5**，**6**），在**步骤5**中选择边（**1**，**3**），以及在**步骤6**中选择边（**5**，**7**）和（**4**，**8**）。值得注意的是，在取（**4**，**8**）边之前，考虑了（**6**，**7**），因为它的权重更低（6而不是8）。然而，将其添加到MST中将会引入由（**5**，**6**），（**6**，**7**）和（**5**，**7**）边形成的环。因此，这样的边被忽略，算法选择了（**4**，**8**）。最后，MST中的边数为7。节点数为8，这意味着算法可以停止运行，MST已经找到。
- en: 'Let’s take a look at its implementation. It involves the `MSTKruskal` method,
    which should be added to the `Graph` class. The proposed code is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实现。这涉及到`MSTKruskal`方法，该方法应添加到`Graph`类中。提出的代码如下：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method does not take any parameters. To start, a list of edges is obtained
    by calling the `GetEdges` method. Then, the edges are sorted in ascending order
    by weight. Such a step is crucial because you need to get an edge with the minimum
    cost in the following iterations of the algorithm. In the next line, a new queue
    is created and `Edge` instances are enqueued, using the constructor of the `Queue`
    class.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不接受任何参数。首先，通过调用`GetEdges`方法获取边列表。然后，根据权重将边按升序排序。这一步至关重要，因为在算法的后续迭代中，你需要获取具有最小成本的边。在下一行，创建了一个新的队列，并使用`Queue`类的构造函数将`Edge`实例入队。
- en: In the next block of code, an array with data of subsets is created. By default,
    each node is added to a separate subset. This is the reason why the number of
    elements in the `subsets` array is equal to the number of nodes. The subsets are
    used to check whether an addition of an edge to the MST causes the creation of
    a cycle.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，创建了一个包含子集数据的数组。默认情况下，每个节点被添加到单独的子集中。这就是为什么`subsets`数组中的元素数量等于节点数量的原因。子集用于检查将边添加到MST中是否会导致创建环。
- en: Then, the list for storing edges from the MST is created (`result`). The most
    interesting part of the code is the `while` loop, which iterates until the correct
    number of edges is found in the MST. Within this loop, you get the edge with the
    minimum weight, just by calling the `Dequeue` method on the `Queue` instance.
    Then, you can check whether no cycles were introduced by adding the found edge
    to the MST. In such a case, the edge is added to the target list, and the `Union`
    method is called to union two subsets.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建用于存储 MST 边的列表（`result`）。代码中最有趣的部分是 `while` 循环，它迭代直到在 MST 中找到正确数量的边。在这个循环中，你只需通过在
    `Queue` 实例上调用 `Dequeue` 方法，就可以得到具有最小权重的边。然后，你可以检查通过将找到的边添加到 MST 中是否引入了任何循环。在这种情况下，边被添加到目标列表中，并调用
    `Union` 方法来合并两个子集。
- en: 'While analyzing the previous method, the `GetRoot` one is mentioned. It aims
    to update parents for subsets, as well as return the root node of the subset,
    as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析前面的方法时，提到了 `GetRoot` 方法。它的目的是更新子集的父节点，并返回子集的根节点，如下所示：
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last private method is named `Union` and performs the *union* operation
    (by a rank) of two sets. It takes three parameters, namely an array of `Subset`
    instances and two `Node` instances, representing root nodes for subsets on which
    the *union* operation should be performed. The suitable part of the code is as
    follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个私有方法命名为 `Union`，它执行两个集合的 *union* 操作（通过秩）。它接受三个参数，即 `Subset` 实例的数组以及两个 `Node`
    实例，代表要执行 *union* 操作的子集的根节点。代码的合适部分如下：
- en: '[PRE25]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the previous code snippets, you can see the `Subset` class, but what does
    it look like? Let’s take a look at its declaration:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到 `Subset` 类，但它是什么样子呢？让我们看看它的声明：
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The class contains properties representing the parent node (`Parent`), as well
    as the rank of the subset (`Rank`). The class also contains the overridden `ToString`
    method, which presents some basic information about the subset in textual form.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含表示父节点的属性（`Parent`），以及子集的秩（`Rank`）。该类还包含重写的 `ToString` 方法，它以文本形式呈现有关子集的一些基本信息。
- en: Where can you find more information?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: Did you know that the presented approach is representative of a **greedy algorithm**?
    The code shown here is based on the implementation available at [https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/](https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/).
    You can find there a lot of interesting information about Kruskal’s algorithm,
    as well as about many other algorithms regarding graphs, such as about a simple
    approach to coloring, which is also one of the topics waiting for you in the current
    chapter. *GeeksForGeeks* is a great resource for various algorithms with a huge
    collection of content, and it’s something I highly recommend!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道所提出的方法代表了一种 **贪心算法** 吗？这里显示的代码基于在 [https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/](https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/)
    可用的实现。你可以在那里找到关于 Kruskal 算法以及关于许多其他图算法的大量有趣信息，例如关于着色的一种简单方法，这也是本章等待你的一个主题。*GeeksForGeeks*
    是一个关于各种算法的极好资源，拥有大量内容，我强烈推荐！
- en: 'Let’s take a look at the usage of the `MSTKruskal` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `MSTKruskal` 方法的用法：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, you initialize an undirected and weighted graph, as well as add nodes
    and edges. Then, you call the `MSTKruskal` method to find the MST using Kruskal’s
    algorithm. Finally, you use the `ForEach` method to write the data of each edge
    from the MST in the console. The exemplary output is shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个无向加权图，并添加节点和边。然后，你调用 `MSTKruskal` 方法使用 Kruskal 算法找到 MST。最后，你使用 `ForEach`
    方法将 MST 中每条边的数据写入控制台。示例输出如下：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As mentioned previously, you will learn about two algorithms for finding the
    MST in this chapter. Now, it is high time to take a look at the second one, namely
    Prim’s algorithm.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你将在本章学习两种寻找 MST 的算法。现在，是时候看看第二种算法了，即 Prim 算法。
- en: Prim’s algorithm
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Prim 算法
- en: Another solution to solve the problem of finding the MST is **Prim’s algorithm**.
    **It uses two sets of nodes that are disjointed, namely the nodes located in the
    MST and the nodes that are not placed there yet**. In the following iterations,
    the algorithm **finds an edge with the minimum weight that connects a node from
    the first group with a node from the second group. The node of the edge, which
    is not already in the MST, is added to** **this set.**
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解决寻找MST问题的另一种方法是**Prim算法**。**它使用两组不相交的节点集，即位于MST中的节点和尚未放置在那里的节点**。在后续迭代中，算法**找到连接第一组中的一个节点和第二组中的一个节点的最小权重的边。该边上的节点，如果它尚未在MST中，则被添加到**该集合中。
- en: 'The preceding description sounds quite simple, doesn’t it? Let’s see it in
    action by analyzing the diagram presenting the steps of finding the MST using
    Prim’s algorithm:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述听起来相当简单，不是吗？让我们通过分析展示使用Prim算法寻找MST步骤的图表来实际看看：
- en: '![Figure 8.18 – Illustration of Prim’s algorithm](img/B18069_08_18.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – Prim 算法的示意图](img/B18069_08_18.jpg)'
- en: Figure 8.18 – Illustration of Prim’s algorithm
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – Prim 算法的示意图
- en: Let’s take a look at the additional indicators that have been added next to
    the nodes in the graph. They present the minimum weight necessary to reach such
    a node from any of its neighbors. By default, the starting node has such a value
    set to **0**, while all others are set to infinity, as presented in **Step 1**.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在图中节点旁边添加的附加指标。它们表示从任何邻居到达此类节点的最小权重。默认情况下，起始节点的此值设置为**0**，而所有其他节点都设置为无穷大，如**步骤
    1**所示。
- en: In **Step 2**, the starting node is added to the subset of nodes forming the
    MST, and the distance to its neighbors is updated, namely **5** for reaching node
    **3** and **3** for reaching node **2**. The values of the other nodes are still
    set to infinity.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，起始节点被添加到形成最小生成树（MST）的节点子集中，并更新其邻居的距离，即到达节点**3**的距离为**5**，到达节点**2**的距离为**3**。其他节点的值仍然设置为无穷大。
- en: In **Step 3**, the node with the minimum cost is chosen. In this case, node
    **2** is selected because the cost is equal to **3**. Its competitor (namely node
    **3**) has a cost equal to **5**. Next, you need to update the cost of reaching
    the neighbors of the current node, namely node **4** with the cost set to **4**.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，选择具有最小成本的节点。在这种情况下，选择节点**2**，因为其成本等于**3**。其竞争对手（即节点**3**）的成本等于**5**。接下来，你需要更新到达当前节点（即节点**4**）邻居的成本，成本设置为**4**。
- en: 'The next chosen node is node **4** because it does not exist in the MST set
    and has the lowest reaching cost (**Step 4**). In the same way, you choose the
    next edges in the following order: (**1**, **3**) in **Step 5**, (**4**, **8**)
    in **Step 6**, (**8**, **5**) in **Step 7**, (**5**, **6**) in **Step 8**, and
    (**5**, **7**) in **Step 9**. Now, all the nodes are included in the MST and the
    algorithm can stop its operation.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选择的节点是节点**4**，因为它不在MST集合中，并且具有最低的到达成本（**步骤 4**）。同样，你将按照以下顺序选择下一个边：**步骤 5**中的（**1**，**3**），**步骤
    6**中的（**4**，**8**），**步骤 7**中的（**8**，**5**），**步骤 8**中的（**5**，**6**），以及**步骤 9**中的（**5**，**7**）。现在，所有节点都包含在MST中，算法可以停止其操作。
- en: 'Given this detailed description of the steps of the algorithm, let’s proceed
    to the C#-based implementation. The majority of operations are performed in the
    `MSTPrim` method, which should be added to the `Graph` class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了算法步骤的详细描述后，让我们继续进行基于C#的实现。大多数操作都在`MSTPrim`方法中执行，该方法应添加到`Graph`类中：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `MSTPrim` method does not take any parameters. It uses three auxiliary
    node-related arrays that assign additional data to the nodes of the graph:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSTPrim`方法不接收任何参数。它使用三个辅助节点相关数组，为图中的节点分配额外的数据：'
- en: The first, namely `previous`, stores indices of the previous node, from which
    the given node can be reached. By default, the values of all elements are equal
    to `0`, except the first one, which is set to `-1`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个，即`previous`，存储从给定节点可以到达的前一个节点的索引。默认情况下，所有元素的值都等于`0`，除了第一个，其设置为`-1`。
- en: The `minWeight` array stores the minimum weight of the edge for accessing the
    given node. By default, all elements are set to the maximum value of the `int`
    type, while the value for the first element is set to `0`.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minWeight`数组存储访问给定节点的边的最小权重。默认情况下，所有元素都设置为`int`类型的最大值，而第一个元素的值被设置为`0`。'
- en: The `isInMST` array indicates whether the given node is already in the MST.
    To start with, the values of all the elements should be set to `false`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInMST`数组表示给定的节点是否已经在MST中。一开始，所有元素的值应该设置为`false`。'
- en: The most interesting part of the code is located in the `for` loop. Within it,
    you’ll find the index of the node from the set of nodes not located in the MST,
    which can be reached with the minimum cost. Such a task is performed by the `GetMinWeightIndex`
    method. Then, another `for` loop is used. Within it, you get an edge that connects
    nodes with the `mwi` index (this stands for *minimum weight index*) and `j`. You
    check whether the node is not already located in the MST and whether the cost
    of reaching the node is smaller than the previous minimum cost. If so, values
    of node-related elements in the `previous` and `minWeight` arrays are updated.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分位于`for`循环中。在其中，你会找到从不在MST中的节点集中，以最小成本可达的节点的索引。这个任务由`GetMinWeightIndex`方法执行。然后，另一个`for`循环被使用。在其中，你得到一个连接具有`mwi`索引（代表*最小权重索引*）和`j`的节点的边。你检查节点是否不在MST中，以及到达该节点的成本是否小于之前的最低成本。如果是这样，`previous`和`minWeight`数组中与节点相关的元素值将被更新。
- en: The remaining part of the code just prepares the final results. Here, you create
    a new instance of the list with the data of edges that form the MST. The `for`
    loop is used to get the data of the following edges and to add them to the `result`
    list.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分只是准备最终结果。在这里，你创建了一个包含形成MST的边的数据的新列表实例。`for`循环用于获取以下边的数据并将它们添加到`result`列表中。
- en: 'While analyzing the code, the `GetMinWeightIndex` private method is mentioned.
    Its code is presented in the following block:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码时，提到了`GetMinWeightIndex`私有方法。其代码如下所示：
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `GetMinWeightIndex` method just finds an index of the node, which is not
    located in the MST and can be reached with the minimum cost. To do so, you use
    a `for` loop to iterate through all the nodes. For each of them, you check whether
    the current node is not located in the MST and whether the cost of reaching it
    is smaller than the already-stored minimum value. If so, the values of the `minValue`
    and `minIndex` variables are updated. Finally, the index is returned.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMinWeightIndex`方法只是找到一个节点索引，该节点不在MST中，并且可以以最小成本到达。为此，你使用`for`循环遍历所有节点。对于每个节点，你检查当前节点是否不在MST中，以及到达它的成本是否小于已存储的最低值。如果是这样，`minValue`和`minIndex`变量的值将被更新。最后，返回索引。'
- en: Where can you find more information?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: Similar to Kruskal’s algorithm, Prim’s variant is also representative of a **greedy
    algorithm**. I strongly encourage you to search for even more interesting information
    about this algorithm in books, research papers, and on the internet. It is worth
    noting that the presented code is based on the implementation shown at [https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与克鲁斯卡尔算法类似，普里姆算法的变体也是**贪婪算法**的一个代表。我强烈建议你在书籍、研究论文和互联网上搜索更多关于这个算法的有趣信息。值得注意的是，所提供的代码基于[https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/)中展示的实现。
- en: 'Let’s take a look at the usage of the `MSTPrim` method:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`MSTPrim`方法的用法：
- en: '[PRE31]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The missing parts of the code are the same as in the case of the exemplary
    code regarding Kruskal’s algorithm. When you run the code, you will get the following
    result:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中缺失的部分与关于克鲁斯卡尔算法的示例代码相同。当你运行代码时，你会得到以下结果：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that we’ve looked at various algorithms for finding the MST, let’s proceed
    to an example.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了多种寻找最小生成树（MST）的算法，让我们来看一个例子。
- en: Example – telecommunication cable
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 电信电缆
- en: As mentioned in the introduction to the topic of MSTs, this problem has some
    important real-world applications, such as creating a plan of connections between
    buildings to supply all of them with a telecommunication cable with the smallest
    cost. Of course, there are various possible connections, such as from one building
    to another or using a hub. What’s more, environmental conditions can have a serious
    impact on the cost of the investment due to the necessity of crossing a road or
    even a river.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在MST主题介绍中提到的，这个问题有一些重要的实际应用，例如制定建筑之间连接的计划，以最低的成本为所有建筑提供电信电缆。当然，有各种可能的连接方式，例如从一个建筑到另一个建筑或使用中心节点。更重要的是，环境条件可能会由于需要穿越道路甚至河流而严重影响投资成本。
- en: 'For example, let’s create a program that solves this problem in the context
    of a set of buildings, as shown in the following figure:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个程序，在一系列建筑的环境中解决此问题，如图所示：
- en: '![Figure 8.19 – Illustration of the telecommunication cable example](img/B18069_08_19.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19 – 电信电缆示例示意图](img/B18069_08_19.jpg)'
- en: Figure 8.19 – Illustration of the telecommunication cable example
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 电信电缆示例示意图
- en: As you can see, the estate community consists of six buildings. The buildings
    are located on two sides of a small river with only one bridge. Moreover, two
    roads exist. Of course, there are different costs of connections between various
    points, depending both on the distance and the environmental conditions. For example,
    the direct connection between two buildings (**B1** and **B2**) has a cost equal
    to **2**, while using the bridge (between **R1** and **R5**) involves a cost equal
    to **75**. If you need to cross the river without a bridge (between **R3** and
    **R6**), the cost is even higher and equal to **100**.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，住宅社区由六个建筑组成。这些建筑位于一条小河的两侧，只有一座桥。此外，还有两条道路。当然，不同点之间的连接成本不同，这取决于距离和环境条件。例如，两个建筑（**B1**和**B2**）之间的直接连接成本等于**2**，而使用桥梁（在**R1**和**R5**之间）的成本等于**75**。如果你需要在没有桥梁的情况下穿越河流（在**R3**和**R6**之间），成本甚至更高，等于**100**。
- en: 'Your task is to find the MST. Within this example, you will apply both Kruskal’s
    and Prim’s algorithms to solve this problem. To start, let’s initialize the undirected
    and weighted graph, as well as add nodes and edges, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是找到MST。在这个示例中，你将应用Kruskal算法和Prim算法来解决这个问题。首先，让我们初始化无向加权图，并添加节点和边，如下所示：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, you just need to call the `MSTKruskal` method to use Kruskal’s algorithm
    to find the MST. When the results are obtained, you can easily present them in
    the console, together with the total cost. The suitable part of the code is shown
    in the following block:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要调用`MSTKruskal`方法来使用Kruskal算法找到MST。当获得结果时，你可以轻松地在控制台展示它们，包括总成本。合适的代码部分如下所示：
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The results presented in the console are shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示的结果如下：
- en: '[PRE35]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you visualize such results on the map, you’ll find the following MST:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此类结果可视化在地图上，你会发现以下MST：
- en: '![Figure 8.20 – Illustration of the result of the telecommunication cable example](img/B18069_08_20.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20 – 电信电缆示例的结果示意图](img/B18069_08_20.jpg)'
- en: Figure 8.20 – Illustration of the result of the telecommunication cable example
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 电信电缆示例的结果示意图
- en: 'Similarly, you can apply Prim’s algorithm:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以应用Prim算法：
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The results are as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You’ve just completed an example related to the real-world application of MSTs.
    Are you ready to proceed to another graph-related subject known as coloring?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了一个与MST实际应用相关的示例。你准备好继续学习另一个被称为着色的图相关主题了吗？
- en: Coloring
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上色
- en: The topic of finding the MST is not the only graph-related problem. Among others,
    **node coloring** exists. It aims to **assign colors (numbers) to all nodes to
    comply with the rule that there cannot be an edge between two nodes with the same
    color**. Of course, the number of colors should be as low as possible. Such a
    problem has some real-world applications, such as for coloring a map. The implementation
    of the coloring algorithm, which is shown in this chapter, is quite simple and
    in some cases could use more colors than is necessary.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最小生成树（MST）的问题并不是唯一的图相关问题。其中之一是**节点着色**。它的目的是**将颜色（数字）分配给所有节点，以符合规则，即不能存在两个具有相同颜色的节点之间的边**。当然，颜色数量应尽可能少。此类问题有一些实际应用，例如绘制地图。本章中展示的着色算法实现相当简单，在某些情况下可能需要比必要的更多颜色。
- en: Four-color theorem
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 四色定理
- en: Did you know that the nodes of each planar graph can be colored with no more
    than four colors? If you are interested in this topic, take a look at the **four-color
    theorem** ([http://mathworld.wolfram.com/Four-ColorTheorem.html](http://mathworld.wolfram.com/Four-ColorTheorem.html)).
    Since I am talking about a planar graph, you should understand that it is a graph
    whose edges do not cross each other while it is drawn on the plane.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道每个平面图的节点可以用不超过四种颜色着色吗？如果你对这个主题感兴趣，请查看 **四色定理** ([http://mathworld.wolfram.com/Four-ColorTheorem.html](http://mathworld.wolfram.com/Four-ColorTheorem.html))。由于我在谈论平面图，你应该理解它是一个在平面上绘制时边不会交叉的图。
- en: 'Let’s take a look at the following diagram:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![Figure 8.21 – Illustration of graph coloring](img/B18069_08_21.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21 – 图着色的示意图](img/B18069_08_21.jpg)'
- en: Figure 8.21 – Illustration of graph coloring
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 图着色的示意图
- en: 'The left-hand side illustration presents a graph that is colored using four
    colors: red (index equal to **0**), green (**1**), blue (**2**), and yellow (**3**).
    As you can see, there are no nodes with the same colors connected by an edge.
    The graph shown on the right depicts the graph with two additional edges, namely
    (**2**, **6**) and (**2**, **5**). In such a case, the coloring has changed, but
    the number of colors remains the same.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的插图展示了一个使用四种颜色着色的图：红色（索引等于 **0**）、绿色（**1**）、蓝色（**2**）和黄色（**3**）。正如你所见，没有节点通过边连接具有相同的颜色。右侧展示的图显示了具有两个额外边（**2**，**6**）和（**2**，**5**）的图。在这种情况下，着色已改变，但颜色的数量保持不变。
- en: 'The question is, how can you find colors for nodes to comply with the aforementioned
    rule? Fortunately, the algorithm is very simple and its implementation is presented
    here. Here is the code of the `Color` method, which should be added to the `Graph`
    class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如何为节点找到颜色以满足上述规则？幸运的是，算法非常简单，其实现如下。以下是 `Color` 方法的代码，它应该添加到 `Graph` 类中：
- en: '[PRE38]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Color` method uses two auxiliary node-related arrays. The first is named
    `colors` and stores indices of colors chosen for particular nodes. By default,
    the values of all elements are set to `-1`, except the first one, which is set
    to `0`. This means that the color of the first node is automatically set to the
    first color (for example, red). The other auxiliary array (`available`) stores
    information about the availability of particular colors.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 方法使用两个与节点相关的辅助数组。第一个名为 `colors`，存储为特定节点选择的颜色索引。默认情况下，所有元素值设置为 `-1`，除了第一个，它被设置为
    `0`。这意味着第一个节点的颜色将自动设置为第一种颜色（例如，红色）。另一个辅助数组（`available`）存储有关特定颜色可用性的信息。'
- en: The most crucial part of the code is the `for` loop. Within it, you reset the
    availability of colors by setting `true` as the value of all elements within the
    `available` array. Then, you iterate through the neighbor nodes of the current
    node to read their colors and mark such colors as unavailable by setting `false`
    as a value of a particular element in the `available` array. Then, you find the
    first available color for the current node and use it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最关键的部分是 `for` 循环。在这个循环中，你通过将 `available` 数组中所有元素的值设置为 `true` 来重置颜色的可用性。然后，你遍历当前节点的邻居节点，读取它们的颜色，并通过将
    `available` 数组中特定元素的值设置为 `false` 来标记这些颜色为不可用。然后，你找到当前节点的第一个可用颜色并使用它。
- en: 'Let’s take a look at the usage of the `Color` method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Color` 方法的用法：
- en: '[PRE39]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, you create a new undirected and unweighted graph, the same as shown in
    the preceding figure, on the left. Then, you add nodes and edges, as well as call
    the `Color` method to perform the node coloring. As a result, you receive an array
    with indices of colors for particular nodes. Then, you present the results in
    the console:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个新的无向无权图，与前面图中的左侧相同。然后，你添加节点和边，以及调用 `Color` 方法进行节点着色。结果，你得到一个包含特定节点颜色索引的数组。然后，你在控制台中展示结果：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this short introduction, you are ready to proceed to the real-world application,
    namely for coloring the voivodeship map.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的介绍，你就可以继续进行实际应用了，即着色省份地图。
- en: Example – voivodeship map
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 省份地图
- en: Let’s create a program that represents the map of voivodeships in Poland as
    a graph, and color such areas so that two voivodeships with common borders aren’t
    the same color. Of course, you should try to limit the number of colors.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个程序，将波兰的省地图表示为图，并着色这些区域，使得相邻省份的颜色不同。当然，你应该尽量限制颜色的数量。
- en: To start, let’s think about the graph’s representation. Here, nodes represent
    particular voivodeships, while edges represent common borders between voivodeships.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下图的表示。在这里，节点代表特定的地区，而边代表地区之间的共同边界。
- en: 'The map of Poland with the graph already colored is shown in the following
    diagram:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了已经着色的波兰地图：
- en: '![Figure 8.22 – Illustration of the voivodeship map example](img/B18069_08_22.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 地区地图示例的说明](img/B18069_08_22.jpg)'
- en: Figure 8.22 – Illustration of the voivodeship map example
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 地区地图示例的说明
- en: 'Your task is just to color nodes in the graph using the previously described
    algorithm. To do so, you create an undirected and unweighted graph, add nodes
    representing voivodeships, and add edges to indicate common borders. The code
    is as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务只是使用之前描述的算法在图中着色节点。为此，你创建一个无向无权图，添加代表地区的节点，并添加边来表示共同边界。代码如下：
- en: '[PRE41]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, the `Color` method is called on the `Graph` instance and the color indices
    for particular nodes are returned. Finally, you present the results in the console.
    The suitable part of the code is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Graph`实例上调用`Color`方法，并返回特定节点的颜色索引。最后，你在控制台中展示结果。合适的代码部分如下：
- en: '[PRE42]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The results are as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE43]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You just learned how to color nodes in a graph! However, this is not the end
    of the interesting topics regarding graphs that will be presented in this book.
    Next, we’ll search for the shortest path in the graph.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何在图中着色节点！然而，这并不是本书中关于图的有意思话题的结束。接下来，我们将搜索图中的最短路径。
- en: Shortest path
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径
- en: A graph is a great data structure for storing data of various maps, such as
    cities and the distances between them. For this reason, one of the obvious real-world
    applications of graphs is **searching for the** **shortest path** **between two
    nodes, which takes into account a specific cost**, such as the distance, the necessary
    time, or even the amount of fuel required.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一种存储各种地图数据（如城市及其之间的距离）的绝佳数据结构。因此，图的一个明显的实际应用是**在两个节点之间搜索** **最短路径** **，考虑到特定的成本**，例如距离、所需时间，甚至所需的燃油量。
- en: There are several approaches to the topic of searching for the shortest path
    in a graph. However, one of the common solutions is **Dijkstra’s algorithm**,
    which makes it possible to **calculate the distance from a starting node to all
    nodes located in the graph**. Then, you can easily get not only the cost of the
    connection between two nodes but also find nodes that are between the start and
    end nodes.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中搜索最短路径的方法有很多。然而，一个常见的解决方案是**Dijkstra算法**，它使得**计算从起始节点到图中所有节点的距离**成为可能。然后，你可以轻松地得到两个节点之间的连接成本，还可以找到位于起始节点和结束节点之间的节点。
- en: 'Dijkstra’s algorithm uses two auxiliary node-related arrays:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法使用两个与节点相关的辅助数组：
- en: One for storing an identifier of the previous node, which is the node from which
    the current node can be reached with the smallest overall cost
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于存储前一个节点的标识符，即当前节点可以通过最小的总成本到达的节点
- en: One for storing the minimum distance (cost), which is necessary for accessing
    the current node
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于存储最小距离（成本），这对于访问当前节点是必要的
- en: What’s more, it uses the queue for storing nodes that should be checked. **During
    the consecutive iterations, the algorithm updates the minimum distances to particular
    nodes in the graph**. Finally, the auxiliary arrays contain the minimum distance
    (cost) to reach all the nodes from the chosen starting node, as well as information
    on how to reach each node using the shortest path.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，它使用队列来存储应该检查的节点。**在连续迭代过程中，算法更新图中特定节点的最小距离**。最后，辅助数组包含从所选起始节点到达所有节点的最小距离（成本），以及如何使用最短路径到达每个节点的信息。
- en: Where can you find more information?
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: You can find a lot of content about Dijkstra’s algorithm on the internet. Just
    search for its name and you will see a huge number of results. As an example,
    you can find useful content related to the implementation presented in this chapter
    at [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在互联网上找到大量关于Dijkstra算法的内容。只需搜索其名称，你将看到大量的结果。例如，你可以在本章中找到有关实现的有用内容，链接为[https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)。
- en: 'Let’s take a look at the following diagram, which presents two various shortest
    paths that have been found using Dijkstra’s algorithm. The left-hand side shows
    the path from node **8** to **1**, while the right-hand side shows the path from
    node **1** to **7**:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表，它展示了使用Dijkstra算法找到的两个不同最短路径。左侧显示从节点**8**到**1**的路径，而右侧显示从节点**1**到**7**的路径：
- en: '![Figure 8.23 – Illustration of the shortest paths in a graph](img/B18069_08_23.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23 – 图中路径的最短路径示意图](img/B18069_08_23.jpg)'
- en: Figure 8.23 – Illustration of the shortest paths in a graph
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 图中路径的最短路径示意图
- en: 'It is high time that you see some C# code that can be used to implement Dijkstra’s
    algorithm. The main role is performed by the `GetShortestPath` method, which should
    be added to the `Graph` class. The code is as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看一些可以用来实现Dijkstra算法的C#代码了。`GetShortestPath`方法扮演主要角色，应该添加到`Graph`类中。代码如下：
- en: '[PRE44]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `GetShortestPath` method takes two parameters, namely `source` and `target`
    nodes. First, it creates two node-related auxiliary arrays for storing the indices
    of previous nodes, from which the given node can be reached with the smallest
    overall cost (`previous`), as well as for storing the current minimum distances
    to the given node (`distances`). By default, the values of all elements in the
    `previous` array are set to `-1`, while in the `distances` array, they are set
    to the maximum value of the `int` type. Of course, the distance to the source
    node is set to `0`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetShortestPath`方法接受两个参数，即`source`和`target`节点。首先，它创建两个与节点相关的辅助数组，用于存储从给定节点可以到达的前一个节点的索引，这些索引具有最小的整体成本（`previous`），以及用于存储到给定节点的当前最小距离（`distances`）。默认情况下，`previous`数组中所有元素的值设置为`-1`，而在`distances`数组中，它们设置为`int`类型的最大值。当然，源节点的距离设置为`0`。'
- en: Then, you create a new priority queue and enqueue the data of all nodes. The
    priority of each element is equal to the current distance to such a node. Here,
    you use the same implementation of a priority queue, as presented in [*Chapter
    5*](B18069_05.xhtml#_idTextAnchor165), *Stacks and Queues*, namely from the `OptimizedPriorityQueue`
    NuGet package.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建一个新的优先队列并将所有节点的数据入队。每个元素优先级等于到该节点的当前距离。在这里，你使用与[*第5章*](B18069_05.xhtml#_idTextAnchor165)中介绍的相同的优先队列实现，即来自`OptimizedPriorityQueue`
    NuGet包。
- en: The most interesting part of the code is the `while` loop, which is executed
    until the queue is empty. Within this `while` loop, you get the first node from
    the queue and iterate through all of its neighbors using a `for` loop. Inside
    such a loop, you calculate the distance to a neighbor by taking the sum of the
    distance to the current node and the weight of the edge. If the calculated distance
    is smaller than the currently stored value, you update the values regarding the
    minimum distance to the given neighbor, as well as the index of the previous node,
    from which you can reach the neighbor. It’s worth noting that the priority of
    the element in the queue should be updated as well.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分是`while`循环，它一直执行到队列变为空。在这个`while`循环中，你从队列中获取第一个节点，并使用`for`循环遍历其所有邻居。在这样一个循环中，你通过将当前节点的距离和边的权重相加来计算到邻居的距离。如果计算出的距离小于当前存储的值，你将更新有关给定邻居的最小距离以及可以到达邻居的前一个节点索引的值。值得注意的是，队列中元素的优先级也应该更新。
- en: The remaining operations are used to resolve the path using the values stored
    in the `previous` array. To do so, you save the indices of the following nodes
    in the `indices` list. Then, you reverse it to achieve the order from the source
    node to the target one. Finally, you create the list of edges to present the result
    in a form that’s suitable for returning from the method.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的操作用于使用存储在`previous`数组中的值来解析路径。为此，你将后续节点的索引保存到`indices`列表中。然后，你将其反转以实现从源节点到目标节点的顺序。最后，你创建一个边列表，以便以适合从方法返回的形式呈现结果。
- en: 'Let’s take a look at the usage of the `GetShortestPath` method:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`GetShortestPath`方法的用法：
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, you create a new directed and weighted graph, as well as add nodes and
    edges. The missing parts of the code are the same as in the case of the *directed
    and weighted edges* example. Then, you call the `GetShortestPath` method to search
    for the shortest path between nodes `1` and `5`. As a result, you receive a list
    of edges forming the shortest path. Then, you just iterate through all the edges
    and present the results in the console:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建一个新的有向加权图，并添加节点和边。代码中缺失的部分与*有向加权边*示例中的相同。然后，你调用`GetShortestPath`方法来搜索节点`1`和`5`之间的最短路径。结果，你将收到形成最短路径的边的列表。然后，你只需遍历所有边，并在控制台显示结果：
- en: '[PRE46]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this short introduction, together with a simple example, let’s proceed
    to a more advanced and interesting application related to game development.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍和简单示例的基础上，让我们继续探讨与游戏开发相关的高级和有趣的应用。
- en: Example – path in game
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 游戏中的路径
- en: The last example we’ll cover in this chapter involves the application of Dijkstra’s
    algorithm to find the shortest path in a game map. Let’s imagine that you have
    a board with various obstacles. For this reason, the player can use only part
    of the board to move. Your task is to find the shortest path between two places
    located on the board.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的最后一个示例涉及将Dijkstra算法应用于在游戏地图中找到最短路径。让我们想象你有一个带有各种障碍物的棋盘。因此，玩家只能使用棋盘的一部分来移动。你的任务是找到棋盘上两个位置之间的最短路径。
- en: 'To start, let’s represent the board as a jagged array. The suitable part of
    the code is shown here:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将棋盘表示为一个交错数组。合适的代码部分如下所示：
- en: '[PRE47]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To improve the readability of code, the map is represented as an array of `string`
    values. Each row is presented as text, with the number of characters equal to
    the number of columns. The value of each character indicates the availability
    of the point. If it is equal to `0`, the position is available. Otherwise, it
    is not. The `string`-based map representation should then be converted into the
    Boolean jagged array. Such a task is performed by a few lines of code, as shown
    in the preceding snippet.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高代码的可读性，地图被表示为一个`string`值数组。每一行都作为文本呈现，字符数等于列数。每个字符的值表示点的可用性。如果等于`0`，则位置可用。否则，不可用。基于`string`的地图表示应然后转换为布尔交错数组。这项任务通过前面片段中显示的几行代码完成。
- en: 'The next step is to create the graph, as well as add the necessary nodes and
    edges. The suitable part of the code is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建图，并添加必要的节点和边。合适的代码部分如下：
- en: '[PRE48]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, you initialize a new undirected and weighted graph. Then, you use two
    `for` loops to iterate through all the places on the board. Within such loops,
    you check whether the given place is available. If so, you create a new node (`from`).
    Then, you check whether the node placed immediately above the current one is also
    available. If so, a suitable edge is added with a weight equal to `1`. Similarly,
    you can check whether the node placed on the left of the current one is available
    and add an edge if necessary.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个新的无向加权图。然后，你使用两个`for`循环遍历棋盘上的所有位置。在循环中，你检查给定位置是否可用。如果是，你创建一个新的节点（`from`）。然后，你检查当前节点正上方的节点是否也可用。如果是，添加一个合适的边，权重等于`1`。同样，你也可以检查当前节点左侧的节点是否可用，并在必要时添加边。
- en: 'Now, you just need to get the `Node` instances representing the source and
    the target nodes. You can do so by using the `Find` method and providing the textual
    representation of the node – for example, `0-0` or `16-24`. Then, you call the
    `GetShortestPath` method. In this case, the algorithm will try to find the shortest
    path between the node in the first row and column and the node in the last row
    and column. The code is presented in the following block:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要获取表示源节点和目标节点的`Node`实例。你可以通过使用`Find`方法并提供节点的文本表示来实现这一点——例如，`0-0`或`16-24`。然后，你调用`GetShortestPath`方法。在这种情况下，算法将尝试找到第一行第一列的节点和最后一行最后一列的节点之间的最短路径。代码如下所示：
- en: '[PRE49]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last part of the code is related to presenting the map in the console:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分与在控制台显示地图有关：
- en: '[PRE50]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To start, you set the proper encoding in the console to be able to present Unicode
    characters as well. Then, you use two `for` loops to iterate through all the places
    on the board. Inside such loops, you choose a color that should be used to represent
    a point in the console, either green (the point is available) or red (unavailable).
    If the currently-analyzed point is a part of the shortest path, the white color
    is set. Finally, you write the Unicode character representing a bullet. When the
    program’s execution exits both loops, the console’s color is reset.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在控制台中设置适当的编码，以便能够以Unicode字符的形式显示。然后，你使用两个`for`循环遍历棋盘上的所有位置。在这些循环内部，你选择一个颜色来表示控制台中的点，绿色（点可用）或红色（不可用）。如果当前分析的点是最短路径的一部分，则设置白色。最后，你写入表示点的Unicode字符。当程序执行退出这两个循环时，控制台的颜色被重置。
- en: 'When you run the application, you will see the following result:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会看到以下结果：
- en: "![Figure 8.24 –\uFEFF \uFEFFScreenshot of the game map example](img/B18069_08_24.jpg)"
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – 游戏地图示例的截图](img/B18069_08_24.jpg)'
- en: Figure 8.24 – Screenshot of the game map example
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 游戏地图示例的截图
- en: Great work! Now, let’s summarize the topics that were covered in this chapter.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在，让我们总结本章中涵盖的主题。
- en: Summary
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was related to one of the most important data structures available
    while developing applications: graphs. As you learned, a **graph** is a data structure
    that consists of **nodes** and **edges**. Each edge connects two nodes. What’s
    more, there are various variants of edges, such as undirected and directed, as
    well as unweighted and weighted. All of them were described and explained in detail,
    and illustrations and code examples were provided. Two methods of graph representation,
    namely using an **adjacency list** and an **adjacency matrix**, were explained
    as well. You also learned how to implement a graph in the C# language.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与开发应用程序时可用的重要数据结构之一相关：图。正如你所学的，**图**是一种由**节点**和**边**组成的数据结构。每条边连接两个节点。更重要的是，还有各种边的变体，如无向和有向，以及无权和加权。所有这些都被详细描述和解释，并提供了插图和代码示例。还解释了两种图表示方法，即使用**邻接表**和**邻接矩阵**。你还学习了如何在C#语言中实现图。
- en: While talking about graphs, it’s important to present some **real-world applications**,
    especially due to the common use of such a data structure. For example, this chapter
    explained the structure of friends that are available on social media or the problem
    of searching for the shortest path in a city.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论图时，展示一些**实际应用**是很重要的，尤其是在这种数据结构被广泛使用的情况下。例如，本章解释了社交媒体上可用的朋友结构或在城市中搜索最短路径的问题。
- en: Among the topics that were covered in this chapter, you learned how to traverse
    a graph to visit all of the nodes in some particular order. Two approaches were
    presented, namely **DFS** and **BFS**. It’s worth mentioning that the traversal
    topic can be also applied to searching for a given node in a graph.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章涵盖的主题中，你学习了如何遍历图以以某种特定顺序访问所有节点。介绍了两种方法，即**深度优先搜索（DFS**）和**广度优先搜索（BFS**）。值得一提的是，遍历主题也可以应用于在图中搜索给定节点。 '
- en: Next, the subject of **spanning trees**, as well as **minimum spanning trees**,
    was introduced. As a reminder, a spanning tree is a subset of edges that connects
    all nodes in a graph without cycles, while an MST is a spanning tree with the
    minimum cost from all spanning trees available in the graph. There are a few approaches
    to finding the MST, including **Kruskal’s** and **Prim’s algorithms**.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，介绍了**生成树**的主题，以及**最小生成树**。作为提醒，生成树是图中所有节点之间无环连接的边的子集，而最小生成树（MST）是从图中所有生成树中选择成本最低的生成树。寻找MST的方法有几种，包括**克鲁斯卡尔算法**和**普里姆算法**。
- en: Then, you learned how to solve the problem of **coloring**, where you assigned
    colors (numbers) to all the nodes to comply with the rule that there cannot be
    an edge between two nodes with the same color.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何解决**着色**问题，其中你为所有节点分配颜色（数字），以符合规则：两个节点之间不能有相同颜色的边。
- en: The other problem was searching for the **shortest path between two nodes**,
    which takes into account a specific cost, such as the distance, the necessary
    time, or even the amount of fuel required. There are several approaches to the
    topic of searching for the shortest path in a graph. However, one of the common
    solutions is **Dijkstra’s algorithm**, which makes it possible to calculate the
    distance from a starting node to all the nodes located in the graph. We covered
    this in detail in this chapter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在两个节点之间寻找**最短路径**，这需要考虑特定的成本，例如距离、所需时间，甚至所需的燃油量。在图论中，寻找最短路径有几种不同的方法。然而，其中一种常见的解决方案是**迪杰斯特拉算法**，它使得从起始节点到图中所有节点的距离计算成为可能。我们在这章中对此进行了详细的介绍。
- en: Now, it is high time to proceed to the next chapter, which focuses on **practical
    aspects of algorithms** from various groups, including recursive, greedy, back-tracking,
    and even genetic. Let’s turn the page and see them in action!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进入下一章了，这一章将重点介绍来自各种组别，包括递归、贪婪、回溯，甚至遗传算法的**算法的实际应用方面**。让我们翻到下一页，看看它们是如何发挥作用的！
- en: '[PRE51]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
