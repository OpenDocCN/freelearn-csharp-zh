- en: Understanding Classes, Structures, and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类、结构体和接口
- en: In [Chapter 1](ccec4122-6067-4279-843b-6123b1eff017.xhtml), *Learning the Basics
    of C#*, we looked at an overview of the very basic components of a C# application.
    All classes in a C# application are composed of attributes and methods. Using
    namespaces and assemblies, we can bundle related classes together.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ccec4122-6067-4279-843b-6123b1eff017.xhtml)“学习C#基础知识”中，我们查看了一个C#应用程序非常基本组件的概述。C#应用程序中的所有类都由属性和方法组成。使用命名空间和程序集，我们可以将相关的类捆绑在一起。
- en: To maintain structure and to reduce complexity, it's essential that only the
    required classes/functionality are exposed outside the scope of a class. In a
    C# program, this is achieved via access modifiers. While defining the attributes
    present in a class, we also need to be clear about the different data types of
    variables available in C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持结构并减少复杂性，确保只暴露必要的类/功能在类的作用域之外是至关重要的。在C#程序中，这是通过访问修饰符实现的。在定义类中的属性时，我们还需要清楚C#中可用的不同变量数据类型。
- en: Using a code implementation of struct and class, we will look at how data and
    reference type variables differ in implementation and behavior during program
    execution. We will also be looking at some good practices that we can follow to
    choose the right data type for our variables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对结构体和类的代码实现进行使用，我们将探讨在程序执行期间数据类型和引用类型变量在实现和行为上的差异。我们还将探讨一些良好的实践，以便为我们的变量选择正确的数据类型。
- en: We will then look at interfaces and inheritance and how they are implemented
    in a C# application. Using examples, we will look at the different scenarios in
    which we should use each of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将探讨接口和继承，以及它们在C#应用程序中的实现方式。通过示例，我们将探讨在不同场景下应该使用它们的各种情况。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Different types of access modifiers in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中的不同访问修饰符类型
- en: Different types of data types in C#
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中的不同数据类型
- en: Understanding the difference between a class and a struct
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类与结构体的区别
- en: Understanding inheritance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承
- en: Understanding interfaces and how they are different from inheritance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解接口及其与继承的不同之处
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapters of this book, the programs explained in this chapter
    will be developed in Visual Studio 2017.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的前几章一样，本章中解释的程序将在Visual Studio 2017中开发。
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples)。
- en: Access modifiers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: All classes, along with their respective attributes and functions, have an access
    modifier associated with them. An access modifier basically indicates how the
    respective element will be accessed in the application, both in its own assembly
    as well as in other assemblies. Collectively, attributes and functions in an application
    are referred to as class members.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类，包括它们各自的属性和函数，都与一个访问修饰符相关联。访问修饰符基本上指示了相应元素在应用程序中的访问方式，包括其自身的程序集以及其他程序集。在应用程序中，属性和函数统称为类成员。
- en: 'In C#, a class and its class members can acquire the following access modifiers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，类及其类成员可以采用以下访问修饰符：
- en: '**Public**: A class or a class member declared as *public* can be accessed
    by all classes in the same assembly as well as by classes in different assemblies
    present in the application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：声明为*公共*的类或类成员可以被同一程序集内的所有类以及应用程序中不同程序集的类访问。'
- en: '**Private**: A class member declared as *private* can be accessed only in the
    same class but not outside it.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：声明为*私有*的类成员只能在同一类中访问，不能在类外访问。'
- en: '**Protected**: A class or a class member declared as *protected* can be accessed
    inside the class or by classes that inherit from the respective class.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护**：声明为*受保护*的类或类成员可以在类内部或由继承自该类的类访问。'
- en: '**Internal**: A class or a class member declared as *internal* can only be
    accessed by classes in the same assembly but not by outside assemblies.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：声明为*内部*的类或类成员只能被同一程序集内的类访问，但不能被外部程序集访问。'
- en: '**Protected internal**: A class or a class member declared as *protected* *internal*
    can only be accessed by classes in the same assembly or by classes present in
    the outside assembly that inherit from the respective class.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的内部（Protected internal）**: 声明为 *protected* *internal* 的类或类成员只能被同一程序集中的类或在外部程序集中继承自相应类的类访问。'
- en: '**Private protected**: A class or a class member declared as *private protected*
    can only be accessed in the same class or in classes present in the same assembly
    that inherit from the respective class.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有受保护的（Private protected）**: 声明为 *private protected* 的类或类成员只能在同一类或同一程序集中继承自相应类的类中访问。'
- en: 'Let''s look at the following image to summarize this knowledge about access
    modifiers. In the following example, we have **Assembly A** and **Assembly B**
    in the application. **Assembly A** has **Class A**, which has different functions,
    each with a separate access modifier. Please refer to the comments against each
    of the functions to understand which classes under which assemblies can access
    the respective functions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图片来总结关于访问修饰符的知识。在以下示例中，我们在应用程序中有 **Assembly A** 和 **Assembly B**。**Assembly
    A** 中有 **Class A**，它有不同的函数，每个函数都有一个单独的访问修饰符。请参考每个函数旁边的注释，了解哪些类在哪些程序集下可以访问相应的函数：
- en: '![](img/57e02d6a-4e22-4590-83e2-cfad46d9ca71.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57e02d6a-4e22-4590-83e2-cfad46d9ca71.png)'
- en: Based upon the accessibility level and the security that we wish to embed in
    the different class members, we can choose either of the previously mentioned
    access modifiers. To keep some structure and avoid introducing undue complexity,
    it's advisable to only expose class members to classes that require some information
    to be shared with the respective class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们希望嵌入的不同类成员的可访问级别和安全级别，我们可以选择之前提到的任何访问修饰符。为了保持一些结构并避免引入不必要的复杂性，建议只将类成员暴露给需要与相应类共享一些信息的类。
- en: In the next section, we will look at the different data types that a class member
    can acquire.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨类成员可以获取的不同数据类型。
- en: Data types in C#
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的数据类型
- en: 'In C#, a variable can acquire one of the following types:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，一个变量可以获取以下类型之一：
- en: A value type
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型
- en: A reference type
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: C# differentiates between these two types in terms of how these values are saved
    and maintained in the **Global Assembly Cache** (**GAC**) during the program execution.
    Value type variables are saved in the stack, while reference type variables are
    saved in a managed heap data structure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C# 在程序执行期间根据这些值在 **全局程序集缓存**（**GAC**）中的保存和维护方式来区分这两种类型。值类型变量保存在堆栈中，而引用类型变量保存在一个托管堆数据结构中。
- en: There are other **pointer types** that allow us to access value in the memory
    location of a variable. In [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml),
    *Creating and Using of Types in C#*, we will explore those data types in detail.
    For now, let's look at these two data types and explore them in detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他 **指针类型** 允许我们访问变量的内存位置中的值。在 [第 8 章](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml)，*C#
    中类型创建和使用*，我们将详细探讨这些数据类型。现在，让我们看看这两种数据类型，并详细探讨它们。
- en: Value type variables
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型变量
- en: In value types, the variables contain the data or the contents of the variable.
    This implies that if any change is made to a value type variable in a different
    scope of the program, the change will not be reflected back once the control shifts
    to the calling function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在值类型中，变量包含数据或变量的内容。这意味着如果对程序的不同作用域中的值类型变量进行了更改，则更改将不会在控制权转移到调用函数时反映回来。
- en: The following are the different types of value types in C#.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 C# 中的不同值类型。
- en: Simple types
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单类型
- en: 'Following is the list of simple types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一系列简单类型：
- en: '`Int`: For example 1, 2, 4, and -100\. They can be both signed and unsigned.
    A signed `int` type can be both positive and negative. An unsigned `int` type
    cannot be negative; its minimum value is `0`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`: 例如 1, 2, 4 和 -100。它们可以是带符号的也可以是无符号的。带符号的 `int` 类型可以是正数也可以是负数。无符号的 `int`
    类型不能是负数；它的最小值是 `0`。'
- en: '`Float`: For example, 3.14.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float`: 例如，3.14。'
- en: '`Long`: Unlike `Int`, which is 32-bit, `Long` is a 64-bit integer value. It
    can also be both signed and unsigned.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Long`: 与 32 位的 `Int` 不同，`Long` 是 64 位整数值。它也可以是带符号的或无符号的。'
- en: '`Decimal`: Like `Float`, decimal data types also represent decimal digit numbers
    with the main difference being in terms of precision. For `Float` data members,
    the precision is 7; however, in the case of decimal data types, the precision
    is 28 digits.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decimal`: 与 `Float` 类似，十进制数据类型也代表十进制数字，主要区别在于精度。对于 `Float` 数据成员，精度为 7；然而，在十进制数据类型的情况下，精度为
    28 位数字。'
- en: '`Char`: Represents a single character sequence. It can acquire values such
    as `C`, `c`, or white-space, any special characters – such as % and # – and even
    a digit such as 1.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Char`: 表示单个字符序列。它可以获取诸如 `C`、`c` 或空白字符，任何特殊字符（如 % 和 #）以及数字（如 1）等值。'
- en: '`bool`: It can be used to represent variables that acquire a digital value
    such as true or false.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`: 可以用来表示获取数字值（如真或假）的变量。'
- en: Enum types
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Enum types are used to indicate an attribute that can acquire a constant set
    of values, for example, `enum Day {Sat, Sun, Mon, Tues, Wed, Thurs, Fri}`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型用于表示可以获取一组常量值的属性，例如，`enum Day {Sat, Sun, Mon, Tues, Wed, Thurs, Fri}`。
- en: 'By default, the value of the first enumerator in the declaration starts from
    0\. It then increments the value of the subsequent enumerators by 1\. For the
    preceding example, the following would be the value of the enumerators:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，声明中第一个枚举值的值从 0 开始。然后，它将后续枚举值的值增加 1。对于前面的例子，枚举值的值如下：
- en: '`Sat` – 0'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sat` – 0'
- en: '`Sun` – 1'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sun` – 1'
- en: '`Mon` – 2'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mon` – 2'
- en: '`Tues` – 3'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tues` – 3'
- en: '`Wed` – 4'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wed` – 4'
- en: '`Thurs` – 5'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thurs` – 5'
- en: '`Fri` - 6'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fri` - 6'
- en: 'We can also override the default values of the enumerators by explicitly defining
    the values in the declaration itself. For example, in the preceding example, if
    we do not want the enumerators to start from 0, we can use the following declaration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在声明本身中显式定义值来覆盖枚举的默认值。例如，在前面的例子中，如果我们不希望枚举值从 0 开始，我们可以使用以下声明：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the preceding declaration, the enumerators will acquire the following values:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的声明，枚举值将获取以下值：
- en: '`Sat` – 1'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sat` – 1'
- en: '`Sun` – 2'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sun` – 2'
- en: '`Mon` – 3'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mon` – 3'
- en: '`Tues` – 4'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tues` – 4'
- en: '`Wed` – 5'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wed` – 5'
- en: '`Thurs` – 6'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thurs` – 6'
- en: '`Fri` – 7'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fri` – 7'
- en: 'Each Enumerator attribute also has an underlying data type that, by default,
    is of type `Int`. If required, we can also change the type of the enumerated values
    to long or short. However, it cannot take `char` as an underlying data type. Refer
    to the following `enum` declaration, in which we are setting the type of Enumerator
    value to `short`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举属性都有一个底层数据类型，默认情况下是 `Int` 类型。如果需要，我们还可以将枚举值的类型更改为长或短。然而，它不能将 `char` 作为底层数据类型。参考以下
    `enum` 声明，其中我们将枚举值类型设置为 `short`：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Struct types
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体类型
- en: 'Just like classes, structs in C# can be used to group together related data.
    Like classes, they can have constructors, fields, and methods. However, there
    are some differences between the implementation of structs and classes. The following
    are some of the key differences:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类一样，C# 中的结构体可以用来将相关数据组合在一起。像类一样，它们可以有构造函数、字段和方法。然而，结构体和类的实现之间有一些区别。以下是一些关键区别：
- en: '| **Feature** | **Struct** | **Class** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **结构体** | **类** |'
- en: '| Type | Structs are managed as value type variables. This implies that the
    value assigned in their objects is not persisted in different scopes of the program.
    | Classes are managed as reference type variables. This implies that the value
    assigned in their objects is persisted across different scopes of the program.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 结构体作为值类型变量进行管理。这意味着分配给它们的对象值不会在不同的程序作用域中持久化。 | 类作为引用类型变量进行管理。这意味着分配给它们的对象值将在不同的程序作用域中持久化。
    |'
- en: '| Constructor | Unlike classes, no default constructor is managed by C#. When
    we go through [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml), *Creating
    and Using of Types in C#*, we will explore default constructors in detail. | When
    declaring a class, if no constructor is specified for the class, C# automatically
    creates a default constructor for the class. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 与类不同，C# 不管理默认构造函数。当我们进入 [第 8 章](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml)，*在
    C# 中创建和使用类型*，我们将详细探讨默认构造函数。 | 当声明一个类时，如果没有为类指定构造函数，C# 会自动为该类创建一个默认构造函数。 |'
- en: '| Inheritance | A struct cannot inherit from another struct. This implies that
    code reuse could become a challenge if we use structs. | A class can inherit from
    other classes. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 继承 | 结构体不能从另一个结构体继承。这意味着如果我们使用结构体，代码重用可能会成为一个挑战。 | 类可以从其他类继承。 |'
- en: Being value type variables, when a struct object is created, the entire object
    – inclusive of attributes, methods, and so on – is saved in a stack. Therefore,
    from a performance perspective, it's essential that structs should only be used
    for creating lightweight objects with only a few members.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为值类型变量，当创建一个结构体对象时，整个对象——包括属性、方法等——都会保存在栈中。因此，从性能角度来看，结构体应该仅用于创建只有少数成员的轻量级对象。
- en: In the coming section, we will go through a code example to show how struct
    implementation is different from a similar implementation in classes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过一个代码示例来展示结构体实现与类中类似实现的区别。
- en: Reference type variables
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型变量
- en: In reference type variables, the data member contains the exact address of the
    variable in memory. As the variable just contains a reference to the memory address,
    two separate reference type variables can point to the same memory address. Therefore,
    if a change is made to a reference type variable, the change is directly done
    at the memory location of the variable. Due to the change being directly made
    at the memory location of the variable, both variables will reflect the updated
    value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型变量中，数据成员包含变量在内存中的确切地址。由于变量仅包含对内存地址的引用，两个独立的引用类型变量可以指向同一个内存地址。因此，如果对引用类型变量进行修改，修改将直接在变量的内存位置上进行。由于修改是直接在变量的内存位置上进行的，两个变量都将反映更新后的值。
- en: 'The following are the reference types available in C#:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在C#中可用的引用类型：
- en: '**Class**: As discussed in [Chapter 1](ccec4122-6067-4279-843b-6123b1eff017.xhtml),
    *Learning the* *Basics of C#*, a class represents a collection of related properties
    and methods.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**: 如在[第一章](ccec4122-6067-4279-843b-6123b1eff017.xhtml)中讨论的，*学习C#的基础知识*，类代表一组相关的属性和方法。'
- en: '**Interface**: An interface in C# represents a collection of related properties,
    events, and methods, with just a declaration and no definition. In this chapter,
    in upcoming sections, we will deep dive into interfaces and see how they are implemented
    in C#.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**: 在C#中，接口代表一组相关的属性、事件和方法，它只包含声明而没有定义。在本章的后续部分，我们将深入探讨接口，并了解它们在C#中的实现方式。'
- en: '**Dynamic**: A dynamic type variable avoids compile-time type checking. For
    example, if we declare a dynamics variable type and assign a variable to it, its
    type is defined at runtime when a value is assigned to it.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态类型**: 动态类型变量避免了编译时的类型检查。例如，如果我们声明一个动态变量类型并将其分配给一个变量，那么它的类型将在运行时分配值时定义。'
- en: 'For example, in the following code snippet, we are creating a dynamics type
    variable, assigning different variables to it and evaluating its type at runtime:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码片段中，我们创建了一个动态类型变量，将其分配给不同的变量，并在运行时评估其类型：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Object**: When a new instance of a class is created using the `new` keyword,
    an object for the class is created in the memory.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**: 当使用`new`关键字创建类的新的实例时，在内存中为该类创建一个对象。'
- en: '**String**: A `String` object is a sequence of `Char` objects whose value is
    immutable or read-only. This basically implies that, when we modify a variable
    of type `String`, it creates a new object in memory.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**: `String`对象是一系列`Char`对象的序列，其值是不可变的或只读的。这基本上意味着，当我们修改类型为`String`的变量时，它会在内存中创建一个新的对象。'
- en: In the next section, we will go through a code example to show how a reference
    type variable such as `Class` and a value type variable such as struct are implemented
    in C# and how their behavior differs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过一个代码示例来展示如何在C#中实现引用类型变量（如`Class`）和值类型变量（如结构体），以及它们的行为差异。
- en: Structs versus classes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体与类
- en: 'In the first chapter, we created a basic `Hello World` program. In this topic,
    we will extend that program and use it to implement a struct and a class. While
    doing so, we will analyze the difference between the implementation and use of
    reference and value type variables. As you are already aware by now, a struct
    is a value type variable and a class is a reference type variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们创建了一个基本的`Hello World`程序。在本主题中，我们将扩展该程序并使用它来实现结构体和类。在这样做的时候，我们将分析引用类型变量和值类型变量的实现和使用之间的差异。如您所知，结构体是一个值类型变量，而类是一个引用类型变量：
- en: 'Open the `Console` project created in [Chapter 1,](ccec4122-6067-4279-843b-6123b1eff017.xhtml)
    *Learning the Basic Structure of C#*, and declare a `CoordinatePoint` class with
    just two member attributes of `x` and `y` coordinates. Also create two constructors
    – one without any parameters and one with two parameters. Please refer to the
    following code implementation for this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开在 [第 1 章](ccec4122-6067-4279-843b-6123b1eff017.xhtml)，*学习 C# 基本结构* 中创建的 `Console`
    项目，并声明一个具有 `x` 和 `y` 坐标两个成员属性的 `CoordinatePoint` 类。同时创建两个构造函数——一个不带参数，一个带两个参数。请参考以下代码实现：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please note that, in the preceding code, the use of the `this` variable is optional.
    It is used to refer to the current instance of the class and can be used to differentiate
    between class members and method parameters if they have the same name.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前述代码中，使用 `this` 变量是可选的。它用于引用类的当前实例，并且可以在类成员和方法参数具有相同名称时用于区分它们。
- en: 'Declare a similar structure. Notice that the compiler gives an error for the
    default constructor:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个类似的结构体。注意，编译器会为默认构造函数报错：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As indicated in the preceding code, we will see a red label on the `struct`
    constructor. This is because, unlike classes, a struct cannot have an implementation
    of a default constructor. To remove the error, we need to remove the default constructor.
    On doing this, we will see that the compiler error goes away. The following would
    be the correct implementation of the struct:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们将在 `struct` 构造函数上看到一个红色标签。这是因为，与类不同，结构体不能有默认构造函数的实现。为了消除错误，我们需要删除默认构造函数。这样做之后，编译器错误就会消失。以下将是结构体的正确实现：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `Main` class, we will now declare two functions, one for each class
    and struct, respectively. In both functions, we will be passing a parameter by
    the name of `obj`, which is an object of type class and struct, respectively.
    In the same function, we will change the values of the `x` and `y` coordinate
    variables in both the struct and the class to a default value of `0.5F`. The following
    is the code implementation for this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 类中，我们现在将声明两个函数，分别对应于每个类和结构体。在这两个函数中，我们将通过名为 `obj` 的参数传递一个对象，该对象分别属于
    `class` 和 `struct` 类型。在同一个函数中，我们将结构体和类中的 `x` 和 `y` 坐标变量值更改为默认值 `0.5F`。以下是该代码实现：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, in the main function, declare the objects of both the class and the structure.
    Notice that, during the declaration of the respective objects, we are specifying
    the same values in the `xCoordinate` and `yCoordinate` member attributes.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主函数中，声明类和结构体的对象。注意，在声明各自的对象时，我们在 `xCoordinate` 和 `yCoordinate` 成员属性中指定了相同的值。
- en: 'For the sake of explanation, we will write syntax that will output the values
    in the respective member attributes to the console. The following is the code
    implementation for this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释说明，我们将编写将相应成员属性的值输出到控制台的语法。以下是该代码实现：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now write syntax to call the respective `ChangeValues` function for each of
    structure and class. After the call to the function, have another statement to
    print the current values in the attributes of the `struct` and `class` objects.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编写语法来调用每个结构体和类的相应 `ChangeValues` 函数。在函数调用之后，再有一个语句来打印 `struct` 和 `class` 对象属性中的当前值。
- en: 'Refer to the following code implementation for this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此内容的代码实现，请参考以下代码：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Click on Build | Build Solution and ensure that there are no compile-time errors.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Build | 构建解决方案，并确保没有编译时错误。
- en: 'Click on Debug | Start Debugging. Alternatively, the user can also click on
    the *F5* key or the triangular icon next to Start to launch the debugger. Please
    refer to the following screenshots:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Debug | 开始调试。或者，用户也可以点击 *F5* 键或 Start 旁边的三角形图标来启动调试器。请参考以下截图：
- en: '![](img/c28097a2-2eec-4160-94a0-8a6901ad53e5.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c28097a2-2eec-4160-94a0-8a6901ad53e5.png)'
- en: 'Notice that the console shows the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，控制台显示了以下输出：
- en: '![](img/71aac2cf-d046-4d12-9d9c-ce9b41ab558a.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71aac2cf-d046-4d12-9d9c-ce9b41ab558a.png)'
- en: Notice that, after calling the change function, the value of the `class` object
    gets modified. However, there is no change to the values in the struct.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用更改函数之后，`class` 对象的值会发生变化。然而，结构体中的值没有变化。
- en: This is due to the fact that `struct` is a value type variable. Therefore, any
    change in the object, outside the scope of the function, has no impact as the
    change happens at an entirely different object in memory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`struct`是一个值类型变量。因此，在函数作用域之外对对象的任何更改都没有影响，因为更改发生在内存中完全不同的对象上。
- en: On the other hand, `class` being a reference type variable is affected by changes
    happening outside the scope of the function as well. For this reason, changes
    are propagated back to the main object as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`class`作为一个引用类型变量，也会受到函数作用域之外发生的更改的影响。因此，更改会传播回主对象。
- en: 'To summarize, the following table illustrates the main differences between
    a `struct` and a `class` type variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，以下表格展示了`struct`和`class`类型变量之间的主要区别：
- en: '| **Feature** | **Class** | **Struct** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **类** | **结构体** |'
- en: '| Default Constructor | If a class does not have a constructor, then whenever
    an object is created for the class, the default constructor triggers and sets
    default values against the member variables present in the class. The default
    values are set in accordance with the default values of the type of those member
    variables. | In contrast to a class, a struct cannot have any default constructors.
    This means that the application doesn''t assign a default value to the member
    variables of the struct. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 默认构造函数 | 如果一个类没有构造函数，那么每当为该类创建对象时，默认构造函数就会触发，并为类中存在的成员变量设置默认值。这些默认值是根据成员变量的类型默认值设置的。
    | 与类不同，`struct`不能有任何默认构造函数。这意味着应用程序不会为`struct`的成员变量分配默认值。 |'
- en: '| Memory Implementation | As illustrated in the previous code example, a class
    is implemented as a reference type. This means that the value of an object of
    class is persisted across different scopes of the program execution. | As illustrated
    in the previous code example, a struct is implemented as a value type. This means
    that its value is not persisted across different scopes of the program. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 内存实现 | 如前一个代码示例所示，类被实现为引用类型。这意味着类对象的值在程序执行的各个作用域中持续存在。 | 如前一个代码示例所示，`struct`被实现为值类型。这意味着它的值不会在程序执行的各个作用域中持续存在。
    |'
- en: '| Inheritance | We will be exploring inheritance in detail both in this chapter
    as well as in the next chapter. However, a class in C# can inherit from other
    classes. | In contrast to a class, a struct cannot inherit from other structs
    or classes. This implies that code reuse is slightly difficult in structs compared
    to in classes. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 继承 | 我们将在本章以及下一章中详细探讨继承。然而，C#中的类可以继承自其他类。 | 与类不同，`struct`不能继承自其他`struct`或类。这意味着与类相比，在`struct`中代码重用稍微困难一些。
    |'
- en: Based upon the preceding differences, depending upon the requirements, a developer
    can choose the right data type between a struct and a class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的差异，根据需求，开发者可以在`struct`和`class`之间选择合适的数据类型。
- en: In the next section, we will look at how an interface is implemented in a C#
    application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在C#应用程序中实现接口。
- en: Interfaces and inheritance
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口和继承
- en: An interface is a collection of properties, methods, and events with just a
    declaration and no definition. We use them in programming to group together a
    set of functionalities that must be implemented in classes that, theoretically,
    are of the same basic type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一组属性、方法和事件的集合，仅包含声明而没有定义。我们在编程中使用它们将必须实现的一组功能组合在一起，这些功能在理论上属于相同的基本类型。
- en: Let's look at an example of a car. In a real-world scenario, any implementation
    of the `Car` class must implement certain common basic features such as driving,
    stopping, and accelerating. Along with those, any object that is classified as
    a car will also have certain features specific to the make of the car, such as
    Honda or Nissan.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个汽车的例子。在现实世界中，任何`Car`类的实现都必须实现某些常见的基本功能，如驾驶、停车和加速。除此之外，任何被归类为汽车的物体也将具有特定于汽车制造商的特征，如本田或尼桑。
- en: In the preceding example, an interface could help to promote code reuse and
    maintain structure across all types of `Car`. What we can do in this case is to
    declare `Car` as an interface that all car derivatives, such as Nissan or Honda
    must implement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一个接口可以帮助促进代码重用，并在所有类型的`Car`中维护结构。在这种情况下，我们可以将`Car`声明为一个接口，所有汽车派生类型，如尼桑或本田，都必须实现。
- en: Similar to an interface, we can also implement *inheritance* in a C# application.
    In inheritance, we can define classes with certain methods and properties, which
    can then be inherited in a child class. In the next subsections, we will look
    at how interfaces and inheritance are implemented in a C# application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口类似，我们也可以在C#应用程序中实现*继承*。在继承中，我们可以定义具有某些方法和属性的类，然后这些方法和属性可以在子类中继承。在接下来的小节中，我们将探讨如何在C#应用程序中实现接口和继承。
- en: Inheritance is one of the main pillars of OOP programming. In [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml),
    *Understanding Object-Oriented Programming*, we will look into more advanced features
    related to inheritance and understand how it works.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的主要支柱之一。在[第3章](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml)《理解面向对象编程》中，我们将探讨与继承相关的高级特性，并了解它是如何工作的。
- en: Inheritance
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is one of the main principles of any object-oriented programming.
    With inheritance, we can define attributes and functions that can be reused in
    child classes. In short, it helps us to reuse code written in the application
    across multiple modules. Let's go through an example to understand how inheritance
    helps us.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是任何面向对象编程的主要原则之一。通过继承，我们可以在子类中定义可重用的属性和函数。简而言之，它帮助我们跨多个模块重用应用程序中编写的代码。让我们通过一个示例来了解继承是如何帮助我们的。
- en: 'Let''s consider two cars, `CarA` and `CarB`. From a very high-level perspective,
    we can think that both these classes will have similar features such as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两辆车，`CarA`和`CarB`。从非常高级的角度来看，我们可以认为这两个类都将具有类似的功能，例如：
- en: A brake function
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个刹车函数
- en: An accelerator function
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个加速函数
- en: A car type; that is, diesel/petrol and so on
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个车型；即柴油/汽油等
- en: Color
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色
- en: Gear type
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 齿轮类型
- en: 'If we need to implement this in a C# application, one way would be to define
    them as two separate classes: `CarA` and `CarB` . However, the main concern with
    this approach is that both of these classes will need to have their own implementation
    of the shared features listed. Please refer the following code for how a possible
    implementation of `CarA` would look in C#:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在C#应用程序中实现这一点，一种方法是将它们定义为两个独立的类：`CarA`和`CarB`。然而，这种方法的主要问题是这两个类都需要实现所列的共享功能。请参考以下代码，了解`CarA`在C#中可能的实现方式：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, please refer to the following code for what a possible implementation
    of `CarB` would look like in C#:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，请参考以下代码，了解`CarB`在C#中可能的实现方式：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This kind of implementation could have the following repercussions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现可能产生以下影响：
- en: '**No code reuse**: As you will understand from the preceding example, there
    are features that both `CarA` and `CarB` have in common. However, instead of maintaining
    common features separately, we are duplicating the code, which could cause maintenance
    issues as well.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有代码复用**：正如您将从前面的示例中理解的那样，`CarA`和`CarB`都有一些共同的特征。然而，我们并没有分别维护这些共同特征，而是重复了代码，这可能会导致维护问题。'
- en: '**Scalability**: From a business/implementation perspective, there could be
    millions of different types of cars. Thus, for every new `Car` or a new common
    feature added to the `Car` implementation, we may face some scalability challenges
    in the application.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：从商业/实施的角度来看，可能会有数百万种不同的车型。因此，对于每个新的`Car`或添加到`Car`实现中的新共同功能，我们可能会在应用程序中面临一些可扩展性的挑战。'
- en: As clearly illustrated, change management in such applications would be a nightmare
    and would be very difficult to carry out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如此清晰地展示，此类应用程序中的变更管理将是一场噩梦，并且执行起来非常困难。
- en: 'Now we will use the concept of inheritance and see how the preceding scenario
    could be implemented in a better way. From an implementation perspective, we will
    be creating a base class, `Car`, which will have all of the common member variables
    across different implementations of `Car`. We will then define individual types
    of `Car`, which will inherit from the base class, `Car`. Let''s look at the following
    code example to understand this better:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用继承的概念，看看如何以前更好的方式实现前面的场景。从实现的角度来看，我们将创建一个基类`Car`，它将包含所有跨不同`Car`实现中的共同成员变量。然后，我们将定义不同的`Car`类型，这些类型将继承自基类`Car`。让我们通过以下代码示例来更好地理解这一点：
- en: 'Create a base class, `Car`. The class will have all the member attributes that
    are common across `CarA` and `CarB`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基类`Car`。该类将包含`CarA`和`CarB`中共同的成员属性：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a class, `CarA`, which will inherit the base class. In C#, we use the`:`
    syntax to define inheritance:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类`CarA`，它将继承基类。在C#中，我们使用`:`语法来定义继承：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As indicated earlier, the attributes declared inside the parent class are automatically
    available in the derived class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在父类内部声明的属性在派生类中自动可用。
- en: Please note that the attributes from the base class that will be available in
    the child class depend upon the access modifiers used against the corresponding
    attributes in the base class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，基类中可用的属性取决于在基类中对应属性上使用的访问修饰符。
- en: In our example, we have used `public` access modified in the base class. If
    it had been `private` or `protected internal`, its accessibility would have differed
    in the child class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们在基类中使用了`public`访问修饰符。如果它是`private`或`protected internal`，其在子类中的可访问性将不同。
- en: 'Let''s consider a scenario wherein, for some reason, we also need to declare
    an attribute by the same name, `bodyType`, in `CarA`. In C#, we can differentiate
    between the attributes present in the base class and in the derived class by using
    the `base` keyword. Refer to the following code for this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，由于某种原因，我们还需要在`CarA`中声明一个同名的属性`bodyType`。在C#中，我们可以通过使用`base`关键字来区分基类和派生类中存在的属性。请参考以下代码：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If `base` is used, it refers to the attribute in the parent class and, if `this`
    is used, it refers to the attribute in the child class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`base`，它指的是父类中的属性，如果使用`this`，它指的是子类中的属性。
- en: 'Similarly, declare a class for `CarB`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，为`CarB`声明一个类：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Please note that, in derived classes, we can also create member variables independent
    of the base classes. As indicated in the preceding screenshots, the `CarA` class
    has an implementation of `FoldableSeat`, which is not present in the base class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在派生类中，我们也可以创建与基类无关的成员变量。如前述截图所示，`CarA`类有一个`FoldableSeat`的实现，这在基类中不存在。
- en: Similarly, the `CarB` class has an implementation of `RoofTopExtendable`, which
    is not present in the base class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`CarB`类有一个`RoofTopExtendable`的实现，这在基类中不存在。
- en: 'In the main method, declare the `CarA` and `CarB` objects and call the respective
    methods:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主方法中，声明`CarA`和`CarB`对象并调用相应的方法：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Click on Build | Build Solution. Notice that there are no compile-time errors.
    Now click on Debug | Start Debugging. Notice that the following output comes up
    in the console window:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“构建 | 构建解决方案”。注意，没有编译时错误。现在点击“调试 | 开始调试”。注意，以下输出出现在控制窗口中：
- en: '![](img/e889716e-6f6f-40b2-adca-06de90d89a62.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e889716e-6f6f-40b2-adca-06de90d89a62.png)'
- en: 'The following provides a brief analysis of each of the output line items:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个输出行项的简要分析：
- en: The first method we call is `ImplementAccelerator`, which is present in the
    base class. As expected, it executes the method in the base class.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先调用的方法是`ImplementAccelerator`，它存在于基类中。正如预期的那样，它执行了基类中的方法。
- en: Similarly, the next method we call is `ImplementBrake`, which is also present
    in the base class. In this case also, the method in the base class is executed.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，下一个我们调用的方法是`ImplementBrake`，它也存在于基类中。在这种情况下，基类中的方法也会被执行。
- en: In the next call, we execute a method just present in `CarA`. In this case,
    the control executes the code present in that function.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一次调用中，我们执行了仅存在于`CarA`中的方法。在这种情况下，控制执行该函数中的代码。
- en: The same thing applies to B as well.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样适用于B。
- en: Thus, using inheritance, we can promote a greater degree of code reuse, along
    with making the maintenance activity quite scalable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用继承，我们可以提高代码的重用程度，同时使维护活动变得相当可扩展。
- en: Once we move on to [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml),
    *Understanding Object-Oriented Programming*, we will cover more features in regard
    to inheritance, such as overriding sealed, abstract classes and so on. However,
    for now, we will go over how an interface helps us in C# code development.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入[第3章](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml)，*理解面向对象编程*，我们将介绍更多关于继承的功能，例如重写密封的、抽象的类等。然而，现在我们将介绍接口如何帮助我们进行C#代码开发。
- en: Interfaces in C#
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的接口
- en: In the preceding example, we illustrated how we can declare a base class with
    some member variables and have them inherited in a derived class. However, there
    could be some scenarios when we need to have a class inherited from two different
    classes. Moreover, if we are using a struct, we will not be able to inherit from
    another struct or class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们展示了如何声明一个具有一些成员变量的基类，并在派生类中继承它们。然而，在某些情况下，我们可能需要从一个类继承两个不同的类。此外，如果我们使用的是结构体，我们将无法从另一个结构体或类继承。
- en: 'Unfortunately, using inheritance, we will not be able to achieve this in a
    C# application due to the following reasons:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于以下原因，使用继承，我们无法在C#应用程序中实现这一点：
- en: Multiple inheritance is not allowed in C#.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中不允许多重继承。
- en: A struct data type in C# cannot inherit from other structs or class types.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中的结构体数据类型不能从其他结构体或类类型继承。
- en: In such scenarios, interfaces come in handy. An interface defines a set of related
    methods, attributes which each class implementing the interface must implement.
    Please note that an interface must have just declarations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，接口非常有用。接口定义了一组相关的方法和属性，每个实现接口的类都必须实现这些方法和属性。请注意，接口必须只有声明。
- en: In reference to interfaces, a declaration refers to the specification of the
    methods along with their signatures – that is, input and output parameters – while
    a definition refers to the actual implementation of the logic in the method body.
    While discussing the following code example, we will look further into this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关于接口，声明指的是方法的规范及其签名——即输入和输出参数——而定义则指的是方法体中逻辑的实际实现。在讨论以下代码示例时，我们将进一步探讨这一点。
- en: 'Let''s look at the example we used for inheritance and see how we can use an
    interface in it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们用于继承的例子，看看我们如何在其中使用接口：
- en: In the preceding example, wherein we created `CarA` and `CarB`, we can deduce
    that it is bound to have several other properties as well, such as color, weight,
    height, brand, logo, manufacturer, and so on.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了`CarA`和`CarB`，我们可以推断出它肯定还有其他一些属性，例如颜色、重量、高度、品牌、标志、制造商等。
- en: From a data model perspective, we can classify them as attributes common to
    any *utility or product* rather than just a car.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据模型的角度来看，我们可以将它们归类为任何*实用工具或产品*的通用属性，而不仅仅是汽车。
- en: So, when we are choosing a product, we can say that there are certain actions,
    such as `ImplementBrand`, `ImplementColor`, and so on that will be common across
    all the product implementations and not just for `CarA` and `CarB`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，当我们选择产品时，我们可以这样说，有一些操作，如`ImplementBrand`、`ImplementColor`等，将在所有产品实现中是通用的，而不仅仅是针对`CarA`和`CarB`。
- en: Therefore, it means that the two classes must inherit from both `Car` and `Product`
    to function correctly.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，这意味着这两个类必须从`Car`和`Product`两个类继承才能正确运行。
- en: 'Let''s try and create another base class of `Product` and try to implement
    multiple inheritance for `CarA`. Here''s the following code implementation for
    the `Product` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建另一个基类`Product`，并尝试为`CarA`实现多重继承。以下是`Product`类的代码实现：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, when we try to implement multiple inheritance for the `CarA` class,
    the compiler gives us an error. The following screenshot shows the error we get
    from the compiler:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试为`CarA`类实现多重继承时，编译器会给出错误。以下截图显示了编译器给出的错误：
- en: '![](img/4ede8a7f-a14b-4e28-a3c9-66ecb6904c44.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ede8a7f-a14b-4e28-a3c9-66ecb6904c44.png)'
- en: A solution would be to merge the implementations of `Car` and `Product` together;
    however, it's clear that from a data model perspective, these two entities are
    not related to each other.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将`Car`和`Product`的实现合并在一起；然而，从数据模型的角度来看，这两个实体之间并没有直接关系。
- en: 'To overcome the preceding dilemma, we will use an interface. When declaring
    an interface, we need to adhere to the following conventions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服上述困境，我们将使用接口。在声明接口时，我们需要遵守以下约定：
- en: To declare an interface, we need to use the `interface` keyword.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要声明接口，我们需要使用`interface`关键字。
- en: An interface cannot have an access modifier for any function declaration.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口不能为任何函数声明指定访问修饰符。
- en: An interface must also just have function declarations and no definitions.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口也必须只包含函数声明，而没有定义。
- en: 'The following is the code syntax of the `ICar` interface, wherein we are declaring
    the methods that should be in the interface:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ICar`接口的代码语法，其中我们声明了接口中应该有的方法：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that, in the preceding example, we have only specified the signature
    that the methods present in the interface should acquire. This is referred to
    as a declaration. The class implementing this interface – in our case, `Car`,
    will be responsible for providing complete implementation for the methods presents
    in the interface.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，我们只指定了接口中存在的方法应该获得的签名。这被称为声明。实现此接口的类——在我们的例子中是`Car`类，将负责为接口中存在的方法提供完整的实现。
- en: 'To implement an interface, we can use syntax similar to inheritance. The following
    is the screenshot for this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现接口，我们可以使用类似于继承的语法。以下是这个语法的截图：
- en: '![](img/9c7acb08-c14f-42e6-9a75-9efc4f39209c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c7acb08-c14f-42e6-9a75-9efc4f39209c.png)'
- en: Review the compile-time error. The error indicates that the `Car` class must
    implement all the functions declared in the interface. To overcome the preceding
    error, we must define all the functions in the interface. Similar to `ICar`, we
    can also create an interface for `IProduct`, which each of the `CarA` and `CarB`
    classes can then implement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 检查编译时错误。错误表明`Car`类必须实现接口中声明的所有函数。为了克服前面的错误，我们必须定义接口中的所有函数。类似于`ICar`，我们也可以为`IProduct`创建一个接口，然后`CarA`和`CarB`类可以分别实现它。
- en: 'While inheritance and interfaces can be used in similar scenarios, some of
    the differences between them are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然继承和接口可以在类似场景中使用，但它们之间的一些差异如下：
- en: '| **Feature** | **Inheritance** | **Interface** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **继承** | **接口** |'
- en: '| Multiple derivations | A class can only inherit from one class. | A class
    can implement multiple interfaces. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 多重继承 | 一个类只能从一个类继承。 | 一个类可以实现多个接口。 |'
- en: '| Data types | A class can inherit from another class. However, a struct cannot
    inherit from another class or struct. | Both classes and structs can implement
    interfaces. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 一个类可以继承自另一个类。然而，一个结构不能从另一个类或结构继承。 | 类和结构都可以实现接口。 |'
- en: '| Method definitions | In inheritance, a base class can define methods. | An
    interface cannot have any definitions against methods. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 方法定义 | 在继承中，基类可以定义方法。 | 接口不能有针对方法的定义。 |'
- en: '| Access modifiers | A base class and its member attributes can assume different
    access modifiers, such as `public`, `private`, `protected`, `protected internal`,
    and `private protected`. | The access modifier of an interface is always public.
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | 基类及其成员属性可以采用不同的访问修饰符，例如`public`、`private`、`protected`、`protected
    internal`和`private protected`。 | 接口的访问修饰符始终是`public`。 |'
- en: Based on these differences, a programmer can decide the right approach for their
    application and choose between creating an interface or managing through inheritance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些差异，程序员可以决定他们应用程序的正确方法，并在创建接口或通过继承管理之间进行选择。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The topics covered in this chapter are the basics of programming in the C# language.
    Using access modifiers, we can control access to different properties and methods
    in different modules of an application. While writing the code, a very common
    mistake that people make is to declare all the properties and methods as public.
    This is not the recommended way of programming in C#. We must logically evaluate
    the need for different access modifiers for each of the properties and methods
    present in a class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的是C#语言编程的基础知识。通过使用访问修饰符，我们可以控制应用程序不同模块中不同属性和方法的可访问性。在编写代码时，人们常犯的一个非常常见的错误是将所有属性和方法声明为public。这不是C#编程中推荐的做法。我们必须对类中存在的每个属性和方法是否需要不同的访问修饰符进行逻辑评估。
- en: Similarly, we should analyze the data types that we need to associate with each
    property used in the class. We must also analyze if we need a reference data type
    variable, or whether we are fine with a value type variable as they have a different
    implementation in the compiler memory and functionality. We should also utilize
    inheritance as it helps us to reuse code and structure our programs in a very
    precise manner.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们应该分析我们需要与类中使用的每个属性关联的数据类型。我们还必须分析我们是否需要一个引用数据类型变量，或者我们是否可以接受值类型变量，因为它们在编译器内存和功能上有所不同。我们还应该利用继承，因为它有助于我们重用代码并以非常精确的方式组织程序。
- en: In the next chapter , we will go through OOP concepts, which are the main building
    blocks of any high-level programming language like C#. We will go over polymorphism,
    abstraction, encapsulation, and inheritance and understand each of these concepts
    in detail, and will also go over some code examples to see their implementation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍面向对象的概念，这些是任何高级编程语言（如C#）的主要构建块。我们将讨论多态、抽象、封装和继承，并详细理解这些概念，同时也会通过一些代码示例来查看它们的实现。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following attributes declared in the `Car` class is not a *value
    type* variable?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Car`类中声明的以下哪个属性不是值类型变量？
- en: '`public Decimal fuelCapacity;`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public Decimal fuelCapacity;`'
- en: '`public Enum carColor;`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public Enum carColor;`'
- en: '`public String registrationNumber;`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public String registrationNumber;`'
- en: '`public Int numberOfSeats`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public Int numberOfSeats`'
- en: Which of the following is not a reference type variable?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是引用类型变量？
- en: Class
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类
- en: String
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串
- en: Struct
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体
- en: Interface
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口
- en: In C#, a child class can inherit from multiple parent classes. Is this statement
    correct?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中，一个子类可以继承自多个父类。这个陈述正确吗？
- en: 'Yes'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Which of the following statements about interfaces and classes is not correct?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于接口和类的陈述哪个是不正确的？
- en: A class can implement multiple interfaces.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类可以实现多个接口。
- en: An interface can have both function declarations and definitions.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个接口可以同时有函数声明和定义。
- en: A struct data variable cannot inherit from another struct.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体数据变量不能从另一个结构体继承。
- en: In inheritance, if both the base class and the derived class have a function
    with the same name, we can use the *base* keyword to implicitly call the function
    of the base class.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继承中，如果基类和派生类都有一个同名函数，我们可以使用`*base*`关键字来隐式调用基类的函数。
- en: Which of the following statements about access modifiers is not correct?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于访问修饰符的陈述哪个是不正确的？
- en: If a member variable is declared as `public`, it can be accessed across the
    entire application.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个成员变量被声明为`public`，它可以在整个应用程序中被访问。
- en: If a member variable is declared as `private`, it can only be accessed in the
    same class.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个成员变量被声明为`private`，它只能在同一类中访问。
- en: If a member variable is declared as `protected`, it can be accessed throughout
    the namespace.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个成员变量被声明为`protected`，它可以在整个命名空间中被访问。
- en: If a member variable is declared as `protected internal`, it can be accessed
    by classes in the name namespace and the classes that derive from it.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个成员变量被声明为`protected internal`，它可以在名称空间中的类以及从它派生的类中访问。
- en: Answers
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`public String registrationNumber;`. String is a reference type variable. All
    others are value type variables.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public String registrationNumber;`。字符串是一个引用类型变量。所有其他都是值类型变量。'
- en: '**Struct** is a value type variable unlike all others which are reference type
    variables.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结构体**是一个值类型变量，与所有其他都是引用类型变量不同。'
- en: '**No**, in C# we cannot have multiple inheritance. A class can only inherit
    from one base class.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不**，在C#中我们不能有多个继承。一个类只能从一个基类继承。'
- en: In C#, an interface must only have function declarations and not definitions.
    All other statements are correct.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中，一个接口必须只有函数声明而没有定义。所有其他陈述都是正确的。
- en: If a member variable is declared as `protected`, it can only be accessed in
    the classes that inherit from its base parent class.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个成员变量被声明为`protected`，它只能在继承自其基父类的类中访问。
