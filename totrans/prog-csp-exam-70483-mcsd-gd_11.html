<html><head></head><body>
        

                            
                    <h1 class="header-title">Validating Application Input</h1>
                
            
            
                
<p>When working on real-world projects, there may be scenarios where different kinds of users access your application and enter information in to it. In the event that any aspect of the scenario was not handled properly, or any input data was not properly parsed, this can cause your application to crash or result in the corruption of your application data. Even though you validate all the input data used and accessed within your application when deployed in production, input data can interact with other external applications, which can place your application in jeopardy.</p>
<p class="mce-root">The purpose of this chapter is to understand the importance of validating input data in your application. Different validation techniques are available in the .NET Framework to validate JSON data and XML data.</p>
<p>In upcoming sections, we will focus on why it is important to validate input data, how we can manage data integrity, how to use framework-provided parsing statements and regular expressions, and how to validate JSON and XML data. After reading this chapter, you will be able to create application logic to validate incoming data and also handle scenarios where exceptions might occur.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The importance of validating input data</li>
<li>Data integrity</li>
<li>Parsing and converting</li>
<li>Regular expressions</li>
<li>JSON and XML</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>Exercises in this chapter can be implemented using Visual Studio 2012 or above with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and above require you to have Visual Studio 2017.</p>
<p>If you don't have a license for any of the products, you can download the community version of Visual Studio 2017 from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>The sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter%2011">https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter 11</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The importance of validating input data</h1>
                
            
            
                
<p>Creating and running an application in isolation mode makes your application run without any issues. However, when working on a real project, your application will be executing in an environment where many external interfaces may interact. In such scenarios, is your application capable of handling such communications? Can it handle all kinds of data from these external applications? There will be many users who will try to use your system; some may use it properly, and others may try to break your system. Can your application tolerate such interactions?</p>
<p>There may be problems with both types of user. Those who use your system properly may make mistakes by entering incorrect data or may forget to provide the requisite data. In the event your application has logic based on the user's date of birth and the user enters some text data, your application might throw an exception and crash. </p>
<p>In a scenario where users try to break your application by providing data that doesn't match any of the types that your application expects, this may crash your application and a significant amount of time may be devoted to recovering it. </p>
<p>Any of these aforementioned actions can cause temporary damage to your application or may constitute a major issue. When it corrupts your database, recovering your application may entail more time and effort.</p>
<p class="mce-root"/>
<p>Creating an application using .NET Framework involves the provision of some built-in features that can be utilized to validate some of the input data, be it from internal or external users or external applications. Framework allows you to add attributes over each property that can validate data for you. These are available when you use ASP.NET or the Entity Framework, and so on. As you learned in previous chapters, you can define custom attributes and perform validation on the data entered by users. </p>
<p>In the next section, we will see a variety of data integrity scenarios that are important to understand while working on data validations in your applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data integrity</h1>
                
            
            
                
<p>While working on any application, it is very important to design it in such a way that it handles all scenarios, or at least provides user-friendly messages to users on what went wrong. We have already learned about exception handling in <a href="7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml">Chapter 7</a>, <em>Implementing Exception Handling</em>, which can be handy in such scenarios. </p>
<p>While working on a database or distributed applications, data integrity plays a vital role. </p>
<p>Data integrity applies differently in different scenarios:</p>
<ul>
<li>For example, if you are creating an application and storing user information in a table, one of the principles you may adopt might be to not maintain duplicate users in the table so that they are uniquely identifiable. This is termed <strong>entity integrity</strong>.</li>
<li>In a scenario where you are collecting demographic information, you may allow certain values, or ranges of values, in specific fields. This is termed <strong>domain integrity</strong>. In other words, you are making sure that the data entered in each record/entity is valid.</li>
<li>There may be a scenario where you have to enter data into multiple tables with a parent-child relationship. In such cases, your application should maintain these relationships while saving information to the database. This is called <strong>referential integrity</strong>.</li>
<li>Last but not least, in a business scenario, in order to achieve the desired outcome based on a business process, your application may enforce certain constraints. This is called <strong>user-defined</strong> integrity, or <strong>business-defined</strong> integrity.</li>
</ul>
<p class="mce-root"/>
<p>There are many real-world examples. These include any eCommerce applications or any banking applications. How critical is it to validate and control input and program flow? In a banking application, what would happen in the event of a power outage? In an eCommerce application, how would a shopping cart be maintained between multiple sessions, when the user closes their browser, or in the event that a clean-up job kicks in?</p>
<p>Many of these data integrity options are available in the latest databases and frameworks, which enable us to utilize these options to validate and control the flow of our program.</p>
<p>One of the ways to validate data is to use the data annotations assembly, which is available in .NET Framework 3.5 and above. Data annotations talk about adding more information about an attribute or property in a class. You can use data annotations by referring to the <kbd>System.ComponentModel.DataAnnotations</kbd> namespace. These data annotations fall into three categories:</p>
<ul>
<li>Validation attributes</li>
<li>Display attributes</li>
<li>Modeling attributes</li>
</ul>
<p>Each of these attributes is used for a specific purpose: validation attributes enforce the validation of data; display attributes are used as display labels on the user interface, and modeling attributes represent the recommended use of the relevant attribute.</p>
<p>In the following class, we will reference <kbd>System.ComponentModel.DataAnnotations</kbd> and use validating attributes, display attributes, and modeling attributes on the three available properties: </p>
<pre>using System;<br/>using System.ComponentModel.DataAnnotations;<br/><br/>namespace Chapter11<br/>{<br/>    public class Student<br/>    {<br/>        [Required(ErrorMessage = "Fullname of the student is <br/>         mandatory")]<br/>        [StringLength(100,MinimumLength =5,ErrorMessage ="Name should <br/>         have minimum of 5 characters")]<br/>        [DataType(DataType.Text)]<br/>        public string FullName { get; set; }<br/><br/>        [DataType(DataType.EmailAddress)]<br/>        [EmailAddress]<br/>        public string EmailAddress { get; set; }<br/><br/>        [DataType(DataType.Date)]<br/>       [Display(Name ="Date of Birth")]<br/>        public DateTime DOB { get; set; }<br/>    }<br/>}</pre>
<p>On the name property, we have a required field attribute and string length restrictions as validation attributes. The data type set to text is a data modeling attribute that tells the system that the name attribute only accepts text values. On the <kbd>DOB</kbd> property, we have a display attribute. However, display properties can be used in either ASP.NET applications or WPF applications.</p>
<p>Now, we create an instance of the <kbd>Student</kbd> class and try to validate its data. Data annotations help us to define <kbd>ValidationContext</kbd>; when an object is validated, <kbd>ValidationResult</kbd> will be returned, which consists of all properties and their respective error messages. While defining properties in the <kbd>Student</kbd> class, we added attributes with messages. When <kbd>ValidationContext</kbd> returns results, it returns each of these properties with their respective attributes and messages:</p>
<pre>Student st = new Student();<br/>st.FullName = "st1";<br/>st.EmailAddress = "st@st";<br/>st.DOB = DateTime.Now;<br/><br/>ValidationContext context = new ValidationContext(st, null, null);<br/>List&lt;ValidationResult&gt; results = new List&lt;ValidationResult&gt;();<br/>bool valid = Validator.TryValidateObject(st, context, results, true);<br/>if (!valid)<br/>{<br/>    foreach (ValidationResult vr in results)<br/>    {<br/>        Console.Write("Student class Property Name :{0}", <br/>         vr.MemberNames.First());<br/>        Console.Write(" :: {0}{1}", vr.ErrorMessage, <br/>         Environment.NewLine);<br/>    }<br/>}</pre>
<p>When you create a <kbd>ValidationContext</kbd> instance, we use the constructor that takes three parameters. These are as follows:</p>
<ul>
<li>An instance of an object that we want to validate</li>
<li>An object that implements the <kbd>IServiceProvider</kbd> interface, which means that you need to create an instance using the <kbd>GetService</kbd> method</li>
<li>A dictionary of a key/value pair to consume</li>
</ul>
<p class="mce-root"/>
<p>Also, while trying to validate an object, we passed <kbd>true</kbd> as the last parameter, which represents the validation of all properties of the object.</p>
<p>When you execute the program, you should see the following output. The student's name should have a minimum of five characters and the email address should be in a valid format:</p>
<pre>Student class Property Name :FullName :: Name should have minimum of 5 characters<br/>Student class Property Name :EmailAddress :: The EmailAddress field is not a valid e-mail address.<br/>Press any key to exit.</pre>
<p>In the next section, we will look at the different features available in C# to validate our data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parsing and converting</h1>
                
            
            
                
<p>Entity integrity and domain integrity involve allowing valid values into our application for further processing. Valid values include manipulating or managing input provided by a user, rendering it as data that is acceptable to the application. This process may including parsing specific types of data to the type our application accepts, converting data types, and so on. </p>
<p><kbd>Parse</kbd> and <kbd>TryParse</kbd> are two statements available across multiple data types within the .NET Framework, for example if you are writing a console application and you want to accept parameters as command-line arguments. In a console application, command-line parameters are always of the string type. So, how do you parse these arguments from the string type to another required type?</p>
<p>In the following example, we know that our first parameter is a Boolean value, but is passed as a string. When we are certain of the value passed, we can use the parse method to convert the string to a Boolean. <kbd>Parse</kbd> compares to with static string values and returns either <kbd>true</kbd> or <kbd>false</kbd>. When invalid data is passed, an exception is thrown—<kbd>Input string is in an invalid format</kbd>.</p>
<p class="mce-root"/>
<p>Let's start with an example. Define two methods that each take a parameter of the string type. We want to parse it into Boolean and integer values. Parsing a Boolean is as simple as using the parse method of a Boolean type. However, for the integer type, there are two approaches. One is to use parse, as we did when parsing a Boolean, and the other is <kbd>TryParse</kbd>. When we are not sure if the string parameter provided is an integer or not, then we can use the <kbd>TryParse</kbd> method, which will then give us a <kbd>bool</kbd> result on which we can set up our logic. In the following example, we are showing both ways. This will allow us to handle exceptions and provide the user with a meaningful message:</p>
<pre>internal class ParseSamples<br/>    {<br/>        internal void ProcessBool(string boolValue)<br/>        {<br/>            if (bool.Parse(boolValue))<br/>            {<br/>                Console.WriteLine($"Parsed bool value is : <br/>                 {bool.Parse(boolValue)}");<br/>            }<br/>        }<br/><br/>        internal void ProcessInteger(string intValue)<br/>        {<br/>            <br/>            int processedValue =int.MinValue;<br/>            if (int.TryParse(intValue, out processedValue))<br/>            {<br/>                Console.WriteLine($"Parsed int value is : <br/>                 {processedValue}");<br/>            }<br/>            else<br/>            {<br/>                Console.WriteLine("Parsed value is not an integer");<br/>            }<br/>            Console.WriteLine($"Parsed int value is : <br/>             {int.Parse(intValue)}");<br/><br/>        </pre>
<p>Now that our sample class is ready, let's invoke it using our <kbd>main</kbd> method. Here, we have a <kbd>switch</kbd> statement to check the length of the arguments passed to the <kbd>main</kbd> method. If it is <kbd>1</kbd>, call the <kbd>processbool</kbd> method; if it is <kbd>2</kbd>, call both methods, otherwise, a message is displayed:</p>
<pre> static void Main(string[] args)<br/>        {<br/>            ParseSamples ps = new ParseSamples();<br/>            switch (args.Length)<br/>            {<br/>                case 1:<br/>                    ps.ProcessBools(args[0]);<br/>                    break;<br/>                case 2:<br/>                    ps.ProcessBools(args[0]);<br/>                    ps.ProcessIntegers(args[1]);<br/>                    break;<br/>                default:<br/>                    Console.WriteLine("Please provide one or two <br/>                     command line arguments");<br/>                    break;<br/>            }<br/><br/><br/>            // Keep the console window open in debug mode.<br/>            System.Console.WriteLine("Press any key to exit.");<br/>            System.Console.ReadKey();<br/>        }</pre>
<p>To invoke this method, because we are trying to read command-line arguments in our program, these need to be passed at runtime or from the Properties window, which will then be read at runtime. Parameters are passed from the Properties window as follows. Right-click on Project, select Properties, and then navigate to the Debug tab, where you can set these parameters:</p>
<div><img src="img/4ac4b314-42ab-4fc9-9202-4a269dc90c2e.png" style=""/></div>
<p>When you run the program, as you pass <kbd>1</kbd> or <kbd>2</kbd> arguments, the respective case statements get executed and the output will be presented on the screen:</p>
<pre>//Command line argument true<br/>Parsed bool value is : True<br/>Press any key to exit.<br/><br/>//Command line argument true 11<br/>Parsed bool value is : True<br/>Parsed int value is : 11<br/>Parsed int value is : 11<br/>Press any key to exit.<br/><br/>//Command line arguments true Madhav<br/>Parsed bool value is : True<br/>Parsed value is not an integer </pre>
<p>Here, in the last output, <kbd>TryParse</kbd> statements are processed, but <kbd>Parse</kbd> will throw an error as follows. Because <kbd>Parse</kbd> expects a proper string to be passed, when a non-string value is passed, or when your statement doesn't correspond to the value passed, it throws an error. However, if we handle this statement using <kbd>try..catch</kbd>, we won't see any issues. Otherwise, your program will break and an exception dialog will appear as follows: </p>
<div><img src="img/999810a0-4c08-41ad-b311-f3e7a2a5b81f.png"/></div>
<p>Another way to validate your input is to use the conversion method. <kbd>Convert</kbd> is a method defined in .NET Framework that casts a base type to another base type. Unlike <kbd>Parse</kbd>, <kbd>Convert</kbd> accepts an object of a type and converts it into another type. <kbd>Parse</kbd> accepts only string input. Also, when a <kbd>null</kbd> value is passed, <kbd>Convert</kbd> returns the minimum value of the target type. The <kbd>Convert</kbd> class has a few static methods that support conversion to and from different types in .NET Framework. Types supported by the <kbd>Convert</kbd> method are <kbd>Boolean</kbd>, <kbd>Char</kbd>, <kbd>SByte</kbd>, <kbd>Byte</kbd>, <kbd>Int16</kbd>, <kbd>Int32</kbd>, <kbd>Int64</kbd>, <kbd>UInt16</kbd>, <kbd>UInt32</kbd>, <kbd>UInt64</kbd>, <kbd>Single</kbd>, <kbd>Double</kbd>, <kbd>Decimal</kbd>, <kbd>DateTime</kbd>, and <kbd>String</kbd>. </p>
<p class="mce-root"/>
<p>When you apply the <kbd>Convert</kbd> method, you can expect any of the following output. The system either successfully converts the source type to the target type or throws one of the following exceptions: <kbd>FormatException</kbd>, <kbd>InvalidCastException</kbd>, or <kbd>ArgumentNull</kbd>. Let's look at an example:</p>
<pre>internal void ConvertSample()<br/>{<br/>    try<br/>    {<br/>        string svalue =string.Empty; <br/>        Console.WriteLine(Convert.ToInt32(svalue));<br/>    }<br/>    catch (FormatException fx)<br/>    {<br/>        Console.WriteLine("Format Exception : "+fx.Message);<br/>    }<br/>    try<br/>    {<br/>        double dvalue = 1212121212121212.12;<br/>        Console.WriteLine(Convert.ToInt32(dvalue));<br/>    }<br/>    catch (OverflowException ox)<br/>    {<br/>        Console.WriteLine("OverFlow Exception : " + ox.Message);<br/>    }<br/>    try<br/>    {<br/>        DateTime date= DateTime.Now;<br/>        Console.WriteLine(Convert.ToDouble(date));<br/>    }<br/>    catch (InvalidCastException ix)<br/>    {<br/>        Console.WriteLine("Invalid cast Exception : " + ix.Message);<br/>    }<br/>    double dvalue1 = 12.22;<br/>    Console.WriteLine("Converted Value : " + Convert.ToInt32(dvalue1));<br/>}</pre>
<p>In the preceding example, we tried to convert different types. The important thing to note is that you can get any output while converting, and so you have to handle it accordingly in your application code. Also, while converting decimal or float values to integers, precise information is lost. However, no exception is thrown.</p>
<p class="mce-root"/>
<p>With same-type conversions, there won't be any exceptions or conversions. <kbd>FormatException</kbd> is thrown when you try to convert a string to any other type. <kbd>String</kbd> to <kbd>Boolean</kbd>, <kbd>String</kbd> to <kbd>Char</kbd>, or <kbd>String</kbd> to <kbd>DateTime</kbd> may throw this exception.</p>
<p><kbd>InvalidCastException</kbd> occurs when a conversion between specific types is not valid, as in the following examples:</p>
<ul>
<li>Conversions from <kbd>Char</kbd> to <kbd>Boolean</kbd>, <kbd>Single</kbd>, <kbd>Double</kbd>, <kbd>Decimal</kbd>, or <kbd>DateTime</kbd></li>
<li>Conversions from <kbd>Boolean</kbd>, <kbd>Single</kbd>, <kbd>Double</kbd>, <kbd>Decimal</kbd>, or <kbd>DateTime</kbd> to <kbd>Char</kbd></li>
<li>Conversions from <kbd>DateTime</kbd> to any other type except <kbd>String</kbd></li>
<li>Conversions from any other type, except <kbd>String</kbd>, to <kbd>DateTime</kbd></li>
</ul>
<p><kbd>OverflowException</kbd> is thrown in the event of loss of data, for example, when converting a huge decimal to an integer, as shown in our example. In our example, we are converting a double value to an <kbd>int</kbd> value. The <kbd>int</kbd> type variable in C# has a minimum and maximum value. If the number passed is outside this range, an overflow exception is raised:</p>
<pre>Format Exception : Input string was not in a correct format.<br/>OverFlow Exception : Value was either too large or too small for an Int32.<br/>Invalid cast Exception : Invalid cast from 'DateTime' to 'Double'.<br/>Converted Value : 12<br/>Press any key to exit.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Regular expressions</h1>
                
            
            
                
<p>When talking about validating input data, it is important to have an understanding of regular expressions, which is a powerful way to process text. It employs a pattern-matching technique to identify a pattern of text in input texts and validates it to the required format. For example, if our application wants to validate an email, regular expressions can be used to identify whether the email address provided is in a valid format. it checks for <kbd>.com</kbd>, <kbd>@</kbd>, and other patterns and returns if it matches a required pattern.</p>
<p><kbd>System.Text.RegularExpressions.Regex</kbd> acts as a regular expression engine in .NET Framework. To use this engine, we need to pass two parameters, the first a pattern to match and the second text where this pattern matching happens.</p>
<p>The regex class comes up with four different methods – <kbd>IsMatch</kbd>, <kbd>Match</kbd>, <kbd>Matches</kbd>, and <kbd>Replace</kbd>. The <kbd>IsMatch</kbd> method is used to identify a pattern in the input text. The <kbd>Match</kbd> or <kbd>Matches</kbd> methods are used to get all occurrences of text that match a pattern. The <kbd>Replace</kbd> method replaces text that matches a regular expression pattern.</p>
<p class="mce-root"/>
<p>Now, let's jump into some examples to understand regular expressions:</p>
<pre>public void ReplacePatternText()<br/>{<br/>    string pattern = "(FIRSTNAME\\.? |LASTNAME\\.?)";<br/><br/>    string[] names = { "FIRSTNAME. MOHAN", "LASTNAME. KARTHIK" };<br/>    foreach(string str in names)<br/>    {<br/>        Console.WriteLine(Regex.Replace(str, pattern, String.Empty));<br/>    }<br/>    <br/>}<br/><br/>public void MatchPatternText()<br/>{<br/>    string pattern = "(Madhav\\.?)";<br/><br/>    string names = "Srinivas Madhav. and Madhav. Gorthi are same";<br/>    MatchCollection matColl = Regex.Matches(names, pattern);<br/>    foreach (Match m in matColl)<br/>    {<br/>        Console.WriteLine(m);<br/>    }<br/>}<br/><br/>public void IsMatchPattern()<br/>{<br/>    string pattern = @"^c\w+";<br/><br/>    string str = "this sample is done as part of chapter 11";<br/>    string[] items = str.Split(' ');<br/>    foreach (string s in items)<br/>    {<br/>        if (Regex.IsMatch(s, pattern))<br/>        {<br/>            Console.WriteLine("chapter exists in string str");<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>ReplacePatternTest</kbd> method identifies <kbd>FirstName</kbd> and <kbd>LastName</kbd> from an array of strings and replaces them with an empty string. In the <kbd>MatchPatternText</kbd> method, we identify how many times <kbd>Madhav</kbd> exists in the string; in the third method, we use a pattern to identify a chapter word. The <kbd>^c\w+</kbd> pattern represents the beginning of the word, <kbd>c</kbd> represents a word starting with <em>c</em>, <kbd>\w</kbd> represents any characters, and <kbd>+</kbd> represents matches with the preceding token. </p>
<p class="mce-root"/>
<p>The following output shows the first two lines of the output from the <kbd>ReplacePatternTest</kbd> method, where we replaced <kbd>Madhav</kbd> with an empty string. The second output set identifies a pattern and displays it. The third set is where we identify a chapter word in the string:</p>
<pre>//ReplacePatternText method<br/>MOHAN<br/> KARTHIK<br/><br/>//MatchPatternText method<br/>Madhav.<br/>Madhav.<br/><br/>//IsMatchPattern method<br/>chapter exists in string str<br/>Press any key to exit.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">JSON and XML</h1>
                
            
            
                
<p>With the extensive use of internet and cloud applications, JSON and XML are becoming more important in terms of data transfer between applications. Using JSON and XML also increases the number of data-related issues, unless the data is validated. </p>
<p>Schema validation can be used to validate an XML file, which will help us to identify whether XML is inline with data types defined. However, to validate the actual data, you may still be using the methods we discussed in this chapter. Visual Studio helps you to create a schema file. The <kbd>Xsd.exe &lt;XML file&gt;</kbd> command will create a schema file. Here is an example XML file.</p>
<p>This XML file has a <kbd>Students</kbd> root element, in which information is held in relation to multiple students. Each <kbd>student</kbd> element has child elements that hold values including <kbd>FirstName</kbd>, <kbd>LastName</kbd>, <kbd>School</kbd>, and <kbd>DOB</kbd>:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;Students&gt;<br/>  &lt;student&gt;<br/>    &lt;FirstName&gt;Student1&lt;/FirstName&gt;<br/>    &lt;LastName&gt;Slast&lt;/LastName&gt;<br/>    &lt;School&gt;School1&lt;/School&gt;<br/>    &lt;DOB&gt;23/10/1988&lt;/DOB&gt;<br/>  &lt;/student&gt;<br/>&lt;/Students&gt;</pre>
<p class="mce-root"/>
<p>Visual Studio allows us to create a schema for this XML. Open the XML file in Visual Studio and select the XML menu item. The Create Schema option will become available. Selecting this will create a <kbd>.xsd</kbd> schema:</p>
<div><img src="img/7e289b05-02e1-4ff8-a351-ca8b86cc67aa.png" style=""/></div>
<p>The content of the <kbd>Sample.xsd</kbd> file is as follows:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" &gt;<br/>  &lt;xs:element name="Students"&gt;<br/>    &lt;xs:complexType&gt;<br/>      &lt;xs:sequence&gt;<br/>        &lt;xs:element name="student"&gt;<br/>          &lt;xs:complexType&gt;<br/>            &lt;xs:sequence&gt;<br/>              &lt;xs:element name="FirstName" type="xs:string" /&gt;<br/>              &lt;xs:element name="LastName" type="xs:string" /&gt;<br/>              &lt;xs:element name="School" type="xs:string" /&gt;<br/>              &lt;xs:element name="DOB" type="xs:string" /&gt;<br/>            &lt;/xs:sequence&gt;<br/>          &lt;/xs:complexType&gt;<br/>        &lt;/xs:element&gt;<br/>      &lt;/xs:sequence&gt;<br/>    &lt;/xs:complexType&gt;<br/>  &lt;/xs:element&gt;<br/>&lt;/xs:schema&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>As you can see, names are defined as a string, as are dates. So when you access this date element, we may need to convert it in order to use it in our application.</p>
<p>Now, we will jump to some sample code and observe how to validate an XML file using a schema:</p>
<pre>static void LoadXML()<br/>{<br/>    var path = new Uri(Path.GetDirectoryName(System.<br/>     Reflection.Assembly.<br/>     GetExecutingAssembly().CodeBase)).LocalPath;<br/>    XmlSchemaSet schema = new XmlSchemaSet();<br/>    schema.Add("", path + "\\sample.xsd");<br/>    XmlReader rd = XmlReader.Create(path + "\\sample.xml");<br/>    XDocument doc = XDocument.Load(rd);<br/>    Console.WriteLine("Validating XML");<br/>    doc.Validate(schema, ValidationEventHandler);<br/>    Console.WriteLine("Validating XML Completed");<br/>}<br/>static void ValidationEventHandler(object sender, <br/> ValidationEventArgs e)<br/>{<br/>    XmlSeverityType type;<br/>    if (Enum.TryParse&lt;XmlSeverityType&gt;(e.Severity.ToString(), out <br/>     type))<br/>    {<br/>        if (type == XmlSeverityType.Error) throw new <br/>         Exception(e.Message);<br/>    }<br/>}</pre>
<p>As we passed a valid XML file, we did not encounter any issues validating it. However, when you try to remove any elements from it, such as removing the school from the XML file, then you encounter an error message. Try it yourself when you practice this lab so as to understand validation in greater detail:</p>
<pre>Validating XML<br/>Validating XML Completed<br/>Press any key to exit.</pre>
<p>When executed, this method either writes a message on the console to the effect that validation is complete, or it may throw an exception in the event of an error in the XML.</p>
<p class="mce-root"/>
<p>Another format we discussed is JSON. .NET Framework provides us with JSON serializers, which can be used to validate JSON. This is like creating a C# class, using a JSON serializer to convert a C# object to JSON, and then deserializing back to the C# object. It is similar to the .NET Framework serialization concept. However, not every JSON has a schema to serialize or deserialize. In this case, we will work on validating the JSON format. In the following example, we create a class serializer to convert a JSON object and then deserialize it back to an object.</p>
<p>Here, we are creating a class called <kbd>Authors</kbd> with three properties: <kbd>AuthorName</kbd>, <kbd>Skills</kbd>, and <kbd>DOB</kbd>. We will use this object to serialize and deserialize this object:</p>
<pre>public class Authors<br/>{<br/>   public string AuthorName { get; set; }<br/>    public string Skills { get; set; }<br/>    public DateTime DOB { get; set; }<br/>}</pre>
<p>In the next section, we created a new method where we used the <kbd>Newtonsoft.Json</kbd> namespace to convert the <kbd>Authors</kbd> object to JSON. You can get <kbd>NewtonSoft.Json</kbd> using NuGet packages:</p>
<pre>static string GetJson()<br/>{<br/>    string result = string.Empty;<br/>    Authors aclass = new Authors() { AuthorName = "Author1", Skills = <br/>     "C#,Java,SQL", DOB = DateTime.Now.Date };<br/>    result = JsonConvert.SerializeObject(aclass);<br/>    Console.WriteLine($"JSON object : {result}");<br/>    return result;<br/>}</pre>
<p>Next, we will convert JSON to the <kbd>Authors</kbd> object using the <kbd>JSON.Deserialize</kbd> method:</p>
<pre>static Authors GetObject(string result)<br/>{<br/>    Authors aresult = JsonConvert.DeserializeObject&lt;Authors&gt;(result);<br/>    Console.WriteLine($"Name: {aresult.AuthorName}, Skills = <br/>     {aresult.Skills}, <br/>    DOB = {aresult.DOB}");<br/>    return aresult;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Following is the program that invokes both these methods. Initially, we invoke the <kbd>GetJSON</kbd> method to get the <kbd>Json</kbd> string, and then use this string to convert it to an <kbd>Authors</kbd> object using the <kbd>GetObject</kbd> method. In the second line, we modify the string result that we got in the first line, and try to deserialize it. This operation will throw an exception. </p>
<p>In the following, we are trying to modify the <kbd>.json</kbd> results by concatenating text called <kbd>Test</kbd>. This is what happens when you modify the <kbd>.json</kbd> object and try to deserialize it to an <kbd>Authors</kbd> object:</p>
<pre>string result = GetJson();<br/>Authors a = GetObject(result);<br/>string result1 = string.Concat(result, "Test");<br/>Console.ReadLine();<br/>Authors a1 = GetObject(result1);</pre>
<p>The following output shows the <kbd>JSON</kbd> object that we converted from the <kbd>Authors</kbd> object, followed by the <kbd>Author</kbd> object that we deserialized from the <kbd>JSON</kbd> object:</p>
<pre>JSON object : {"AuthorName":"Author1","Skills":"C#,Java,SQL","DOB":"2019-03-31T00:00:00+11:00"}<br/>Name: Author1, Skills = C#,Java,SQL, DOB = 3/31/2019 12:00:00 AM<br/>Press any key to exit.</pre>
<p>Here is the exception that the program throws when we modify <kbd>JSON</kbd> and try to deserialize it to an <kbd>Authors</kbd> object:</p>
<div><img src="img/e6e9c06d-4dc9-48a4-b810-3e0b0db40c46.png"/></div>
<p>This is an example where we try to validate a <kbd>JSON</kbd> object. If it gets modified during transmission, this can be identified during the deserialization process.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we understood the importance of validating input data; different ways of validating input data in our application, including the <kbd>Parse</kbd> and <kbd>Convert</kbd> methods; and how we can use regular expressions and the data annotations namespace. We also looked briefly at how we can validate XML and JSON input.</p>
<p>In the next chapter, we will explore ways to secure our data, such as emails, passwords, and API keys, using encryption techniques available in .NET Framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>The <kbd>Parse</kbd> method always takes the __ type as input
<ol>
<li>Any valid .NET type</li>
<li>Object</li>
<li>String</li>
<li>None</li>
</ol>
</li>
<li>When converting <kbd>DateTime</kbd> to <kbd>Double</kbd>, which exception is thrown?
<ol>
<li>No exception is thrown; instead, it gets converted successfully.</li>
<li>A Format exception is thrown.</li>
<li>An Overflow exception is thrown.</li>
<li>An Invalid cast exception is thrown.</li>
</ol>
</li>
<li>Information about members of an object can be provided using the ___________ namespace.
<ol>
<li><kbd>DataContract</kbd></li>
<li><kbd>DataAnnotations</kbd></li>
<li><kbd>System.Reflection</kbd></li>
<li><kbd>System.XML</kbd></li>
</ol>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Answers</h1>
                
            
            
                
<ol>
<li><strong>String</strong></li>
<li><strong>An</strong> <strong>Invalid cast exception is thrown</strong>.</li>
<li><kbd>DataAnnotations</kbd></li>
</ol>


            

            
        
    </body></html>