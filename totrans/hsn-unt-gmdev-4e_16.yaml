- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Immersive Realism: Achieving Fullscreen Effects with Post-Processing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created different objects, such as meshes, particles, and lights,
    to alter the visuals of our scene. But if we really want to get that slick, modern
    game look, it’s time to try our hand at some post-processing magic. We can tweak
    the settings of our objects here and there to improve our scene quality, but you
    will always feel that something is missing when comparing it with modern game
    scenes, and the thing that is missing is post-processing effects, that is, any
    effects applied after all the processing of the scene has been completed to enhance
    its visual results. In this chapter, you will learn how to apply effects to the
    final rendered frame, which will alter the look of the overall scene we have been
    creating in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following image effect concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using post-processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by seeing how we can apply post-processing to our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Using post-processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Post-processing** is a Unity feature that allows us to apply a stack of effects
    (several effects) one on top of the other to alter the final look of an image.
    Each one will affect the finished frame, changing the final image the user sees.
    In *Figure 13.1*, you can see a scene before and after applying image effects.
    You will notice a dramatic difference, but that scene doesn’t have any changes
    in its objects, including lights, particles, and meshes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The effects applied are based on a per-pixel level. Have a look at both the
    scenes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_01_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: A scene without image effects (left) and the same scene with effects
    (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the following URP post-processing concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using basic effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By mastering these URP post-processing concepts, you’ll be able to transform
    your scenes from the ordinary to the extraordinary. Let’s start preparing our
    scene to apply effects, for which we need to set up a profile.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start applying effects, we need to create a **profile**, which is an asset
    containing all the effects and settings we want to apply. This is a separate asset
    because we can share the same post-processing profile across different scenes
    and parts of scenes, as we do for the materials. When we refer to parts of scenes,
    we are referring to volumes, which are zones, regions, or areas of the game that
    have certain effects applied. We can define a global area that applies effects
    regardless of the position of the player, or we can apply different effects—for
    example, when we are outdoors or indoors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will use a global volume, one that we will use to apply a
    profile with our first effect, by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty GameObject (**GameObject | Create Empty**) named `PP Volume`
    (Post-Processing Volume).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **Volume** component to it and make sure **Mode** is set to **Global**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **New** button at the right of the **Profile** setting, which
    will generate a new `Profile` asset with the same name as the GameObject that
    was selected when clicking the button (**PP Volume** **Profile**). Move that asset
    to its own folder, which is recommended for asset organization purposes. The final
    settings are illustrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Volume component'
  prefs: []
  type: TYPE_NORMAL
- en: To test whether the volume is working, let’s add an effect. To do so, click
    the **Add Override** button and select the **Post-Processing | Chromatic Aberration**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Intensity** checkbox in the **Chromatic Aberration** effect and
    set the intensity to `0.25`, as illustrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21361_13_03_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Chromatic aberration effect'
  prefs: []
  type: TYPE_NORMAL
- en: Now, watch as the aberration effect subtly tweaks the corners of your image,
    adding a dynamic edge to the scene. Remember to look at this in the **Scene**
    panel; we will make the effect applied to the **Game** view in the next step.
    This is illustrated in the following figure:![](img/B21361_13_04_PE.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.4: Chromatic aberration applied to the scene'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you don’t see the effect, make sure that the toggle effects button is on,
    as seen in the following image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B21361_13_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 13.5: Scene view effects toggle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, if you hit **Play** and see the game from the view of the Main Camera,
    you will see that the effect is not being applied, and that’s because we need
    to check the **Post Processing** checkbox in the **Rendering** section of our
    Main Camera, as illustrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Enabling post-processing'
  prefs: []
  type: TYPE_NORMAL
- en: With our global volume set up, we’ve just unlocked the ability to consistently
    apply effects across the entire scene, no matter where our player roams.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have prepared our scene to use post-processing, we can start experimenting
    with different effects. Let’s start with the simplest ones in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using basic effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have post-processing in our scene, the only thing needed is to start
    adding effects and set them up until we have the desired look and feel. In order
    to do that, let’s explore several simple effects included in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with **Chromatic Aberration**, the one we just used, which, as
    with most image effects, tries to replicate a particular real-life effect. All
    game engine rendering systems use a simple mathematical approximation of how human
    vision really works, and because of that, we don’t have some effects that occur
    in the human eye or camera lenses. A real camera lens works by bending light rays
    to point them toward the camera sensors, but that bending is not perfect in some
    lenses (sometimes intentionally), and, hence, you can see distortion, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_07_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Image without chromatic aberration (top) and the same image with
    chromatic aberration (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This effect will be one of several that we will add to generate a cinematic
    feeling in our game, simulating the usage of real-life cameras. Of course, this
    effect won’t look nice in every kind of game; maybe a simplistic cartoonish style
    won’t benefit from this one, but you never know: art is subjective, so it’s a
    matter of trial and error.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have exaggerated the intensity a little bit in the previous example
    to make the effect more noticeable, but I would recommend using an intensity of
    `0.25` in this scenario. It is usually recommended to be gentle with the intensity
    of the effects; it’s tempting to have intense effects, but as you will be adding
    lots of them, after a while, the image will become bloated with too many distortions.
    So, try to add several subtle effects instead of a few intense ones. But, again,
    this depends on the target style you are looking for; there are no absolute truths
    here (but common sense still applies).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, before moving on to discuss other effects, if you are used to using
    other kinds of post-processing effects frameworks, you will notice that this version
    of **Chromatic Aberration** has fewer settings, and that’s because the URP version
    seeks performance, so it will be as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The next effect we are going to discuss is **Vignette**. This is another camera
    lens imperfection where the image intensity is lost at the edges of the lens.
    This can be applied not only to simulate older cameras but also to draw the attention
    of the user toward the center of the camera—for example, during cinematics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you are developing **virtual reality** (**VR**) applications, this
    can be used to reduce motion sickness by reducing the peripheral vision of the
    player. In the following screenshot, you can see an example of vignetting on an
    old camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image result for vignetting](img/B21361_13_08_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Photo taken with an old camera, with vignetting over the edges'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to try it, let’s apply some vignetting to our scene by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `PP Volume` GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **Postprocessing | Vignette** effect by clicking on the **Add Override**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Intensity** checkbox and set it to `0.3`, increasing the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Smoothness** checkbox and set it to `0.5`; this will increase the
    spread of the effect. You can see the result in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_09_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Vignette effect'
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can change the color by checking the **Color** checkbox and
    setting it to another value; in our case, black is okay to reinforce the rainy-day
    environment. Here, I invite you to check other properties, such as **Center**
    and **Rounded**. You can create nice effects just by playing with the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another effect we are going to see is **Motion Blur**, and again, it simulates
    the way the cameras work. A real camera has an exposure time: the time it needs
    to capture photons in an image. When an object moves fast enough, the same object
    is placed in different positions during that brief exposure time, so it will appear
    blurred. In the following screenshot, you can see the effect applied to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of this image, we are moving the camera up and down fast, with
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_10_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Motion Blur being applied to our scene'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to consider is that this blur will only be applied to the camera movement
    and not the movement of the objects (still camera, moving objects), due to the
    fact that this URP doesn’t support motion vectors yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this effect, follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the **Post-processing | Motion Blur** override with the **Add override**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Intensity** checkbox and set it to `0.25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rotate the camera while looking at the **Game** view (not the **Scene** view).
    You can click and drag the **X** property of **Transform** of the camera (not
    the value—the **X** label), as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_11_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Changing rotation'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this effect cannot be seen in the **Scene** view, as well as
    other effects, so take that into account before concluding the effect is not working.
    Unity does this because it would be very annoying to have that effect while working
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to briefly discuss two simple effects, **Film Grain**
    and **White Balance**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is pretty simple: add it, set the intensity to `1`, and you will
    get the famous grain effect from old movies. You can set **Type** with a different
    number of sizes to make it more subtle or harsh.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second one, **White Balance** allows you to change the color temperature,
    making colors warmer or cooler depending on how you configure it. In our case,
    we are working in a cold, dark scene, so you can add it and set the temperature
    to `-20` to adjust the appearance just slightly and improve the look and feel
    in this kind of scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When I was learning how to make my own post-processing effects, I remember
    experimenting with a dream-like transition distortion effect. To do so, I used
    the sine mathematical function to calculate the amount of horizontal distortion
    to apply based on the vertical position of the pixels. After doing so, I saw my
    framerate drop heavily, and that was the moment I realized post-processing can
    be expensive. To be fair, it was an old PC, but still, the point holds. Be careful
    about the number of postprocessing effects you add, and learn about each one to
    see how to configure it properly. You can analyze the cost of the GPU with tools
    like PIX, which analyzes the GPU performance of your application: [https://devblogs.microsoft.com/pix/download/](https://devblogs.microsoft.com/pix/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a few of the simple effects, let’s check out a few of
    the remaining ones that are affected by some advanced rendering features.
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we’re stepping up our game with some advanced effects. They’re a notch
    above what we’ve seen before, and a bit trickier, but don’t worry—we’ll guide
    you through them. In this section, we are going to see the following advanced
    effect concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: High Dynamic Range (HDR) and Depth Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying advanced effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing some requirements for some of these effects to work
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: High Dynamic Range (HDR) and depth map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the Depth Map from our last chapter? Some effects need more than just
    the rendered image; they require extra data like this to really shine. Some effects
    not only work with the rendered image but also need additional data. We can first
    discuss the Depth Map, a concept we discussed in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Depth Map is an image rendered from the point of view of the camera, but
    instead of generating a final image of the scene, it renders the scene objects’
    depth, rendering the objects in shades of gray. In a Depth Map, the rule is simple:
    the darker the shade, the further away the pixel is from the camera, and the lighter
    it is, the closer it is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see an example of a Depth Map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image result for depth buffer](img/B21361_13_12_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Notice how the varying shades of gray depict the distance from
    the camera'
  prefs: []
  type: TYPE_NORMAL
- en: We will see some effects such as **Depth of Field**, which will blur some parts
    of the image based on the distance of the camera, but it can be used for several
    purposes on custom effects (not in the base URP package).
  prefs: []
  type: TYPE_NORMAL
- en: Another concept to discuss here that will alter how colors are treated and,
    hence, how some effects work is **High Dynamic Range** (**HDR**). In older hardware,
    color channels (red, green, and blue) were encoded in a 0 to 1 range, 0 representing
    no intensity and 1 representing full intensity (per channel), so all lighting
    and color calculations were done in that range. That seems okay but doesn’t reflect
    how light actually works. You can see full white (all channels set to 1) in a
    piece of paper being lit by sunlight, and you can see full white when you look
    directly at a light bulb, but even if both light and paper are of the same color,
    the latter will, firstly, irritate the eye after a while and, secondly, have some
    overglow due to an excess of light. The problem here is that the maximum value
    (1) is not enough to represent the most intense color, so if you have a high-intensity
    light and another with even more intensity, both will generate the same color
    (1 in each channel) because calculations cannot go further than 1\. To overcome
    these limitations and capture light more realistically, **HDR Rendering** was
    created.
  prefs: []
  type: TYPE_NORMAL
- en: HDR is a way for colors to exceed the 0 to 1 range, so lighting and effects
    that work based on color intensity have better accuracy in this mode. Unity will
    do the calculations in HDR but the final image will still work using the previous
    color space (0 to 1, or **Low Dynamic Range (LDR**)), so don’t confuse Unity’s
    hdr rendering with the display’s hdr.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about HDR, check this link: [https://docs.unity3d.com/Manual/HDR.html](https://docs.unity3d.com/Manual/HDR.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the HDR calculations back to LDR, Unity (and also TVs) uses a concept
    called **tonemapping**. You can see an example of an LDR-rendered scene and tonemapping
    being used in an HDR scene in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_13_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: An LDR-rendered scene (left) and an HDR scene with corrected
    overbrights using tonemapping (right)'
  prefs: []
  type: TYPE_NORMAL
- en: Tonemapping is a way to convert colors outside the 0-1 light intensity range
    back inside this range to render them on LDR screens. It basically uses curves
    to determine how each color channel should be mapped back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picture this: you’re stepping out from a dimly lit room into the glaring afternoon
    sun. That momentary blinding effect and gradual adjustment is HDR at work. It’s
    like stepping out into bright sunlight from a dark room; at first, everything
    is too bright, but gradually, your eyes adjust—that’s tonemapping in action. The
    idea here is that calculations are not different when you are inside or outside
    the building; a white wall inside the building will have a color close to 1 intensity,
    while the same white wall outside will have a higher value (due to sunlight).
    The difference is that tonemapping will take the higher-than-1 color back to 1
    when you are outside the building, and maybe it will increase the lighting of
    the wall inside if the whole scene is darker, depending on how you set it. That
    feature is called **auto-exposure**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if HDR is enabled by default, let’s just see how we can verify if it is
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Edit | Project Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Graphics** section in the left panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the asset referenced under the **Scriptable Render Pipeline Settings**
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the highlighted asset in the **Project** panel. Ensure that this panel
    is visible before clicking the property in the **Graphics** settings. Alternatively,
    you can double-click the asset reference in the **Graphics** settings to select
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the **Quality** section, ensure that **HDR** is checked, as illustrated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_14_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Enabling HDR'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the **HDR Rendering** property of the **Camera** component in the
    **Main Camera** GameObject is set to **Use settings from Render Pipeline** to
    ensure the change in the previous steps is respected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, the fact that HDR is togglable means that there are scenarios where
    you don’t want to use it. As you can guess, not all hardware supports HDR, and
    using it incurs a performance overhead, so take that into account. Luckily, most
    effects work with both HDR and LDR color ranges, so if you have HDR enabled but
    the user device doesn’t support it, you won’t get any errors, just different results
    depending on the effect, such as brighter or darker images, or exaggerated effects,
    as we will see in the next section, *Applying advanced effects*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are sure we have HDR enabled, let’s explore some advanced effects
    that use this and depth mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Applying advanced effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see certain effects that use the previously described techniques, starting
    with the commonly used **Bloom**. This effect emulates the overglow that happens
    around a heavily lit object on a camera lens or even the human eye. In *Figure
    13.15*, you can see the difference between the default version of our scene and
    an exaggerated Bloom version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can observe how the effect is only applied to the brightest areas of our
    scene. Have a look at both effects here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_15_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: The default scene (left) and the same scene with a high-intensity
    Bloom (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This effect is actually very common and simple, but I consider it advanced
    because the results are drastically affected by HDR. This effect relies on calculating
    the intensity of each pixel’s color to detect areas where it can be applied. In
    LDR, we can have a white object that isn’t overbright, but due to the limitations
    in this color range, Bloom may cause an overglow over it. In HDR, due to its increased
    color range, we can detect if an object is white or if the object is maybe light
    blue but just overbright, generating the illusion that it is white (such as objects
    near a high-intensity lamp). In *Figure 13.16,* you can see the difference between
    our scene with HDR and without it. You will notice that the LDR version will have
    overglow in areas that are not necessarily overbright. The difference may be very
    subtle, but pay attention to the little details to note the difference. And remember,
    I exaggerated the effect here. Have a look at both scenes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_16_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: Bloom in an LDR scene (left) and Bloom in an HDR scene (right).
    Notice that the Bloom settings were changed to try to approximate them as much
    as possible'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s stick with the HDR version of the scene. In order to enable
    Bloom, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the **Bloom** override to the profile, as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **Intensity** checkbox by checking it, and set the value to `0.2`.
    This controls how much overglow will be applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **Threshold** and set it to `0.7`. This value indicates the minimum intensity
    a color needs to have to be considered for overglow. In our case, our scene is
    somewhat dark, so we need to reduce this value in the **Bloom** effect settings
    to have more pixels included. As usual, those values need to be adjusted to your
    specific scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that the difference is very subtle, but again, remember that
    you will have several effects, so all those little differences will add up. You
    can see both effects in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_17_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: Bloom effect'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, it is recommended that you fiddle with other values. Some interesting
    settings I recommend you test are the **Dirt Texture** and **Dirt Intensity**
    values, which will simulate dirty lenses in the overglow area.
  prefs: []
  type: TYPE_NORMAL
- en: Building on our understanding of Depth Maps, let’s explore another popular effect,
    **Depth of Field**. This one relies on the Depth Map we discussed earlier. It
    is not that obvious to the naked eye, but when you focus on an object within your
    sight, the surrounding objects become blurred because they are out of focus. We
    can use this to focus the attention of the player in key moments of gameplay.
    Think of this effect like a camera’s autofocus – it samples the Depth Map to decide
    what should be crisp and what should be blurred, much like focusing on an object
    in photography.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use it, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the camera near a column to try to focus on a specific object, as illustrated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_18_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: Camera positioning'
  prefs: []
  type: TYPE_NORMAL
- en: Add the **Depth of Field** override.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable and set the **Mode** setting to **Gaussian**: the cheapest one in terms
    of performance used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In my case, I have set **Start** to `10` and **End** to `20`, which will make
    the effect start at a distance behind the target object. The **End** setting will
    control how the blur’s intensity will increase, reaching its maximum at a distance
    of `20` meters. Remember to tweak these values to your case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to exaggerate the effect a little bit, set **Max Radius** to `1.5`.
    The result is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_19_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: Exaggerated effect'
  prefs: []
  type: TYPE_NORMAL
- en: Something to consider here is that our game will have a top-down perspective,
    and unlike the first-person camera where you can see distant objects, here, we
    will have objects near enough to not notice the effect, so we can limit the use
    of this effect just for cutscenes in our scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, most of the remaining effects are different ways to alter the actual colors
    of the scene. The idea is that the real color sometimes doesn’t give you the exact
    look and feel you are seeking. You may need the dark zones to be darker to reinforce
    the sensation of a horror ambiance, or you may want to do the opposite: increase
    the dark areas to represent an open scene. It could also be that you want to tint
    the highlights a little bit to get a neon effect if you are creating a futuristic
    game, or perhaps you want a sepia effect temporarily to do a flashback. We have
    a myriad of ways to do this, and in this case, I will use a simple but powerful
    effect called **Shadows Midtones Highlights**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This effect will apply different color corrections to—well—shadows, midtones,
    and highlights, meaning that we can modify darker, lighter, and medium areas separately.
    Let’s try it by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the **Shadow Midtones Highlights** override.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start doing some testing. Check the three **Shadows**, **Midtones**, and
    **Highlights** checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the **Shadows** and **Midtones** sliders all the way to the left and the
    one for **Highlights** to the right. This will reduce the intensity of shadows
    and midtones and increase the intensity of highlights. We did this so that you
    can see the areas that **Highlights** will alter, based on the intensity. You
    can do the same with the other sliders to check the other two areas. You can see
    the result in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_20_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: Isolating highlights'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, test moving the white circle at the center of the colored circle to apply
    a little bit of tinting to those areas. Reduce the intensity of the highlights
    by moving the slider a little bit to the left to make the tinting more noticeable.
    You can see the result in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_21_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: Tinting highlights'
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, you can explore how those controls work, but of course, those
    extreme values are useful for some edge cases. In our scene, the settings you
    can see in the following screenshot worked best for me. As always, it is better
    to use subtler values to not distort the original result too much, as illustrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_13_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: Subtle changes'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the before-and-after effects in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_13_23_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: Before-and-after effects'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re looking for something less complex than HDR, **Split Toning** offers
    a simpler yet effective way to play with shadows and highlights, or **Color Curves**,
    which give you advanced control of how each color channel of the scene will be
    mapped, but the idea is the same: to alter the actual color of the resulting scene
    to apply a specific color ambiance to your scene. If you remember the movie series
    *The Matrix*, when the characters were in the Matrix, everything had subtle green
    tinting, and while outside it, the tinting was blue.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the results of using HDR and not using it regarding these effects
    are important, so it is better to decide sooner rather than later whether to use
    HDR, excluding certain target platforms (which may not be important to your target
    audience), or not to use it (using LDR) and have less control over your scene
    lighting levels.
  prefs: []
  type: TYPE_NORMAL
- en: Also, take into account that maybe you will need to tweak some objects’ settings,
    such as light intensities and material properties, because sometimes we use post-processing
    to fix graphics errors that may be caused by wrongly set objects, and that’s not
    okay. For example, increasing the `ambient lighting` in our scene will drastically
    change the output of the effects, and we can use that to increase the overall
    brightness instead of using an effect if we find the scene too dark.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered a range of image effects. Remember, the idea is not to use
    every single one but to use the ones that you feel are contributing to your scene;
    they are not free in terms of performance (although not that resource-intensive),
    so use them wisely. Also, you can check for the already created profiles to apply
    them to your game and see how little changes can make a huge difference.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed basic and advanced full screen effects to apply
    in our scene, making it look more realistic in terms of camera lens effects and
    more stylish in terms of color distortions. We also discussed the internals of
    HDR and Depth Maps and how they are important when using those effects, which
    can immediately increase your game’s graphic quality with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered most of the common graphics found in Unity systems,
    let’s start looking at how to increase the immersion of our scene by using sounds
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1498477041053909218.png)'
  prefs: []
  type: TYPE_IMG
