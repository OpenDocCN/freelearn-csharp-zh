使用观察者模式解耦组件

在Unity开发中，一个常见的挑战是找到优雅的方法来解耦组件。在引擎中编写代码时，这是一个重大的障碍，因为它为我们提供了通过API和直接在检查器中引用组件的多种方式。但这种灵活性可能会带来代价，并且可能会使你的代码变得脆弱，因为在某些情况下，一个缺失的引用就足以破坏你的游戏。

因此，在本章中，我们将使用观察者模式来设置与核心组件的关系。这些关系将通过分配对象作为主题或观察者的角色来映射。这种方法不会完全消除我们组件之间的耦合，但会将其放松并逻辑化组织。它还将建立一个具有一对一结构的处理系统，这正是本章用例中需要实现的内容。

如果你正在寻找一种使用事件在多对多关系中解耦对象的方法，请查看第6章，*使用事件总线管理游戏事件*。

本章将涵盖以下主题：

+   理解观察者模式

+   使用观察者模式解耦核心组件

+   实现观察者模式

+   审查替代方案

# 技术要求

本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09)。

查看以下视频以查看代码的实际操作：[https://bit.ly/3xDlBDa](https://bit.ly/3xDlBDa)。

# 理解观察者模式

观察者模式的核心目的是在对象之间建立一对一的关系，其中一个充当主题，而其他则充当观察者。然后，主题承担通知观察者的责任，当其内部发生变化并可能影响它们时。

它与发布者和订阅者关系有些相似，其中对象订阅并监听特定事件通知。核心区别在于观察者模式中，主题和观察者彼此知晓对方，因此它们仍然轻度耦合在一起。

让我们回顾一个典型观察者模式实现的UML图，看看它在代码中实现时可能如何工作：

![](img/03b549cd-caed-4ef5-a6f2-951802a723de.png)

图9.1 – 观察者模式的UML图

如您所见，主题和观察者都有自己的接口实现，但最重要的一个是`ISubject`，它包括以下方法：

+   `AttachObserver()`: 此方法允许你将观察者对象添加到要通知的观察者列表中。

+   `DetachObserver()`: 此方法从观察者列表中移除一个观察者。

+   `NotifyObservers()`: 此方法通知所有已添加到主题观察者列表中的对象。

扮演观察者的对象必须实现一个名为 `Notify()` 的公共方法，该方法将由主题用于在它改变状态时通知它。

## 观察者模式的优缺点

这些是观察者模式的一些好处：

+   **动态性**: 观察者允许主题根据需要添加任意数量的观察者对象。但也可以在运行时动态地移除它们。

+   **一对一**: 观察者模式的主要好处是它优雅地解决了实现一个事件处理系统的问题，其中对象之间存在一对一的关系。

以下是一些观察者模式的潜在缺点：

+   **无序性**: 观察者模式不保证通知观察者的顺序。因此，如果有两个或更多观察者对象共享依赖项并且必须按特定顺序一起工作，那么观察者模式在其原生形式中并不是为处理这种执行上下文而设计的。

+   **泄漏**: 观察者可能导致内存泄漏，因为主题对其观察者持有强引用。如果实现不当，并且观察者对象在不再需要时没有正确地分离和释放，它可能会引起垃圾收集问题，并且某些资源将不会被释放。

要了解此处指出的潜在内存泄漏缺陷，我建议阅读以下关于该主题的维基百科文章：[https://en.wikipedia.org/wiki/Lapsed_listener_problem](https://en.wikipedia.org/wiki/Lapsed_listener_problem)。

但请注意，与任何与优化相关的内容一样，它是上下文相关的，因此你应该在优化潜在的性能问题之前对代码进行性能分析。

## 何时使用观察者模式

观察者模式的优势在于它解决了与对象之间一对一关系相关的特定问题。因此，如果你有一个核心组件经常改变状态并且有许多依赖项需要对这些变化做出反应，那么观察者模式允许你定义这些实体之间的关系以及一个使它们能够被通知的机制。

因此，如果你不确定何时使用观察者模式，你应该分析你对象之间的关系，以确定这种模式是否适合你试图解决的问题。

# 使用观察者模式解耦核心组件

我们游戏的核心元素是赛车。它是场景中状态变化最频繁的实体，因为它在玩家控制下在世界各地移动并与其他实体交互时，经常更新其属性。它有多个依赖项需要管理，例如跟随它的主摄像头和显示其当前速度的用户界面。

竞速自行车是我们游戏的主要主题，许多系统必须观察它，以便在它状态改变时更新自己。例如，每次自行车与障碍物碰撞时，HUD 必须更新护盾当前的健康值，而相机则显示一个全屏着色器，使屏幕边缘变暗，以展示减少的耐力。

在 Unity 中实现这种行为很容易。我们可以让 `BikeController` 告诉 `HUDController` 和 `CameraController` 当它受到伤害时应该做什么。但为了使这种方法有效，`BikeController` 必须知道在各个控制器上调用哪些公共方法。

如你所想，这并不容易扩展，因为随着 `BikeController` 的复杂性增加，我们需要管理的对其依赖的调用也会增多。但有了观察者模式，我们将打破控制器之间的这种耦合。首先，我们将给每个组件分配一个角色；`BikeController` 将成为主题，并负责管理依赖列表并在必要时通知它们。

HUD 和相机控制器将作为 `BikeController` 的观察者。它们的核心责任是监听来自 `BikeController` 的通知并相应地行动。`BikeController` 并不告诉它们做什么；它只是告诉它们有变化发生，并让它们自行决定如何反应。

以下图表说明了我们刚刚讨论的概念：

![图片](img/da2d43e3-3686-46c3-aafa-57d46f4aaa09.png)

图9.2 – 控制器观察主题的示意图

如我们所见，我们可以有任意数量的控制器观察自行车（主题）。在下一节中，我们将把这些概念转化为代码。

# 实现观察者模式

现在，让我们以简单且可重用的方式实现观察者模式，以便在各种场景中使用：

1.  我们将从这个代码示例开始，实现模式的两个元素。让我们从 `Subject` 类开始：

[PRE0]

`Subject` 抽象类有三个方法。前两个方法，`Attach()` 和 `Detach()`，分别负责将观察者对象添加到观察者列表或从列表中移除。第三个方法 `NotifyObservers()` 负责遍历观察者对象列表，并调用它们的公共方法，即 `Notify()`。在接下来的步骤中实现具体的观察者类时，这一点将变得有意义。

1.  接下来是 `Observer` 抽象类：

[PRE1]

希望成为观察者的类必须继承这个 `Observer` 类并实现名为 `Notify()` 的抽象方法，该方法接收主题作为参数。

1.  现在我们已经有了核心成分，让我们编写一个作为主题的 `BikeController` 类的骨架。然而，因为它太长了，我们将将其分成三个部分。第一部分只是初始化代码：

[PRE2]

下面的部分很重要，因为我们是在 `BikeController` 启用时附加我们的观察者，并在它禁用时解除它们；这避免了我们保留不再需要的引用：

[PRE3]

对于最后一部分，我们有一些核心行为的初步实现。请注意，我们只在自行车参数更新时通知观察者，例如它受到伤害或涡轮增压器激活时：

[PRE4]

`BikeController` 从不直接调用 `HUDController` 或 `CameraController`；它只通知它们有变化——它从不告诉它们该做什么。这很重要，因为观察者可以独立选择在收到通知时的行为。因此，它们在一定程度上与主题解耦。

1.  现在，让我们实现一些观察者并观察它们在主题发出信号时的行为。我们将从 `HUDController` 开始，它负责显示用户界面：

[PRE5]

`HUDController` 的 `Notify()` 方法接收一个指向通知它的主题的引用。因此，它可以访问其属性并选择在界面中显示哪一个。

1.  最后，我们将实现 `CameraController`。相机的预期行为是在自行车涡轮增压器激活时开始晃动：

[PRE6]

`CameraController` 检查刚刚通知它的主题的公共布尔属性，如果为真，则开始晃动相机，直到再次被 `BikeController` 通知并确认涡轮增压开关关闭。

这个实现的要点是记住，`BikeController`（**主题**）并不知道一旦它们被通知，HUD 和相机控制器（**观察者**）会如何行为。因此，观察者可以选择如何响应主题的变更通知。

这种方法将这些控制器组件彼此解耦。因此，单独实现和调试它们要容易得多。

## 测试观察者模式实现

为了测试我们的实现，我们必须做以下事情：

1.  打开一个空的 Unity 场景，但确保它至少包含一个相机和一个光源。

1.  将一个 3D GameObject，例如一个立方体，添加到场景中，并使其对相机可见。

1.  将 `BikeController` 脚本作为组件附加到新的 3D 对象。

1.  将 `CameraController` 脚本附加到主场景相机。

1.  创建一个空的 GameObject，将其添加以下 `ClientObserver` 脚本，然后开始场景：

[PRE7]

我们应该在屏幕上看到类似于以下内容的 GUI 按钮和标签：

![](img/168bc28d-38b6-45bb-b13c-e144af66e6ba.png)

图 9.3 – 运行中的 Unity 场景中的 GUI 元素

如果我们按下涡轮增压按钮，我们会看到相机晃动，HUD 显示涡轮增压器的状态。而“损坏自行车”按钮会减少自行车的健康值。

实现观察者模式有许多不同的方法，每种方法都有其固有的优点。我无法在本章中涵盖所有这些方法。因此，出于教育目的，我编写了本章中的代码示例。因此，这并不是最优化方法，但是一种易于理解的方法。

# 审查替代解决方案

观察者模式的替代方案是本地的 C# 事件系统。这个事件系统的一个显著优点是它比观察者模式更细粒度，因为对象可以监听另一个对象发出的特定事件，而不是从主体获得一般通知。

如果您需要组件通过事件进行交互，尤其是如果您不需要在它们之间建立特定关系时，应始终考虑使用本地事件系统。

Unity 有自己的本地事件系统；它与 C# 版本非常相似，但增加了引擎功能，例如通过检查器连接事件和动作的能力。要了解更多信息，请访问 [https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html](https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html)。

# 摘要

在本章中，我们学习了如何通过将它们分配为主体或观察者的角色来使用观察者模式将`BikeController`与其依赖项解耦。现在我们的代码更容易管理和扩展，因为我们能够轻松地将`BikeController`与其他控制器进行交互，而耦合度最小。

在下一章中，我们将探讨访问者模式，这是最难学习的一种模式。我们将使用它来构建增强功能，这是我们游戏的核心机制和成分。
