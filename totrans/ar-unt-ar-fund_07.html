<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer079">
			<h1 id="_idParaDest-110"><em class="italic"><a id="_idTextAnchor119"/>Chapter 5</em>: Using the AR User Framework</h1>
			<p>In this chapter, we will learn how to use the <strong class="bold">Augmented Reality</strong> (<strong class="bold">AR</strong>) user framework that we set up in the previous chapter, <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">, Creating an AR User Framework</em>. Starting with the <strong class="source-inline">ARFramework</strong> scene template, we will add a main menu for placing virtual objects in the environment. If you skipped that chapter or just read through it, you can find the scene template and assets in the files provided on this book's GitHub repository.</p>
			<p>For this project, we'll extend the framework with a new <em class="italic">PlaceObject-mode</em> that prompts the user to tap to place a virtual object in the room. The user will have a choice of objects from the main menu. </p>
			<p>In the latter half of the chapter, I'll discuss some advanced AR application issues including making an AR-optional project, determining whether a device supports a specific AR feature, and adding localization to your <strong class="bold">User Interface </strong>(<strong class="bold">UI</strong>).</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Planning the project</li>
				<li>Starting with the ARFramework scene template</li>
				<li>Adding a main menu</li>
				<li>Adding PlaceObject mode and instructional UI</li>
				<li>Wiring the menu buttons</li>
				<li>Doing a Build And Run</li>
				<li>Hiding tracked objects when not needed</li>
				<li>Making an AR-optional project</li>
				<li>Determining whether a device supports specific AR features at runtime</li>
				<li>Adding localization features to a project</li>
			</ul>
			<p>By the end of the chapter, you'll be more familiar with the AR user framework developed for this book, which we'll use in subsequent chapters as we build a variety of different AR application projects.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>To implement the project in this chapter, you need Unity installed on your development computer, with a mobile device connected that supports AR applications (see <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up for AR Development,</em> for instructions), including the following:</p>
			<ul>
				<li>Universal Render Pipeline</li>
				<li>Input System package</li>
				<li>XR Plugin for your target device</li>
				<li>AR Foundation package</li>
			</ul>
			<p>We assume you have installed the assets from the Unity <strong class="bold">arfoundation-samples</strong> project imported from <strong class="source-inline">ARF-samples.unitypackage</strong> created in <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">, Your First AR Scene</em>. </p>
			<p>Also from <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Your First AR Scene,</em> we created an <strong class="bold">AR Input Actions</strong> asset that we'll use in this project, containing an <strong class="bold">action map</strong> named <strong class="bold">ARTouchActions</strong> including (at least) a <strong class="bold">PlaceObject</strong> action. </p>
			<p>We also assume you have the <strong class="source-inline">ARFramework</strong> scene template created in <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">, Creating an AR User Framework</em>, along with all the prerequisite Unity packages detailed at the beginning of <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic"> Creating an AR User Framework</em>. A copy of the template and assets can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation">https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation</a> (not including the third-party packages that you should install yourself). </p>
			<p>The AR user framework requires the following prerequisites, as detailed in <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">, Creating an AR User Framework</em>, including the following:</p>
			<ul>
				<li>The Addressables package</li>
				<li>The Localization package</li>
				<li>TextMesh Pro</li>
				<li>The DOTween package from the Asset Store</li>
				<li>The Serialized Dictionary Lite package from the Asset Store</li>
			</ul>
			<p>The completed scene for this chapter can also be found in the GitHub repository.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor121"/>Planning the project </h1>
			<p>For this project, we'll create<a id="_idIndexMarker409"/> a simple demo AR scene starting with the <strong class="source-inline">ARFramework</strong> scene template and building up the user framework structure we have set up. </p>
			<p>With the framework, when the app first starts, Startup-mode is enabled and the AR Session is initialized. Once the session is ready, it transitions to Scan-mode.</p>
			<p>If the AR Session determines that the current device does not support AR, Scan-mode will transition to NonAR-mode instead. Presently this just puts a text message on the screen. See the <em class="italic">Making an AR-optional project</em> section near the end of this chapter for more information. </p>
			<p>In Scan-mode, the user is prompted to use their device camera to slowly scan the room until AR features are detected, namely, horizontal planes. The <strong class="bold">ScanMode</strong> script checks for any tracked planes and then transitions to Main-mode.</p>
			<p>Given this, our plan is to add the following features:</p>
			<ul>
				<li>The AR session will be configured to detect and track horizontal planes. We'll also render point clouds.</li>
				<li>Main-mode will show a main menu with buttons that lets the user choose objects to place in the real-world environment. You can find your own models to use here, but we'll include three buttons for a cube, a sphere, and a virus (created in <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">, Your First AR Scene</em>). </li>
				<li>When a place-object button is selected, it will enable a new PlaceObject-mode that prompts the user to tap to place the objects onto a detected plane.</li>
				<li>Tapping on a tracked horizontal plane will create an instance of the object in the scene. The app then goes back to Main-mode.</li>
				<li>Tracked AR features (planes and point clouds) will be hidden in Main-mode, and visible in PlaceObject-mode.</li>
			</ul>
			<p>I have chosen<a id="_idIndexMarker410"/> to provide a cube, a sphere, and a virus (the virus model was created in <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">, Your First AR Scene</em>). Feel free to find and use your own models instead. The prefab assets I will be using are the following:</p>
			<ul>
				<li><strong class="bold">AR Placed Cube</strong> (found in the <strong class="source-inline">Assets/ARF-samples/Prefabs/</strong> folder)</li>
				<li><strong class="bold">AR Placed Sphere</strong> (found in the <strong class="source-inline">Assets/ARF-samples/Prefabs/</strong> folder)</li>
				<li><strong class="bold">Virus</strong> (found in <strong class="source-inline">Assets/_ARFBookAssets/Chapter02/Prefabs/</strong> folder)</li>
			</ul>
			<p>This is a simple AR demo that will help you become more familiar with the AR user framework we developed and will use in subsequent projects in this book. </p>
			<p>Let's get started.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor122"/>Starting with the ARFramework scene template</h1>
			<p>To begin, we'll create a new scene<a id="_idIndexMarker411"/> named <strong class="source-inline">FrameworkDemo</strong> using the <strong class="source-inline">ARFramework</strong> scene template, using the following steps:</p>
			<ol>
				<li>Select <strong class="bold">File | New Scene</strong>.</li>
				<li>In the <strong class="bold">New Scene</strong> dialog box, select the <strong class="bold">ARFramework</strong> template.</li>
				<li>Press <strong class="bold">Create</strong>. </li>
				<li>Select <strong class="bold">File | Save As</strong>. Navigate to the <strong class="source-inline">Scenes/</strong> folder in your project's <strong class="source-inline">Assets</strong> folder, give it the name <strong class="source-inline">FrameworkDemo</strong>, and press <strong class="bold">Save</strong>. <p class="callout-heading">Note: Unintended clone dependencies</p><p class="callout">When creating a new scene from<a id="_idIndexMarker412"/> a scene template, if you're prompted right away for a name to save the file under, this indicates your scene template has some clone dependencies defined. If this is not your intention, cancel the creation, select the template asset in your Project window, and ensure all the <strong class="bold">Clone</strong> checkboxes are cleared in the <strong class="bold">Dependencies</strong> list. Then try creating your new scene again.</p></li>
			</ol>
			<p>The new AR scene already has the following game objects included from the template:</p>
			<ul>
				<li>The <strong class="bold">AR Session</strong> game object</li>
				<li>The <strong class="bold">AR Session Origin</strong> rig with the raycast manager and plane manager components.</li>
				<li> <strong class="bold">UI Canvas</strong> is a screen<a id="_idIndexMarker413"/> space canvas with Startup UI, Scan UI, Main UI, and NonAR UI child panels. It also has the UI Controller component script that we wrote.</li>
				<li><strong class="bold">Interaction Controller</strong> is a game object with the Interaction Controller component script we wrote that helps the app switch between interaction modes, including Startup, Scan, Main, and NonAR modes. It also has a <strong class="bold">Player Input</strong> component configured with the <strong class="bold">AR Input Actions</strong> asset we previously created.</li>
				<li>The <strong class="bold">OnboardingUX</strong> prefab from the AR Foundation Demos project that provides AR session status and feature detection status messages, and animated onboarding graphics prompts.</li>
			</ul>
			<p>Set up the app title now as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong> object, and unfold its child <strong class="bold">App Title Panel</strong>.</li>
				<li>Select the <strong class="bold">Title Text</strong> object.</li>
				<li>In its <strong class="bold">Inspector</strong>, change its text content to <strong class="source-inline">Place Object Demo</strong>.</li>
			</ol>
			<p>The default AR Session Origin already has an AR Plane Manager component. Let's ensure it's only detecting horizontal planes. Let's add a point cloud visualization too. Follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, set the <strong class="bold">AR Plane Manager | Detection Mode</strong> to <strong class="bold">Horizontal</strong> by first selecting <strong class="bold">Nothing</strong> (to clear the list) and then selecting <strong class="bold">Horizontal</strong>.</li>
				<li>Click the <strong class="bold">Add Component</strong> button, search for <strong class="source-inline">ar point cloud</strong>, then add an <strong class="bold">AR Point Cloud Manager</strong> component.</li>
				<li>Find a point cloud visualizer prefab and set the <strong class="bold">Point Cloud Prefab</strong> slot (for example, <strong class="bold">AR Point Cloud Debug Visualizer</strong> can be found in the <strong class="source-inline">Assets/ARF-samples/Prefabs/</strong> folder).</li>
				<li>Save your work with <strong class="bold">File | Save</strong>.</li>
			</ol>
			<p>We've created<a id="_idIndexMarker414"/> a new scene based on the ARFramework template and added AR trackables managers for point clouds and horizontal planes. Next, we'll add the main menu.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor123"/>Adding a main menu</h1>
			<p>The main menu<a id="_idIndexMarker415"/> UI resides<a id="_idIndexMarker416"/> under the Menu UI panel (under UI Canvas) in the scene hierarchy. We will add a menu panel with three buttons to let you add a cube, a sphere, and a virus. We'll create a menu sub-panel and arrange the menu buttons horizontally. Follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong>, unfold the <strong class="bold">UI Canvas</strong>, and unfold its child <strong class="bold">Main UI</strong> object.</li>
				<li>First, remove the temporary <strong class="bold">Main</strong> mode text element. <em class="italic">Right-click</em> the child <strong class="bold">Text</strong> object and select <strong class="bold">Delete</strong>.</li>
				<li><em class="italic">Right-click</em> the <strong class="bold">Menu UI </strong>and select <strong class="bold">UI | Panel</strong>, then rename it <strong class="source-inline">Main Menu</strong>.</li>
				<li>On the <strong class="bold">Main Menu</strong> panel, use the <strong class="bold">Anchor Presets</strong> to set <strong class="bold">Bottom-Stretch</strong>, and use <em class="italic">Shift + Alt +</em> click <strong class="bold">Bottom-Stretch</strong> to make a bottom panel. Then set <strong class="bold">Rect Transform | Height</strong> to <strong class="source-inline">175</strong>.</li>
				<li>I set my background <strong class="bold">Image | Color</strong> to opaque white with <strong class="bold">Alpha:</strong> <strong class="source-inline">255</strong>.</li>
				<li>Select <strong class="bold">Add Component</strong>, search <strong class="source-inline">layout</strong>, then select <strong class="bold">| Horizontal Layout Group</strong>.</li>
				<li>On the <strong class="bold">Horizontal Layout Group</strong> component<a id="_idIndexMarker417"/> check<a id="_idIndexMarker418"/> the <strong class="bold">Control Child Size | Width</strong> and <strong class="bold">Height</strong> checkboxes (leave the others at their default values, <strong class="bold">Use Child Scale</strong> unchecked, and <strong class="bold">Child Force Expand</strong> checked). The Main Menu panel looks like this in the Inspector:</li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="Images/Figure_5.01-MainMenu-insp.jpg" alt="Figure 5.1 – The Main Menu panel settings&#13;&#10;" width="820" height="512"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The Main Menu panel settings</p>
			<p>Now we'll add three buttons to the menu using the following steps:</p>
			<ol>
				<li value="1"><em class="italic">Right-click</em> the <strong class="bold">Main Menu</strong>, select <strong class="bold">UI | Button – TextMeshPro</strong>, and rename it to <strong class="source-inline">Cube Button</strong>.</li>
				<li>Select its child text object, and set the <strong class="bold">Text</strong> value to <strong class="source-inline">Cube</strong> and <strong class="bold">Font Size</strong> to <strong class="source-inline">48</strong>.</li>
				<li><em class="italic">Right-click</em> the <strong class="bold">Cube Button</strong> and select <strong class="bold">Duplicate</strong> (or press <em class="italic">Ctrl + D</em>). Rename it <strong class="source-inline">Sphere Button</strong> and change its text to <strong class="source-inline">Sphere</strong>.</li>
				<li>Repeat <em class="italic">step 3</em> again, renaming it <strong class="source-inline">Virus Button</strong>, and changing the text to <strong class="source-inline">Virus</strong>.</li>
			</ol>
			<p>The resulting<a id="_idIndexMarker419"/> scene<a id="_idIndexMarker420"/> hierarchy of the Main Menu is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="Images/Figure_5.02-mainmenu-hier.jpg" alt="" width="199" height="208"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.2 – Main Menu hierarchy</p>
			<p>I decided to go further and add a sprite image of each model to the buttons. I created the images by screen-capturing a view of each model, edited them with Photoshop, saved them as PNG files, and in Unity made sure the image's <strong class="bold">Texture Type</strong> is set to <strong class="bold">Sprite (2D and UI)</strong>. I then added a child <strong class="bold">Image</strong> element to the buttons. The result is as shown in the following image of my menu:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="Images/Figure_5.03-mainmenu-iconbuttons.jpg" alt="Figure 5.3 – Main Menu with icon buttons&#13;&#10;" width="432" height="106"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Main Menu with icon buttons</p>
			<p>Thus far we have created a Main Menu panel with menu buttons under the Main UI. When the app goes into Main-mode, this menu will be displayed.</p>
			<p>Next, we'll add a UI panel that prompts the user to tap the screen to place an object into the scene.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor124"/>Adding PlaceObject-mode with instructional UI</h1>
			<p>When the user<a id="_idIndexMarker421"/> picks<a id="_idIndexMarker422"/> an object from the main menu, the app will enable PlaceObject-mode. For this mode, we need a UI panel to prompt the user to tap the screen to place the object. Let's create the UI panel first.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor125"/>Creating the PlaceObject UI panel</h2>
			<p>The <strong class="bold">PlaceObject UI</strong> panel<a id="_idIndexMarker423"/> should be similar to the <strong class="bold">Scan UI</strong> one, so we can duplicate and modify it using the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong>.</li>
				<li><em class="italic">Right-click</em> the <strong class="bold">Scan UI</strong> game object and select <strong class="bold">Duplicate</strong>. Rename the new object <strong class="source-inline">PlaceObject UI</strong>.</li>
				<li>Unfold <strong class="bold">PlaceObject UI</strong> and select its child <strong class="bold">Animated Prompt</strong>.</li>
				<li>In the <strong class="bold">Inspector</strong>, set the <strong class="bold">Animated Prompt | Instruction</strong> to <strong class="bold">Tap To Place</strong>. The resulting component is shown in the following screenshot:<div id="_idContainer071" class="IMG---Figure"><img src="Images/Figure_5.04-placeobjectui-insp.jpg" alt="Figure 5.4 – Animated Prompt settings for the PlaceObject UI panel&#13;&#10;" width="542" height="94"/></div><p class="figure-caption">Figure 5.4 – Animated Prompt settings for the PlaceObject UI panel</p></li>
				<li>Now we add the panel to the UI Controller.<p>In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">UI Canvas</strong> object.</p></li>
				<li>In the <strong class="bold">Inspector</strong>, at<a id="_idIndexMarker424"/> the bottom-right of the <strong class="bold">UI Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the UI Panels dictionary.</li>
				<li>Enter <strong class="source-inline">PlaceObject</strong> as text in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">PlaceObject UI</strong> game object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Value</strong> slot. The UI Controller component now looks like the following:</li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="Images/Figure_5.05-uicontroller-insp.jpg" alt="Figure 5.5 – UI Controller's UI Panels list with PlaceObject added&#13;&#10;" width="422" height="347"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – UI Controller's UI Panels list with PlaceObject added</p>
			<p>We added<a id="_idIndexMarker425"/> an instructional user prompt for the <strong class="bold">PlaceObject</strong> UI. When the user chooses to add an object to the scene, this panel will be displayed. Next, we'll add the <strong class="bold">PlaceObject</strong> mode and script.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor126"/>Creating the PlaceObject mode</h2>
			<p>To add a mode<a id="_idIndexMarker426"/> to the framework, we create a child GameObject under the <strong class="bold">Interaction Controller</strong> and write a mode script. The mode script will show the mode's UI, handle any user interactions, and then transition to another mode when it is done. For PlaceObject-mode, it will display the <strong class="bold">PlaceObject UI </strong>panel, wait for the user to tap the screen, instantiate the prefab object, and then return to Main-mode. </p>
			<p>Let's write<a id="_idIndexMarker427"/> the <strong class="source-inline">PlaceObjectMode</strong> script as follows:</p>
			<ol>
				<li value="1">Begin by creating a new script in your <strong class="bold">Project</strong> <strong class="source-inline">Scripts/</strong> folder using <em class="italic">right-click</em> <strong class="bold">| Create C# Script</strong>, and name the script <strong class="source-inline">PlaceObjectMode</strong>.</li>
				<li><em class="italic">Double-click</em> the file to open it for editing and replace the default content, starting with the following declarations:<p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.InputSystem;</p><p class="source-code">using UnityEngine.XR.ARFoundation;</p><p class="source-code">using UnityEngine.XR.ARSubsystems;</p><p class="source-code">public class PlaceObjectMode : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">   [SerializeField] ARRaycastManager raycaster;</p><p class="source-code">    GameObject placedPrefab;</p><p class="source-code">    List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();</p><p>The script will use APIs from <strong class="source-inline">ARFoundation</strong> and <strong class="source-inline">ARSubsystems</strong> so we specify these in the <strong class="source-inline">using</strong> statements at the top of the script. It will use the <strong class="source-inline">ARRaycastManager</strong> to determine which tracked plane the user has tapped. Then it will instantiate the <strong class="source-inline">placedPrefab</strong> into the scene. </p></li>
				<li>When the mode<a id="_idIndexMarker428"/> is enabled, we will show the <strong class="bold">PlaceObject UI</strong> panel:<p class="source-code">    void OnEnable()</p><p class="source-code">    {</p><p class="source-code">        UIController.ShowUI("PlaceObject");</p><p class="source-code">    }</p></li>
				<li>When the user selects an object from the Main Menu, we need to tell <strong class="source-inline">PlaceObjectMode</strong> which prefab to instantiate, given the following code:<p class="source-code">    public void SetPlacedPrefab(GameObject prefab)</p><p class="source-code">    {</p><p class="source-code">        placedPrefab = prefab;</p><p class="source-code">    }</p></li>
				<li>Then when the user taps the screen, the Input System triggers an <strong class="source-inline">OnPlaceObject</strong> event (given the <strong class="bold">AR Input Actions</strong> asset we previously set up), using the following code:<p class="source-code">    public void OnPlaceObject(InputValue value)</p><p class="source-code">    {</p><p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p><p class="source-code">        PlaceObject(touchPosition);</p><p class="source-code">    }</p><p class="source-code">    void PlaceObject(Vector2 touchPosition)</p><p class="source-code">    {</p><p class="source-code">        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))</p><p class="source-code">        {</p><p class="source-code">            Pose hitPose = hits[0].pose;</p><p class="source-code">            Instantiate(placedPrefab, hitPose.position,                hitPose.rotation);</p><p class="source-code">            InteractionController.EnableMode("Main");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>When a touch event<a id="_idIndexMarker429"/> occurs, we pass the <strong class="source-inline">touchPosition</strong> to the <strong class="source-inline">PlaceObject</strong> function, which does a <strong class="source-inline">Raycast</strong> to find the tracked horizontal plane. If found, we <strong class="source-inline">Instantiate</strong> the <strong class="source-inline">placedPrefab</strong> at the <strong class="source-inline">hitPose</strong> location and orientation. And then the app returns to Main-mode.</p></li>
				<li>Save the script and return to Unity.</li>
			</ol>
			<p>We can now add the mode to the Interaction Controller as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, right-click the <strong class="bold">Interaction Controller</strong> game object and select <strong class="bold">Create Empty</strong>. Rename the new object <strong class="source-inline">PlaceObject Mode</strong>.</li>
				<li>Drag the <strong class="bold">PlaceObjectMode</strong> script from the <strong class="bold">Project</strong> window onto the <strong class="bold">PlaceObject</strong> <strong class="bold">Mode</strong> object adding it as a component.</li>
				<li>Drag the <strong class="bold">AR Session Origin</strong> object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Place Object Mode | Raycaster</strong> slot.<p>Now we'll add the mode to the <strong class="bold">Interaction Controller</strong>.</p></li>
				<li>In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Interaction Controller</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, at the bottom-right of the <strong class="bold">Interaction Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the <strong class="bold">Interaction Modes</strong> dictionary.</li>
				<li>Enter the <strong class="source-inline">PlaceObject</strong> text in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">PlaceObject Mode</strong> game<a id="_idIndexMarker430"/> object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Value</strong> slot. The <strong class="bold">Interaction Controller</strong> component now looks like the following:</li>
			</ol>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="Images/Figure_5.06-interactionmodes-insp.jpg" alt="Figure 5.6 – The Interaction Controller's Interaction Modes list with PlaceObject added&#13;&#10;" width="497" height="343"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – The Interaction Controller's Interaction Modes list with PlaceObject added</p>
			<p>We have now added a <strong class="bold">PlaceObject Mode</strong> to our framework. It will be enabled by the Interaction Controller when <strong class="bold">EnableMode("PlaceObject")</strong> is called by another script or, in our case, by a main menu button. When enabled, the script shows the <strong class="bold">PlaceObject</strong> instructional UI, then listens for an <strong class="source-inline">OnPlaceObject</strong> input action event. Upon the input event, we use Raycast to determine where in the 3D space the user wants to place the object, then the script instantiates the prefab and returns to Main-mode.</p>
			<p>The final step is to wire up the main menu buttons.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor127"/>Wiring the menu buttons</h1>
			<p>When the user presses<a id="_idIndexMarker431"/> a main menu button to add an object to the scene, the button will tell <strong class="source-inline">PlaceObjectMode</strong> which prefab is to be instantiated. Then PlaceObject mode is enabled, which prompts the user to tap to place the object and handles the user input action. Let's set up the menu buttons now using the following steps:</p>
			<ol>
				<li value="1">Unfold the <strong class="bold">Main Menu</strong> game object in the <strong class="bold">Hierarchy</strong> by navigating to <strong class="bold">UI Canvas / Main UI / Main Menu</strong> and select the <strong class="bold">Cube Button</strong> object.</li>
				<li>In its <strong class="bold">Inspector</strong>, on the <strong class="bold">Button</strong> component, in its <strong class="bold">OnClick</strong> section, press the <strong class="bold">+</strong> button in the bottom right to add an event action.</li>
				<li>From the <strong class="bold">Hierarchy</strong>, drag the <strong class="bold">PlaceObject Mode</strong> object onto the <strong class="bold">OnClick Object</strong> slot.</li>
				<li>In the <strong class="bold">Function</strong> selection list, choose <strong class="bold">PlaceObject Mode | SetPlacedPrefab</strong>.</li>
				<li>In the <strong class="bold">Project</strong> window, locate a cube model prefab to use. For example, navigate to your <strong class="source-inline">Assets/ARF-samples/Prefabs/</strong> folder and drag the <strong class="bold">AR Placed Cube</strong> prefab into the <strong class="bold">Game Object</strong> slot for this click event in <strong class="bold">Inspector</strong>.</li>
				<li>Now let the button enable PlaceObject Mode. In its <strong class="bold">Inspector</strong>, on the <strong class="bold">Button</strong> component, in its <strong class="bold">OnClick</strong> section, press the <strong class="bold">+</strong> button in the bottom right to add another event action.</li>
				<li>From the <strong class="bold">Hierarchy</strong>, drag the <strong class="bold">Interaction Controller</strong> object onto the <strong class="bold">OnClick</strong> event's <strong class="bold">Object</strong> slot.</li>
				<li>In the <strong class="bold">Function</strong> selection list, choose <strong class="bold">InteractionController | EnableMode</strong>.</li>
				<li>In the string parameter field, enter <strong class="source-inline">PlaceObject</strong>.</li>
			</ol>
			<p>The Cube Button object's Button component now has the following <strong class="bold">OnClick</strong> event settings:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/Figure_5.07-cubebutton-onclick-insp.jpg" alt="Figure 5.7 – The OnClick events for the Cube Button&#13;&#10;" width="444" height="143"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – The OnClick events for the Cube Button</p>
			<p>Repeat<a id="_idIndexMarker432"/> these steps for the Sphere Button and Virus Button. As a shortcut we can copy/paste the component settings as follows:</p>
			<ol>
				<li value="1">With the <strong class="bold">Cube Button</strong> selected in the <strong class="bold">Hierarchy</strong>, over in the <strong class="bold">Inspector</strong>, click the three-dot context menu for the <strong class="bold">Button</strong> component, and select <strong class="bold">Copy Component</strong>.</li>
				<li>In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Sphere Button</strong> object.</li>
				<li>In its <strong class="bold">Inspector</strong>, click the three-dot context menu for the <strong class="bold">Button</strong> component, and select <strong class="bold">Paste Component Values</strong>.</li>
				<li>In the <strong class="bold">Project</strong> window, locate a sphere model prefab to use. For example, navigate to your <strong class="source-inline">Assets/ARF-samples/Prefabs/</strong> folder and drag the <strong class="bold">AR Placed Sphere</strong> prefab into the <strong class="bold">Game Object</strong> slot for this click event in <strong class="bold">Inspector</strong>.</li>
				<li>Likewise, repeat <em class="italic">steps 1-4</em> for the <strong class="bold">Virus Button</strong>, and set the GameObject to the <strong class="bold">Virus</strong> prefab (perhaps located in your own <strong class="source-inline">Prefabs</strong> folder).</li>
				<li>Save your work using <strong class="bold">File | Save</strong>.</li>
			</ol>
			<p>Everything should be set up now. We created a new scene using the <strong class="bold">ARFramework</strong> template, added a main menu with buttons, added the PlaceObject-mode with instructional user prompt, wrote the <strong class="source-inline">PlaceObjectMode</strong> script that handles user input actions and instantiates the prefab, and wired it all up to the main menu buttons. Let's try it out!</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor128"/>Performing a Building and Run</h1>
			<p>To build<a id="_idIndexMarker433"/> and<a id="_idIndexMarker434"/> run the project, use the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Build Settings</strong> window using <strong class="bold">File | Build Settings</strong>.</li>
				<li>Click the <strong class="bold">Add Open Scenes</strong> button if the current scene (<strong class="source-inline">FrameworkDemo</strong>) is not already in the <strong class="bold">Scenes In Build</strong> list.</li>
				<li>Ensure that the <strong class="source-inline">FrameworkDemo</strong> scene is the only one checked in the <strong class="bold">Scenes In Build</strong> list.</li>
				<li>Click <strong class="bold">Build And Run</strong> to build the project.</li>
			</ol>
			<p>When the project builds successfully, it starts up in Startup-mode while the AR Session is initializing. Then it goes into Scan-mode that prompts the user to scan the environment, until at least one horizontal plane is detected and tracked. Then it goes into Main-mode and displays the main menu. Screen captures of the app running on my phone in each of these modes are shown in the following figure:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="Images/Figure_5.08-app-1-3.jpg" alt="Figure 5.8 – Screen captures of Startup-mode, Scan-mode, and Main-mode&#13;&#10;" width="1628" height="1054"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Screen captures of Startup-mode, Scan-mode, and Main-mode</p>
			<p>On pressing one of the menu buttons, the app goes into PlaceObject-mode, prompting the user to tap to place an object. Tapping the screen instantiates the object at the specified location in the environment. Then the app returns to Main-mode. </p>
			<p>We now have<a id="_idIndexMarker435"/> a working<a id="_idIndexMarker436"/> demo AR application for placing various virtual objects onto horizontal surfaces in your environment. One improvement might be to hide the trackable objects in Main-mode and only display them when needed in PlaceObject-mode. </p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor129"/>Hiding tracked objects when not needed</h1>
			<p>When the app<a id="_idIndexMarker437"/> first starts tracking, we show the trackable planes and point clouds. This is useful feedback to the user when the app first starts and subsequently when placing an object. But once we have objects placed in the scene, these trackable visualizations can be distracting and unwanted. Let's only show the object while in PlaceObject-mode and hide them after at least one virtual object has been placed.</p>
			<p>In AR Foundation, hiding<a id="_idIndexMarker438"/> the trackables requires two separate things: hiding the existing trackables that have already been detected, and preventing new trackables from being detected and visualized. We will implement both.</p>
			<p>To implement this, we can write a separate component on <strong class="bold">PlaceObject mode</strong> that shows the trackables when enabled and hides them when disabled. Follow these steps:</p>
			<ol>
				<li value="1">Create a new C# script in your <strong class="source-inline">Scripts/</strong> folder named <strong class="source-inline">ShowTrackablesOnEnable</strong> and open it for editing. </li>
				<li>At the top of the class, add variable references to <strong class="source-inline">ARSessionOrigin</strong>, <strong class="source-inline">ARPlaneManager</strong>, and <strong class="source-inline">ARPointCloudManager</strong>. Also, we will now remember the most recently placed object in <strong class="source-inline">lastObject</strong>, and initialize them in <strong class="source-inline">Awake</strong>, as follows:<p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.XR.ARFoundation;</p><p class="source-code">public class ShowTrackablesOnEnable : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    [SerializeField] ARSessionOrigin sessionOrigin;</p><p class="source-code">    ARPlaneManager planeManager;</p><p class="source-code">    ARPointCloudManager cloudManager;</p><p class="source-code">    bool isStarted;</p><p class="source-code">    void Awake()</p><p class="source-code">    {</p><p class="source-code">        planeManager =             sessionOrigin.GetComponent&lt;ARPlaneManager&gt;();</p><p class="source-code">        cloudManager = sessionOrigin.GetComponent             &lt;ARPointCloudManager&gt;();</p><p class="source-code">    }</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        isStarted = true;</p><p class="source-code">    }</p><p>I've also added an <strong class="source-inline">isStarted</strong> flag that we'll use to prevent the visualizers from<a id="_idIndexMarker439"/> being hidden when the app starts up.</p><p class="callout-heading">Info: OnEnable and OnDisable can be called before Start</p><p class="callout">In the life cycle of a <strong class="source-inline">MonoBehaviour</strong> component, <strong class="source-inline">OnEnable</strong> is called<a id="_idIndexMarker440"/> when<a id="_idIndexMarker441"/> the object becomes enabled and active. <strong class="source-inline">OnDisable</strong> is called when the script object becomes inactive. <strong class="source-inline">Start</strong> is called on the first frame the script is enabled, just before <strong class="source-inline">Update</strong>. See <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html</a>.<span class="hidden"> </span></p><p class="callout">In our app, it is possible for <strong class="source-inline">OnDisable</strong> to get called before <strong class="source-inline">Start</strong> (when we're initializing the scene from <strong class="source-inline">InteractionController</strong>). To prevent <strong class="source-inline">ShowTrackables(false)</strong> from getting called before the scene has started, we use an <strong class="source-inline">isStarted</strong> flag in this script.</p></li>
				<li>We will show the trackables when the mode is enabled and hide them when disabled using the following code:<p class="source-code">    void OnEnable()</p><p class="source-code">    {</p><p class="source-code">        ShowTrackables(true);</p><p class="source-code">    }</p><p class="source-code">    void OnDisable()</p><p class="source-code">    {</p><p class="source-code">        if (isStarted)</p><p class="source-code">        {</p><p class="source-code">            ShowTrackables(false);</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>These call <strong class="source-inline">ShowTrackables</strong>, which<a id="_idIndexMarker442"/> we implement as follows:<p class="source-code">    void ShowTrackables(bool show)</p><p class="source-code">    {</p><p class="source-code">        if (cloudManager)</p><p class="source-code">        {</p><p class="source-code">            cloudManager.SetTrackablesActive(show);</p><p class="source-code">            cloudManager.enabled = show;</p><p class="source-code">        }</p><p class="source-code">        if (planeManager)</p><p class="source-code">        {</p><p class="source-code">            planeManager.SetTrackablesActive(show);</p><p class="source-code">            planeManager.enabled = show;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>Setting <strong class="source-inline">SetTrackablesActive(false)</strong> will hide all the existing trackables. Disabling<a id="_idIndexMarker443"/> the trackable manager component itself will prevent new trackables from being added. We check for null managers in case the component is not present in <strong class="source-inline">ARSessionOrigin</strong>.</p></li>
				<li>Save the script. </li>
				<li>Back in Unity, select the <strong class="bold">PlaceObject Mode</strong> game object in the <strong class="bold">Hierarchy</strong>.</li>
				<li>Drag the <strong class="source-inline">ShowTrackablesOnEnable</strong> script onto the <strong class="bold">PlaceObject Mode</strong> object.</li>
				<li>Drag the <strong class="bold">AR Session Origin</strong> object from the <strong class="bold">Hierarchy</strong> into the <strong class="bold">Inspector</strong> and drop it onto the <strong class="bold">Show Trackables On Enable | Session Origin</strong> slot.</li>
				<li>Save the scene using <strong class="bold">File | Save</strong>.</li>
			</ol>
			<p>Now when you click <strong class="bold">Build And Run</strong> again, the trackables will be shown when PlaceObject Mode is enabled, and will be hidden when disabled. Thus, the trackables will be visible when Main mode is first enabled but after an object has been placed and the app goes back to Main-mode, the trackables will be hidden. This is the behavior we desire. The PlaceObject-mode and subsequent Main-mode are shown in the following screen captures of the project running on my phone:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="Images/Figure_5.09-app-4-5.jpg" alt="Figure 5.9 – Screen captures of PlaceObject-mode, and subsequent Main-mode with trackables hidden&#13;&#10;" width="1283" height="1141"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Screen captures of PlaceObject-mode, and subsequent Main-mode with trackables hidden</p>
			<p class="callout-heading">Tip: Disable trackables by modifying the plane detection mode</p>
			<p class="callout">To disable plane<a id="_idIndexMarker444"/> detection, the method I'm using is to disable the manager component. This is the technique given in the example <strong class="source-inline">PlaneDetectionController.cs</strong> script in the AR Foundation Samples project. Alternatively, the Unity ARCore XR Plugin<a id="_idIndexMarker445"/> docs ( <a href="https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html">https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html</a>) recommend disabling plane detection by setting the <strong class="source-inline">ARPlaneManager</strong> detection mode to the value <strong class="source-inline">PlaneDetectionMode.None</strong>. </p>
			<p>We've now<a id="_idIndexMarker446"/> completed a simple AR project to place various virtual objects on horizontal planes detected in the environment, using our AR user framework. </p>
			<p>Further improvements<a id="_idIndexMarker447"/> you could add to the project include the following:</p>
			<ul>
				<li>A reset button in the main menu to remove any virtual objects already placed in the scene.</li>
				<li>Only allow one instance of a virtual object to be placed in the scene at a time.</li>
				<li>The ability to move and resize an existing object (see <a href="B15145_07_Final_SB_epub.xhtml#_idTextAnchor170"><em class="italic">Chapter 7</em></a><em class="italic">, Gallery: Editing Virtual Objects</em>).</li>
				<li>Can you think of more improvements? Let us know.</li>
			</ul>
			<p>In the rest of this chapter, we'll discuss some advanced onboarding and user experience features you may want to include in your projects at a later time.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor130"/>Advanced onboarding issues</h1>
			<p>In this section, we'll review some other issues<a id="_idIndexMarker448"/> related to AR onboarding, AR sessions, and devices, including the following:</p>
			<ul>
				<li>Making an AR-optional project</li>
				<li>Determining whether the device supports a specific AR feature</li>
				<li>Adding localization to your project</li>
			</ul>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor131"/>Making an AR-optional project</h2>
			<p>Some applications<a id="_idIndexMarker449"/> are intended<a id="_idIndexMarker450"/> to be run specifically using AR features and should just quit (after a friendly notification to the user) if it's not supported. But other applications may want to behave like an ordinary mobile app with an extra optional capability of supporting AR features. </p>
			<p>For example, a game I recently created, Epoch Resources (available for Android at <a href="https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&amp;hl=en_US&amp;gl=US">https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&amp;hl=en_US&amp;gl=US</a>, and iOS at <a href="https://apps.apple.com/us/app/epoch-resources/id1455848902">https://apps.apple.com/us/app/epoch-resources/id1455848902</a>) is a planetary evolution incremental game with a 3D planet you mine for resources. It offers<a id="_idIndexMarker451"/> an<a id="_idIndexMarker452"/> optional AR-viewing mode where you can "pop" the planet into your living room and continue playing the game in AR, as shown in the following image.</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="Images/Figure_5.10-EpochResources.jpg" alt="Figure 5.10 – Epoch Resources is an AR-optional game&#13;&#10;" width="1650" height="928"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Epoch Resources is an AR-optional game</p>
			<p>For an AR-optional application, your app will probably start up as an ordinary non-AR app. Then at some point the user may choose to turn on AR-specific features. That's when you'll activate the AR Session and handle the onboarding UX.</p>
			<p>None of the projects in this book implement AR-optional so this is an informational discussion only. To start, you'll tell the XR Plugin that AR is optional by going to <strong class="bold">Edit | Project Settings | XR Plug-in Management</strong> and selecting <strong class="bold">Requirement | Optional</strong> (instead of <strong class="bold">Required</strong>) for each of your platforms (ARCore and ARKit are set separately).</p>
			<p>You will need a mechanism for running with or without AR. One approach is to have separate AR and non-AR scenes<a id="_idIndexMarker453"/> that are loaded as needed (see <a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html">https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html</a>). </p>
			<p>In the case<a id="_idIndexMarker454"/> of<a id="_idIndexMarker455"/> the Epoch Resources game, we did not create two separate scenes. Rather the scene contains two cameras, the normal default camera for non-AR mode and the AR Session Origin (with child camera) for AR mode. We then flip between the two cameras when the user toggles viewing modes.</p>
			<p>Another issue you may run into is determining whether the user's device supports a specific AR feature at runtime.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor132"/>Determining whether the device supports a specific AR feature </h2>
			<p>It is possible that your app requires<a id="_idIndexMarker456"/> a specific AR feature that is not supported by all devices. We can ask the Unity AR subsystems what features are supported by getting the subsystem descriptor records.</p>
			<p>For example, suppose we are interested in detecting vertical planes. Some older devices may support AR but only horizontal planes. The following code illustrates how to get and check plane detection support:</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using UnityEngine.XR.ARSubsystems;</p>
			<p class="source-code">public class CheckPlaneDetectionSupport : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var planeDescriptors =             new List&lt;XRPlaneSubsystemDescriptor&gt;();</p>
			<p class="source-code">        SubsystemManager.            GetSubsystemDescriptors(planeDescriptors);</p>
			<p class="source-code">        Debug.Log("Plane descriptors count: " +            planeDescriptors.Count);</p>
			<p class="source-code">        if (planeDescriptors.Count &gt; 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            foreach (var planeDescriptor in planeDescriptors)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                Debug.Log("Support horizontal: " +                    planeDescriptor.                        supportsHorizontalPlaneDetection);</p>
			<p class="source-code">                Debug.Log("Support vertical: " +                    planeDescriptor.                        supportsVerticalPlaneDetection);</p>
			<p class="source-code">                Debug.Log("Support arbitrary: " +                    planeDescriptor.                        supportsArbitraryPlaneDetection);</p>
			<p class="source-code">                Debug.Log("Support classification: " +                    planeDescriptor.supportsClassification);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The types<a id="_idIndexMarker457"/> of descriptors available in AR Foundation include the following (their purpose is self-evident from their names):</p>
			<ul>
				<li><strong class="source-inline">XRPlaneSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRRaycastSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRFaceSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRImageTrackingSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XREnvironmentProbeSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRAnchorSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRObjectTrackingSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRParticipantSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRDepthSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XROcclusionSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRCameraSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRSessionSubsystemDescriptor</strong></li>
				<li><strong class="source-inline">XRHumanBodySubsystemDescriptor</strong></li>
			</ul>
			<p>Documentation<a id="_idIndexMarker458"/> for the AR Subsystems<a id="_idIndexMarker459"/> API and these descriptor records can be found at <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html">https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html</a>. For example, the <strong class="source-inline">XRPlaneSubsystemDescriptor</strong> record<a id="_idIndexMarker460"/> we used here is documented at <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html">https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html</a>. </p>
			<p>If you are planning to distribute your application in different countries, you may also be interested in localization.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor133"/>Adding localization</h2>
			<p>Localization<a id="_idIndexMarker461"/> is the<a id="_idIndexMarker462"/> translation of text strings and other assets into local languages. It can also specify date and currency formatting, alternative graphics for national flags, and so on, to accommodate international markets and users. The Unity Localization package<a id="_idIndexMarker463"/> provides a standard set of tools and data structures for localizing your application. More information can be found at <a href="mailto:https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html">https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html</a>. We do not use localization in any projects in this book, except where already supported by imported assets such as the Onboarding UX assets from the AR Foundation Demos project.</p>
			<p>The Unity Onboarding UX assets<a id="_idIndexMarker464"/> has<a id="_idIndexMarker465"/> built-in support for localization of the user prompts and explanation of scanning problems. The <strong class="source-inline">ReasonsUX</strong> localization tables given with the Onboarding UX project, for example, can be opened by selecting <strong class="bold">Window | Asset Management | Localization Tables</strong> and is shown in the following screenshot. You can see, for example, the second-row <strong class="bold">INIT</strong> key says in English, <strong class="bold">Initializing augmented reality</strong>, along with the same string translated into many other languages:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="Images/Figure_5.11-Localization-tables.jpg" alt="Figure 5.11 – The ReasonsUX localization tables included in Onboarding UX assets&#13;&#10;" width="762" height="414"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – The ReasonsUX localization tables included in Onboarding UX assets</p>
			<p>In the code, the <strong class="bold">Initializing augmented reality</strong> message, for example, is retrieved with a call like this:</p>
			<p class="source-code">string localizedInit = reasonsTable.GetEntry("INIT").GetLocalizedString();</p>
			<p>When we added the onboarding UX prefab (<strong class="source-inline">ARFoundationDemos/UX/Prefabs/ScreenspaceUI</strong>) to our scene, I had you disable the <strong class="bold">Localization Manager</strong> component because it gives runtime errors until it is set up. Provided<a id="_idIndexMarker466"/> you've<a id="_idIndexMarker467"/> installed the <strong class="bold">Localization</strong> package via <strong class="bold">Package Manager</strong> as described earlier in this chapter, we can set it up now for the project using the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Localization</strong> settings window by going to <strong class="bold">Edit | Project Settings | Localization</strong>.</li>
				<li>In the <strong class="bold">Project</strong> window, navigate to <strong class="source-inline">Assets/ARFOundationDemos/Common/Localization/</strong> and drag the <strong class="source-inline">LocalizationSettings</strong> asset onto the <strong class="bold">Location Settings</strong> slot (or use the <em class="italic">doughnut</em> icon to open the <strong class="bold">Location Setting Select</strong> dialog box).</li>
				<li>In the settings window, click <strong class="bold">Add All</strong>.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">OnboardingUX</strong> object and in the <strong class="bold">Inspector</strong>, enable the <strong class="bold">Localization Manager</strong> component.</li>
				<li>Open the <strong class="bold">Addressables Groups</strong> window using <strong class="bold">Window | Asset Management | Addressables | Groups</strong>.</li>
				<li>From the <strong class="bold">Addressables Groups</strong> menu bar, select <strong class="bold">Build | New Build | Default Build Script</strong>. You will need to do this for each target platform you are building (for example, once for Android and once for iOS).</li>
			</ol>
			<p>As you can see in this last step, the Localization package uses Unity's new <strong class="bold">Addressables</strong> system for managing, packing, and loading assets from any location locally or over the internet (<a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html">https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html</a>).</p>
			<p>Note that as I'm writing this, the Onboarding UX <strong class="source-inline">LocalizationManager</strong> script does not select the language at runtime. The language must be set in the Inspector and compiled into your build.</p>
			<p>The AR UI framework we built in this chapter can be used as a template for new scenes. Unity makes it easy to set that up.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor134"/>Summary</h1>
			<p>In this chapter, we got a chance to use the AR user framework we developed in the previous <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">, Creating an AR User Framework</em>, in a simple AR <em class="italic">Place Object Demo</em> project. We created a new scene using the <strong class="source-inline">ARFramework</strong> scene template that implements a state machine mechanism for managing user interaction modes. It handles user interaction with a controller-view design pattern, separating the control scripts from the UI graphics. </p>
			<p>By default, the scene includes the AR Session and AR Session Origin components required by AR Foundation. The scene is set up with a Canvas UI containing separate panels that will be displayed for each interaction mode. It also includes an Interaction Controller that references separate mode objects, one for each interaction mode. </p>
			<p>The modes (and corresponding UI) given with the template are Startup, Scan, Main, and NonAR. An app using this framework first starts in Startup-mode while the AR Session is initializing. Then it goes into Scan-mode, prompting the user to scan the environment for trackable features, until a horizontal plane is detected. Then it goes into Main-mode and displays the main menu. </p>
			<p>For this project, we added a main menu that is displayed during Main-mode and that contains buttons for placing various virtual objects in the environment. Pressing a button enables a new PlaceObject-mode that we added to the scene. When PlaceObject-mode is enabled, it displays an instructional animated prompt for the user to tap to place an object in the scene. After an object is added, the app returns to Main-mode, and the trackables are hidden so you can see your virtual objects in the real world without any extra distractions. </p>
			<p>In the next chapter, we will go beyond a simple demo project and begin to build a more complete AR application – a photo gallery where you can place framed photos of your favorite pictures on the drab walls in your home or office.</p>
		</div>
	</div></body></html>