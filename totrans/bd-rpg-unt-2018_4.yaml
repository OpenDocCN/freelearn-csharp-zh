- en: The Game Mechanics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏机制
- en: In [Chapter 3](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79), *RPG
    Character Design,* we covered a wide range of topics to prepare your character
    model for the game. We looked at how to import and set up our character model,
    created the `BaseCharacter` class, used the Animator Controller to set up the
    state diagram, created the initial character controller to handle the motion and
    behavior of our character model, and finally, looked at some basic inverse kinematics
    for the foot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79)，“RPG角色设计”中，我们涵盖了广泛的主题，以准备你的角色模型用于游戏。我们探讨了如何导入和设置我们的角色模型，创建了`BaseCharacter`类，使用动画控制器设置状态图，创建了初始角色控制器来处理我们角色模型的运动和行为，最后，查看了一些基本逆运动学用于脚部。
- en: 'In this chapter, we will expand on the character player and also the non-character
    player, covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展角色玩家和非角色玩家，涵盖以下主题：
- en: 'Customizing the player character:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制玩家角色：
- en: Customizable parts (model)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可定制部分（模型）
- en: C# code for customization
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制化的C#代码
- en: Preserving character state
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留角色状态
- en: Recap
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Non-player characters:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非玩家角色：
- en: Non-player character basics
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非玩家角色基础
- en: Setting up the non-player character
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置非玩家角色
- en: Navmesh setup
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航网格设置
- en: NPC Animator Controller
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC动画控制器
- en: NPC Attack
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC攻击
- en: NPC AI
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC AI
- en: PC and NPC interaction
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PC和NPC交互
- en: Customizing the player character
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制玩家角色
- en: One of the key features of an RPG is to be able to customize your character
    player. In this section, we will take a look at how we can provide a means to
    achieve this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个RPG的关键特性是能够定制你的角色玩家。在本节中，我们将探讨如何提供实现这一点的手段。
- en: Once again, the approach and concept are universal, but the actual implementation
    might be a little different based on your model structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，方法和概念是通用的，但实际实现可能根据你的模型结构略有不同。
- en: Create a new scene and name it `CharacterCustomization`. Create a Cube prefab
    and set it to the origin. Change the Scale of the cube to `<5, 0.1, 5>`. You can
    also change the name of the GameObject to Base. This will be the platform that
    our character model stands on while the player customizes his/her character before
    game play.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并将其命名为`CharacterCustomization`。创建一个立方体预制件并将其设置为原点。将立方体的缩放设置为`<5, 0.1,
    5>`。你还可以将GameObject的名称更改为Base。这将是我们角色模型站立的平台，在玩家在游戏开始前定制他的/她的角色时。
- en: I used my environment assets to create the stage. This takes more time, but
    it is more attractive. This is totally up to you, the creator and designer of
    the game, and the sky is the limit!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用我的环境资源来创建舞台。这需要更多的时间，但更加吸引人。这完全取决于你，游戏创造者和设计师，天空才是极限！
- en: Drag and the drop the prefab representing your character model into the Scene
    View. The next few steps will entirely depend on your model hierarchy and structure
    as designed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将代表你的角色模型的预制件拖放到场景视图中。接下来的几个步骤将完全取决于你设计的模型层次结构和结构。
- en: I am using the Barbarian model to illustrate the structure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用野蛮人模型来展示结构。
- en: 'To illustrate the point, I have placed the same model in the scene twice. The
    one on the left is the model that has been configured to display only the basics,
    and the model on the right is the model in its original state, as shown in the
    following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我在场景中放置了相同的模型两次。左边的是配置为仅显示基础的模型，而右边的模型是其原始状态，如下面的截图所示：
- en: '![](img/00075.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00075.jpeg)'
- en: 'Barbarian model: simple and fully geared'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 野蛮人模型：简单且全副武装
- en: 'Notice that the particular model I am using has everything attached. This includes
    the different types of weapons, shoes, helmets, armor, and skins. The instantiated
    prefab on the left-hand side has turned off all of the extras from the model''s
    hierarchy. Here is how the hierarchy looks in `Hierarchy View`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我正在使用的特定模型将所有内容都附加在上面。这包括不同类型的武器、鞋子、头盔、盔甲和皮肤。左侧的实例化预制件已关闭模型层次结构中的所有额外内容。以下是`Hierarchy
    View`中的层次结构看起来是这样的：
- en: '![](img/00076.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.jpeg)'
- en: Barbarian model structure
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 野蛮人模型结构
- en: The model has a very extensive hierarchy in its structure. The preceding screenshot
    is a small snippet to demonstrate that you will need to navigate the structure
    and manually identify and enable or disable the mesh representing a particular
    part of the model.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型在其结构中具有非常广泛的层次结构。前面的截图是一个小片段，以展示你需要导航结构并手动识别和启用或禁用表示模型特定部分的网格。
- en: 'Model root:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模型根：
- en: 'Pelvis:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 骨盆：
- en: 'Left thigh:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 左大腿：
- en: Left calf
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左腿
- en: 'Right thigh:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 右大腿：
- en: Right calf
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右小腿
- en: 'Spine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 脊柱：
- en: 'Ribcage:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胸廓：
- en: 'Left collarbone:'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左锁骨：
- en: 'Left upper arm:'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左上臂：
- en: Left forearm
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左前臂
- en: 'Neck:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颈部：
- en: Head
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部
- en: 'Right collarbone:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右锁骨：
- en: 'Right upper arm:'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右上臂：
- en: 'Right forearm:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右前臂：
- en: Right palm
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右手掌
- en: Each one of your character models will have their own unique hierarchy and bone
    structure. You will need to study this, as mentioned previously, to understand
    and plan how you will configure and program them during game play.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色模型都将有自己的独特层次结构和骨骼结构。你需要研究这一点，如前所述，以了解和计划你如何在游戏过程中配置和编程它们。
- en: Customizable parts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可自定义部分
- en: Using my Barbarian model, I can customize a few items with it. I can customize
    the shoulder pads, the body type, the weapons, the armor, the helmets, the shoes,
    and, finally, the texture or skin of the model to give it different and unique
    looks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我的野蛮人模型，我可以使用它自定义一些物品。我可以自定义肩垫、体型、武器、盔甲、头盔、鞋子，最后，模型的纹理或皮肤，以赋予它不同和独特的样子。
- en: 'Let''s get a list of all the different customizable items we have for our character:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们为角色拥有的所有可自定义物品：
- en: '**Shields**: There are two types'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**盾牌**：有两种类型'
- en: '**Body Type**: There are three body types: skinny, buff, and chubby'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体型**：有三种体型：瘦、健壮和胖'
- en: '**Armor**: knee pad, leg plate'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**盔甲**：护膝、腿板'
- en: '**Boots**: There are two types of boots'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**靴子**：有两种类型'
- en: '**Helmet**: There are four types of helmets'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头盔**：有四种类型'
- en: '**Weapons**: There are 13 different types of weapons'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**武器**：有13种不同的类型'
- en: '**Skins**: There are 13 different types of skins'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**皮肤**：有13种不同的类型'
- en: '![](img/00077.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: Model assets 1
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模型资产1
- en: 'You can easily extract each accessory from the main model and create a prefab
    of the individual weapon, armor, and clothing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地从主模型中提取每个配件，并为单个武器、盔甲和服装创建预制件：
- en: '![](img/00078.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: Model assets 2
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模型资产2
- en: 'We are separating the items in such a way to give the player the ability to
    level-up or find the required weapon or armor during game play:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式分离物品，以便玩家在游戏过程中能够升级或找到所需的武器或盔甲：
- en: '![](img/00079.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: Model assets 3
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模型资产3
- en: Once an item is picked up, we would have it in our inventory and the player
    can easily access it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拾取了物品，我们就会将其放入我们的库存中，玩家可以轻松访问它。
- en: User interface
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面
- en: Now that we know what our options are for customizing our player character,
    we can start thinking about the **User Interface** (**UI**). The UI will be used
    for the customization of the character.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们可以如何自定义我们的玩家角色，我们可以开始考虑**用户界面**（**UI**）。UI将用于角色的自定义。
- en: 'The following is a sketch of an idea for the UI. As we start implementing the
    UI, we might have to make some adjustments to accommodate the usability of the
    original concept:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个UI想法的草图。当我们开始实现UI时，我们可能需要做一些调整以适应原始概念的可用性：
- en: '![](img/00080.gif)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.gif)'
- en: To design our UI, we will need to create a Canvas GameObject. This is done by
    right-clicking in the **Hierarchy View** and selecting Create *|* UI *|* Canvas.
    This will place a Canvas GameObject and an `EventSystem` GameObject in the Hierarchy
    View.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计我们的UI，我们需要创建一个Canvas GameObject。这是通过在**层次视图**中右键单击并选择创建 *|* UI *|* Canvas来完成的。这将在一个Canvas
    GameObject和一个`EventSystem` GameObject中放置层次视图。
- en: 'It is assumed that you already know how to create a UI in Unity. If you do
    not, please refer to *Introduction to Game Programming: Using C# and Unity 3D,*
    [Chapter 5](part0109.html#37UDA0-7a1ef7ae3ef249cdb149f8344d2e8e79), *GameMaster
    and Game Mechanics,* at [https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/](https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经知道如何在Unity中创建UI。如果你不知道，请参阅*《游戏编程入门：使用C#和Unity 3D》* [第5章](part0109.html#37UDA0-7a1ef7ae3ef249cdb149f8344d2e8e79)，*游戏大师和游戏机制*，在[https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/](https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/).
- en: 'I am going to use panels to group the customizable items. For the moment, I
    will be using checkboxes for some items and scroll bars for the weapons and skin
    texture. The following screenshot illustrates how my UI for customization looks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用面板来分组可自定义的物品。目前，我将使用复选框来处理一些物品，并使用滚动条来处理武器和皮肤纹理。以下截图说明了我的自定义UI看起来：
- en: '![](img/00081.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: Character customization UI
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 角色自定义UI
- en: These UI elements will need to be integrated with event handlers that will perform
    the necessary actions for enabling or disabling certain parts of the character
    model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些UI元素需要与事件处理器集成，以便执行启用或禁用角色模型某些部分所需的操作。
- en: For instance, using the UI, I can select Shoulder Pad 4, use the scroll bar
    to increase or decrease the chubbiness of the body, and move the weapons type
    scroll bar until the Hammer weapon shows up. Selecting the second Helmet checkbox,
    selecting Shield 1, and Boot 2, my character will look the like following screenshot.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用UI，我可以选择肩垫4号，使用滚动条增加或减少身体的圆润度，并将武器类型滚动条移动到锤子武器出现的位置。选择第二个头盔复选框，选择盾牌1号和靴子2号，我的角色将看起来像以下截图。
- en: We need a way to refer to each one of the meshes representing the different
    types of customizable objects on the model. This will be done through a C# script.
    The script will need to keep track of all the parts we are going to be managing
    for customization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来引用模型上代表不同可定制对象类型的每个网格。这将通过C#脚本完成。脚本需要跟踪我们将要管理的所有定制部分。
- en: Some models will not have the extra meshes attached. You can always create empty
    GameObjects at a particular location on the model, and you can dynamically instantiate
    the prefab representing your custom object at the given point. This can also be
    done for our current model. For instance, if we have a special space weapon that
    somehow gets dropped by aliens in the game world, we can attach the weapon to
    our model through C# code. The important thing is to understand the concept, and
    the rest is up to you!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模型可能没有附加额外的网格。你可以在模型的特定位置创建空的GameObject，并且可以在给定点动态实例化代表你的自定义对象的预制体。这也可以应用于我们的当前模型。例如，如果我们有一个特殊的太空武器，某种方式被游戏世界中的外星人丢弃，我们可以通过C#代码将武器附加到我们的模型上。重要的是要理解这个概念，其余的则由你决定！
- en: '![](img/00082.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: Character customization in action
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 角色定制化实战
- en: The code for character customization
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色定制化代码
- en: Things don't happen automatically. We need to create some C# code that will
    handle the customization of our character model. The script we create here will
    handle the UI events that will drive the enabling and disabling of different parts
    of the model mesh.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事情不会自动发生。我们需要创建一些C#代码来处理我们的角色模型的定制化。我们在这里创建的脚本将处理驱动模型网格不同部分启用和禁用的UI事件。
- en: 'Create a new C# script and call it `BarbarianCharacterCustomization.cs`. Create
    an empty GameObject called `__Base` and attach the script to `__Base GameObject`
    in the scene. Here is a listing of the script:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，命名为`BarbarianCharacterCustomization.cs`。创建一个名为`__Base`的空GameObject，并将脚本附加到场景中的`__Base
    GameObject`。以下是脚本的列表：
- en: '`path of the code`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`代码路径`'
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a long script but it is straightforward. At the top of the script,
    we have defined all of the variables that will be referencing the different meshes
    in the model character. All variables are of type GameObject with the exception
    of the `PLAYER_SKIN` variable, which is an array of `Material` data type. The
    array is used to store the different types of texture created for the character
    model:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的脚本，但它很简单。在脚本顶部，我们定义了所有将引用模型角色中不同网格的变量。所有变量都是GameObject类型，除了`PLAYER_SKIN`变量，它是一个`Material`数据类型的数组。数组用于存储为角色模型创建的不同类型的纹理：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are a few functions defined that are called by the UI event handler.
    These functions are: `SetShoulderPad(Toggle id)`, `SetBodyType(Toggle id)`, `SetKneePad(Toggle
    id)`, `SetLegPlate(Toggle id)`, `SetWeaponType(Slider id)`, `SetHelmetType(Toggle
    id)`, `SetShieldType(Toggle id)`, `SetSkinType(Slider id)`, `SetBodyFat(Slider
    id)`, and `SetBodySkinny(Slider id)`;'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 已定义了一些函数，这些函数由UI事件处理器调用。这些函数是：`SetShoulderPad(Toggle id)`、`SetBodyType(Toggle
    id)`、`SetKneePad(Toggle id)`、`SetLegPlate(Toggle id)`、`SetWeaponType(Slider id)`、`SetHelmetType(Toggle
    id)`、`SetShieldType(Toggle id)`、`SetSkinType(Slider id)`、`SetBodyFat(Slider id)`和`SetBodySkinny(Slider
    id)`；
- en: All of the functions take a parameter that identifies which specific type should
    enable or disable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都接受一个参数，用于标识应启用或禁用的特定类型。
- en: We have just created a tool that will enable you quickly visualize character
    customization.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个工具，可以快速可视化角色定制。
- en: You can also use the system we just built to create all of the different variations
    of your player character or non-character player models and store them as prefabs!
    Wow! This will save you so much time and effort in creating your characters representing
    different barbarians!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用我们刚刚构建的系统来创建您玩家角色的所有不同变体或非玩家角色模型，并将它们作为预制体存储！哇！这将为您节省大量创建代表不同野蛮人的角色的时间和精力！
- en: Preserving our character state
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留我们的角色状态
- en: Now that we have spent the time to customize our character, we need to preserve
    our character and use it in our game. In Unity, there is a function called `DontDestroyOnLoad()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花费时间定制了我们的角色，我们需要保留我们的角色并在我们的游戏中使用它。在 Unity 中，有一个名为 `DontDestroyOnLoad()`
    的函数。
- en: This is a great function that can be utilized at this time. What does it do?
    It keeps the specified GameObject in memory going from one scene to the next.
    We can use these mechanisms for now. Eventually, though, you will want to create
    a system that you can save and load your user data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个现在可以使用的优秀功能。它做什么？它将指定的 GameObject 在场景之间保持内存中。我们现在可以使用这些机制。然而，最终，您可能希望创建一个可以保存和加载用户数据的系统。
- en: 'Go ahead and create a new C# script and call it `DoNotDestroy.cs`. This script
    is going to be very simple. Here is the listing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个新的 C# 脚本，并将其命名为 `DoNotDestroy.cs`。这个脚本将会非常简单。以下是代码列表：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After you create the script, go ahead and attach it to your character model
    prefab in the scene. Not bad; let's do a quick recap of what we have done so far.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建脚本后，将其附加到场景中的角色模型预制体上。不错；让我们快速回顾一下到目前为止我们已经做了什么。
- en: Recap
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'By now you should have three scenes that are functional. We have our scene
    that represents the main menu, we have our scene that represents our initial level,
    and we just created a scene that is used for character customization. Here is
    the flow of our game thus far:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该有三个功能性的场景。我们有代表主菜单的场景，我们有代表初始级别的场景，我们刚刚创建了一个用于角色定制的场景。以下是到目前为止我们游戏的流程：
- en: '![](img/00083.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00083.jpeg)'
- en: We start the game, see the main menu, select the Start Game button to enter
    the character customization scene, do our customization, and when we click the
    Save button, we load level 1.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始游戏，看到主菜单，选择“开始游戏”按钮进入角色定制场景，进行定制，然后点击“保存”按钮，加载第 1 级。
- en: 'For this to work, we have created the following C# scripts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们创建了以下 C# 脚本：
- en: '`GameMaster.cs`: This is used as the main script to keep track of our game
    state'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameMaster.cs`: 这用作跟踪游戏状态的主要脚本'
- en: '`BarbarianCharacterCustomization.cs`: This is used exclusively for customizing
    our character'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BarbarianCharacterCustomization.cs`: 这仅用于定制我们的角色'
- en: '`DoNotDestroy.cs`: This is used to save the state of a given object'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoNotDestroy.cs`: 这用于保存给定对象的状态'
- en: '`BarbarianCharacterController.cs`: This is used to control the motion of our
    character'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BarbarianCharacterController.cs`: 这用于控制我们的角色动作'
- en: '`IKHandle.cs`: This is used to implement inverse kinematics for the foot'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IKHandle.cs`: 这用于实现脚部的逆运动学'
- en: When you combine all of this together, you now have a good framework and flow
    that can be used to extend and improve as we go along.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将这些结合起来，现在您就拥有了一个良好的框架和流程，我们可以随着进展进行扩展和改进。
- en: Non-player characters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非玩家角色
- en: Until now, we have concentrated on the player character. In this section, we
    will start thinking about our non-player characters. Let's start with our Barbarians.
    We can use our Character Customization scene to quickly create a few prefabs that
    will represent our unique Barbarians.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于玩家角色。在本节中，我们将开始考虑我们的非玩家角色。让我们从我们的野蛮人开始。我们可以使用角色定制场景快速创建几个预制体，这些预制体将代表我们的独特野蛮人。
- en: 'Using the tool we have just developed, you can make your adjustments, and when
    satisfied with your model, drag and drop the GameObject representing your character
    player into the `Prefabs` folder. This will create a copy of the instance of the
    GameObject as you see it and save it into a prefab. The following screenshot demonstrates
    the two characters I have created and stored as a prefab:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚刚开发的工具，您可以进行调整，当对模型满意时，将代表您的角色玩家的 GameObject 拖放到“预制体”文件夹中。这将创建一个与您所看到的
    GameObject 实例的副本，并将其保存为预制体。以下截图展示了我已经创建并存储为预制体的两个角色：
- en: '![](img/00084.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.jpeg)'
- en: Creating unique characters using the tool
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具创建独特的角色
- en: What I have shown you, if done properly, could save you hours of tedious work
    to manually go down the model structure and individually enable and disable the
    different meshes. In other words, we not only create a scene that allows us to
    customize the in-game player character, we have also created a tool that can help
    us customize our own character models quickly for use within the game!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我向您展示的，如果做得恰当，可以为您节省数小时手动遍历模型结构并逐个启用和禁用不同网格的繁琐工作。换句话说，我们不仅创建了一个允许我们自定义游戏内玩家角色的场景，我们还创建了一个可以帮助我们快速自定义游戏内自己的角色模型以供使用的工具！
- en: Another point to emphasize here is the power of prefabs. Think of a prefab as
    a storage that can be used to save the state of a given GameObject and used over
    and over again within your game environment. When you update your prefab, all
    instances of the prefab will automatically get updated! This is great, but at
    the same time you have to be careful not to break anything for the same reason.
    When you update a code logic on a script that is attached to a prefab, all instances
    of the prefab will use the updated script, so a bit of planning on your part can
    save a lot of time and headache in the long run.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要强调的另一个点是预制件的强大功能。将预制件想象成一个存储库，可以用来保存给定GameObject的状态，并在您的游戏环境中重复使用。当您更新预制件时，所有预制件的实例将自动更新！这很好，但与此同时，您必须小心不要因为同样的原因破坏任何东西。当您在附加到预制件的脚本上更新代码逻辑时，所有预制件的实例都将使用更新的脚本，因此您的一点点规划可以从长远来看节省大量时间和头疼。
- en: Non-player character basics
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非玩家角色基础
- en: We are going to be using the newly created prefabs to implement our non-player
    characters. Since there are some similarities in the character models, we can
    re-use some of the assets that we have created so far.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新创建的预制件来实现我们的非玩家角色。由于角色模型之间存在一些相似之处，我们可以重用我们迄今为止创建的一些资产。
- en: For instance, all character will be inheriting the BaseCharacte*r* class defined
    in [Chapter 3](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79), *RPG Character
    Design*. They will also incorporate the same states we have already created for
    the player character and extend a few more states specifically for the NPC, such
    as searching and seeking.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有角色都将继承在[第3章](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79)中定义的`BaseCharacter`类，*RPG角色设计*。它们还将包含我们为玩家角色已经创建的相同状态，并扩展一些专门为NPC设计的额外状态，如搜索和寻找。
- en: We have used our character customization tool to create and save our non-player
    character; hence, we are OK with the modeling part. What we need to concentrate
    on is the motion of our non-player characters. We would need to create a new Animator
    Controller that will handle the states of our NPCs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用我们的角色定制工具创建并保存了我们的非玩家角色；因此，我们对建模部分感到满意。我们需要集中精力的是我们非玩家角色的动作。我们需要创建一个新的动画控制器来处理我们NPC的状态。
- en: Setting up the non-player character
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置非玩家角色
- en: One of the main difficulties for implementing an NPC is the ability to give
    it realistic intelligence. This can be achieved easily by identifying and implementing
    several key areas for our NPCs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实现NPC的主要困难之一是赋予它真实智能的能力。这可以通过识别和实现我们NPC的几个关键区域来轻松实现。
- en: 'There are a few new components we would need to attach to our NPCs. Using the
    prefab we have saved, we will need to add the following components:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一些新组件附加到我们的NPC上。使用我们已保存的预制件，我们需要添加以下组件：
- en: New Sphere Collider, this will be used to implement the range of sight for our
    NPC.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的球体碰撞器，这将用于实现我们NPC的视野范围。
- en: We already have an Animator component attached, but we will need to create a
    new Animator Controller to capture new states for the NPC.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经附加了一个动画组件，但我们需要创建一个新的动画控制器来捕捉NPC的新状态。
- en: We also need to add a Nav Mesh Agent component. We are going to use the built-in
    navigation and pathfinding system for our NPC.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要添加一个导航网格代理组件。我们将为我们的NPC使用内置的导航和路径查找系统。
- en: To add the Sphere Collider, you will need to select the prefab defined for the
    NCP, and in the **Inspector** Window. Select Add Component *|* Physics *|* Sphere
    Collider. This will attach a Sphere Collider to our prefab.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加球体碰撞器，您需要选择为NPC定义的预制件，并在**检查器**窗口中。选择添加组件 *|* 物理 *|* 球体碰撞器。这将为我们预制件附加一个球体碰撞器。
- en: Next, we need to add Nav Mesh Agent*.* Again, from the Inspector Window, select
    Add Component *|* Navigation | Nav Mesh Agent. OK, so now we have set up our main
    built-in components that are going to be used for the NPC.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加 Nav Mesh Agent*.* 再次，从检查器窗口中选择添加组件 *|* 导航 | Nav Mesh Agent。好的，现在我们已经设置了用于
    NPC 的主要内置组件。
- en: Since our prefab is an instance of our player character, we will need to remove
    some of the script components that have been carried over. If your NPC prefab
    contains any scripts attached to it, go ahead and remove them now.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的预制件是我们玩家角色的实例，我们需要移除一些被携带过来的脚本组件。如果您的 NPC 预制件上附加了任何脚本，请现在移除它们。
- en: Make sure you also change the `Tag` property to `Untagged`, if you have not
    done so already.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请确保将 `Tag` 属性更改为 `Untagged`。
- en: 'The following screenshot illustrates the components that we have so far on
    the NPC. This will include both the existing components, including the scripts
    we have brought over from the player character, and the newly added components
    that will be used for the NPC:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了我们到目前为止在 NPC 上设置的组件。这包括现有的组件，包括我们从玩家角色带来的脚本，以及将用于 NPC 的新增组件：
- en: '![](img/00085.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Before you perform the next step, make sure you are in one of the level scenes.
    I am going to use the Awakening scene.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行下一步之前，请确保您在一个级别场景中。我将使用觉醒场景。
- en: Switch to one of your playable game scenes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到您的可玩游戏场景之一。
- en: 'The next step is to set up our Navmesh. To create a Navmesh, we need to get
    into the Navigation window, by selecting Window *|* Navigation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置我们的 Navmesh。要创建 Navmesh，我们需要进入导航窗口，通过选择 Window *|* 导航：
- en: '![](img/00086.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'In order for the navmesh to work properly, we will need to mark all GameObjects
    that are going to be static in the scene as Navigation Static. This wkill create
    a navmesh based on the static objects in the scene; that is, GameObjects that
    are not going to be moving throughout the lifespan on the scene:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 navmesh 正确工作，我们需要将场景中所有将要设置为静态的 GameObject 标记为导航静态。这将基于场景中的静态对象创建 navmesh；也就是说，在整个场景生命周期中不会移动的
    GameObject：
- en: '![](img/00087.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: In your active scene, select the GameObjects that are going to be set as Navigation
    Static, as shown in the preceding screenshot (1), use the Static drop-down menu
    (2), and select the Navigation Static option (3). If your GameObject is a parent
    GameObject with children, Unity will ask if you want to apply the property change
    to all children.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的活动场景中，选择将要设置为导航静态的 GameObject，如图中所示（1），使用静态下拉菜单（2），并选择导航静态选项（3）。如果您的 GameObject
    是具有子对象的父 GameObject，Unity 将询问您是否要将属性更改应用于所有子对象。
- en: Notice that I have placed all of my environment GameObjecst under a GameObject
    called `__Structure`*,* `_RootRockCollection` and a few others that have been
    added at a later time. This way, if I have many static objects, I can apply the
    property change to the parent and the children will automatically inherit the
    change as well. But make sure everything in the group will be static!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将所有环境 GameObject 放在一个名为 `__Structure`* 的 GameObject 下，以及后来添加的一些其他 GameObject。这样，如果我有许多静态对象，我可以将属性更改应用于父对象，子对象将自动继承更改。但请确保组中的所有内容都将保持静态！
- en: 'Once this is complete, we need to go back to the Navigation window and make
    some adjustments. In the Navigation tab, select Terrains and make sure it is set
    to Navigation Static, and the *Navigation Area* is set to Walkable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们需要回到导航窗口并做一些调整。在导航选项卡中，选择地形并确保它设置为导航静态，并且*导航区域*设置为可通行：
- en: '![](img/00088.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: 'In the Bake tab, change the Agent Radius to 0.3 and Agent Height to 1\. Keep
    the rest of the properties the same. This will give the NPC more freedom to pass
    through tight corners:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在烘焙选项卡中，将代理半径更改为 0.3，代理高度更改为 1。保持其他属性不变。这将给 NPC 带来更多的灵活性，使其能够通过狭窄的角落：
- en: '![](img/00089.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: When you are ready, you can select the Bake button at the bottom of the Navigation
    window.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好后，您可以在导航窗口的底部选择烘焙按钮。
- en: 'Unity will take some time to generate the Navmesh for your scene. This will
    depend on the complexity of your level. If all is done correctly, you will see
    something similar to the following screenshot displaying your Navmesh:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 需要一些时间来为您场景生成 Navmesh。这取决于您级别的复杂度。如果一切操作正确，您将看到类似于以下截图所示的 Navmesh：
- en: '![](img/00090.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Navmesh generation
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Navmesh 生成
- en: 'The blue areas you see are all the regions that the NPC can actually navigate
    to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的蓝色区域都是NPC可以导航到的区域：
- en: '![](img/00091.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00091.jpeg)'
- en: NPC Animator Controller
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC 动画控制器
- en: 'We now need to create the **Animator Controller** (**AC**) for our NPC. The
    Animator Controller will use input from the `MeshAgent` to control and change
    the state of our NPC. We also need to define a few parameters for our NPC AC.
    These are going to be:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为我们的NPC创建 **动画控制器**（**AC**）。动画控制器将使用来自 `MeshAgent` 的输入来控制和改变NPC的状态。我们还需要为NPC
    AC定义一些参数。这些将是：
- en: '`AngularSpeed`: This will be used for directional movement'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AngularSpeed`: 这将用于方向移动'
- en: '`Speed`: This will be used to determine how fast the NPC will be moving'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Speed`: 这将用于确定NPC移动的速度'
- en: '`Attack`: This will be used to determine if it needs to attack'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attack`: 这将用于确定是否需要攻击'
- en: '`AttackWeight`: This might be used'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttackWeight`: 这可能被使用'
- en: '`PlayerInSight`: This will be used to determine if the PC is in sight'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerInSight`: 这将用于确定PC是否在视线范围内'
- en: 'Go ahead and create a new Animator Controller in your project and name it `NPC_BarbarianAnimatorController`.
    Open the Animator Window. Create a new Blend Tree by right-clicking in the Animator
    Window and selecting Create State | From New Blend Tree. Change the name to `NPC_Locomotion`.
    Double-click it so that you can edit the Blend Tree. Change the node name to `NPC_Locomotion`
    as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中创建一个新的动画控制器，并将其命名为 `NPC_BarbarianAnimatorController`。打开动画窗口。通过在动画窗口中右键单击并选择创建状态
    | 从新混合树创建一个新的混合树。将名称更改为 `NPC_Locomotion`。双击它以便编辑混合树。也将节点名称更改为 `NPC_Locomotion`：
- en: '![](img/00092.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00092.jpeg)'
- en: From the Inspector Window, change the *Blend Type* to *2D Freeform Cartesian:*
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器窗口中，将 *混合类型* 更改为 *2D 自由形式笛卡尔*：
- en: '![](img/00093.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00093.jpeg)'
- en: The *x*-axis will be represented by the *AngularSpeed*, and the *y*-axis will
    be represented by the *Speed* parameters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 轴将由 *AngularSpeed* 表示，*y* 轴将由 *Speed* 参数表示。'
- en: The Blend Tree is going to hold all of the different locomotion animation states.
    These are going to be the idle, walking, and running states.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 混合树将包含所有不同的运动动画状态。这些将是空闲、行走和跑步状态。
- en: 'I have set up 11 different animation states for the locomotion of my NPC. The
    following screenshot will give you and overview of the Blend Tree:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我的NPC设置了11个不同的动画状态，用于移动。以下截图将为你提供一个混合树的概述：
- en: '![](img/00094.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: NPC Blend Tree
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: NPC 混合树
- en: 'Once you include all of the animations states in the Blend Tree, you will need
    to compute the positions of your animations. An easy way to do this, is to select
    the *Compute Positions* dropdown and select *AngularSpeed and Speed*. This will
    place the animation position based on the root motion, as illustrated in the following
    screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在混合树中包含了所有动画状态，你需要计算你动画的位置。一个简单的方法是选择 *计算位置* 下拉菜单并选择 *AngularSpeed 和 Speed*。这将根据根运动放置动画位置，如图所示：
- en: '![](img/00095.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00095.jpeg)'
- en: You can use your mouse to drag the red point shown in the screenshot to preview
    your animation states in action.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用鼠标拖动截图中的红色点来预览你的动画状态。
- en: NPC Attack
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC 攻击
- en: In order to implement our attack mode, we will need to create a new layer in
    the Animator Controller. Go ahead and create a new layer and call it `NPC_Attack`.
    This layer will be responsible for animating our character when we enter the attack
    mode.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的攻击模式，我们需要在动画控制器中创建一个新的层。继续创建一个新的层，并将其命名为 `NPC_Attack`。这个层将负责在我们进入攻击模式时对角色进行动画处理。
- en: 'We need to create a new mask for the layer. The mask will be used to determine
    which parts of the humanoid body will be affected by the layer animation. To create
    a mask, right-click in your Project Window and select Create *|* Avatar Mask.
    Name the new mask `NPC_BarbarianAttackMask`. Use the Inspector Window to disable
    the body parts that we don''t want to be affected by the layer animation, as illustrated
    in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个层创建一个新的遮罩。这个遮罩将用于确定哪些人体部位会受到层动画的影响。要创建遮罩，在项目窗口中右键单击并选择创建 *|* 角色遮罩。将新遮罩命名为
    `NPC_BarbarianAttackMask`。使用检查器窗口禁用我们不想受层动画影响的身体部位，如图所示：
- en: '![](img/00096.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00096.jpeg)'
- en: 'Your layer setup should look like the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你的层设置应该看起来像以下截图：
- en: '![](img/00097.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00097.jpeg)'
- en: Make sure you change the Weight property to *1*, the Mask property assigned
    to the Avatar Mask we created, and also that the IK property is checked. Now we
    are ready to create our attack state machine.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将权重属性更改为*1*，将分配给我们所创建的Avatar Mask的遮罩属性，并且还要确保IK属性被选中。现在我们就可以创建我们的攻击状态机了。
- en: Right-click in the Animator Window and select Create State *|* Empty. Drag and
    drop your attack animation(s). The empty state is used to have a nice transition
    between the main layer and back.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画器窗口中右键单击并选择创建状态 *|* 空状态。将你的攻击动画（们）拖放到空状态中。空状态用于在主层和返回之间有一个良好的过渡。
- en: After you have dropped your attack animation(s) into the Animator, you will
    need to connect them using the transition conditions. I have added three more
    parameters to the parameter list named attack1, attack2, and attack3\. These parameters,
    in connection with the Attack parameter, will determine which attack state our
    NPC will transition to.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将攻击动画（们）放入动画器后，你需要使用过渡条件将它们连接起来。我已经将三个额外的参数添加到参数列表中，分别命名为attack1、attack2和attack3。这些参数与攻击参数一起，将确定NPC将过渡到哪个攻击状态。
- en: 'The following screenshot shows the `NPC_Attack` layer as configured up to this
    point:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了配置到这一点的`NPC_Attack`层：
- en: '![](img/00098.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00098.jpeg)'
- en: New parameters
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数
- en: Finally, you want to assign the new `NPC_BarbarianAnimatorController` to the
    NPC prefab(s).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你想要将新的`NPC_BarbarianAnimatorController`分配给NPC预制件（们）。
- en: NPC AI
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC AI
- en: Now it is time to give some intelligence to our NPCs. One of the scripts we
    will need to create is to give the NPC the ability to detect the player. This
    script will be called `NPC_BarbarianMovement.cs`. The script will be used to detect
    if the player is in-sight, calculate the field of view for the NPC, and calculate
    the path from the NPC to the player character.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给我们的NPC添加一些智能了。我们需要创建的一个脚本是将NPC的能力赋予它来检测玩家。这个脚本将被命名为`NPC_BarbarianMovement.cs`。这个脚本将用于检测玩家是否在视野中，计算NPC的视野，以及计算NPC到玩家角色的路径。
- en: 'Here is a listing of the source code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是源代码的列表：
- en: '[PRE3]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'OK, so let''s actually take a look and see what this code is trying to do.
    In the `Awake()` function we are initializing our variables that will be used
    in the script. We have a reference to the `NavMeshAgent`, the `SphereCollider`,
    and the `Animator` components attached to the NPC. These are stored in the `nav`, `col`, and `anim` variables,
    respectively:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们实际看看这段代码试图做什么。在`Awake()`函数中，我们初始化将在脚本中使用的变量。我们有一个指向NPC附加的`NavMeshAgent`、`SphereCollider`和`Animator`组件的引用。这些分别存储在`nav`、`col`和`anim`变量中：
- en: '[PRE4]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need to get a reference to the player and the player animator component.
    These is done through the `player` variable. We are also setting the `playerInSight` variable
    to false by default:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要获取对玩家和玩家动画组件的引用。这是通过`player`变量来完成的。我们还默认将`playerInSight`变量设置为false：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Update()` function is not performing anything major at this point. It is
    just checking to see if the player character is in sight, and, if so, it makes
    sure that the NPC is orienting itself to look at the player.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前`Update()`函数没有执行任何重大操作。它只是检查玩家角色是否在视野中，如果是的话，确保NPC正在调整自己的方向以看向玩家。
- en: Most of the meat of our code is in the `OnTriggerStay()` function. The first
    things we need to do is make sure the object that has entered our collider is
    the player object. This is done by checking the tag attribute on the other collider.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的大部分内容都在`OnTriggerStay()`函数中。我们首先需要做的是确保进入我们碰撞器的对象是玩家对象。这是通过检查另一个碰撞器的标签属性来完成的。
- en: 'If the player is within our collider, then we go ahead and calculate the direction,
    the distance, and the angle of the player relative to the NPC. This is done with
    the following lines:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在我们的碰撞器内，我们就继续计算玩家相对于NPC的方向、距离和角度。这是通过以下行来完成的：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, if the angle is smaller than the `fieldOfViewAngle` variable, we can
    use ray casting to determine if we can hit the player. If that is the case, the
    player is in NPC''s sight:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果角度小于`fieldOfViewAngle`变量，我们可以使用射线投射来确定是否能击中玩家。如果是这样，玩家就在NPC的视野中：
- en: '![](img/00099.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00099.jpeg)'
- en: Debug rays
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 调试射线
- en: There is one more critical calculation the NPC needs to perform. That is how
    to get to the player once it is in range. Once we have established that the player
    is in range and that we are facing the player, we need to make the NPC find its
    way to the player. This is where the `NavMesh` and the `NavMeshAgent` come into
    play.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: NPC需要执行的一个更关键的计算是如何在到达范围内后到达玩家。一旦我们确定玩家在范围内，并且我们面对玩家，我们需要让NPC找到到达玩家的路径。这就是`NavMesh`和`NavMeshAgent`发挥作用的地方。
- en: The `CalculatePathLength()` is a function that takes the position of the player
    and, using the mesh data, it calculates the best path to navigate from the NPCs
    location to the player's location.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculatePathLength()`是一个函数，它接受玩家的位置，并使用网格数据，计算出从NPC位置到玩家位置的最佳路径。'
- en: 'However, there is one more additional calculation we are performing, and that
    is, we are calculating the length of the path between the two points. This length
    calculation will be used in the future to perform the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还在执行一个额外的计算，那就是计算两点之间的路径长度。这个长度计算将在未来用于执行以下操作：
- en: If the length of the path is larger than a threshold we have set, then we won't
    make the NPC attack. If it is within mean, then we can make the NPC move towards
    the player to engage in battle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径长度超过我们设定的阈值，那么我们不会让NPC发起攻击。如果它在平均值范围内，那么我们可以让NPC向玩家移动以进行战斗。
- en: 'In the last function `OnTriggerExit()`, we set the `playerInSight` variable
    to false. This will stop the NPC from pursuing the player:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个函数`OnTriggerExit()`中，我们将`playerInSight`变量设置为false。这将阻止NPC追逐玩家：
- en: '![](img/00100.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: Navmesh path
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Navmesh path
- en: The preceding screenshot illustrates the path between the NPC and the player
    based on real-time calculation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图展示了基于实时计算的NPC和玩家之间的路径。
- en: 'Go ahead and attach the script to the NPC prefab if you have not done so already,
    and run the application to test it out. If all things are good, then you will
    be able to move the player character around the level, and once the player character
    enters the NPC field of view, the NPC will start moving towards the player and
    when close enough, it will attack:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请将脚本附加到NPC预制体上，并运行应用程序以测试它。如果一切正常，那么你将能够移动玩家角色在关卡中移动，一旦玩家角色进入NPC视野，NPC将开始向玩家移动，并在足够接近时攻击：
- en: '![](img/00101.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: 'At this point, your NPC should have the following components attached to its
    prefab:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的NPC应该在其预制体上附加以下组件：
- en: Animator
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator
- en: Rigidbody
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody
- en: Capsule and sphere colliders
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Capsule和sphere colliders
- en: NavMesh Agent
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NavMesh Agent
- en: '`NPC_BarbarianMovement` script'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NPC_BarbarianMovement`脚本'
- en: We have covered a lot of information. I would encourage you to take the time
    to read through it one more time and understand the concepts before moving forward.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了大量的信息。我鼓励你花时间再次阅读它，并在继续之前理解这些概念。
- en: PC and NPC interaction
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PC和NPC交互
- en: Thus far, we have created the basics movement for both our PC and NPC. The next
    item I would like to complete is the attack mechanism for the PC and the NPC characters.
    Let's start by implementing the hit for the NPC.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的PC和NPC创建了基本移动。我接下来想要完成的是PC和NPC角色的攻击机制。让我们先实现NPC的击中效果。
- en: Our NPC detects the player character based on the code we just created in the
    previous section. When the player character is in sight, the NPC will find the
    shortest path to the player character, and at a given range, it will attack the
    player character. We have the movement and animation mechanics completed. The
    next objective is to keep track of the hit points when the NPC is attacking.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在上一节中创建的代码，我们的NPC能够检测到玩家角色。当玩家角色在视野中时，NPC将找到到达玩家角色的最短路径，并在给定范围内攻击玩家角色。我们已经完成了移动和动画机制。下一个目标是跟踪NPC攻击时的生命值。
- en: 'There are a few adjustments we need to make in `NPC_Animator_Controller`. Open
    the Animator window, and select the `NPC_Attack` layer:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`NPC_Animator_Controller`中进行一些调整。打开Animator窗口，并选择`NPC_Attack`层：
- en: '![](img/00102.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: NPC attack layer
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: NPC攻击层
- en: Double-click on the *attack1* state, or the attack state you have defined in
    your state machine. This will open the related animation in the Inspector window.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 双击*attack1*状态，或者你在状态机中定义的攻击状态。这将在检查器窗口中打开相关的动画。
- en: 'In the Inspector window, scroll down to the *Curves* section. We are going
    to create a new curve by selecting the (+) sign under the *Curves* section. We
    are also going to create a new parameter called *Attack1C* to represent the value
    of the curve. This parameter should of type float:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器窗口中，向下滚动到 *曲线* 部分。我们将通过在 *曲线* 部分的 (+) 符号下选择来创建一个新的曲线。我们还将创建一个新的参数，称为 *Attack1C*，以表示曲线的值。此参数应为
    float 类型：
- en: '![](img/00103.gif)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: 'The curve displayed in the preceding screenshot will be based on your animation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个屏幕截图显示的曲线将基于你的动画：
- en: '![](img/00104.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: In the preceding screenshot, I have marked the important parts of the interface
    that you will need to work with to configure the curve of an animation. The first
    step would be to actually preview your animation and get a feeling for it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中，我标记了你需要与之交互以配置动画曲线的接口的重要部分。第一步是实际预览你的动画，并对其有一个感觉。
- en: The next step for my particular animation sequence was determining when the
    right arm of the model is coming along and I set a marker in the curve. I make
    another marker a bit more into the animation where the right arm has crossed a
    good deal from the right side to the left side.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我特定的动画序列的下一步是确定模型的右手何时进入，我在曲线上设置了一个标记。我在动画中稍后位置又设置了一个标记，此时右手已经从右侧很好地跨到了左侧。
- en: 'These markers will indicate a hit point during the animation when the NPC is
    in attack mode:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标记将在 NPC 攻击模式下的动画中指示击中点：
- en: '![](img/00105.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: OK, why do we do this? Simple. This will help us only generate a hit based on
    the curve of the animation. This way, we don't hit the player and reduce the health
    of the player while the weapon is away from the player's body.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们为什么要这样做呢？简单。这将帮助我们仅根据动画曲线生成击中效果。这样，当武器远离玩家身体时，我们不会击中玩家并减少玩家的生命值。
- en: Next, we need to update out `NPC_BarbarianMovement.cs` code to program the NPC
    attack.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的 `NPC_BarbarianMovement.cs` 代码来编程 NPC 攻击。
- en: 'Note: I have only listed the portions that have been updated.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我只列出了已更新的部分。
- en: 'Here is an updated listing of the code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的更新列表：
- en: '[PRE7]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new addition to the code checks to see if the player is in sight, and if
    that is the case, we check to see if we are in range to be able to attack. If
    that is the case, we get into the attack mode. If we are in the attack mode, the
    attack animation is played.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的新增部分检查玩家是否在视线范围内，如果是这样，我们检查我们是否在攻击范围内。如果是这样，我们就进入攻击模式。如果我们处于攻击模式，就播放攻击动画。
- en: In the code, we check to get the value of the newly created parameter called
    Attack1, and if it happens to be of value 1.0, then we go ahead and reduce the
    health of the player character.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们检查新创建的参数 *Attack1* 的值，如果它恰好是 1.0，我们就继续减少玩家角色的生命值。
- en: If the player dies while the NPC is attacking, it will stop attacking and go
    back into the idle state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在 NPC 攻击时死亡，它将停止攻击并返回空闲状态。
- en: 'OK, you might be wondering how did we get the ability to get the information
    from the player character. This is because we need to make some more additional
    C# scripts. Let''s go ahead and do so now. Create the following C# scripts:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可能想知道我们是如何获得从玩家角色获取信息的能力的。这是因为我们需要创建一些额外的 C# 脚本。让我们继续这样做。创建以下 C# 脚本：
- en: '`PlayerCharacter.cs`: This is going to be our player character class, which
    inherits from the `BaseCharacter` class we have defined previously'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerCharacter.cs`: 这将是我们的玩家角色类，它将继承我们之前定义的 `BaseCharacter` 类'
- en: '`PlayerAgent.cs`: This is going to be used to store the PC data and also inherit
    `MonoBehaviour`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerAgent.cs`: 这将用于存储玩家数据并继承 `MonoBehaviour`'
- en: '`NPC.cs`: This is going to be our non-player character class, which inherits
    from the `BaseCharacter` class as well'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NPC.cs`: 这将是我们的非玩家角色类，它将继承自 `BaseCharacter` 类'
- en: '`NPC_Agent.cs`: This is going to be used to store the NPC data and also inherit
    `MonoBehaviour`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NPC_Agent.cs`: 这将用于存储 NPC 数据并继承 `MonoBehaviour`'
- en: 'I have made some modification to the `BaseCharacter.cs` script to make it more
    accessible through the editor. Here is the new listing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 `BaseCharacter.cs` 脚本进行了一些修改，使其通过编辑器更容易访问。以下是新的列表：
- en: '[PRE8]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I have gone ahead and made the class and the fields serializable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了类和字段，使其可序列化。
- en: 'Let''s take a look at the listing for `PlayerCharacter.cs`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `PlayerCharacter.cs` 的列表：
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is nothing much going on there at this point. Now let''s take a look
    at the `PlayerAgent.cs`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 目前那里没有什么动作。现在让我们看看`PlayerAgent.cs`：
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the player agent code, we are initializing some default values for our PC
    data in the `Awake()` function. Since the class has been serialized, we can actually
    see the data during runtime for debugging purposes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家代理代码中，我们在`Awake()`函数中为我们的PC数据初始化了一些默认值。由于类已被序列化，我们实际上可以在运行时看到这些数据，用于调试目的。
- en: In the `Update()` function, we check to see if the health of our PC is less
    than 0.0f, and if it is, then this indicates the player has died. Then we use
    the `CharacterController` component we have created to set the *die* property
    to true. The `CharacterController` then will use the new value and communicate
    with the Animator Controller for the player character to get into the die state.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`函数中，我们检查我们的PC的健康值是否小于0.0f，如果是，那么这表明玩家已经死亡。然后我们使用我们创建的`CharacterController`组件将*死亡*属性设置为true。`CharacterController`随后将使用新值并与玩家角色的动画控制器通信，使玩家角色进入死亡状态。
- en: Notice that our `NPC_BarbarianMovement.cs` script is accessing the exact same
    PC data through the reference we have created in the script.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`NPC_BarbarianMovement.cs`脚本正在通过脚本中创建的引用访问确切的PC数据。
- en: 'You will need to attach the `PlayerAgent.cs` script to your player character
    in the scene:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`PlayerAgent.cs`脚本附加到场景中的玩家角色上：
- en: '![](img/00106.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: Player character data
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色数据
- en: In the preceding screenshot, you can see the additions we have done to the scripts
    and how they look during runtime. We will have a listing for the `NPC.cs` and
    `NPC_Agent.cs` in future chapters. At this point, they are not used.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到我们对脚本所做的添加以及它们在运行时的外观。我们将在未来的章节中列出`NPC.cs`和`NPC_Agent.cs`。目前，它们尚未使用。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a very involved one. We covered some very important topics
    and concepts in the chapter that can be used and enhanced for your games. We started
    the chapter by looking into how to customize your player character. The concepts
    you take away from the section can be applied to a wide variety of scenarios.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章内容非常丰富。我们涵盖了章节中一些非常重要的主题和概念，这些可以用于并增强您的游戏。我们通过研究如何定制玩家角色开始了这一章。您从该部分学到的概念可以应用于各种不同的场景。
- en: We looked at how to understand the structure of your character model so that
    you can better determine the customization methods. These are the different types
    of weapons, clothing, armor, shields, and on.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了如何理解您的人物模型的结构，以便您可以更好地确定定制方法。这些包括不同的武器、服装、盔甲、盾牌等等。
- en: We then looked at how to create a user interface to help enable us with the
    customization of our player character during game play. We also learned that the
    tool we developed can be used to quickly create several different character models
    (customized) and store them as prefabs for later use. Great time saver! We also
    learned how to preserve the state of our player character after customization
    for game play.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着研究了如何创建用户界面，以帮助我们在游戏过程中定制我们的玩家角色。我们还了解到，我们开发的工具可以快速创建几个不同的角色模型（定制）并将它们作为预制件存储以供以后使用。节省了大量时间！我们还学习了如何在定制后保存玩家角色的游戏状态。
- en: We looked at the non-player characters next. We went through the basics of setting
    up the NPC with the different necessary components. We then looked at how to create
    a Navmesh and how to work with Navmesh Agent and Pathfinding using the Navmesh.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来研究了非玩家角色。我们了解了如何设置NPC的不同必要组件的基础知识。然后我们研究了如何创建导航网格以及如何使用导航网格与导航网格代理和路径查找进行交互。
- en: We created a new Animator Controller for the NPC. We created a 2D Freeform Cartesian
    Blend Tree that was used for the animation of the NPC. We looked at how to create
    multiple layers in the Animation Controller and enable IK for different regions
    of the humanoid skeleton. We created the initial NPC AI script to detect and determine
    if the player is close enough for it to make a move and attack. Finally, we created
    new scripts to make interaction between the NPC and the player character possible.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为NPC创建了一个新的动画控制器。我们创建了一个用于NPC动画的2D自由形式笛卡尔混合树。我们研究了如何在动画控制器中创建多个层级并启用不同区域的人形骨骼的逆运动学（IK）。我们创建了初始的NPC
    AI脚本，用于检测并确定玩家是否足够接近，以便它进行移动和攻击。最后，我们创建了新的脚本，使NPC与玩家角色之间的交互成为可能。
- en: By the end of the chapter, you should have a good grasp of how everything is
    interrelated and have an idea of how to approach your project.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对一切是如何相互关联的有一个很好的理解，并且对如何处理你的项目有一个想法。
- en: In the next chapter, we will create a better way to manage our game state.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创造一种更好的方法来管理我们的游戏状态。
