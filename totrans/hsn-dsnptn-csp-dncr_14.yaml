- en: Advanced Database Design and Application Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据库设计和应用技术
- en: In the previous chapter, we learned about reactive programming by discussing
    its principles and models. We also discussed and looked at examples of how reactive
    programming is all about data streams.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过讨论其原理和模型来了解响应式编程。我们还讨论并查看了一些关于响应式编程如何全部关于数据流的例子。
- en: Database designing is a complex task and needs a lot of patience. In this chapter,
    we will discuss advanced database and application techniques, including applying
    **Command Query Responsibility Segregation** (**CQRS**) and ledger-style databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计是一项复杂的工作，需要很多耐心。在本章中，我们将讨论高级数据库和应用技术，包括应用**命令查询责任分离**（**CQRS**）和库存式数据库。
- en: Similar to previous chapters, a requirement gathering session will be illustrated
    in order to determine the **Minimum Viable Product** (**MVP**). In this chapter,
    several factors will be used to lead the design to CQRS. We will be using a ledger-style
    approach that consists of increased tracking of changes to inventory levels, as
    well as wanting to provide public APIs for retrieving inventory levels. This chapter
    will cover why developers use ledger-style databases and why we should focus on
    CQRS implementation. In this chapter, we will see why we adapt the CQRS pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章类似，为了确定**最小可行产品**（**MVP**），将展示一个需求收集会议。在本章中，将使用几个因素来引导设计到CQRS。我们将采用一种库存式方法，该方法包括对库存水平变化的跟踪增加，以及希望提供用于检索库存水平的公共API。本章将涵盖为什么开发者使用库存式数据库以及为什么我们应该关注CQRS实现。在本章中，我们将看到为什么我们采用CQRS模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Use case discussion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例讨论
- en: Database discussion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库讨论
- en: Ledger-style databases for inventory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存式数据库
- en: Implementing the CQRS pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CQRS模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demo purposes. Most of the examples involve a .NET
    Core console application written in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释概念。代码保持简单，仅用于演示目的。大多数示例涉及用C#编写的.NET Core控制台应用程序。
- en: To run and execute the code, Visual Studio 2019 is a prerequisite (you can also
    use Visual Studio 2017 to run the application).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，Visual Studio 2019是必备条件（您也可以使用Visual Studio 2017来运行应用程序）。
- en: Installing Visual Studio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio (preferred IDE).
    To do so, follow these instructions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio（首选IDE）。为此，请按照以下说明操作：
- en: 'Download Visual Studio 2017 (or version 2019) from the following download link:
    [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下下载链接下载Visual Studio 2017（或版本2019）：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions that are accessible through the previous
    link. Multiple options are available for Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照可从前一链接访问的安装说明进行操作。Visual Studio安装有多种选项。在这里，我们使用Windows版本的Visual Studio。
- en: Setting up .NET Core
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装 .NET Core，您需要按照以下说明操作：
- en: 'Download .NET Core for Windows: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载.NET Core for Windows：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多个版本和相关库，请访问[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: 'If you do not have SQL Server installed, you need to follow these instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装SQL Server，您需要按照以下说明操作：
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: You can find the installation instructions at [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)找到安装说明。
- en: 'For troubleshooting and for more information, refer to the following link:
    [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如需故障排除和更多信息，请参阅以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: Use case discussion
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例讨论
- en: In this chapter, we will continue with our FlixOne inventory application. Throughout
    this chapter, we will discuss CQRS patterns and extend the web application that
    we developed in the previous chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续讨论FlixOne库存应用。在整个章节中，我们将讨论CQRS模式，并扩展我们在前几章中开发的Web应用程序。
- en: This chapter continues with the web application that was developed in the previous
    chapter. If you skipped the previous chapter, please revisit it in order to aid
    your understanding of the current chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续讨论前一章中开发的Web应用程序。如果您跳过了前一章，请重新阅读以帮助您理解本章内容。
- en: In this section, we will go through the process of requirement gathering, and
    then discuss the various challenges with our web application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论需求收集的过程，然后讨论我们Web应用程序的各种挑战。
- en: Project kickoff
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目启动
- en: 'In [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml), *Implementing Design
    Patterns for Web Applications – Part 2*, we extended FlixOne Inventory and added
    authentication and authorization to the web application. We extended the application
    after considering the following points:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml)《为Web应用程序实现设计模式 – 第2部分》中，我们扩展了FlixOne库存，并在Web应用程序中添加了身份验证和授权。在考虑以下要点后，我们扩展了应用程序：
- en: The current application is open for all; therefore, any user can visit any page,
    even restricted pages.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序对所有用户开放；因此，任何用户都可以访问任何页面，即使是受限页面。
- en: Users should not access pages that require access or special access rights;
    these pages are also known as restricted pages or pages with limited access.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不应访问需要访问权限或特殊访问权限的页面；这些页面也被称为受限页面或有限访问页面。
- en: Users should be able to access pages/resources as per their roles.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够根据其角色访问页面/资源。
- en: 'In [Chapter 10](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml), *Reactive Programming
    Patterns and Techniques*, we further extended our FlixOne Inventory application
    and added paging, filtering, and sorting to all pages that show listings. The
    following points were considered while we extended the app:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml)《反应式编程模式和技巧》中，我们进一步扩展了FlixOne库存应用，并为显示列表的所有页面添加了分页、过滤和排序功能。在扩展应用时，我们考虑了以下要点：
- en: '**Item filtering**: Currently, users are unable to filter items by their categories.
    To extend this feature, users should be able to filter product items based on
    their categories.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目过滤**：目前，用户无法根据其类别过滤项目。为了扩展此功能，用户应能够根据其类别过滤产品项目。'
- en: '**Item sorting**: Currently, items are appearing in the order in which they
    have been added to the database. There is no mechanism that enables the user to
    sort items based on categories such as item name or price.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目排序**：目前，项目以它们被添加到数据库中的顺序显示。没有机制允许用户根据项目名称或价格等类别对项目进行排序。'
- en: Requirements
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: 'After several meetings and discussions with management, **Business Analyst**
    (**BA**), and pre-sales staff, management decided to work on the following high-level
    requirements: business requirements and technical requirements.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 经过与管理部门、**业务分析师**（**BA**）和预销售团队的多次会议和讨论后，管理部门决定着手以下高级需求：业务需求和技术需求。
- en: Business requirements
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务需求
- en: 'On the basis of discussions with stakeholders and endusers, and as per the
    market survey, our business team has listed the following requirements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基于与利益相关者和最终用户的讨论，以及市场调查，我们的业务团队列出了以下需求：
- en: '**Product expansion**: The product is reaching different users. This is a good
    time to expand the application. The application will robust to expand after having
    expanded it.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品扩展**：产品正在触及不同的用户。现在是扩展应用的好时机。扩展后，应用将更加稳健。'
- en: '**Product model**: Being an inventory management application, users should
    feel freedom (this mean no restriction at model level, without complicated validations)
    and there should not be any restriction while users are interacting with the application.
    Every screen and page should be self-explanatory.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品模型**：作为一个库存管理应用程序，用户应该感到自由（这意味着在模型级别没有限制，没有复杂的验证）并且在与应用程序交互时不应有任何限制。每个屏幕和页面都应该一目了然。'
- en: '**Database design**: The application''s database should be designed in such
    a way that the expansion should not take much time.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库设计**：应用程序的数据库应该设计得尽可能快地扩展。'
- en: Technical requirements
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The actual requirements that meet business needs are now ready for development.
    After several discussions with business staff, we concluded that the following
    are the requirements:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 满足业务需求的实际需求现在已准备好开发。经过与业务人员的多次讨论，我们得出以下结论：
- en: 'The following are the requirements for the **landing** or **home page**:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对**着陆页**或**主页**的要求：
- en: Should be a dashboard that contains various widgets
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该是一个包含各种小部件的仪表板
- en: Should show an at-a-glance picture of the store
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该展示商店的直观图像
- en: 'The following are the requirements for the **product page**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对**产品页**的要求：
- en: Should have the capability to add, update, and delete products
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该具备添加、更新和删除产品的功能
- en: Should have the capability to add, update, and delete product categories
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该具备添加、更新和删除产品类别的功能
- en: The FlixOne Inventory Management web application is an imaginary product. We
    are creating this application to discuss the various design patterns that are
    required/used in web projects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne库存管理Web应用是一个虚构的产品。我们创建这个应用是为了讨论在Web项目中需要/使用的各种设计模式。
- en: Challenges
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Although we have extended our existing web application, it has various challenges
    for both developers and businesses. In this section, we will discuss these challenges
    and then we will find out the solutions to overcome these challenges.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经扩展了现有的Web应用程序，但它对开发者和商业都存在各种挑战。在本节中，我们将讨论这些挑战，然后我们将找出克服这些挑战的解决方案。
- en: Challenges for developers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者面临的挑战
- en: 'The following are the challenges that arose due to a big change in the application.
    They were also a result of the major extensions associated with upgrading a console
    application to a web application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由于应用程序发生重大变化而出现的挑战。它们也是将控制台应用程序升级到Web应用程序的主要扩展的结果：
- en: '**No support for RESTful services**: Currently, there is no support for RESTful
    services because no APIs have been developed.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持RESTful服务**：目前没有支持RESTful服务，因为没有开发API。'
- en: '**Limited security**: In the current application, there is only one mechanism
    that can restrict/permit the user from/to gaining access to a particular screen
    or module of the application: that is, by the login.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性有限**：在当前的应用程序中，只有一个机制可以限制/允许用户访问应用程序的特定屏幕或模块：那就是登录。'
- en: Challenges for businesses
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业面临的挑战
- en: 'The following challenges occur as we adapt a new technology stack, and there
    are plenty of changes in the code. Therefore, it takes time to achieve the final
    output, which delays the product, resulting in a loss for the business:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们适应新的技术栈时，会出现以下挑战，代码中也有很多变化。因此，达到最终输出需要花费时间，这导致产品延迟，从而给业务带来损失：
- en: '**Loss of clientele**: Here, we are still in the development stage but the
    demand for our business is very high. However, the development team is taking
    longer than expected to deliver the product.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户流失**：在这里，我们仍处于开发阶段，但对我们业务的需求非常高。然而，开发团队交付产品的速度比预期要慢。'
- en: '**It takes more time to roll out the production updates**: Development efforts
    are time-consuming at the moment and this delays the subsequent activities, leading
    to a delay in production.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推出生产更新需要更多时间**：目前开发工作耗时较多，这导致后续活动延迟，进而导致生产延迟。'
- en: Providing a solution to the problems/challenges
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供解决问题/挑战的解决方案
- en: After several meetings and brainstorming sittings, the development team came
    to the conclusion that we have to stabilize our web-based solution. To overcome
    these challenges and provide the solution, the tech team and business team got
    together to identify the various solutions and points.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几轮会议和头脑风暴会议后，开发团队得出结论，我们必须稳定我们的基于Web的解决方案。为了克服这些挑战并提供解决方案，技术团队和业务团队聚集在一起，确定各种解决方案和要点。
- en: 'The following are the points supported by the solution:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由解决方案支持的要点：
- en: Evolve RESTful webservices—there should be one API dashboard
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展RESTful Web服务——应该有一个API仪表板
- en: Strictly following **T****est-Driven Development** (**TDD**)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格遵循**测试驱动开发**（**TDD**）
- en: Re-designing the **user interface** (**UI**) to meet the user experience expectations
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新设计**用户界面**（**UI**）以满足用户体验的期望
- en: Database discussion
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库讨论
- en: 'Before we start with the database discussion we have to consider the following
    points—a big picture of our FlixOne web application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始数据库讨论之前，我们必须考虑以下要点——我们FlixOne Web应用程序的总体情况：
- en: One part of our application is inventory management, but another part of it
    is an e-commerce web application.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序的一部分是库存管理，但另一部分是电子商务Web应用程序。
- en: The challenging part is that our application would also serve as a **Point Of
    Sale** (**POS**). In this part/module, the user can pay for the items they have
    purchased from offline counters/outlets.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战在于我们的应用程序还将作为**销售点**（**POS**）。在这一部分/模块中，用户可以从线下柜台/网点支付他们所购买的物品。
- en: For the inventory part, we need to address which approach we will be taking
    to calculate and maintain accounts and transactions, and to determine the cost
    of any item sold.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于库存部分，我们需要确定我们将采取哪种方法来计算和维护账户和交易，以及确定任何售出物品的成本。
- en: To maintain stock for inventories, various options are available, with the two
    most commonly used options being **First In First Out** (**FIFO**) and **Last
    In First Out** (**LIFO**).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了维护库存，有多种选择，其中最常用的两种选项是**先进先出**（**FIFO**）和**后进先出**（**LIFO**）。
- en: 'Most of the transactions involve financial data, hence these transactions require
    historical data. Every record should have the following information: current value,
    the value before current changes, and the changes made.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数交易涉及财务数据，因此这些交易需要历史数据。每个记录都应该包含以下信息：当前价值，当前变化前的价值，以及所做的更改。
- en: While we're maintaining inventory, we are also required to maintain the items
    purchased.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在维护库存时，我们还必须维护所购买的物品。
- en: There are more points that are important when designing a database for any e-commerce
    web application. We are limiting our scope for the FlixOne application in order
    to showcase the inventory and stock management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何电子商务Web应用程序设计数据库时，还有更多重要的要点。我们正在限制FlixOne应用程序的范围，以便展示库存和库存管理。
- en: Database processing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库处理
- en: Similar to the other topics we have covered in this book, there are a large
    number of databases ranging from basic patterns concerning the schema of a database
    to patterns that govern how database systems are put together. This section will
    cover two system patterns, **Online Transaction Processing** (**OLTP**) and **Online
    Analytical Processing** (**OLAP**). To further understand database design patterns,
    we will explore a specific pattern, ledger-style databases, in more detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在本书中涵盖的其他主题类似，数据库的种类繁多，从涉及数据库模式的基本模式到规范数据库系统如何组合的模式。本节将涵盖两个系统模式，**在线事务处理**（**OLTP**）和**在线分析处理**（**OLAP**）。为了进一步了解数据库设计模式，我们将更详细地探讨一个特定模式，即账簿式数据库。
- en: A database schema is another word for the collection of tables, views, stored
    procedures, and other components that make up a database. Think of this as the
    *blueprint* of the database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式是表格、视图、存储过程和其他组成数据库的组件的集合的另一种说法。将其视为数据库的**蓝图**。
- en: OLTP
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OLTP
- en: An OLTP database has been designed to handle large numbers of statements that
    cause changes to the database. Basically, the `INSERT`, `UPDATE`, and `DELETE`
    statements all cause changes and behave very differently from the `SELECT` statement.
    OLTP databases have been designed with this in mind. Because these databases record
    changes, they are typically the *main* or *master*database, meaning that they
    are the repositories that hold the current data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OLTP数据库已被设计来处理大量导致数据库变化的语句。基本上，`INSERT`、`UPDATE`和`DELETE`语句都会导致变化，并且与`SELECT`语句的行为非常不同。OLTP数据库正是基于这一点设计的。因为这些数据库记录变化，它们通常是**主要**或**主**数据库，这意味着它们是存储当前数据的存储库。
- en: The `MERGE` statement also qualifies as a statement that causes change. This
    is because it provides a convenient syntax for the insertion of a record when
    a row does not exist, and the insertion of an update when a row does exist. It
    will update when a row does exist. The `MERGE` statement is not supported in all
    database providers or versions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE`语句也符合导致变化的语句的资格。这是因为它提供了一个方便的语法，用于在不存在行时插入记录，在存在行时更新记录。当存在行时，它将进行更新。`MERGE`语句并不在所有数据库提供程序或版本中得到支持。'
- en: OLTP databases are typically designed to process change statements quickly.
    This is normally done by the careful planning of table structures. A simple way
    of viewing this is to consider a database table. This table can have fields for
    storing data, keys for looking up the data efficiently, indexes to other tables,
    triggers to respond to specific situations, and other table constructs. Each one
    of these constructs has a performance penalty. The design of OLTP databases is,
    therefore, a balance between using the minimum number of constructs on a table
    versus the desired behavior.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: OLTP数据库通常设计为快速处理变化语句。这通常是通过仔细规划表结构来完成的。简单来说，可以考虑数据库表。这个表可以包含用于存储数据的字段、用于高效查找数据的键、指向其他表的索引、用于响应特定情况的触发器以及其他表结构。这些结构中的每一个都有性能惩罚。因此，OLTP数据库的设计是在表上使用最少数量的结构与其所需行为之间取得平衡。
- en: Let's consider a table that records the books in our inventory system. Each
    book might record the name, quantity, date published, and have references to author
    information, publishers, and other related tables. We could put an index on all
    columns and even add indexes for the data in related tables. The problem with
    this approach is that each index has to be stored and maintained for each statement
    that causes change. Database designers have to carefully plan and analyze databases
    in order to determine the optimal combination of adding and, just as importantly,
    not adding indexes and other constructs to tables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个记录我们库存系统中书籍的表。每本书可能记录名称、数量、出版日期，并包含作者信息、出版商和其他相关表的引用。我们可以在所有列上放置索引，甚至为相关表中的数据添加索引。这种方法的问题在于，每个索引都必须为每个导致变化的语句存储和维护。数据库设计者必须仔细规划和分析数据库，以确定添加索引和其他表结构的最佳组合，同样重要的是，不添加索引和其他结构。
- en: A table index can be thought of like a virtual lookup table that provides the
    relational database with a faster way of looking up data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将表索引视为一个虚拟查找表，它为关系数据库提供了一种更快的数据查找方式。
- en: OLAP
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OLAP
- en: Databases designed using the OLAP pattern are expected to have more `SELECT`
    statements than statements that cause change. These databases usually have a consolidated
    view of the data of one or more databases. Because of this, these databases are
    usually not the master database, but a database used to provide reporting and
    analysis separate from the master database. In some situations, this is provided
    on infrastructure isolated from other databases so as to not impact the performance
    of operational databases. This type of deployment is often referred to as a **data
    warehouse**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OLAP模式设计的数据库预计会有比导致变化的语句更多的`SELECT`语句。这些数据库通常有一个或多个数据库数据的综合视图。正因为如此，这些数据库通常不是主数据库，而是一个用于提供与主数据库分离的报表和分析的数据库。在某些情况下，这种部署是在与其他数据库隔离的基础设施上提供的，以避免影响操作数据库的性能。这种部署通常被称为**数据仓库**。
- en: A data warehousecan be used to provide a consolidated view of a system or collection
    of systems within an enterprise. The data is traditionally fed with slower periodical
    jobs to refresh the data from other systems, but with modern database systems,
    this is trending towards near real-time consolidation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数据仓库可以用来提供一个企业内部系统或系统集合的统一视图。数据传统上通过较慢的周期性作业从其他系统刷新数据，但现代数据库系统正趋向于接近实时地合并。
- en: The major difference between OLTP and OLAP is around how the data is stored
    and organized. In many situations, this would require tables or persistent views—depending
    on the technology used—to be created in the OLAP database that supports specific
    reporting scenarios and duplicates the data. In OLTP databases, duplication of
    data is undesirable as it then introduces multiple tables that need to be maintained
    for a single statement that causes change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OLTP和OLAP之间的主要区别在于数据的存储和组织方式。在许多情况下，这需要创建表或持久视图——取决于所使用的技术——以支持特定的报告场景并复制数据。在OLTP数据库中，数据复制是不希望的，因为它会引入需要维护的多个表，而这些表只针对一个引起变化的单个语句。
- en: Ledger-style databases
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账簿式数据库
- en: 'The ledger-style database design will be highlighted, as it is both a pattern
    that has been used in many financial databases for decades and it may not be known
    to some developers. The ledger-style database stems from an accountant''s ledger,
    where transactions were added to a document and the quantities and/or amounts
    are tallied in order to arrive at a final quantity or amount. The following table
    shows a ledger of the sale of apples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 账簿式数据库设计将被突出显示，因为它是一种在许多金融数据库中使用了几十年的模式，并且可能一些开发者并不知道。账簿式数据库源于会计的账簿，其中交易被添加到文件中，数量和/或金额被总计，以便得出最终的数量或金额。以下表格显示了苹果销售的账簿：
- en: '![](img/f1a0135c-e2a0-406c-8ce9-2c20c019ee12.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1a0135c-e2a0-406c-8ce9-2c20c019ee12.png)'
- en: There are a couple of things to point out about the example. The Purchaser information
    is written on separate rows instead of erasing their amounts and entering a new
    amount. Take the two purchases and one credit for West Country Produce. This is
    typically different from many databases in which a single row contains the Purchaser
    information with separate fields for the Amount and Price.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于示例，有几件事情需要指出。购买者信息是单独写在不同的行上，而不是删除它们的金额并输入新的金额。考虑两个购买和一个对西乡村产品的信用。这通常与许多数据库不同，在许多数据库中，一个单独的行包含购买者信息，有单独的字段用于金额和价格。
- en: A ledger-style database takes this concept by having a separate row per transaction,
    thus removing the `UPDATE` and `DELETE` statements and only relying on `INSERT`
    statements. This has several benefits. Similarly to a ledger, once each transaction
    has been written it cannot be removed or changed. If a mistake or a change occurs,
    such as the credit to West Country Produce, a new transaction needs to be written
    in order to arrive at the desired state. An interesting benefit of this is that
    the source table now has the immediate value of providing a detailed log of the
    activity. If we were to add a *modified by* column, we could then have a comprehensive
    log of who or what made the change and what the change was.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 账簿式数据库通过为每笔交易保留单独的行来采用这个概念，从而消除了`UPDATE`和`DELETE`语句，并且只依赖于`INSERT`语句。这有几个好处。类似于账簿，一旦每笔交易被写入，就不能被删除或更改。如果发生错误或更改，例如对西乡村产品的贷方，就需要写入一笔新的交易，以便达到期望的状态。这个有趣的好处是，源表现在立即具有提供详细活动日志的价值。如果我们添加一个*修改者*列，我们就可以有一个全面的日志，记录谁或什么导致了更改以及更改的内容。
- en: This example is for a single-entry ledger, but in the real world, a double-entry
    ledger would be used. The difference is that in a double-entry ledger, each transaction
    is recorded as a credit in one table and a debit in another.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个单条目账簿，但在现实世界中，会使用双条目账簿。区别在于在双条目账簿中，每一笔交易都记录在一个表中的贷方和另一个表中的借方。
- en: 'The next challenge is capturing the final or rolled-up version of the table.
    In this example, that is that amount of apples that have been purchased and for
    how much. The first approach could use a `SELECT` statement that simply performs
    `GROUP BY` on the purchaser, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个挑战是捕获表的最终或汇总版本。在这个例子中，就是购买了多少苹果以及价格。第一种方法可以使用一个`SELECT`语句，简单地根据购买者执行`GROUP
    BY`，如下所示：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this would be fine for smaller data sizes, the issue here is that the
    performance of the query would degrade over time as the number of rows increases.
    An alternative would be to aggregate the data into another form. There are two
    main ways of achieving this. The first is to perform this activity at the same
    time as you write the information from the ledger table into another table (or
    persistent view if supported) that holds the data in an aggregate form.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于较小的数据量来说是可行的，但问题是随着行数的增加，查询的性能会随着时间的推移而下降。一个替代方案是将数据聚合成另一种形式。主要有两种实现方式。第一种是在将信息从账本表写入另一个表（或支持的持久视图）时同时执行此活动，该表以聚合形式存储数据。
- en: A **persistent** or **materialized view** is similar to a database view, but
    the results of the view are cached. This gives us the benefit of not requiring
    the view to be recalculated on each request, and it is either refreshed periodically
    or when the underlying data changes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久**或**物化视图**类似于数据库视图，但视图的结果被缓存。这使我们无需在每次请求时重新计算视图，并且视图要么定期刷新，要么在底层数据更改时刷新。'
- en: The second approach relies on another mechanism that is separate from the `INSERT`
    statement to retrieve the aggregated view when required. In some systems, the
    primary scenario of writing changes to a table and retrieving the result is performed
    less frequently. In this case, it would make more sense to optimize the database
    so that writes are faster than reads, therefore limiting the amount of processing
    required when new records are inserted.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法依赖于一种与`INSERT`语句不同的机制，在需要时检索聚合视图。在某些系统中，将更改写入表并检索结果的主要场景执行得较少。在这种情况下，优化数据库以使写入速度比读取速度快，因此当新记录插入时，可以限制所需的处理量。
- en: The next section deals with an interesting pattern CQRS that can be applied
    at the database level. This could be used in the ledger-style database design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将处理一个有趣的CQRS模式，该模式可以在数据库级别应用。这可以用于账本式数据库设计。
- en: Implementing the CQRS pattern
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CQRS模式
- en: CQRS simply works on the separation between queries (to read) and commands (to
    modify). **Command-Query Separation** (**CQS**) is an approach to **Object-oriented
    Design** (**OOD**).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS简单地基于查询（读取）和命令（修改）之间的分离。**命令-查询分离**（**CQS**）是**面向对象设计**（**OOD**）的一种方法。
- en: 'CQRS was introduced for the first time by Bertrand Meyer ([https://en.wikipedia.org/wiki/Bertrand_Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer)).
    He mentioned this term in his book, *Object-Oriented Software Construction*, during
    the late 1980s: [https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554](https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS首次由Bertrand Meyer提出（[https://en.wikipedia.org/wiki/Bertrand_Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer)）。他在1980年代末在其著作《面向对象软件构造》中提到了这个术语：[https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554](https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554)。
- en: 'CQRS does fit well with some scenarios and has some useful factors to it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS与某些场景非常契合，并且具有一些有用的因素：
- en: '**Model separation**: In modeling terms, we are able to have multiple representations
    for our data model. The clear separation allows for choosing different frameworks
    or techniques over others that are more suitable for query or command. Arguably,
    this is achievable with **create, read, update, and delete** (**CRUD**)-style
    entities, although the single data layer assembly often emerges.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型分离**：在建模术语中，我们能够为我们的数据模型拥有多个表示形式。这种清晰的分离允许我们选择比其他更适合查询或命令的框架或技术。可以说，这可以通过**创建、读取、更新和删除**（**CRUD**）-风格的实体来实现，尽管通常会出现单一数据层组装。'
- en: '**Collaboration**: In some enterprises, a separation between query and command
    would benefit the teams involved in building complex systems, particularly when
    some teams are more suited for different aspects of an entity. For example, a
    team that is more concerned about presentation could concentrate on the query
    model, while another team that is more focused on data integrity could maintain
    the command model.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：在某些企业中，查询和命令之间的分离将有利于参与构建复杂系统的团队，尤其是当某些团队更适合实体的不同方面时。例如，一个更关注展示的团队可以专注于查询模型，而另一个更专注于数据完整性的团队可以维护命令模型。'
- en: '**Independent scalability**: Many solutions tend to either require more reads
    against the model, or more writes, depending on the business requirements.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立可伸缩性**：许多解决方案倾向于根据业务需求，要么需要更多的模型读操作，要么需要更多的写操作。'
- en: For CQRS, remember that commands update data and queries read data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CQRS，请记住，命令更新数据，查询读取数据。
- en: 'Some important things to note while working on CQRS are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理CQRS时需要注意的一些重要事项如下：
- en: Commands should be placed asynchronously rather than as synchronous operations.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令应该异步放置，而不是作为同步操作。
- en: Databases should never be modified with queries.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要用查询修改数据库。
- en: CQRS simplifies the design with the use of separate commands and queries. Also,
    we can physically separate read data from write data operations. In this arrangement,
    a read database could use a separate database schema, or in other words, we can
    say that it could use a read-only database that is optimized for queries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS通过使用单独的命令和查询简化了设计。此外，我们可以物理上分离读数据和写数据操作。在这种安排中，读数据库可以使用单独的数据库模式，或者换句话说，我们可以称它为使用针对查询优化的只读数据库。
- en: 'As the database uses a physical separation approach, we can visualize the CQRS
    flow of the application, as depicted in the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库使用物理分离方法，我们可以可视化应用CQRS流程，如下面的图所示：
- en: '![](img/a303ee36-9fb8-411d-a49c-26b3f526b63d.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a303ee36-9fb8-411d-a49c-26b3f526b63d.png)'
- en: The preceding diagram depicts an imaginary workflow of the CQRS application,
    in which an application has physically separate databases for write operations
    and read operations. This imaginary application is based on RESTful web services
    (.NET Core APIs). No APIs have been exposed directly to the client/end user who
    is consuming these APIs. There is an API gateway exposed to users, and any requests
    for applications will come through the API gateway.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了CQRS应用的虚构工作流程，其中应用在物理上分别有用于写操作和读操作的数据库。这个虚构的应用基于RESTful Web服务（.NET Core
    API）。没有API直接暴露给使用这些API的客户端/最终用户。有一个API网关暴露给用户，任何对应用的请求都将通过API网关。
- en: The API Gateway provides an entry point to groups with similar types of services.
    You can also simulate it with the facade pattern, which is part of the distributed
    system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: API网关为具有相似类型服务的组提供了一个入口点。您也可以使用分布式系统的一部分外观模式来模拟它。
- en: 'In the previous diagram, we have the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，我们有以下内容：
- en: '**User interface**: This could be any client (who is consuming the APIs), web
    application, desktop application, mobile application, or any other application.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：这可以是任何客户端（使用API的客户端），Web应用，桌面应用，移动应用或任何其他应用。'
- en: '**API Gateway**: Any request from UI and response to UI is delivered from the
    API Gateway. This is the main part of CQRS, as business logic can be incorporated
    by using the Commands and Persistence layers.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：所有来自UI和响应到UI的请求都由API网关传递。这是CQRS的主要部分，因为可以通过使用命令和持久层来集成业务逻辑。'
- en: '**Database(s)**: The diagram shows two physically separated databases. In real
    applications, this depends upon the requirements of the product, and you can use
    the database for both write and read operations.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库（s）**：该图显示了两个物理上分离的数据库。在实际应用中，这取决于产品的需求，你可以使用数据库进行写操作和读操作。'
- en: Queries are generated with `Read` operations that are **Data Transfer Objects**
    (**DTOs**).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询是通过`Read`操作生成的，这些操作是**数据传输对象**（**DTOs**）。
- en: 'You can now go back to the *Use case* section, in which we discussed the new
    features/extensions of our FlixOne inventory application. In this section, we
    will create a new FlixOne application with the features discussed previously using
    the CQRS pattern. Please note that we will be developing APIs first. If you did
    not install the pre-requisites, I suggest revisiting the *Technical requirements*
    section, gathering all of the required software, and installing them onto your
    machine. If you have completed the pre-requisites, then let''s start by following
    these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以回到*用例*部分，其中我们讨论了我们的FlixOne库存应用的新功能/扩展。在本节中，我们将使用CQRS模式创建一个具有先前讨论的功能的新FlixOne应用。请注意，我们将首先开发API。如果您没有安装先决条件，我建议重新查看*技术要求*部分，收集所有必需的软件，并将它们安装到您的机器上。如果您已完成先决条件，那么让我们按照以下步骤开始：
- en: Open Visual Studio.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Click File | New Project to create a new project.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件 | 新建项目以创建一个新的项目。
- en: On the New Project window, select Web and then select ASP.NET Core Web Application.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新建项目窗口中，选择Web，然后选择ASP.NET Core Web应用。
- en: Give a name to your project. I have named our project `FlixOne.API` and ensured
    that the Solution Name is `FlixOne`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的项目起一个名字。我已将我们的项目命名为 `FlixOne.API` 并确保解决方案名称为 `FlixOne`。
- en: 'Select the Location of your `Solution` folder, then click on the OK button
    as shown in the following screenshot:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的 `解决方案` 文件夹的位置，然后单击以下截图所示的 OK 按钮：
- en: '![](img/914c131b-65df-48fc-8f20-228eee0db8f6.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/914c131b-65df-48fc-8f20-228eee0db8f6.png)'
- en: 'Now you should be on the New ASP.NET Web Core Application - FlixOne.API screen.
    Make sure that on this screen, you select ASP.NET Core 2.2\. Select Web Application
    (Model-View-Controller) from the available templates, and uncheck the Configure
    for HTTPS checkbox, as shown in the following screenshot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该在新 ASP.NET Web 核心应用程序 - FlixOne.API 界面上。确保在此界面上，您选择 ASP.NET Core 2.2。从可用的模板中选择
    Web 应用程序（模型-视图-控制器），并取消选中配置 HTTPS 复选框，如以下截图所示：
- en: '![](img/90477786-80eb-41aa-b030-2bf74fa836dd.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90477786-80eb-41aa-b030-2bf74fa836dd.png)'
- en: 'You will see a default page appear, as shown in the following screenshot:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个默认页面出现，如以下截图所示：
- en: '![](img/193efeb2-573e-4ed9-a6d9-49ec51d1d571.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/193efeb2-573e-4ed9-a6d9-49ec51d1d571.png)'
- en: 'Expand Solution Explorer and click on Show All files. You will see the default
    folders/files created by Visual Studio. Refer to the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开解决方案资源管理器并单击显示所有文件。您将看到 Visual Studio 创建的默认文件夹/文件。参考以下截图：
- en: '![](img/40563f44-0662-4c1b-aa6e-4901e13813ae.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40563f44-0662-4c1b-aa6e-4901e13813ae.png)'
- en: 'We have selected the ASP.NET Core Web (Model-View-Controller) template. Therefore,
    we have the default folders, Controllers, Models, and Views. This is a default
    template provided by Visual Studio. To check this default template, hit *F5* and
    run the project. Then, you will see the following default page:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了 ASP.NET Core Web (模型-视图-控制器) 模板。因此，我们有默认的文件夹，控制器、模型和视图。这是一个 Visual Studio
    提供的默认模板。要检查此默认模板，按 *F5* 运行项目。然后，您将看到以下默认页面：
- en: '![](img/61edea34-6458-48cb-b002-75bcbfa738a9.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61edea34-6458-48cb-b002-75bcbfa738a9.png)'
- en: 'The previous screenshot is the default Home screen of our web application.
    You may be thinking *is it a website?* and be expecting an API documentation page
    here instead of a web page. This is because, when we select the template, Visual
    Studio adds MVC Controller instead of API Controller by default. Please note that
    in ASP.NET Core, both MVC Controller and API Controller use the same Controller
    Pipeline (see the Controller class: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2)).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是我们 Web 应用程序的默认主页。您可能会想 *这是一个网站吗？* 并期望在这里看到 API 文档页面而不是网页。这是因为，当我们选择模板时，Visual
    Studio 默认添加 MVC 控制器而不是 API 控制器。请注意，在 ASP.NET Core 中，MVC 控制器和 API 控制器使用相同的控制器管道（请参阅控制器类：[https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2)）。
- en: 'Before discussing API projects in detail, let''s first add a new project to
    our FlixOne solution. To do so, expand Solution Explorer, right-click on the Solution
    Name, and then click on Add New Project. Refer to the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论 API 项目之前，让我们首先向我们的 FlixOne 解决方案添加一个新的项目。为此，展开解决方案资源管理器，右键单击解决方案名称，然后单击添加新项目。参考以下截图：
- en: '![](img/8b9834e5-e012-4982-932b-057a6510b41e.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b9834e5-e012-4982-932b-057a6510b41e.png)'
- en: 'In the New Project window, add the new `FlixOne.CQRS` project, and click on
    the `OK` button. Refer to the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目窗口中，添加新的 `FlixOne.CQRS` 项目，然后单击 `OK` 按钮。参考以下截图：
- en: '![](img/87ee0e48-d801-44b4-9c68-6e9201eb48e5.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87ee0e48-d801-44b4-9c68-6e9201eb48e5.png)'
- en: 'The previous screenshot is of the Add New Project window. On it, select .NET
    Core and then select the Class Library(.NET Core) project. Enter the name `FlixOne.CQRS`
    and click the OK button. A New Project has been added to the solution. You can
    then add folders to the new solution, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是新项目窗口。在它上面，选择 .NET Core，然后选择类库(.NET Core)项目。输入名称 `FlixOne.CQRS` 并单击 OK
    按钮。已将新项目添加到解决方案中。然后您可以为新解决方案添加文件夹，如以下截图所示：
- en: '![](img/cb3a872f-4b1b-486f-b858-b04df8b0855e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb3a872f-4b1b-486f-b858-b04df8b0855e.png)'
- en: 'The previous screenshot is showing that I have added four new folders: `Commands`,
    `Queries`, `Domain`, and `Helper`. In the `Commands` folder, I have the `Command`
    and `Handler` sub-folders. Similarly, for the `Queries` folder, I have added sub-folders
    called `Handler` and `Query`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示我已经添加了四个新文件夹：`Commands`、`Queries`、`Domain`和`Helper`。在`Commands`文件夹中，我有`Command`和`Handler`子文件夹。同样，对于`Queries`文件夹，我添加了名为`Handler`和`Query`的子文件夹。
- en: 'To get started with the project, let''s first add two Domain Entities in the
    project. The following is the required code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始项目，让我们首先在项目中添加两个域实体。以下是需要使用的代码：
- en: '[PRE1]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is a `Product` domain entity that has the following properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个具有以下属性的`Product`域实体：
- en: '`Id`: A unique identifier'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`: 唯一标识符'
- en: '`Name`: A product name'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`: 产品名称'
- en: '`Description`: A product description'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`: 产品描述'
- en: '`Image`: An image of the product'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`: 产品图片'
- en: '`Price`: The price of the product'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price`: 产品价格'
- en: 'We also need to add the `CommandResponse` database. This plays an important
    role when interacting with database/repository, in that it ensures that the system
    gets a response. The following is the code-snippet of the `CommandResponse` Entity
    Model:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加`CommandResponse`数据库。当与数据库/存储库交互时，它起着重要作用，确保系统得到响应。以下是从`CommandResponse`实体模型的代码片段：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding `CommandResponse` class contains the following properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`CommandResponse`类包含以下属性：
- en: '`Id`: Unique identifier.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`: 唯一标识符。'
- en: '`Success`: With values of `True` or `False`, it tells us whether the operation
    is successful or not.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Success`: 值为`True`或`False`，告诉我们操作是否成功。'
- en: '`Message`: A message as a response to the operation. If `Success` if false,
    this message contains `Error`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`: 作为操作响应的消息。如果`Success`为假，则此消息包含`Error`。'
- en: 'Now, it''s time to add interfaces for a query. To add interfaces, follow these
    steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为查询添加接口了。要添加接口，请按照以下步骤操作：
- en: 'From Solution Explorer, right-click on the `Queries` folder, click on Add,
    and then click on New Item, as per the following screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“解决方案资源管理器”中，右键单击“Queries”文件夹，点击“添加”，然后点击“新建项”，如下截图所示：
- en: '![](img/c7b79ebb-67b7-49ff-a003-26a089491ba5.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7b79ebb-67b7-49ff-a003-26a089491ba5.png)'
- en: 'From the Add New Item window, choose Interface, name it IQuery, and click on
    the Add button:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“添加新项”窗口中选择接口，命名为IQuery，然后点击“添加”按钮：
- en: '![](img/e055b30e-23f0-49bd-b246-49d682935ed7.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e055b30e-23f0-49bd-b246-49d682935ed7.png)'
- en: 'Follow the previous steps and add the `IQueryHandler` interface as well. The
    following is the code from the `IQuery` interface:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面的步骤操作，并添加`IQueryHandler`接口。以下是从`IQuery`接口的代码：
- en: '[PRE3]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous interface works as a skeleton for querying for any kind of operation.
    This is a generic interface using an `out` parameter of the `TResponse` type.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的接口作为查询任何类型操作的骨架。这是一个使用`TResponse`类型的`out`参数的通用接口。
- en: 'The following is code from our `ProductQuery` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`ProductQuery`类的代码：
- en: '[PRE4]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is code from our `ProductQueryHandler` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`ProductQueryHandler`类的代码：
- en: '[PRE5]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is code from our `ProductQueryHandlerFactory` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`ProductQueryHandlerFactory`类的代码：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly to `Query` interfaces and `Query` classes, we need to add interfaces
    for commands and their classes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`Query`接口和`Query`类，我们需要为命令及其类添加接口。
- en: 'At the point by which we have created CQRS for a product domain entity, you
    can follow this workflow and add more entities as many times as you like. Now,
    let''s move on to our `FlixOne.API` project and add a new API controller by following
    these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为产品域实体创建CQRS之后，你可以遵循此工作流程并多次添加更多实体。现在，让我们继续我们的`FlixOne.API`项目，并按照以下步骤添加一个新的API控制器：
- en: From Solution Explorer, right-click on the `Controllers` folder.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“解决方案资源管理器”中，右键单击“Controllers”文件夹。
- en: Select Add | New Item.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加 | 新项”。
- en: 'Select API Controller Class and name it `ProductController`; refer to the following
    screenshot:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择API控制器类，命名为`ProductController`；参考以下截图：
- en: '![](img/b9088f70-6e1b-4b33-a49f-2cff8620875d.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9088f70-6e1b-4b33-a49f-2cff8620875d.png)'
- en: 'Add the following code in the API controller:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API控制器中添加以下代码：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code is for saving the product:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于保存产品：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code is for deletion of products:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于删除产品：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have created Product APIs, and we are not going to creates UI in this section.
    To view what we have done, we will be adding **Swagger** support to our API project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了产品API，我们不会在本节中创建UI。要查看我们所做的工作，我们将向我们的API项目添加**Swagger**支持。
- en: Swagger is a tool that can be used for documentation purposes, and provides
    all of the information regarding the API endpoints on one screen, where you can
    visualize the API and test it by setting parameters as well.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是一个可用于文档的工具，它在一个屏幕上提供了有关API端点的所有信息，您可以通过设置参数来可视化API并进行测试。
- en: 'To get started with the implementation of Swagger in our API project, follow
    these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在我们的API项目中实现Swagger，请按照以下步骤操作：
- en: Open Nuget Package Manager.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Nuget包管理器。
- en: 'Go to Nuget Package Manager | Browse and search for `Swashbuckle.ASPNETCore`;
    refer to the following screenshot:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Nuget包管理器 | 浏览并搜索`Swashbuckle.ASPNETCore`；参考以下截图：
- en: '![](img/1704e800-d6c6-4e30-b6aa-ff6e38bde866.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1704e800-d6c6-4e30-b6aa-ff6e38bde866.png)'
- en: 'Open the `Startup.cs` file and add the following code to the `ConfigureService`
    method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Startup.cs`文件，并将以下代码添加到`ConfigureService`方法中：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, add the following code to the `Configure` method:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`Configure`方法中：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have now completed all of the changes that serve to showcase the power of
    CQRS in the application. Hit *F5* in Visual Studio and open the Swagger documentation
    page by accessing the following URL: [http://localhost:52932/swagger/](http://localhost:52932/swagger/)
    (please note that port number `52932` may vary as per your setting of the project).
    You will see the following Swagger Documentation page:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了所有旨在展示CQRS在应用程序中强大功能的更改。在Visual Studio中按*F5*键，并通过访问以下URL打开Swagger文档页面：[http://localhost:52932/swagger/](http://localhost:52932/swagger/)（请注意，端口号`52932`可能会根据您的项目设置而有所不同）。您将看到以下Swagger文档页面：
- en: '![](img/2a67a98c-096c-4475-8258-7a0ace3abfbd.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a67a98c-096c-4475-8258-7a0ace3abfbd.png)'
- en: Here, you can test Product APIs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以测试产品API。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the CQRS pattern, which we then implemented into our
    application. The aim of the chapter was to go through the database techniques
    and look at how ledger-style databases work for inventory systems. To showcase
    the power of CQRS, we have created Product APIs and added support for Swagger
    documentation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了CQRS模式，然后我们将该模式实现到了我们的应用程序中。本章的目标是介绍数据库技术，并探讨账本式数据库在库存系统中的应用。为了展示CQRS的强大功能，我们创建了产品API，并增加了对Swagger文档的支持。
- en: In the next chapter, we will discuss cloud services and look at microservices
    and serverless techniques in detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论云服务，并详细探讨微服务和无服务器技术。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: What is a ledger-style database?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是账本式数据库？
- en: What is CQRS?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是CQRS？
- en: When should we use CQRS?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么情况下使用CQRS？
