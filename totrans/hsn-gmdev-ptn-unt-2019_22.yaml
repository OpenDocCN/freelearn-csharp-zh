- en: Service Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Service Locator is a very straightforward pattern, and its name implies
    perfectly its purpose, which is locating services. In game development, services
    are usually game-mechanics-related systems that provide specific functionality—for
    example: spawners, save states, and online connectivity. Because games are mainly
    composed of layers of in-game systems communicating, functioning, and synchronizing
    with one another to simulate an interactive experience, the Service Locator creates
    a large number of dependencies between system components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, having a way for services to find one another through a central locator
    can streamline communication between components, while avoiding explicit references
    to the location of dependencies that a system might need to be able to run correctly.
    And that''s what the Service Locator pattern offers: a global access point and
    registry to the core services of a program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Service Locator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a global service locator that will act as a runtime linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity-specific engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review [Chapter 6](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml), *Singleton*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2U8Mb6H](http://bit.ly/2U8Mb6H)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Service Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Service Locator is a straightforward pattern and doesn't have much academic
    theory behind it, so we can safely say it falls into the category of pragmatic
    patterns. As its name implies, it locates services for a client; it achieves this
    by maintaining a central registry of classes that offer specific services. This
    registry can be updated dynamically at runtime by having services register themselves
    when available.
  prefs: []
  type: TYPE_NORMAL
- en: Another common component of the Service Locator is its local cache, which uses
    the same principles as the Object Pool. A Service Locator might hold instances
    of its most-requested services in memory to avoid using too much memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a diagram of a typical Service Locator implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7a4dcba-0fc5-432d-a9e7-67707cca2edc.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we could easily say that the **Service Locator** is acting like
    a proxy between the clients (requestors) and the service providers, and this means
    that the relationship between both is a decoupled one. A client will only need
    to call the **Service Locator** when it has a dependency to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that the software architecture term *client* is often
    used to describe a class using the functionalities of another class, or other
    classes—it has nothing to do with the end user of an application. Systems can
    be clients of other systems without any human input.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Service Locator is a young pattern; its reputation in the industry is quite
    limited compared to more traditional patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of using the Service Locator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime optimization**: A Service Locator can optimize an application at
    runtime by dynamically detecting better libraries or components to use, depending
    on the context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contextual run-time locators**: It''s possible to have multiple Service Locators
    in memory, each configured for a specific runtime context, such as testing, staging,
    and production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simpler than Dependency Injection**: A Service Locator is simpler to implement
    than a **Dependency Injection** (**DI**)-driven architecture, mainly because it''s
    a centralized approach to managing dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the drawbacks of using the Service Locator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blackboxing**: Services contained in the registry can become invisible to
    other components in a system. This approach can make it harder to detect errors
    or regressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security hole**: Depending on the overall architecture of the code base,
    the Service Locator could permit the injection code that could exploit your systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Globally accessible**: If implemented as a Singleton, the Service Locator
    can suffer from the same issues of globally accessible managers and components,
    making them harder to unit test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our use case will be straightforward, and we will not focus on a specific in-game
    system. Instead, we will concentrate on building a simple Service Locator that
    will offer the ability to *link* a client to the following services dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currency converter**: A service that converts in-game currency to a real-world
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighting** **coordinator**: A system that manages the lights in our scenes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lobby coordinator**: A service that coordinates with the multiplayer lobby
    to set up "death matches"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, of course, we could add many available services to the registry, but for
    this example, we will focus on just those three.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are going to see from the following code example, implementing a basic
    Service Locator is a straightforward process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the most important ingredient: the `ServiceLocator`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of a Service Locator has two primary responsibilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing the registry with the `FillRegistry()` function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a specified service to the client with the `GetService(T)` function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Those two functions refer to the central registry that's in the form of a `Dictionary`.
    Of course, we could separate these responsibilities into individual classes, instead
    of encapsulating them inside local functions, but for this example, we are keeping
    it simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Service Locator set up, we can now start implementing some
    services for our clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first service is `Currencyconverter`; this is essential for modern games
    when we consider that they usually include an in-game purchase and lootbox mechanics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our second service is `LightingCoordinator`; it''s responsible for managing
    all the lights in our scenes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last service is `LobbyCoordinator`; this is responsible for making sure
    that our player can join an active lobby when required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have three services, each with specific responsibilities, available
    to our clients if need be. But we have an apparent limitation: at the moment,
    we are adding services to the central registry only by hand, and this is, of course,
    not the best approach for production code; however, it is acceptable for us to
    test our first pass implementation of a Service Locator. Later on, as a practical
    exercise, it would be wise to add the option for service providers to register
    themselves dynamically into the service registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, for our final class, we are going to implement the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once we have implemented the client-side code, we can appreciate the benefits
    of the Service Locator. We are now able to have access to any core service of
    our code base without having to know the location of its class or how to initialize
    it. We have a global but straightforward interface that we can query from anywhere
    that dynamically links a client with a service while decoupling the entire process
    of localizing a service and initializing it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Service Locator, a pattern that is a global
    solution that can resolve the recurring challenge of managing dependencies between
    objects that rely on services (functionalities) that other objects offer. In its
    simplest form, the Service Locator decouples the relationship between a client
    (requester) and a service provider. But in its most advanced form, it can also
    optimize memory usage if extended with a local cache that will reuse instances
    of providers when required.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the DI pattern, which we could say is somewhat
    the opposite of the Service Locator in its approach but has a similar intent.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the code example, we implemented a simple version of the Service Locator
    so we could have a clear overview of its core intent and design. But for an exercise,
    I would recommend you take this basic draft of the Service Locator and expand
    it into something that could be production ready, by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulate the registry and cache components into self-contained classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the cache with a combination of the Factory and Prototype patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the ability for services to add themselves dynamically to the registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a standard interface for your service providers so you can effectively
    manage them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's good practice to approach design patterns like a jazz musician approaches
    a melody. Once you understand the core theme of a pattern, extend it, improvise
    on it, and make it your own, while staying accurate to its fundamental design.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Inversion of Control Containers and the Dependency Injection* *pattern*, by
    Martin Fowler([https://martinfowler.com/articles/injection.html#UsingAServiceLocator](https://martinfowler.com/articles/injection.html#UsingAServiceLocator))'
  prefs: []
  type: TYPE_NORMAL
