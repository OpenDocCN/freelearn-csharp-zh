- en: Dependency Injection and IoC Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is intended to cover the Dependency Inversion principle in more
    depth. This means coverage of how it is used in already popular frameworks with
    different languages, like C#, or JavaScript. We will see what are its main advantages
    and caveats are, together with a brief analysis of why it is gaining momentum
    and consensus among developers all over the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In all, we'll talk about the concepts and implementation of software artifacts
    like Factories and Service Locators, and how they relate to Dependency Injection.
    Factories and Service Locators--concepts, implementations, and how they relate
    to Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also cover how IoC containers implement this concept, and what the main
    points that these IoC containers have in common are, beyond the language they're
    implemented in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we'll go through a brief introduction to Object Composition, Object Lifetime,
    and the different types of injection, ending with some commentaries about those
    cases in which Dependency Injection is not the best choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will end up with some demos about popular IoC containers in use today for
    .NET Framework and a brief introduction to how DI is used in JavaScript frameworks,
    like AngularJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Factories and Service Locators--Concepts, Implementations, and how they relate
    to Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoC containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demos about popular IoC containers in use today for .NET Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Object Composition, Object Lifetime, and the different types
    of injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brief introduction to how DI is used in JavaScript frameworks, like AngularJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dependency Principle in more detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But, before all that, let''s remember that we postponed a more detailed explanation
    of the principle for this chapter. In [Chapter 1](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml),
    *The SOLID Principles of Software Design*, we discussed the five SOLID principles
    in general, so it''s time to go deeper into the Dependency Principle. Actually,
    it''s not that difficult. It only requires to properly understand the two basic
    points, which Robert Martin highlights, and express the idea by means of some
    source code. Recall:'
  prefs: []
  type: TYPE_NORMAL
- en: '"High-level modules should not depend on low-level modules. Both should depend
    on abstractions.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions should not depend upon details. Details should depend upon abstractions."
  prefs: []
  type: TYPE_NORMAL
- en: Remember, also, that we explained the intuitive notion of high-level and low-level
    classes, depending on their functionality for the application. For this respect,
    you can think of an app as if it was an organization hierarchy, with its different
    levels which depend on their role in the company.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's see an example that violates the dependency principle, propose a solution,
    and see how that solution might take several flavors depending on the application's
    needs (or even the programmer's tastes, in many situations).
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use a basic .NET app to settle the initial scenario. It's just
    a classic console application that reads a file with a movie's information from
    a specific directory, and presents the content in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a file called `MovieDB.xml` (in the XML format and stored
    in the app''s data subdirectory) with a data structure like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, we can use LINQ to XML to easily read data from that file and iterate over
    the results to present a list of movie titles in the console. As a good practice,
    we'll define a class (the model) that represents the data to be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we''ll have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you can use the Edit menu in Visual Studio and select Paste Special
    to get the options Paste XML as classes and Paste JSON as classes, which will
    build a new class in the open editor page and insert a definition according to
    the data pasted, with the class name `Rootobject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first approach to the problem might end up with the following code (notice
    I''m using here the initial and simplest approach to have, both, a model to deal
    with, and the functionality required):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, we end up with a `List<Movie>` collection, and iterate over it,
    presenting the first ten results of the `Title` field in the console (see the
    following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0927f89d-2d97-4ce5-ba01-c4dd5b0fec53.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, that's fine for a single use, but not for extended purposes. Since
    the `Program` class has several responsibilities, it should be decoupled accordingly.
    So, we can think of a `MovieReader` class which takes care of reading data and
    apply the first SOLID principle (separation of concerns).
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `MovieReader` class could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, we just moved the declarations required to access data to the new class
    and wrapped the reading functionality around a method `ReadMovies`, which reads
    and returns the required data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Main` entry point is now much simpler. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's fine, but still, our `Program` class depends on the `XMLMovieReader`.
    What happens if we (or somebody else) needs to read data in another format, like
    JSON, for example?
  prefs: []
  type: TYPE_NORMAL
- en: This is where Dependency Injection comes in. It would be much better than if
    our `Program` class could depend on an abstraction, not on a concrete class. It
    could be an abstract class, or it could be an interface.
  prefs: []
  type: TYPE_NORMAL
- en: This implies another class in charge of deciding which concrete implementation
    has to be served, depending on the file format. In this manner, it could also
    be possible to add further methods of reading data (like accessing a web service
    or database) without changing the already working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we could have another specialized reader called `JSONMovieReader` with this
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, we just have to implement the appropriate class depending on the format
    we use. Besides that, given that both files include exactly the same data, we
    would obtain identical results in both cases (I omitted the output for that reason).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should create an interface that defines the common operation that all
    readers will have in common; the `ReadMovies()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface is the contract that both classes (and other possible candidates)
    implement, so, we just have to change both declarations to explicitly indicate
    that they indeed implement the `IMovieReader` interface. In this way, the final
    definitions will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last step consists of the creation of the new class in charge of deciding
    which reader has to be used (the `ReaderFactory`, in this demo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the constructor of `ReaderFactory` decides which type of reader
    is assigned to the `_IMovieReader` property. This could easily grow as needed.
    Our `Program` class has a new definition but it is an extensible one, and we can
    add as many reading methods as required with few or no changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we offer an option to choose the file format, and, depending on
    the user's choice, the `IMovieReader` returned deals with the peculiarities of
    the format (you can think as well in other formats, such as Excel spreadsheets,
    pure text formats, comma-delimited files, databases, web services, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Class Diagram that Visual Studio generates from this architecture adopts
    the following aspect (just right-click on the name of the class--`Program3`, in
    this demo, and select View Class Diagram), to obtain a graphic structure like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da9281ae-feb7-42e8-9130-b5d2960e0c2d.png)'
  prefs: []
  type: TYPE_IMG
- en: In summary, the `IMovieReader` interface is the contract that both classes agree
    upon. As long as any other class implements this interface, we'll be able to extend
    the potential data access mechanisms with new ways, as mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of this implementation is the fact that, from the user interface,
    we access to a read-only property, `_IMovieReader` inside the `ReaderFactory`
    class. In that fashion, we avoid further changes in the property, once assigned
    a value. Finally, we get the `Name` property of the resulting type of `_IMovieReader`,
    to include it in the final output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list is like the previous one, only this time the user can select the type
    of format (XML or JSON):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7572144e-243a-453f-9e91-4c45e0d87480.png)'
  prefs: []
  type: TYPE_IMG
- en: At first sight, you might think that we have to write more code when using the
    DI approach, but, this only happens when we're dealing with simple demos, like
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: In real applications, with thousands or tenths of thousands of lines of code,
    the amount of required code usually diminishes and it greatly facilitates other
    aspects of the lifecycle, like maintainability, testability, extensibility, parallel
    development, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects of Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, before going on with the distinct aspects of Dependency Injection,
    it is advisable to recall some of the basic concepts that have a deep influence
    in the way this principle takes form, and that we should consider before its implementation.
    Concretely, there are three main points to evaluate--Object Composition, Object
    Lifetime, and Interception.
  prefs: []
  type: TYPE_NORMAL
- en: Since these three topics are crucial in software development in general (not
    just when talking about DI), we will go back to them in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml),
    *Object Lifetime*, [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml), *Interception*,
    and [Chapter 8](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml), *Patterns - Dependency
    Injection*, but let's include now this light introduction to serving as a basic
    reminder of what is to come.
  prefs: []
  type: TYPE_NORMAL
- en: Object Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important notions behind Dependency Injection and other SOLID patterns
    is Object Composition, which, as Wikipedia ([https://en.wikipedia.org/wiki/Object_composition](https://en.wikipedia.org/wiki/Object_composition))
    reminds, "*is a way to combine simple objects or data types into more complex
    ones. Compositions are a critical building block of many basic data structures,
    including the tagged union, the linked list, and the binary tree, as well as the
    object used in object-oriented programming."*
  prefs: []
  type: TYPE_NORMAL
- en: 'It puts a quite a clear example; types can often be divided into composite
    and non-composite types, and composition can be regarded as a relationship between
    types: an object of a composite type (for example, a car) *has an* object of a
    simpler type (for example, a wheel).'
  prefs: []
  type: TYPE_NORMAL
- en: As you know, these relations have been at the heart of OOP, since the very beginning.
    It also has to do with Aggregation and should not be confused with inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there is a well-known principle of the OOP called *Composition over
    Inheritance*, which states that "*classes should achieve polymorphic behavior
    and code reuse by their composition (by containing instances of other classes
    that implement the desired functionality) rather than inheritance from a base
    or parent class."*
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the recommendation is to favor object composition over class inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b34dfae-13e8-45a6-8560-ee849353b0d6.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://atomicobject.com/resources/oo-programming/object-oriented-aggregation](https://atomicobject.com/resources/oo-programming/object-oriented-aggregation))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous schema shows the difference between both approaches: composition
    and aggregation. The individual elements used to compose a car are part of the
    car. The object could not perform its tasks without them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, passengers could come and go (or even, now, since driverless
    cars don't require any), but they can eventually be managed by the car's instance.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Wikipedia ([https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance))
    remarks that--"*Classes implementing the identified interfaces are built and added
    to business domain classes as needed. Thus, system behaviors are realized without
    inheritance. In fact, business domain classes may all be base classes without
    any inheritance at all. Alternative implementation of system behaviors is accomplished
    by providing another class that implements the desired behavior interface. Any
    business domain class that contains a reference to the interface can easily support
    any implementation of that interface and the choice can even be delayed until*
    *run time."*
  prefs: []
  type: TYPE_NORMAL
- en: Object Lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous demo, we've seen a way to get rid of a classes' dependencies
    by means of abstractions, and the possibilities that we have later on to change
    those abstractions as needed, along with the application's lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, besides this fundamental ability, this practice allows us to determine
    abstractions'' life: when they are born (instantiated) and when they go out of
    scope (and leave the Garbage Collector in charge of the task of finishing the
    useful life).'
  prefs: []
  type: TYPE_NORMAL
- en: You know, when an object is not referenced by any other object it automatically
    becomes eligible for destruction, liberating its associated memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the GC works is not trivial (although transparent to the user) and
    quite a few things should be considered, especially the way in which object generations
    are processed and the memory recovered, even in the Simplified Model (see the
    following image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1bfa354-214e-45de-8d0c-bf93a03090ad.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://msdn.microsoft.com/en-us/library/ms973837.aspx](https://msdn.microsoft.com/en-us/library/ms973837.aspx))'
  prefs: []
  type: TYPE_NORMAL
- en: A little about Garbage Collection from Wikipedia ([https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)))--"*In
    computer science, garbage collection (GC) is a form of automatic memory management.
    The garbage collector, or just collector, attempts to reclaim garbage* *or memory
    occupied by objects that are no longer in use by the program. Garbage collection
    was invented by John McCarthy around 1959 to simplify manual memory management
    in Lisp*."
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that problems might arise when two objects share an instance of
    the same interface, or when a new scenario shows up when we inject two distinct
    instances to different clients.
  prefs: []
  type: TYPE_NORMAL
- en: The way those objects are managed in memory also depends on our code to a large
    extent. Therefore, we will explain those intricacies in [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml),
    *Interception*, so you can have a detailed picture of this behavior and the implications
    it might have in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Interception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can consider Interception as an application of the Decorator design pattern.
    For some authors, Interception is the process of pre-filtering a given call, in
    a way that we can include (or exclude) certain information from its standard (original)
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the IMovieReader implementation, the creation of a valid object
    capable of reading movies is redirected to the `ReaderFactory`, instead of the
    previous call to a concrete constructor. This is possible because abstractions
    allow us to defer instantiation and decide what to create depending on arguments,
    a system's configuration, configuration files, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another typical usage of interception relates to Instrumentation: distinct
    aspects of the application that go beyond application domains, like logging, auditing,
    validation and many others.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can find interception when we capture the default behavior of system
    components using the so-called sub-classing technique, which allows for interleaving
    system calls and, effectively, change the system's behavior, substituting it for
    our own.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to implement DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, Dependency Injection is implemented by means of a constructor,
    which is the preferred way of today's implementation for many of the popular IoC
    containers we can find for the .NET Framework (and even, for other frameworks,
    like Angular).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are other two classical paths for DI implementation: via properties
    (also called setter injection) or methods.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Property Injection flavor, we're dealing with a scenario in which it
    makes sense to allow the user to change the dependency once the program is running.
    For instance, imagine that you start with a concrete implementation, and later
    on, the client or some program's condition, require change.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations in which that change doesn't require -strictly speaking-
    a new instance of the class, so it would not be coherent to create it just to
    change a given value. It's much better to keep the level of independence that
    DI promotes, but allow the client of the dependency to change that value once
    used.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this goal we must create a writable property (not a read-only one,
    like we did before). But, there's a danger. We have to avoid null values. We can
    do this easily by creating a default value, something very easy and concise to
    implement using C# latest techniques, as we'll see in a demo. So, a change of
    a dependency's value is the key to determining if we have to use properties in
    the injection.
  prefs: []
  type: TYPE_NORMAL
- en: In Method Injection, the code block that requires the dependency is usually
    a parameter of some method, and the purpose of the dependency's argument is to
    provide a context, which determines how the method should behave.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can say that the scenario is scope-dependent. When the scope of the dependency
    is somehow local, as it happens when it is only being used in one concrete method
    (it does not affect the whole class), it's a good practice to limit the presence
    of the dependency exclusively to the method that it is going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a couple of samples about these two ways of implementing DI.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine something very simple for this demo. The code presents an initial
    configuration of color values for the current console, together with a message
    indicating those values. We offer the user the ability to change themes, to avoid
    unreadable combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We reduce these combinations to light and dark, besides the initial one, which
    is black/white. We could define a very simple `ConsoleDisplayFactory` class with
    two default values that are assigned in its instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this definition, every time we create an instance, both properties (`ForeColor`
    and `BackColor`) are assigned the default theme configuration. Our `Program` class
    will depend on `ConsoleDisplayFactory`, but we make sure that both values hold
    a consistent color configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our main entry point, located in `Program4`, would look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Observe changes to console configuration that are performed via the `ConsoleDisplayFactory`
    instance, which is a property of the `Program4` class. For this initial version
    of the demo, we have opted for a method (which serves as a setter) that takes
    care of the values assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach could be to code the `ForeColor` and `BackColor` properties
    of the `ConsoleDisplayFactory` class in a way that the setters of each property
    would take care of assigning the suitable changes for each theme.
  prefs: []
  type: TYPE_NORMAL
- en: Though pretty simple, this code shows the idea behind Property Injection. We
    don't need the whole class to be re-instantiated, so we allow the client to change
    the required properties, but taking care that the results are injected according
    to business rules.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we use an injector method or program the setters directly will
    always depend on the architecture of the code and your necessities.
  prefs: []
  type: TYPE_NORMAL
- en: (We omit the output since it is quite trivial in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Method Injection in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we previously mentioned, the key here is that the injected resource makes
    sense inside a method of the client class. There are two main reasons for this,
    which are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The injected parameter affects the way the method behaves and it can change
    along its life-runtime (in distinct method calls)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The injected parameter's functionality affects the method's block of code and
    nothing else. Therefore, there's no need to create a class-scope dependency when
    it is only used inside that block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This scenario shows up when we are coding a method that has some functionality
    that is dynamic in nature (an HTTP context, access to a directory that contains
    files that might change during the execution, Web Sockets, and so on.).
  prefs: []
  type: TYPE_NORMAL
- en: It is well-known that the .NET Framework already implements this feature in
    some classes belonging to a variety of namespaces. For example, in the **Base
    Class Libraries** (**BCL**), the `System.ComponentModel` namespace allows using
    the `TypeConverter` class which is especially useful in contexts where WPF is
    involved, to allow conversions between pure CLR types and XAML types or other
    business logic types.
  prefs: []
  type: TYPE_NORMAL
- en: Some of this classes' methods use an instance of `ITypeDescriptorContext` that
    carries information about the context in which the execution takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there''s a simpler and much more common scenario in which this is happening
    all the time: the structure of the .NET''s event system, and I think that understanding
    the way it works is very useful to realize how we can find implementations of
    this pattern in every-day situations, and how this is being used since the very
    beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET event architecture as Model Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s think of the event model for a second: in practice, method A calls method
    B and passes some arguments (two, by default). When you program a Click, `SelectedItemChanged`,
    of `FormClosing` event in classic (and modern) .NET, a communication process takes
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process involves a method responsible for calling (the sender) and the
    callee (the receiver). This can be represented with the classic scheme of any
    other communication process that we all know from the first books of Information
    Theory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a08780c-c39b-4f75-87d0-4dc2a64d6876.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregation is a simple collection, like a bag of marbles, while composition
    implies internal/functional dependencies, like the hinges on a box. Cars aggregate
    passengers; they get in and out without breaking the car's functionality but the
    tires are components; remove one and the car no longer functions correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know these concepts (Composition and Aggregation), PACKT has excellent
    books to start with that, like *Learning Object-Oriented Programming* by Gaston
    C. Hillar ([https://www.packtpub.com/application-development/learning-object-oriented-programming](https://www.packtpub.com/application-development/learning-object-oriented-programming)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a correspondence between the two schemes in the four elements implied:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Issuer (sender): It is the method that makes the call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Receiver: It is another class (or the same) responding in another method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Channel: It is the environment, replaced by a managed environment in .NET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message: The set of values passed to the receiver (the EventArgs in .NET)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s think of a Windows app in which the user interface generates events,
    as, for example, when we use a button to close the window. The piece of code that
    represents such a scenario is expressed with some code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/324631da-adcb-4d77-80f8-0e36b697c692.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Who launches the execution of this code? Well, the Button object, when we program
    the click event includes the following code in the designer''s section of the
    `Form` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a delegate of type `EventHandler` (the default one) which is going
    to be in charge of calling the destination method, every time the user clicks
    on it. To avoid possible problems, that event is just a class with some characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Its signature is the same as the method to be called. In this manner, possible
    casting problems are avoided since there is no need for type conversions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delegate checks for the presence and availability of the `btnClose_Click`
    method before the call, so it guarantees there are no pointer-to-null problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that casting and pointers-to-nowhere were the two of the main causes of
    the infamous BSODs (Blue Screens of Death), the implantation of this architecture
    was something crucial from the very beginning of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is something else here that implies Method Injection, if you
    analyze the code and, even in those cases, like in the next demo, when the delegate
    is not the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To really appreciate this point, let''s program the `FormClosing` event that
    will be launched whenever the user clicks the Close button or tries to close the
    window in any of the other available ways: *Alt* + *F4*, the window''s x button,
    or the window''s menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b7a2985-0940-4f35-8ffe-c240ca1ab426.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this time the second argument of the `FormClosing` event is
    not the default, but an instance of an object that inherits from `EventArgs`,
    and encloses extra information providing the context, that we were talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, that object holds two properties: `Cancel` (which is assignable and
    forces a stop in the exit procedure), and `CloseReason`, a read-only property
    that indicates which mechanism really launched the closing process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''re not programming or instantiating this parameter: it is given to
    us via injection, every time we define an event procedure. And that internal injection
    system is responsible for providing the information relevant to the execution
    context. This is a clear sample of method injection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you peek into the definition of the `FormClosingEventArgs` parameter, you
    will see that it is, indeed, another class that inherits from `CancelEventArgs`
    (which, in turn, inherits from EventArgs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's interesting to note that `ClosingEventArgs` also belongs to the namespace
    `System.ComponentModel` that we mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: So, even when we're doing something as simple as closing a window, we're implicitly
    using method injection, that is at the heart of the .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture can be extended by the user in many ways, even using techniques
    like event chaining when we need to concatenate processes that depend on the user's
    choice and that are usually generated via events, for example.
  prefs: []
  type: TYPE_NORMAL
- en: A typical case for even chaining is when a user's selection from a combo (Like
    Select a Country), generates code that fills up another combo, let's say Select
    a City. You first have to select the country if you want the cities combo to be
    filled with the cities belonging to a given country.
  prefs: []
  type: TYPE_NORMAL
- en: One such case could be when the closing process of a window (something like
    the preceding code shown) requires an extra user intervention. For instance, imagine
    that you have to ask the user if he/she wants to save the audits (or perform any
    other action) but only in the case that a previous question is affirmative, like
    confirming that the user wants to exit the application (which might, in turn,
    depend on other conditions, like the `CloseReason` expressed in the previous code
    of the FormClosing event.
  prefs: []
  type: TYPE_NORMAL
- en: One possible approach would be to create a generic event on our own, that could
    be launched if the requested conditions apply. Let's say that only if `ClosingReason`
    is `CloseReason.UserClosing`, we should ask the user to confirm application exit
    and, in case the answer is positive, ask him again if he/she wants to save the
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''re invoking the event `FormClosingExtended` only when the if block
    evaluates to true. But, using the new generic event handler we can pass login
    information to another event that jumps from there to a distinct event procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This event procedure receives data in the e argument and also asks the user
    if he/she wants to save it as audit information. In this manner, we don't have
    to concatenate two `MessageBox` calls and the code is clearly separated.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, since the e argument could be a generic event handler of any kind,
    the type of information passed as the event argument, could also be of any kind,
    of any complexity level. For instance, it could be an object with its own methods
    suitable for validation purposes, security checking, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing missing in the code is to define the event handlers for each
    of the events implied in the process, which we can do inside the `MethodInjection`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in terms of DI, we''re using the internal injection engine inside .NET
    Framework in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, to obtain information passed to us by the framework in relation
    to the cause that provoked that event to happen (`ClosingReason`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second, because we have implemented our own event, that is executed in
    concatenation to the previous one and receives the required information expecting
    the user's approval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, in case that no business logic argument is required for the second
    event handler, we could have registered it also for the FormClosing event, since
    events are multicast in .NET
  prefs: []
  type: TYPE_NORMAL
- en: DI containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday practice, a good part of the plumbing to have DI working is not
    done via manual coding, but using something called DI Containers (also called
    IoC Containers). The previous demo using the .NET Framework event's system implies
    the existence of some DI Container.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a DI Container is a software library that facilitates the use of
    Dependency Injection and its based methodologies, like object composition, lifetime
    management, and so on. This is quite convenient for the programmer, who doesn't
    have to worry about the details of creation, destruction, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many people have some confusion with DI and IoC. You can refer to this website
    to clear out any confusions: [http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection.](http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection)'
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, DI Containers enforce several good practices, like avoiding duplication
    of instances, by supplying singleton instances of the required component, like
    it happens in AngularJS since the initial versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET, as we have mentioned, IoC is present in several scenarios, and the
    following image shows some of the main components that use this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da9d1376-b23a-441a-b0ee-5602c2c34a19.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://hotproton.com/category/dependency-injection/](https://hotproton.com/category/dependency-injection/))'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the graphic, .NET (even in the previous versions), holds several
    components that provide Inversion of Control (IoC), either linked to Events and
    Delegates, as we've seen in previous demos, or as Service Locators, or DI Injection
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Service locators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, a service locator is just a design pattern that instructs the implementer
    on how to construct DI containers capable of obtaining a service with a strong
    abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a condition that all service locators require: services have to be
    registered, so they can be later found and served at the code''s request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia ([http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection](http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection))
    summarizes the advantages of Service Locators in three main points:'
  prefs: []
  type: TYPE_NORMAL
- en: The service locator can act as a simple run-time linker. This allows code to
    be added at run-time without re-compiling the application, and in some cases without
    having to even restart it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications can optimize themselves at run-time by selectively adding and removing
    items from the service locator. For example, an application can detect that it
    has a better library for reading JPG images available than the default one, and
    alter the registry accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large sections of a library or application can be completely separated. The
    only link between them becomes the registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, we can say the application of the Dependency Inversion principle
    leads to the construction of IoC containers and they reflect in concrete DI techniques
    and Service Locators. (See the following diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae91c95e-f636-47b9-9073-e76f66fcfa59.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/](http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/))'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these advantages don't go without their counterparts. Possible problems
    include the registry acting like a black box for the rest of the application,
    uniqueness, security vulnerabilities, hiding class dependencies, adding some testing
    difficulties, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: DI Containers for .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the internal functionality related to DI inside .NET, it is very common
    to use external containers that provide extra or extended functionality to programmers,
    and, being .NET--a very popular programming framework, many have proliferated
    in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: So, our criteria here will be showing the basic implementation of those that
    seem to have a greater acceptance in the community, like Unity, Castle Windsor,
    StructureMap, and Autofac.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the number of choices available has kept growing in the last few years,
    and some of them are pretty popular as well, like Ninject, Simple Injector, Dynamo,
    LinFu, Spring.NET, Hiro, and so on, so our choice, in this case, was mainly driven
    by the level of implementation in the community, their ease of use, their API's
    consistency, and the performance tests in the latest versions. Since I don't want
    to pronounce myself about any of those tests, you can take a look at different
    benchmarks available on the web, and you'll probably come to the same or similar
    conclusion as I did.
  prefs: []
  type: TYPE_NORMAL
- en: 'These DI Containers (and others) share a few things in common: they all require
    a previous configuration, and they have the ability to resolve the required dependencies
    at runtime. The following schema shows an approach to this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06bfc163-a1c4-4682-82a1-e65663472e37.png)'
  prefs: []
  type: TYPE_IMG
- en: In practice, this means we will instantiate and configure a container object,
    and later on, we'll ask the container to resolve the required dependencies in
    one or more locations within our code.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, in most of the cases, components are resolved from the same instance
    that we initially instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common (and very simple) context for our demos:'
  prefs: []
  type: TYPE_NORMAL
- en: Since complications will show up themselves when coding real-life applications,
    I've chosen a very, very, simple starting point, that can serve us as a common
    scenario to solve the DI problems it presents. It's based on our previous idea
    of the `MovieReader` but let's say in this case that we don't even read anything
    from disk (only display a message in the console), to focus on the code's architecture
    and not on the details of its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The demo proposes the existence of two classes in charge of reading some books''
    information from the disk, and they both share a common interface `IBookReader`,
    which implements a unique method `ReadBooks()`. These three elements comprise
    the Data Access Layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty simple, right? Now, we build another succinct Business Layer, made up
    of a class called `BookManager`, whose only purpose is to perform business logic,
    so it exposes a public constructor that receives an instance of one of the two
    possible readers, and implements a call to the `ReadBooks` method, that in turn,
    will refer to the reading method that corresponds to each case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the user interface, that in this case is the `Console`, we ask
    the user to decide the reading mechanism and call the corresponding version of
    the `BookManager`, so we can call the `ReadBooks` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, it's a very simple code, already using some dependency inversion,
    but still stuck to the creation of the type of reader in the user interface. That's
    exactly what we obtain when we use an external creation mechanism that takes care
    of this work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see now how we can change this using the distinct DI Containers mentioned
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity container has been in place for quite a few years now. Somehow, it
    was the official Microsoft external container and has been linked to the *Patterns
    & Practices* initiative for many years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that Unity is not an official Microsoft product or does not belong
    to the Patterns & Practices team anymore. The project has been redirected to other
    people (Pablo Cibraro and Pedro Wood), as Immo Landwerth published in .NET Blog
    in 2015 ([https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/](https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/)),
    commenting: "*Dependency injection containers for .NET have continued to mature
    and evolve significantly. In addition, open source components are now more accepted.
    The need for having an "official" container from Microsoft is no longer as widespread
    as it once was.*"'
  prefs: []
  type: TYPE_NORMAL
- en: That said, Unity is still a very common feature in thousands of projects, and
    it has reached version 4.01, which you can install inside any project using the
    `NuGet Package Manager` available from the contextual menu of the `Solution Explorer,`
    or the `Project` menu as well, either in V. Studio 2017 or other versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you''ll see that it really references two different libraries:
    Unity 4.01 and the CommonServiceLocator 1.30 library, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4df937a-fc0a-47b4-b4d9-00d687b67d88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once installed, you''ll see four new references to DLL''s in the Solution''s
    Explorer: three of them belong to Unity and the fourth one to `CommonServiceLocator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f14847a3-8bd7-45c7-a3cd-d7c267bc37c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the `Microsoft.Practices.Unity.Configuration` library, you have utilities
    that allow writing the configuration required in an XML file, so that it serves
    as the initial settlement for the DI Container. Classes in that namespace will
    allow you to read and configure a given execution context based on that XML.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, the `Microsoft.Practices.Unity.RegistrationByConvention`
    library is intended to provide a programmable way of configuration to register
    multiple types with the container automatically by using a set of rules and conventions,
    as the official documentation defines ([https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx](https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we just want to register those classes belonging to our Business Layer
    and Data Access Layer, the most evident way to include all elements in our business
    model and have our data ready, would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice, however, that we're defining `BookManager` together with `XMLBookReader`
    and `JSONBookReader`. This means that if we run the code, we get an instance of
    the last registered class (`JSONBookReader`), which becomes the default option.
    The reason is that we're not naming these registrations, so they're assigned unnamed
    identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the demo inside `Chapter02_02.Unity` namespace and insert breakpoints
    to prove it.
  prefs: []
  type: TYPE_NORMAL
- en: To reproduce the initial situation in which the user selects the format, we
    need to register distinct aliases for registered types, so they can be resolved
    at runtime, passing the concrete version that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides that, notice that Unity plays the role that was previously playing
    the `BookManager` class. So in this case, we don''t need the `BookManager` class
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, Unity resolves the dependency with the parameter we pass to the `Resolve()`
    method, as we can see it by setting a breakpoint in this line, or simply, watching
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UnityContainer` class admits alternative registration mechanisms. For
    example, we could use a new business layer class entirely dedicated to Unity registration,
    with the following code (notice that we should reference `Microsoft.Practices.Unity`
    in the `using` section of our code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, all classes from the loaded assemblies are registered for Unity,
    all mappings (or correspondences) are defined between the existing interfaces
    and their implementing classes, their default names are used and their lifetime
    is assigned to be managed by the container, so it's the container itself which
    decides at runtime when to leave object's instances to the Garbage Collector.
  prefs: []
  type: TYPE_NORMAL
- en: Using Castle Windsor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the winners in benchmarks and usability tests, Castle Windsor has been
    around for quite some time, and now rallies all activities around its dedicated
    GitHub project site at [https://github.com/castleproject/Windsor.](https://github.com/castleproject/Windsor)
  prefs: []
  type: TYPE_NORMAL
- en: 'The community around this project is very active and, at the time of writing
    these lines, has more than 500 stars and 265 forks, and they were preparing to
    release version 3.4\. Of course, you can download it and install it separately,
    or use `NuGet` and have it installed for your project in the usual manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c227ceb1-14f2-4b9c-9a8f-425c8c373af2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The process of installation really installs two components: Castle.Core 3.3
    and Castle.Windsor 3.4\. Both work together, although they include several namespaces
    to cover many of the possible programming situations in which we might need dependency
    injection (and other features).'
  prefs: []
  type: TYPE_NORMAL
- en: Castle Windsor's API set is very rich in possibilities and the documentation
    in the official site lets you start quickly with some samples (see [https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md](https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our demo, we only have to reference those namespaces required to initialize
    the `WindsorContainer` class and proceed with the registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one allows the creation of a new `WindsorContainer` class, while
    the other defines the required classes for registration. The whole process is
    similar to the one we saw previously with Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the Component class includes static, generic methods to allow definitions
    of any interface (`IBookReader`, here), and you can concatenate successive calls
    to indicate which class implements what interface and what name that we want to
    assign to each registration, so it can be solved at runtime later on.
  prefs: []
  type: TYPE_NORMAL
- en: Once the registration is completed, the way to resolve it in a concrete implementation
    accepts a format that is identical to the one we used with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The code just runs exactly the same as in the previous demo.
  prefs: []
  type: TYPE_NORMAL
- en: Using StructureMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official site for this DI container defines precisely the differences and
    spirit behind this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StructureMap` is the oldest, continuously used IoC/DI container for .NET dating
    back to its first public release and production usage all the way back in June
    2004 on .NET 1.1\. The current 4\. release represents 12+ years of lessons learned
    in the StructureMap and greater .NET community--while also wiping away a lot of
    legacy design decisions that no longer make sense today.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we're dealing with a veteran here, and that means stability, together with
    a wide presence in internet forums and coder's sites, like `StackOverflow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The philosophy that lies behind usage and configuration is quite similar to
    the other two we''ve already seen, but it offers several ways to configure the
    application. As the official documentation states to this respect: "*from release
    3.0 onwards, StructureMap provides a streamlined fluent interface called the Registry
    DSL to configure a StructureMap Container with both explicit registrations and
    conventional auto-registrations.StructureMap no longer supports XML configuration
    or MEF-style attribute configuration -- but there is some facility for rolling
    your own attribute-based configuration support.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference is that it recommends a configuration approach via lambda
    expressions, but still with similar mechanisms, as you can see in the following
    code used to create and configure the Container object in the same operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The other main choice relies on creating a `Registry` object and then configuring
    the container based on it. Something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All this depends on the architecture and complexity of the application to build.
    For our demo purposes, we will first reference the library (this time there is
    only one namespace), via NuGet, that presents this installation option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10aa6b00-9d5f-4a77-a005-05e3df34616a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, for a basic configuration and usage, we only need to reference the basic
    `StructureMap` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code equivalent to the previous demos would be (with identical results
    in execution):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the container is configured by passing a lambda expression to the
    newly created instance of Container and, within the body expression, we use the
    following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding pattern allows us to express as many registrations as we want
    in a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s only a slight variation in the way the `IBookReader` instance is obtained
    because it doesn''t use the resolve paradigm. In turn, we can find several methods
    of resolving instances, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad0131e3-88bb-425f-a68b-a9e50357654d.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, execution is the same as in the other cases and there is nothing
    really relevant in the output, which you can find in the source code for `Chapter02_02.StructureMap`
    demo.
  prefs: []
  type: TYPE_NORMAL
- en: Using Autofac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll finish this short visit over .NET containers examining the basics of AutoFac,
    another DI Container well known in the community, and that claims to be up-to-date
    with versions that cover .NET Core, ASP.NET Core, Universal Windows Apps, and
    .NET Framework 4.5.1 and later versions. It also allows support for WCF-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: It has its own dedicated site ([https://autofac.org/](https://autofac.org/))
    which serves as the starting point, although it is also referenced via `NuGet`
    packages. Besides this, you will find references to several libraries, some specialized,
    in this page or NuGet.org at [https://www.nuget.org/packages/Autofac/.](https://www.nuget.org/packages/Autofac/)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to keep on using `NuGet` from Visual Studio, you should find
    the following reference, once you search for Autofac in the NuGet package editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4622db5-fe37-4b33-a89d-fc3cf4d6d10c.png)'
  prefs: []
  type: TYPE_IMG
- en: The standard architecture is similar to the other three we've already seen,
    with minor differences. For example, the container here is named `ContainerBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: After its instantiation, we have to configure the required types and interfaces
    and, finally, we should call to the `Build()` method of the `ContainerBuilder`
    to have everything ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we might use an approach similar to the other demos, in this case,
    we decided to inject only the version chosen by the user. This can be easily accomplished
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, we have many options regarding IoC containers, and many choices about
    the way to configure them, but all of them provide us with similar functionality:
    we can abstract dependencies that are resolved at a later time.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in this and other cases we could opt for other forms of configuration,
    like using XML or JSON files and also use more complex configuration classes to
    support all possible situations that our application requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is only an introduction to IoC containers, if you are interested
    in these APIs, you will see that it is possible to handle the three aspects discussed
    at the beginning: Object Composition, Object Lifetime, and Interception.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection in other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET or Java are not the only programming environments in which we can find
    Dependency Injection containers. Many of the most popular JavaScript frameworks
    also support DI from its inception. This is the case for AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: DI in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AngularJS (1.x) and Angular (2.x, 4.x, etc) are perhaps the most popular frameworks
    for JavaScript applications in use today. They are pretty different in their programming
    model and general purpose, so I will distinguish them both:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9990bd7-3496-422d-91c2-305e39ce312b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Angular frameworks are the result of a Google teamwork lead by Misko Hevery,
    Igor Minar, and Brad Green, which initially appeared in 2010\. The project has
    bifurcated into two distinct branches: AngularJS 1.x for small/medium projects
    and Angular 2 (or just Angular) which is intended to cover the needs of big/complex
    projects and uses TypeScript as the programming language due to its strongly typed
    nature.'
  prefs: []
  type: TYPE_NORMAL
- en: In December 2016, they announced the adoption of a semantic versioning approach,
    together with a continuous delivery roadmap that will publish a new version every
    six months, very careful of breaking changes. The latest version is Angular 4,
    which appeared in March 2017, and is totally backward compatible with Angular
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both projects are also maintained by Google and, despite their different programming
    models and language, they share a few things in common: They promote the **Single
    Page Application** (**SPA**) model, and they use a **Model-view-controller** (**MVC**)
    architecture to provide a suitable separation of responsibilities from the first
    moment.'
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS presents itself as a bunch of libraries so the user can choose only
    the ones needed for a given purpose, achieving that way a better granularity.
    All libraries are available via GitHub, NuGet, NPM, Bower, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Our first demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get down to work with our first demo, and, from this initial approach,
    we will test how AngularJS provides an excellent, integrated dependency injection
    system, that facilitates programmers' work to a large extent.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, we can use any IDE to work with Angular, since the three languages
    implied (two in case we don't care about the visual aspects provided by CSS) are
    just HTML and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: However, I'll keep on using Visual Studio, which has a very good support for
    Angular programming and provides native Intellisense on Angular directives, and
    a pretty good debugging experience.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start a new project or a new website (we don't need any compiled libraries).
    We can choose an Empty Project in the ASP.NET section. This creates a project
    with only a `web.config` file in case we need to configure the **Internet Information
    Server** (**IIS**).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the project, we'll create a new HTML file, and once the project is saved
    we can add the Angular libraries in the usual manner, via the `NuGet Package Manager`.
    We should see that AngularJS is now in versions 1.6.x or higher (we should select
    Angular.Core for this demo, which is the basic module).
  prefs: []
  type: TYPE_NORMAL
- en: Once we accept the installation, we'll see a new `Scripts` folder containing
    the development (`angular.js`) and deployment (`angular.min.js`) versions of Angular
    1.6, plus a Mock library for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We just have to include the development library and create the minimum required
    plumbing to see Angular in action--just by including the library, some objects
    and services are loaded into memory and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Especially, there is a `$injector` object that will take care of retrieving
    object instances, instantiate types, load modules and invoke methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, Angular creates an initial, basic model which serves as the root model
    for the application ($rootScope), and expects that the user marks an HTML element
    as the scope of the app. We''ll do that in the `<body> tag`, name it `app`, and
    define a module with the same name, with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice we use an Angular-specific attribute (`ng-app`) to mark the scope of
    our application. These attributes are called directives in Angular and they allow
    us to modify the DOM to suit our needs (All predefined directives start with `ng-`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want our page to show the local time when it loads in the browser. The
    angular mode to do this is to select a target area of the DOM and assign a controller
    to that area. We can do that including the `ng-controller` directive inside the
    corresponding tag.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the code, next to the page's title we've included a `<h3>`
    tag to hold that information, and inside that tag's text, a message, followed
    by `{{ time }}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The double brackets syntax is one of the possible binding mechanisms that Angular
    uses to link data inside the model with the active view, and it''s called **moustache
    syntax**. Thus, we modify the tag in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `ng-controller` directive named `TimeController`, that we need
    to define inside the script. Controllers are defined by calling the app's main
    module, that we previously created, and passing a function as the second argument
    that will be in charge of the logic linked to that controller.
  prefs: []
  type: TYPE_NORMAL
- en: And, here, we finally get to the Dependency Injection mechanism of AngularJS.
    This function should have access to the specific model created by Angular to hold
    the information managed by the controller. We do that via the `$scope` object.
  prefs: []
  type: TYPE_NORMAL
- en: Every controller has its own $scope (it's like a sub-model), which allows read/write
    operations in memory and permits binding between the moustache expressions in
    the DOM and data stored in that model.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does the user code access to that (or any other) service? Via DI, of
    course. The final code is surprisingly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the controller's definition receives a string to identify the controller's
    name, and an anonymous function, to hold the functionality linked to that controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, in that function, we just declared the $scope object: the Angular''s injection
    system takes care of the rest. In the next line of code, we can use that object,
    with a total guarantee of its existence. Even further, Angular provides services
    and objects of this type using a Singleton approach, so there''s no other $scope
    at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the output is as expected, and every time we reload the page, the
    current time is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bee9dac8-f393-4913-ae28-2b7d0891382c.png)'
  prefs: []
  type: TYPE_IMG
- en: This philosophy is extended to any AngularJS object or service and even to those
    services that the user might want to create.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular (modern versions), the architecture is similar, only that it uses
    TypeScript and the preferred way for DI is the constructor-injection model we
    saw in other demos, given that TypeScript is a totally object-oriented language.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](48b807a5-dcd8-479d-b71b-670d93f20cc8.xhtml), *Dependency Injection
    in Other JavaScipt Frameworks*, we'll cover Dependency Injection in JavaScript
    (ES6, or ES 2015, to be precise), TypeScript and Angular 2, so you can have a
    wider sight of today's implementations of DI in modern web frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have focused on the principles and advantages of Dependency
    Injection, and how to implement it in C# starting from a very simple application
    and modifying it to achieve decoupling of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we saw the foundations of DI, we''ve covered briefly three programming
    aspects that influence the way these techniques are applied: Object Composition,
    Object Lifetime, and Interception, as a first approach that we''ll cover in more
    detail in further chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: And, finally, we've seen how some popular IoC containers implement these concepts,
    together with a brief introduction to its use in other frameworks, like AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml), *Introducing Dependency
    Injection in .NET Core 2.0*, we will begin the study of the most interesting features
    about Dependency Injection included in .NET Core.
  prefs: []
  type: TYPE_NORMAL
