<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-101"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.2.1">Data Access in ASP.NET Core (Part 1: Entity Framework Core Fundamentals)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B18971_02.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we introduced a simple ASP.NET Core application to manage blog posts, which uses a static field to store the data in memory. </span><span class="koboSpan" id="kobo.5.2">In many real-world applications, the data is persisted in databases – such as SQL Server, MySQL, SQLite, PostgreSQL, and so on – so we will need to access the database to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">CRUD operations.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will learn about data access in ASP.NET Core. </span><span class="koboSpan" id="kobo.7.2">There are many ways to access the database in ASP.NET Core, such as through ADO.NET, Entity Framework Core, and Dapper, among others. </span><span class="koboSpan" id="kobo.7.3">In this chapter, we will focus on Entity Framework Core, which is the most </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.8.1">popular </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.11.1">ORM</span></strong><span class="koboSpan" id="kobo.12.1">) framework in .</span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">NET Core.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.14.1">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.15.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">EF Core</span></strong><span class="koboSpan" id="kobo.17.1"> for </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.18.1">short, is an open-source ORM framework that allows us to create and manage mapping configurations between the database schema and the object models. </span><span class="koboSpan" id="kobo.18.2">It provides a set of APIs to perform CRUD operations using LINQ methods, which is like operating the objects in memory. </span><span class="koboSpan" id="kobo.18.3">EF Core supports many database providers, such as SQL Server, SQLite, PostgreSQL, MySQL, and so on. </span><span class="koboSpan" id="kobo.18.4">It also supports many other features, such as migrations, change tracking, and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">Why </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">use ORM?</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Configuring the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">DbContext class</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">CRUD controllers</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Basic </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">LINQ queries</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Configuring the mapping between models and </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">database tables</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">By the end of this chapter, you will be able to use EF Core to access the database in ASP.NET Core applications and perform basic </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">CRUD operations.</span></span><a id="_idTextAnchor200"/></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">The code example in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/</span></a><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">You can use VS 2022 or VS Code to open </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">the solution.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">You are expected to have basic knowledge of SQL queries and LINQ. </span><span class="koboSpan" id="kobo.39.2">If you are not familiar with them, you can refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">following resources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.41.1">SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">queries: </span></span><a href="https://www.w3schools.com/sql/"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://www.w3schools.com/sql/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.44.1">LINQ: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/"><span class="No-Break"><span class="koboSpan" id="kobo.45.1">https://learn.microsoft.com/en-us/dotnet/csharp/linq/</span></span></a></li>
</ul>
<h1 id="_idParaDest-104"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.46.1">Why use ORM?</span></h1>
<p><span class="koboSpan" id="kobo.47.1">To operate the</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.48.1"> data in relational databases, we need to write SQL statements. </span><span class="koboSpan" id="kobo.48.2">However, SQL statements are not easy to maintain and are not type-safe. </span><span class="koboSpan" id="kobo.48.3">Every time you update the database schema, you need to update the SQL statements as well, which is error-prone. </span><span class="koboSpan" id="kobo.48.4">In many traditional applications, the logic is tightly coupled with the database. </span><span class="koboSpan" id="kobo.48.5">For example, the logic could be defined in a SQL database directly, such as stored procedures, triggers, and so on. </span><span class="koboSpan" id="kobo.48.6">This makes the application hard to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and extend.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">ORM helps us to map the database schema to the object model, so we can operate the data in the database just like we operate the objects in memory. </span><span class="koboSpan" id="kobo.50.2">ORM can translate the CRUD operations to SQL statements, which means it is like an abstract layer between the application and the database. </span><span class="koboSpan" id="kobo.50.3">The data access logic is decoupled from the database, so we can easily change the database without changing the code. </span><span class="koboSpan" id="kobo.50.4">Also, it provides strong type safety, so we can avoid runtime errors caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">type mismatch.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Keep in mind that we are not saying that ORM is the best solution for all scenarios. </span><span class="koboSpan" id="kobo.52.2">Sometimes, we need to write SQL statements directly to achieve the best performance. </span><span class="koboSpan" id="kobo.52.3">For example, if we need to generate a complex data report, we may need to write SQL statements to optimize the performance of the query. </span><span class="koboSpan" id="kobo.52.4">However, for most scenarios, ORM provides more benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">than drawbacks.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">There are many ORM frameworks in .NET. </span><span class="koboSpan" id="kobo.54.2">In this book, we will use EF Core, which is the most popular ORM framework in .NET Core. </span><span class="koboSpan" id="kobo.54.3">The following are the reasons why we chose </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">EF Core:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Open-source</span></strong><span class="koboSpan" id="kobo.57.1">: EF Core is an</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.58.1"> open-source project and is mainly maintained by Microsoft, so it is well-supported. </span><span class="koboSpan" id="kobo.58.2">The contribution is also </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">very active.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Multiple database support</span></strong><span class="koboSpan" id="kobo.61.1">: EF Core supports</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.62.1"> many database providers, such as SQL Server, SQLite, PostgreSQL, MySQL and so on. </span><span class="koboSpan" id="kobo.62.2">Developers can use the same APIs to access </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">different databases.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Migration</span></strong><span class="koboSpan" id="kobo.65.1">: EF Core supports </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.66.1">database migrations, which allows us to update the database </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">schema easily.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">LINQ support</span></strong><span class="koboSpan" id="kobo.69.1">: EF Core </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.70.1">provides support for LINQ, which allows us to use a familiar syntax to query </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">the database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Code-first approach</span></strong><span class="koboSpan" id="kobo.73.1">: EF Core</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.74.1"> supports the code-first approach, which means we can define the database schema using C# code, and EF Core will generate the database </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">schema automatically.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Performance</span></strong><span class="koboSpan" id="kobo.77.1">: EF Core</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.78.1"> is designed to be lightweight and performant. </span><span class="koboSpan" id="kobo.78.2">It supports query caching and lazy loading to help improve performance. </span><span class="koboSpan" id="kobo.78.3">Also, EF Core provides asynchronous APIs, which allows us to perform database operations asynchronously to improve the scalability of the application. </span><span class="koboSpan" id="kobo.78.4">In addition, EF Core supports raw SQL queries, enabling us to write SQL statements directly to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">best performance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.80.1">Overall, EF Core is a good choice for most scenarios if you are using .NET Core. </span><span class="koboSpan" id="kobo.80.2">So, in this book, we will be using EF Core as the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">ORM framework.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">To use the .NET Core CLI to perform EF Core-related tasks, we first need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">dotnet-ef</span></strong><span class="koboSpan" id="kobo.84.1"> tool. </span><span class="koboSpan" id="kobo.84.2">You can install it using the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.86.1">
dotnet tool install --global dotnet-ef</span></pre> <p><span class="koboSpan" id="kobo.87.1">It is recommended to install the tool as a global tool, so you can use it in any project </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">for convenience.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Next, create a new web API project using the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.91.1">
dotnet new webapi -n BasicEfCoreDemo -controllers</span></pre> <p><span class="koboSpan" id="kobo.92.1">Then, navigate to the project folder and run the following command to install EF </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">Core packages:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.94.1">
dotnet add package Microsoft.EntityFrameworkCore.SqlServerdotnet add package Microsoft.EntityFrameworkCore.Design</span></pre>
<p><span class="koboSpan" id="kobo.95.1">The first package is the database provider, which is used to connect the application to a SQL Server database. </span><span class="koboSpan" id="kobo.95.2">For this demo application, we </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.96.1">will use </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">LocalDB</span></strong><span class="koboSpan" id="kobo.98.1">, which is a lightweight version of SQL Server. </span><span class="koboSpan" id="kobo.98.2">The second package contains shared design-time components for EF Core tools, which are required to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">database migrations.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.100.1">What is LocalDB?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.101.1">LocalDB is designed to be used as a substitute for the full version of SQL Server; it is suitable for development and testing, but not for production use. </span><span class="koboSpan" id="kobo.101.2">We can use LocalDB for development and replace the connection string when we deploy the application to production. </span><span class="koboSpan" id="kobo.101.3">LocalDB is installed with VS 2022. </span><span class="koboSpan" id="kobo.101.4">If you do not have VS 2022 by default, you can find the installation package </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">at </span></span><a href="https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb"><span class="No-Break"><span class="koboSpan" id="kobo.103.1">https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.104.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.105.1">LocalDB is supported by Windows only. </span><span class="koboSpan" id="kobo.105.2">If you use macOS or Linux, you can use SQLite instead of LocalDB, or use a Docker container to run SQL Server. </span><span class="koboSpan" id="kobo.105.3">For more information about SQLite, please refer </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">to </span></span><a href="https://docs.microsoft.com/en-us/ef/core/providers/sqlite/"><span class="No-Break"><span class="koboSpan" id="kobo.107.1">https://docs.microsoft.com/en-us/ef/core/providers/sqlite/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.108.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.109.1">For more information about SQL Server on Docker, please refer to </span><a href="https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker"><span class="koboSpan" id="kobo.110.1">https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker</span></a><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">Note that there are many other database providers, such as SQLite, PostgreSQL, MySQL, and so on. </span><span class="koboSpan" id="kobo.111.3">You can find the full list of database providers at </span><a href="https://docs.microsoft.com/en-us/ef/core/providers/"><span class="koboSpan" id="kobo.112.1">https://docs.microsoft.com/en-us/ef/core/providers/</span></a><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">Some providers are not maintained </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">by Microsoft.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Next, let’s explore how to use EF Core to access </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the </span><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.117.1">database.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.118.1">Configuring the DbContext class</span></h1>
<p><span class="koboSpan" id="kobo.119.1">To </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.120.1">represent the database, EF Core uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">DbContext</span></strong><span class="koboSpan" id="kobo.122.1"> class, which allows us to query and save data. </span><span class="koboSpan" id="kobo.122.2">An instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">DbContext</span></strong><span class="koboSpan" id="kobo.124.1"> class maintains the database connection and maps the database schema to the object model. </span><span class="koboSpan" id="kobo.124.2">It also tracks the changes in objects and manages the transactions. </span><span class="koboSpan" id="kobo.124.3">If you are familiar with OOP, you can think of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">DbContext</span></strong><span class="koboSpan" id="kobo.126.1"> class as a bridge between the database and the object model, just like an interface. </span><span class="koboSpan" id="kobo.126.2">When you query or save data, you operate the objects through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">DbContext</span></strong><span class="koboSpan" id="kobo.128.1"> class, and EF Core will translate the operations to the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">SQL statements.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">In this chapter, we will develop a simple application to manage invoices. </span><span class="koboSpan" id="kobo.130.2">This application will be used to demonstrate how to use EF Core to access the database, including how to define the database schema, how to perform CRUD operations, and how to use migrations to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">database schema.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">You can follow </span><a href="B18971_01.xhtml#_idTextAnchor012"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.134.1"> to define the API contract first. </span><span class="koboSpan" id="kobo.134.2">The API contract defines the endpoints and the request/response models. </span><span class="koboSpan" id="kobo.134.3">When we define the API contract, note that we need to consult stakeholders to understand the requirements. </span><span class="koboSpan" id="kobo.134.4">For example, we need to know the fields of the invoice, the data types of the fields, and so on. </span><span class="koboSpan" id="kobo.134.5">We also need to understand the business rules, such as </span><em class="italic"><span class="koboSpan" id="kobo.135.1">the invoice number should be unique</span></em><span class="koboSpan" id="kobo.136.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.137.1">the invoice amount should be greater than 0</span></em><span class="koboSpan" id="kobo.138.1">, for example. </span><span class="koboSpan" id="kobo.138.2">That means we will spend lots of time on the API design phase. </span><span class="koboSpan" id="kobo.138.3">Here, we assume that we have already defined the API contract, and we can start to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the ap</span><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.140.1">plication.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.141.1">Creating models</span></h2>
<p><span class="koboSpan" id="kobo.142.1">The </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.143.1">first step is to define the models. </span><span class="koboSpan" id="kobo.143.2">A model, also known as an entity, is a class that represents an object in the real world, which will be mapped to a table (or multiple tables) in the database. </span><span class="koboSpan" id="kobo.143.3">In this demo application, we need to define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Invoice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> model.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">An invoice can be defined as the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">following class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
namespace BasicEfCoreDemo.Models;public class Invoice{
    public Guid Id { get; set; }
    public string InvoiceNumber { get; set; } = string.Empty;
    public string ContactName { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.148.2">Description { get; set; }
    public decimal Amount { get; set; }
    public DateTimeOffset InvoiceDate { get; set; }
    public DateTimeOffset DueDate { get; set; }
    public InvoiceStatus Status { get; set; }
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">InvoiceStatus</span></strong><span class="koboSpan" id="kobo.150.1"> is a </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.151.1">custom enum type, which is defined as the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
public enum InvoiceStatus{
    Draft,
    AwaitPayment,
    Paid,
    Overdue,
    Cancelled
}</span></pre>
<p><span class="koboSpan" id="kobo.154.1">You can create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Invoice.cs</span></strong><span class="koboSpan" id="kobo.156.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Models</span></strong><span class="koboSpan" id="kobo.158.1"> folder and copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Invoice</span></strong><span class="koboSpan" id="kobo.160.1"> class code into </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the file.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.162.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.163.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Guid</span></strong><span class="koboSpan" id="kobo.165.1"> type for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Id</span></strong><span class="koboSpan" id="kobo.167.1"> property, which is the unique identifier for the invoice. </span><span class="koboSpan" id="kobo.167.2">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">int</span></strong><span class="koboSpan" id="kobo.169.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">long</span></strong><span class="koboSpan" id="kobo.171.1"> as the identifier. </span><span class="koboSpan" id="kobo.171.2">Either way has its pros and cons. </span><span class="koboSpan" id="kobo.171.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">int</span></strong><span class="koboSpan" id="kobo.173.1"> is more efficient than </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Guid</span></strong><span class="koboSpan" id="kobo.175.1">, but it is not unique across databases. </span><span class="koboSpan" id="kobo.175.2">When the database grows, you may need to split the data into multiple databases, which means the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">int</span></strong><span class="koboSpan" id="kobo.177.1"> identifier may not be unique anymore. </span><span class="koboSpan" id="kobo.177.2">On the other hand, </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Guid</span></strong><span class="koboSpan" id="kobo.179.1"> is unique no matter how many databases you have, but it is more expensive to store, insert, query, and sort the records than using </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">int</span></strong><span class="koboSpan" id="kobo.181.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">long</span></strong><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Guid</span></strong><span class="koboSpan" id="kobo.185.1"> primary key with the cluster index may cause poor performance in some scenarios. </span><span class="koboSpan" id="kobo.185.2">In this demo application, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Guid</span></strong><span class="koboSpan" id="kobo.187.1"> as the identifier for now. </span><span class="koboSpan" id="kobo.187.2">We will discuss more about the techniques to optimize the application performance in </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">future chapters.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.189.1">We also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">DateTimeOffset</span></strong><span class="koboSpan" id="kobo.191.1"> type for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">InvoiceDate</span></strong><span class="koboSpan" id="kobo.193.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">DueDate</span></strong><span class="koboSpan" id="kobo.195.1"> properties, which is the recommended type for date and time in .NET Core. </span><span class="koboSpan" id="kobo.195.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">DateTime</span></strong><span class="koboSpan" id="kobo.197.1"> type if you do not care about the time zone. </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">DateTimeOffset</span></strong><span class="koboSpan" id="kobo.199.1"> includes a time zone offset from UTC time, and it is supported by both .NET type and SQL Server. </span><span class="koboSpan" id="kobo.199.2">This is helpful if you want to avoid the time </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">zone issues.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">We may need</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.202.1"> more properties in the future, such as contact information, invoice items, and so on, but we will add them later. </span><span class="koboSpan" id="kobo.202.2">Let’s focus on only the m</span><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.203.1">odel </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">for now.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.205.1">Creating and configuring the DbContext class</span></h2>
<p><span class="koboSpan" id="kobo.206.1">Next, we will </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.207.1">create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">DbContext</span></strong><span class="koboSpan" id="kobo.209.1"> class to represent the database. </span><span class="koboSpan" id="kobo.209.2">Create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">InvoiceDbContext.cs</span></strong><span class="koboSpan" id="kobo.211.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Data</span></strong><span class="koboSpan" id="kobo.213.1"> folder and add the</span><a id="_idIndexMarker467"/> <span class="No-Break"><span class="koboSpan" id="kobo.214.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
using BasicEfCoreDemo.Models;using Microsoft.EntityFrameworkCore;
namespace BasicEfCoreDemo.Data;
public class InvoiceDbContext(DbContextOptions&lt;InvoiceDbContext&gt; options) : DbContext(options)
{
    public DbSet&lt;Invoice&gt; Invoices =&gt; Set&lt;Invoice&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.216.1">In the </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.217.1">preceding code, we have done </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.219.1">Inherited the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">DbContext</span></strong><span class="koboSpan" id="kobo.221.1"> class and defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.223.1"> class, which represents </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">the database.</span></span></li>
<li><span class="koboSpan" id="kobo.225.1">Defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Invoices</span></strong><span class="koboSpan" id="kobo.227.1"> property, which is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">DbSet&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.229.1"> type. </span><span class="koboSpan" id="kobo.229.2">It is used to represent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Invoices</span></strong><span class="koboSpan" id="kobo.231.1"> table in </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">the database.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.233.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.234.1">Why we do not use </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">public DbSet&lt;Invoice&gt; Invoices { get; set; }</span></strong><span class="koboSpan" id="kobo.236.1"> here? </span><span class="koboSpan" id="kobo.236.2">The reason is that if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">DbSet&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.238.1"> properties are not initialized, the compiler will emit warnings from them because the nullable reference type feature is enabled by default. </span><span class="koboSpan" id="kobo.238.2">So we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">Set&lt;TEntity&gt;()</span></strong><span class="koboSpan" id="kobo.240.1"> method to initialize the property to eliminate the warning. </span><span class="koboSpan" id="kobo.240.2">Another way to fix that is to use the null-forgiving operator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">!</span></strong><span class="koboSpan" id="kobo.242.1">, which forces the silencing of the compiler warnings. </span><span class="koboSpan" id="kobo.242.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">DbContext</span></strong><span class="koboSpan" id="kobo.244.1"> base constructor will initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">DbSet&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.246.1"> properties for us, so it is safe to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">!</span></strong><span class="koboSpan" id="kobo.248.1"> for this case. </span><span class="koboSpan" id="kobo.248.2">If you do not mind seeing the warnings, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">public DbSet&lt;Invoice&gt; Invoices { get; set; }</span></strong><span class="koboSpan" id="kobo.250.1"> also works. </span><span class="koboSpan" id="kobo.250.2">You can use </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">either method.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Next, let’s configure the database connection string. </span><span class="koboSpan" id="kobo.252.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.254.1"> file and add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">ConnectionStrings</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
"ConnectionStrings": {    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=BasicEfCoreDemoDb;Trusted_Connection=True;MultipleActiveResultSets=true"
  }</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.258.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.259.1">You can use other databases, such as SQLite or PostgreSQL, but you need to install the corresponding database provider and change the connection string accordingly. </span><span class="koboSpan" id="kobo.259.2">To learn more about connection strings, please refer to </span><a href="https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax"><span class="koboSpan" id="kobo.260.1">https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax</span></a><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">There is a website called </span><a href="https://connectionstrings.com/"><span class="koboSpan" id="kobo.262.1">https://connectionstrings.com/</span></a><span class="koboSpan" id="kobo.263.1"> that can generate connection strings for different </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">database providers.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">In the </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.266.1">preceding connection string, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Server=(localdb)\\mssqllocaldb </span></strong><span class="koboSpan" id="kobo.268.1">to specify the server as a LocalDB instance, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Database=BasicEfCoreDemoDb</span></strong><span class="koboSpan" id="kobo.270.1"> to specify the name of the database. </span><span class="koboSpan" id="kobo.270.2">You can change the database name to whatever you want. </span><span class="koboSpan" id="kobo.270.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Trusted_Connection=True</span></strong><span class="koboSpan" id="kobo.272.1"> option specifies that the connection is trusted, which means you do not need to provide the username and password. </span><span class="koboSpan" id="kobo.272.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">MultipleActiveResultSets=true</span></strong><span class="koboSpan" id="kobo.274.1"> option specifies that the connection can have </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">Multiple Active Result Sets</span></strong><span class="koboSpan" id="kobo.276.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">MARS</span></strong><span class="koboSpan" id="kobo.278.1">). </span><span class="koboSpan" id="kobo.278.2">This</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.279.1"> means that you can have multiple independent queries executing on the same connection. </span><span class="koboSpan" id="kobo.279.2">This option is required for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Include()</span></strong><span class="koboSpan" id="kobo.281.1"> method in </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">EF Core.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Program.cs</span></strong><span class="koboSpan" id="kobo.285.1"> file and add the following code after </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">builder</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.287.1">is created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
builder.Services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));</span></pre>
<p><span class="koboSpan" id="kobo.289.1">The preceding code registers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.291.1"> class to the dependency injection container. </span><span class="koboSpan" id="kobo.291.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">AddDbContext&lt;TContext&gt;()</span></strong><span class="koboSpan" id="kobo.293.1"> method is an extension method that accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">DbContextOptionsBuilder</span></strong><span class="koboSpan" id="kobo.295.1"> parameter, which calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">UseSqlServer()</span></strong><span class="koboSpan" id="kobo.297.1"> method to configure the database provider to use SQL Server or LocalDB. </span><span class="koboSpan" id="kobo.297.2">Note that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">UseSqlServer()</span></strong><span class="koboSpan" id="kobo.299.1"> method for both SQL Server and LocalDB. </span><span class="koboSpan" id="kobo.299.2">The difference is that LocalDB has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">(localdb)\\mssqllocaldb</span></strong><span class="koboSpan" id="kobo.301.1"> server name by default. </span><span class="koboSpan" id="kobo.301.2">We also pass the database connection string to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">UseSqlServer()</span></strong><span class="koboSpan" id="kobo.303.1"> method, which should be the same as the name we defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Currently, this</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.307.1"> code just registers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.309.1"> class to the dependency injection container, but we have not created the database yet. </span><span class="koboSpan" id="kobo.309.2">Next, we will create the database using the</span><a id="_idTextAnchor209"/> <strong class="source-inline"><span class="koboSpan" id="kobo.310.1">dotnet </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">ef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1"> command.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.313.1">Creating the database</span></h2>
<p><span class="koboSpan" id="kobo.314.1">We </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.315.1">have defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.317.1"> class, and the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.319.1"> is added to the dependency injection container. </span><span class="koboSpan" id="kobo.319.2">Next, we need to create the database and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Invoices</span></strong><span class="koboSpan" id="kobo.321.1"> table before we can use it. </span><span class="koboSpan" id="kobo.321.2">To create the database and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Invoices</span></strong><span class="koboSpan" id="kobo.323.1"> table, we need to run the following command to apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">database migration:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.325.1">
dotnet ef migrations add InitialDb</span></pre> <p><span class="koboSpan" id="kobo.326.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">InitialDb</span></strong><span class="koboSpan" id="kobo.328.1"> parameter is the migration name. </span><span class="koboSpan" id="kobo.328.2">You can use any name you like as long as it is a valid C# identifier. </span><span class="koboSpan" id="kobo.328.3">It is recommended to use a meaningful name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">InitialDb</span></strong><span class="koboSpan" id="kobo.330.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">AddInvoiceTable</span></strong><span class="koboSpan" id="kobo.332.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">The preceding command creates a couple of migration files, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">&lt;timestamp&gt;_InitialDb.cs</span></strong><span class="koboSpan" id="kobo.336.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">&lt;timestamp&gt;_InitialDb.Designer.cs</span></strong><span class="koboSpan" id="kobo.338.1">, which are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Migrations</span></strong><span class="koboSpan" id="kobo.340.1"> folder. </span><span class="koboSpan" id="kobo.340.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">&lt;timestamp&gt;_InitialDb.cs</span></strong><span class="koboSpan" id="kobo.342.1"> migration file contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Up()</span></strong><span class="koboSpan" id="kobo.344.1"> method to create the database and the tables. </span><span class="koboSpan" id="kobo.344.2">It also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Down()</span></strong><span class="koboSpan" id="kobo.346.1"> method to roll back the changes. </span><span class="koboSpan" id="kobo.346.2">Note that this command does not create the database; it just creates the migration files. </span><span class="koboSpan" id="kobo.346.3">Please do not manually modify or delete the migration files as they are required to apply or roll back the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">database changes.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Here is a sample of the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">migration files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
protected override void Up(MigrationBuilder migrationBuilder){
    migrationBuilder.CreateTable(
        name: "Invoices",
        columns: table =&gt; new
        {
            Id = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),
            InvoiceNumber = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
            ContactName = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
            Description = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: true),
            Amount = table.Column&lt;decimal&gt;(type: "decimal(18,2)", nullable: false),
            InvoiceDate = table.Column&lt;DateTimeOffset&gt;(type: "datetimeoffset", nullable: false),
            DueDate = table.Column&lt;DateTimeOffset&gt;(type: "datetimeoffset", nullable: false),
            Status = table.Column&lt;int&gt;(type: "int", nullable: false)
        },
        constraints: table =&gt;
        {
            table.PrimaryKey("PK_Invoices", x =&gt; x.Id);
        });
}
// Omitted for brevity</span></pre>
<p><span class="koboSpan" id="kobo.351.1">As you </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.352.1">can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Up()</span></strong><span class="koboSpan" id="kobo.354.1"> method creates the table, columns, and constraints. </span><span class="koboSpan" id="kobo.354.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Down()</span></strong><span class="koboSpan" id="kobo.356.1"> method drops the table. </span><span class="koboSpan" id="kobo.356.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">dotnet ef migrations remove</span></strong><span class="koboSpan" id="kobo.358.1"> to remove the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">migration files.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.360.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.361.1">You may see a warning message </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">like this:</span></span></p>
<p class="callout"><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.363.1">Microsoft.EntityFrameworkCore.Model.Validation[30000]</span></strong></span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.364.1">No store type was specified for the decimal property ‘Amount’ on entity type ‘Invoice’. </span><span class="koboSpan" id="kobo.364.2">This will cause &gt; values to be silently truncated if they do not fit in the default precision and scale. </span><span class="koboSpan" id="kobo.364.3">Explicitly &gt; specify the SQL server column type that can accommodate all the values in ‘OnModelCreating’ using &gt; ‘HasColumnType’, specify precision and scale using ‘HasPrecision’, or configure a value converter using &gt; ‘</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.365.1">HasConversion’.</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.366.1">This is because we did not specify the precision and scale for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Amount</span></strong><span class="koboSpan" id="kobo.368.1"> property. </span><span class="koboSpan" id="kobo.368.2">We will fix it later. </span><span class="koboSpan" id="kobo.368.3">Currently, EF Core will use the default precision and scale for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">decimal</span></strong><span class="koboSpan" id="kobo.370.1"> type, which </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">decimal(18,2)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">The migration file </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.375.1">has been created, but it has not been applied to the database yet. </span><span class="koboSpan" id="kobo.375.2">Next, run the following command to create the database and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Invoices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.377.1"> table:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.378.1">
dotnet ef database update</span></pre> <p><span class="koboSpan" id="kobo.379.1">If the command is successful, we should find the database file in your user folder, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">C:\Users\{username}\BasicEfCoreDemoDb.mdf</span></strong><span class="koboSpan" id="kobo.381.1"> if you use Windows. </span><span class="koboSpan" id="kobo.381.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">%USERPROFILE%</span></strong><span class="koboSpan" id="kobo.383.1"> to get the user </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">folder path.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.385.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.386.1">You may encounter an error</span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1"> System.Globalization.CultureNotFoundException</span></strong><span class="koboSpan" id="kobo.388.1">: Only the invariant culture is supported in globalizati</span><a href="https://aka"><span class="koboSpan" id="kobo.389.1">on-invarian</span></a><span class="koboSpan" id="kobo.390.1">t mode. </span><span class="koboSpan" id="kobo.390.2">See https://aka</span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">.ms/GlobalizationInvariantMode</span></strong><span class="koboSpan" id="kobo.392.1"> for more information. </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">(Parameter 'name')</span></strong><span class="koboSpan" id="kobo.394.1">. </span><span class="koboSpan" id="kobo.394.2">This is because starting in .NET 6, the globalization invariant mode is enabled by default. </span><span class="koboSpan" id="kobo.394.3">You can disable it by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">InvariantGlobalization</span></strong><span class="koboSpan" id="kobo.396.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">false</span></strong><span class="koboSpan" id="kobo.398.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">csproj</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">There are several tools you can use to open the LocalDB database file – for example, </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">SQL Server Management Studio</span></strong><span class="koboSpan" id="kobo.403.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.404.1">SSMS</span></strong><span class="koboSpan" id="kobo.405.1">), which </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.406.1">is supported by Microsoft. </span><span class="koboSpan" id="kobo.406.2">Yo</span><a href="https://learn"><span class="koboSpan" id="kobo.407.1">u can downloa</span></a><span class="koboSpan" id="kobo.408.1">d it here: </span><a href="https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms"><span class="koboSpan" id="kobo.409.1">https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms</span></a><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">You can also use other </span><a href="https://dbeaver"><span class="koboSpan" id="kobo.411.1">tools, such as </span></a><span class="koboSpan" id="kobo.412.1">Dbeaver (</span><a href="https://dbeaver.io/"><span class="koboSpan" id="kobo.413.1">https://dbeaver.io/</span></a><span class="koboSpan" id="kobo.414.1">), a free, universal database tool,</span><a href="https://www"><span class="koboSpan" id="kobo.415.1"> or JetBrai</span></a><span class="koboSpan" id="kobo.416.1">ns DataGrip (</span><a href="https://www.jetbrains.com/datagrip/"><span class="koboSpan" id="kobo.417.1">https://www.jetbrains.com/datagrip/</span></a><span class="koboSpan" id="kobo.418.1">), a </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.419.1">powerful database IDE. </span><span class="koboSpan" id="kobo.419.2">We’ll be </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">using SSMS.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Open the </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.422.1">database file in SSMS, and you will see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">BasicEfCoreDemoDb</span></strong><span class="koboSpan" id="kobo.424.1"> database has been created. </span><span class="koboSpan" id="kobo.424.2">It will have two tables – </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">Invoices</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.426.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">__EFMigrationsHistory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.429.1"><img alt="Figure 5.1 – The database created by EF Core migration" src="image/B18971_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.430.1">Figure 5.1 – The database created by EF Core migration</span></p>
<p><span class="koboSpan" id="kobo.431.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">__EFMigrationsHistory</span></strong><span class="koboSpan" id="kobo.433.1"> table is used to track the migrations. </span><span class="koboSpan" id="kobo.433.2">It is created automatically by EF Core. </span><span class="koboSpan" id="kobo.433.3">Do not manually </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">modify it.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">Now that we </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.436.1">have created the database and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">Invoices</span></strong><span class="koboSpan" id="kobo.438.1"> table. </span><span class="koboSpan" id="kobo.438.2">Next,let’s add som</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.439.1">e seed data to </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the table.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.441.1">Adding seed data</span></h2>
<p><span class="koboSpan" id="kobo.442.1">Open</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.443.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">InvoiceDbContext.cs</span></strong><span class="koboSpan" id="kobo.445.1"> file and add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">OnModelCreating()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
protected override void OnModelCreating(ModelBuilder modelBuilder){
    modelBuilder.Entity&lt;Invoice&gt;().HasData(
        new Invoice
        {
            Id = Guid.NewGuid(),
            InvoiceNumber = "INV-001",
            ContactName = "Iron Man",
            Description = "Invoice for the first month",
            Amount = 100,
            InvoiceDate = new DateTimeOffset(2023, 1, 1, 0, 0, 0, TimeSpan.Zero),
            DueDate = new DateTimeOffset(2023, 1, 15, 0, 0, 0, TimeSpan.Zero),
            Status = InvoiceStatus.AwaitPayment
        },
        // Omitted for brevity. </span><span class="koboSpan" id="kobo.448.2">You can check the full code in the sample project.
</span><span class="koboSpan" id="kobo.448.3">}</span></pre>
<p><span class="koboSpan" id="kobo.449.1">We need to create a new database migration to apply the changes to the database. </span><span class="koboSpan" id="kobo.449.2">Run the </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.451.1">
dotnet ef migrations add AddSeedDatadotnet ef database update</span></pre>
<p><span class="koboSpan" id="kobo.452.1">If you check the </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.453.1">database in SSMS, you will see that the seed data is added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Invoices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1"> table.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">The data is ready. </span><span class="koboSpan" id="kobo.456.2">Next, we will create the controllers to handle the HTTP requests and operate </span><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.457.1">the data with </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">the database.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.459.1">Implementing CRUD controllers</span></h1>
<p><span class="koboSpan" id="kobo.460.1">In this </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.461.1">section, we will implement the controllers to handle the HTTP requests, which are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">GET</span></strong><span class="koboSpan" id="kobo.463.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">POST</span></strong><span class="koboSpan" id="kobo.465.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">PUT</span></strong><span class="koboSpan" id="kobo.467.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">DELETE</span></strong><span class="koboSpan" id="kobo.469.1"> operations that are used to retrieve, create, update, an</span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.470.1">d delete </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">data, respectively.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.472.1">Creating the controller</span></h2>
<p><span class="koboSpan" id="kobo.473.1">If you</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.474.1"> have installed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">dotnet aspnet-codegenerator</span></strong><span class="koboSpan" id="kobo.476.1"> tool following </span><a href="B18971_02.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.477.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.478.1">, you can use the following command to create a controller with the specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">DbContext</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">Do not forget to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Microsoft.VisualStudio.Web.CodeGeneration.Design</span></strong><span class="koboSpan" id="kobo.482.1"> NuGet package, which is required by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">dotnet </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">aspnet-codegenerator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1"> tool:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.486.1">
# Install the tool if you have not installed it yet.#dotnet tool install -g dotnet-aspnet-codegenerator
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet-aspnet-codegenerator controller -name InvoicesController -api -outDir Controllers ––model Invoice ––dataContext InvoiceDbContext -async -actions</span></pre>
<p><span class="koboSpan" id="kobo.487.1">The preceding command has some parameters as </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">shown here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">-name</span></strong><span class="koboSpan" id="kobo.490.1">: The name of </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">the controller.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">-api</span></strong><span class="koboSpan" id="kobo.493.1">: Indicates that the controller is an </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">API controller.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">-outDir</span></strong><span class="koboSpan" id="kobo.496.1">: The output directory of </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">the controller.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">--model</span></strong><span class="koboSpan" id="kobo.499.1">: The model class name. </span><span class="koboSpan" id="kobo.499.2">In this case, it is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Invoice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.501.1"> class.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">--dataContext</span></strong><span class="koboSpan" id="kobo.503.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">DbContext</span></strong><span class="koboSpan" id="kobo.505.1"> class name. </span><span class="koboSpan" id="kobo.505.2">In this case, it is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">InvoiceDbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1"> class.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">-async</span></strong><span class="koboSpan" id="kobo.509.1">: Indicates that the actions of the controller </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">are asynchronous.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.511.1">For more </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.512.1">information about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">dotnet</span></strong><a href="https://learn"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1"> aspnet-codeg</span></strong></a><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">enerator</span></strong><span class="koboSpan" id="kobo.516.1"> tool, </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">see </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator"><span class="No-Break"><span class="koboSpan" id="kobo.518.1">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.519.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">dotnet aspnet-codegenerator</span></strong><span class="koboSpan" id="kobo.522.1"> tool will create a controller with the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">following actions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
using BasicEfCoreDemo.Data;using BasicEfCoreDemo.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
namespace BasicEfCoreDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class InvoicesController : ControllerBase
    {
        private readonly InvoiceDbContext _context;
        public InvoicesController(InvoiceDbContext context)
        {
            _context = context;
        }
        // GET: api/Invoices
        [HttpGet]
        public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices()
        {
            if (_context.Invoices == null)
            {
                return NotFound();
            }
            return await _context.Invoices.ToListAsync();
        }
        // GET: api/Invoices/5
        [HttpGet("{id}")]
        public async Task&lt;ActionResult&lt;Invoice&gt;&gt; GetInvoice(Guid id)
        {
            if (_context.Invoices == null)
            {
                return NotFound();
            }
            var invoice = await _context.Invoices.FindAsync(id);
            if (invoice == null)
            {
                return NotFound();
            }
            return invoice;
        }
        // PUT: api/Invoices/5
        // To protec</span><a href="https://go"><span class="koboSpan" id="kobo.525.1">t from ove</span></a><span class="koboSpan" id="kobo.526.1">rposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754
        [HttpPut("{id}")]
        public async Task&lt;IActionResult&gt; PutInvoice(Guid id, Invoice invoice)
        {
            if (id != invoice.Id)
            {
                return BadRequest();
            }
            _context.Entry(invoice).State = EntityState.Modified;
            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!InvoiceExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }
            return NoContent();
        }
        // POST: api/Invoices
        // To protec</span><a href="https://go"><span class="koboSpan" id="kobo.527.1">t from ove</span></a><span class="koboSpan" id="kobo.528.1">rposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754
        [HttpPost]
        public async Task&lt;ActionResult&lt;Invoice&gt;&gt; PostInvoice(Invoice invoice)
        {
            if (_context.Invoices == null)
            {
                return Problem("Entity set 'InvoiceDbContext.Invoices'  is null.");
            }
            _context.Invoices.Add(invoice);
            await _context.SaveChangesAsync();
            return CreatedAtAction("GetInvoice", new { id = invoice.Id }, invoice);
        }
        // DELETE: api/Invoices/5
        [HttpDelete("{id}")]
        public async Task&lt;IActionResult&gt; DeleteInvoice(Guid id)
        {
            if (_context.Invoices == null)
            {
                return NotFound();
            }
            var invoice = await _context.Invoices.FindAsync(id);
            if (invoice == null)
            {
                return NotFound();
            }
            _context.Invoices.Remove(invoice);
            await _context.SaveChangesAsync();
            return NoContent();
        }
        private bool InvoiceExists(Guid id)
        {
            return (_context.Invoices?.Any(e =&gt; e.Id == id)).GetValueOrDefault();
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.529.1">It is so easy! </span><span class="koboSpan" id="kobo.529.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">dotnet aspnet-codegenerator</span></strong><span class="koboSpan" id="kobo.531.1"> tool has generated the controller </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.532.1">with basic CRUD operations. </span><span class="koboSpan" id="kobo.532.2">You can run the application and test the API endpoints with the Swagger UI. </span><span class="koboSpan" id="kobo.532.3">We will explain the co</span><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.533.1">de of the controller </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">in detail.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.535.1">How controllers work</span></h2>
<p><span class="koboSpan" id="kobo.536.1">In </span><a href="B18971_02.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.537.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.538.1"> and</span><em class="italic"> </em><a href="B18971_03.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.539.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.540.1">, we introduced how HTTP requests are mapped to the controller actions. </span><span class="koboSpan" id="kobo.540.2">In this chapter, we focus on data access and </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">database operations.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">First, we use DI</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.543.1"> to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.545.1"> instance into the controller, which handles the database operations. </span><span class="koboSpan" id="kobo.545.2">As developers, normally, we do not need to worry about the database connection. </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.547.1"> is registered as scoped, which means that each HTTP request will create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.549.1"> instance, and the instance will be disposed of after the request </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Once we get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.553.1"> instance, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">DbSet</span></strong><span class="koboSpan" id="kobo.555.1"> property to access the entity set. </span><span class="koboSpan" id="kobo.555.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">DbSet&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.557.1"> property represents a collection of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">Invoice</span></strong><span class="koboSpan" id="kobo.559.1"> model class, which is mapped to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Invoices</span></strong><span class="koboSpan" id="kobo.561.1"> table in the database. </span><span class="koboSpan" id="kobo.561.2">We can </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.562.1">use </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">LINQ</span></strong><span class="koboSpan" id="kobo.564.1"> methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.566.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Add()</span></strong><span class="koboSpan" id="kobo.568.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Remove()</span></strong><span class="koboSpan" id="kobo.570.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Update()</span></strong><span class="koboSpan" id="kobo.572.1">, to retrieve, add, remove, and update the entity in the database, respectively. </span><span class="koboSpan" id="kobo.572.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.574.1"> method is used to save the changes to the database. </span><span class="koboSpan" id="kobo.574.2">In this way, we operate the database through .NET objects, which is much easier than using SQL statements. </span><span class="koboSpan" id="kobo.574.3">That is the power </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">of ORMs.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.576.1">What is LINQ?</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.577.1">Language-Integrated Query</span></strong><span class="koboSpan" id="kobo.578.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.579.1">LINQ</span></strong><span class="koboSpan" id="kobo.580.1">) is a </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.581.1">set of features in .NET that provide a consistent and expressive way to query and manipulate data from various data sources, such as a database, XML, and in-memory collections. </span><span class="koboSpan" id="kobo.581.2">With LINQ, you can write queries in a declarative way, which is much easier than using SQL statements. </span><span class="koboSpan" id="kobo.581.3">We will show you some basic LINQ queries in the next section. </span><a href="https://lear"><span class="koboSpan" id="kobo.582.1">For more info</span></a><span class="koboSpan" id="kobo.583.1">rmation about LINQ, </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">see </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/"><span class="No-Break"><span class="koboSpan" id="kobo.585.1">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.586.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">Let us look </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.588.1">at the generated SQL statements. </span><span class="koboSpan" id="kobo.588.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">dotnet run</span></strong><span class="koboSpan" id="kobo.590.1"> to start the application and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">api/Invoices</span></strong><span class="koboSpan" id="kobo.592.1"> API endpoint with the Swagger UI or any tool you like. </span><span class="koboSpan" id="kobo.592.2">You can see the following SQL statements in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.593.1">Debug</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.594.1"> window:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.595.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (26ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]</span></pre>
<p><span class="koboSpan" id="kobo.596.1">The logs are helpful for understanding the SQL statements generated by EF Core. </span><span class="koboSpan" id="kobo.596.2">EF Core executes the SQL query and then maps the result to the models. </span><span class="koboSpan" id="kobo.596.3">It significantly simplifies d</span><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.597.1">ata access and </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">database operations.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">Next, let us learn how to query data using LINQ </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">in controllers.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.601.1">Basic LINQ queries</span></h1>
<p><span class="koboSpan" id="kobo.602.1">This book</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.603.1"> is not intended to be a LINQ handbook. </span><span class="koboSpan" id="kobo.603.2">However, we will show you some basic LINQ queries in </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.605.1">Querying </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">the data</span></span></li>
<li><span class="koboSpan" id="kobo.607.1">Filtering </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">the data</span></span></li>
<li><span class="koboSpan" id="kobo.609.1">Sorting </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">the data</span></span></li>
<li><span class="koboSpan" id="kobo.611.1">Paging </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">the data</span></span></li>
<li><span class="koboSpan" id="kobo.613.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">the data</span></span><a id="_idTextAnchor221"/></li>
<li><span class="koboSpan" id="kobo.615.1">Updating </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">the data</span></span></li>
<li><span class="koboSpan" id="kobo.617.1">Deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the data</span></span></li>
</ul>
<h2 id="_idParaDest-114"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.619.1">Querying the data</span></h2>
<p><span class="koboSpan" id="kobo.620.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">DbSet&lt;Invoice&gt; Invoices</span></strong><span class="koboSpan" id="kobo.622.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.624.1"> class represents</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.625.1"> a collection of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">Invoice</span></strong><span class="koboSpan" id="kobo.627.1"> entity. </span><span class="koboSpan" id="kobo.627.2">We can use LINQ methods to query the data. </span><span class="koboSpan" id="kobo.627.3">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.629.1"> method to retrieve all the invoices from </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
var invoices = await _context.Invoices.ToListAsync();</span></pre> <p><span class="koboSpan" id="kobo.632.1">That is how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">GetInvoices</span></strong><span class="koboSpan" id="kobo.634.1"> action </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">method works.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">To find a specific invoice, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.638.1"> method, as shown in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">GetInvoice()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.640.1">action method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
var invoice = await _context.Invoices.FindAsync(id);</span></pre> <p><span class="koboSpan" id="kobo.642.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.644.1"> method accepts the primary key value as the parameter. </span><span class="koboSpan" id="kobo.644.2">EF Core will translate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.646.1"> method to the SQL </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">SELECT</span></strong><span class="koboSpan" id="kobo.648.1"> statement, as </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.650.1">
Executed DbCommand (15ms) [Parameters=[@__get_Item_0='?' </span><span class="koboSpan" id="kobo.650.2">(DbType = Guid)], CommandType='Text', CommandTimeout='30']      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0</span></pre>
<p><span class="koboSpan" id="kobo.651.1">We</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.652.1"> can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Single()</span></strong><span class="koboSpan" id="kobo.654.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.656.1"> methods to find a specific entity. </span><span class="koboSpan" id="kobo.656.2">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">SingleAsync()</span></strong><span class="koboSpan" id="kobo.658.1"> method to find the invoice with the </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">specified ID:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">
var invoice = await _context.Invoices.SingleAsync(i =&gt; i.Id == id);</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.661.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.662.1">You may notice that we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">SingleAsync()</span></strong><span class="koboSpan" id="kobo.664.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Single()</span></strong><span class="koboSpan" id="kobo.666.1"> in the code. </span><span class="koboSpan" id="kobo.666.2">Many methods of EF Core have both synchronous and asynchronous versions. </span><span class="koboSpan" id="kobo.666.3">The asynchronous versions are suffixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Async</span></strong><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">It is recommended to use the asynchronous versions in the controller actions because they are non-blocking and can improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">If you have LINQ experience, you may know there are other methods – such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">First()</span></strong><span class="koboSpan" id="kobo.672.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">FirstOrDefault()</span></strong><span class="koboSpan" id="kobo.674.1">, and so on – that can be used to find a specific entity. </span><span class="koboSpan" id="kobo.674.2">The differences are listed </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Find()</span></strong><span class="koboSpan" id="kobo.677.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.679.1"> is used to find an entity by the primary key value. </span><span class="koboSpan" id="kobo.679.2">If the entity is not found, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">null</span></strong><span class="koboSpan" id="kobo.681.1">. </span><span class="koboSpan" id="kobo.681.2">Note that these two methods are related to the tracking state of the entity. </span><span class="koboSpan" id="kobo.681.3">If the entity is already tracked by </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">DbContext</span></strong><span class="koboSpan" id="kobo.683.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">Find()</span></strong><span class="koboSpan" id="kobo.685.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.687.1"> methods will return the tracked entity immediately without querying the database. </span><span class="koboSpan" id="kobo.687.2">Otherwise, they will execute the SQL </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">SELECT</span></strong><span class="koboSpan" id="kobo.689.1"> statement to retrieve the entity from </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">the database.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">Single()</span></strong><span class="koboSpan" id="kobo.692.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">SingleAsync()</span></strong><span class="koboSpan" id="kobo.694.1"> can accept a predicate as the parameter. </span><span class="koboSpan" id="kobo.694.2">It returns the </span><em class="italic"><span class="koboSpan" id="kobo.695.1">single</span></em><span class="koboSpan" id="kobo.696.1"> entity that satisfies the predicate and throws an exception if the entity is not found or more than one entity satisfies the condition. </span><span class="koboSpan" id="kobo.696.2">If it is called without a predicate, it returns the only entity of the collection and throws an exception if more than one entity exists in </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">the collection.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.699.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">SingleOrDefaultAsync()</span></strong><span class="koboSpan" id="kobo.701.1"> can accept a predicate as the parameter. </span><span class="koboSpan" id="kobo.701.2">It also returns the </span><em class="italic"><span class="koboSpan" id="kobo.702.1">single</span></em><span class="koboSpan" id="kobo.703.1"> entity that satisfies the predicate and throws an exception if more than one entity satisfies the condition but returns a default value if the entity is not found. </span><span class="koboSpan" id="kobo.703.2">If it is called without a predicate, it returns a default value (or a specified default value) if the collection is empty and throws an exception if more than one entity exists in </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">the collection.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">First()</span></strong><span class="koboSpan" id="kobo.706.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">FirstAsync()</span></strong><span class="koboSpan" id="kobo.708.1"> can accept a predicate as the parameter. </span><span class="koboSpan" id="kobo.708.2">It returns the </span><em class="italic"><span class="koboSpan" id="kobo.709.1">first</span></em><span class="koboSpan" id="kobo.710.1"> entity that satisfies the predicate and throws an exception if the entity is </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.711.1">not found or the collection is null or empty. </span><span class="koboSpan" id="kobo.711.2">If it is called without a predicate, it returns the first entity of the collection and throws an exception if the collection is null </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">or empty.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">FirstOrDefault()</span></strong><span class="koboSpan" id="kobo.714.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">FirstOrDefaultAsync()</span></strong><span class="koboSpan" id="kobo.716.1"> can accept a predicate as the parameter. </span><span class="koboSpan" id="kobo.716.2">It also returns the </span><em class="italic"><span class="koboSpan" id="kobo.717.1">first</span></em><span class="koboSpan" id="kobo.718.1"> entity that satisfies the predicate. </span><span class="koboSpan" id="kobo.718.2">If the entity is not found or the collection is empty, it returns a default value (or a specified default value). </span><span class="koboSpan" id="kobo.718.3">If it is called without a predicate, it returns the first entity if the collection is not empty; otherwise, it returns a default value (or a specified default value). </span><span class="koboSpan" id="kobo.718.4">If the collection is null, it throws </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">an exception.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.720.1">These methods are kind of confusing. </span><span class="koboSpan" id="kobo.720.2">The recommended practice is </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.722.1">If you want to find an entity by the primary key value and leverage the tracking state to improve the performance, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Find()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.724.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">FindAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.727.1">If you are sure that the entity exists and only one entity satisfies the condition, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">Single()</span></strong><span class="koboSpan" id="kobo.729.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">SingleAsync()</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">If you would like to specify a default value when the entity is not found, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">SingleOrDefault()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.733.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">SingleOrDefaultAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">If you are not sure whether the entity exists, or there may be more than one entity that satisfies the condition, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">First()</span></strong><span class="koboSpan" id="kobo.738.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">FirstAsync()</span></strong><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">If you would like to specify a default value when the entity is not found, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">FirstOrDefault()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.742.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">FirstOrDefaultAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.745.1">Do not forget </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.746.1">to check whether the result is </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">null</span></strong><span class="koboSpan" id="kobo.748.1"> if you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">Find()</span></strong><span class="koboSpan" id="kobo.750.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.752.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.754.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">SingleOrDefaultAsync()</span></strong><span class="koboSpan" id="kobo.756.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">Firs</span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.758.1">tOrDefault()</span></strong><span class="koboSpan" id="kobo.759.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">FirstOrDefaultAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">.</span></span></li>
</ul>
<h2 id="_idParaDest-115"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.763.1">Filtering the data</span></h2>
<p><span class="koboSpan" id="kobo.764.1">If the table </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.765.1">contains a lot of records, we may want to filter the data based on some conditions, instead of returning all of them. </span><span class="koboSpan" id="kobo.765.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">Where()</span></strong><span class="koboSpan" id="kobo.767.1"> method to filter the invoices by status. </span><span class="koboSpan" id="kobo.767.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">GetInvoices</span></strong><span class="koboSpan" id="kobo.769.1"> action method as </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.771.1">
[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(InvoiceStatus? </span><span class="koboSpan" id="kobo.771.2">status)
{
    // Omitted for brevity
    return await _context.Invoices.Where(x =&gt; status == null || x.Status == status).ToListAsync();
}</span></pre>
<p><span class="koboSpan" id="kobo.772.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">Where()</span></strong><span class="koboSpan" id="kobo.774.1"> method accepts a lambda expression as the parameter. </span><span class="koboSpan" id="kobo.774.2">A lambda expression is a concise way to define a delegate method inline, which is widely used in LINQ queries to define filtering, sorting, and projection operations. </span><span class="koboSpan" id="kobo.774.3">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">x =&gt; status == null || x.Status == status</span></strong><span class="koboSpan" id="kobo.776.1"> lambda expression means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">Status</span></strong><span class="koboSpan" id="kobo.778.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">Invoice</span></strong><span class="koboSpan" id="kobo.780.1"> entity is equal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">status</span></strong><span class="koboSpan" id="kobo.782.1"> parameter if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">status</span></strong><span class="koboSpan" id="kobo.784.1"> parameter is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">null</span></strong><span class="koboSpan" id="kobo.786.1">. </span><span class="koboSpan" id="kobo.786.2">EF Core will translate the lambda expression to the SQL </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">WHERE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.788.1"> clause.</span></span></p>
<p><span class="koboSpan" id="kobo.789.1">Run the application and check the Swagger UI. </span><span class="koboSpan" id="kobo.789.2">You will find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">/api/Invoices</span></strong><span class="koboSpan" id="kobo.791.1"> endpoint now has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">status</span></strong><span class="koboSpan" id="kobo.793.1"> parameter. </span><span class="koboSpan" id="kobo.793.2">You can use the parameter to filter the invoices </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">by status:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.795.1"><img alt="Figure 5.2 – Filtering the invoices by status" src="image/B18971_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.796.1">Figure 5.2 – Filtering the invoices by status</span></p>
<p><span class="koboSpan" id="kobo.797.1">Send a </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.798.1">request with a status parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">/api/Invoices</span></strong><span class="koboSpan" id="kobo.800.1"> endpoint. </span><span class="koboSpan" id="kobo.800.2">You will get the invoices with the specified status. </span><span class="koboSpan" id="kobo.800.3">The SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.802.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (44ms) [Parameters=[@__status_0='?' </span><span class="koboSpan" id="kobo.802.2">(Size = 16)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Status] = @__status_0</span></pre>
<p><span class="koboSpan" id="kobo.803.1">You can</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.804.1"> see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Where()</span></strong><span class="koboSpan" id="kobo.806.1"> me</span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.807.1">thod is translated to the SQL </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">WHERE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.809.1"> clause.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.810.1">Sorting and paging</span></h2>
<p><span class="koboSpan" id="kobo.811.1">It is not </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.812.1">always enough to filter the data. </span><span class="koboSpan" id="kobo.812.2">We may also want to sort the data based on some properties and return a subset of the data using paging. </span><span class="koboSpan" id="kobo.812.3">We can use some methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">OrderBy()</span></strong><span class="koboSpan" id="kobo.814.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">OrderByDescending()</span></strong><span class="koboSpan" id="kobo.816.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">Skip()</span></strong><span class="koboSpan" id="kobo.818.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">Take()</span></strong><span class="koboSpan" id="kobo.820.1">, and so on, to sort and page the data. </span><span class="koboSpan" id="kobo.820.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">GetInvoices</span></strong><span class="koboSpan" id="kobo.822.1"> action method as</span><a id="_idIndexMarker498"/> <span class="No-Break"><span class="koboSpan" id="kobo.823.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.824.1">
[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10, InvoiceStatus? </span><span class="koboSpan" id="kobo.824.2">status = null)
{
    // Omitted for brevity
    return await _context.Invoices.AsQueryable().Where(x =&gt; status == null || x.Status == status)
                .OrderByDescending(x =&gt; x.InvoiceDate)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();
}</span></pre>
<p><span class="koboSpan" id="kobo.825.1">In the preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">AsQueryable()</span></strong><span class="koboSpan" id="kobo.827.1"> method to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">DbSet&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.829.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">IQueryable&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.831.1">. </span><span class="koboSpan" id="kobo.831.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">IQueryable</span></strong><span class="koboSpan" id="kobo.833.1"> to build a query. </span><span class="koboSpan" id="kobo.833.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">Where()</span></strong><span class="koboSpan" id="kobo.835.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">OrderByDescending()</span></strong><span class="koboSpan" id="kobo.837.1"> methods return a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">IQueryable</span></strong><span class="koboSpan" id="kobo.839.1"> object. </span><span class="koboSpan" id="kobo.839.2">So, we can chain the LINQ methods to build a new query. </span><span class="koboSpan" id="kobo.839.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">Where()</span></strong><span class="koboSpan" id="kobo.841.1"> method is used to filter the data, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">OrderByDescending()</span></strong><span class="koboSpan" id="kobo.843.1"> method is used to sort the data based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">InvoiceDate</span></strong><span class="koboSpan" id="kobo.845.1"> property in descending order, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Skip()</span></strong><span class="koboSpan" id="kobo.847.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Take()</span></strong><span class="koboSpan" id="kobo.849.1"> methods are used to page the data. </span><span class="koboSpan" id="kobo.849.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Skip()</span></strong><span class="koboSpan" id="kobo.851.1"> method skips the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">pageSize * (page - 1)</span></strong><span class="koboSpan" id="kobo.853.1"> records, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">Take()</span></strong><span class="koboSpan" id="kobo.855.1"> method returns the next </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">pageSize</span></strong><span class="koboSpan" id="kobo.857.1"> records. </span><span class="koboSpan" id="kobo.857.2">At the end of the statement, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.859.1"> method executes the query and returns </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">In fact, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">AsQueryable()</span></strong><span class="koboSpan" id="kobo.863.1"> method is not required here because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">DbSet&lt;TEntity&gt;</span></strong><span class="koboSpan" id="kobo.865.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">IQueryble&lt;TEntity&gt;</span></strong><span class="koboSpan" id="kobo.867.1"> interface, which means the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">DbSet&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.869.1"> property is already an </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">IQueryable</span></strong><span class="koboSpan" id="kobo.871.1"> object. </span><span class="koboSpan" id="kobo.871.2">We can chain</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.872.1"> the </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.873.1">LINQ </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">methods directly.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.875.1">What is IQueryable?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.876.1">When we </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.877.1">use some LINQ methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">Where()</span></strong><span class="koboSpan" id="kobo.879.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">OrderBy()</span></strong><span class="koboSpan" id="kobo.881.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">Skip()</span></strong><span class="koboSpan" id="kobo.883.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">Take()</span></strong><span class="koboSpan" id="kobo.885.1">, EF Core will not execute the query immediately. </span><span class="koboSpan" id="kobo.885.2">It will build a query and return a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">IQueryable</span></strong><span class="koboSpan" id="kobo.887.1"> object. </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">IQueryable</span></strong><span class="koboSpan" id="kobo.889.1"> is an interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">System.Linq</span></strong><span class="koboSpan" id="kobo.891.1"> namespace that represents a queryable collection of entities that can be used to compose a query against a specific data source, such as a database. </span><span class="koboSpan" id="kobo.891.2">It allows us to build complex queries by chaining the LINQ methods, but it postpones the query execution until the very last moment when the result is needed. </span><span class="koboSpan" id="kobo.891.3">Generally, when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.893.1"> method, the query will be translated to a server-specific query language, such as SQL, and executed against the database. </span><span class="koboSpan" id="kobo.893.2">This can improve the performance of the application because we do not need to fetch all the data from the database before we can filter and sort </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.895.1">Run the application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">dotnet run</span></strong><span class="koboSpan" id="kobo.897.1"> and check the Swagger UI, you will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">page</span></strong><span class="koboSpan" id="kobo.899.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">pageSize</span></strong><span class="koboSpan" id="kobo.901.1"> parameters are added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">/api/Invoices</span></strong><span class="koboSpan" id="kobo.903.1"> endpoint. </span><span class="koboSpan" id="kobo.903.2">You can use the parameters to page the invoices </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.905.1"><img alt="Figure 5.3 – Sorting and paging the invoices" src="image/B18971_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.906.1">Figure 5.3 – Sorting and paging the invoices</span></p>
<p><span class="koboSpan" id="kobo.907.1">The </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.908.1">generated </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.909.1">SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.911.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (40ms) [Parameters=[@__status_0='?' </span><span class="koboSpan" id="kobo.911.2">(Size = 16) (DbType = AnsiString), @__p_1='?' </span><span class="koboSpan" id="kobo.911.3">(DbType = Int32), @__p_2='?' </span><span class="koboSpan" id="kobo.911.4">(DbType = Int32)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Status] = @__status_0
      ORDER BY [i].[InvoiceDate] DESC
      OFFSET @__p_1 ROWS FETCH NEXT @__p_2 ROWS ONLY</span></pre>
<p><span class="koboSpan" id="kobo.912.1">Note that </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.913.1">the SQL statement uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">OFFSET/FETCH</span></strong><span class="koboSpan" id="kobo.915.1"> clause to </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.916.1">page the data. </span><span class="koboSpan" id="kobo.916.2">These keywords are supported by SQL Server but may not be supported by other databases. </span><span class="koboSpan" id="kobo.916.3">For example, MySQL uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">LIMIT</span></strong><span class="koboSpan" id="kobo.918.1"> clause to page the data. </span><span class="koboSpan" id="kobo.918.2">EF Core can eliminate the differences between different databases. </span><span class="koboSpan" id="kobo.918.3">It will translate the LINQ query to the correct SQL statement for the database. </span><span class="koboSpan" id="kobo.918.4">In this way, developers can focus on writing the LINQ query in a dat</span><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.919.1">abase-agnostic way. </span><span class="koboSpan" id="kobo.919.2">That is the beauty of </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">EF Core.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.921.1">Creating an entity</span></h2>
<p><span class="koboSpan" id="kobo.922.1">Next, let’s see</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.923.1"> how to create a new invoice. </span><span class="koboSpan" id="kobo.923.2">Check the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">PostInvoice</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.925.1">action method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.926.1">
[HttpPost]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; PostInvoice(Invoice invoice)
{
    if (_context.Invoices == null)
    {
        return Problem("Entity set 'InvoiceDbContext.Invoices'  is null.");
    }
    _context.Invoices.Add(invoice);
    await _context.SaveChangesAsync();
    return CreatedAtAction("GetInvoice", new { id = invoice.Id }, invoice);</span></pre>
<p><span class="koboSpan" id="kobo.927.1">}The </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">PostInvoice</span></strong><span class="koboSpan" id="kobo.929.1"> action method accepts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">Invoice</span></strong><span class="koboSpan" id="kobo.931.1"> object as the request body. </span><span class="koboSpan" id="kobo.931.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">Add()</span></strong><span class="koboSpan" id="kobo.933.1"> method to add the invoice to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">Invoices</span></strong><span class="koboSpan" id="kobo.935.1"> entity set. </span><span class="koboSpan" id="kobo.935.2">Note that this change occurs in the memory. </span><span class="koboSpan" id="kobo.935.3">The data will not be added to the database until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.937.1"> method is called to save the changes to the database. </span><span class="koboSpan" id="kobo.937.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">CreatedAtAction()</span></strong><span class="koboSpan" id="kobo.939.1"> method returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">201 Created</span></strong><span class="koboSpan" id="kobo.941.1"> response with the location of the newly created invoice. </span><span class="koboSpan" id="kobo.941.2">You can return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">200 OK</span></strong><span class="koboSpan" id="kobo.943.1"> response instead but it is recommended to return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">201 Created</span></strong><span class="koboSpan" id="kobo.945.1"> response for the creation of a </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">new resource.</span></span></p>
<p><span class="koboSpan" id="kobo.947.1">You can</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.948.1"> send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">POST</span></strong><span class="koboSpan" id="kobo.950.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">/api/invoices</span></strong><span class="koboSpan" id="kobo.952.1"> endpoint to create a new invoice and see how the SQL statement is generated from the logs. </span><span class="koboSpan" id="kobo.952.2">It should be similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.954.1">
 info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (3ms) [Parameters=[@p0='?' </span><span class="koboSpan" id="kobo.954.2">(DbType = Guid), @p1='?' </span><span class="koboSpan" id="kobo.954.3">(Precision = 18) (Scale = 2) (DbType = Decimal), @p2='?' </span><span class="koboSpan" id="kobo.954.4">(Size = 32), @p3='?' </span><span class="koboSpan" id="kobo.954.5">(Size = 256), @p4='?' </span><span class="koboSpan" id="kobo.954.6">(DbType = DateTimeOffset), @p5='?' </span><span class="koboSpan" id="kobo.954.7">(DbType = DateTimeOffset), @p6='?' </span><span class="koboSpan" id="kobo.954.8">(Size = 32) (DbType = AnsiString), @p7='?' </span><span class="koboSpan" id="kobo.954.9">(Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      INSERT INTO [Invoices] ([Id], [Amount], [ContactName], [Description], [DueDate], [InvoiceDate], [InvoiceNumber], [Status])
      VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6, @p7);</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.955.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.956.1">The JSON body for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">POST</span></strong><span class="koboSpan" id="kobo.958.1"> action does not need to contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">Id</span></strong><span class="koboSpan" id="kobo.960.1"> property. </span><span class="koboSpan" id="kobo.960.2">EF Core</span><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.961.1"> will generate a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">Guid</span></strong><span class="koboSpan" id="kobo.963.1"> value for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.965.1"> property.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.966.1">Updating an entity</span></h2>
<p><span class="koboSpan" id="kobo.967.1">To update</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.968.1"> an entity, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">Put</span></strong><span class="koboSpan" id="kobo.970.1"> request. </span><span class="koboSpan" id="kobo.970.2">The code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.972.1"> action method is </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.974.1">
[HttpPut("{id}")]public async Task&lt;IActionResult&gt; PutInvoice(Guid id, Invoice invoice)
{
    if (id != invoice.Id)
    {
        return BadRequest();
    }
    _context.Entry(invoice).State = EntityState.Modified;
    try
    {
        await _context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        if (!InvoiceExists(id))
        {
            return NotFound();
        }
        else
        {
            throw;
        }
    }
    return NoContent();
}</span></pre>
<p><span class="koboSpan" id="kobo.975.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.977.1"> action method accepts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">id</span></strong><span class="koboSpan" id="kobo.979.1"> parameter and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">Invoice</span></strong><span class="koboSpan" id="kobo.981.1"> object as the request body. </span><span class="koboSpan" id="kobo.981.2">If you check the Swagger UI, you will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">id</span></strong><span class="koboSpan" id="kobo.983.1"> parameter is defined in the URL but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">Invoice</span></strong><span class="koboSpan" id="kobo.985.1"> object is defined in the request body. </span><span class="koboSpan" id="kobo.985.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">Invoice</span></strong><span class="koboSpan" id="kobo.987.1"> is not a primitive type, so ASP.NET Core can only get it from the request body. </span><span class="koboSpan" id="kobo.987.2">We discussed this in the </span><em class="italic"><span class="koboSpan" id="kobo.988.1">Binding source attributes</span></em><span class="koboSpan" id="kobo.989.1"> section in </span><a href="B18971_03.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.990.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.991.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">Next, we </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.993.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">_context.Entry()</span></strong><span class="koboSpan" id="kobo.995.1"> method to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">EntityEntry</span></strong><span class="koboSpan" id="kobo.997.1"> object of the invoice. </span><span class="koboSpan" id="kobo.997.2">Then, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">State</span></strong><span class="koboSpan" id="kobo.999.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">EntityState.Modified</span></strong><span class="koboSpan" id="kobo.1001.1">. </span><span class="koboSpan" id="kobo.1001.2">It seems that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">EntityState</span></strong><span class="koboSpan" id="kobo.1003.1"> enum plays an important role here. </span><span class="koboSpan" id="kobo.1003.2">What is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">EntityState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1"> enum?</span></span></p>
<p><span class="koboSpan" id="kobo.1006.1">In EF Core, each instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">DbContext</span></strong><span class="koboSpan" id="kobo.1008.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">ChangeTracker</span></strong><span class="koboSpan" id="kobo.1010.1"> to track the changes in the entities, which is a powerful feature of EF Core. </span><span class="koboSpan" id="kobo.1010.2">In other words, EF Core knows the state of each entity – whether it is added, deleted, or modified. </span><span class="koboSpan" id="kobo.1010.3">When we update the entity, we just update the entity in the memory. </span><span class="koboSpan" id="kobo.1010.4">EF Core can track the changes. </span><span class="koboSpan" id="kobo.1010.5">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1012.1"> method is called, it will generate the SQL statement to update the data in </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1014.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">EntityState</span></strong><span class="koboSpan" id="kobo.1016.1"> enum can have the </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">following values:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">Detached</span></strong><span class="koboSpan" id="kobo.1019.1">: The entity is not being tracked by </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">the context.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">Unchanged</span></strong><span class="koboSpan" id="kobo.1022.1">: The entity is being tracked by the context, but the values are </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">not changed.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">Deleted</span></strong><span class="koboSpan" id="kobo.1025.1">: The entity is being tracked and exists in the database, but it has been marked for deletion. </span><span class="koboSpan" id="kobo.1025.2">So, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1027.1"> method is called, EF Core will generate the SQL statement to delete the entity from </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">the database.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">Modified</span></strong><span class="koboSpan" id="kobo.1030.1">: The entity is being tracked and exists in the database, and the values have been modified in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">DbContext</span></strong><span class="koboSpan" id="kobo.1032.1">. </span><span class="koboSpan" id="kobo.1032.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1034.1"> method is called, EF Core will generate the SQL statement to update the entity in </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">the database.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">Added</span></strong><span class="koboSpan" id="kobo.1037.1">: The entity is being tracked but it does not exist in the database. </span><span class="koboSpan" id="kobo.1037.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1039.1"> method is called, EF Core will generate the SQL statement to insert the entity into </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1041.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.1042.1">Creating an entity</span></em><span class="koboSpan" id="kobo.1043.1"> section, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">Add()</span></strong><span class="koboSpan" id="kobo.1045.1"> method to add the entity to the entity set. </span><span class="koboSpan" id="kobo.1045.2">This is equivalent to setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">State</span></strong><span class="koboSpan" id="kobo.1047.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">Added</span></strong><span class="koboSpan" id="kobo.1049.1">, such as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
//_context.Invoices.Add(invoice); This is equivalent to the following code_context.Entry(invoice).State = EntityState.Added;
await _context.SaveChangesAsync();</span></pre>
<p><span class="koboSpan" id="kobo.1052.1">Similar to</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.1053.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">Add()</span></strong><span class="koboSpan" id="kobo.1055.1"> method, changing the state of the entity does not modify the data in the database. </span><span class="koboSpan" id="kobo.1055.2">You must call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1057.1"> method to save the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1059.1">Let's try to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.1061.1"> action method to update an invoice. </span><span class="koboSpan" id="kobo.1061.2">Send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">PUT</span></strong><span class="koboSpan" id="kobo.1063.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">/api/invoices/{id}</span></strong><span class="koboSpan" id="kobo.1065.1"> endpoint in the Swagger UI. </span><span class="koboSpan" id="kobo.1065.2">The request body is </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
{  "id": "0d501380-83d9-44f4-9087-27c8f09082f9",
  "invoiceNumber": "INV-001",
  "contactName": "Spider Man",
  "description": "Invoice for the first month",
  "amount": 100,
  "invoiceDate": "2023-01-01T00:00:00+00:00",
  "dueDate": "2023-01-15T00:00:00+00:00",
  "status": 1
}</span></pre>
<p><span class="koboSpan" id="kobo.1068.1">Please update the JSON body to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">contactName</span></strong><span class="koboSpan" id="kobo.1070.1"> property only. </span><span class="koboSpan" id="kobo.1070.2">The SQL statement generated by EF Core is </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1072.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (39ms) [Parameters=[@p7='?' </span><span class="koboSpan" id="kobo.1072.2">(DbType = Guid), @p0='?' </span><span class="koboSpan" id="kobo.1072.3">(Precision = 18) (Scale = 2) (DbType = Decimal), @p1='?' </span><span class="koboSpan" id="kobo.1072.4">(Size = 32), @p2='?' </span><span class="koboSpan" id="kobo.1072.5">(Size = 4000), @p3='?' </span><span class="koboSpan" id="kobo.1072.6">(DbType = DateTimeOffset), @p4='?' </span><span class="koboSpan" id="kobo.1072.7">(DbType = DateTimeOffset), @p5='?' </span><span class="koboSpan" id="kobo.1072.8">(Size = 32) (DbType = AnsiString), @p6='?' </span><span class="koboSpan" id="kobo.1072.9">(Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Invoices] SET [Amount] = @p0, [ContactName] = @p1, [Description] = @p2, [DueDate] = @p3, [InvoiceDate] = @p4, [InvoiceNumber] = @p5, [Status] = @p6
      OUTPUT 1
      WHERE [Id] = @p7;</span></pre>
<p><span class="koboSpan" id="kobo.1073.1">You can see EF Core omits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">Id</span></strong><span class="koboSpan" id="kobo.1075.1"> column in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">UPDATE</span></strong><span class="koboSpan" id="kobo.1077.1"> statement. </span><span class="koboSpan" id="kobo.1077.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">Id</span></strong><span class="koboSpan" id="kobo.1079.1"> column is the primary key of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">Invoices</span></strong><span class="koboSpan" id="kobo.1081.1"> table. </span><span class="koboSpan" id="kobo.1081.2">EF Core knows that it does not need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">Id</span></strong><span class="koboSpan" id="kobo.1083.1"> column. </span><span class="koboSpan" id="kobo.1083.2">But EF Core will update the other properties irrespective of whether the values are changed or not because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">EntityState</span></strong><span class="koboSpan" id="kobo.1085.1"> of the entity </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">Modified</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1089.1">Sometimes </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.1090.1">we want to update only the changed properties. </span><span class="koboSpan" id="kobo.1090.2">For example, if we just want to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">Status</span></strong><span class="koboSpan" id="kobo.1092.1"> property, the SQL statement should not have to update other columns. </span><span class="koboSpan" id="kobo.1092.2">To do this, we can find the entity that needs to be updated, and then update the properties explicitly. </span><span class="koboSpan" id="kobo.1092.3">Let us update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.1094.1"> action method to </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1096.1">
var invoiceToUpdate = await _context.Invoices.FindAsync(id);if (invoiceToUpdate == null)
{
    return NotFound();
}
invoiceToUpdate.Status = invoice.Status;
await _context.SaveChangesAsync();</span></pre>
<p><span class="koboSpan" id="kobo.1097.1">In this example, we first find the entity by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.1099.1"> method. </span><span class="koboSpan" id="kobo.1099.2">Then, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">Status</span></strong><span class="koboSpan" id="kobo.1101.1"> property. </span><span class="koboSpan" id="kobo.1101.2">EF Core will mark the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">Status</span></strong><span class="koboSpan" id="kobo.1103.1"> property as modified. </span><span class="koboSpan" id="kobo.1103.2">Finally, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1105.1"> method to save the changes to the database. </span><span class="koboSpan" id="kobo.1105.2">You can see the generated SQL statement only updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">Status</span></strong><span class="koboSpan" id="kobo.1107.1"> property, which </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.1108.1">is </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1110.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__get_Item_0='?' </span><span class="koboSpan" id="kobo.1110.2">(DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (2ms) [Parameters=[@p1='?' </span><span class="koboSpan" id="kobo.1110.3">(DbType = Guid), @p0='?' </span><span class="koboSpan" id="kobo.1110.4">(Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Invoices] SET [Status] = @p0
      OUTPUT 1
      WHERE [Id] = @p1;</span></pre>
<p><span class="koboSpan" id="kobo.1111.1">However, in an actual scenario, normally, the endpoint will receive the whole entity, not just the changed properties. </span><span class="koboSpan" id="kobo.1111.2">We may not know which properties are changed. </span><span class="koboSpan" id="kobo.1111.3">In this case, we can just update all the properties in the code. </span><span class="koboSpan" id="kobo.1111.4">EF Core can track the state of the entity, so it is smart enough to determine which properties are changed. </span><span class="koboSpan" id="kobo.1111.5">Let us update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.1113.1"> action method to explicitly update all </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">the properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1115.1">
// Omitted for brevityvar invoiceToUpdate = await _context.Invoices.FindAsync(id);
if (invoiceToUpdate == null)
{
    return NotFound();
}
invoiceToUpdate.InvoiceNumber = invoice.InvoiceNumber;
invoiceToUpdate.ContactName = invoice.ContactName;
invoiceToUpdate.Description = invoice.Description;
invoiceToUpdate.Amount = invoice.Amount;
invoiceToUpdate.InvoiceDate = invoice.InvoiceDate;
invoiceToUpdate.DueDate = invoice.DueDate;
invoiceToUpdate.Status = invoice.Status;
await _context.SaveChangesAsync();
// Omitted for brevity</span></pre>
<p><span class="koboSpan" id="kobo.1116.1">Send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">PUT</span></strong><span class="koboSpan" id="kobo.1118.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">/api/Invoices/{id}</span></strong><span class="koboSpan" id="kobo.1120.1"> endpoint and attach a JSON body to the </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.1121.1">request. </span><span class="koboSpan" id="kobo.1121.2">If you just update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">Status</span></strong><span class="koboSpan" id="kobo.1123.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">Description</span></strong><span class="koboSpan" id="kobo.1125.1"> properties, the SQL statement will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1127.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (17ms) [Parameters=[@p2='?' </span><span class="koboSpan" id="kobo.1127.2">(DbType = Guid), @p0='?' </span><span class="koboSpan" id="kobo.1127.3">(Size = 256), @p1='?' </span><span class="koboSpan" id="kobo.1127.4">(Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Invoices] SET [Description] = @p0, [Status] = @p1
      OUTPUT 1
      WHERE [Id] = @p2;</span></pre>
<p><span class="koboSpan" id="kobo.1128.1">The preceding SQL statement slightly improves the performance because it only updates the changed properties. </span><span class="koboSpan" id="kobo.1128.2">It might not be a big deal for a small table, but if you have a large table that has many columns, it will be a good practice. </span><span class="koboSpan" id="kobo.1128.3">However, it needs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">SELECT</span></strong><span class="koboSpan" id="kobo.1130.1"> statement to get the entity first. </span><span class="koboSpan" id="kobo.1130.2">Choose the way that suits </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">your scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.1132.1">There is an issue in</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.1133.1"> the preceding code. </span><span class="koboSpan" id="kobo.1133.2">If the entity has many properties, it will be tedious to update all the properties one by one. </span><span class="koboSpan" id="kobo.1133.3">In this case, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">Entry</span></strong><span class="koboSpan" id="kobo.1135.1"> method to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">EntityEntry</span></strong><span class="koboSpan" id="kobo.1137.1"> object and then set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">CurrentValues</span></strong><span class="koboSpan" id="kobo.1139.1"> property to the new values. </span><span class="koboSpan" id="kobo.1139.2">Let us update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.1141.1"> action method to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">Entry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1144.1">
// Update only the properties that have changed _context.Entry(invoiceToUpdate).CurrentValues.SetValues(invoice);</span></pre> <p><span class="koboSpan" id="kobo.1145.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">SetValues()</span></strong><span class="koboSpan" id="kobo.1147.1"> method will set all the properties of the entity to the new values. </span><span class="koboSpan" id="kobo.1147.2">EF Core can detect the changes and mark the properties that have changed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">Modified</span></strong><span class="koboSpan" id="kobo.1149.1">. </span><span class="koboSpan" id="kobo.1149.2">So, we do not need to manually set each property. </span><span class="koboSpan" id="kobo.1149.3">This way is a good practice when updating an entity that has many properties. </span><span class="koboSpan" id="kobo.1149.4">Also, the object used to update the properties does not have to be the same type as the entity. </span><span class="koboSpan" id="kobo.1149.5">It is useful in a layered application. </span><span class="koboSpan" id="kobo.1149.6">For example, the entity received from the client is a </span><strong class="bold"><span class="koboSpan" id="kobo.1150.1">Data Transfer Object</span></strong><span class="koboSpan" id="kobo.1151.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1152.1">DTO</span></strong><span class="koboSpan" id="kobo.1153.1">) object, and </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.1154.1">the entity in the database is a domain object. </span><span class="koboSpan" id="kobo.1154.2">In this case, EF Core will update the properties that match the names of the properties in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">DTO object.</span></span></p>
<p><span class="koboSpan" id="kobo.1156.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">SetValues()</span></strong><span class="koboSpan" id="kobo.1158.1"> method only updates the simple properties, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">string</span></strong><span class="koboSpan" id="kobo.1160.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">int</span></strong><span class="koboSpan" id="kobo.1162.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">decimal</span></strong><span class="koboSpan" id="kobo.1164.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">DateTime</span></strong><span class="koboSpan" id="kobo.1166.1">, and so on. </span><span class="koboSpan" id="kobo.1166.2">If the entity has a navigation property, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">SetValues()</span></strong><span class="koboSpan" id="kobo.1168.1"> method will not update the navigation property. </span><span class="koboSpan" id="kobo.1168.2">In this case, we need to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">properties explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.1170.1">Test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">/api/Invoices/{id}</span></strong><span class="koboSpan" id="kobo.1172.1"> endpoint by sending a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">PUT</span></strong><span class="koboSpan" id="kobo.1174.1"> request again. </span><span class="koboSpan" id="kobo.1174.2">You can see</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.1175.1"> the generated SQL statement is similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">previous one.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.1177.1">Deleting an entity</span></h2>
<p><span class="koboSpan" id="kobo.1178.1">In the </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.1179.1">generated code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">DeleteInvoice</span></strong><span class="koboSpan" id="kobo.1181.1"> action method, we can see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1183.1">
[HttpDelete("{id}")]public async Task&lt;IActionResult&gt; DeleteInvoice(Guid id)
{
    if (_context.Invoices == null)
    {
        return NotFound();
    }
    var invoice = await _context.Invoices.FindAsync(id);
    if (invoice == null)
    {
        return NotFound();
    }
    _context.Invoices.Remove(invoice);
    await _context.SaveChangesAsync();
    return NoContent();
}</span></pre>
<p><span class="koboSpan" id="kobo.1184.1">The logic is to</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.1185.1"> find the entity first, and then remove it from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">DbSet</span></strong><span class="koboSpan" id="kobo.1187.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">Remove()</span></strong><span class="koboSpan" id="kobo.1189.1"> method. </span><span class="koboSpan" id="kobo.1189.2">Finally, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1191.1"> method to save the changes to the database. </span><span class="koboSpan" id="kobo.1191.2">If you understand </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">EntityState</span></strong><span class="koboSpan" id="kobo.1193.1"> already, you might know that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">Remove()</span></strong><span class="koboSpan" id="kobo.1195.1"> method is equivalent to setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">EntityState</span></strong><span class="koboSpan" id="kobo.1197.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">Deleted</span></strong><span class="koboSpan" id="kobo.1199.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1201.1">
_context.Entry(invoice).State = EntityState.Deleted;</span></pre> <p><span class="koboSpan" id="kobo.1202.1">The generated SQL statement is </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1204.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__get_Item_0='?' </span><span class="koboSpan" id="kobo.1204.2">(DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (3ms) [Parameters=[@p0='?' </span><span class="koboSpan" id="kobo.1204.3">(DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      DELETE FROM [Invoices]
      OUTPUT 1
      WHERE [Id] = @p0;</span></pre>
<p><span class="koboSpan" id="kobo.1205.1">As you can see, EF Core </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.1206.1">generates two SQL statements, which seems a little bit unnecessary to find the entity first. </span><span class="koboSpan" id="kobo.1206.2">When we delete an entity, the only thing we need is the primary key. </span><span class="koboSpan" id="kobo.1206.3">So, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">DeleteInvoice()</span></strong><span class="koboSpan" id="kobo.1208.1"> action </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1210.1">
// Omitted for brevityvar invoice = new Invoice { Id = id };
_context.Invoices.Remove(invoice);
await _context.SaveChangesAsync();
// Omitted for brevity</span></pre>
<p><span class="koboSpan" id="kobo.1211.1">Now, the SQL statement is </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1213.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@p0='?' </span><span class="koboSpan" id="kobo.1213.2">(DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      DELETE FROM [Invoices]
      OUTPUT 1
      WHERE [Id] = @p0;</span></pre>
<p><span class="koboSpan" id="kobo.1214.1">It is much simpler than the </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">previous one.</span></span></p>
<p><span class="koboSpan" id="kobo.1216.1">From EF Core 7.0, we</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.1217.1"> have a new method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">ExecuteDeleteAsync()</span></strong><span class="koboSpan" id="kobo.1219.1"> that can be used to delete an entity without loading it first. </span><span class="koboSpan" id="kobo.1219.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1221.1">
await _context.Invoices.Where(x =&gt; x.Id == id).ExecuteDeleteAsync();</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.1222.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1223.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">ExecuteDeleteAsync()</span></strong><span class="koboSpan" id="kobo.1225.1"> method does not involve the change tracker, so it will execute the SQL statement immediately to the database. </span><span class="koboSpan" id="kobo.1225.2">It does not need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">SaveChangesAsync()</span></strong><span class="koboSpan" id="kobo.1227.1"> method at the end. </span><span class="koboSpan" id="kobo.1227.2">It is a recommended way to delete one entity (or more) from EF Core 7.0 and later versions. </span><span class="koboSpan" id="kobo.1227.3">However, if the entity already exists in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">DbContext</span></strong><span class="koboSpan" id="kobo.1229.1"> and is tracked by the change tracker, executing the SQL statement directly may cause the data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">DbContext</span></strong><span class="koboSpan" id="kobo.1231.1"> and the database to be inconsistent. </span><span class="koboSpan" id="kobo.1231.2">In this case, you may need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">Remove()</span></strong><span class="koboSpan" id="kobo.1233.1"> method or set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">EntityState</span></strong><span class="koboSpan" id="kobo.1235.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">Deleted</span></strong><span class="koboSpan" id="kobo.1237.1"> to delete the entity from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">DbContext</span></strong><span class="koboSpan" id="kobo.1239.1">. </span><span class="koboSpan" id="kobo.1239.2">Please consider your scenario carefully before using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">ExecuteDeleteAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1241.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1242.1">You must be wondering how EF Core knows the names of columns and tables in the database. </span><span class="koboSpan" id="kobo.1242.2">We will talk about the configu</span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.1243.1">ration and see how EF Core maps the models to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">database next.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.1245.1">Configuring the mapping between models and database</span></h1>
<p><span class="koboSpan" id="kobo.1246.1">ORM, as </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.1247.1">the name suggests, is used to map the objects to the relational database. </span><span class="koboSpan" id="kobo.1247.2">EF Core uses the mapping configuration to map the models to the database. </span><span class="koboSpan" id="kobo.1247.3">In the previous section, we saw that we did not configure any mappings; however, EF Core could still map the models to the database automatically. </span><span class="koboSpan" id="kobo.1247.4">This is because EF Core has a set of built-in conventions to configure the mappings. </span><span class="koboSpan" id="kobo.1247.5">We can also explicitly customize the configuration to meet our needs. </span><span class="koboSpan" id="kobo.1247.6">In this section, we will discuss the configuration in EF Core, includi</span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.1248.1">ng </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">Mapping conventions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">Data annotations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">Fluent API</span></span></li>
</ul>
<h2 id="_idParaDest-121"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.1253.1">Mapping conventions</span></h2>
<p><span class="koboSpan" id="kobo.1254.1">There are </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.1255.1">some conventions in EF Core for mapping the models to </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">the database:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1257.1">The database uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">dbo</span></strong><span class="koboSpan" id="kobo.1259.1"> schema </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">by default.</span></span></li>
<li><span class="koboSpan" id="kobo.1261.1">The table name is the plural form of the model name. </span><span class="koboSpan" id="kobo.1261.2">For example, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">DbSet&lt;Invoice&gt; Invoices</span></strong><span class="koboSpan" id="kobo.1263.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.1265.1"> class, so the table name </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">Invoices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1269.1">The column name is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">property name.</span></span></li>
<li><span class="koboSpan" id="kobo.1271.1">The data type of the column is based on the property type and the database providers. </span><span class="koboSpan" id="kobo.1271.2">Here is a list of the default mapping for some common C# types in </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">SQL Server:</span></span></li>
</ul>
<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.1273.1">.</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1274.1">NET type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.1275.1">SQL Server </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1276.1">data type</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">int</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">int</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">long</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">bigint</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">string</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">nvarchar(max)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">bool</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">bit</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">datetime</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">datetime</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">double</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">float</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">decimal</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">decimal(18,2)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">byte</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">tinyint</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">short</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">smallint</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">byte[]</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">varbinary(max)</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1297.1">Table 5.1 – Default mapping for some common C# types in SQL Server</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1298.1">If a property is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">Id</span></strong><span class="koboSpan" id="kobo.1300.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">&lt;entity name&gt;Id</span></strong><span class="koboSpan" id="kobo.1302.1">, EF Core will map it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">primary key.</span></span></li>
<li><span class="koboSpan" id="kobo.1304.1">If EF Core detects that the relationship between two models is one-to-many, it will map the navigation property to a foreign key column in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">database automatically.</span></span></li>
<li><span class="koboSpan" id="kobo.1306.1">If a</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.1307.1"> column is a primary key, EF Core will create a clustered index for </span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1">it automatically.</span></span></li>
<li><span class="koboSpan" id="kobo.1309.1">If a column is a foreign key, EF Core will create a non-clustered index for </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">it automatically.</span></span></li>
<li><span class="koboSpan" id="kobo.1311.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">enum</span></strong><span class="koboSpan" id="kobo.1313.1"> type is mapped to the underlying type of the enum. </span><span class="koboSpan" id="kobo.1313.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">InvoiceStatus</span></strong><span class="koboSpan" id="kobo.1315.1"> enum is mapped to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">int</span></strong><span class="koboSpan" id="kobo.1317.1"> type in </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1319.1">However, sometimes we need to refine the mapping. </span><span class="koboSpan" id="kobo.1319.2">For example, we may want to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">varchar(100)</span></strong><span class="koboSpan" id="kobo.1321.1"> column instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">nvarchar(max)</span></strong><span class="koboSpan" id="kobo.1323.1"> column for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">string</span></strong><span class="koboSpan" id="kobo.1325.1"> property. </span><span class="koboSpan" id="kobo.1325.2">We may also want to save enums as strings in the database instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">int</span></strong><span class="koboSpan" id="kobo.1327.1"> values. </span><span class="koboSpan" id="kobo.1327.2">In such cases, we</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.1328.1"> can override the default conventions to customize the mapping based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">our needs.</span></span></p>
<p><span class="koboSpan" id="kobo.1330.1">There are two ways to explicitly configure the mapping between the models and </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">the database:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">Data annotations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1333.1">Fluent API</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1334.1">Let us see how to use data annotations and Fluent API to customize </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">the mapping</span><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.1336.1">.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.1337.1">Data annotations</span></h2>
<p><span class="koboSpan" id="kobo.1338.1">Data annotations </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.1339.1">are attributes that you can apply to the model classes to customize the mapping. </span><span class="koboSpan" id="kobo.1339.2">For example, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">Table</span></strong><span class="koboSpan" id="kobo.1341.1"> attribute to specify the table name and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">Column</span></strong><span class="koboSpan" id="kobo.1343.1"> attribute to specify the column name. </span><span class="koboSpan" id="kobo.1343.2">The following code shows how to use data annotations to customize </span><span class="No-Break"><span class="koboSpan" id="kobo.1344.1">the mapping:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1345.1">
[Table("Invoices")]public class Invoice
{
    [Column("Id")]
    [Key]
    public Guid Id { get; set; }
    [Column(name: "InvoiceNumber", TypeName = "varchar(32)")]
    [Required]
    public string InvoiceNumber { get; set; } = string.Empty;
    [Column(name: "ContactName")]
    [Required]
    [MaxLength(32)]
    public string ContactName { get; set; } = string.Empty;
    [Column(name: "Description")]
    [MaxLength(256)]
    public string? </span><span class="koboSpan" id="kobo.1345.2">Description { get; set; }
    [Column("Amount")]
    [Precision(18, 2)]
    [Range(0, 9999999999999999.99)]
    public decimal Amount { get; set; }
    [Column(name: "InvoiceDate", TypeName = "datetimeoffset")]
    public DateTimeOffset InvoiceDate { get; set; }
    [Column(name: "DueDate", TypeName = "datetimeoffset")]
    public DateTimeOffset DueDate { get; set; }
    [Column(name: "Status", TypeName = "varchar(16)")]
    public InvoiceStatus Status { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1346.1">In the </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.1347.1">preceding code, each property has one or more data annotations. </span><span class="koboSpan" id="kobo.1347.2">These data annotations are attributes that you can apply to the model classes to customize the mapping. </span><span class="koboSpan" id="kobo.1347.3">You can specify some mapping information, such as the table name, column name, column data type, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1349.1">Here is a list of the most </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.1350.1">commonly used </span><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">data annotations:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1352.1">Attribute</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1353.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">Table</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1355.1">The table name that the model class is </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">mapped to.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">Column</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1358.1">The column name in the table that a property is mapped to. </span><span class="koboSpan" id="kobo.1358.2">You can also specify the column data type using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">TypeName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1"> property.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">Key</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1362.1">Specifies the property as </span><span class="No-Break"><span class="koboSpan" id="kobo.1363.1">a key.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">ForeignKey</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1365.1">Specifies the property as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">foreign key.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">NotMapped</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1368.1">The model or property is not mapped to </span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">the database.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">Required</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1371.1">The value of the property </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">is required.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">MaxLength</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1374.1">Specifies the maximum length of the value in the database. </span><span class="koboSpan" id="kobo.1374.2">Applied to string or array </span><span class="No-Break"><span class="koboSpan" id="kobo.1375.1">values only.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">Index</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1377.1">Creates an index on the column that the property is </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">mapped to.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">Precision</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1380.1">Specifies the precision and scale of the property if the database supports precision and </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">scale facets.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">DatabaseGenerated</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1383.1">Specifies how the database should generate the values for the property. </span><span class="koboSpan" id="kobo.1383.2">If you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">int</span></strong><span class="koboSpan" id="kobo.1385.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">long</span></strong><span class="koboSpan" id="kobo.1387.1"> as the primary key for an entity, you can use this attribute and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">DatabaseGeneratedOption</span></strong><span class="koboSpan" id="kobo.1389.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">Identity</span></strong><span class="koboSpan" id="kobo.1391.1">, such </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">[DatabaseGenerated(DatabaseGeneratedOption.Identity)]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1394.1">.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">TimeStamp</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1396.1">Specifies the property is used for concurrency management. </span><span class="koboSpan" id="kobo.1396.2">The property will map to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">rowversion</span></strong><span class="koboSpan" id="kobo.1398.1"> type in SQL Server. </span><span class="koboSpan" id="kobo.1398.2">The implementation may vary in different </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">database providers.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1400.1">Table 5.2 – Commonly used data annotations</span></p>
<p><span class="koboSpan" id="kobo.1401.1">In this way, the</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.1402.1"> mapping configuration is embedded in the model classes. </span><span class="koboSpan" id="kobo.1402.2">It is easy to understand, but it is a little bit intrusive, which means the model classes are polluted with the database-related configuration. </span><span class="koboSpan" id="kobo.1402.3">To decouple the model classes from the database mapping configuration, we can use </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">Fluent API.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1404.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1405.1">Every time the mapping is changed, you need to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">dotnet ef migrations add &lt;migration name&gt;</span></strong><span class="koboSpan" id="kobo.1407.1"> command to generate a new migration. </span><span class="koboSpan" id="kobo.1407.2">Then, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">dotnet ef database update</span></strong><span class="koboSpan" id="kobo.1409.1"> command to update </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">the database.</span></span><a id="_idTextAnchor239"/></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.1411.1">Fluent API</span></h2>
<p><span class="koboSpan" id="kobo.1412.1">Fluent API is a </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.1413.1">set of extension methods that you can use to configure the mappings gracefully. </span><span class="koboSpan" id="kobo.1413.2">It is the most flexible and powerful way to apply the mapping configuration without polluting the model classes. </span><span class="koboSpan" id="kobo.1413.3">Another important thing to note is that Fluent API has a higher priority than data annotations. </span><span class="koboSpan" id="kobo.1413.4">If you configure the same property in both data annotations and Fluent API, Fluent API will override the data annotations. </span><span class="koboSpan" id="kobo.1413.5">So, Fluent API is the recommended way to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">the mapping.</span></span></p>
<p><span class="koboSpan" id="kobo.1415.1">Fluent API is applied in the order of the method calls. </span><span class="koboSpan" id="kobo.1415.2">If there are two calls to configure the same property, the latest call will override the </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">previous configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.1417.1">To use Fluent API, we need to override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">OnModelCreating()</span></strong><span class="koboSpan" id="kobo.1419.1"> method in the derived </span><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">DbContext</span></strong><span class="koboSpan" id="kobo.1421.1"> class. </span><span class="koboSpan" id="kobo.1421.2">The following code shows how to use Fluent API to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.1422.1">the mapping:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1423.1">
protected override void OnModelCreating(ModelBuilder modelBuilder){
    // Seed data is omitted for brevity
    modelBuilder.Entity&lt;Invoice&gt;(b =&gt;
    {
        b.ToTable("Invoices");
        b.HasKey(i =&gt; i.Id);
        b.Property(p =&gt; p.Id).HasColumnName("Id");
        b.Property(p =&gt; p.InvoiceNumber).HasColumnName("InvoiceNumber").HasColumnType("varchar(32)").IsRequired();
        b.Property(p =&gt; p.ContactName).HasColumnName("ContactName").HasMaxLength(32).IsRequired();
        b.Property(p =&gt; p.Description).HasColumnName("Description").HasMaxLength(256);
        // b.Property(p =&gt; p.Amount).HasColumnName("Amount").HasColumnType("decimal(18,2)").IsRequired();
        b.Property(p =&gt; p.Amount).HasColumnName("Amount").HasPrecision(18, 2);
        b.Property(p =&gt; p.InvoiceDate).HasColumnName("InvoiceDate").HasColumnType("datetimeoffset").IsRequired();
        b.Property(p =&gt; p.DueDate).HasColumnName("DueDate").HasColumnType("datetimeoffset").IsRequired();
        b.Property(p =&gt; p.Status).HasColumnName("Status").HasMaxLength(16).HasConversion(
                v =&gt; v.ToString(),
                v =&gt; (InvoiceStatus)Enum.Parse(typeof(InvoiceStatus), v));
    });
}</span></pre>
<p><span class="koboSpan" id="kobo.1424.1">In the preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">Entity()</span></strong><span class="koboSpan" id="kobo.1426.1"> method to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">Invoice</span></strong><span class="koboSpan" id="kobo.1428.1"> entity. </span><span class="koboSpan" id="kobo.1428.2">This method </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.1429.1">accepts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">Action&lt;EntityTypeBuilder&lt;TEntity&gt;&gt;</span></strong><span class="koboSpan" id="kobo.1431.1"> parameter to specify the mappings. </span><span class="koboSpan" id="kobo.1431.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">EntityTypeBuilder&lt;TEntity&gt;</span></strong><span class="koboSpan" id="kobo.1433.1"> class has a lot of methods to configure the entity, such as table name, column name, column data type, and so on. </span><span class="koboSpan" id="kobo.1433.2">You can chain these methods in a fluent way to configure the entity, so it is called </span><span class="No-Break"><span class="koboSpan" id="kobo.1434.1">Fluent API.</span></span></p>
<p><span class="koboSpan" id="kobo.1435.1">Here is a list of the most </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.1436.1">commonly used Fluent </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">API methods:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-4">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1438.1">Method</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1439.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.1440.1">Equivalent </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1441.1">data annotation</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">HasDefaultSchema()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1443.1">Specifies the database schema. </span><span class="koboSpan" id="kobo.1443.2">The default schema </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1445.1">dbo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1447.1">N/A</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">ToTable()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1449.1">The table name that the model class is </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">mapped to.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">Table</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">HasColumnName()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1453.1">The column name in the table that a property is </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">mapped to.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">Column</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">HasKey()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1457.1">Specifies the property as </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">a key.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">Key</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">Ignore()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1461.1">Ignores a model or a property from the mapping. </span><span class="koboSpan" id="kobo.1461.2">This method can be applied on an entity level or a </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">property level.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">NotMapped</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">IsRequired()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1465.1">The value of the property </span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1">is required.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">Required</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">HasColumnType()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1469.1">Specifies the data type of the column that the property is </span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1">mapped to.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">Column</span></strong><span class="koboSpan" id="kobo.1472.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">TypeName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1474.1"> property</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">HasMaxLength()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1476.1">Specifies the maximum length of the value in the database. </span><span class="koboSpan" id="kobo.1476.2">Applied to a string or </span><span class="No-Break"><span class="koboSpan" id="kobo.1477.1">array only.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">MaxLength</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">HasIndex()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1480.1">Creates an index on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1481.1">specific property.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">Index</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">IsRowVersion()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1484.1">Specifies the property is used for concurrency management. </span><span class="koboSpan" id="kobo.1484.2">The property will map to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">rowversion</span></strong><span class="koboSpan" id="kobo.1486.1"> type in SQL Server. </span><span class="koboSpan" id="kobo.1486.2">The implementation may vary in different </span><span class="No-Break"><span class="koboSpan" id="kobo.1487.1">database providers.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">TimeStamp</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">HasDefaultValue()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1490.1">Specifies a default value for a column. </span><span class="koboSpan" id="kobo.1490.2">The value must be </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">a constant.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">N/A</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">HasDefaultValueSql()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1494.1">Specifies a SQL expression to generate the default value for a column, such </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">GetUtcDate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1">.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">N/A</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">HasConversion()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1500.1">Defines a value converter to map the property to the column data type. </span><span class="koboSpan" id="kobo.1500.2">It contains two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">Func</span></strong><span class="koboSpan" id="kobo.1502.1"> expressions to convert </span><span class="No-Break"><span class="koboSpan" id="kobo.1503.1">the values.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1504.1">N/A</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">ValueGeneratedOnAdd()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1506.1">Specifies the value of the property to be generated by the database when a new entity is added. </span><span class="koboSpan" id="kobo.1506.2">EF Core will ignore this property when inserting </span><span class="No-Break"><span class="koboSpan" id="kobo.1507.1">a record.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">DatabaseGenerated</span></strong><span class="koboSpan" id="kobo.1509.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">DatabaseGeneratedOption.Identity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1511.1"> option</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1512.1">Table 5.3 – Commonly used Fluent API methods</span></p>
<p><span class="koboSpan" id="kobo.1513.1">There are some other methods </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.1514.1">to configure the relationships using Fluent API, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">HasOne()</span></strong><span class="koboSpan" id="kobo.1516.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1517.1">HasMany()</span></strong><span class="koboSpan" id="kobo.1518.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">WithOne()</span></strong><span class="koboSpan" id="kobo.1520.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">WithMany()</span></strong><span class="koboSpan" id="kobo.1522.1">, and so on. </span><span class="koboSpan" id="kobo.1522.2">We will cover them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">next chapter.</span></span><a id="_idTextAnchor241"/></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.1524.1">Separating the mapping configurations</span></h2>
<p><span class="koboSpan" id="kobo.1525.1">In a</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.1526.1"> large project, there may be a lot of model classes. </span><span class="koboSpan" id="kobo.1526.2">If we put all the mapping configurations in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">OnModelCreating()</span></strong><span class="koboSpan" id="kobo.1528.1"> method, the method will be very long and hard to maintain. </span><span class="koboSpan" id="kobo.1528.2">To make the code more readable and maintainable, we can extract the mapping configuration to one class or a couple of </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">separate classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1530.1">One way to do this is to create an extension method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">ModelBuilder</span></strong><span class="koboSpan" id="kobo.1532.1"> class. </span><span class="koboSpan" id="kobo.1532.2">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">InvoiceModelCreatingExtensions</span></strong><span class="koboSpan" id="kobo.1534.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1535.1">Data</span></strong><span class="koboSpan" id="kobo.1536.1"> folder. </span><span class="koboSpan" id="kobo.1536.2">Then, add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.1537.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1538.1">
public static class InvoiceModelCreatingExtensions{
    public static void ConfigureInvoice(this ModelBuilder builder)
    {
        builder.Entity&lt;Invoice&gt;(b =&gt;
        {
            b.ToTable("Invoices");
            // Other mapping configurations are omitted for brevity
        });
    }
}
// You can continue to create the mapping for other entities, or create separate files for each entity.</span></pre>
<p><span class="koboSpan" id="kobo.1539.1">Then, in</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.1540.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1541.1">OnModelCreating()</span></strong><span class="koboSpan" id="kobo.1542.1"> method, call the </span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">extension method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1544.1">
modelBuilder.ConfigureInvoice();// You can continue to call the extension methods for other entities. </span><span class="koboSpan" id="kobo.1544.2">such as
// modelBuilder.ConfigureInvoiceItem();</span></pre>
<p><span class="koboSpan" id="kobo.1545.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">OnModelCreating()</span></strong><span class="koboSpan" id="kobo.1547.1"> method is much cleaner and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.1548.1">to read.</span></span></p>
<p><span class="koboSpan" id="kobo.1549.1">Another way to separate the mapping configurations is to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">IEntityTypeConfiguration&lt;TEntity&gt;</span></strong><span class="koboSpan" id="kobo.1551.1"> interface. </span><span class="koboSpan" id="kobo.1551.2">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">InvoiceConfiguration</span></strong><span class="koboSpan" id="kobo.1553.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">Data</span></strong><span class="koboSpan" id="kobo.1555.1"> folder. </span><span class="koboSpan" id="kobo.1555.2">Then, add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.1556.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1557.1">
public class InvoiceConfiguration : IEntityTypeConfiguration&lt;Invoice&gt;{
    public void Configure(EntityTypeBuilder&lt;Invoice&gt; builder)
    {
        builder.ToTable("Invoices");
        // Other mapping configurations are omitted for brevity
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1558.1">Then, in</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1559.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">OnModelCreating()</span></strong><span class="koboSpan" id="kobo.1561.1"> method, there are two ways to apply </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">the configuration:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1563.1">If you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">ApplyConfiguration()</span></strong><span class="koboSpan" id="kobo.1565.1"> method, add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">OnModelCreating()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1567.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1568.1">
modelBuilder.ApplyConfiguration(new InvoiceConfiguration());// You can continue to call the ApplyConfiguration method for other entities. </span><span class="koboSpan" id="kobo.1568.2">such as// modelBuilder.ApplyConfiguration(new InvoiceItemConfiguration());</span></pre></li> <li><span class="koboSpan" id="kobo.1569.1">Or you can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1570.1">Configure()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1571.1">method directly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1572.1">
new InvoiceConfiguration().Configure(modelBuilder.Entity&lt;Invoice&gt;());// You can continue to call the Configure method for other entities. </span><span class="koboSpan" id="kobo.1572.2">such as// new InvoiceItemConfiguration().Configure(modelBuilder.Entity&lt;InvoiceItem&gt;());</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.1573.1">As the </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1574.1">project grows, it might be a little bit tedious to call the mapping configuration for each entity. </span><span class="koboSpan" id="kobo.1574.2">In this case, EF Core has a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">ApplyConfigurationsFromAssembly()</span></strong><span class="koboSpan" id="kobo.1576.1"> to apply all the configurations in the assembly, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1578.1">
modelBuilder.ApplyConfigurationsFromAssembly(typeof(InvoiceDbContext).Assembly);</span></pre> <p><span class="koboSpan" id="kobo.1579.1">You can choose the one that fits your project best. </span><span class="koboSpan" id="kobo.1579.2">One reminder is that if you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">ApplyConfigurationsFromAssembly()</span></strong><span class="koboSpan" id="kobo.1581.1"> method, you need to make sure that all the configuration classes are in the same assembly as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">DbContext</span></strong><span class="koboSpan" id="kobo.1583.1"> class. </span><span class="koboSpan" id="kobo.1583.2">Also, you cannot control the order of the configurations. </span><span class="koboSpan" id="kobo.1583.3">If the order matters, you need to call each configuration explicitly in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1">correct order.</span></span></p>
<p><span class="koboSpan" id="kobo.1585.1">After you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">dotnet ef migrations add &lt;migration name&gt;</span></strong><span class="koboSpan" id="kobo.1587.1"> command, you can find that the generated migration file has the </span><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1589.1">
migrationBuilder.AlterColumn&lt;string&gt;(    name: "Status",
    table: "Invoices",
    type: "varchar(16)",
    nullable: false,
    oldClrType: typeof(int),
    oldType: "int");
migrationBuilder.AlterColumn&lt;string&gt;(
    name: "InvoiceNumber",
    table: "Invoices",
    type: "varchar(32)",
    nullable: false,
    oldClrType: typeof(string),
    oldType: "nvarchar(max)");</span></pre>
<p><span class="koboSpan" id="kobo.1590.1">The preceding snippet shows that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">Status</span></strong><span class="koboSpan" id="kobo.1592.1"> property is changed from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1593.1">int</span></strong><span class="koboSpan" id="kobo.1594.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">varchar(16)</span></strong><span class="koboSpan" id="kobo.1596.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">InvoiceNumber</span></strong><span class="koboSpan" id="kobo.1598.1"> property is changed from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">nvarchar(max)</span></strong><span class="koboSpan" id="kobo.1600.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">varchar(32)</span></strong><span class="koboSpan" id="kobo.1602.1">. </span><span class="koboSpan" id="kobo.1602.2">Then, you can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1603.1">dotnet ef database update</span></strong><span class="koboSpan" id="kobo.1604.1"> command to update the database. </span><span class="koboSpan" id="kobo.1604.2">You will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1605.1">Status</span></strong><span class="koboSpan" id="kobo.1606.1"> column is stored </span><span class="No-Break"><span class="koboSpan" id="kobo.1607.1">as strings.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1608.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1609.1">During the migration, the data may get lost if the data type is changed. </span><span class="koboSpan" id="kobo.1609.2">For example, if the data type is changed from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">nvarchar(max)</span></strong><span class="koboSpan" id="kobo.1611.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">varchar(32)</span></strong><span class="koboSpan" id="kobo.1613.1">, the original data will be truncated to 32 characters. </span><span class="koboSpan" id="kobo.1613.2">Please make sure you understand the data type change before you run </span><span class="No-Break"><span class="koboSpan" id="kobo.1614.1">the migration.</span></span></p>
<p><span class="koboSpan" id="kobo.1615.1">It is </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1616.1">recommended to explicitly configure the mapping for each entity in order to ensure optimal performance. </span><span class="koboSpan" id="kobo.1616.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">nvarchar(max)</span></strong><span class="koboSpan" id="kobo.1618.1"> requires more storage space than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">varchar</span></strong><span class="koboSpan" id="kobo.1620.1">, so the default mapping configuration may not be the most efficient. </span><span class="koboSpan" id="kobo.1620.2">Additionally, the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">dbo</span></strong><span class="koboSpan" id="kobo.1622.1"> database schema may not be suitable for your particular scenario. </span><span class="koboSpan" id="kobo.1622.2">Therefore, explicitly configuring the mapping is a </span><span class="No-Break"><span class="koboSpan" id="kobo.1623.1">recommended prac</span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.1624.1">tice.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.1625.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1626.1">In this chapter, we learned how to access the database using EF Core. </span><span class="koboSpan" id="kobo.1626.2">We implemented CRUD operations using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">DbContext</span></strong><span class="koboSpan" id="kobo.1628.1"> class. </span><span class="koboSpan" id="kobo.1628.2">We introduced some basic LINQ queries, such as query, filter, sort, create, update, and delete. </span><span class="koboSpan" id="kobo.1628.3">We also learned how to configure the mapping using data annotations and Fluent API. </span><span class="koboSpan" id="kobo.1628.4">With the knowledge gained in this chapter, you can build a simple application to access </span><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1630.1">However, the application we built in this chapter is quite basic and only has one entity. </span><span class="koboSpan" id="kobo.1630.2">In a real-world project, there are usually multiple entities and relationships </span><span class="No-Break"><span class="koboSpan" id="kobo.1631.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.1632.1">In the next chapter, we will learn how to configure relationshiseps between entities using </span><span class="No-Break"><span class="koboSpan" id="kobo.1633.1">EF Core.</span></span></p>
</div>
</body></html>