- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameter Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context is a critical aspect of any API. The client has their own understanding
    of how data is structured, as does the server. For example, as the client, you
    will view API documentation that tells you to format a request payload in JSON
    format. You therefore create the JSON payload as per the API requirements.
  prefs: []
  type: TYPE_NORMAL
- en: When the API receives your payload, it is not guaranteed that the object you
    transmitted will remain as JSON (especially in an ASP.NET API), and a mechanism
    will often be in place to bind the JSON object to a strongly typed .NET object
    that the API can manipulate more easily within its own context.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take another example. You (still as the client) make a **GET** request
    for all logs corresponding to a *job* with a particular ID. However, you want
    to restrict the number of logs returned to 100, which the API allows you to do.
    According to the API documentation, you can do this by including the job ID in
    the route, and an option in the query string specifying how many logs you wish
    to return.
  prefs: []
  type: TYPE_NORMAL
- en: When receiving this request from you as the client, the API will need to know
    where to look to retrieve these parameters, so that they can be used in the context
    of the request handler. This type of transformation of data between client and
    server during requests is known as **parameter binding** , and we are going to
    explore it in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter binding sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding precedence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom parameter bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter binding sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the box, ASP.NET supports several different parameter binding types.
    Each binding type has a source from which it can bind. Additionally, each binding
    source is situated in a different location within the request, with various ways
    in which they can be bound to data structures in the API.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with one of the most common binding sources, the route value.
  prefs: []
  type: TYPE_NORMAL
- en: Route values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **route value** is simply a section of an API route. Look at a typical route
    and imagine it is split into sections delimited by each occurrence of the **/**
    character. Each of these resulting sections is a value within the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this example: **/todoitems/2** . It would be split into two route value
    sections: **todoitems** and **2** .'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, **2** is the route value we are interested in, because it is
    the ID of a **TodoItem** entity. So, how can we access this within an endpoint?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we can see that the incoming route has been modified to add a
    value surrounded by curly braces. This **id** value is a placeholder for an integer
    value that will be passed in its place from the client’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In the parameter of the lambda expression that follows the route, we declare
    that we are passing in an integer parameter, called **id** . We can do this thanks
    to ASP.NET’s routing module, which detects the route value placeholder and parses
    out the actual value, converting it to the data type needed for the lambda expression,
    which in this case is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client’s side, the requested route might look like this: **https://myTodoAPI/todoitems/2**'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that in this example, if an item with an **id**
    value of **2** does not exist, the binding will not match, and the endpoint won’t
    hit at all, instead returning **404** **NOT FOUND** .
  prefs: []
  type: TYPE_NORMAL
- en: By declaring a route parameter in the endpoint, the **id** value of **2** found
    at the end of this route will be automatically detected and bound to the integer
    parameter declared in the lambda expression, allowing it to be used within the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Route values do not have to be automatically bound to the lambda expression
    parameters. They can be manually accessed within the request by passing an **HttpRequest**
    object as the parameter instead. On **HttpRequest** , there is a **RouteValues**
    collection that will be populated with the values you need for binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful if you have multiple types of parameter bindings and you want
    to make the request more readable. Here’s an example that passes in an **HttpRequest**
    parameter. This does not require any change on the client side, as it is already
    present. By adding it as a parameter, we are allowing the endpoint to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When making requests to an API, there are times when you need to be more granular
    about the state or the conditions of a query you’re making. In these situations,
    query strings can be added to the endpoint URL. This allows you to pass more specific
    parameters to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Query strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of route values, they are often a direct route to data. Requesting
    something by an ID using a route value, on its own, produced a predictable result.
    However, data comes in many different forms, meaning that we often need to specify
    specific conditions that will transform the data we are retrieving in the required
    shape. **Query strings** allow us to achieve this. They sit at the end of a route,
    and they have their own notation that defines them, starting with a **?** character.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the presence of query string parameters
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of checking for the query strings before using them only if they
    exist is that we can make query string parameters optional (more on that in the
    next section). Otherwise, our code would assume that the client is always going
    to send query string values, therefore making them mandatory parameters for the
    endpoint. This is fine when intended, but in the examples shown in this chapter,
    the aim is to ensure that the client has the choice to either filter the data
    or not, using query string values.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in this route, **https://myTodoAPI/todoitems?pastDue=true&priority=1**
    , the query string starts at the end of the route values with a **?** character.
    After this, a collection of key-value pairs is specified.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the query string in the route is to pass a series of variables
    into the API, which can be used to filter the data that will be returned. In this
    case, the client is requesting any **TodoItem** that is past its due date, but
    also has a priority with a value of **1** .
  prefs: []
  type: TYPE_NORMAL
- en: Optional query string parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can make it so that a parameter passed in is optional. It’s very simple;
    you just make the query string parameter you added to the endpoint nullable by
    affixing a **?** character to it. Then, in the body of your endpoint, you can
    check for the existence of an optional value. If the optional value is not null,
    you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of an optional parameter used on an endpoint that fetches
    a todo item by ID. It allows the client to specify that the assignee must be a
    certain value. If the assignee value is not null and does not match the assignee
    value on the item, you can send a different response, such as **404** **NOT FOUND**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, the query string parameters are bound as per the following
    example. In this example, we are also checking for the existence of certain query
    string key-value pairs and building the relevant query for the data based on the
    specified query string values, using **IQueryable** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ve spent most of our time so far passing parameters within the URLs of our
    requests. Let us explore parameters that exist outside of this, starting with
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Headers** are a classic component of general API architecture, providing
    important metadata about the request. They are like query strings in the sense
    that they are defined by a key-value structure, but the syntax used when applying
    them differs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like query strings and route values, they can also be accessed from an **HttpRequest**
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another critical parameter type that exists outside of the URL is the request
    body, sometimes referred to as the *payload.* ASP.NET has a clever feature that
    allows the payload’s contents to be automatically converted into a strongly typed
    object defined in the project. The feature is known as **object binding** .
  prefs: []
  type: TYPE_NORMAL
- en: Strongly typed object binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When representing objects in a request payload, it is extremely common for that
    object to be structured as JSON when the client creates the request. ASP.NET provides
    a convenient way of automatically binding incoming JSON parameters to a strongly
    typed object so that it can be easily used when handling the request.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen examples of this already in previous chapters, where we send a
    JSON payload representing a **TodoItem** object.
  prefs: []
  type: TYPE_NORMAL
- en: If the JSON object can be parsed, ASP.NET allows you to implicitly declare that
    the request parameter is an object of type *x* – *x* in our example being a **TodoItem**
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use implicit binding in this manner, simply declare a parameter of the type
    you wish to receive as a parameter in your endpoint, as shown in the following
    example, where we receive a new **TodoItem** to be created via a **POST** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Object binding is initiated thanks to the client sending a data structure represented
    by a string, within the body of the request. This is often the result of a developer
    formatting the payload after the data was gathered, before sending it to the API.
    However, if the data was gathered by a user, who could be entering the data in
    the **Graphical User Interface** ( **GUI** ) via a form, the process can be streamlined
    further, thanks to form values.
  prefs: []
  type: TYPE_NORMAL
- en: Form values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API endpoints take in data and do something with it. What better use case can
    there be for data submission than a form? Minimal APIs support the receipt of
    **form values** , making them a suitable option for handling submissions from
    forms within a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the previous parameter examples, form values can be retrieved from their
    own dedicated member within an **HttpRequest** object, where they also exist in
    a key-value structure within an **IFormCollection** collection. The following
    code shows the retrieval of form values within a **PATCH** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So far, we’ve made some good progress exploring the various types of parameters
    that can be bound to API endpoints. In each of the previous examples, a lot is
    assumed about how these parameters should be bound. The location of the parameters,
    whether they be in the URL as query strings or in the request body, is *implicit*
    ; it does not require definition, instead occurring automatically. Inversely,
    there will be times when we will need to be *explicit* about how parameters are
    bound. This explicit binding can be achieved with **attributes** .
  prefs: []
  type: TYPE_NORMAL
- en: Explicit binding with attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the previous examples have something in common – they are accessible using
    keys from collections that exist within an **HttpRequest** object.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way of binding these parameter types without needing to inject
    **HttpRequest** or its parent, **HttpContext** – attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this is that we can make the code more readable and arguably
    improve the structure of the request, because the parameters can be bound from
    within the parentheses of the endpoint’s lambda expression, leaving the expression
    body dedicated exclusively to handling the request. As shown in the previous examples,
    we are using the parentheses to receive parameters but then performing explicit
    binding in the body, as well as executing handling logic, which can be somewhat
    messy.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter binding with attributes is simpler because you are explicitly stating
    that you have a parameter that should be bound from a specific location in the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take query strings as an example. In the code block in the *Query strings*
    section, we were accessing query strings from within the endpoint body by index
    on **IQueryCollection** within the **HttpRequest** object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block demonstrates how this endpoint can be refactored to
    obtain query string values using attributes, reducing the amount of code and making
    it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you were to change the **[FromQuery]** attributes in this code slightly by
    removing the argument, for example, to **Name = "priority"** , the API would still
    match the query values, assuming that the name was specified in the query string.
  prefs: []
  type: TYPE_NORMAL
- en: All the parameter binding methods demonstrated previously in this chapter can
    be extracted in this way – by specifying in an attribute where the parameter should
    be bound from and then providing an object with the appropriate data type in which
    it can be bound.
  prefs: []
  type: TYPE_NORMAL
- en: Let us update another of our previous **POST** examples by checking the headers
    in this manner. For the purposes of demonstration, let us assume that when a client
    posts a new **TodoItem** , they can indicate whether another process should be
    triggered in the background by using a custom header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header can be explicitly bound using an attribute, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’re ready to step into more advanced territory now, in which we can explore
    parameters that have been *injected* from a catalog of previously registered **services**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Binding parameters through dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters can be bound to an endpoint that was not necessarily sent by the
    client. One example of this is dependencies. Where an API has dependencies registered
    for injection, they can be explicitly bound as parameters. Let us explore an example
    of this by rewriting the **GET** request example from the first code block in
    the *Explicit binding with* *attributes* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as you can see in the code on GitHub, we’ve created a service called
    **TodoItemService** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This service has been registered for dependency injection as a singleton service
    in **Program.cs** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can now access this service from within an endpoint using
    the **[** **FromServices]** attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this code, binding a service registered for dependency injection is demonstrated
    using a **[FromService]** attribute. This allows API endpoints to leverage reusable
    components easily.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at examples of various parameter types and how they are
    bound to API endpoints. Hopefully, it is clear that ASP.NET is taking care of
    the heavy lifting when it comes to resolving these parameters before binding.
    It is also important to understand the order in which this resolution of parameters
    happens. This is known as **binding precedence** .
  prefs: []
  type: TYPE_NORMAL
- en: Binding precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET has its own defined order in which it will bind parameters, known as
    its **order of precedence** . Using this order keeps resolution consistent and
    ensures that ASP.NET is resolving in a predictable way, starting with the most
    specific parameters to the least.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6* *.1* outlines the official order ASP.NET uses, which is useful to
    know as a developer, as it can help you anticipate any potential binding issues
    depending on the parameters in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: ASP.NET order of precedence for parameter binding](img/B20968_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: ASP.NET order of precedence for parameter binding'
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at a working example of how we can create custom binding logic,
    giving us more control over the way binding is executed on incoming parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom binding logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we are going to change the way we bind an incoming **TodoItem**
    , adding validation logic that will occur at the point of binding.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this kind of custom binding, we need to implement a function within
    **TodoItem** . This function is static and is called **BindAsync()** .
  prefs: []
  type: TYPE_NORMAL
- en: '**BindAsync()** allows us to interrupt the binding process for an object and
    apply our own logic. Let us start by adding **BindAsync()** to the **TodoItem**
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **TodoItem** , add the following static function below the property definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a **try/catch** block so that we can perform JSON validation
    logic, catching any errors in the process. We are expecting to see exceptions
    of type **JsonException** if the validation fails, so we will explicitly catch
    this exception type in our **try/catch** block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start by accessing the body of the request and deserializing the
    raw JSON to a **TodoItem** instance. We will add options to ensure case is not
    factored into validation, and then check to see whether deserialization was successful.
    If it was not, the incoming parameter cannot be bound and the request is invalid,
    so we will return a **400 Bad Request** response. Update the **try** block with
    this code, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have now checked the validity of the JSON to be bound. In
    [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094) , we explored an example of validation
    middleware for verifying that objects were created according to specific rules.
    We used **ValidationContext** along with the static type, **Validator** , to return
    a list of **ValidationResult** , which would determine the validity of the model.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this same logic in **BindAsync()** to implement validation of the
    object as part of the parameter binding process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this logic to the **try** block to complete the custom binding logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add the following basic logic to the **catch** block to
    handle any exceptions of type **JsonException** that are caught:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to this chapter’s code in the accompanying GitHub repository to see the
    finished class: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Custom parameter binding is a good example of ASP.NET’s flexible feature set.
    Minimal APIs may be labeled as such but that doesn’t mean they restrict custom
    configurations. Let us review what we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binding of parameters is a fairly broad subject, and we have certainly covered
    the bulk of it in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at how the different parameter types are bound, from route
    values and query strings right up to headers and the automatic binding provided
    for strongly typed objects.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored some alternative binding methods for these parameter types
    in the form of explicit attribute binding and the order of binding precedence,
    before looking at how dependency injection can be leveraged within requests to
    add parameters that may not have been received from the client.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked through an example of custom parameter binding, adding custom
    validation to the binding logic of the **TodoItem** model.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not the last we have seen of dependency injection in minimal
    APIs. In the next chapter, we will explore the topic in more detail.
  prefs: []
  type: TYPE_NORMAL
