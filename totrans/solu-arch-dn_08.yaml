- en: '*Chapter 6*: Architecture Considerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about a set of architectural patterns that
    you must know to design and build a successful solution. These patterns are essential
    as they set the path for the development team and address the client concerns
    related to solution agility, scalability, and performance. Later in the chapter,
    we had a quick overview of a set of architecture characteristics that affect how
    you choose the right pattern for your solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dig deep into the quality factors that should be taken
    into account, such as reusability, usability, performance, security, development
    time, and similar quality requirements. Additionally, we will get to know best
    practices to plan for exception handling, tracing, and deploying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the design and runtime quality attributes of the solution architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to plan for exception handling, tracing, and deploying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching in web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned what makes an architecture
    pattern the best fit for the product you are building by exploring design and
    runtime quality attributes. We will also enrich your knowledge by learning best
    practices to implement caching to improve performance and overall user experience,
    logging to track reported errors in a centralized location, and deployment techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about quality attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An organized solution architecture sets the right path for your development
    team and makes it easy to maintain different quality characteristics, which will
    further enhance the quality of the product in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start exploring the various quality attributes, let''s first understand
    what a quality attribute is. A **quality attribute** is a property that defines
    the quality of a system, it is a measurable or testable characteristic of a system
    that is used to indicate how well the architecture chosen for the system satisfies
    the requirements of the client. There are two types of quality attributes: qualities
    that can be measured at design time and others that can be measured at runtime
    or during execution. The following diagram shows us the various attributes that
    we will discuss in this chapter along with their respective types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Software architecture quality attributes](img/Figure_6.1_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Software architecture quality attributes'
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore these quality attributes in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring design quality attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business functionalities of the product take the front seat in terms of importance
    for the development team. We often focus on meeting the functional requirements
    of the client and later, after releasing the product, we notice some quality deficiency
    such as the product is difficult to maintain or to scale. Also, we may end up
    with performance issues or security breaches. In this section, we will explore
    the design quality attributes that should be addressed during the software architecture
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Maintainability** is one of the key software quality attributes. It refers
    to the ability of the architecture to support future changes in the product behavior
    such as introducing a feature with new business requirements or modifying an existing
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: Repair philosophy also affects the measurement of this attribute, which refers
    to the time needed to restore the system after a failure. The more our code is
    coupled and the components are developed with excessive dependencies, the more
    the product is difficult to maintain. With the existence of this attribute, software
    engineers started introducing the concept of separation of concerns into architectures,
    which is supported in microservices architecture, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Improving the maintainability of the product can greatly improve team productivity
    and lower the cost of adding new features. Here is a list of key techniques for
    better maintainability:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an architecture that allows us to separate the responsibilities of the
    components by having low coupling, which should create well-defined layers in
    the system and ease changes in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use interfaces to maximize the use of plugin modules in the system, which will
    allow more flexibility and extensibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide detailed documentation to explain the object-oriented structure in the
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Flexibility** refers to the ability of the architecture to adapt to varying
    environments and situations in response to different user and system requirements,
    which could be hardware changes, software changes, or even changes in the business
    rules. The less effort you put in to cope with changes, the more flexible it is;
    the easier it is to reconfigure and deploy the system, the more flexible it is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A flexible software architecture is able to adapt to changes, so let''s check
    the following key techniques to improve flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider using business layers to encapsulate the business rules. We can only
    modify these layers when business rules change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using a configurable business workflow engine such as **Microsoft Power
    Automate**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider implementing layers in the system to separate the UI from the business
    logic and the data access functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design layers to be consistent and loosely coupled to maximize flexibility and
    facilitate the replacement and reusability of the components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reusability** is also one of the key software quality attributes. It refers
    to the degree to which existing components, classes, and functions can be reused
    to develop new modules, new features, or even new applications. It eliminates
    the duplication of code and minimizes the time needed to implement new components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusability is an approach that should be applied with careful consideration
    of the benefits it brings to a system. Here are some key techniques to improve
    reusability:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the cross-cutting functionalities between components and implement
    the common classes and functions that we can reuse across different components
    to provide capabilities such as validation, logging, tracing, authorization, and
    authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider exposing the business logic through web services or Web APIs to provide
    this logic to different systems or platforms, such as web and mobile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data types and structures that can be accessed through different components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Integrability** outlines the way the components are designed to operate together
    by exchanging information as part of the overall system architecture. It also
    includes the coding standards and naming conventions in addition to other factors
    that affect the consistency of the components and makes it easy for the developers
    to understand the code and maintain it. It also measures the ability of the system
    to be integrated with other systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous advantages of applying integrability to improve the harmony
    between the different components of a system. Here are some key techniques to
    maximize integrability:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforce coding standards that should be predefined and available for the development
    team and provide detailed documentation for the entire system architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using web services or gateway layers to integrate with legacy systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform code review sessions to ensure guidelines are respected during the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Testability** is a quality attribute that shows how well a system allows
    us to create test cases and execute test plans to determine whether the system
    is working as per the requirements. It allows us to identify faults in the system
    in an effective manner and based on predefined test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should find defects, performance issues, and security vulnerabilities sooner
    as it is less expensive than having the customer find them when the product is
    released. Let''s get to know some key techniques to improve testability:'
  prefs: []
  type: TYPE_NORMAL
- en: Create test cases in **Visual Studio**, then run test plans and check the test
    results. This is also applicable in **Azure DevOps**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use mock objects in test cases to build different scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let our architecture support modular components to allow detailed testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create unit testing to test every single functionality in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to consistently increase our learning curve and upgrade our
    skills to ensure that we are able to apply all these design attributes. This will
    lead to the creation of balanced and highly efficient software solutions and products.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore runtime quality attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding runtime quality attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runtime quality attributes are a set of attributes that are measured during
    the execution of a system in real-life scenarios. They represent a set of features
    that facilitate the measurement of the performance and security of a software
    product in addition to other quality constraints.
  prefs: []
  type: TYPE_NORMAL
- en: These quality attributes must be assessed to take actions proactively to ensure
    they are maintained properly to deliver great products to end users. What follows
    is an introduction to each runtime quality attribute with some key techniques
    diving into details that should be considered for improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Performance** is the most important quality attribute for every client. It
    refers to the responsiveness of the system to perform a specific function in given
    constraints such as time, accuracy, or memory usage. It includes two metrics,
    namely, *latency*, which is the time needed to respond to an event triggered in
    the system, and *throughput*, which is the number of events that can occur in
    a given time frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We all know that there are some products out there that aren''t being used
    because of their performance problems. So, let''s get to know some key techniques
    for improving performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider using asynchronous calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **Data Transfer Objects** (**DTOs**) to minimize the size of data sent from
    the server to the frontend client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid retrieving data more often than is necessary and use paging when returning
    data collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use performance profiling tools, such as **Visual Studio Diagnostic Tools**
    to identify code that has a large impact on performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minify frontend assets such as **JavaScript** and **CSS** files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using **Azure** **Functions** to handle long-running requests, as out-of-process
    functions are beneficial to minimize CPU usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the size of HTTP responses by using HTTP compression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use the latest release of ASP.NET Core as it includes many improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Security** is an essential part of the system. It refers to the fact that
    any system should be protected from disclosure and unauthorized attempts to access
    data. Securing a system starts with implementing proper authentication and authorization
    mechanisms. In addition, securing the system assets from unauthorized modification
    is a must. That''s why we should always deploy the compiled assemblies and never
    upload the .NET classes as is.'
  prefs: []
  type: TYPE_NORMAL
- en: To secure our system, we must have an in-depth understanding of the environment
    where we want to deploy the product, what type of access we need to grant users,
    and what they can access. It is important to know that we need to apply various
    mechanisms to increase the protection level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more we learn about potential threats and take action to avoid them, the
    more we protect the system. Having the product tested on a regular basis for security
    vulnerabilities is a must for protection against data breaches that may affect
    the client''s reputation negatively and undermine their brand''s integrity. Let''s
    check the following key techniques that should help us improve the overall security
    of the product:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a periodic task to back up the database and the system assets then store
    them in a secure location, which will make it possible to recover them quickly
    when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the restore process to make sure that the backups will work properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply solid authentication and authorization processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never trust user input, always validate data input, and use stored procedures
    to prevent **SQL injection**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never use string concatenation to create SQL statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode passwords saved in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not store sensitive data in hidden fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement audit logging functionality to log every single event in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider implementing a clustered server architecture if the system is considered
    mission-critical for the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reliability** is the ability of a system to perform all tasks and events
    triggered by users over time without the need to conduct a repair or modification.
    The system has a probability of high reliability during the early stage of operation.
    This probability will start reducing over time. Improving the reliability of a
    system requires us to identify the most essential user journeys, then analyze
    them to detect the areas where we can improve. This methodology will allow us
    to create indicators about the services and functions that matter most to the
    users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This quality attribute is critical for the continuity of services delivered
    by the system. Here are some key techniques to improve the reliability of our
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: Trace the performance of the most used services in our system to identify poor
    performance or failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit calls to Web APIs and web services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider implementing a failover plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider analyzing customer complaints to troubleshoot and identify the services
    that should be improved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Usability** is a quality attribute that assesses the user interface of a
    system. It shows how easy it is to use the system. If users don''t like the design
    or if they find it difficult to find what they are looking for, they might stop
    using the system. That''s why usability is one of the main factors that will lead
    users to adopt a system. There are five key factors that constitute the usability
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learnability**: This factor tells us how easy it is for users to perform
    their tasks the first time they see the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: This factor specifies how quickly the users can perform their
    main tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memorability**: This denotes how easy it is to remember the steps to perform
    main tasks after not using the system for a long time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Errors**: This stipulates how many errors they encounter while performing
    actions in the system and whether it''s easy to report them or to recover and
    proceed to accomplish the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Satisfaction**: This indicates how satisfied the users are with the overall
    design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usability concerns should be carefully considered during the earliest design
    decisions of the system to avoid the disappointment and frustration of end users
    when the product is released. Here is a list of some key techniques to improve
    usability:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider maximizing ease-of-use patterns by enforcing accepted UI design standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify user interaction and multi-step functionalities by applying workflows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using asynchronous calls to increase user interactivity and to perform
    background tasks and avoid full post-back calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Interoperability** is a quality attribute that assesses the ability of the
    components in our system to cooperate at runtime to perform tasks successfully
    and efficiently exchange information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, interoperability is an attribute of the system that is responsible
    for its operation and interaction with other systems as well. It is an attribute
    that cannot be ignored. Let''s get to know a few key techniques to increase interoperability:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider using connectors and web services to connect to third-party systems
    and exchange data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose functionalities through standard web services or **REST APIs** to exchange
    data with legacy systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that our architecture design allows low coupling between components to
    improve flexibility and reusability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we explored the runtime quality attributes that affect the
    quality of the software product. These attributes should be considered and solved
    during the implementation and execution of the system to ensure the delivery of
    great products for our clients. In the next section, we will explore the caching
    mechanism in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Caching in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Caching** is a technique that allows us to store frequently used data in
    memory. Instead of querying the database multiple times to get the same content,
    we often use caching to store this content and then retrieve it from the memory
    the next time we request the same content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching is essential to improve performance in ASP.NET Core and the overall
    user experience of the product. In ASP.NET Core, there are different techniques
    to cache data. Here is an overview of these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-memory caching**: In this technique, the memory of the server is used
    to store the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed caching**: This technique is used when our app is deployed to
    Azure or when it is hosted on a farm environment. The cache is distributed across
    the servers contributing to this farm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn how to implement caching in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing caching in ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ASP.NET Core, there are two built-in main interfaces that you can use to
    start caching the content of mission-critical tasks: `IMemoryCache` and `IDistributedCache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IMemoryCache`: This is an interface that allows us to apply a local in-memory
    cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDistributedCache`: This is an interface that provides us with a set of methods
    to manipulate the cache in a distributed environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IMemoryCache example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code demonstrates an example of using `IMemoryCache` to avoid
    querying the database multiple times to get the same content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `NewsService` class with a method to get all the
    updates from the database. Instead of querying the database every time, we want
    to display the new data. So, we decided to use the `IMemoryCache` interface to
    benefit from its caching mechanism. In the `GetNewsList` method, we are returning
    the cached version of the data if available; otherwise, we are querying the database
    then storing the content in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: IDistributedCache example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This interface should be used when the application is hosted on a web farm
    or a cloud service. This interface doesn''t use the local memory of the server.
    This cache is shared by multiple web servers. There are various options to implement
    the `IDistributedCache` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the SQL Server distributed cache. This cache will be stored in a
    SQL table. For this option, we need to add the following `Microsoft.Extensions.Caching.SqlServer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `Microsoft.Extensions.Caching.StackExchangeRedis`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example showing how to use the `IDistributedCache` interface for
    caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created a **Razor** page to display the time and two
    asynchronous methods: one to get the cached time and the other one is to reset
    the cache.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnGetAsync` method, we get the cached time if available. The `ResetCachedTime`
    method is used to set the cache object and define the sliding expiration for 60
    seconds, which means the cache will be cleared if it is not used within 60 seconds.
    Otherwise, the time frame of the cache will be extended for another 60 seconds
    when it is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding two examples, we tried to explain the difference between `IMemoryCache`
    and `IDistributedCache` and how to use them. You can find many Microsoft online
    forums that provide step-by-step examples on how to configure and implement caching
    in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the logging and tracing mechanisms in ASP.NET
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: Unified solution for logging and tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET logging providers are used to log event messages to track the execution
    of the application and report all code errors or application exceptions in a centralized
    location. Tracing is used to track and view diagnostic information about a single
    flow in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging and tracing are essential for .NET teams as every time the application
    fails, we request information to troubleshoot the issue and resolve it. The unified
    solution for logging and tracing will give you answers to the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Why did the system fail to complete the action?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*When did the error occur?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Which function in the code caused the exception?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What was the status of the data exchanged between the functions?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For traditional solutions that are hosted on-premises, logging and tracing are
    performed by the same process that runs the executable of the application. As
    for modern cloud applications that are built with the microservices pattern, each
    service runs within a specific process. In this case, the logging and tracing
    are generated by each microservice process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture recommended by Microsoft to implement
    a unified logging and monitoring system using Azure services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Unified logging and monitoring system using Azure services](img/Figure_6.2_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Unified logging and monitoring system using Azure services'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to know the main components from the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Hubs**: This is a real-time data ingestion service that is fully integrated
    with all other Azure services. It is used to log all types of events in one centralized
    hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Monitor**: This is used to create operational dashboards to help notify
    .NET teams about any issues and critical malfunctions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Insights**: This is part of Azure Monitor, which is used to monitor
    live Azure services, detect abnormalities in performance, and diagnose and trace
    malfunctions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logic Apps**: This is a serverless cloud service that allows you to schedule
    and organize automated workflows using a user-friendly and easy-to-use visual
    designer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blob Storage**: This is cloud storage used for cloud-native workloads to
    store unstructured data and binary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Data Lake Storage**: This is a cloud platform that provides secure
    storage for big data analytics. It provides a set of capabilities required for
    developers and data scientists to store and analyze big data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Sentinel**: This is a cloud platform that uses built-in AI to log and
    analyze security information, then report any potential threat or anomalous behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Stream Analytics**: This is a serverless cloud engine used to collect
    and log real-time analytics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we have learned about the main components. Now let''s get an understanding
    of the logging and tracing mechanism shown in *Figure 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: First, our application hosted on Azure triggers events to **Event Hubs** and
    **Application Insights** from both a user interface action and a Web API call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Application Insights** queries log data, traces problems, and monitors the
    application performance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Stream Analytics** platform queries the data in **Event Hubs** to trigger
    **Logic Apps** workflows and process event messages that are flagged as critical
    indicators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, a **Logic Apps** scheduled process calls a REST endpoint and sends alerts
    to the .NET teams.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Azure Sentinel** uses **Playbooks**, which are a set of procedures powered
    by **Azure Logic Apps** to log security alerts or incidents.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All logs will then be stored in **Blob Storage** and **Data Lake Storage** for
    later analysis and troubleshooting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we are going to talk about the high-level deployment steps
    in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for deployment and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to focus on deploying your ASP.NET application
    to **Azure App Service**. This doesn't mean that other traditional deployment
    options are not valid anymore, but we think the future is to host modern apps
    in the cloud for many reasons, including the capabilities offered by Azure that
    don't exist in traditional web hosting.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy the ASP.NET Core web app to Azure, we'll need to create a new Azure
    App Service web app. After the creation of the App Service, we'll be able to deploy
    our app using **Git** or Visual Studio. To create the App Service, we can use
    command-line scripts and **Azure Cloud Shell** or you can use the **Azure portal**
    to create and configure the App Service; both are easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the Microsoft documentation for detailed steps on how to create
    an App Service. Refer to the *Deploy an app to App Service* section at [https://docs.microsoft.com/en-us/dotnet/architecture/devops-for-aspnet-developers/deploying-to-app-service?view=aspnetcore-5.0](https://docs.microsoft.com/en-us/dotnet/architecture/devops-for-aspnet-developers/deploying-to-app-service?view=aspnetcore-5.0).
  prefs: []
  type: TYPE_NORMAL
- en: After creating the App Service, you can publish the application using Visual
    Studio. Just right-click the Visual Studio project and then publish it. By default,
    our app will be deployed to the production environment and we will be able to
    browse it on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '*What if you want to have a staging environment so you can test and approve
    changes before moving them to production?* In this case, you can make use of Azure
    deployment slots. You can add a new deployment slot that will allow you to swap
    the app assets along with the configuration settings between the two deployment
    slots, usually staging and production. You can refer to the Microsoft documentation
    to create a staging deployment slot (similar steps can be applied to create a
    production slot): [https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots](https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the design and runtime quality attributes that
    affect the overall quality of our architecture and as a result, our product. It
    is important to understand and apply these quality attributes. This will give
    our product the ability to undergo repair and evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about the impact of caching on the performance of the application
    and how to enable it using ASP.NET Core interfaces. Later in this chapter, we
    discussed the logging and tracing mechanism in modern apps, then we explored the
    deployment capability of Azure App Service.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that our responsibility as solution architects is to get a satisfactory
    result from the big picture, which consists of the solution architecture as well
    as the implementation and deployment being done in the correct way – that's what
    we tried to cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deep into security considerations and will
    highlight some key techniques to secure your ASP.NET web applications.
  prefs: []
  type: TYPE_NORMAL
