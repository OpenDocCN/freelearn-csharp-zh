- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks and Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you learned a lot about arrays and lists. However, these structures
    are not the only ones available. Among others, there is also a group of more specialized
    data structures called **limited access** **data structures**.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean? To explain the name, let’s return to the topic of arrays
    for the moment, which belong to the group of **random access data structures**.
    The difference between them is only one word - that is, *limited* or *random*.
    As you already know, arrays allow you to store data and get access to various
    elements using indices. Thus, you can easily get the first, the middle, the *n*th,
    or the last element from an array. For this reason, it can be named a random access
    data structure.
  prefs: []
  type: TYPE_NORMAL
- en: However, what does *limited* mean? The answer is very simple. With a limited
    access data structure, **you cannot access every element from the structure**.
    Thus, **the way of getting elements is strictly specified**. For example, you
    can get only the first or the last element, but you cannot get the *n*th element
    from the data structure. Popular representatives of limited access data structures
    are stacks and queues, which are topics mentioned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the application of a stack, as well as a few variants of queues,
    including a regular one, a priority queue, and a circular queue. To make understanding
    easier, the text is supported with illustrations and code snippets with detailed
    explanations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let’s talk about a **stack**. It is a data structure that allows you
    to **add a new element only at the top** (referred to as a **push** operation)
    and **to get an element only by removing it from the top** (a **pop** operation).
    For this reason, a stack is consistent with the **LIFO** principle, which stands
    for **Last-In First-Out**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a stack
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize a stack, let’s close the book for a moment,
    go to the kitchen, and take a look at a pile of plates, each placed on top of
    the other. You can only add a new plate to the top of the pile, and you can only
    get a plate from the top of the pile. You cannot remove the seventh plate without
    taking the previous six from the top, and you cannot add a plate to the middle
    of the pile. So, the last added plate (last-in) will be removed from the pile
    first (first-out). And do not even try to get a plate from the middle of the pile,
    as you don’t want to break plates! The stack operates similarly. It allows you
    to add a new element only at the top (a push operation) and to get an element
    only by removing it from the top (a pop operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram of a stack with *push* and *pop* operations is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.1 – \uFEFFIllustration of a stack](img/B18069_05_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Illustration of a stack
  prefs: []
  type: TYPE_NORMAL
- en: It seems to be very easy, doesn’t it? It really is, and you can benefit from
    various features of stacks using the built-in generic `Stack` class. It is worth
    remembering that it is located in the `System.Collections.Generic` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s mention three methods from this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Push` inserts an element at the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pop` removes an element from the top of the stack and returns it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek` returns an element from the top of the stack without removing it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also have access to other methods, such as for removing all elements from
    the stack (`Clear`) or for checking whether a given element is available in the
    stack (`Contains`). You can get the number of elements currently in the stack
    using the `Count` property.
  prefs: []
  type: TYPE_NORMAL
- en: What about the performance?
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the `Push` method is either an *O(1)* operation, if
    the capacity does not need to increase, or *O(n)* otherwise, where *n* is the
    number of elements in the stack. Both `Pop` and `Peek` are *O(1)* operations.
  prefs: []
  type: TYPE_NORMAL
- en: As the time complexity looks very promising, it is high time to take a look
    at some examples showing stacks in action.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find content regarding a stack at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1)
  prefs: []
  type: TYPE_NORMAL
- en: Example – reversing a word
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the first example, let’s try to reverse a word using a stack. You can do
    this by iterating through characters that form a string, adding each at the top
    of the stack, and then removing all elements from the stack. At the end, you receive
    the reversed word, as shown in the following diagram presenting how to reverse
    `MARCIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.2 – \uFEFFIllustration of the reversing \uFEFFa word example](img/B18069_05_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Illustration of the reversing a word example
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: NICRAM
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: public class Game
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public Stack<int> From { get; private set; }
  prefs: []
  type: TYPE_NORMAL
- en: public Stack<int> To { get; private set; }
  prefs: []
  type: TYPE_NORMAL
- en: public Stack<int> Auxiliary { get; private set; }
  prefs: []
  type: TYPE_NORMAL
- en: public int DiscsCount { get; private set; }
  prefs: []
  type: TYPE_NORMAL
- en: public int MovesCount { get; private set; }
  prefs: []
  type: TYPE_NORMAL
- en: public event EventHandler<EventArgs>? MoveCompleted;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: public Game(int discsCount)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: DiscsCount = discsCount;
  prefs: []
  type: TYPE_NORMAL
- en: From = new Stack<int>();
  prefs: []
  type: TYPE_NORMAL
- en: To = new Stack<int>();
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary = new Stack<int>();
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < discsCount; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int size = discsCount - i;
  prefs: []
  type: TYPE_NORMAL
- en: From.Push(size);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: public async Task MoveAsync(int discs, Stack<int> from,
  prefs: []
  type: TYPE_NORMAL
- en: Stack<int> to, Stack<int> auxiliary)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (discs == 0) { return; }
  prefs: []
  type: TYPE_NORMAL
- en: await MoveAsync(discs - 1, from, auxiliary, to);
  prefs: []
  type: TYPE_NORMAL
- en: to.Push(from.Pop());
  prefs: []
  type: TYPE_NORMAL
- en: MovesCount++;
  prefs: []
  type: TYPE_NORMAL
- en: MoveCompleted?.Invoke(this, EventArgs.Empty);
  prefs: []
  type: TYPE_NORMAL
- en: await Task.Delay(250);
  prefs: []
  type: TYPE_NORMAL
- en: await MoveAsync(discs - 1, auxiliary, to, from);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: public class Visualization
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: private readonly Game _game;
  prefs: []
  type: TYPE_NORMAL
- en: private readonly int _columnSize;
  prefs: []
  type: TYPE_NORMAL
- en: private readonly char[,] _board;
  prefs: []
  type: TYPE_NORMAL
- en: public Visualization(Game game)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: _game = game;
  prefs: []
  type: TYPE_NORMAL
- en: _columnSize = Math.Max(6,
  prefs: []
  type: TYPE_NORMAL
- en: GetDiscWidth(_game.DiscsCount) + 2);
  prefs: []
  type: TYPE_NORMAL
- en: _board = new char[_game.DiscsCount,
  prefs: []
  type: TYPE_NORMAL
- en: _columnSize * 3];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'private int Show, which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The method clears the current content of the console (by calling the `Clear`
    method). Then, it calls the `FillEmptyBoard` and `FillRodOnBoard` methods to clear
    content that should be shown in the console and then fill it with data of the
    current state of rods, one in each call of `FillRodOnBoard`. Next, you show captions
    for each rod, draw the board, as well as write the number of moves and discs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clear the content of the board, you just iterate through all elements in
    the two-dimensional array and set the value of each item to a space, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to learn how to fill a part of the two-dimensional array that is
    related to a particular rod, let’s take a look at the code of `FillRodOnBoard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, the left margin is calculated to add data in the correct section within
    the overall array - that is, within the correct range of columns. The main part
    of the method is the `for` loop, where the number of iterations is equal to the
    number of discs located in the stack. In each iteration, the size of the current
    disc is read using the `ElementAt` extension method (from the `System.Linq` namespace).
    Next, you calculate an index of a row, where the disc should be shown, as well
    as start and end indices for columns. Finally, a `for` loop is used to insert
    the equals sign (`=`) in proper locations in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the auxiliary methods is `Center`. It aims to add additional spaces
    before and after the text, passed as the parameter, to center the text in the
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last used method is named `DrawBoard`. It simply iterates through all elements
    in the two-dimensional array and writes content in the console. The code is shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, let’s take a look at the main code, located in the `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: List<int> items = [2, -4, 1, 8, 5];
  prefs: []
  type: TYPE_NORMAL
- en: Queue<int> queue = new();
  prefs: []
  type: TYPE_NORMAL
- en: items.ForEach(queue.Enqueue);
  prefs: []
  type: TYPE_NORMAL
- en: while (queue.Count > 0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(queue.Dequeue());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'items.ForEach(ConcurrentQueue generic class from the System.Collections.Concurrent
    namespace. This class contains a set of built-in methods to perform various operations
    on the queue, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue` adds an element at the end of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryDequeue` tries to remove an element from the beginning and return it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPeek` tries to return an element from the beginning without removing it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `TryDequeue` and `TryPeek` have a parameter with the `out` keyword. If
    the operation is successful, such methods return `true`, and the result is returned
    as a value of the `out` parameter. Moreover, the `ConcurrentQueue` class also
    contains two properties, namely `Count` to get the number of elements stored in
    the collection and `IsEmpty` to return a value indicating whether the queue is
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find content regarding the `ConcurrentQueue` class at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let’s proceed to two examples representing a
    queue in the context of a call center, with many clients and one or many consultants.
  prefs: []
  type: TYPE_NORMAL
- en: Example – call center with a single consultant
  prefs: []
  type: TYPE_NORMAL
- en: This first example represents a simple approach to the call center solution,
    where there are **many clients** (with different identifiers), and **only one
    consultant**, who answers waiting calls in the same order in which they appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scenario is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.9 – \uFEFFIllustration of the call center with a single consultant\
    \ example](img/B18069_05_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Illustration of the call center with a single consultant example
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding diagram, four calls are performed by clients.
    They are added to the queue with waiting phone calls, namely from clients `#1234`,
    `#5678`, `#1468`, and `#9641`. When a consultant is available, they answer the
    phone. When the call ends, the consultant can answer the next waiting call. According
    to this rule, the consultant will talk with clients in the following order: **#1234**,
    **#5678**, **#1468**, and **#9641**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code of the first class, named `IncomingCall`, which
    represents a single incoming call performed by a client. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The class contains six properties representing a unique identifier of a call
    (`Id`), a client identifier (`ClientId`), the date and time when the call was
    started (`CallTime`), when it was answered (`AnswerTime`), and when it was ended
    (`EndTime`), as well as the name of the consultant (`Consultant`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the code is related to the `CallCenter` class, which
    represents call-related operations. Its fragment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `CallCenter` class contains the `_counter` field with an identifier of the
    last call, which is equal to the number of calls so far. The class also has the
    `Calls` property representing a queue (with `IncomingCall` instances), where data
    of waiting calls is stored. In the constructor, a new instance of the `Queue`
    generic class is created, and its reference is assigned to the `Calls` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the class contains some methods, such as `Call` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create a new instance of the `IncomingCall` class and set values of
    its properties, namely its identifier (together with pre-incrementing the `_counter`
    field), the client identifier (using the `clientId` parameter), and the call time.
    The created instance is added to the queue by calling the `Enqueue` method and
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is `Answer`. It represents the operation of answering the call
    from the person waiting in the queue for the longest time. Such a call is represented
    by the element located at the beginning of the queue. The `Answer` method is shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Within this method, you check whether the queue is empty. If so, the method
    returns `null`, which means that there are no phone calls that can be answered
    by the consultant. Otherwise, the call is removed from the queue (using the `Dequeue`
    method), and its properties are updated by setting the consultant’s name (using
    the `consultant` parameter) and answer time (to the current date and time). At
    the end, the data of the call is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `Call` and `Answer` methods, you also implement the `End` method,
    which is called whenever the consultant ends a call with a particular client.
    In such a case, you only set the end time, as shown in the following piece of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method in the `CallCenter` class is named `AreWaitingCalls`. It returns
    a value indicating whether there are any waiting calls in the queue, using the
    `Count` property of the `Queue` class. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Random random = new();
  prefs: []
  type: TYPE_NORMAL
- en: CallCenter center = new();
  prefs: []
  type: TYPE_NORMAL
- en: center.Call(1234);
  prefs: []
  type: TYPE_NORMAL
- en: center.Call(5678);
  prefs: []
  type: TYPE_NORMAL
- en: center.Call(1468);
  prefs: []
  type: TYPE_NORMAL
- en: center.Call(9641);
  prefs: []
  type: TYPE_NORMAL
- en: while (center.AreWaitingCalls())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: IncomingCall call = center.Answer("Marcin")!;
  prefs: []
  type: TYPE_NORMAL
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  prefs: []
  type: TYPE_NORMAL
- en: answered by {call.Consultant}.");
  prefs: []
  type: TYPE_NORMAL
- en: await Task.Delay(random.Next(1000, 10000));
  prefs: []
  type: TYPE_NORMAL
- en: center.End(call);
  prefs: []
  type: TYPE_NORMAL
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  prefs: []
  type: TYPE_NORMAL
- en: ended by {call.Consultant}.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: void Log(string text) =>
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {text}");
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[13:10:53] Call #1 from client #1234 answered by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:10:56] Call #1 from client #1234 ended by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:10:56] Call #2 from client #5678 answered by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:10:59] Call #2 from client #5678 ended by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:10:59] Call #3 from client #1468 answered by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:11:06] Call #3 from client #1468 ended by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:11:06] Call #4 from client #9641 answered by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13:11:09] Call #4 from client #9641 ended by Marcin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: using System.Collections.Concurrent;
  prefs: []
  type: TYPE_NORMAL
- en: public class CallCenter
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: private int _counter = 0;
  prefs: []
  type: TYPE_NORMAL
- en: public ConcurrentQueue<IncomingCall> Calls
  prefs: []
  type: TYPE_NORMAL
- en: '{ get; private set; }'
  prefs: []
  type: TYPE_NORMAL
- en: public CallCenter() => Calls =
  prefs: []
  type: TYPE_NORMAL
- en: new ConcurrentQueue<IncomingCall>();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: public IncomingCall? Answer(string consultant)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (!Calls.IsEmpty
  prefs: []
  type: TYPE_NORMAL
- en: '&& Calls.TryDequeue(out IncomingCall? call))'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: call.Consultant = consultant;
  prefs: []
  type: TYPE_NORMAL
- en: call.AnswerTime = DateTime.Now;
  prefs: []
  type: TYPE_NORMAL
- en: return call;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return null;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'public bool AreWaitingCalls() => CallCenter class. However, more changes are
    required in the code located in Program.cs, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: void Clients(CallCenter center)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: while (true)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int clientId = random.Next(1, 10000);
  prefs: []
  type: TYPE_NORMAL
- en: IncomingCall call = center.Call(clientId);
  prefs: []
  type: TYPE_NORMAL
- en: 'Log($"Incoming call #{call.Id}'
  prefs: []
  type: TYPE_NORMAL
- en: 'from client #{clientId}");'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log($"Waiting calls in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '{center.Calls.Count}");'
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(random.Next(500, 2000));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: void Consultant(CallCenter center, string name,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleColor color)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: while (true)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(random.Next(500, 1000));
  prefs: []
  type: TYPE_NORMAL
- en: IncomingCall? call = center.Answer(name);
  prefs: []
  type: TYPE_NORMAL
- en: if (call == null) { continue; }
  prefs: []
  type: TYPE_NORMAL
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  prefs: []
  type: TYPE_NORMAL
- en: answered by {call.Consultant}.", color);
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(random.Next(1000, 10000));
  prefs: []
  type: TYPE_NORMAL
- en: center.End(call);
  prefs: []
  type: TYPE_NORMAL
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  prefs: []
  type: TYPE_NORMAL
- en: ended by {call.Consultant}.", color);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: void Log(string text,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleColor color = ConsoleColor.Gray)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.ForegroundColor = color;
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: $"[{DateTime.Now:HH:mm:ss.fff}] {text}");
  prefs: []
  type: TYPE_NORMAL
- en: Console.ResetColor();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: using Priority_Queue;
  prefs: []
  type: TYPE_NORMAL
- en: SimplePriorityQueue<string> queue = new();
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("Marcin", 1);
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("Lily", 1);
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("Mary", 2);
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("John", 0);
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("Emily", 1);
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("Sarah", 2);
  prefs: []
  type: TYPE_NORMAL
- en: queue.Enqueue("Luke", 1);
  prefs: []
  type: TYPE_NORMAL
- en: while (queue.Count > 0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(queue.Dequeue());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: John
  prefs: []
  type: TYPE_NORMAL
- en: Marcin
  prefs: []
  type: TYPE_NORMAL
- en: Lily
  prefs: []
  type: TYPE_NORMAL
- en: Emily
  prefs: []
  type: TYPE_NORMAL
- en: Luke
  prefs: []
  type: TYPE_NORMAL
- en: Mary
  prefs: []
  type: TYPE_NORMAL
- en: Sarah
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: public class IncomingCall
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public int Id { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public int ClientId { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public DateTime CallTime { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public DateTime? AnswerTime { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public DateTime? EndTime { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public string? Consultant { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public bool IsPriority { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: public class CallCenter
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: private int _counter = 0;
  prefs: []
  type: TYPE_NORMAL
- en: public SimplePriorityQueue<IncomingCall> Calls
  prefs: []
  type: TYPE_NORMAL
- en: '{ get; private set; }'
  prefs: []
  type: TYPE_NORMAL
- en: public CallCenter() => Calls =
  prefs: []
  type: TYPE_NORMAL
- en: new SimplePriorityQueue<IncomingCall>();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: public IncomingCall Call(int clientId, bool isPriority)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: IncomingCall call = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Id = ++_counter,
  prefs: []
  type: TYPE_NORMAL
- en: ClientId = clientId,
  prefs: []
  type: TYPE_NORMAL
- en: CallTime = DateTime.Now,
  prefs: []
  type: TYPE_NORMAL
- en: IsPriority = isPriority
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calls.Enqueue(call, isPriority ? 0 : 1);'
  prefs: []
  type: TYPE_NORMAL
- en: return call;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: public IncomingCall? Answer(string consultant)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (!AreWaitingCalls()) { return null; }
  prefs: []
  type: TYPE_NORMAL
- en: IncomingCall call = Calls.Dequeue();
  prefs: []
  type: TYPE_NORMAL
- en: call.Consultant = consultant;
  prefs: []
  type: TYPE_NORMAL
- en: call.AnswerTime = DateTime.Now;
  prefs: []
  type: TYPE_NORMAL
- en: return call;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void End(IncomingCall call) =>
  prefs: []
  type: TYPE_NORMAL
- en: call.EndTime = DateTime.Now;
  prefs: []
  type: TYPE_NORMAL
- en: 'public bool Program.cs file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You may be surprised to learn that only small changes are necessary in this
    part of the code. The reason for this is that the logic regarding a used data
    structure is hidden in the `CallCenter` class. Within the `Program.cs` file, you
    call methods and use properties exposed by the `CallCenter` class. You just need
    to modify how you add calls to the queue (together with priorities), as well as
    adjust logs presented when a call is answered by the consultant, to choose a proper
    color based on the call’s priority. That’s all!
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will receive a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.14 – \uFEFFScreenshot of the call center with priority support example](img/B18069_05_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Screenshot of the call center with priority support example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the calls are served in the correct order. This means that the
    calls from clients with priority support are served earlier than calls from clients
    with the standard support plan, even though such calls need to wait much longer
    to be answered.
  prefs: []
  type: TYPE_NORMAL
- en: Circular queues
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, let’s take a look at another data structure, namely
    a **circular queue**, also called a **ring buffer**. In this case, **a queue forms
    a circle**, internally uses an array, and the maximum number of elements that
    can be placed inside the queue is limited. You need to specify two variables that
    indicate indices of the **front** and **rear** elements. **The front one points
    to the element that will be dequeued first. The rear one points to the element
    that is the last in** **the queue**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a circular queue
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a circular queue, think back to your young years
    when you persuaded your parents to take you on a roller coaster. It consisted
    of 10 carriages, each with room for 2 people, so only 20 people could take part
    in 1 roller coaster ride. As this was a unique attraction, such a ride took place
    only once an hour. This meant that only 20 people were allowed to enter a queue
    for the roller coaster and no one else. As the departure date approached, people
    were admitted to it in the order in which they were admitted to the queue. And
    a circular queue works similarly! It has some specific capacity, and nothing else
    can be enqueued to it. However, when you dequeue elements, new ones can be added
    in place of the previous ones. Well, it means that after an hour, you can fill
    a queue for the roller coaster with new people!
  prefs: []
  type: TYPE_NORMAL
- en: 'The mentioned data structure is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.15 – \uFEFFIllustration of a circular queue](img/B18069_05_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Illustration of a circular queue
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, the circular queue is empty, so both `-1`. Then, you add `2`,
    `-4`, `1`, and `8` elements, and this state is shown in the first step in the
    preceding diagram. Here, the front index is equal to `0`, and the rear one to
    `3`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you perform an `5` is located at index `4`, as shown in the
    third step in the preceding diagram. Of course, the rear index is updated to `4`
    while the front index remains the same, namely `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The following step shows a `2` is returned, and the front index is changed to
    `1`. It means that currently, the circular queue stores `4` elements in the part
    of the array between `1` (the front index) and `4` (the rear index).
  prefs: []
  type: TYPE_NORMAL
- en: What about the performance?
  prefs: []
  type: TYPE_NORMAL
- en: The performance results are great in this case! Both the `Enqueue` and the `Dequeue`
    methods are *O(1)* operations, as you don’t need to iterate through an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform many more *enqueue* and *dequeue* operations to see how the
    content of the queue “rotates” within a circular queue. To do so, you need to
    implement this data structure. Let’s write some code, starting with the `CircularQueue`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a generic class that uses the primary constructor taking the maximum
    number of elements in the queue as the `size` parameter. You can see four private
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: An array with the stored items (`_items`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An index of the front and rear elements in the queue (`_front` and `_rear`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current number of elements located in the circular queue (`_count`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The public read-only `Count` property is added as well, which returns the value
    of the `_count` field. If everything is clear for you, let’s take a look at the
    `Enqueue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the beginning, you need to check whether you have any space within the circular
    queue, so you compare the current number of elements in the queue (`_count`) with
    the length of the array storing such data (`_items`). If these values are equal,
    you return `false` because there is no space, so you cannot enqueue any element.
  prefs: []
  type: TYPE_NORMAL
- en: The next line checks whether the circular queue is empty, which means that the
    front index is smaller than `0`. If so, both front and rear indices are set to
    `0`. It indicates that there is only one element in the circular queue, and it
    is pointed to by both these indices.
  prefs: []
  type: TYPE_NORMAL
- en: If there is already something in the queue, you increment a value of the rear
    index. If it is equal to the number of elements in the array, you assign `0` to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the last three lines, you add the new item to the place indicated by the
    rear index (`_rear`), increment the counter storing the number of elements currently
    located in the queue (`_count`), as well as return `true` indicating that the
    enqueue operation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now move to the `Dequeue` method, the code of which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, you check whether the circular queue is empty. If so, you return a `null`
    value. Otherwise, you save as `result` a value indicated by the front index. Such
    a value will be returned at the end of this method.
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines, you check whether the front and rear indices are equal.
    It means that there is only one element in the queue. If so, you set both these
    indices to `-1`, which indicates that the circular queue is empty. Otherwise,
    you increment the front index. If it is equal to the number of elements in the
    array, you assign `0` to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two lines, you just decrement the number of elements in the queue,
    as well as return the previously saved value (`result`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method is named `Peek` and is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This method just returns the first item in the queue without removing it from
    the queue. Of course, it returns `null` if the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the implementation of a circular queue is not difficult and
    requires a small number of lines of code. So, let’s see it in action with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines perform the operations shown in the diagram presenting a
    circular queue (*Figure 5**.15*). You create a new circular queue with places
    for eight elements of the `int` type. Then, you add `2`, `-4`, `1`, `8`, and `5`
    values and dequeue one element.
  prefs: []
  type: TYPE_NORMAL
- en: After the introduction to the topic of circular queues, it is high time to take
    a look at a real-world example.
  prefs: []
  type: TYPE_NORMAL
- en: Example – gravity roller coaster
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s simulate the behavior of a gravity roller coaster located on a mountainside.
    There can be a maximum of 12 carts on this queue at the same time, which slide
    down the chute accelerated by gravity. After the participant enters the cart,
    it accelerates automatically, and there are several turns on its path. After reaching
    the foot of the mountain, the cart and the participant are pulled in using a simple
    pulley. The participant gets off at the same place where they boarded the cart,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.16 – \uFEFFIllustration of a gravity roller coaster example](img/B18069_05_16.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Illustration of a gravity roller coaster example
  prefs: []
  type: TYPE_NORMAL
- en: You can simulate this example using a circular queue with the maximum size set
    to 12, which means that a maximum of 12 people can currently be on this gravity
    roller coaster. Another person will not be admitted until a seat becomes available.
    Entering the cart means performing an *enqueue* operation, and leaving the cart
    means performing a *dequeue* operation. It is also worth mentioning that it is
    not possible to change the order in which participants are served. Whoever enters
    the queue first will be let out first, which is consistent with the FIFO principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code, which is located in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, you specify a `QueueItem` alias for the value tuple type consisting of
    cart entering time and the chosen color. Then, the ride length is set to 10 seconds,
    as well as some additional variables being created, including the circular queue
    and the last used color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It contains an infinite `while` loop. Within it, you first check which items
    should be dequeued, which means that the ride time (that is, 10 seconds) elapsed
    for them. If so, you also log the message. Then, you draw a random number to decide
    whether a new item should be added to the circular queue in this iteration of
    an infinite `while` loop. If so, you choose the next color from the `ConsoleColor`
    enumeration, try to enqueue a new item to the queue, as well as log the message.
    At the end of the iteration, you wait 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the auxiliary `Log` method is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code, you get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.17 – \uFEFFScreenshot of the gravity roller coaster example](img/B18069_05_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Screenshot of the gravity roller coaster example
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you now know how to use a few types of queues! You took a
    look at a regular one, a priority queue, as well as a circular one, together with
    examples. So, it is high time to summarize the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about two limited access data structures, namely
    stacks and queues, including regular, priority, and circular ones. It is worth
    remembering that such data structures have strictly specified ways of accessing
    elements. All of them also have various real-world applications. Some of them
    were mentioned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, you saw how a **stack** operates according to the LIFO principle. In
    this case, you can add an element at the top of the stack (a *push* operation),
    and remove an element from the top (a *pop* operation). The stack was shown in
    two examples, namely for reversing a word and for solving the *Tower of Hanoi*
    mathematical game.
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the chapter, you got to know a **queue** as a data
    structure, which operates according to the FIFO principle. In this case, *enqueue*
    and *dequeue* operations were presented. The queue was explained using two examples,
    both regarding the application simulating a call center. You learned how to use
    a thread-safe variant of a queue-related class, which is available while developing
    applications in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: The next data structure shown in this chapter is named a **priority queue**
    and is an extension of a queue that supports the priorities of particular elements.
    In the end, you learned about a **circular queue**, which expands the concept
    of a regular queue by forming a circle, where the first and rear elements are
    indicated by indices.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the fifth chapter of this book, and you already learned a lot about
    various data structures and algorithms that are useful while developing applications
    in C#! Are you interested in increasing your knowledge by learning about **dictionaries**
    and **sets**? If so, let’s proceed to the next chapter and learn more about them!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
