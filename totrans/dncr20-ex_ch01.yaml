- en: Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: In this chapter, we are going to learn about tools used to perform development
    tasks for .NET Core 2.0 on Windows and Linux operating systems. Also, we will
    learn how to set up Linux and virtualization using VirtualBox and Hyper-V. This
    chapter will cover how to install .NET Core 2.0 and tools for Windows and Linux
    (Ubuntu). We will learn about the **virtual machine** (**VM**) setup for Ubuntu
    and create your first simple .NET Core 2.0 running application code. We will configure
    the VM to manage your first application. The purpose of this chapter is to get
    a general idea of the required tools and how to install .NET core 2.0 SDK for
    Windows and Linux, and give you basic F# understanding.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习用于在Windows和Linux操作系统上执行.NET Core 2.0开发任务的工具。我们还将学习如何使用VirtualBox和Hyper-V设置Linux和虚拟化。本章将涵盖如何为Windows和Linux（Ubuntu）安装.NET
    Core 2.0和工具。我们将了解Ubuntu的**虚拟机**（**VM**）设置，并创建您的第一个简单的.NET Core 2.0运行应用程序代码。我们将配置VM以管理您的第一个应用程序。本章的目的是让您对所需的工具有一个大致的了解，以及如何为Windows和Linux安装.NET
    Core 2.0 SDK，并为您提供基本的F#理解。
- en: 'This chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Downloading the required tools for Windows and Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载Windows和Linux所需的工具
- en: Installing .NET Core 2.0 and tools (Windows)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装.NET Core 2.0和工具（Windows）
- en: Setting up an Ubuntu Linux VM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Ubuntu Linux虚拟机
- en: Installing .NET Core 2.0 and tools (Linux)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装.NET Core 2.0和工具（Linux）
- en: Creating simple running code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单可运行的代码
- en: F# primer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#入门
- en: Downloading required tools for Windows and Linux
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Windows和Linux所需的工具
- en: In this section, we will discuss the prerequisites to be downloaded for both
    Windows and Linux operating systems to start development with .NET Core 2.0\.
    We will start with Windows and then move to Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论为Windows和Linux操作系统下载的先决条件，以便开始使用.NET Core 2.0进行开发。我们将从Windows开始，然后转到Linux。
- en: Downloads for Windows
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows下载
- en: Microsoft offers the Visual Studio **integrated development environment** (**IDE**)
    for developers to develop computer programs for Microsoft Windows, as well as
    websites, web applications, web services, and mobile applications. Microsoft gives
    us the choice to pick from four Visual Studio adaptations—Community, Professional,
    Enterprise, and Code. You can download one of these, depending on your individual
    prerequisite. How these versions differ from each other is explained next.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为开发者提供了Visual Studio **集成开发环境**（**IDE**），用于开发适用于Microsoft Windows的计算机程序，以及网站、Web应用、Web服务和移动应用。微软为我们提供了从四个Visual
    Studio版本中选择的机会——社区版、专业版、企业版和代码版。您可以根据个人需求下载其中一个版本。下面将解释这些版本之间的区别。
- en: Navigate to [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)
    in the browser of your choice. You will see four choices. Select the Visual Studio
    product based on your requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的浏览器中导航到[https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)。您将看到四个选项。根据您的需求选择Visual
    Studio产品。
- en: 'All versions of Visual Studio 2017 are available for Windows and Macintosh
    operating systems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有版本的Visual Studio 2017都适用于Windows和Macintosh操作系统：
- en: '**Visual Studio Community**: This is a free, open source version of Visual
    Studio with limited features. This is for the individual developer.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Community**：这是一个具有有限功能的免费开源版本，适用于个人开发者。'
- en: '**Visual Studio Professional**: This version has professional developer tools,
    services, and subscription benefits for small teams (five members).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Professional**：这个版本为小型团队（五人以下）提供了专业的开发工具、服务和订阅优惠。'
- en: '**Visual Studio Enterprise**: This version supports all Visual Studio features
    and is meant for end-to-end solution development to meet the demanding quality
    and scaling needs of teams of all sizes. It is great for enterprise organizations.
    Some of the key features that come with this version are testing tools, architectural
    layer diagrams, live dependency validation, architecture validation, code clone
    detection, IntelliTrace, .NET memory dump analysis, and so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Enterprise**：这个版本支持所有Visual Studio功能，旨在满足所有规模团队的端到端解决方案开发的需求，以满足对质量和扩展性的严格要求。它非常适合企业组织。这个版本包含的一些关键功能包括测试工具、架构层图、实时依赖项验证、架构验证、代码克隆检测、IntelliTrace、.NET内存转储分析等等。'
- en: '**Visual Studio Code**: This is a free, open source version and cross-platform
    (Linux, macOS, Windows) editor that can be extended with plugins to meet your
    needs. It includes support for debugging, embedded Git control, syntax highlighting,
    extension support, intelligent code completion, snippets, and code refactoring.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：这是一个免费、开源且跨平台（Linux、macOS、Windows）的编辑器，可以通过插件扩展以满足您的需求。它包括调试支持、内嵌
    Git 控制、语法高亮、扩展支持、智能代码补全、代码片段和代码重构。'
- en: Make a note that Visual Studio is an IDE, while Visual Studio Code is an editor,
    just like Notepad is an editor. So Visual Studio Code is much more lightweight,
    fast, and fluid with great support for debugging and has embedded Git control.
    It is a cross-platform editor and supports Windows, Linux, and Macintosh. Debugging
    support is good and has rich IntelliSense and refactoring. Like most editors,
    it is keyboard-centric. It is a file and folders-based editor and doesn't need
    to know the project context, unlike an IDE. There is no File | New Project support
    in Visual Studio Code as you would be used to in Visual Studio IDE. Instead, Visual
    Studio Code offers a terminal, through which we can run dotnet command lines to
    create new projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Visual Studio 是一个集成开发环境 (IDE)，而 Visual Studio Code 是一个编辑器，就像记事本是一个编辑器一样。因此，Visual
    Studio Code 更轻量级、更快、更流畅，并提供了出色的调试支持和内嵌的 Git 控制。它是一个跨平台编辑器，支持 Windows、Linux 和 Macintosh。调试支持良好，拥有丰富的智能感知和重构功能。像大多数编辑器一样，它以键盘为中心。它是一个基于文件和文件夹的编辑器，不需要了解项目上下文，与
    IDE 不同。Visual Studio Code 中没有文件 | 新建项目支持，就像你在 Visual Studio IDE 中所习惯的那样。相反，Visual
    Studio Code 提供了一个终端，我们可以通过它运行 dotnet 命令行来创建新项目。
- en: 'So, for development in Windows, we can use either of these:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Windows 上进行开发时，我们可以使用这两个中的任何一个：
- en: Visual Studio 2017 IDE
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017 集成开发环境 (IDE)
- en: Visual Studio Code editor
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code 编辑器
- en: If we choose Visual Studio 2017, all we need to do is download Visual Studio
    2017 version 15.3 from [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads).
    It comes bundled with the .NET Core 2.0 SDK and its templates and so we will be
    ready for development immediately after installing it. Also with Visual Studio
    2017, F# tools automatically get installed once we create an F# project or open
    an F# project for the very first time. So, the F# development setup is taken care
    of as well. We will see the installation of Visual Studio 2017 in the *Installing
    .NET Core 2.0 and tools (Windows)* section of this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择 Visual Studio 2017，我们只需要从 [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)
    下载 Visual Studio 2017 版本 15.3。它捆绑了 .NET Core 2.0 SDK 以及其模板，因此安装后我们就可以立即开始开发了。此外，使用
    Visual Studio 2017，一旦我们创建一个 F# 项目或首次打开一个 F# 项目，F# 工具就会自动安装。因此，F# 开发环境也得到了妥善处理。我们将在本章的
    *安装 .NET Core 2.0 和工具 (Windows)* 部分看到 Visual Studio 2017 的安装过程。
- en: If we choose Visual Studio Code for development, we need to download Visual
    Studio Code from [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    and the .NET Core 2.0.0 SDK from [https://www.microsoft.com/net/core#windowscmd](https://www.microsoft.com/net/core#windowscmd)
    . We will look at the installation of Visual Studio Code in the *Installing .NET
    Core 2.0 and tools (Windows)* section of this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择 Visual Studio Code 进行开发，我们需要从 [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    下载 Visual Studio Code，并从 [https://www.microsoft.com/net/core#windowscmd](https://www.microsoft.com/net/core#windowscmd)
    下载 .NET Core 2.0.0 SDK。我们将在本章的 *安装 .NET Core 2.0 和工具 (Windows)* 部分查看 Visual Studio
    Code 的安装过程。
- en: Downloads for Linux
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 的下载
- en: As mentioned in the preceding section, Microsoft Visual Studio Code is a cross-platform
    editor, and it supports Linux operating systems. So, we are going to use Visual
    Studio Code to create all the example applications on Linux in this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Microsoft Visual Studio Code 是一个跨平台编辑器，支持 Linux 操作系统。因此，我们将使用 Visual Studio
    Code 在本书中创建所有 Linux 示例应用程序。
- en: 'Let''s start downloading the tools required to stop our development of .NET
    Core 2.0 applications on the Linux operating system:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始下载停止在 Linux 操作系统上开发 .NET Core 2.0 应用程序所需的工具：
- en: 'Download Visual Studio Code from [https://code.visualstudio.com/](https://code.visualstudio.com/). We
    are going to install the Ubuntu 32-bit version, so we will download the Visual
    Studio Code 32-bit version. Select the Linux x86 .deb stable package for download,
    as shown in the following image:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://code.visualstudio.com/](https://code.visualstudio.com/) 下载 Visual
    Studio Code。我们将安装 Ubuntu 32 位版本，因此我们将下载 Visual Studio Code 32 位版本。选择下载以下图像所示的
    Linux x86 .deb 稳定包：
- en: '![](img/bd3b09a2-0088-4160-9a8a-3f0f0d44778d.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd3b09a2-0088-4160-9a8a-3f0f0d44778d.png)'
- en: If you have a Linux machine handy, you can skip the next download step. If you
    wish to try development on the Linux platform and have a Windows machine to work
    with, then the next two steps are for you.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手头有一台Linux机器，你可以跳过下一个下载步骤。如果你想在Linux平台上尝试开发并且有一台Windows机器可以工作，那么接下来的两个步骤就是为你准备的。
- en: 'Download VirtualBox from [https://www.virtualbox.org/](https://www.virtualbox.org/).
    It is Oracle''s open source general-purpose full virtualizer. At the time of writing
    this chapter, the latest version of VirtualBox is 5.1\. The version 5.1.26 was
    released on July 27, 2017\. Using this, we will set up a Linux (Ubuntu) virtual
    machine on the Windows host machine. Click on Download VirtualBox `5.1.` It will
    open a page that has options on VirtualBox binaries. We can select an option based
    on the machine on which we are installing it. We are installing it on a Windows
    machine, so we will click on Windows hosts. In a similar way, we can select different
    platforms. On clicking Windows hosts, it will download the VirtualBox executable
    `VirtualBox-5.1.26-117224-Win.exe`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.virtualbox.org/](https://www.virtualbox.org/)下载VirtualBox。它是Oracle的开源通用全虚拟化器。在撰写本章时，VirtualBox的最新版本是5.1。5.1.26版本于2017年7月27日发布。使用这个版本，我们将在Windows主机上设置一个Linux（Ubuntu）虚拟机。点击下载VirtualBox
    `5.1.`，它将打开一个包含VirtualBox二进制选项的页面。我们可以根据安装的机器选择一个选项。我们是在Windows机器上安装它，所以我们将点击Windows主机。以类似的方式，我们可以选择不同的平台。点击Windows主机后，它将下载VirtualBox可执行文件`VirtualBox-5.1.26-117224-Win.exe`：
- en: '![](img/61e988ca-8ed5-44f4-8dc2-d788287dbbb1.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61e988ca-8ed5-44f4-8dc2-d788287dbbb1.png)'
- en: VirtualBox needs the Ubuntu **International Standards Organization** (**ISO**)
    image to create the Ubuntu VM, so next we need to download the ISO image of Ubuntu.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox需要Ubuntu的国际标准化组织（ISO）镜像来创建Ubuntu虚拟机，因此接下来我们需要下载Ubuntu的ISO镜像。
- en: 'Download the ISO image of Ubuntu by navigating to [https://www.ubuntu.com](https://www.ubuntu.com).
    By default, the virtual machine software uses 32-bit Linux, so we will select
    32-bit. Hover over the Downloads menu and click on the highlighted Desktop link:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[https://www.ubuntu.com](https://www.ubuntu.com)下载Ubuntu的ISO镜像。默认情况下，虚拟机软件使用32位Linux，因此我们将选择32位。将鼠标悬停在下载菜单上，并点击高亮的桌面链接：
- en: '![](img/06faca8a-c433-4ec0-8eef-95fda0c6567c.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06faca8a-c433-4ec0-8eef-95fda0c6567c.png)'
- en: It will take us to the downloads page for the desktop. Click Download on Ubuntu
    for the desktop. It will start the download of Ubuntu 17.04 ISO. An ISO image
    of approximately 1.5 GB will be downloaded.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它将带我们到桌面下载页面。点击下载桌面版的Ubuntu。它将开始下载Ubuntu 17.04 ISO。将下载大约1.5GB的ISO镜像。
- en: 'Download .NET Core 2.0 SDK from [https://www.microsoft.com/net/download/linux](https://www.microsoft.com/net/download/linux):'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.microsoft.com/net/download/linux](https://www.microsoft.com/net/download/linux)下载.NET
    Core 2.0 SDK：
- en: '![](img/b1447c9e-07fc-4ddc-bc33-a195c281f2c2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1447c9e-07fc-4ddc-bc33-a195c281f2c2.png)'
- en: With this, we are done with the downloads for our setup in Linux. In the next
    section, we will learn how to install and set up these tools.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们已经完成了Linux设置所需的下载。在下一节中，我们将学习如何安装和设置这些工具。
- en: '**Ubuntu 17.04**: As of writing this chapter, this is the latest version, and
    its code name is **Zesty Zapus**, released on April 13, 2017\. Ubuntu releases
    carry a version number in the form of `XX.YY`, with `XX` representing the year
    and `YY` representing the month of the official release. For example, the latest
    version released in April 2017 is represented by 17 (year) and 04 (month). Ubuntu
    code names use an adjective animal combination, that is an adjective word followed
    by the name of an animal, typically one that''s unique. At the time of writing,
    Ubuntu 17.10 is due to be released in October 2017; examples covered here used
    the Ubuntu 17.04 version.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu 17.04**：在撰写本章时，这是最新版本，其代号为**Zesty Zapus**，于2017年4月13日发布。Ubuntu版本以`XX.YY`的形式表示，其中`XX`代表年份，`YY`代表官方发布月份。例如，2017年4月发布的最新版本表示为17（年份）和04（月份）。Ubuntu的代号使用形容词动物组合，即形容词词后跟动物名称，通常是独特的。在撰写本章时，Ubuntu
    17.10预计将于2017年10月发布；这里涵盖的示例使用了Ubuntu 17.04版本。'
- en: Installing .NET Core 2.0 and tools (Windows)
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装.NET Core 2.0和工具（Windows）
- en: 'Now that we are done with the downloads, it''s time to install. As seen in
    the last section on Windows, we have two options for development in Windows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了下载，是时候安装了。正如上一节在Windows中看到的，我们在Windows中进行开发有两个选项：
- en: Visual Studio 2017 version 15.3
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017版本15.3
- en: Visual Studio Code
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Based on your choice, you can follow the appropriate installation steps.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的选择，您可以遵循适当的安装步骤。
- en: Installing Visual Studio 2017 version 15.3
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio 2017版本15.3
- en: 'Double-click on the executable file downloaded for Visual Studio 2017 version
    15.3 in the earlier section. This will start the installation. C# comes by default
    in every Visual Studio installation, so there is nothing to do for C#. Visual
    Studio 2017 also comes with F# support in all its editions: Community, Professional,
    and Enterprise. F# is an optional component though. The installer includes it
    as a selectable workload, or you can select it manually in the Individual components
    tab, under the Development activities category. Select F# language support:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 双击前面部分下载的Visual Studio 2017版本15.3的可执行文件。这将启动安装过程。C#在Visual Studio的每个安装中都是默认的，因此对于C#不需要做任何事情。Visual
    Studio 2017的所有版本（社区版、专业版和企业版）都包含F#支持。尽管F#是一个可选组件，但安装程序将其作为可选的工作负载提供，或者您可以在“开发活动”类别下的“单独组件”选项卡中手动选择它。选择F#语言支持：
- en: '![](img/a40121a2-39ee-4b89-8043-45f8b6a8c1ef.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a40121a2-39ee-4b89-8043-45f8b6a8c1ef.png)'
- en: 'Visual Studio 2017 version 15.3 comes with the .NET Core SDK. Select .NET Core
    cross-platform development under Workloads during the Visual Studio 2017 version
    15.3 installation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017版本15.3附带.NET Core SDK。在安装Visual Studio 2017版本15.3时，在工作负载下选择.NET
    Core跨平台开发：
- en: '![](img/0559c9f4-6be3-4749-b440-9e8decac83a9.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0559c9f4-6be3-4749-b440-9e8decac83a9.jpg)'
- en: For other versions of Visual Studio, download the .NET Core 2.0 SDK from [https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core),
    or update Visual Studio to 2017 15.3 and select .NET Core cross-platform development
    under Workloads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Visual Studio的其他版本，从[https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)下载.NET
    Core 2.0 SDK，或将Visual Studio更新到2017 15.3并选择“工作负载”下的.NET Core跨平台开发。
- en: Installing Visual Studio Code
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio Code
- en: 'Install Visual Studio Code by double-clicking the Visual Studio Code setup
    executable from its download location. It''s a simple installation for Windows. Once
    Visual Studio Code is installed, launch it. The following screenshot shows the
    user interface layout of Visual Studio Code. It follows the conventional editor
    style and displays files and folders you have access to on the left side and the
    code content in the editor on the right side. It can be roughly divided into seven
    sections, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击从其下载位置下载的Visual Studio Code设置可执行文件来安装Visual Studio Code。这是一个简单的Windows安装。一旦安装了Visual
    Studio Code，启动它。下面的截图显示了Visual Studio Code的用户界面布局。它遵循传统的编辑器风格，在左侧显示您有权访问的文件和文件夹，在编辑器的右侧显示代码内容。它可以大致分为七个部分，如下面的截图所示：
- en: '![](img/fe03fcab-ec66-4669-a23e-6cc4927d1e13.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe03fcab-ec66-4669-a23e-6cc4927d1e13.png)'
- en: 'Let''s discuss them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下：
- en: '**Menu bar**: The standard menu bar for doing various operations in the editor,
    such as opening a file/folder, editing, viewing and installing extensions, changing
    themes, debugging, running and configuring tasks, and getting help.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**菜单栏**：编辑器中执行各种操作的标准菜单栏，例如打开文件/文件夹、编辑、查看和安装扩展、更改主题、调试、运行和配置任务以及获取帮助。'
- en: '**Activity bar**: Groups the most commonly performed activities on the leftmost
    side of the editor. It lets the user switch between the views. It is customizable
    and lets the user choose the views to be displayed in the bar, by right-clicking
    on the bar and selecting/unselecting the views. The bar itself can be hidden in
    the same way. By default, it has five views, as shown in the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**活动栏**：将编辑器中最常执行的活动分组在左侧。它允许用户在视图之间切换。它是可定制的，并允许用户通过在栏上右键单击并选择/取消选择视图来选择要在栏中显示的视图。栏本身也可以以相同的方式隐藏。默认情况下，它有五个视图，如下面的截图所示：'
- en: '![](img/37501094-9eb2-412c-af94-1c9871a30aa0.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37501094-9eb2-412c-af94-1c9871a30aa0.png)'
- en: '**EXPLORER**: This view lets your browse, open, and manage all the files and
    folders in your project. You can create, delete, and rename files and folders,
    as well as move files and folders from here. You can also open the files/folders
    in Terminal (Command Prompt in Windows) from here by right-clicking and selecting Open
    in Command Prompt. You can find the file/folder location as well from here.'
  id: totrans-59
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器**：此视图允许您浏览、打开和管理项目中的所有文件和文件夹。您可以创建、删除和重命名文件和文件夹，以及从此处移动文件和文件夹。您还可以通过右键单击并选择“在命令提示符中打开”来在此处打开文件/文件夹。您还可以从这里找到文件/文件夹的位置。'
- en: '**SEARCH**: This view lets you search and replace globally across your open
    folder.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：此视图允许您在打开的文件夹中全局搜索和替换。'
- en: '**SOURCE CONTROL**: This lets you work with Git source control by default.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码控制**：默认情况下，这允许您使用 Git 源代码控制。'
- en: '**DEBUG**: This view displays the breakpoints, variables, and call stack for
    debugging.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DEBUG**：此视图显示调试用的断点、变量和调用堆栈。'
- en: '**EXTENSIONS**: This is used to install and manage extensions in Visual Studio
    Code.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：用于在 Visual Studio Code 中安装和管理扩展。'
- en: '**Side bar**: This contains the view selected from the activity bar.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**侧边栏**：包含从活动栏中选定的视图。'
- en: '**Command Palette**: As stated earlier, Visual Studio Code is keyboard-centric,
    so anyone who loves using a keyboard is going to have a great time working on
    Visual Studio Code. The *Ctrl *+ *Shift *+ *P* key combination brings up what
    is called a Command Palette. We can access all the functionality of Visual Studio
    Code from here. To make effective use of Visual Studio Code, it is highly recommended
    that the reader makes himself/herself well versed with the commands from the help
    menu item links:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**命令面板**：如前所述，Visual Studio Code 以键盘为中心，因此任何喜欢使用键盘的人都会在 Visual Studio Code
    上工作得非常愉快。*Ctrl* + *Shift* + *P* 键组合会弹出所谓的命令面板。我们可以从这里访问 Visual Studio Code 的所有功能。为了有效地使用
    Visual Studio Code，强烈建议读者熟悉帮助菜单项链接中的命令：'
- en: '![](img/ad6810b3-2259-47e5-a467-02876b7ef96a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad6810b3-2259-47e5-a467-02876b7ef96a.png)'
- en: '**Editor**: The editor is where the content of the file is displayed and the
    user can edit it. Visual Studio Code provides a feature called Split Editor (open
    to the side in Linux). Go to the View menu in the menu bar and select Split Editor
    (alternatively you can type the command *Ctrl* +*\*). This will create a new editor
    region, where you can edit a group of files. These regions are called editor groups.
    The open editors can also be seen in the Explorer view in the sidebar. Visual
    Studio Code allows up to three editor groups, designated as LEFT, CENTER, and
    RIGHT**,** as shown in the following screenshot:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑器**：编辑器是显示文件内容并允许用户编辑的地方。Visual Studio Code 提供了一个名为 Split Editor（在 Linux
    中侧向打开）的功能。转到菜单栏中的“视图”菜单并选择 Split Editor（或者您也可以输入命令 *Ctrl* +*\*）。这将创建一个新的编辑器区域，您可以在其中编辑一组文件。这些区域被称为编辑器组。打开的编辑器也可以在侧边栏的“资源管理器”视图中看到。Visual
    Studio Code 允许最多三个编辑器组，分别标记为 LEFT、CENTER 和 RIGHT****，如下面的截图所示：'
- en: '![](img/7664a48d-5c8d-4cd1-8f9e-25a63919783f.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7664a48d-5c8d-4cd1-8f9e-25a63919783f.png)'
- en: '**Panels**: Displays the TERMINAL, OUTPUT, PROBLEMS, and DEBUG CONSOLE panes
    below the editor. To see it in action, go to the View menu and click any of the
    menu items from PROBLEMS, OUTPUT, DEBUG CONSOLE, and TERMINAL. Alternatively,
    you can also press their corresponding commands. We will see more on panels when
    we write our first application.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**面板**：在编辑器下方显示 TERMINAL、OUTPUT、PROBLEMS 和 DEBUG CONSOLE 面板。要查看其操作，请转到“视图”菜单并点击“PROBLEMS”、“OUTPUT”、“DEBUG
    CONSOLE”和“TERMINAL”中的任何菜单项。或者，您也可以按相应的命令。当我们编写第一个应用程序时，我们将更详细地了解面板。'
- en: '**Status Bar**: Displays information about the opened project and files being
    edited, such as errors, warnings, current line and column number, encoding, and
    file type.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**状态栏**：显示有关打开的项目和正在编辑的文件的信息，例如错误、警告、当前行和列号、编码和文件类型。'
- en: Now we are familiar with Visual Studio Code, its layout, and basic functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Visual Studio Code 的布局和基本功能。
- en: Go to the Help menu and explore in detail the features that Visual Studio Code
    offers. The Interactive Playground highlights a number of features in Visual Studio
    Code and also lets you interactively try them out. The Help menu also has Documentation,
    Introductory Videos, Tips and Tricks, which are very handy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 转到“帮助”菜单并详细了解 Visual Studio Code 提供的功能。交互式游乐场突出了 Visual Studio Code 的一些功能，并允许您交互式地尝试它们。帮助菜单还包括文档、入门视频、技巧和窍门，这些都非常实用。
- en: Remember, Visual Studio Code is an editor and therefore we need to add support
    for the language we want to work with through extensions. Visual Studio Code is
    very rich in extensions. For our example and for the purpose of learning .NET
    Core 2.0, we will install extensions for C# and F#, as we will be working with
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Visual Studio Code 是一个编辑器，因此我们需要通过扩展来添加我们想要使用的语言的支撑。Visual Studio Code 的扩展非常丰富。对于我们的示例以及学习
    .NET Core 2.0 的目的，我们将安装 C# 和 F# 的扩展，因为我们将会使用它们。
- en: 'Let''s start with C#, as after a fresh install we do not have support for C#
    and hence there would be no IntelliSense to work with on the editor. To install
    C#, let''s switch to Extension View and search for `C#`. We will choose C# for
    Visual Studio Code (powered by OmniSharp)**,** as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 C# 开始，因为在新安装后我们没有 C# 的支持，因此在编辑器上不会有智能感知可用。要安装 C#，让我们切换到扩展视图并搜索 `C#`。我们将选择
    Visual Studio Code 的 C#（由 OmniSharp 提供支持）**，**如图所示：
- en: '![](img/828306d3-72fc-4b35-a66a-a1d348ce5dc0.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/828306d3-72fc-4b35-a66a-a1d348ce5dc0.png)'
- en: Click Install and then click on Reload and Visual Studio Code will start supporting
    C# along with its IntelliSense.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击安装，然后点击重新加载，Visual Studio Code 将开始支持 C# 以及其智能感知。
- en: 'Similarly, search `F#` and Install it. We will be using the Ionide-fsharp extension,
    as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，搜索 `F#` 并安装它。我们将使用如图所示的 Ionide-fsharp 扩展：
- en: '![](img/72c491b3-1f54-4104-81b9-3c974e688265.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72c491b3-1f54-4104-81b9-3c974e688265.png)'
- en: 'With Visual Studio Code, we need to install .NET Core SDK - 2.0.0 (x64) also,
    as Visual Studio Code doesn''t install it. Double-click on the executable of .NET
    Core 2.0 SDK to install it, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code，我们还需要安装 .NET Core SDK - 2.0.0 (x64)，因为 Visual Studio Code
    不会安装它。双击 .NET Core 2.0 SDK 的可执行文件来安装它，如图所示：
- en: '![](img/07de42a5-167b-471f-a8d5-7e750de63b49.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07de42a5-167b-471f-a8d5-7e750de63b49.png)'
- en: And with this, we are done with the installation of our prerequisites for development
    on the Windows platform. Next, we will set up a Linux (Ubuntu) VM and perform
    the installation of prerequisites there. If you are using a Windows platform and
    do not wish to set up a Linux VM, the next section can be skipped.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了在 Windows 平台上开发的前置安装。接下来，我们将设置一个 Linux (Ubuntu) 虚拟机，并在那里安装前置条件。如果您使用的是
    Windows 平台并且不想设置 Linux 虚拟机，可以跳过下一节。
- en: The Visual Studio Code user interface was developed on the Electron framework,
    which is an open source framework used to build cross-platform desktop applications
    with JavaScript, HTML, and CSS. The editor is powered by Microsoft's Monaco Editor
    and gets its intelligence from OmniSharp/Roslyn and TypeScript. As all of these
    are open source, you can search them and see the source code in GitHub.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 用户界面是在 Electron 框架上开发的，这是一个用于使用 JavaScript、HTML 和 CSS 构建跨平台桌面应用程序的开源框架。编辑器由微软的
    Monaco 编辑器提供动力，并从 OmniSharp/Roslyn 和 TypeScript 获取智能。由于这些都是开源的，您可以在 GitHub 中搜索它们并查看源代码。
- en: Setting up an Ubuntu Linux VM
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Ubuntu Linux 虚拟机
- en: 'In this section, we will see how to set up Linux (Ubuntu) on a virtual machine,
    so that a Windows user can also develop and test their .NET Core 2.0 applications
    in Linux. To do so, let’s start with the VirtualBox setup. Oracle provides an
    open source VirtualBox executable, which we downloaded in the previous section.
    The following are the steps we need to follow to set up VirtualBox:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在虚拟机上设置 Linux (Ubuntu)，以便 Windows 用户也能在 Linux 上开发和测试他们的 .NET Core
    2.0 应用程序。为此，让我们从 VirtualBox 设置开始。Oracle 提供了一个开源的 VirtualBox 可执行文件，我们在上一节中已下载。以下是我们需要遵循的步骤来设置
    VirtualBox：
- en: Double-click on the VirtualBox executable. It will open a wizard. Before installation,
    click on Disk usage and check Disk Space Requirement. It is recommended that the
    virtual machine for Ubuntu Linux is set up with at least 2 GB RAM and 25 GB free
    hard drive space. So, instead of choosing the default drive (the `C` drive in
    our case, where Windows is installed), select another drive if it exists (for
    example, the `D` drive) so that you can easily allocate more space, and it also
    prevents any impact on the host operating system.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 VirtualBox 可执行文件。它将打开一个向导。在安装之前，点击磁盘使用情况并检查磁盘空间需求。建议为 Ubuntu Linux 虚拟机设置至少
    2 GB RAM 和 25 GB 的空闲硬盘空间。因此，而不是选择默认驱动器（在我们的例子中是安装 Windows 的 `C` 驱动器），如果存在其他驱动器（例如
    `D` 驱动器），请选择它，这样您可以轻松地分配更多空间，并且它还可以防止对主机操作系统产生影响。
- en: The VirtualBox setup needs approximately 241 MB of disk space to install. It's
    recommended to create a new folder (for example, `VirtualBox`) to easily identify
    and track the VM.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VirtualBox 设置大约需要 241 MB 的磁盘空间来安装。建议创建一个新的文件夹（例如，`VirtualBox`），以便轻松识别和跟踪虚拟机。
- en: 'Keep clicking the Next button until the last page. At the end, a warning will
    be displayed that the installation of VirtualBox will reset the network connection
    and temporarily disconnect the machine from the network. This is alright if you
    are working on the same physical machine. So, click on the Yes button and continue,
    and then click on the Install button and finish the installation:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续点击“下一步”按钮，直到最后一页。最后，将显示一个警告，说明VirtualBox的安装将重置网络连接并暂时断开机器的网络连接。如果你在同一台物理机器上工作，这是可以的。因此，点击“是”按钮继续，然后点击“安装”按钮完成安装：
- en: '![](img/95a398fd-5cbd-4d6d-bf8f-3c8147979cc5.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95a398fd-5cbd-4d6d-bf8f-3c8147979cc5.png)'
- en: 'Once the preceding installation is done, open the VirtualBox manager to create
    a new virtual machine. Click on New and give the Name of the machine (for example, `Ubuntu`,
    as shown), and select the Type as Linux and the Version as Ubuntu (32 bit):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成前面的安装，打开VirtualBox管理器以创建一个新的虚拟机。点击新建，为机器命名（例如，`Ubuntu`，如图所示），并选择类型为Linux，版本为Ubuntu（32位）：
- en: '![](img/dd7acfaf-bf11-4c0d-b328-b61641c1cd5b.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd7acfaf-bf11-4c0d-b328-b61641c1cd5b.png)'
- en: 'We need to specify the memory size. More memory is good, but we should consider
    our disk space before selecting it. A minimum of 2 GB system memory is required
    for Ubuntu 17.04\. Select Create and then select VDI (VirtualBox Disk Image) as
    Hard disk file type. Select a Dynamically allocated hard disk. It will use space
    on your physical hard disk as it fills up (up to the maximum fixed size). Set
    the disk space maximum size to `25 GB` and click on Create. It will create a virtual
    machine with the Ubuntu operating system (32-bit) and 4 GB RAM, and the full details
    will be displayed on the final page:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要指定内存大小。更多的内存是好的，但在选择之前我们应该考虑我们的磁盘空间。Ubuntu 17.04至少需要2 GB的系统内存。选择创建，然后选择VDI（VirtualBox磁盘镜像）作为硬盘文件类型。选择动态分配的硬盘。当它填满时（最多固定大小），它将使用你的物理硬盘上的空间。将磁盘空间最大大小设置为`25
    GB`并点击创建。它将创建一个带有Ubuntu操作系统（32位）和4 GB RAM的虚拟机，所有详细信息将在最后一页显示：
- en: '![](img/2d742522-be93-434b-876a-d8cab1bef381.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d742522-be93-434b-876a-d8cab1bef381.png)'
- en: Ubuntu setup using Hyper-V
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hyper-V设置Ubuntu
- en: 'For Windows machines, we can use Hyper-V to create a Linux virtual machine.
    Let''s start with the basic settings and important configuration changes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows机器，我们可以使用Hyper-V来创建Linux虚拟机。让我们从基本设置和重要的配置更改开始：
- en: 'First, enable Hyper-V Management Tools and Hyper-V Platform from Windows Features:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从Windows功能中启用Hyper-V管理工具和Hyper-V平台：
- en: '![](img/ddb31de5-3f7c-4d1d-99e2-2550885beb15.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddb31de5-3f7c-4d1d-99e2-2550885beb15.png)'
- en: 'Change the default virtual directory. By default, Hyper-V uses the same drive
    as that on which the OS is installed but this is not a good practice. We should
    change the default drive the drive on which the operating system is not installed,
    such as the `D` drive in our case.  It''s a good practice to keep Windows and
    system files separate from other files. To make configuration changes, open Hyper-V
    Manager and then Hyper-V Settings. Instead of the default selection, change it
    to some other drive (`D` in our case). Create a new folder named `Virtual Machine`
    on this new drive location:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改默认的虚拟目录。默认情况下，Hyper-V使用与操作系统安装相同的驱动器，但这不是好的做法。我们应该将默认驱动器更改为操作系统未安装的驱动器，例如我们案例中的`D`驱动器。将Windows和系统文件与其他文件分开是一个好的做法。要做出配置更改，打开Hyper-V管理器，然后选择Hyper-V设置。将默认选择更改为其他驱动器（在我们的案例中是`D`）。在这个新驱动器位置创建一个名为`Virtual
    Machine`的新文件夹：
- en: '**   ![](img/94579428-5761-4be4-8405-d64efd81ef2f.png)**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**   ![](img/94579428-5761-4be4-8405-d64efd81ef2f.png)**'
- en: 'Create a virtual switch. A virtual switch is used to join computers and to
    create networks. We can create three types for virtual switches:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟交换机。虚拟交换机用于连接计算机并创建网络。我们可以为虚拟交换机创建三种类型：
- en: 'External: An accessible network where the virtual machines are hosted on the
    same physical computer and all external servers from which the host machine can
    connect.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部：一个可访问的网络，虚拟机托管在同一台物理计算机上，以及所有主机计算机可以连接的外部服务器。
- en: Internal: Creates a virtual switch that can be used only by the virtual machines
    that run on the same physical computer, and between virtual machines and the physical
    computer. An internal virtual switch doesn't provide connectivity to a physical
    network connection.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部：创建一个只能由在同一台物理计算机上运行的虚拟机使用的虚拟交换机，以及虚拟机与物理计算机之间的连接。内部虚拟交换机不提供与物理网络连接的连接性。
- en: 'Private: Creates a virtual switch that can be used only by the virtual machines
    that run on the same physical computer.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有：创建一个只能由在同一台物理计算机上运行的虚拟机使用的虚拟交换机。
- en: 'Create a Private or External type of virtual switch. This will be used for
    the virtual machine:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个私有或外部类型的虚拟交换机。这将用于虚拟机：
- en: '![](img/350600c5-f394-4ac2-9838-66ebf7b3a637.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/350600c5-f394-4ac2-9838-66ebf7b3a637.png)'
- en: 'Open Network and Sharing Center on your host machine and then open the external
    virtual switch properties. You will find Hyper-V Extensible Virtual Switch**.** This
    provides network connectivity to the virtual machine. Enable this or the virtual
    machine won''t be able to connect to the host machine network:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主机机器上打开网络和共享中心，然后打开外部虚拟交换机的属性。你会找到Hyper-V可扩展虚拟交换机**。**这为虚拟机提供网络连接。启用此选项，否则虚拟机将无法连接到主机机器的网络：
- en: '![](img/324987f8-430f-4c1f-a74a-e238614f6a51.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/324987f8-430f-4c1f-a74a-e238614f6a51.png)'
- en: 'Create a new virtual machine, and choose the name and location for the virtual
    machine. Select Generation 1 on the next page and select External Virtual Switch.
    Select the Install an operating system from a bootable CD/DVD-ROM option and select
    Image file (.iso), which we downloaded earlier for Ubuntu. Continue clicking the Next
    button in the wizard and the Ubuntu virtual machine will be created. Click on
    Start and connect to it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟机，并为虚拟机选择名称和位置。在下一页上选择第1代，并选择外部虚拟交换机。选择从可启动CD/DVD-ROM安装操作系统选项，并选择我们之前下载的Ubuntu镜像文件(.iso)。继续点击向导中的下一步按钮，Ubuntu虚拟机将被创建。点击启动并连接到它：
- en: '![](img/ff990b4c-d99d-457a-bc2c-6006f55bf2e4.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff990b4c-d99d-457a-bc2c-6006f55bf2e4.png)'
- en: 'After connection, we will be able to see the following screen. Select Install
    Ubuntu and set the language as English. Choose the Erase disk and install Ubuntu option
    and then click Continue:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接后，我们将能够看到以下屏幕。选择安装Ubuntu，并将语言设置为英语。选择**擦除磁盘并安装Ubuntu**选项，然后点击继续：
- en: '![](img/ee5c0e55-4258-4719-814b-ca2126e86f49.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee5c0e55-4258-4719-814b-ca2126e86f49.png)'
- en: 'Provide the username and password that you want and click Continue. Restart
    the system once the installation is done:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供你想要的用户名和密码，然后点击继续。安装完成后重新启动系统：
- en: '![](img/529ab54e-cfc4-48ba-95bd-b78818a339a9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/529ab54e-cfc4-48ba-95bd-b78818a339a9.png)'
- en: After restarting the virtual machine, it will display a login page. Enter the
    password that you provided while installing Ubuntu. On successful login, it will
    open the homepage, from where we can start Visual Studio Code and .NET Core 2.0
    SDK installation on this Ubuntu machine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重启虚拟机后，将显示登录页面。输入你在安装Ubuntu时提供的密码。登录成功后，将打开主页，从这里我们可以开始在这个Ubuntu机器上安装Visual
    Studio Code和.NET Core 2.0 SDK。
- en: Installing .NET Core 2.0 and tools (Linux)
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装.NET Core 2.0和工具（Linux）
- en: 'To install Visual Studio Code in Linux, download the .deb (32 bit) file from
    [http://code.visualstudio.com/download](http://code.visualstudio.com/download),
    as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux中安装Visual Studio Code，从[http://code.visualstudio.com/download](http://code.visualstudio.com/download)下载.deb
    (32位)文件，如下截图所示：
- en: '![](img/044c93b4-fbe6-4fea-a9bb-b278f6b9cf75.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/044c93b4-fbe6-4fea-a9bb-b278f6b9cf75.png)'
- en: 'Open the folder location the `.deb` file has been downloaded to. Right-click
    and select **Open in Terminal.** This will open Terminal from this location. Run
    the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`.deb`文件下载到的文件夹位置。右键点击并选择**在终端中打开**。这将从这个位置打开终端。运行以下命令：
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`<fileName>`: Enter the filename that was downloaded, which is `code_1.15.1-1502903950_i386.deb`
    in our case, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`<fileName>`：输入下载的文件名，在我们的例子中是`code_1.15.1-1502903950_i386.deb`，如下截图所示：'
- en: '![](img/7ae57513-5ff0-4f69-8c53-680e2451b271.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ae57513-5ff0-4f69-8c53-680e2451b271.png)'
- en: 'Right-click on the `Downloads` folder, and select Open in Terminal. It will
    display the following terminal window:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`下载`文件夹上右键点击，并选择在终端中打开。它将显示以下终端窗口：
- en: '![](img/10059e49-68ed-4234-ba3f-0c1d577ea2a5.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10059e49-68ed-4234-ba3f-0c1d577ea2a5.png)'
- en: 'It may show error messages stating that dependencies have not been installed.
    Run the following command to install the dependencies:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会显示错误消息，指出依赖项尚未安装。运行以下命令来安装依赖项：
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will complete the installation of Visual Studio Code in this Ubuntu machine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完成在这个Ubuntu机器上Visual Studio Code的安装。
- en: 'Now, let''s install the .NET Core 2.0 SDK. Open the folder location where the `dotnet-sdk-2.0.0`
    file is downloaded. Right-click and select Open in Terminal. It will open Terminal
    from this location. Run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装 .NET Core 2.0 SDK。打开下载 `dotnet-sdk-2.0.0` 文件的文件夹位置。右键单击并选择在终端中打开。它将从该位置打开终端。运行以下命令：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Congratulations! We are all set to run Visual Studio Code! Please refer to the *Installing
    Visual Studio Code* section of this chapter to get an overview of Visual Studio
    Code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经准备好运行 Visual Studio Code！请参阅本章的 *安装 Visual Studio Code* 部分，以了解 Visual
    Studio Code 的概述。
- en: Open Extensions View from the Visual Studio Code activity bar. Search `F#` and
    install the Ionide-fsharp extension for F# language support, as we discussed in
    the *Installing Visual Studio Code* section under the *Install .NET Core 2.0 and
    tools (Windows)* section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio Code 的活动栏打开扩展视图。搜索 `F#` 并安装用于 F# 语言支持的 Ionide-fsharp 扩展，正如我们在
    *安装 Visual Studio Code* 部分下 *安装 .NET Core 2.0 和工具 (Windows)* 部分所讨论的那样。
- en: Now, search `C#` and install the C# for Visual Studio Code (powered by OmniSharp)
    extension for C# language support.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索 `C#` 并安装用于 C# 语言支持的 C# for Visual Studio Code (由 OmniSharp 提供支持) 扩展。
- en: Creating simple running code
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的运行代码
- en: Let's create our very first .NET Core 2.0 application. We will create it using
    Visual Studio Code as well as Visual Studio 2017 in Windows, and with Visual Studio
    Code in Ubuntu.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个 .NET Core 2.0 应用程序。我们将使用 Visual Studio Code 以及 Windows 上的 Visual
    Studio 2017，以及 Ubuntu 上的 Visual Studio Code 来创建它。
- en: The .NET Core 2.0 SDK installs the templates for creating the class library,
    console, web, MVC, razor, web API, and so on, for applications based on .NET Core
    2.0\. As our first application, we will create a simple MVC application on .NET
    Core 2.0, and get familiar with the application code and the .NET Core 2.0 command-line
    integration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.0 SDK 为基于 .NET Core 2.0 的应用程序安装了创建类库、控制台、Web、MVC、razor、Web API 等模板。作为我们的第一个应用程序，我们将在
    .NET Core 2.0 上创建一个简单的 MVC 应用程序，并熟悉应用程序代码和 .NET Core 2.0 命令行集成。
- en: Let's start by creating this application in Windows using Visual Studio 2017,
    and then we will create the same application from Visual Studio Code, first in
    Windows and then in Linux.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Windows 上使用 Visual Studio 2017 创建此应用程序开始，然后我们将从 Visual Studio Code 创建相同的应用程序，首先是
    Windows，然后是 Linux。
- en: Creating an application in Windows through Visual Studio 2017 version 15.3
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Visual Studio 2017 版本 15.3 在 Windows 上创建应用程序
- en: 'For this, we need to perform the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此操作，我们需要执行以下步骤：
- en: Open Visual Studio 2017.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2017。
- en: 'Go to File | New | Project. In the New Project dialog, you should see the .NET
    Core template inside `Visual C#`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往文件 | 新建 | 项目。在新项目对话框中，你应该在 `Visual C#` 内看到 .NET Core 模板：
- en: '![](img/c81643bf-0a80-41e3-b8c7-afb300454989.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c81643bf-0a80-41e3-b8c7-afb300454989.png)'
- en: Click on .NET Core and select ASP.NET Core Web Application.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 .NET Core 并选择 ASP.NET Core Web Application。
- en: Name the project `HelloDotNetCore2` and click OK.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `HelloDotNetCore2` 并点击确定。
- en: 'It will show a New ASP.NET Core Web Application dialog. Ensure .NET Core and
    ASP.NET Core 2.0 are selected in the two dropdowns displayed in this dialog, as
    we are discussing .NET Core 2.0 here. The first dropdown signifies the target
    framework of the application and the second dropdown is the version of ASP.NET
    Core that we are using. You have the option to choose .NET Framework as the target
    framework in the first dropdown, but then the resulting application would not
    be cross-platform. If the application has to be cross-platform, it should target
    .NET Core. The second dropdown has the different versions of ASP.NET Core that
    have been released so far, such as 1.0, 1.1, and 2.0\. We will keep it as ASP.NET
    Core 2.0\. You will also notice that with ASP.NET Core 2.0, the number of templates
    has increased from the previous version. Apart from Empty, Web API, and Web Application,
    which were present in ASP.NET 1.1, we also have templates for Web Application
    (Model-View-Controller),  Angular, React.js, and React.js and Redux. We will choose
    Web Application (Model-View-Controller) as our template. There is support for
    a Docker container but let''s keep it unchecked for the time being. We will discuss
    Docker in detail in a later chapter. Also, keep the Authentication as No Authentication.
    We will explore authentication options in detail in a later chapter. Click OK:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将显示一个新的 ASP.NET Core Web 应用程序对话框。确保在此对话框中显示的两个下拉列表中选择了 .NET Core 和 ASP.NET
    Core 2.0，因为我们在这里讨论的是 .NET Core 2.0。第一个下拉列表表示应用程序的目标框架，第二个下拉列表是我们使用的 ASP.NET Core
    的版本。您可以在第一个下拉列表中选择 .NET Framework 作为目标框架，但这样生成的应用程序将不会是跨平台的。如果应用程序必须是跨平台的，则应针对
    .NET Core。第二个下拉列表包含迄今为止发布的不同版本的 ASP.NET Core，例如 1.0、1.1 和 2.0。我们将将其保留为 ASP.NET
    Core 2.0。您还会注意到，与之前的版本相比，ASP.NET Core 2.0 的模板数量有所增加。除了在 ASP.NET 1.1 中存在的 Empty、Web
    API 和 Web Application 之外，我们还有 Web Application (Model-View-Controller)、Angular、React.js
    和 React.js 及 Redux 的模板。我们将选择 Web Application (Model-View-Controller) 作为我们的模板。支持
    Docker 容器，但暂时不要勾选。我们将在后面的章节中详细讨论 Docker。此外，将身份验证保留为无身份验证。我们将在后面的章节中详细探讨身份验证选项。点击确定：
- en: '![](img/eddf3a01-4596-402b-96d8-4a356f44f97c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eddf3a01-4596-402b-96d8-4a356f44f97c.png)'
- en: 'And *voila*! Visual Studio creates the `HelloDotNetCore2` project for us and
    restores the required packages to build in the background. You can check this
    by inspecting the Package Manager Console output. Your very first ASP.NET Core
    2.0 is ready to be run:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*哇*！Visual Studio 为我们创建了 `HelloDotNetCore2` 项目，并在后台恢复所需的包以进行构建。您可以通过检查包管理器控制台输出进行检查。您非常第一个
    ASP.NET Core 2.0 应用程序已准备好运行：
- en: '![](img/78b10a2d-85bc-4d67-9616-715a2ab4674b.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78b10a2d-85bc-4d67-9616-715a2ab4674b.png)'
- en: Click Debug or press *F5* to run the application. We will see a detailed walk-
    through of all the project artifacts in the next chapter.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击调试或按 *F5* 运行应用程序。我们将在下一章中看到所有项目组件的详细说明。
- en: Creating application in Windows through Visual Studio Code
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 中通过 Visual Studio Code 创建应用程序
- en: Visual Studio is the IDE and is aware of projects and templates. As stated earlier,
    Visual Studio Code is a file and folder-based editor and hence it is not aware
    of projects and templates. So to create the same application through Visual Studio
    Code, we will make use of the .NET command line. Let's get going!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 是 IDE，并且了解项目和模板。如前所述，Visual Studio Code 是基于文件和文件夹的编辑器，因此它不了解项目和模板。因此，为了通过
    Visual Studio Code 创建相同的应用程序，我们将使用 .NET 命令行。让我们开始吧！
- en: Open Visual Studio Code, go to View, and click on TERMINAL. It will open Command
    Prompt/the PowerShell terminal in the bottom section of Visual Studio Code. If
    you see the PowerShell terminal, type `cmd` so that it turns into Command Prompt.
    This is an optional step if you are comfortable with PowerShell.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code，转到视图，然后点击终端。它将在 Visual Studio Code 的底部区域打开命令提示符/PowerShell
    终端。如果您看到 PowerShell 终端，请输入 `cmd` 以将其转换为命令提示符。如果您对 PowerShell 感到舒适，这一步是可选的。
- en: 'Let''s try and explore the commands available to create a new project, so let''s
    type `dotnet --help` . This is the help command for dotnet and will let us know
    about the options that we have available for creating a .NET Core 2.0 MVC application
    as shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试并探索可用于创建新项目的命令，因此让我们输入 `dotnet --help`。这是 dotnet 的帮助命令，并将让我们了解可用于创建 .NET
    Core 2.0 MVC 应用程序的选项，如下面的截图所示：
- en: '![](img/39ef1123-d7fc-4dfd-a637-78be2ce4bdc0.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39ef1123-d7fc-4dfd-a637-78be2ce4bdc0.png)'
- en: The SDK lists all the possible commands and options that can be used with explanations.
    So keep in mind, any time you need any help with .NET commands, SDK is there to
    help us. Just ask for help by typing `dotnet --help` in the terminal.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 列出了所有可能的命令和选项以及解释。所以记住，任何时候您需要任何 .NET 命令的帮助，SDK 都会帮助我们。只需在终端中输入 `dotnet
    --help` 请求帮助。
- en: From the command list, it looks like the command of interest to us is the `new` command,
    as its description reads that this command initializes .NET projects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令列表来看，我们感兴趣的命令是 `new` 命令，因为它的描述中提到这个命令初始化 .NET 项目。
- en: 'So, let''s ask SDK how to use the new command by typing `dotnet new --help`.
    This will let us know the command that we need to run to create a new MVC application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过输入 `dotnet new --help` 来询问 SDK 如何使用 `new` 命令。这将让我们知道需要运行以创建新的 MVC 应用的命令：
- en: '![](img/05500d06-5272-4274-9b29-70743e27cf50.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05500d06-5272-4274-9b29-70743e27cf50.png)'
- en: 'Based on the preceding help text, let''s enter the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的帮助文本，让我们输入以下命令：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will create a new MVC project named `HelloDotNetCore2` in the C# language,
    in the folder named `HelloDotNetCore2` at the location of the terminal. Now let''s
    build and run the application by typing the following commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端位置的 `HelloDotNetCore2` 文件夹中创建一个名为 `HelloDotNetCore2` 的新 MVC 项目。现在让我们通过输入以下命令来构建和运行应用程序：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first command navigates to the newly created folder, `HelloDotNetCore2`.
    Then, we build the application with the second command and run it through the
    third command. The `dotnet build` command is just to show that we have a build
    command as well. The `dotnet run` command actually builds and runs the application.
    Now, go to the browser of your choice and navigate to `http://localhost:5000`
    to see the application running in your browser:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令导航到新创建的文件夹 `HelloDotNetCore2`。然后，我们使用第二个命令构建应用程序，并通过第三个命令运行它。`dotnet build`
    命令只是为了显示我们也有构建命令。`dotnet run` 命令实际上构建并运行应用程序。现在，转到您选择的浏览器并导航到 `http://localhost:5000`
    以查看在浏览器中运行的应用程序：
- en: '![](img/1035eb4c-283d-4272-9add-af8161a32f1d.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1035eb4c-283d-4272-9add-af8161a32f1d.png)'
- en: Alternatively, you can go to the Explorer view in the activity bar, open the
    `HelloDotNetCore2` folder, and press *F5*. This will also build the application
    and launch it in the browser.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以在活动栏中转到资源管理器视图，打开 `HelloDotNetCore2` 文件夹，然后按 *F5*。这也会构建应用程序并在浏览器中启动它。
- en: Steps for creating the application in Ubuntu through Visual Studio Code are
    the same as in Windows, but instead of Command Prompt, we have Bash.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中通过 Visual Studio Code 创建应用程序的步骤与 Windows 中相同，但不同的是，我们使用 Bash 而不是命令提示符。
- en: F# primer
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 入门
- en: F# is a functional programming language. Functional programming treats programs
    as mathematical expressions. It focuses on functions and constants that don't
    change, rather than variables and states. F# is a Microsoft programming language
    for concise and declarative syntax. Let's begin with a brief history of how this
    language came into existence. The first attempt at functional programming was **Haskell
    .NET**. F# development began in 2005 and after that, various versions came along. At
    the time of writing this chapter, F# 4.1 is the latest version; it was released
    in March 2017\. This comes with Visual Studio 2017 and supports .NET Core.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: F# 是一种函数式编程语言。函数式编程将程序视为数学表达式。它侧重于不变常量和函数，而不是变量和状态。F# 是一种微软的编程语言，具有简洁和声明性语法。让我们从该语言是如何产生的简要历史开始。函数式编程的第一次尝试是
    **Haskell .NET**。F# 的开发始于 2005 年，此后，各种版本相继推出。在撰写本章时，F# 4.1 是最新版本；它于 2017 年 3 月发布。它随
    Visual Studio 2017 一起发布，并支持 .NET Core。
- en: 'The F# language can be used for the following tasks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: F# 语言可用于以下任务：
- en: To solve mathematical problems
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决数学问题
- en: For graphic design
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于图形设计
- en: For financial modeling
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于金融建模
- en: For compiler programming
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编译器编程
- en: For CPU design
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 CPU 设计
- en: It is also used for CRUD applications, web pages GUI games, and other programs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它还用于 CRUD 应用程序、网页、GUI 游戏和其他程序。
- en: F# keywords
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 关键字
- en: 'Keywords and their use in the F# language are outlined in the following table:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: F# 语言中的关键字及其用法概述如下表：
- en: '| **Keyword** | **Description** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **描述** |'
- en: '| `abstract` | Indicates that either it has no implementation or is a virtual
    and has default implementation. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `abstract` | 表示它没有实现，或者是一个虚拟的并且有默认实现。 |'
- en: '| `begin` | In verbose syntax, indicates the start of a code block. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `begin` | 在详细语法中，表示代码块的开始。 |'
- en: '| `default` | Indicates an implementation of an abstract method; used together
    with an abstract method declaration to create a virtual method. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 表示抽象方法的实现；与抽象方法声明一起使用以创建虚拟方法。 |'
- en: '| `elif` | Used in conditional branching. A short form of else-if. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `elif` | 在条件分支中使用。else-if 的简写形式。 |'
- en: '| `end` | Used in type definitions and type extensions, indicates the end of
    a section of member definitions.In verbose syntax, used to specify the end of
    a code block that starts with the `begin` keyword. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `end` | 在类型定义和类型扩展中使用，表示成员定义部分的结束。在详细语法中，用于指定以 `begin` 关键字开始的代码块的结束。 |'
- en: '| `exception` | Used to declare an exception type. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `exception` | 用于声明异常类型。 |'
- en: '| `finally` | Used together with `try` to introduce a block of code that executes
    regardless of whether an exception occurs. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `finally` | 与 `try` 一起使用，用于引入一个无论是否发生异常都会执行的代码块。 |'
- en: '| `fun` | Used in lambda expressions, and is also known as anonymous functions.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `fun` | 在 lambda 表达式中使用，也称为匿名函数。 |'
- en: '| `function` | Used as a shorter alternative to the `fun` keyword and a match
    expression in a lambda expression that has pattern matching on a single argument.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `function` | 作为 `fun` 关键字和 lambda 表达式中的匹配表达式的简短替代。 |'
- en: '| `inherit` | Used to specify a base class or base interface. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `inherit` | 用于指定基类或基接口。 |'
- en: '| `interface` | Used to declare and implement interfaces. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `interface` | 用于声明和实现接口。 |'
- en: '| `let` | Used to associate or bind a name to a value or function. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `let` | 用于将名称与值或函数关联或绑定。 |'
- en: '| `member` | Used to declare a property or method in an object type. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `member` | 用于在对象类型中声明属性或方法。 |'
- en: '| `mutable` | Used to declare a variable; that is, a value that can be changed.
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `mutable` | 用于声明变量；即可以改变的值。 |'
- en: '| `override` | Used to implement a version of an abstract or virtual method
    that differs from the base version. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `override` | 用于实现与基版本不同的抽象或虚拟方法。 |'
- en: '| `rec` | Used to indicate that a function is recursive. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `rec` | 用于表示一个递归函数。 |'
- en: '| `select` | Used in query expressions to specify what fields or columns to
    extract. Note that this is a contextual keyword, which means that it is not actually
    a reserved word and it only acts like a keyword in an appropriate context. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `select` | 在查询表达式中使用，用于指定要提取的字段或列。注意，这是一个上下文关键字，这意味着它实际上不是一个保留字，它只在适当的上下文中像关键字一样作用。
    |'
- en: '| `static` | Used to indicate a method or property that can be called without
    an instance of a type, or a value member that is shared among all instances of
    a type. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `static` | 用于表示可以不通过类型实例调用的方法或属性，或者一个在类型的所有实例之间共享的值成员。 |'
- en: '| `struct` | Used to declare a structure type. Also used in generic parameter
    constraints. Used for OCaml compatibility in module definitions. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `struct` | 用于声明结构类型。也在泛型参数约束中使用。在模块定义中用于 OCaml 兼容性。 |'
- en: '| `type` | Used to declare a class, record, structure, discriminated union,
    enumeration type, unit of measure, or type abbreviation. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 用于声明类、记录、结构、区分联合、枚举类型、度量单位或类型缩写。 |'
- en: '| `val` | Used in a signature to indicate a value, or in a type to declare
    a member, in limited situations. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `val` | 在签名中用于表示值，或在类型中用于声明成员，在有限情况下。 |'
- en: '| `yield` | Used in a sequence expression to produce a value for a sequence.
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `yield` | 在序列表达式中使用，用于生成序列的值。 |'
- en: This reference is taken from the Microsoft official website, and a detailed
    explanation and description can be found at [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference.](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本参考内容来自微软官方网站，更详细的内容和描述可以在 [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference.](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference)
    找到。
- en: Comments
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'In the F# language, we have two types of comments for a single line and for
    multiple lines. This is the same as C#. The following are the two types of comments:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 语言中，我们有两种类型的注释，用于单行和多行注释。这与 C# 相同。以下是两种注释类型：
- en: A single-line comment which starts with the `//` symbol.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `//` 符号开始的单行注释。
- en: Example: `// returns an integer exit code`
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`// 返回一个整数退出码`
- en: A multi-line comment which starts with (`*` and ends with `*`).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以 `(*` 开始并以 `*` 结束的多行注释。
- en: Example:  `(*Learn more about F# at http://fsharp.org *)`
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`(*了解更多关于 F# 的信息，请访问 http://fsharp.org *)`
- en: Data types
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'F# has a rich data type system. We can broadly classify them as:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: F# 拥有丰富的数据类型系统。我们可以将它们广泛地分为：
- en: '**Integral types**: `sbyte`, `byte`, `int16`, `uint16`, `int32`, `uint32`,
    `int64`, and `bigint`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型**: `sbyte`, `byte`, `int16`, `uint16`, `int32`, `uint32`, `int64`, 和 `bigint`'
- en: '**Floating point types**: `float32`, `float`, and `decimal`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点类型**: `float32`、`float` 和 `decimal`'
- en: '**Text types**: `char` and `string `'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本类型**: `char` 和 `string`'
- en: '**Other types**: `bool`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他类型**: `bool`'
- en: These types are also referred to as fundamental primitive types in F#. Apart
    from these, F# has an exhaustive list of predefined types as well, such as lists,
    arrays, records, enumerations, tuples,  units, sequences, and so on. It is recommended
    that a person learning F# goes through the official Microsoft documentation on
    F# at [https://docs.microsoft.com/en-us/dotnet/fsharp/.](https://docs.microsoft.com/en-us/dotnet/fsharp/)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型也被称为 F# 中的基本原始类型。除了这些，F# 还有一系列预定义类型，例如列表、数组、记录、枚举、元组、单元、序列等。建议学习 F# 的人阅读官方微软关于
    F# 的文档，网址为 [https://docs.microsoft.com/en-us/dotnet/fsharp/](https://docs.microsoft.com/en-us/dotnet/fsharp/)
- en: Variable declaration
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'F# uses the `let` keyword for the declaration of a variable, for example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: F# 使用 `let` 关键字来声明变量，例如：
- en: '[PRE5]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The compiler automatically detects this as a value type. If we pass a float
    value, the compiler will be able to understand that without declaring a data type.
    Variables in F# are immutable, so once a value is assigned to a variable, it can't
    be changed. They are compiled as static read-only properties.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动将其检测为值类型。如果我们传递一个浮点值，编译器将能够理解这一点，而无需声明数据类型。F# 中的变量是不可变的，所以一旦一个值被分配给变量，它就不能被改变。它们被编译为静态只读属性。
- en: 'The following example demonstrates this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这一点：
- en: '[PRE6]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables `x`, `y`, and `z` are all of type `int32` and are immutable, meaning
    their value cannot be changed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x`、`y` 和 `z` 都是 `int32` 类型，且是不可变的，这意味着它们的值不能被改变。
- en: 'Let''s print their values. The syntax is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印它们的值。语法如下：
- en: '[PRE7]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the preceding code executes, the result is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码后，结果如下：
- en: '[PRE8]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, suppose we want to modify the value of `x` from `50` to `60` and check
    that `z` reflects the updated sum; we will write the code as:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想将 `x` 的值从 `50` 修改为 `60` 并检查 `z` 是否反映了更新的总和；我们将编写如下代码：
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On executing this code, we get the following errors, and rightly so because
    `x` and `z` are immutable:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此代码时，我们将得到以下错误，这是正确的，因为 `x` 和 `z` 是不可变的：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The correct way of doing it would be to use mutable variables for the declaration,
    as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的做法是使用可变变量进行声明，如下所示：
- en: '[PRE11]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On printing the values again, we will see:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打印值，我们将看到：
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Operators
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'F# has the following operators:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有以下运算符：
- en: Arithmetic operators
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Comparison operators
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Boolean operators
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: Bitwise operators
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: Let's discuss these operators in detail.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这些运算符。
- en: Arithmetic operators
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'Arithmetic operators supported by the F# language are outlined in the following
    table. Assuming variable `X = 10` and variable `Y = 40` , we have the following
    expressions:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: F# 语言支持的算术运算符概述如下表。假设变量 `X = 10` 和变量 `Y = 40`，我们有以下表达式：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `+` | Adds two values | `X + Y  = 50` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加上两个值 | `X + Y = 50` |'
- en: '| `-` | Subtracts the second value from the first | `X - Y = -30` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 从第一个值中减去第二个值 | `X - Y = -30` |'
- en: '| `*` | Multiplies both values | `X * Y = 400` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘以两个值 | `X * Y = 400` |'
- en: '| `/` | Divides two values | `Y / X = 4` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除以两个值 | `Y / X = 4` |'
- en: '| `%` | Modulus operator and gives the value of the remainder after an integer
    division | `Y % X = 0` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模运算符，给出整数除法后的余数 | `Y % X = 0` |'
- en: '| `**` | Exponentiation operator; raises one variable to the power of another
    | `Y**X = 40^(10)` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 幂运算符；将一个变量提升到另一个变量的幂 | `Y**X = 40^(10)` |'
- en: Comparison operators
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: The following table shows all the comparison operators supported by F# . These
    operators return `true` or `false`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 F# 支持的所有比较运算符。这些运算符返回 `true` 或 `false`。
- en: 'Let''s take `X = 20` and `Y = 30`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取 `X = 20` 和 `Y = 30`：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `==` | Verifies the values of two variables are equal; if not, then the condition
    becomes `false`. | `(X == Y)` returns `false` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 验证两个变量的值是否相等；如果不相等，则条件变为 `false`。 | `(X == Y)` 返回 `false` |'
- en: '| `<>`  | Verifies the values of two variables are equal; if values are not
    equal then the condition becomes `true`. | `(X <> Y)` returns `true` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `<>`  | 验证两个变量的值是否相等；如果不相等，则条件变为 `true`。 | `(X <> Y)` 返回 `true` |'
- en: '| `>`  | Verifies the value of the left variable is greater than the value
    of the right variable; if not, then the condition becomes `false`. | `(X > Y)` returns `false`
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `>`  | 验证左变量的值是否大于右变量的值；如果不满足，则条件变为 `false`。 | `(X > Y)` 返回 `false` |'
- en: '| `<`  | Verifies the value of the left variable is less than the value of
    the right variable; if yes, then the condition becomes `true`. | `(X < Y)` returns `true`
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `<`  | 验证左变量的值是否小于右变量的值；如果是，则条件变为 `true`。 | `(X < Y)` 返回 `true` |'
- en: '| `>=` | Verifies the value of the left variable is greater than or equal to
    the value of the right variable; if not, then condition becomes `false`. | `(X
    >= Y)` returns `false` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 验证左变量的值是否大于或等于右变量的值；如果不满足，则条件变为 `false`。 | `(X >= Y)` 返回 `false` |'
- en: '| `<=` | Verifies the value of the left variable is less than or equal to the
    value of the right variable; if yes, then the condition becomes `true`. | `(X
    <= Y)` returns `true` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 验证左变量的值是否小于或等于右变量的值；如果是，则条件变为 `true`。 | `(X <= Y)` 返回 `true` |'
- en: Boolean operators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: 'The following table shows all the Boolean operators supported by the F# language.
    Let''s take variable `X` as `true` and `Y` as `false`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 F# 语言支持的所有布尔运算符。让我们以变量 `X` 为 `true` 和 `Y` 为 `false` 为例：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `&&` | Boolean AND operator. If both the bool values are `true` means `1`,
    then the condition is `true`. | `(X && Y)` is `false` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 布尔 AND 运算符。如果两个布尔值都为 `true`（即 `1`），则条件为 `true`。 | `(X && Y)` 为 `false`
    |'
- en: '| `&#124;&#124;` | Boolean OR operator. If either of the two bool values is
    `true` means `1`, then the condition is `true`. | `(X &#124;&#124; Y)` is `true`
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 布尔 OR 运算符。如果两个布尔值中的任意一个为 `true`（即 `1`），则条件为 `true`。 | `(X
    &#124;&#124; Y)` 为 `true` |'
- en: '| `not` | Boolean NOT operator. If the condition is `true`, then the logical
    NOT operator will become `false` and vice versa. | `not (X && Y)` is `true` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `not` | 布尔 NOT 运算符。如果条件为 `true`，则逻辑 NOT 运算符变为 `false`，反之亦然。 | `not (X &&
    Y)` 为 `true` |'
- en: Bitwise operators
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'Bitwise operators work on bits and perform bit-by-bit operations. The truth
    tables for `&&&` (bitwise AND), `|||` (bitwise OR), and `^^^` (bitwise exclusive
    OR) are shown as follows. In the following table, the first variable is `X` and
    the second variable is `Y`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符对位进行操作，并执行逐位操作。以下表格显示了 `&&&`（位 AND）、`|||`（位 OR）和 `^^^`（位异或）的真值表。在以下表格中，第一个变量是
    `X`，第二个变量是 `Y`：
- en: '| **`X`** | `Y` | `X &&& Y` | `X &#124;&#124;&#124; Y` | `X ^^^ Y` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **`X`** | `Y` | `X &&& Y` | `X &#124;&#124;&#124; Y` | `X ^^^ Y` |'
- en: '| `0` | `0` | `0` | `0` | `0` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `1` | `1` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | `1` |'
- en: '| `1` | `1` | `1` | `1` | `0` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `0` |'
- en: '| `1` | `0` | `0` | `1` | `1` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | `1` |'
- en: It also supports `~~~`(Unary, effect of flipping bits) , `<<<` (left shift operator),
    and `>>>`(right shift operator).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持 `~~~`(一元，翻转位的效果) ，`<<<`（左移运算符）和 `>>>`(右移运算符)。
- en: Decision-making statements
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策语句
- en: The F# language has the following (`if...else` and loop) types of decision-making
    statements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: F# 语言有以下 (`if...else` 和循环) 类型的决策语句。
- en: if statements
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The following table shows all the ways of implementing `if` statements:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了实现 `if` 语句的所有方式：
- en: '| **Statement** | **Description** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **语句** | **描述** |'
- en: '| `if`/`then` statement |  An `if`/`then` statement consists of a Boolean expression
    followed by one or more statements. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `if`/`then` 语句 | 一个 `if`/`then` 语句由一个布尔表达式后跟一个或多个语句组成。 |'
- en: '| `if`/`then`/`else` statement | An `if`/`then` statement can be followed by
    an optional `else` statement, which executes when the Boolean expression is `false`.
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `if`/`then`/`else` 语句 | 一个 `if`/`then` 语句可以跟一个可选的 `else` 语句，当布尔表达式为 `false`
    时执行。 |'
- en: '| `if`/`then`/`elif`/`else` statement | An `if`/`then`/`elif`/`else` statement
    allows you to have multiple `else` statements. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `if`/`then`/`elif`/`else` 语句 | 一个 `if`/`then`/`elif`/`else` 语句允许你拥有多个 `else`
    语句。 |'
- en: '| Nested `if` statements | You can use one `if` or `else if` statement inside
    another `if` or `else if` statements. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 嵌套 `if` 语句 | 你可以在另一个 `if` 或 `else if` 语句内部使用一个 `if` 或 `else if` 语句。 |'
- en: Loop statements
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环语句
- en: 'F# provides the following types of loop:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供以下类型的循环：
- en: '| **Loop type** | **Description** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **循环类型** | **描述** |'
- en: '| `for…to` and `for…downto` expressions | The `for...to` expression is used
    to iterate in a loop over a range of values of a loop variable. The `for…downto`
    expression reduces the value of a loop variable. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `for…to` 和 `for…downto` 表达式 | `for...to` 表达式用于在循环中遍历循环变量的值范围。`for...downto`
    表达式减少循环变量的值。|'
- en: '| `for…in` expression | This form of `for` loop is used to iterate over collections
    of items; that is, loops over collections and sequences. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `for…in` 表达式 | 这种形式的 `for` 循环用于遍历项目集合；即，遍历集合和序列。|'
- en: '| `while…do` loop | Repeats a statement or group of statements while the given
    condition is true. It tests the condition before executing the loop body. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `while…do` 循环 | 在给定的条件为真时重复执行语句或语句组。它在执行循环体之前测试条件。|'
- en: '| nested loops | We can use one or more loop inside any other `for` or `while`
    loop. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 嵌套循环 | 我们可以在任何其他 `for` 或 `while` 循环内使用一个或多个循环。|'
- en: F# functions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 函数
- en: 'F# functions act like variables. We can declare and use them in the same way
    as we use variables in C#. A function definition starts with the `let` keyword, followed
    by the function name and parameters, a colon, its type, and the right-side expression,
    showing what the function does. The syntax is follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: F# 函数的行为类似于变量。我们可以像在 C# 中使用变量一样声明和使用它们。函数定义以 `let` 关键字开始，后跟函数名和参数，一个冒号，其类型，以及右侧表达式，显示函数的功能。语法如下：
- en: '[PRE13]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding syntax:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语法中：
- en: '`functionName` is an identifier of the function.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functionName` 是函数的标识符。'
- en: '`parameters` gives the list of parameters separated by spaces. We can also
    specify an explicit type for each parameter and if not specified, the compiler
    tends to presume it from the function body as variables.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters` 提供了用空格分隔的参数列表。我们还可以为每个参数指定显式类型，如果没有指定，编译器倾向于从函数体作为变量推断它。'
- en: '`functionbody` comprises an expression, or a compound expression, which has
    number of expressions. The final expression in the function body is the return
    value.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functionbody` 包含一个表达式或复合表达式，其中包含多个表达式。函数体中的最终表达式是返回值。'
- en: '`returnType` is a colon followed by a type and it is optional. If the `returnType`
    is not specified, then the compiler determines it from the final expression in
    the function body.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnType` 是一个冒号后跟一个类型，它是可选的。如果没有指定 `returnType`，则编译器会从函数体中的最终表达式确定它。'
- en: 'Have a look at the following example for our syntax:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下示例以了解我们的语法：
- en: '[PRE14]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calling a function
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数调用
- en: 'A function can be called by passing the function name followed, by a space,
    and then arguments (if any) separated by spaces, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过传递函数名，然后是一个空格，然后是（如果有）用空格分隔的参数来调用，如下所示：
- en: '[PRE15]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can perform many tasks using F# functions, some of which are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 F# 函数执行许多任务，其中一些如下：
- en: 'We can create a new function and link that function with a type as it acts
    as a variable type:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的函数，并将该函数与类型链接，因为它充当变量类型：
- en: '`let square x = x*x`'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let square x = x*x`'
- en: 'We can perform some calculations as well, such as:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以执行一些计算，例如：
- en: '`` `let square x = x*x` ``'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`` `let square x = x*x` ``'
- en: 'We can assign a value. Taking the same example:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以赋值。以相同的例子为例：
- en: '`let square x = x*x`'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let square x = x*x`'
- en: 'We can pass a function as a parameter to another function like this:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将函数作为参数传递给另一个函数，如下所示：
- en: '`let squareValue = List.map square[1;2;3] // using square function`'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let squareValue = List.map square[1;2;3] // 使用 square 函数`'
- en: 'We can return a function as a result of another function example:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将函数作为另一个函数的结果返回示例：
- en: '`let squareValue = List.map square[1;2;3]`'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let squareValue = List.map square[1;2;3]`'
- en: File sequence
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件序列
- en: The order of files in a project matters in an F# solution. The file used in
    any function should be placed above the file where the function is used, because
    F# has a forward-only model of compilation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 解决方案中，项目的文件顺序很重要。任何函数中使用的文件都应该放在该函数使用的文件之上，因为 F# 具有仅向前的编译模型。
- en: 'Unlike C#, where the file sequence doesn''t matter, the sequencing of files
    does matter in F#. For example, consider that `Program.fs` is using `DotNetCorePrint.fs`.
    So, `DotNetCorePrint.fs` should be placed above `Program.fs` in the solution;
    otherwise, it will throw a compilation error. To move a file up or down, we can
    right-click on the file and select Move Up or the keys *Alt* + the up arrow to
    move the file. The ordering of the files in Solution Explorer can be seen in the
    following screenshot:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 不同，在 C# 中文件顺序并不重要，但在 F# 中文件顺序很重要。例如，假设 `Program.fs` 正在使用 `DotNetCorePrint.fs`。因此，`DotNetCorePrint.fs`
    应该放在解决方案中的 `Program.fs` 之上；否则，它将抛出编译错误。要移动文件上下，我们可以右键单击文件并选择“上移”或使用 *Alt* + 上箭头键来移动文件。在解决方案资源管理器中可以看到文件的顺序，如下截图所示：
- en: '![](img/785d689b-0614-4bef-a938-625773a91d84.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/785d689b-0614-4bef-a938-625773a91d84.png)'
- en: Basic input/output syntax
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本输入/输出语法
- en: 'We are now going to see how to write and read in F#. To read and write into
    the console, we can use the following commands:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何在 F# 中写入和读取。为了将数据写入和读取到控制台，我们可以使用以下命令：
- en: To write: `System.Console.Write("Welcome!")`
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入：`System.Console.Write("Welcome!")`
- en: To read: `` `System.Console.Read()` ``
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取：`System.Console.Read()`
- en: To print: `printfn "Hello"`
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印：`printfn "Hello"`
- en: 'Let''s compare F# with C#:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 F# 和 C#：
- en: '|                                 **F#** | **C#** |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|                                 **F#** | **C#** |'
- en: '| The F# user is free from the obligation of defining types; for example: `let
    square x = x* x`The compiler can identify (`integer * integer`) or (`float * float`)
    when we pass a value. | The C# user is bound to provide a type:`Public int square(int
    x){ return x = x*x ; }` |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| F# 用户无需定义类型；例如：`let square x = x* x` 编译器可以在我们传递值时识别（`整数 * 整数`）或（`浮点 * 浮点`）。|
    C# 用户必须提供类型：`Public int square(int x){ return x = x*x ; }` |'
- en: '| F# has immutable data, and the value never changes; for example: `let number
    = [3;2;1]``let moreNumber = 4:: number`In the preceding example, to add one more
    number, (`4`), we need to create a new list of items using `number`, and add the
    new record, `4` in this case. The same list doesn''t get modified for safer asynchronous
    execution and a simplified understanding of a function. | C# has mutable as well
    as immutable data. Strings are immutable, the rest are all mutable, for example:`var
    number = new List<int> {1,2,3}; number.Add(4);`In the preceding example, we created
    a list and added a new item to the same list. The list gets modified. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| F# 有不可变数据，其值永远不会改变；例如：`let number = [3;2;1]` `let moreNumber = 4:: number`
    在前面的例子中，要添加一个数字（`4`），我们需要使用 `number` 创建一个新的项目列表，并添加新的记录，在这种情况下是 `4`。相同的列表不会被修改，以确保更安全的异步执行和简化函数的理解。|
    C# 既有可变数据也有不可变数据。字符串是不可变的，其余都是可变的，例如：`var number = new List<int> {1,2,3}; number.Add(4);`
    在前面的例子中，我们创建了一个列表，并向同一个列表中添加了一个新项目。列表被修改了。|'
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: F# compiles code in an order. It is favoured for data processing and algorithmic
    computation. It doesn't work on visibility; it works sequentially. | C# code works
    on visibility. The sequence doesn't matter. |
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: F# 按顺序编译代码。它因数据处理和算法计算而受到青睐。它不依赖于可见性；它是顺序执行的。| C# 代码依赖于可见性。顺序并不重要。|
- en: '| The order of files in a project matters in the F# solution. A file used in
    any method should be placed above the file where the method has been used. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 在 F# 解决方案中，项目的文件顺序很重要。任何方法中使用的文件都应该放在该方法被使用过的文件之上。|'
- en: The order doesn't matter in C#. |
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，顺序并不重要。|
- en: '| F# has precise syntax; it focuses on *what not* and *how*; for example:`let
    square x = x*x``let squared = List.map square[1;2;3]  // using square function`Right-click
    execute &#124; result `1;4;9`F# uses declarative syntax, not imperative syntax
    as in C#. F# helps us to minimize accidental complexity, meaning complexity that
    is not a part of the problem, but which we introduced as part of the solution,
    for example:`let rec quicksort = function &#124; [] -> [] &#124; x :: xs ->  let
    smaller = List.filter((>)x) xs let larger = List.filter ((<=)x) xs`Quicksort smaller
    `@ [x] @` quicksort larger:`Let sorted = quicksort [4;5;4;7;9;1;6;1;0;-99;10000;3;2]``rec`
    is used for a recursive function. It is assigned in the sorted result. Run it
    and you will get a sorted result. It is a very simple sorting function with less
    complexity than C#, which has a high chance of errors. | C# code implementation
    is more about how to implement. It sometimes increases unnecessary complexity
    as part of the solution to a problem.Quick sort has a very complex algorithm and
    a high chance of increasing accidental complexity. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| F# 拥有精确的语法；它关注*不是什么*和*如何*；例如：`let square x = x*x` `let squared = List.map
    square[1;2;3]  // 使用 square 函数` 右键执行 &#124; 结果 `1;4;9` F# 使用声明式语法，而不是像 C# 那样的命令式语法。F#
    帮助我们最小化意外复杂性，即不是问题本身的一部分，而是我们在解决方案中引入的复杂性，例如：`let rec quicksort = function &#124;
    [] -> [] &#124; x :: xs -> let smaller = List.filter((>)x) xs let larger = List.filter
    ((<=)x) xs` `Quicksort smaller @ [x] @ quicksort larger:` `Let sorted = quicksort
    [4;5;4;7;9;1;6;1;0;-99;10000;3;2]` `rec` 用于递归函数。它在排序结果中赋值。运行它，你将得到一个排序结果。这是一个非常简单的排序函数，比
    C# 的复杂度低，C# 的错误概率很高。 | C# 代码实现更多地关注如何实现。它有时会增加不必要的复杂性，作为问题解决方案的一部分。快速排序算法非常复杂，并且有很大可能增加意外复杂性。
    |'
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed downloading Visual Studio Code, .NET Core 2.0,
    an Ubuntu 17.04 ISO image, and the tools required to start .NET Core application
    creation, as well as how to install them on Windows and Linux machines. We also
    discussed how to set up a Ubuntu Linux virtual machine and introduced the F# language.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了下载 Visual Studio Code、.NET Core 2.0、Ubuntu 17.04 ISO 镜像以及启动 .NET Core
    应用程序创建所需的工具，以及如何在 Windows 和 Linux 机器上安装它们。我们还讨论了如何设置 Ubuntu Linux 虚拟机，并介绍了 F#
    语言。
- en: In the following chapter, you'll be introduced to native libraries in .NET Core,
    used to extend console capabilities. We will discuss Interop with existing libraries
    and ncurses.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解用于扩展控制台功能的 .NET Core 原生库。我们将讨论与现有库的互操作性和 ncurses。
