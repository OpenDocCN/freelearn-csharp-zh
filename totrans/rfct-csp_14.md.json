["```cs\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeActions;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\nusing System.Collections.Immutable;\nusing System.Composition;\nusing System.Linq;\nusing System.Threading.Tasks;\nnamespace Packt.Analyzers {\n  [Shared]\n  [ExportCodeFixProvider(LanguageNames.CSharp,\n    Name = nameof(ToStringCodeFix))]\n  public class ToStringCodeFix : CodeFixProvider {\n    public override ImmutableArray<string>\n      FixableDiagnosticIds =>\n        ImmutableArray.Create(ToStringAnalyzer.Rule.Id);\n    public override FixAllProvider GetFixAllProvider()\n      => WellKnownFixAllProviders.BatchFixer;\n    public async override Task RegisterCodeFixesAsync(\n      CodeFixContext context) {\n      throw new NotImplementedException();\n    }\n  }\n}\n```", "```cs\npublic async override Task RegisterCodeFixesAsync(\n  CodeFixContext context) {\n  Diagnostic diagnostic = context.Diagnostics.First();\n  TextSpan span = diagnostic.Location.SourceSpan;\n  Document doc = context.Document;\n```", "```cs\n  SyntaxNode root = await doc\n    .GetSyntaxRootAsync(context.CancellationToken)\n    .ConfigureAwait(false);\n  TypeDeclarationSyntax typeDec =\n    root.FindToken(span.Start)\n        .Parent\n        .AncestorsAndSelf()\n        .OfType<TypeDeclarationSyntax>()\n        .First();\n```", "```cs\n  CodeAction fix = CodeAction.Create(\n    title: \"Override ToString\",\n    createChangedDocument: c => FixAsync(doc, typeDec)\n  );\n  context.RegisterCodeFix(fix, diagnostic);\n}\n```", "```cs\npublic override string ToString()\n{\n  throw new NotImplementedException();\n}\n```", "```cs\nprivate Task<Document> FixAsync(Document doc,\n  TypeDeclarationSyntax typeDec) {\n  const string exType = \"NotImplementedException\";\n  IdentifierNameSyntax exId =\n    SyntaxFactory.IdentifierName(exType);\n  BlockSyntax methodBody = SyntaxFactory.Block(\n    SyntaxFactory.ThrowStatement(\n      SyntaxFactory.ObjectCreationExpression(exId)\n        .WithArgumentList(SyntaxFactory.ArgumentList())\n    )\n  );\n```", "```cs\n  SyntaxToken[] modifiers = new SyntaxToken[] {\n    SyntaxFactory.Token(SyntaxKind.PublicKeyword),\n    SyntaxFactory.Token(SyntaxKind.OverrideKeyword)\n  };\n  SyntaxToken returnType =\n    SyntaxFactory.Token(SyntaxKind.StringKeyword);\n  MethodDeclarationSyntax newMethod =\n    SyntaxFactory.MethodDeclaration(\n      SyntaxFactory.PredefinedType(returnType),\n      SyntaxFactory.Identifier(\"ToString\")\n    )\n    .WithModifiers(SyntaxFactory.TokenList(modifiers))\n    .WithBody(methodBody);\n```", "```cs\n  TypeDeclarationSyntax newType =\n    typeDec.AddMembers(newMethod);\n  SyntaxNode root = typeDec.SyntaxTree.GetRoot();\n  SyntaxNode newRoot = root.ReplaceNode(typeDec, newType);\n  Document newDoc = doc.WithSyntaxRoot(newRoot);\n  return Task.FromResult(newDoc);\n}\n```", "```cs\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CodeFixes;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing RoslynTestKit;\nnamespace Packt.Analyzers.Tests;\npublic class ToStringCodeFixTests : CodeFixTestFixture {\n protected override string LanguageName\n   => LanguageNames.CSharp;\n protected override CodeFixProvider CreateProvider()\n   => new ToStringCodeFix();\n protected override IReadOnlyCollection<DiagnosticAnalyzer>\n   CreateAdditionalAnalyzers()\n   => new[] { new ToStringAnalyzer() };\n```", "```cs\n  public const string BadCode = @\"\nusing System;\npublic class [|Flight|]\n{\n    public string Id {get; set;}\n    public string DepartAirport {get; set;}\n    public string ArriveAirport {get; set;}\n}\";\n  public const string GoodCode = @\"\nusing System;\npublic class Flight\n{\n    public string Id {get; set;}\n    public string DepartAirport {get; set;}\n    public string ArriveAirport {get; set;}\n    public override string ToString()\n    {\n        throw new NotImplementedException();\n    }\n}\";\n  [Fact]\n  public void CodeFixShouldMoveBadCodeToGood() {\n    string ruleId = ToStringAnalyzer.Rule.Id;\n    TestCodeFix(BadCode, GoodCode, ruleId);\n  }\n}\n```", "```cs\n1>Successfully created package 'C:\\PacktBook\\Chapter14\\Ch14BeginningCode\\Packt.Analyzers\\bin\\Debug\\Packt.Analyzers.1.0.0.nupkg'.\n1>Done building project \"Packt.Analyzers.csproj\".\n```", "```cs\n<Project Sdk=\"Microsoft.NET.Sdk\">\n <PropertyGroup>\n   <TargetFramework>netstandard2.0</TargetFramework>\n   <GeneratePackageOnBuild>True</GeneratePackageOnBuild>\n   <IncludeBuildOutput>false</IncludeBuildOutput>\n   <Authors>YourName</Authors>\n   <Company>YourCompany</Company>\n   <PackageId>YourCompany.Analyzers</PackageId>\n   <PackageVersion>1.0.0</PackageVersion>\n   <PackageLicenseExpression>MIT</PackageLicenseExpression>\n   <Description>\n      Sample analyzer with fix from \"Refactoring with C#\"\n      by Matt Eland via Packt Publishing.\n   </Description>\n   <PackageProjectUrl>\nhttps://github.com/PacktPublishing/Refactoring-with-CSharp\n   </PackageProjectUrl>\n   <RepositoryUrl>https://github.com/PacktPublishing/\nRefactoring-with-CSharp</RepositoryUrl>\n </PropertyGroup>\n <ItemGroup>\n   <PackageReference Include=\"Microsoft.CodeAnalysis\"\n                     Version=\"4.0.1\" />\n<None Include=\"$(OutputPath)\\Packt.Analyzers.dll\"\n         Pack=\"true\"\n         PackagePath=\"analyzers/dotnet/cs\"\n         Visible=\"false\" />\n </ItemGroup>\n</Project>\n```"]