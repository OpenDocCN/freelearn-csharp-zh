- en: Documenting Your API Using Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to document our API using the OpenAPI Specification
    and how to use Swagger tools to parse and generate the documentation. Documenting
    APIs is particularly significant when our web service is consumed by an external
    company or a foreign organization team. Moreover, some services can be considerably
    complex and expose a lot of endpoints. For this reason, some tools related to
    the .NET ecosystem guarantee up-to-date API documentation. Two main toolchains
    can be used in this process: NSwag and Swashbuckle. In this book, we will cover
    and use NSwag to document our APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OpenAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing OpenAPI in ASP.NET Core services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to automatically generate up-to-date
    documentation that's compliant with the OpenAPI Specification using Swagger and
    the NSwag package.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenAPI initiative is part of the Linux Foundation and defines the **OpenAPI**
    **Specification** (**OAS**) standard. The OpenAPI Specification aims to provide
    a language-agnostic interface for REST APIs. This kind of approach guarantees
    that both humans and client applications understand and discover the capabilities
    of a web service by referring to a unique entry point. In addition, it provides
    a high-level abstraction that can also be used for business or design purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, its standard way of querying services facilitates every kind of
    automation â€“ from the autogeneration of a client to the autogeneration of the
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Swagger project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the OpenAPI Specification, Swagger was born as a language-agnostic
    specification for describing REST APIs. It has recently been adopted by the OpenAPI
    project, which means there are no differences between these two projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main aim of Swagger is to autogenerate and expose a document called `swagger.json`,
    also known as the **Swagger Specification**. The Swagger Specification is the
    autogenerated documentation of the API and provides information about every single
    route that''s exposed by the web services. The following code shows the structure
    of an example `swagger.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet describes some of the routes that are defined in the
    **catalog service** API. As you can see, at the first level of the JSON, there
    is some general information about the service, such as the `apiVersion`, `title`,
    and `basePath` of the service. Furthermore, we can also see a node called `paths`,
    which contains all the paths of our service. For each route, it describes the
    different response types, the different HTTP verbs, and all the payload information
    that''s accepted by the service. Since we have a unique standard for describing
    our APIs, it is also possible to define a unique user interface so that we can
    query and send information to the service; this is what **Swagger UI** does. Swagger
    UI is a tool that uses the `swagger.json` file to provide a user-friendly UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68000202-f3d8-455b-928f-d5a3f0a2952f.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows an example of a useful UI that we can use to
    browse the different routes that are exposed by the APIs. Furthermore, it allows
    the consumer to have an immediate overall view of the data that's provided by
    the API. Now, let's learn how to implement OpenAPI in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OpenAPI in ASP.NET Core services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different packages that we can use to implement OpenAPI in ASP.NET
    Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swashbuckle**: [https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NSwag**: [https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of these use middleware to generate and serve the `swagger.json` file
    and allow the user interface to browse the service definition. In this section,
    we will discuss how to integrate NSwag into our vinyl catalog service. The following
    schema shows how NSwag is plugged into our ASP.NET Core service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9316aeb8-6ddc-4e23-b63f-140dc116b563.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by adding `NSwag.AspNetCore` to the `Catalog*.*API` project by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can proceed by combining the middleware to generate and provide
    the OpenAPI specification and the middleware to initialize the UI. As we saw in
    [Chapter 3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml), *Working with the Middleware
    Pipeline*, we need to use the `Configure` and `ConfigureServices` methods, which
    are implemented in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`AddOpenApiDocument` adds the services that are required for OpenAPI 3.0 generation.
    `UseOpenApi` adds the OpenAPI/Swagger generator, which uses API description to
    perform Swagger generation, and `UseSwaggerUi3` creates and instantiates the middleware
    that provides the UI of Swagger. Since we integrated the OpenAPI middleware into
    our service, we can proceed by running our service and browse the `https://localhost/swagger`
    URL using our preferred browser.'
  prefs: []
  type: TYPE_NORMAL
- en: NSwag and Swashbuckle use reflection to browse the action methods inside our
    controllers. Fortunately, this process is only executed the first time the service
    runs. Sometimes, complex response types can prevent the `swagger.json` file from
    being generated. For that reason, it is strongly suggested that you check all
    the response types that are provided by the action methods of our controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'NSwag also provides some useful utilities so that we can perform code generation
    on our web services, such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSwag.CodeGeneration.CSharp` ([https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/](https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSwag.CodeGeneration.TypeScript` ([https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/](https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These allow us to autogenerate client classes for C# and Typescript, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to install and configure NSwag so that we can
    expose Swagger documentation that's compatible with the OpenAPI Specification.
    In the next section, we will learn how to explicitly define the conventions for
    our APIs, as well as how to include additional information in the `swagger.json`
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ASP.NET Core's conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default response type of the Swagger UI produces some incorrect information.
    If we take a look at the responses section, we will see that the response code
    is incorrect and that it doesn''t correspond with the actual HTTP code that''s
    returned by the web service. When using ASP.NET Core 2.2 or later, it is possible
    to use conventions to specify the response types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the preceding code uses the `ApiConventionMethod` attribute to
    pass a custom type and a method name. The `ApiConventionMethod` attribute is part
    of the `Microsoft.AspNetCore.Mvc` namespace and uses the `DefaultApiConventions`
    static class, which provides a default set of conventions for each action in a
    generic API. In the same way, we can add that attribute to the writing methods
    of `ItemController`, such as the `Create`, `Update`, and `Delete` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of approach is a shortcut that we can use to declare action method
    responses without explicitly using the `ProducesResponseType` attribute. Let''s
    take a look at the `DefaultApiConventions` static class, which provides a set
    of default response types if we declare some static void methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For example, for the `Get` method, it states the `HTTP 200 OK` response and
    `HTTP 404 Not found`. By doing this, we can easily declare the proper response
    types for each action. The `DefaultApiConventions` class is part of the `Microsoft.AspNetCore.Mvc`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Custom conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DefaultApiConvention` class isn''t always suitable for our controllers.
    Furthermore, it is too generic, and action methods are usually too specific to
    suit the `DefaultApiConvention` class. Due to this, ASP.NET Core allows us to
    create our custom API conventions based on our needs. To declare a new convention,
    we need to create a new static class with the corresponding static methods, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The conventions we''ve implemented here describe the `Get` action method of
    `ItemController`. As you can see, this method produces the following HTTP responses:
    `200`, `404`, and `400`. This approach also allows us to generate and extend the
    response types that are returned by a route. Furthermore, it is possible to assign
    and use these conventions by applying the attribute in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows us to customize and group API conventions into a unique
    class and fully-customize the contract of the API. The same approach can be used
    for the other action methods that are present in the controller classes of your
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to improve the discoverability of web services
    by documenting them using the OpenAPI Specification. The OpenAPI technique also
    provides us with a standard way to generate clients in every language and generate
    auto-maintainable documentation. Documenting APIs is useful when the service is
    utilized by third-party teams and consumers, and also provides us with a high-level
    overview of the information and actions that are exposed by the service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Postman and how to use it to query,
    test, and check the responses of a web service.
  prefs: []
  type: TYPE_NORMAL
