- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Getting Creative with Creational Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创造性使用创建型模式
- en: Creational patterns deal with creating objects, a process we call *instantiation*.
    Remember, an object is a class that has been instantiated. Objects only exist
    in running programs. They are built from blueprints called *classes*. Since C#
    is a static language, you can’t generally change the structure of an object once
    it has been instantiated, which means you should use the best strategy to create
    your objects. That’s what we’ll be discussing in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式处理对象的创建，这个过程我们称之为*实例化*。记住，对象是一个已经被实例化的类。对象只存在于运行程序中。它们是由称为*类*的蓝图构建的。由于C#是一种静态语言，一旦对象被实例化，通常无法更改其结构，这意味着你应该使用最佳策略来创建你的对象。这就是我们将在本章讨论的内容。
- en: 'Even if you’re `new` to software development with C# (that might be the first
    pun in the book that relies only on formatting to be funny), you already know
    the simplest way to instantiate an object from a class. You simply use the `new`
    keyword and invoke the class’s constructor:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你是C#软件开发的`new`手（这可能是书中第一个仅依靠格式来搞笑的双关语），你也已经知道从类中实例化对象的最简单方法。你只需使用`new`关键字并调用类的构造函数：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s instantiation. You’re creating an instance of a class that acts as the
    point where the class turns into an object. In C#, like many languages, we use
    the `new` keyword in conjunction with a constructor. A constructor is a method,
    whose name. matches the class’s name Its only job is to create and return an instance
    of the class as a new object. That is why you have a parenthesis at the end of
    `CreateObjectThingy()`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实例化。你正在创建一个类的实例，这个类作为类转变为对象的点。在C#中，像许多语言一样，我们使用`new`关键字与构造函数一起使用。构造函数是一个方法，其名称与类的名称匹配。它的唯一任务是创建并返回一个类的实例作为新对象。这就是为什么`CreateObjectThingy()`的末尾有一个括号的原因。
- en: Why do we need anything else? Remember the foundational principles we covered
    earlier in this book. We don’t want a stovepipe system consisting of a bunch of
    object classes we can’t build from because they’re too specific, too concrete,
    or tightly coupled to one another. By definition, the `new` keyword creates a
    concrete object. Our classes should be open for extension but closed for modification.
    and However in stovepipe software they aren’t stovepipe software, they aren’t.
    Following patterns will help us avoid those situations and provide us with a clear
    way to create complex objects that are easy to understand and extend.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么还需要其他东西呢？记住这本书前面我们讨论的基础原则。我们不希望有一个由我们无法构建的许多对象类组成的管道系统，因为它们太具体、太具体，或者彼此之间耦合得太紧密。根据定义，`new`关键字创建一个具体对象。我们的类应该易于扩展但不易于修改。然而，在管道软件中，它们并不是管道软件，它们不是。遵循模式将帮助我们避免这些情况，并为我们提供一种创建复杂对象并易于理解和扩展的清晰方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The initial design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始设计
- en: No pattern implementation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有模式实现
- en: The Simple Factory pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单工厂模式
- en: The Factory Method pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The Builder pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者模式
- en: The Object Pool pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池模式
- en: The Singleton pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: These patterns will be shown in simple C# command-line projects to keep the
    proverbial signal-to-noise ratio low. There are a great many books out there that
    teach patterns independently of any coding language. I think this is a mistake.
    Most people learn by doing, and to “do” patterns, you need an implementation language.
    Without that, you are just learning academic concepts. We are focused on the real
    world and we’re using C#, but what you will learn in this book is 100% portable.
    As you learn about these patterns, remember that they are not language-specific.
    You can use the knowledge you gain here and apply it to Java, Python, or any other
    object-oriented language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式将通过简单的C#命令行项目来展示，以保持象征性的信号与噪声比低。有许多书籍独立于任何编程语言教授模式。我认为这是一个错误。大多数人通过实践来学习，而要“实践”模式，你需要一个实现语言。没有那个，你只是在学习学术概念。我们专注于现实世界，我们使用C#，但你在本书中学到的知识是100%可移植的。当你了解这些模式时，请记住，它们不是语言特定的。你可以使用在这里获得的知识并将其应用于Java、Python或任何其他面向对象的语言。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Throughout this book, I assume you know how to create new C# projects in your
    favorite **integrated development environment** (**IDE**), so I won’t spend any
    time on the mechanics of setting up and running projects. Should you decide to
    try any of this out, you’ll need the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我假设你知道如何在你的首选**集成开发环境**（**IDE**）中创建新的C#项目，所以我不会在设置和运行项目的机制上花费任何时间。如果你决定尝试这些，你需要以下内容：
- en: A computer running the Windows operating system. I’m using Windows 10\. Since
    the projects are simple command-line projects, I’m pretty sure everything here
    would also work on a Mac or Linux, but I haven’t tested the projects on those
    operating systems.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Windows操作系统的计算机。我使用的是Windows 10。由于项目是简单的命令行项目，我相当确信这里的一切也都可以在Mac或Linux上运行，但我还没有在这些操作系统上测试过这些项目。
- en: A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code
    with C# extensions. I’m using Rider 2021.3.3.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的IDE，如Visual Studio、JetBrains Rider或带有C#扩展的Visual Studio Code。我使用的是Rider 2021.3.3。
- en: Some version of the .NET SDK. Again, the projects are simple enough that our
    code shouldn’t be reliant on any particular version. I happen to be using the
    .NET Core 6 SDK.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK的某个版本。再次强调，项目足够简单，我们的代码不应该依赖于任何特定的版本。我恰好使用的是.NET Core 6 SDK。
- en: You can find the completed project files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的完成项目文件，网址为[https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3)。
- en: The following story is fictitious
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以下故事是虚构的
- en: Any resemblance to actual persons, alive or dead, is a mere coincidence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何在世或已故的人物的相似之处纯属巧合。
- en: 'Meet Kitty and Phoebe – Texas-born sisters who share a love for riding bicycles.
    Phoebe is studying engineering at Southern Methodist University, a private university
    in the sisters’ hometown of Dallas, Texas. Texas is one of the southernmost states
    in the United States. Kitty is studying industrial design at Sul Ross University
    in West Texas. Purely through kismet, they both won a summer internship at MegaBikeCorp,
    which is a large multi-national bicycle manufacturing company:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 来认识凯蒂和菲比——这对出生于德克萨斯州的姐妹，她们都对骑自行车有着共同的热爱。菲比在德克萨斯州达拉斯的南方卫理公会大学学习工程学，这是姐妹俩的家乡。德克萨斯州是美国最南部的几个州之一。凯蒂在德克萨斯州西部的Sul
    Ross大学学习工业设计。纯粹是命运的安排，她们俩都在MegaBikeCorp获得了暑期实习机会，这是一家大型跨国自行车制造公司：
- en: '![Figure 3.1: Kitty (left) and Phoebe (right) posing with their innovative
    bicycle prototype built entirely in their robotic factory. ](img/B18605_Figure_3.1_NEW.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：凯蒂（左）和菲比（右）在他们的机器人工厂中完全建造的创新自行车原型前摆姿势](img/B18605_Figure_3.1_NEW.jpg)'
- en: 'Figure 3.1: Kitty (left) and Phoebe (right) posing with their innovative bicycle
    prototype built entirely in their robotic factory.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：凯蒂（左）和菲比（右）在他们的机器人工厂中完全建造的创新自行车原型前摆姿势。
- en: 'While working at MegaBikeCorp, the sisters had the opportunity to try out several
    different kinds of bicycles. Phoebe, who lives in a big city, is partial to the
    road bike. Road bikes use a diamond-shaped frame with two large thin wheels, slick
    tires, and plenty of gears to help a rider deal with the steep hills they often
    encounter in many cities:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在MegaBikeCorp工作期间，姐妹俩有机会尝试几种不同类型的自行车。菲比住在大城市，偏爱公路自行车。公路自行车使用菱形车架，两个大而细的轮子，光滑的轮胎，以及丰富的变速器来帮助骑行者应对他们在许多城市经常遇到的陡峭的山丘：
- en: '![Figure 3.2 – Kitty’s CAD design for a road bike she calls Hillcrest. ](img/B18605_Figure_4.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 凯蒂为她称为Hillcrest的公路自行车所做的CAD设计](img/B18605_Figure_4.2.jpg)'
- en: Figure 3.2 – Kitty’s CAD design for a road bike she calls Hillcrest.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 凯蒂为她称为Hillcrest的公路自行车所做的CAD设计
- en: The rider on a road bike leans far forward on a set of dropped handlebars. This
    makes these bicycles fast, and every year, hundreds of riders from all over the
    world compete in a famous race called the *Tour de France*. In the tour, racers
    compete to see who is the fastest in the world. Kitty and Phoebe recalled that
    their mother, a huge cycling fan, would not allow anyone in the house to speak
    while the race was on television. Phoebe also enjoyed the tour and as she cycled
    through the streets of Dallas on her road bike, she would often have a desire
    to ride faster. This requires a different bike.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 骑行在公路自行车上的骑行者会向前倾斜，身体靠在低矮的车把上。这使得这些自行车速度很快，每年，来自世界各地的数百名骑行者都会参加一项名为*环法自行车赛*的著名赛事。在比赛中，选手们竞争，看谁是世界最快的。基蒂和菲比回忆起，她们的母亲，一个狂热的自行车爱好者，不允许在电视播放比赛时家里任何人说话。菲比也喜欢环法自行车赛，当她骑着她的公路自行车穿越达拉斯的街道时，她经常会渴望骑得更快。这需要一辆不同的自行车。
- en: 'Phoebe rides a recumbent bike when she needs to satisfy her need for speed.
    A recumbent bicycle features the rider sitting in a comfortable seat that looks
    more like a lawn chair but with wheels. You can see Kitty’s design in the following
    diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当菲比需要满足她对速度的需求时，她会骑躺式自行车。躺式自行车具有一个舒适的座椅，看起来更像带轮子的躺椅，你可以看到基蒂的设计在下图中：
- en: '![Figure 3.3 – Kitty’s CAD design for a recumbent bicycle. Note that the frame
    is shaped differently than the diamond shape used on most other bicycles such
    as the Hillcrest shown in the inset. These are among the fastest bicycles ever
    made. ](img/B18605_Figure_4.3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 基蒂为躺式自行车设计的CAD图。注意，车架的形状与大多数其他自行车（如插入图中所示的Hillcrest）所使用的菱形形状不同。这些是制造过的最快的自行车之一。](img/B18605_Figure_4.3.jpg)'
- en: Figure 3.3 – Kitty’s CAD design for a recumbent bicycle. Note that the frame
    is shaped differently than the diamond shape used on most other bicycles such
    as the Hillcrest shown in the inset. These are among the fastest bicycles ever
    made.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 基蒂为躺式自行车设计的CAD图。注意，车架的形状与大多数其他自行车（如插入图中所示的Hillcrest）所使用的菱形形状不同。这些是制造过的最快的自行车之一。
- en: The rider leans way back and sits very low on the bicycle. The seat is stretched
    out beneath Phoebe. The pedals are elevated above the front wheel to capture the
    power of the rider’s full leg extension. These bikes can go faster than a traditional
    racing bicycle and they’re very comfortable to ride over long distances. However,
    because of racing rules recognized throughout the world, they are never used for
    racing in events such as the *Tour de France*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 骑行者会向后倾斜，并非常低地坐在自行车上。座椅被拉长，位于菲比下方。脚踏板被提升到前轮上方，以捕捉骑行者腿部完全伸展时的力量。这些自行车比传统的赛车更快，而且骑行长途时非常舒适。然而，由于全球范围内认可的赛车规则，它们从未被用于如*环法自行车赛*等赛事中。
- en: 'Kitty, on the other hand, enjoys riding a mountain bike, which is designed
    to be ridden off-road like a Jeep. Mountain bikes, like road bikes, use a diamond-shaped
    frame, but they have big, knobby tires and disc brakes that work well in the mud.
    The rider sits more upright so that they can see and react to any off-road obstacles.
    The standard mountain bicycles usually have fancy shock absorbers in the front,
    and the more expensive bikes have a separate shock absorber on the back wheel,
    along with the front shocks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基蒂喜欢骑山地自行车，这种自行车设计用于越野骑行，就像吉普车一样。山地自行车，就像公路自行车一样，使用菱形车架，但它们有大的、多孔的轮胎和适合泥地的碟刹。骑行者坐得更直，这样他们可以观察并应对任何越野障碍。标准山地自行车通常在前轮有复杂的减震器，而更昂贵的自行车在后轮上有一个独立的减震器，以及前轮的减震器：
- en: '![Figure 3.4 – Kitty’s CAD drawing for an innovative design for a mountain
    bike that she calls the “Palo Duro Canyon Ranger”. ](img/B18605_Figure_4.4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 基蒂为她称为“Palo Duro Canyon Ranger”的创新山地自行车设计的CAD图。](img/B18605_Figure_4.4.jpg)'
- en: Figure 3.4 – Kitty’s CAD drawing for an innovative design for a mountain bike
    that she calls the “Palo Duro Canyon Ranger”.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 基蒂为她称为“Palo Duro Canyon Ranger”的创新山地自行车设计的CAD图。
- en: 'Kitty also likes riding in town, but she doesn’t like the uncomfortable riding
    position of a road bike. A recumbent bike is too dangerous to ride because it
    is so low to the ground that cowboys driving the big trucks that are so popular
    in Texas won’t be able to see her. Instead, Kitty likes to ride comfort cruisers,
    sometimes called *granny bikes*. They are perfect for in-town riding. They let
    her sit fully upright in a comfortable position owing to a curved handlebar design:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 契蒂也喜欢在镇上骑自行车，但她不喜欢公路自行车的难受骑行姿势。躺式自行车因为离地面太低，所以骑起来太危险，在德克萨斯州非常流行的那些驾驶大型卡车的牛仔们是看不到她的。相反，契蒂喜欢骑舒适的巡航车，有时也被称为*老奶奶自行车*。它们非常适合在镇上骑行。由于弯曲把手的设计，它们让她能够完全直立地坐在一个舒适的位置：
- en: '![Figure 3.5 – Kitty’s design for a comfort cruiser bicycle, sometimes called
    a granny bike. These are perfect for in-town commutes and tourists who need to
    get around comfortably. ](img/B18605_Figure_4.5.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 契蒂设计的舒适巡航自行车，有时也被称为老奶奶自行车。这些自行车非常适合在镇上通勤和需要舒适出行的游客。](img/B18605_Figure_4.5.jpg)'
- en: Figure 3.5 – Kitty’s design for a comfort cruiser bicycle, sometimes called
    a granny bike. These are perfect for in-town commutes and tourists who need to
    get around comfortably.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 契蒂设计的舒适巡航自行车，有时也被称为老奶奶自行车。这些自行车非常适合在镇上通勤和需要舒适出行的游客。
- en: The cruisers have thick tires for stability and they have a chain guard and
    enclosed gear system to prevent ruining the left leg of your pants, which tends
    to rub against the bicycle chain. These bicycles are built for comfort rather
    than speed or off-road prowess.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 巡航车配备了厚轮胎以增加稳定性，并且有链条防护罩和封闭式齿轮系统，以防止你的左腿裤子被链条磨坏，这通常会发生。这些自行车的设计是为了舒适而不是速度或越野能力。
- en: 'Between them, the sisters rode every model of bicycle produced by MegaBikeCorp.
    Phoebe found the level of engineering innovation at MegaBikeCorp uninspiring.
    Kitty felt MegaBike’s designs were stale. “*They’ve been making the same four
    bicycles for 30 years,*” Kitty said. The sisters decided they could do better
    and decided to make a plan of action. After many long nights, lots of tacos, online
    collaboration sessions, bicycle rides, and a few skinned knees, they came up with
    four bicycle designs. But the sisters did not stop with bike designs. They also
    came up with plans for a robotic manufacturing system that could fully automate
    the bicycle production process. Together, they formed a start-up company called
    *Bumble Bikes Incorporated*, named after Phoebe’s favorite childhood toy: a stuffed
    bumblebee she named *Bumbles*. They plan to open two manufacturing locations:
    one in the sisters’ hometown of Dallas, Texas, and the other in Kitty’s college
    town of Alpine, Texas. The two areas are very different geographically.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 两位姐妹骑遍了MegaBikeCorp生产的每一种自行车型号。菲比觉得MegaBikeCorp的工程创新水平令人鼓舞。契蒂觉得MegaBike的设计已经过时了。“*他们已经生产了同样的四种自行车30年了*，”契蒂说。姐妹俩决定她们可以做得更好，并决定制定一个行动计划。经过许多漫长的夜晚，大量的玉米卷饼，在线协作会议，自行车骑行，以及一些擦伤的膝盖，她们提出了四种自行车设计。但姐妹俩并没有止步于自行车设计。她们还提出了一个机器人制造系统的计划，该系统能够完全自动化自行车生产过程。她们一起成立了一家名为*Bumble
    Bikes Incorporated*的初创公司，这个名字来源于菲比最喜欢的童年玩具：一只她命名为*Bumbles*的填充大黄蜂。她们计划开设两个制造地点：一个在姐妹们的家乡德克萨斯州的达拉斯，另一个在契蒂的大学城阿尔派恩，德克萨斯州。这两个地区在地理上非常不同。
- en: North Texas, Dallas in particular, is urban and heavily developed. Cycling is
    a popular sport and hobby for many North Texans. The riders in the Dallas area
    primarily buy traditional road bicycles. Surprisingly, there is also a lot of
    interest in recumbent bicycles, especially around the large engineering colleges.
    You can even see recumbents ridden around the 7 million-square-foot (650 million
    square-meter) campus of Texas Instruments – a large semi-conductor manufacturer
    in Dallas. The girls decided to build their road bike and recumbent bike designs
    in the factory in Dallas.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 北德克萨斯州，尤其是达拉斯，是城市化和高度发达的地区。骑自行车对于许多北德克萨斯人来说是一种流行的运动和爱好。达拉斯地区的骑行者主要购买传统的公路自行车。令人惊讶的是，躺式自行车也非常受欢迎，尤其是在大型工程学院附近。你甚至可以在德克萨斯仪器公司7百万平方英尺（6.5亿平方米）的校园里看到躺式自行车，德克萨斯仪器公司是一家位于达拉斯的大型半导体制造商。女孩们决定在达拉斯的工厂建造她们的公路自行车和躺式自行车设计。
- en: In West Texas, the city of Alpine is the last bastion of civilization north
    of Big Bend National Park. Extreme mountain biking is popular in the Chisos mountain
    basin and the old mining and cattle roads that crisscross the desert. Alpine is
    a small town and doesn’t have or need any mass transit services. Kitty’s research
    indicates there is a market for comfortable “cruiser” bicycles that are ideal
    for getting around town. Kitty decides to manufacture the mountain bike and the
    cruiser models in Alpine. Phoebe and Kitty, with their initial plans in hand,
    set to work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在西德克萨斯州，阿尔派市是比格本国家公园以北的最后一块文明堡垒。极限山地自行车在奇索斯山脉盆地以及横穿沙漠的旧采矿和牛车路非常流行。阿尔派是一个小镇，没有也不需要任何大众交通服务。凯蒂的研究表明，市场上需要舒适型“巡航”自行车，这种自行车非常适合在镇上四处走动。凯蒂决定在阿尔派制造山地自行车和巡航车型。手握初步计划，菲比和凯蒂开始着手工作。
- en: Phoebe tasked herself to work on the robotics to be used in manufacturing the
    bicycles. Kitty settled down with her favorite C# IDE and got to work on the control
    software that would ultimately control Phoebe’s robotics. She knows that her designs,
    along with Phoebe’s engineering, will produce the best bicycles the industry has
    ever seen. Kitty is planning on their company and the software that runs it being
    wildly successful, which, as we learned in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016),
    *There’s a Big Ball of Mud on Your Plate of Spaghetti*, is the worst-case scenario.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比负责研究用于制造自行车的机器人技术。凯蒂坐在她最喜欢的C#集成开发环境中，开始编写将最终控制菲比机器人的控制软件。她知道她的设计，连同菲比的工程，将生产出行业有史以来最好的自行车。凯蒂计划他们的公司和运行的软件将取得巨大的成功，正如我们在[*第1章*](B18605_01.xhtml#_idTextAnchor016)中学习的，“你的意大利面盘上有一大团泥巴”，这是最坏的情况。
- en: Kitty’s starting point in writing the code for her robotics control software
    is going to be modeling out the basic class structure for very generic bicycle
    objects. This modeling will form the basis of her entire company’s future. Modeling
    the classes well the first time will put Kitty and Phoebe riding their bicycles
    down the road to success!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂编写机器人控制软件代码的起点将是为非常通用的自行车对象建模基本类结构。这种建模将成为她整个公司未来的基础。第一次就很好地建模类将使凯蒂和菲比骑上通往成功的自行车之路！
- en: 'Let’s follow the exploits of the sisters, Kitty and Phoebe, as they embark
    on building the automated plant’s robotic control systems. We’ll focus on creational
    patterns, which are just what they sound like: patterns for controlling the instantiation
    of objects.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随姐妹俩凯蒂和菲比的冒险，她们着手构建自动化工厂的机器人控制系统。我们将关注创建型模式，正如其名称所示：控制对象实例化的模式。
- en: The initial design
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始设计
- en: Kitty knows she wants to model a bicycle for her software, and she wants to
    design her models in a way that maximizes each class’s flexibility. The plan for
    the start-up is to develop four bicycles with a future expansion to include exotic
    bicycles and custom builds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂知道她想要为她的软件建模自行车，并且她希望以最大化每个类别的灵活性来设计她的模型。创业计划是开发四种自行车，未来将扩展以包括异国情调的自行车和定制构建。
- en: Kitty opens her IDE and creates a class library project to hold her classes
    since she knows she’s probably going to use these in several different programs.
    She calls the class library `BumbleBikesLibrary` which you’ll find in the sample
    code for this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂打开她的IDE，创建一个类库项目来存放她的类，因为她知道她可能会在几个不同的程序中使用这些类。她将类库命名为`BumbleBikesLibrary`，你可以在本章的示例代码中找到它。
- en: 'She decides to start with an abstract class and to use inheritance to define
    her bicycle models for each of the four types of bicycles she intends to initially
    design and manufacture. *Figure 3.6* shows the result of her effort. This set
    of properties can be used to define nearly any type of bicycle:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 她决定从一个抽象类开始，并使用继承来定义她打算最初设计和制造的四种自行车模型。*图3.6*展示了她努力的结果。这组属性可以用来定义几乎任何类型的自行车：
- en: '![Figure 3.6 – The abstract bicycle model. ](img/B18605_Figure_4.6.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 抽象自行车模型。](img/B18605_Figure_4.6.jpg)'
- en: Figure 3.6 – The abstract bicycle model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 抽象自行车模型。
- en: 'Let’s take a look at these properties in more detail:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些属性：
- en: '`ModelName`: The name of the model as it will appear on the company website.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModelName`：模型在公司网站上的名称。'
- en: '`Year`: The model year for the bicycle. All bicycle designs should be updated
    every 2 years to prevent the designs from becoming stale like MegaBikeCorp’s.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Year`：自行车的型号年份。所有自行车设计应每两年更新一次，以防止设计像 MegaBikeCorp 的那样过时。'
- en: '`SerialNumber`: A unique identifier for each bicycle that rolls off the assembly
    line.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SerialNumber`：每辆从生产线下来的自行车的唯一标识符。'
- en: '`Color`: The color of the bicycle. To keep initial costs low, Kitty will define
    an enumeration with a limited set of colors for each model.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Color`：自行车的颜色。为了保持初始成本较低，Kitty 将为每个型号定义一个具有有限颜色集合的枚举。'
- en: '`Geometry`: This refers to the frame configuration for the bicycle. All the
    bikes for the initial manufacturing run are either upright or recumbent geometries.
    This can be moved into an enumeration as well.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Geometry`：这指的是自行车的车架配置。所有初始制造运行的自行车都是直立或躺式几何形状。这也可以被移动到枚举中。'
- en: '`Suspension`: This refers to the type of shock absorbers used on the bicycle.
    Shocks are most important on mountain bikes, but you also find them on road bicycles,
    recumbents, and some cruisers. It could be argued that this property is only appropriate
    for a mountain bike subclass, but Kitty knows about “analysis paralysis.” Rather
    than trying to get the model perfect on the first go-around, she decides to put
    it in the superclass for now. She can always refactor it later when things become
    more concrete, or if she gets a whiff of smelly code structure.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspension`：这指的是自行车上使用的减震器类型。减震器在山地自行车上最为重要，但您也可以在公路自行车、躺式自行车和一些巡航车上找到它们。可以争论说，这个属性只适用于山地自行车子类，但Kitty了解“分析瘫痪”。她决定现在将其放入超类中，而不是试图在第一次尝试时就使模型完美。她可以在事情变得更加具体或如果她闻到有问题的代码结构时，稍后总是可以重构它。'
- en: '`BuildStatus`: Kitty knows her robotics control system needs to understand
    the current state of the bicycle build process, so she decides to include an enumerated
    property to hold this information.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildStatus`：Kitty 知道她的机器人控制系统需要了解自行车制造过程的当前状态，因此她决定包括一个枚举属性来保存此信息。'
- en: 'Several properties can be expressed as an enumeration, which is a fixed collection.
    Back in the old days, we used “magic numbers” to represent finite lists. The programmers
    would assign an integer to each value. As an example, to represent a finite list
    of suspension types, we might be tempted to number them 0 through 3, since there
    are four possibilities. This made maintenance difficult because everyone had to
    remember what each number meant. Was it 0 for a full suspension? What was the
    code for a hardtail? Later, we wised up and defined constants for everything:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 几个属性可以表示为枚举，它是一个固定的集合。在过去的岁月里，我们使用“魔法数字”来表示有限列表。程序员会为每个值分配一个整数。例如，为了表示悬挂类型的有限列表，我们可能会倾向于将它们编号为
    0 到 3，因为总共有四种可能性。这使得维护变得困难，因为每个人都需要记住每个数字的含义。0 是全悬挂吗？硬尾的代码是什么？后来，我们变得聪明起来，为所有事物定义了常量：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is better, but it isn’t very object-oriented. You wind up with dozens
    of lines of ugly constant definitions in all caps. You might be tempted to use
    an integer type to model them since you are presented with the opportunity to
    assign an arbitrary integer as a value. What will stop someone from setting it
    to 100 when the potential values are supposed to be from 0 to 3? We could write
    encapsulation logic to enforce our range of 0 to 3\. That’s all well and good,
    but we’d have to constantly alter the accessor logic every time we add a new suspension
    to the line-up. Thankfully, in C#, we have `<<Enumeration>>` tag at the top of
    the box. Our bicycle class uses four enumerations, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好，但它并不非常面向对象。您最终会得到数十行大写字母的丑陋常量定义。您可能会倾向于使用整数类型来模拟它们，因为您有机会分配一个任意的整数值。什么会阻止某人将其设置为
    100，当潜在值应该是从 0 到 3 时？我们可以编写封装逻辑来强制我们的范围是 0 到 3。这都很好，但每次我们向阵容中添加一个新的悬挂时，我们都需要不断修改访问器逻辑。幸运的是，在
    C# 中，我们在框的顶部有 `<<Enumeration>>` 标签。我们的自行车类使用四个枚举，如下所示：
- en: '![Figure 3.7 – Four enumerations are defined to limit the options available
    for our abstract bicycle’s geometry, suspension, color, and current manufacturing
    status. Enumerations help us keep our object’s state clean, valid, and easy to
    read. ](img/B18605_Figure_4.7.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 定义了四个枚举来限制我们抽象自行车的几何形状、悬挂、颜色和当前制造状态的可选选项。枚举帮助我们保持对象状态整洁、有效且易于阅读。](img/B18605_Figure_4.7.jpg)'
- en: Figure 3.7 – Four enumerations are defined to limit the options available for
    our abstract bicycle’s geometry, suspension, color, and current manufacturing
    status. Enumerations help us keep our object’s state clean, valid, and easy to
    read.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.7* – 定义了四个枚举来限制我们抽象自行车的几何形状、减震、颜色和当前制造状态的选项。枚举帮助我们保持对象状态干净、有效且易于阅读。'
- en: 'Before getting into patterns, let’s begin by creating what we have diagrammed
    so far. First, Kitty will make the four enumerations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入模式之前，让我们先创建到目前为止所绘制的图形。首先，Kitty 将进行四个枚举：
- en: '`SuspensionTypes`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SuspensionTypes`'
- en: '`BicycleGeometries`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BicycleGeometries`'
- en: '`BicyclePaintColors`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BicyclePaintColors`'
- en: '`ManufacturingStatus`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManufacturingStatus`'
- en: 'Here is the `BicycleGeometries` enumeration:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `BicycleGeometries` 枚举：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, she makes an `enum` for suspension types:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，她创建了一个用于减震类型的 `enum`：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next comes the paint colors:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是油漆颜色：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, Kitty makes an `enum` for manufacturing status codes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kitty 创建了一个用于制造状态代码的 `enum`：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With those out of the way, let’s see what the `Bicycle` base class looks like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们看看 `Bicycle` 基类是什么样的：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Kitty creates the `Bicycle` class as an abstract class, just as she did in the
    UML model. Note that the name of the class in *Figure 3.6* is *italicized*, indicating
    it is abstract. Next, she adds the properties. The UML model purposefully left
    out the access modifiers and types, leaving those as implementation details for
    the programmer to determine. In this case, as it is with many start-up projects,
    the architect and developer are the same person.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 创建了一个名为 `Bicycle` 的抽象类，就像她在 UML 模型中所做的那样。注意，*图 3.6* 中的类名被*斜体*标注，表示它是抽象的。接下来，她添加了属性。UML
    模型故意省略了访问修饰符和类型，将这些留作程序员确定的实现细节。在这种情况下，就像许多初创项目一样，架构师和开发者是同一个人。
- en: Kitty defines several of the properties as being protected because she intends
    to manipulate them from the subclasses. A few of the properties are marked `private`
    since it is appropriate to manipulate those at a higher level.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 将一些属性定义为受保护的，因为她打算从子类中操作它们。一些属性被标记为 `private`，因为适当地在更高层次上操作这些属性是合适的。
- en: 'Next, she moves on to the constructor, which is the function that is run with
    instantiation using the `new` keyword:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，她转向构造函数，这是使用 `new` 关键字进行实例化时运行的函数：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Kitty sets the default values for each property within the constructor. The
    model name, for now, is empty. She’ll change that in the subclass. The serial
    number property is a generated GUID, which is a string that is guaranteed to always
    be unique. The `Year` property is set to the current year, and `BuildStatus` is
    set to the first status in the enumeration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 在构造函数中为每个属性设置了默认值。目前，车型名称为空。她将在子类中更改它。序列号属性是一个生成的 GUID，这是一个保证始终唯一的字符串。`Year`
    属性设置为当前年份，`BuildStatus` 设置为枚举中的第一个状态。
- en: 'The last step is to add the `Build` method. For now, the `Build` method will
    just print to the console to show the logic is working correctly. Eventually,
    this can be substituted for the more complex control logic for Phoebe’s robotic
    systems:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加 `Build` 方法。目前，`Build` 方法只是打印到控制台以显示逻辑是否正确工作。最终，这可以替换为 Phoebe 机器人系统的更复杂控制逻辑：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The abstract class is done! Next, Kitty needs to create the concrete subclasses
    for the bicycles they intend to build:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类已经完成！接下来，Kitty 需要创建他们打算制造的自行车的具体子类：
- en: '`RoadBike`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoadBike`'
- en: '`MountainBike`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MountainBike`'
- en: '`Recumbent`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recumbent`'
- en: '`Cruiser`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cruiser`'
- en: 'First, she makes the `RoadBike` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，她创建了 `RoadBike` 类：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `RoadBike` class inherits from `Bicycle` and the constructor sets the defaults
    for the class. The model name is `Hillcrest`, after the name of the street that
    runs West of Phoebe’s university campus. Road bikes typically lack shock absorbers,
    so she defines the suspension type as `Hardtail`. The initial models only come
    in one color, and this one comes in blue. Since this isn’t a recumbent, the geometry
    is set to `Upright`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoadBike` 类从 `Bicycle` 类继承，构造函数设置了类的默认值。车型名为 `Hillcrest`，这个名字来自 Phoebe 大学校园西边的街道。公路自行车通常没有减震器，所以她将减震类型定义为
    `Hardtail`。初始型号只有一种颜色，这款是蓝色的。由于这不是一款躺式自行车，所以几何形状设置为 `Upright`。'
- en: 'With Phoebe’s favorite road bike out of the way, Kitty sets to modeling her
    favorite – the mountain bike:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完 Phoebe 最喜欢的公路自行车之后，Kitty 开始建模她最喜欢的——山地自行车：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Kitty names the mountain bike after the Palo Duro Canyon located in the Texas
    panhandle. Few people know that the Palo Duro Canyon is the second-largest canyon
    in the United States, after the Grand Canyon. Palo Duro Canyon is home to some
    of the best mountain biking in Texas. She wants an aggressive look for her design,
    so she goes with `Black` for the color. Naturally, not being one to skimp, she
    creates the design with full suspension – shocks on the front and rear of the
    bicycle to handle any obstacle the trail might present. As mentioned previously,
    given it isn’t recumbent, the geometry is defined as `Upright`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂以德克萨斯州潘哈德尔的帕洛杜罗峡谷命名山地自行车。很少有人知道帕洛杜罗峡谷是美国第二大峡谷，仅次于大峡谷。帕洛杜罗峡谷是德克萨斯州一些最好的山地自行车骑行地。她希望设计有侵略性的外观，因此选择了`黑色`作为颜色。自然地，她不是一个会节省开支的人，因此她设计了全悬挂式设计——自行车前后都有减震器，以应对小径上可能出现的任何障碍。如前所述，由于它不是躺式，其几何形状被定义为`直立`。
- en: 'Now, the `Recumbent` bicycle class needs to be created:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要创建`躺式`自行车的类别：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Kitty decides to call this bike *Big Bend*. The Big Bend area is a desert with
    a mountain range, which has a host of mountain biking opportunities. However,
    there are great stretches of paved and unpaved roads that are more or less straight.
    Recumbents do well in those environments as their design allows riders to go faster
    and farther without getting tired. The recumbents are also pretty good at pulling
    trailers. A person who desires to camp can carry adequate water and supplies.
    Since the bicycle’s namesake has paved and unpaved roads, Kitty opts for a front
    suspension. Recumbents already have a nice seat, so rear suspension doesn’t add
    many benefits, and it would make the bicycle more expensive. Naturally, the geometry
    is set to `Recumbent`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂决定将这辆自行车命名为*大弯*。大弯地区是一个沙漠，有一个山脉，那里有许多山地自行车骑行机会。然而，有很长一段铺砌和不铺砌的道路，大致上是直的。躺式自行车在这些环境中表现良好，因为它们的设计允许骑行者更快、更远地骑行而不会感到疲劳。躺式自行车在拖曳拖车方面也相当不错。一个想要露营的人可以携带足够的水和补给。由于自行车的名字来源于铺砌和不铺砌的道路，奇蒂选择了前悬挂。躺式自行车已经有一个很好的座椅，所以后悬挂不会增加很多好处，而且会使自行车更贵。自然地，几何形状被设置为`躺式`。
- en: 'The final bicycle is the cruiser:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种自行车是休闲车：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Kitty names this bicycle the *Galveston Cruiser* after fondly remembering her
    seaside vacations with her family. Galveston is a medium-sized city on the Gulf
    of Mexico. Galveston has beaches, a pier for commercial and vacation cruise ships,
    and a lively historical district called *The Strand*. The Strand is loaded with
    one-of-a-kind shops, cafes, bars, museums, and fun activities for tourists. Parking
    at the Strand is expensive, and often difficult to find. Galveston’s Strand is
    the perfect place to ride a cruiser, aside from the less known streets of Alpine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂以她与家人在海边度假的美好回忆为名，将这辆自行车命名为*加尔维斯顿休闲车*。加尔维斯顿是墨西哥湾的一个中等城市。加尔维斯顿有海滩、商业和度假游轮的码头，以及一个充满活力的历史区，称为*斯特兰德*。斯特兰德充满了独一无二的商店、咖啡馆、酒吧、博物馆和为游客提供的娱乐活动。在斯特兰德的停车费用昂贵，而且往往很难找到停车位。除了阿尔派因不太为人所知的街道外，加尔维斯顿的斯特兰德是骑休闲车的完美场所。
- en: No pattern implementation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有模式实现
- en: 'Kitty is on a roll! You know how it gets. She knocked out the enumerations,
    base class, and subclasses in nary an hour. She’s seriously *cruising* along and
    she doesn’t want to lose velocity. Kitty gives in to the temptation to write this
    code for the final implementation of the main entry point for the program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂正在一路高歌猛进！你知道那是怎么回事。她在一小时内就完成了枚举、基类和子类的编写。她真的在快速前进，而且她不想失去速度。奇蒂屈服于诱惑，为程序的最终实现编写了主入口点的代码：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We take in an argument from the command-line program and use that to determine
    what to make. If a string was passed in, the length of `args` will be greater
    than zero and we can do our thing. Otherwise, we can admonish our foolish users
    for thinking our software can read their minds:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从命令行程序中获取一个参数，并使用它来确定要创建什么。如果传递了一个字符串，`args`的长度将大于零，我们可以做我们的事情。否则，我们可以责备我们愚蠢的用户，因为他们认为我们的软件能读懂他们的心思：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s a good idea to trim and normalize your command-line input. This means
    we ignore extra spaces in front of and after the argument. We ignore the case
    by forcing everything to either upper or lowercase so that we can compare the
    input with our expected values. The comparison works regardless of whether the
    user passed in *mountainbike*, *MOUNTAINBIKE*, or even *mOuNtAiNbIkE*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 剪切和规范化命令行输入是个好主意。这意味着我们忽略参数前后多余的空格。我们通过强制将所有内容转换为上档或小写来忽略大小写的情况，以便我们可以将输入与我们的预期值进行比较。比较无论用户输入的是
    *mountainbike*、*MOUNTAINBIKE* 还是甚至 *mOuNtAiNbIkE* 都能正常工作：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next comes a `switch` statement based on the input. The input determines what
    to build and returns the corresponding class instance:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个基于输入的 `switch` 语句。输入确定要构建的内容，并返回相应的类实例：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the user passes an argument that we haven’t accounted for in the switch,
    such as `MotorCycle` or `PeanutButter`, we write and throw an exception:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户传递了一个我们在 `switch` 中没有考虑到的参数，比如 `MotorCycle` 或 `PeanutButter`，我们编写并抛出一个异常：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If no arguments were passed into the command-line program, we show an error
    message instructing the user to supply the required argument:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有将参数传递到命令行程序中，我们显示一个错误消息，指示用户提供所需的参数：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Effectively, Kitty is taking a command-line argument and using the software’s
    main entry point, `Program.cs`, as the class that will instantiate the correct
    bicycle type. She tries it out and it works! Kitty has cleverly leveraged Liskov
    substitution by using the abstract base class as her type for the `bikeToBuild`
    variable, which allows her to instantiate the appropriate subclass based on what
    kind of bike she wants to build. Kitty would not be able to do that if she was
    working at MegaBikeCorp. She would probably have a pointy-haired boss who would
    tell her to clean up the code and ship it. Thankfully, she’s in business for herself
    as a nagging voice in the back of her mind decries, “*You can do better.*”
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，基蒂正在使用命令行参数，并使用软件的主入口点 `Program.cs` 作为将实例化正确自行车类型的类。她试了一下，结果成功了！基蒂巧妙地利用了
    Liskov 替换原则，通过使用抽象基类作为 `bikeToBuild` 变量的类型，这使得她可以根据她想要构建的自行车类型实例化适当的子类。如果她在 MegaBikeCorp
    工作，她将无法做到这一点。她可能有一个爱挑剔的老板会告诉她清理代码并发货。幸运的是，她是个个体户，她内心深处的一个声音在抱怨，“*你可以做得更好。*”
- en: Kitty’s first implementation can be found in the `NoPattern` project within
    this chapter’s sample source code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂的第一个实现可以在本章示例源代码中的 `NoPattern` 项目中找到。
- en: The Simple Factory pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单工厂模式
- en: Kitty decides to do a little research on patterns. She wasn’t a computer science
    major in college and had only heard of patterns in her coding class. Kitty looks
    around and finds some blog articles on something called **the Simple Factory pattern**.
    Perfect, she thinks. This being her first coding project since college, and since
    she has a lot *riding* on her code (see what I did there?), she decides that something
    with *simple* right there in the name is a good place to start.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂决定对模式进行一些研究。她在大学时并没有计算机科学专业，只是在她的编码课程中听说过模式。基蒂四处寻找，并找到了一些关于称为 **简单工厂模式** 的内容的博客文章。太好了，她心想。这是她大学以来的第一个编码项目，而且她对自己的代码寄予厚望（看我在这里做了什么？），她决定以名字中的
    *simple* 为起点。
- en: According to the blogs, all she has to do is move her instantiation logic into
    its own class, called a **factory class**. This is done, say the articles, to
    decouple the instantiation logic from the main program. This should get her closer
    to honoring the open-closed principle and should make her code more flexible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据博客文章，她只需要将实例化逻辑移动到自己的类中，这个类被称为 **工厂类**。文章中说，这样做是为了将实例化逻辑与主程序解耦。这应该让她更接近遵循开闭原则，并使她的代码更加灵活。
- en: 'She returns to her IDE and adds a class called `SimpleBicycleFactory` and moves
    her instantiation logic there. The logic is the same as that shown previously:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 她回到她的集成开发环境（IDE），并添加了一个名为 `SimpleBicycleFactory` 的类，并将实例化逻辑移动到那里。逻辑与之前展示的相同：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, Kitty refactors her `Program.cs` file to use the simple factory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，基蒂重构了她的 `Program.cs` 文件以使用简单工厂：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the different part – Kitty uses the `SimpleBicycleFactory` class instead
    of directly running a `switch` statement:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是不同的部分——基蒂使用 `SimpleBicycleFactory` 类而不是直接运行一个 `switch` 语句：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A refactor, by definition, means you are improving the structure or performance
    of your code without introducing any new features. Kitty has accomplished this
    by making her code a little more elegant.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，重构意味着你在不引入任何新功能的情况下改进代码的结构或性能。Kitty通过使她的代码更加优雅实现了这一点。
- en: When the logic is free-range in the `Program.cs` file, it is locked into being
    used in only that program. Kitty wisely realizes that she and, undoubtedly, Phoebe
    will want to create other programs that can use the creation logic. Encapsulating
    the logic into a class is an obvious improvement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当逻辑在`Program.cs`文件中是自由范围的，它就被锁定只能用于那个程序。Kitty明智地意识到她和，毫无疑问，Phoebe将想要创建其他可以使用创建逻辑的程序。将逻辑封装到类中是一个明显的改进。
- en: Kitty, before closing her laptop for the evening, notices a post on social media
    from her programming professor. She asks how he’s been and while catching up,
    she mentions her code project. The prof says he’d love to see it, so she sends
    him a GitHub link.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在晚上关闭笔记本电脑之前，Kitty注意到了社交媒体上她编程教授的一条帖子。她询问他最近怎么样，在聊天中，她提到了她的代码项目。教授说他很乐意看看，于是她给他发了一个GitHub链接。
- en: The code Kitty’s professor is going to review can be found in the `SimpleFactoryPattern`
    project within this chapter’s sample source code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty的教授将要审查的代码可以在本章示例源代码中的`SimpleFactoryPattern`项目中找到。
- en: The Factory Method pattern
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: Kitty’s old professor looks at the code and tells her this newer code is an
    improvement, but she isn’t using a pattern. The simple factory is classified as
    a **programming idiom**. Idioms are like patterns, in that they occur frequently.
    You recognize them when you see one, but they haven’t fully realized any solutions
    to common problems. Perhaps the most famous programming idiom ever devised was
    created in Kernighan and Ritchie’s book titled *The C Programming Language*, also
    known as *The K&R book*. It was in this book we saw our very first *Hello, World*
    program. *Hello, World* is an idiom. It usually serves as the first few lines
    of code you try when you are learning a new language. It doesn’t solve any industrial-grade
    problems by encouraging flexibility and code reuse.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty的旧教授看了看代码，告诉她这个更新的代码是一个改进，但她没有使用任何模式。简单工厂被归类为**编程习语**。习语就像模式一样，它们经常出现。当你看到它们时，你会认出它们，但它们并没有完全解决常见问题。也许最著名的编程习语是Kernighan和Ritchie所著的《C程序设计语言》一书中创造的，也被称为*The
    K&R book*。正是在这本书中，我们看到了我们的第一个*Hello, World*程序。*Hello, World*是一个习语。它通常是你学习新语言时尝试的前几行代码。它通过鼓励灵活性和代码重用，并没有解决任何工业级问题。
- en: 'Kitty realized she’d seen this idiom in her IDE of choice for C#, JetBrains
    *Rider*. When you create a console application, like the one she’s been working
    on, the first thing you see is this code , which is generated by the IDE as a
    starting point for the project:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty意识到她曾在她选择的C# IDE中看到过这个习语，那就是JetBrains *Rider*。当你创建一个控制台应用程序，就像她一直在做的那样，你首先看到的是这段代码，这是IDE作为项目起点的生成代码：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I have included an example of a `Hello,` `World` program. You’ll find it in
    the `HelloWorld` project, located within the chapter’s source code. Yes, I did
    include a `Hello, World` program because I’m all about attention to detail. Now,
    back to the story.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我包括了一个`Hello,` `World`程序的例子。你可以在章节源代码中的`HelloWorld`项目中找到它。是的，我确实包括了一个`Hello,
    World`程序，因为我非常注重细节。现在，回到故事中。
- en: 'The next day, Kitty sets herself to fully researching the creational patterns.
    She wanted to do this the right way. After some reading, Kitty found several patterns
    called factory patterns:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，Kitty决定全面研究创建型模式。她想要正确地做这件事。阅读了一些资料后，Kitty发现了几种被称为工厂模式的模式：
- en: The simple factory, which we’ve established isn’t a pattern, but it is often
    mistaken for one.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单工厂，我们已经确定它不是一个模式，但它经常被误认为是。
- en: The Factory pattern, which is a mild improvement over the simple factory.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式，它是对简单工厂的一个轻微改进。
- en: The Factory Method pattern, which truly abstracts the creation process when
    you have a variety of object types to instantiate.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式，它真正抽象了当你需要实例化多种对象类型时的创建过程。
- en: The Abstract Factory pattern, which, for now, seems more complex than necessary
    since it deals with creating groups of objects.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式，它目前似乎比必要的更复杂，因为它涉及到创建对象组。
- en: 'Kitty settled on what she thought would be the perfect pattern for her problem:
    **the Factory Method pattern**. She also thought it ironic that the starting point
    for her software design was working with a factory pattern, given she was modeling
    what would one day be a physical factory. The factory patterns are so-called because
    they take a set of inputs and produce a concrete object as output. The simple
    factory accomplished this at a superficial level, but there are some problems
    with relying on the idiom in place of the real pattern. The idiom isn’t as flexible
    as it could be. Bumble Bikes Inc. is going to have two factory locations making
    different types of bicycles. The simple factory can create any bicycle, but at
    the same time, it’s locked into making all four. Relate that to a real factory
    and you can see it might be wasteful to require the factory to make every kind
    of bicycle, instead of the two that it will be making.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂确定了她认为适合她问题的完美模式：**工厂方法模式**。她也认为讽刺的是，她的软件设计的起点是使用工厂模式，因为她正在模拟一个将来将成为物理工厂的东西。工厂模式之所以被称为工厂模式，是因为它们接受一组输入并产生一个具体的对象作为输出。简单的工厂在表面上完成了这个任务，但依赖于这种习语而不是真实模式有一些问题。习语不如它可能的那样灵活。Bumble
    Bikes Inc. 将有两个工厂地点制造不同类型的自行车。简单工厂可以创建任何自行车，但与此同时，它被锁定在制造所有四种。将这一点与真实工厂联系起来，你可以看到要求工厂制造每种类型的自行车可能是浪费的，而不是它将要制造的两种。
- en: 'In our software design, the factory shouldn’t have any knowledge of what it
    is going to create. It should be flexible enough to make any kind of bicycle.
    We can structure this so that we can create a factory capable of producing a subset
    of all the subclasses. The subclasses decide what can and should be made concrete.
    We can diagram the generic factory method pattern as so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的软件设计中，工厂不应了解它将要创建的内容。它应该足够灵活，可以制造任何类型的自行车。我们可以这样构建，以便我们可以创建一个能够生产所有子类子集的工厂。子类决定什么可以和应该被具体化。我们可以这样表示通用的工厂方法模式：
- en: '![Figure 3.8 – A generic diagram of the Factory Method pattern. ](img/B18605_Figure_4.8.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 工厂方法模式的通用图](img/B18605_Figure_4.8.jpg)'
- en: Figure 3.8 – A generic diagram of the Factory Method pattern.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 工厂方法模式的通用图。
- en: 'Let’s review each part of the diagram based on the numbers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数字，让我们回顾一下图中的每一部分：
- en: The Factory Method pattern starts with an interface that defines a common behavior
    or set of behaviors. In general, using interfaces is more flexible than using
    a base class because you aren’t limited by the inheritance rules in C. This is
    to say that any child class in C# may have only one parent class. Multiple class
    inheritance is not supported. In the case of interfaces, any class may implement
    as many different interfaces as are needed.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂方法模式从定义公共行为或一组行为的接口开始。一般来说，使用接口比使用基类更灵活，因为在 C 中，你不受继承规则的限制。也就是说，在 C# 中，任何子类可能只有一个父类。不支持多重类继承。在接口的情况下，任何类都可以实现所需的不同接口。
- en: When we discuss the Factory Method pattern, we call the objects the factory
    creates `products`. These are the concrete products the factory will produce.
    They will all implement the common product interface. In practice, you don’t need
    to stick with the same names, as shown in the preceding diagram.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们讨论工厂方法模式时，我们称工厂创建的对象为 `products`。这些是工厂将要生产的具体产品。它们都将实现公共产品接口。在实践中，你不需要坚持使用与前面图示相同的名称。
- en: A factory method has a `Creator` class that houses the factory method itself.
    The Factory Method is coded to return the `Product` interface so that it can return
    any product that implements that interface. It isn’t tied to a particular abstract
    base class, as was the case with Kitty’s original refactor. These creators are
    abstract and are meant to be overridden in concrete creator subclasses. This is
    what provides the flexibility we need with our bicycle factory.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂方法有一个包含工厂方法的 `Creator` 类。工厂方法被编码为返回 `Product` 接口，以便它可以返回实现该接口的任何产品。它不依赖于特定的抽象基类，正如凯蒂最初的重构那样。这些创建者都是抽象的，并意味着在具体的创建者子类中被覆盖。这就是我们自行车工厂所需的灵活性所在。
- en: Concrete creators provide the actual concrete classes. All your creation logic
    will be here.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体创建者提供实际的 concrete 类。所有你的创建逻辑都将在这里。
- en: 'Let’s remember the specifics of Kitty and Phoebe’s plan. It calls for two factories
    – one in Dallas to make road and recumbent bicycles and another in Alpine to make
    mountain and cruiser bicycles. Kitty heads to her whiteboard and makes her version
    of the preceding diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住凯蒂和菲比的计划细节。这个计划需要两个工厂——一个在达拉斯制造公路自行车和休闲自行车，另一个在阿尔卑斯山制造山地自行车和巡航自行车。凯蒂走向她的白板，并绘制了她版本的先前图表：
- en: '![Figure 3.9 – Kitty’s whiteboard drawing of her Factory Method pattern design
    idea. ](img/B18605_Figure_4.9.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 凯蒂的工厂方法设计理念的白色板草图](img/B18605_Figure_4.9.jpg)'
- en: Figure 3.9 – Kitty’s whiteboard drawing of her Factory Method pattern design
    idea.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 凯蒂的工厂方法设计理念的白色板草图。
- en: This looks pretty good! Kitty decides to move a lot of what is in her abstract
    bicycle class into an interface she calls `IBicycle`. This doesn’t mean she should
    throw out the abstract class, but it’s easy to have the abstract class implement
    the interface. Once she does that, she can pass the interface around, which is
    more flexible than using the base class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当不错！凯蒂决定将她抽象自行车类中的大部分内容移动到一个她称为 `IBicycle` 的接口中。这并不意味着她应该丢弃抽象类，但抽象类实现接口很容易。一旦她这样做，她就可以传递接口，这比使用基类更灵活。
- en: The abstract bicycle base class won’t change, other than implementing the `IBicycle`
    interface. None of the bicycle subclasses change at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象自行车基类除了实现 `IBicycle` 接口外不会改变。所有的自行车子类都不会有任何变化。
- en: She does need to add some creator classes. She’ll need to create an abstract
    `BicycleCreator` class, which will be subclassed by as many concrete creation
    classes as she might need.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 她确实需要添加一些创建类。她将需要创建一个抽象的 `BicycleCreator` 类，这个类将被她可能需要的尽可能多的具体创建类所继承。
- en: This fits the design problem because we need to model two actual factories.
    One is called `DallasCreator`, which will make road bikes and recumbent bikes,
    and the other is called `AlpineCreator`, which will produce mountain bikes and
    cruisers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合设计问题，因为我们需要模拟两个实际的工厂。一个被称为 `DallasCreator`，将制造公路自行车和休闲自行车，另一个被称为 `AlpineCreator`，将生产山地自行车和巡航自行车。
- en: Our design is closed for modification. We never need to mess with the base classes
    and interface again. However, the design is also open for extension. As the line
    of products expands in the future, we can continue to add factories and each factory
    can specialize in any set of products. New bikes can be added by simply creating
    new subclasses of `Bicycle`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计对修改是封闭的。我们再也不需要与基类和接口打交道了。然而，设计对扩展也是开放的。随着产品线的未来扩展，我们可以继续添加工厂，每个工厂可以专门生产任何一组产品。只需创建
    `Bicycle` 的新子类即可添加新自行车。
- en: There’s nothing left but the typing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只有打字了。
- en: 'Kitty adds the `IBicycle` interface to her `class` library:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂将 `IBicycle` 接口添加到她的 `class` 库中：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, she modifies the `Bicycle` base class. Defining non-public members is
    not possible in an interface. C# generally requires properties and methods defined
    in an interface to be `public`. Non-public members in an interface don’t make
    sense. They would be housing implementation details, not something for public
    consumption, which is the point of an interface. The bottom line is that if we
    want to require anything on the `Bicycle` base class, we will need to change the
    access modifiers to `public`. We usually want to avoid changing classes once they
    are published in production. At this stage, we haven’t done that yet. We can either
    change the access modifiers or avoid defining those elements in the interface
    and just have the `build` function. Kitty decides on the more complete version
    of the interface she’s already typed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，她修改了 `Bicycle` 基类。在接口中定义非公共成员是不可能的。C# 通常要求接口中定义的属性和方法是 `public`。接口中的非公共成员没有意义。它们将容纳实现细节，而不是供公众消费的东西，这是接口的目的。底线是，如果我们想在
    `Bicycle` 基类上要求任何东西，我们需要将访问修饰符更改为 `public`。我们通常希望避免在生产中发布后更改类。在这个阶段，我们还没有这样做。我们可以更改访问修饰符，或者避免在接口中定义这些元素，只保留
    `build` 函数。凯蒂决定采用她已输入的更完整的接口版本：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need our creator classes. Kitty starts with the abstract class, which
    she’ll call `BicycleCreator`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要我们的创建类。凯蒂从抽象类开始，她将称之为 `BicycleCreator`：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next comes the two concrete creator classes, beginning with `DallasCreator`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个具体的创建类，从 `DallasCreator` 开始：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is followed by the `AlpineCreator` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是 `AlpineCreator` 类：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Kitty needs a quick test, so she adds this code to `Program.cs`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂需要一个快速测试，所以她将此代码添加到 `Program.cs` 中：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now is the moment of truth. Kitty hits the run button in the IDE and moves
    to the edge of her seat as her code compiles:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检验真伪的时刻。Kitty 在 IDE 中点击运行按钮，并坐到椅子的边缘，随着代码编译：
- en: '![Figure 3.10 – Booyah! It works! The Factory Method pattern is running in
    Kitty’s code! ](img/B18605_Figure_4.10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 哇！它工作了！工厂方法模式正在 Kitty 的代码中运行！](img/B18605_Figure_4.10.jpg)'
- en: Figure 3.10 – Booyah! It works! The Factory Method pattern is running in Kitty’s
    code!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 哇！它工作了！工厂方法模式正在 Kitty 的代码中运行！
- en: Kitty commits and pushes her code, which you can review in the `FactoryMethodExample`
    project within the source code for this chapter. Don’t forget that the `IBicycle`
    interface was added to the `BumbleBikesLibrary` project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 提交并推动了她的代码，你可以在本章源代码中的 `FactoryMethodExample` 项目中查看。别忘了 `IBicycle` 接口已被添加到
    `BumbleBikesLibrary` 项目中。
- en: The Abstract Factory pattern
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: After Kitty finishes her initial design using the factory method, Phoebe checks
    Kitty’s work on GitHub. Phoebe has managed to finish the tooling that creates
    the frames and she’s hard at work on some of the other parts that go into making
    a bicycle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kitty 使用工厂方法完成初步设计后，Phoebe 在 GitHub 上检查了 Kitty 的工作。Phoebe 已经完成了创建车架的工具，她正在努力完成其他一些制造自行车的部件。
- en: “*Kitty!,*” Phoebe says, “*This code will allow us to make a bicycle object
    but that’s a little bit too abstract. A bicycle is made of lots of different parts.*”
    After a long discussion, the two decided to concentrate on manufacturing the bicycle
    frame and the handlebars for each bicycle type. The other parts, such as the wheels,
    tires, brakes, and gears, can be outsourced for the initial production of the
    bicycles.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: “*Kitty！*，” Phoebe 说，“*这段代码将允许我们创建自行车对象，但这有点太抽象了。自行车由许多不同的部件组成。*” 经过长时间的讨论，两人决定专注于制造每种自行车类型的自行车框架和把手。其他部件，如轮子、轮胎、刹车和齿轮，可以在自行车初始生产中外包。
- en: It occurs to Phoebe that these parts can be made in families. The road bike
    uses dropped handlebars, while mountain bikes use a flat handlebar design. You
    shouldn’t interchange these parts. Flat handlebars on a road bike create a new
    class of bicycle called a *gravel bike* or *hybrid*. We’re not interested in changing
    our product line-up yet. Drop handlebars on a mountain bike make no sense at all
    and are dangerous. It makes sense for the physical bicycle factory to mirror the
    software pattern. The sisters conclude a better fit might be to use the **Abstract
    Factory pattern**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Phoebe 想到这些部件可以按系列制造。公路自行车使用下弯把手，而山地自行车使用平面把手设计。你不应该互换这些部件。公路自行车上的平面把手会创造一个新的自行车类别，称为
    *砾石自行车* 或 *混合型*。我们目前不感兴趣改变我们的产品线。山地自行车上的下弯把手完全没有意义，而且很危险。对于物理自行车工厂来说，模仿软件模式是有意义的。姐妹们得出结论，更好的选择可能是使用
    **抽象工厂模式**。
- en: This is a pattern a lot of people get wrong. It is a common misconception that
    the Abstract Factory pattern simply involves making your factory class abstract.
    Not so! The Abstract Factory pattern is designed to create objects that are related
    and to decouple those objects from the client’s dependency on a concrete type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很多人做错的模式。一个常见的误解是抽象工厂模式仅仅涉及使你的工厂类抽象化。不是这样！抽象工厂模式旨在创建相关对象，并将这些对象从客户端对具体类型的依赖中解耦。
- en: 'Our bicycle design consists of four families of bicycles:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计包括四种自行车系列：
- en: Road bicycles (the Hillcrest)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路自行车（希尔克里斯特）
- en: Mountain bicycles (The Palo Duro Canyon Ranger)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 山地自行车（帕洛杜罗峡谷管理员）
- en: Recumbent bicycles (The Big Bend)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休闲自行车（大弯）
- en: Cruiser bicycles (The Galveston Cruiser)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巡游自行车（加尔维斯顿巡游）
- en: Each type has a particular type of frame, as well as a different design for
    handlebars. We can say we will be making four *families* of bicycle components.
    When you encounter a problem that involves families of related objects, you should
    automatically think about the abstract factory pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都有特定的车架类型，以及不同的把手设计。我们可以说我们将制造四种 *系列* 的自行车组件。当你遇到涉及相关对象系列的问题时，你应该自动考虑抽象工厂模式。
- en: 'A second benefit of the abstract factory pattern is that it decouples the client’s
    dependency on any particular concrete object. Let’s look at the following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的第二个好处是它解耦了客户端对任何特定具体对象的依赖。让我们看看以下图表：
- en: '![Figure 3.12 – The Abstract Factory Pattern. ](img/B18605_Figure_4.11.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 抽象工厂模式。](img/B18605_Figure_4.11.jpg)'
- en: Figure 3.12 – The Abstract Factory Pattern.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 抽象工厂模式。
- en: 'I have drawn the parts going from right to left, beginning with the client:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我从右到左绘制了这些部分，从客户端开始：
- en: The client is whatever code consumes the objects created by the Abstract Factory.
    Here, I’m showing a private reference to an Abstract Factory as a property on
    the client object.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端是任何消耗由抽象工厂创建的对象的代码。在这里，我展示了一个客户端对象上的私有引用，指向一个抽象工厂作为属性。
- en: The client is dependent on the `AbstractFactory` interface. This interface defines
    two methods. Normally, I don’t put the return types in the UML, but in this case,
    it is truly important. The interface is going to refer to a pair of abstract classes.
    Maybe now you’re starting to see where this is going. The final product created
    by the Abstract Factory will be a concrete class that inherits from one of these
    abstract classes.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端依赖于 `AbstractFactory` 接口。此接口定义了两个方法。通常，我不在 UML 中放置返回类型，但在这个情况下，这确实非常重要。接口将引用一对抽象类。也许你现在开始看到这要去哪里了。由抽象工厂创建的最终产品将是一个继承自这些抽象类之一的具体类。
- en: Two concrete factories are presented for each family of products. Our requirements
    have four families of products, but this diagram only shows two to keep things
    simple. You can add as many concrete factories as you need.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每种产品系列，都展示了两个具体的工厂。我们的需求有四个产品系列，但这个图仅展示了两个以保持简单。你可以根据需要添加任意多的具体工厂。
- en: Two abstract classes are used to define two types of objects, independent of
    the family for the concrete object.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个抽象类来定义两种类型的对象，这些对象独立于具体对象的家庭。
- en: The final concrete products inherit from the abstract products. Phoebe and Kitty
    can model more specifics into their process because they are not just making bicycles
    – they are making the handlebars too. Each physical factory should make the frames
    and handlebars that are needed.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的具体产品继承自抽象产品。菲比和凯蒂可以在他们的过程中添加更多具体细节，因为他们不仅仅在制作自行车——他们还在制作把手。每个物理工厂都应该制作所需的框架和把手。
- en: 'The sisters head to the whiteboard and draw out the Abstract Factory pattern
    design. They will limit their diagramming to road bikes and mountain bikes to
    keep things simple:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 姐妹俩走向白板，并绘制出抽象工厂模式的设计。为了保持简单，她们将只绘制公路自行车和山地自行车：
- en: '![Figure 3.13  – Phoebe and Kitty’s whiteboard design using the Abstract Factory
    pattern. ](img/B18605_Figure_4.12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 菲比和凯蒂使用抽象工厂模式的白板设计。(img/B18605_Figure_4.12.jpg)]'
- en: Figure 3.13 – Phoebe and Kitty’s whiteboard design using the Abstract Factory
    pattern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 菲比和凯蒂使用抽象工厂模式的白板设计。
- en: The client in this program is just the `Program.cs` file created by your IDE
    when you created a command-line project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，客户端只是当你创建一个命令行项目时，你的 IDE 创建的 `Program.cs` 文件。
- en: The diagram says `Program.cs` and depends on an object created from `IBicycleFactory`.
    Note that the arrowheads are different. These are significant in UML. The closed
    arrowhead on a solid line indicates inheritance. A closed arrowhead on a dashed
    line indicates a realization of an interface. The open arrowhead on a closed line
    indicates an association. The client depends on something that follows `IBicycleFactory`.
    The `Program.cs` class has a private field to hold an instance of an object that
    realizes this interface, which can be either `RoadBicycleFactory` or `MountainBicycleFactory`,
    as per the preceding diagram.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示 `Program.cs` 并依赖于由 `IBicycleFactory` 创建的对象。注意箭头的不同。这些在 UML 中很重要。实线上的封闭箭头表示继承。虚线上的封闭箭头表示接口的实现。封闭线上的开放箭头表示关联。客户端依赖于
    `IBicycleFactory` 后面的某个东西。`Program.cs` 类有一个私有字段来保存实现此接口的对象的实例，这可以是 `RoadBicycleFactory`
    或 `MountainBicycleFactory`，如前图所示。
- en: It is worth noting here that Phoebe drew `IBicyleFactory` as a literal interface.
    The code-level understanding of an interface may be either a literal interface
    or an abstract class because either can serve to define the structure an object
    must take.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意，菲比将 `IBicycleFactory` 绘制为一个字面接口。对接口的代码级理解可能是一个字面接口或一个抽象类，因为它们都可以用来定义对象必须采取的结构。
- en: We have concrete classes that realize the `IBicycleFactory` interface called
    `RoadBicycleFactory` and `MountainBicycleFactory`, respectively. Each concrete
    factory is responsible for creating a family of objects. In our case, the families
    are `Road` and `Mountain`. `RoadBicycleFactory` can create `RoadBicycleFrame`
    and `RoadBicycleHandlebars` based on the dependency line, but you can see that
    `RoadBicycleFrame` and `RoadBicycleHandlebars` inherit from the `BicycleFrame`
    and `BicycleHandlebars` abstract classes respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有实现`IBicycleFactory`接口的具体系列类，分别称为`RoadBicycleFactory`和`MountainBicycleFactory`。每个具体工厂负责创建一个对象家族。在我们的例子中，家族是`Road`和`Mountain`。`RoadBicycleFactory`可以根据依赖关系创建`RoadBicycleFrame`和`RoadBicycleHandlebars`，但你可以看到`RoadBicycleFrame`和`RoadBicycleHandlebars`分别继承自`BicycleFrame`和`BicycleHandlebars`抽象类。
- en: When the client requests a bicycle frame and a set of handlebars, it can reference
    the abstract classes. Owing to Liskov substitution, the client doesn’t need to
    be strictly coupled to any concrete class. This makes our client very flexible.
    As our bicycle family line-up changes, we won’t need to alter the client because
    the client does not know what the factory is sending back. The client only knows
    it has methods called `CreateBicycleFrame` and `CreateBicycleHandlebars`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求自行车车架和一组把手时，它可以引用抽象类。由于Liskov替换原则，客户端不需要严格耦合到任何具体类。这使得我们的客户端非常灵活。随着我们的自行车家族阵容的变化，我们不需要修改客户端，因为客户端不知道工厂返回的是什么。客户端只知道它有名为`CreateBicycleFrame`和`CreateBicycleHandlebars`的方法。
- en: Phoebe makes a branch on the repository. She knows you should always work in
    a branch and goes to work creating the code. She begins with the `IBicycleFactory`
    interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Phoebe在仓库中创建了一个分支。她知道你应该始终在分支上工作，于是开始编写代码。她从`IBicycleFactory`接口开始。
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the first two `using` statements. Since we are starting to break the bicycle
    into components, Kitty and Phoebe decided to refactor those components into a
    `BicycleComponents` namespace within `BumbleBikesLibrary`. The refactor isn’t
    particularly relevant to patterns – it’s just a refactor to get a little bit more
    organized. You can find the components in BumbleBikesLibrary in the GitHub repository
    for this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前两个`using`语句。由于我们开始将自行车分解成组件，Kitty和Phoebe决定将这些组件重构到`BumbleBikesLibrary`中的`BicycleComponents`命名空间内。这次重构与模式无关，只是为了让代码更加有序。你可以在GitHub仓库中找到本章的BumbleBikesLibrary中的组件。
- en: The sisters are coding by the book. Everything is typed into an interface for
    flexibility. We’re adding methods to handle creating frames and handlebars, two
    related classes specified by the interfaces. Naturally, we could make more. There
    are more component classes in the `BicycleComponents` namespace. We’re keeping
    it to two here to keep things simple. If you’d like to practice, see whether you
    can add the other components, such as seats, drivetrain, and brakes, to the pattern
    code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 姐妹俩按照书中的方法进行编码。所有内容都输入到接口中以保持灵活性。我们正在添加处理创建车架和把手的方法，这两个由接口指定的相关类。自然，我们可以添加更多。`BicycleComponents`命名空间中还有更多组件类。我们在这里只保留两个以保持简单。如果你想练习，看看你是否可以将其他组件，如座椅、传动系统和刹车，添加到模式代码中。
- en: 'Next, Kitty and Phoebe need to work in the concrete factories. These classes
    will only be used in this project, so you’ll find them in the `BicycleAbstractFactoryExample`
    project in the book’s sample source on GitHub. Remember, an *abstraction* can
    refer to an interface or an *abstract* class. In this case, the abstract part
    of the *abstract factory* is this interface. Kitty takes on writing `MountainBicycleFactory`
    based on the `IBicycleFactory` interface:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Kitty和Phoebe需要在具体的工厂中工作。这些类只在这个项目中使用，所以你可以在GitHub上书籍示例源代码的`BicycleAbstractFactoryExample`项目中找到它们。记住，*抽象*可以指接口或*抽象类*。在这种情况下，*抽象工厂*的抽象部分就是这个接口。Kitty根据`IBicycleFactory`接口编写了`MountainBicycleFactory`：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The concrete factory is responsible for creating the specific objects we need
    relative to the object family we’re creating. In this case, Kitty is making the
    parts for a mountain bike, so all the parts being returned are specific to that
    family. More product families can be added without modifying the abstract factory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 具体工厂负责创建相对于我们创建的对象家族所需的具体对象。在这种情况下，Kitty正在制作山地自行车的部件，所以所有返回的部件都是针对该家族的。可以添加更多的产品家族，而不需要修改抽象工厂。
- en: 'Here is what Phoebe wrote for the `RoadBicycleFactory` class, which also extends
    `IBicycleFactory`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Phoebe为`RoadBicycleFactory`类编写的代码，它也扩展了`IBicycleFactory`接口：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now have an Abstract Factory pattern in place making two possible components,
    in two possible product families. Let’s look at the client. Phoebe writes that
    part:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了抽象工厂模式，制造出两种可能的产品组件，属于两种可能的产品系列。让我们看看客户。菲比写道：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We made a road bike using `RoadBikeFactory`! The key here is the use of the
    interface as the factory type. Coding this way makes it possible to change the
    factory without relying on concrete factory classes directly. You can see the
    console output showing the results of the operation. Phoebe continues and writes
    some code to generate a mountain bike using `MountainBikeFactory`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`RoadBikeFactory`制造了一辆公路自行车！这里的关键是使用接口作为工厂类型。这样编码可以使更改工厂而不直接依赖于具体的工厂类成为可能。你可以看到控制台输出显示了操作的结果。菲比继续编写代码，使用`MountainBikeFactory`生成一辆山地自行车：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The same process could be repeated for any new bicycle type that Phoebe and
    Kitty could ever dream of making.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于菲比和凯蒂可能梦想制造的任何新型自行车，都可以重复同样的过程。
- en: The Builder pattern
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者模式
- en: Phoebe finishes her implementation of the Abstract Factory and goes back to
    designing more on the robotics for the bicycle factory. How many times have you
    thought some job or project was simple, only to find out that once you got into
    the thick of working on it, things involved more than you realized?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比完成了抽象工厂的实现，然后回到设计自行车工厂的机器人部分。你有多少次认为某个工作或项目很简单，结果发现一旦你开始着手做，事情比你所意识到的要复杂得多？
- en: Phoebe and Kitty are new to engineering, design, and software development. Phoebe’s
    unique understanding of the design problems surrounding building an automated
    factory solidifies over time. She realizes that building a bicycle is more complicated
    than she had first realized. The sisters built their prototypes by hand. They
    were able to use wood for the frames and off-the-shelf parts for everything else.
    They are now committed to making their own frames and handlebars using a lightweight
    aluminum alloy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比和凯蒂对工程、设计和软件开发都是新手。菲比对围绕建造自动化工厂的设计问题的独特理解随着时间的推移而巩固。她意识到制造自行车比她最初想象的要复杂。姐妹俩手工制作了原型。他们能够使用木材制作车架，并使用现成的部件制作其他部分。他们现在致力于使用轻质铝合金自行制作车架和把手。
- en: Phoebe realizes the frame is the hard part. The other components, such as the
    wheels, brakes, and drivetrain, as well as the handlebars, could easily be built
    in-house as part of the automated process.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比意识到车架是难点。其他组件，如车轮、刹车、传动系统以及把手，可以很容易地作为自动化过程的一部分内部制造。
- en: Naturally, this increases the complexity of the machinery and the software that
    runs it. Phoebe calls Kitty.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这增加了机器及其软件的复杂性。菲比给凯蒂打电话。
- en: “*Hey sis, how is the Abstract Factory pattern treating you?*” Kitty asks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: “*嘿，妹妹，抽象工厂模式对你怎么样？*”凯蒂问。
- en: “*It’s fine, but I’ve been thinking,*” Phoebe replies.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: “*这没问题，但我一直在想，*”菲比回答说。
- en: “*Uh oh. Every time you do that Daddy’s credit card gets a workout. What is
    your idea?*” Kitty asks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: “*哎呀。每次你这么做，爸爸的信用卡就会受到考验。你有什么想法？*”凯蒂问。
- en: Phoebe told Kitty about her idea to make all the parts from the same aluminum
    alloy. “*Some of the parts will need to be reinforced, but the result will be
    a lighter bicycle that costs less to build than we initially thought,*” said Phoebe.
    Kitty loved the idea. The sisters were excited before, but now they are fired
    up. Phoebe says, “*I’ll get Dad’s credit card and source the aluminum I need for
    the first few bicycles.*” Kitty replies “*Great. While you’re doing that, I’ll
    incorporate your ideas into the control software. You merged your branch into
    main, right?*”
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比向凯蒂讲述了她用同一种铝合金制造所有部件的想法。“*有些部件需要加固，但结果将是一辆比我们最初想象的更轻、更便宜的自行车，*”菲比说。凯蒂喜欢这个主意。姐妹俩之前很兴奋，但现在更加激动。菲比说：“*我会用爸爸的信用卡购买制造前几辆自行车所需的铝合金。*”凯蒂回答说：“*太好了。当你这么做的时候，我会把你的想法融入到控制软件中。你把分支合并到主分支上了，对吧？*”
- en: Kitty pulls the latest code from *GitHub* and starts a new branch. She starts
    thinking hard about how to accomplish coding a process that will build an entire
    bicycle per any possible specification a customer might have. The sisters have
    a set of four bicycles with constrained options for the first release. Kitty doesn’t
    want to lock her thinking and her software design into building just those four
    bicycles. That would make it a stovepipe system. Kitty heads to the whiteboard.
    She realizes that she might have to disregard the progress she’s made so far in
    the Abstract Factory pattern. A different pattern might not simply be a direct
    evolution of what they’ve done so far. She knows the elemental structures will
    remain the same. A bicycle will always need a frame, seat, handlebars, wheels,
    brakes, and a drivetrain.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂从 *GitHub* 拉取了最新的代码并开始了一个新的分支。她开始认真思考如何完成编写一个过程，这个过程可以根据客户可能有的任何规格来构建一辆完整的自行车。姐妹们有一套四辆自行车，第一版有有限的选项。凯蒂不想把自己的思考和软件设计锁定在只构建那四辆自行车上。那会使其成为一个烟囱系统。凯蒂走向白板。她意识到她可能不得不放弃到目前为止在抽象工厂模式中取得的进展。不同的模式可能不仅仅是他们迄今为止所做工作的直接演变。她知道基本结构将保持不变。自行车总是需要车架、座椅、把手、轮子、刹车和传动系统。
- en: The new problem entails creating a complex object. The construction will require
    multiple steps instead of a simple `BuildBicycle` method that creates the frame
    and handlebars, as she had in the earlier designs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 新问题涉及到创建一个复杂对象。构建将需要多个步骤，而不是像早期设计中那样简单的 `BuildBicycle` 方法，该方法创建车架和把手。
- en: 'Deep in thought, her reverie is broken by a loud buzzing from her phone. It’s
    sitting on her metal worktable and the vibration, indicating she’s received a
    text, nearly bounced a small pile of screws and some tools right off the edge
    of the table:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 沉思中，她的幻想被手机响亮的嗡嗡声打断。手机放在她的金属工作台上，震动表明她收到了一条短信，几乎把一小堆螺丝和一些工具从桌边弹了出去：
- en: '![Figure 3.15 – She checks the screen. There’s a text from her father. ](img/B18605_Figure_4.15_NEW.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 她检查屏幕。有一条来自她父亲的信息](img/B18605_Figure_4.15_NEW.jpg)'
- en: Figure 3.15 – She checks the screen. There’s a text from her father.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 她检查屏幕。有一条来自她父亲的信息。
- en: Uh - oh. Kitty decides to rip off the proverbial band-aid and calls her father.
    Maybe her excitement over the latest developments will cushion the blow. “*Daddy
    will understand,*” she says quietly to herself as if she is quietly trying to
    convince herself out loud.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。凯蒂决定撕下那个众所周知的创可贴，给她的父亲打电话。也许她对最新进展的兴奋可以减轻打击。“*爸爸会理解的*，”她低声对自己说，好像她正在大声试图说服自己。
- en: Kitty and Phoebe’s father was a software engineer. He’d lost his job a few years
    ago because he was always talking about crazy conspiracy theories on social media.
    He decided to just retire, and after a falling out with his extended family, Kitty
    and Phoebe’s parents moved to a small town in Southern Oklahoma, just north of
    the Texas border where the roads are unpaved and the internet access is non-existent.
    This is just the way he likes it. Kitty dials the number.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂和菲比的父亲是一位软件工程师。他几年前因为总是在社交媒体上谈论疯狂的阴谋论而失去了工作。他决定退休，在与他的大家庭发生争执后，凯蒂和菲比的父母搬到了美国南部俄克拉荷马州的一个小镇，这个小镇位于德克萨斯州边境以北，那里的道路没有铺路，互联网接入也不存在。这正是他喜欢的方式。凯蒂拨打了电话。
- en: When he answered, her father’s language was, shall we say, colorful. This wasn’t
    the first time Phoebe had run up a bill. She had once charged over a thousand
    dollars in 1 day. Most teenage girls run up a bill traveling or shopping. Phoebe’s
    bill was from several reputable industrial suppliers, a tool and die shop, and
    a peanut butter factory. She never came clean on what she was up to, but shortly
    after that, she got into engineering school and the incident was all but forgotten.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当他接电话时，他父亲的语言，我们可以说是丰富多彩的。这不是菲比第一次欠下账单。她曾经一天之内就欠下了超过一千美元。大多数少女都是因为旅行或购物而欠下账单。菲比的账单来自几家知名的工业供应商，一个模具车间和一个花生酱工厂。她从未坦白她在做什么，但不久之后，她进入了工程学院，那件事几乎被遗忘。
- en: Kitty talks him down from his anger and tells him about what’s going on. “*You
    should look at* **the Builder pattern***,*” he says. “*Yeah, I once wrote a book
    on patterns and I remember this one. It is used to make complex objects using
    a flexible set of steps. It sounds like that’s what you need. Oh, and y’all are
    gonna pay me back! I want stock in your company and the first bicycle you two
    build.*”
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 契蒂安抚了他的怒气，并告诉他正在发生的事情。“*你应该看看* **建造者模式**，”他说。“*是的，我曾经写过一本关于模式的书籍，我记得这个。它用于使用一系列灵活的步骤来创建复杂对象。听起来这好像是你需要的。哦，还有，你们得还我人情！我想在公司里得到股份，还有你们两个建造的第一辆自行车。””
- en: “*Of course, Daddy,*” Kitty said in her sweetest voice, normally reserved for
    when she wanted ice cream but had already been told, “*No.*” She decided not to
    admonish him for not telling her he had written a book on patterns. Her father
    had taught the sisters to code when Phoebe was 11 and Kitty was 12\. He had published
    a lot of books and videos over the years. Of course, he had done one on patterns.
    At that moment, Kitty’s call went to static. It was hard to hear anything. Her
    father was still speaking to her, but she only caught a few words. Something about
    alternate timelines and temporal recursion. “*He says the silliest things sometimes.
    He’s probably been watching old episodes of Doctor Who again,*” she thought. The
    call dropped.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: “*当然，爸爸，*”契蒂用她最甜美的声音说，这通常是当她想要冰淇淋但已经被告诉“*不*”时才会使用的。她决定不责备他没有告诉她他写过一本关于模式的书籍。当菲比11岁、契蒂12岁时，她的父亲就教她们编程。他多年来出版了许多书籍和视频。当然，他也写过一本关于模式的。在那个时刻，契蒂的电话变得静默。很难听到任何声音。她的父亲还在和她说话，但她只听到了几个词。关于平行时空和时间递归的事情。“*他有时会说些很傻的话。他可能又重新看了《神秘博士》的老剧集，*”她心想。电话挂断了。
- en: 'Kitty shrugged and set to researching the Builder pattern. Her father’s book
    had been out of print for years, but it was a runaway international bestseller,
    so she was able to find a few of the diagrams among the many more recent books
    that cited his:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 契蒂耸了耸肩，开始研究建造者模式。她父亲的书籍已经绝版多年，但它却是一本国际畅销书，因此她能够在引用他的许多更近期的书籍中找到一些图表：
- en: '![Figure 3.16 – The builder pattern consists of a builder interface, a director
    to control the creation process, and concrete builders based on the builder interface
    to produce specific products. ](img/B18605_Figure_4.13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – 建造者模式由一个建造者接口、一个控制创建过程的导演和一个基于建造者接口的具体建造者来产生特定产品组成](img/B18605_Figure_4.13.jpg)'
- en: Figure 3.16 – The builder pattern consists of a builder interface, a director
    to control the creation process, and concrete builders based on the builder interface
    to produce specific products.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 建造者模式由一个建造者接口、一个控制创建过程的导演和一个基于建造者接口的具体建造者来产生特定产品组成
- en: 'Let’s look at this diagram in more detail:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个图表：
- en: There are two important parts to the Builder pattern. The first is the IB. Remember,
    this can be a literal interface or an abstract class. I’ll stick to using a true
    interface for the sake of flexibility. The `Builder` interface defines all the
    methods that will be in a set of concrete builder classes. The second part that
    you’ll always find in the Builder pattern is the `Director` class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式有两个重要的部分。第一个是IB。记住，这可以是一个字面接口或一个抽象类。我将坚持使用真正的接口以保持灵活性。`Builder`接口定义了将在一组具体建造类中出现的所有方法。建造者模式中你总会找到的第二个部分是`Director`类。
- en: A `Director class` is created, which contains logic that defines the creation
    process in a step-by-step fashion.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`Director类`，其中包含以逐步方式定义创建过程的逻辑。
- en: A set of concrete builder classes defines each type of object that can be created.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组具体建造类定义了可以创建的每种对象类型。
- en: Different products come out of the concrete builder classes, depending on the
    logic contained within the director.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据导演中包含的逻辑，不同的产品会从具体建造类中产生。
- en: 'Armed with this new knowledge, Kitty goes back to her whiteboard:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 契蒂带着这些新知识回到她的白板上：
- en: '![Figure 3.17 – Kitty’s whiteboard implementation of the builder pattern. ](img/B18605_Figure_4.14.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – 契蒂在白板上实现的建造者模式](img/B18605_Figure_4.14.jpg)'
- en: Figure 3.17 – Kitty’s whiteboard implementation of the builder pattern.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 契蒂在白板上实现的建造者模式。
- en: Kitty was excited about this one. Having gone through a few different patterns,
    this one felt like it was the best representation of what the sisters are trying
    to accomplish. You can find this code in the `BicycleBuilderExample` project within
    this chapter’s GitHub repository.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂对这一款很兴奋。经过尝试了几种不同的模式后，她觉得这一款最能代表姐妹们想要达成的目标。你可以在本章GitHub仓库中的`BicycleBuilderExample`项目中找到这段代码。
- en: 'Kitty starts by creating an abstraction for what the builders will be producing
    – that is, the product. She creates an interface called `IBicycleProduct`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂首先为建造者将要生产的内容创建了一个抽象——即产品。她创建了一个名为`IBicycleProduct`的接口：
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The interface contains everything needed to make a complete bicycle. We have
    something of a design luxury at play here. All the bicycles follow the same interface.
    We no longer need to think about a road bike or a mountain bike. A road bike is
    simply a collection of parts:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含了制作完整自行车所需的一切。在这里，我们有一些设计上的奢侈。所有自行车都遵循相同的接口。我们不再需要考虑公路车或山地车。公路车只是一个部件的集合：
- en: A road bike frame
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路车车架
- en: A hardtail suspension (that is, no suspension at all)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬尾悬挂（即完全没有悬挂）
- en: Road bike handlebars (that is, dropped curved handlebars)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路车把手（即下弯的曲线把手）
- en: A road bike drive train (that is, a normal length chain and a group set with
    3 front and 8 rear cogs for a total of 24 speeds)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公路车传动系统（即正常长度的链条和一套3个前齿轮和8个后齿轮，总共24速）
- en: Caliper brakes
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刹车卡钳
- en: A standard, cheap, very uncomfortable seat
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的、便宜的、非常不舒服的座椅
- en: Phoebe and Kitty learned about seats during their internship. Bicycle manufacturers
    know that seats are a very personal choice and no two riders will pick the same
    seat if they are given a choice. They all sell bicycles with cheap, uncomfortable
    seats and offer separate products to upgrade the seat to the rider’s preference.
    This lowers the build cost for the bicycle and gives their dealers something to
    upcharge, as well as offering seat installation as a service.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比和基蒂在实习期间学习了有关座椅的知识。自行车制造商知道座椅是一个非常个人化的选择，如果给骑手选择，没有人会挑选相同的座椅。他们都会销售配备便宜、不舒服座椅的自行车，并提供单独的产品来升级座椅以满足骑手的偏好。这降低了自行车的制造成本，并让他们的经销商有机会加价，同时提供座椅安装服务。
- en: 'Kitty codes a generic bicycle object for the builder called `BicycleProduct`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂为建造者编写了一个通用的自行车对象，称为`BicycleProduct`：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class is just an implementation of the interface, plus a large `ToString()`override
    that we’re using as the meat of our sample code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是接口的一个实现，加上一个大的`ToString()`重写，我们将其用作示例代码的主体。
- en: 'Next, Kitty creates the `IBicycleBuilder` interface, which will define the
    various builders for the bicycle lines:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，基蒂创建了`IBicycleBuilder`接口，它将定义自行车型号的各个建造者：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The interface defines what must be in a `builder` class. The next piece of
    the puzzle is the `Director` class. The classical implementation of the `Builder`
    pattern will always have one of these. In our case, we could skip this part because
    all of our bicycles fit the same interface. A director can create anything, given
    a builder. The director’s job is to call the methods in the builder according
    to any business logic required and to return the product created by the builder.
    In our case, every product has the same set of properties, and the builders all
    have the same methods. Just realize that if your builders don’t all follow the
    same interface, it’s okay to have a lot more logic in your director to figure
    out what to do with it. The point of the director is to run the build methods
    in the builder in the right order. Sometimes, that entails a lot more logic than
    what we have here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了`builder`类中必须包含的内容。拼图中的下一部分是`Director`类。`Builder`模式的经典实现总会有这样一个类。在我们的例子中，我们可以跳过这一部分，因为我们的所有自行车都符合相同的接口。导演可以创建任何东西，只要有一个建造者。导演的职责是根据所需的业务逻辑调用建造者的方法，并返回由建造者创建的产品。在我们的例子中，每个产品都有相同的属性集，建造者都有相同的方法。只需意识到，如果你的建造者没有遵循相同的接口，导演中可以有更多的逻辑来决定如何处理它们。导演的目的是以正确的顺序运行建造者的构建方法。有时，这需要比我们这里更多的逻辑：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Kitty starts with a private field to hold a reference to the builder she’ll
    be working with. You can pass in anything that extends the `IBicycleBuilder` interface.
    The constructor sets the actual builder object that is passed in. Next, she makes
    a method that allows us to change the builder without exposing it directly:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 从一个私有字段开始，用来存储她将要与之工作的构建器引用。你可以传递任何扩展 `IBicycleBuilder` 接口的对象。构造函数设置了实际传递的构建器对象。接下来，她创建了一个允许我们更改构建器而不直接暴露它的方法：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Lastly, she creates a `Make` method per her UML diagram. It’s the `Make` method’s
    job to run the build steps in the right order. Kitty has this method follow the
    same process the robots will use. They’d start with a frame and then add parts
    to it. Nobody would think to start building a bicycle around the seat or the gears.
    Here, we can see a logical build process for a bicycle that starts with the bigger
    and more important parts, followed by smaller parts that attach to the larger
    ones:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，她根据她的 UML 图创建了一个 `Make` 方法。`Make` 方法的任务是按正确的顺序运行构建步骤。Kitty 让这个方法遵循机器人将使用的相同流程。他们将从车架开始，然后添加部件。没有人会想到从座椅或齿轮开始构建自行车。在这里，我们可以看到自行车的一个逻辑构建过程，它从更大、更重要的部件开始，然后是附加到较大部件上的较小部件：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, Kitty creates the concrete builders for mountain and road bikes. Naturally,
    she created the code for the other bicycle types, but here, we’ll keep things
    short so that you don’t have to sort through so much code to see the pattern.
    Here’s the `RoadBikeBuilder` class based on the `IBicycleBuilder` class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Kitty 为山地自行车和公路自行车创建了具体的构建器。自然地，她也创建了其他自行车类型的代码，但在这里，我们将保持简短，这样你就不必在大量的代码中寻找模式。以下是基于
    `IBicycleBuilder` 类的 `RoadBikeBuilder` 类：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Kitty creates a private field called `_bicycle` to hold the product to be built
    by the `Director` class. We have a public constructor and a `Reset()` method that
    sets the `_bicycle` field to a new bicycle based on the `BicycleProduct` class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 创建了一个名为 `_bicycle` 的私有字段来存储由 `Director` 类构建的产品。我们有一个公共构造函数和一个 `Reset()`
    方法，该方法将 `_bicycle` 字段设置为基于 `BicycleProduct` 类的新自行车：
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The same builders can be made for mountain, recumbent, and cruiser bikes. They
    look the same, but naturally, they use different parts as appropriate. The builder
    steps (methods) understand the parts needed to build, while the director understands
    the order needed for the steps (methods) to be called.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的构建器可以用于山地车、躺式自行车和休闲自行车。它们看起来一样，但自然地，它们使用适当的部件。构建器步骤（方法）了解构建所需的部件，而导演了解调用步骤（方法）所需的顺序。
- en: 'The client code that’s used to call these builders would look like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调用这些构建器的客户端代码看起来像这样：
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s where all the hard work pays off. You can build any bicycle with three
    lines of code. First, make the builder. Then, make a director, if you don’t have
    one yet, and pass in the builder you just created. Then, call the `Make()` method.
    The result is a perfectly built product:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有辛勤工作的回报。你可以用三行代码构建任何自行车。首先，创建构建器。然后，如果你还没有，创建一个导演，并将你刚刚创建的构建器传递给它。然后，调用
    `Make()` 方法。结果是完美构建的产品：
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Would you rather have a mountain bike? That’s easy!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你更愿意拥有一辆山地自行车吗？这很简单！
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can make recumbents and cruisers just as easily, but in the interest of saving
    trees, I’ll leave that to your imagination. If you’re like me and have a weak
    imagination, the sample code for this chapter contains the builder for creating
    all four types.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同样容易地制作躺式自行车和休闲自行车，但为了节约树木，我将留给你的想象力。如果你像我一样想象力较弱，本章的示例代码包含了创建所有四种类型的构建器。
- en: Kitty is delighted with the way things turned out. She has a software architecture
    that is closed for modification but open for extension. She has leveraged interfaces
    and abstract classes wisely, so Kitty is ready for the next challenge the world
    of robotic bicycle manufacturing might have for her.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 对事情的结果感到非常高兴。她有一个对修改封闭但对扩展开放的软件架构。她明智地利用了接口和抽象类，因此 Kitty 准备迎接世界机器人自行车制造领域可能对她提出的下一个挑战。
- en: The Object Pool pattern
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池模式
- en: 'Back at the factory, Phoebe has made progress on the robotics. She has developed
    a mobile robotic arm to handle the welding during the manufacturing process. She
    was hoping to build 30 of these arms to allow for maximum factory output, but
    her father’s credit card mysteriously stopped working. This puzzled Phoebe. Could
    her sister have told on her, leading her father to block the card from further
    purchases? “*She wouldn’t do that!*” Phoebe thought, but as soon as she said it,
    she knew that’s exactly what had happened. She considered calling her sister out
    on it but decided to focus on her father’s words:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 回到工厂，菲比在机器人技术方面取得了进展。她开发了一种移动式机器人臂，用于在制造过程中处理焊接工作。她原本希望制造30个这样的臂，以实现最大化的工厂产量，但她的父亲的信用卡神秘地停止工作了。这让菲比感到困惑。难道她的姐姐告发了她，导致父亲阻止了卡片的进一步购买？“*她不会那么做的!*”菲比想，但当她这么说的时候，她立刻意识到这正是发生的事情。她考虑过指责她的姐姐，但最终决定专注于她父亲的话：
- en: “*A good engineer is someone who makes the best product possible given constraints
    of time, materials, people, and budget with a minimum of complaining.*”
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: “*一个优秀的工程师是在时间、材料、人力和预算的限制下，尽可能少抱怨地制造出最佳产品的那个人。*”
- en: 'The last part is the hardest. Most engineers complain, “*If I’d gotten the
    budget, I’d asked for…*” or “*If only I had another year…*” It’s an ego thing.
    Phoebe swallows hers and decides she must figure out how to make do with just
    the 10 robot arms she was able to build. Her arm design looks a little like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这部分是最难的。大多数工程师会抱怨，“*如果我有预算，我会要求……*”或者“*如果我有另一年的时间……*”这是一件关于自尊的事情。菲比吞下了她的抱怨，决定她必须想出如何仅用她能建造的10个机器人臂来解决问题。她的臂设计看起来有点像这样：
- en: '![Figure 3.18 – Phoebe’s design for a robotic arm to handle the welding on
    the bicycle frames. ](img/B18605_Figure_4.15.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 菲比为处理自行车车架焊接的机器人臂设计](img/B18605_Figure_4.15.jpg)'
- en: Figure 3.18 – Phoebe’s design for a robotic arm to handle the welding on the
    bicycle frames.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 菲比为处理自行车车架焊接的机器人臂设计。
- en: Given that the arms are mobile, Phoebe decides it is possible to have the arms
    move between welding projects as needed. As the bicycles come through the line,
    only a few will need welding at any given point in time. Phoebe thought, “*Running
    with 30 arms would have been nice, but honestly, they’d be dormant most of the
    time. This will be better. I’m forced to be more efficient.*”
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于臂是移动的，菲比决定可以在需要时让臂在焊接项目之间移动。当自行车通过生产线时，只有少数几辆在任何时候都需要焊接。菲比想，“*拥有30个臂会很不错，但说实话，它们大部分时间都会处于闲置状态。这样会更好。我被迫更加高效。*”
- en: The pool of 10 arms sit on a track where they move to any of the assembly lines
    at a moment’s notice. As a weld is needed, Kitty’s software will move the arm
    to where it’s required. After the weld is finished, the arm can return to the
    pool and wait until it’s needed again. If several welders are needed on different
    projects, one arm will come out of the pool and do its work, then return. So long
    as we don’t need more than 10 arms at a time, we’re fine. If we do, the eleventh
    job will have to wait until one of the arms is available. Phoebe is happy with
    this because creating the arms is expensive, and as she’s discovered, she only
    needs a few. She can add more arms to the pool as the business expands.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 10个臂的池子位于轨道上，它们可以随时移动到任何装配线。当需要焊接时，基蒂的软件会将臂移动到所需的位置。焊接完成后，臂可以返回池中等待下一次需要。如果需要在不同项目上使用多个焊接工，一个臂会从池中取出并完成工作，然后返回。只要我们一次不需要超过10个臂，我们就没问题。如果我们需要，第11个任务将不得不等待直到有一个臂可用。菲比对此感到高兴，因为创建臂的成本很高，而且她已经发现，她只需要几个。随着业务的扩张，她可以添加更多的臂到池中。
- en: Phoebe has unwittingly stumbled onto the **O****bject Pool pattern**. This pattern
    is used to create computationally expensive objects, and as such, they tend to
    slow software performance to a crawl. The most obvious case is working with relational
    databases. This is something every software developer does at some point, and
    for many of us, this is a skill we rely on daily.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比无意中发现了**对象池模式**。这种模式用于创建计算成本高昂的对象，因此它们往往会将软件性能降低到极慢。最明显的例子是与关系数据库一起工作。这是每个软件开发者在某个时候都会做的事情，对我们中的许多人来说，这是一项我们每天都要依赖的技能。
- en: 'Instantiating and connecting to a database is computationally costly and time-consuming.
    Sure, it takes maybe 100 milliseconds, but most relational databases are designed
    to handle millions of transactions every hour. When your software is under load
    at scale, 100 milliseconds is an eternity. Every commercially viable database
    has a driver that handles connection pooling for you. The driver creates a pool
    of open database connections. Just like with the robot arms, your software takes
    connections from the pool, runs queries, and then when the connection is closed
    (which should always be done as quickly as is feasible) the open connection, instead
    of being truly closed, is returned to the pool and is available for another process
    in your running program. Check out the following generic diagram:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化和连接到数据库在计算上代价高昂且耗时。当然，这可能只需要100毫秒，但大多数关系型数据库都是设计来每小时处理数百万次事务的。当你的软件在规模负载下运行时，100毫秒就是一段很长的时间。每个具有商业可行性的数据库都有一个驱动程序，它会为你处理连接池。驱动程序创建了一个数据库连接池。就像机器人手臂一样，你的软件从池中获取连接，执行查询，然后当连接关闭时（这应该尽可能快地完成）而不是真正关闭，开放的连接会被返回到池中，并可供程序中的另一个进程使用。查看以下通用图示：
- en: '![Figure 3.19 – The object pool pattern creates an object that manages a collection
    of other objects. The client requests objects from the pool to use them and then
    releases them when it’s finished. ](img/B18605_Figure_4.16.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – 对象池模式创建了一个管理其他对象集合的对象。客户端从池中请求对象以使用它们，完成后释放它们。](img/B18605_Figure_4.16.jpg)'
- en: Figure 3.19 – The object pool pattern creates an object that manages a collection
    of other objects. The client requests objects from the pool to use them and then
    releases them when it’s finished.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 对象池模式创建了一个管理其他对象集合的对象。客户端从池中请求对象以使用它们，完成后释放它们。
- en: There is a private collection called `PooledObjects` that holds the objects
    in the pool. The client, after gaining access to the object pool, can request
    objects from the pool using the `GetPooledObject` method. Once it is finished,
    the borrowed object is returned to the pool. If the pool is ever empty, a subsequent
    request to `GetInstance` will create a new object if it can. If it can’t, it is
    common for an implementation to wait until an object is returned to the pool.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`PooledObjects`的私有集合，用于存储池中的对象。客户端在获得对对象池的访问权限后，可以使用`GetPooledObject`方法从池中请求对象。一旦完成，借用的对象就会被返回到池中。如果池为空，后续对`GetInstance`的请求将创建一个新对象，如果可能的话。如果不可能，实现通常会等待直到对象返回到池中。
- en: 'Phoebe decides to add a pool to control access to her limited number of robot
    arms:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比决定添加一个池来控制对她的有限数量机器人手臂的访问：
- en: '![Figure 3.20 – Phoebe’s design for an object pool to control a limited number
    of available robot arms on her assembly line. ](img/B18605_Figure_4.17.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – 菲比为她装配线上的有限数量可用机器人手臂设计的对象池。](img/B18605_Figure_4.17.jpg)'
- en: Figure 3.20 – Phoebe’s design for an object pool to control a limited number
    of available robot arms on her assembly line.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – 菲比为她装配线上的有限数量可用机器人手臂设计的对象池。
- en: 'Phoebe writes the code for the diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比为该图编写代码：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Phoebe only has 10 robot arms available, but she knows she’ll have more in
    the future. She makes a private variable here and initializes it to `10`. Next,
    she makes a constructor, but normally, a constructor would just handle creating
    the initialized object. The UML diagram contains an entry for a `Reset()` method,
    which does the same thing. She’ll write that in a moment but puts it in place
    within the constructor. The IDE protests, but she knows it’ll all work out when
    she has finished:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比只有10台机器人手臂可用，但她知道将来会有更多。在这里她创建了一个私有变量并将其初始化为`10`。接下来，她创建了一个构造函数，但通常，构造函数只会处理创建初始化对象。UML图包含一个`Reset()`方法的条目，它执行相同的功能。她将稍后编写它，但将其放在构造函数中。IDE提出了抗议，但她知道当她完成时一切都会顺利：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The most important part of the object pool is some sort of collection to hold
    the pooled objects. Phoebe opted for a `List` of `WeldingArm` objects. This will
    be initialized in the `Reset()`method we mentioned a moment ago, though Phoebe
    hasn’t created it yet:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池最重要的部分是某种类型的集合来存储池中的对象。菲比选择了`WeldingArm`对象的`List`。这将在我们之前提到的`Reset()`方法中初始化，尽管菲比还没有创建它：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Phoebe wants to be able to change the max size of the pool so that she’s able
    to build more robot arms. She can increase the pool size or even decrease it if
    the arms are out of the pool for servicing:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比希望能够改变池的最大大小，这样她就能构建更多的机器人手臂。她可以增加池的大小，甚至在手臂因维护而离开池时减少它：
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Phoebe decides it would be nice to have a way to see how many arms are in the
    pool:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比决定有一个方法来查看池中有多少手臂会很好：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, the fabled `Reset()` method we’ve been promised. It looks like code
    you’d put in a constructor. Phoebe wants a way to reset the pool if she needs
    to. Since being DRY is a good thing and calling a constructor with anything besides
    the `new` keyword seems weird and unnatural, Phoebe flips things around and puts
    the logic here and then calls it from wherever it’s needed, including the constructor.
    This drives my IDE crazy. It thinks I have a non-nullable list that is never initialized.
    That’s not true, but the automation in the IDE isn’t savvy enough to see that.
    The code itself initializes the list and then fills it with as many arms as indicated
    by the `MaxSize` property:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们期待已久的`Reset()`方法。这看起来像是你会在构造函数中放入的代码。菲比想要一种在需要时重置池的方法。由于DRY（Don't Repeat
    Yourself）是一个好习惯，而且使用除`new`关键字之外的任何内容调用构造函数看起来都很奇怪且不自然，菲比将事情反过来，将逻辑放在这里，然后在需要的地方调用它，包括构造函数。这让我的人工智能开发环境（IDE）疯狂。它认为我有一个永不初始化的非空列表。这不是真的，但IDE的自动化功能还不够聪明，看不出来。代码本身初始化列表，然后根据`MaxSize`属性指示的数量填充它：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need a way to get arms from the pool. The following method checks whether
    there are any arms available, and if there are, it retrieves the first one in
    the pool. If there aren’t any arms, we throw an error:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种从池中获取手臂的方法。以下方法检查是否有可用的手臂，如果有，则检索池中的第一个手臂。如果没有手臂，我们抛出一个错误：
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In a real program, you would probably just return a new object and pay the
    performance penalty. In this case, we are physically constrained. We could implement
    some concurrent code that watches for an available arm as it becomes free, which
    directs to a new job, but that’s getting outside the scope of a pattern demonstration.
    Phoebe needs a way to return her arms to the pool. The arm stores the location
    of its last weld. Phoebe, to avoid confusion, decides to reset it to zero. This
    will indicate the arm isn’t working on anything and that it’s in the pool, ready
    for assignment:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实程序中，你可能只是返回一个新的对象，并承担性能损失。在这种情况下，我们实际上受到限制。我们可以实现一些并发代码，监视当手臂空闲时是否有可用的手臂，这指向一个新的工作，但这已经超出了模式演示的范围。菲比需要一种方法将她的手臂返回到池中。手臂存储其最后焊接的位置。为了避免混淆，菲比决定将其重置为零。这将表明手臂没有在工作，它位于池中，准备分配：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Wrapping things up, Phoebe writes a small test program in `Program.cs`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，菲比在`Program.cs`中编写了一个小的测试程序：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As a tool, the Object Pool can seriously speed up most software because usually,
    you only think to use it when an object takes a lot of time or resources to create.
    The pool creates the objects in advance, and hopefully, never again.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种工具，对象池可以极大地加快大多数软件的速度，因为通常，你只有在对象创建需要大量时间或资源时才会想到使用它。池预先创建对象，并希望以后不再需要。
- en: “*BUT!*” Phoebe says aloud to herself, “*this seems like it would work best
    if you could guarantee only one pool was in use at a time.*” She’s right. Concerning
    the robot arms, it wouldn’t do to have the software simply create more instances
    of the arm. It stands to reason that eventually, the control software should be
    multithreaded. You can’t have multiple threads creating their own pool. Instantiating
    additional pools can’t magically generate more resources in the real world. “*If
    only there were a way to make sure the object pool is only ever instantiated once
    per program run,*” Phoebe thinks. She’d keep working, but it’s taco night, so
    she shuts down her laptop and prepares herself for dinner. You can find Phoebe’s
    source for the object pool pattern in this chapter’s source code in the `ObjectPoolExample`
    project.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: “*但是*！”菲比大声对自己说，“*这似乎最好能保证一次只有一个池在使用。*”她是对的。关于机器人手臂，软件简单地创建更多实例是不合适的。从逻辑上讲，控制软件最终应该是多线程的。你不能有多个线程创建它们自己的池。在现实世界中，实例化额外的池不能神奇地生成更多资源。“*如果只有一种方法可以确保对象池在程序运行期间只实例化一次，*”菲比想。她本可以继续工作，但今天是玉米卷之夜，所以她关闭了笔记本电脑，准备晚餐。你可以在这个章节的源代码中的`ObjectPoolExample`项目中找到菲比对对象池模式的源代码。
- en: The Singleton pattern
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: That night, perhaps inspired by her Object Pool singularity problem, perhaps
    by the tacos, or perhaps both, Phoebe had a strange dream. She was a judge dressed
    in long flowing black robes sitting high on her bench in a courtroom. A trial
    was in progress. The defendant was one Sing Elton. He was a well-dressed middle-aged
    gentleman who sat quietly behind a large elaborately carved oaken table next to
    his counsel.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 那天晚上，或许是被她的对象池奇点问题所启发，或许是受到玉米卷的影响，或许两者兼而有之，菲比做了一个奇怪的梦。她是一个穿着长流苏黑色法袍的法官，坐在法庭的高台上。一个审判正在进行。被告是辛·埃尔顿。他是一位穿着得体的中年绅士，安静地坐在他律师旁边的一个大而精致雕刻的橡木桌后。
- en: The courtroom clerk cleared her throat and spoke without inflection into a microphone.
    “*The defendant, Sing Elton, stands accused of impersonating a beneficial design
    pattern and is, in fact, an antipattern.*”
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 法庭书记员清了清嗓子，对着麦克风平静地说，“*被告辛·埃尔顿被指控模仿一个有益的设计模式，实际上却是一个反模式。*”
- en: There was a collective gasp from half of the gallery. It came from the back
    of the courtroom, which Phoebe only now notices. The room is filled with software
    developers, all of whom are clad in cargo shorts, Birkenstock sandals, and $300
    replicas of vintage *Metallica* T-shirts. Phoebe bangs her gavel and shouts, “*ORDER
    IN THE COURT!*” She had seen that in a movie once and had always wanted to do
    that. With the gallery quietened, the clerk continued without looking up from
    her computer screen. “*These are very serious charges, Mr. Elton; how do you plead*?”
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 陪审团中有一半人发出了集体吸气声。这声音来自法庭的后方，菲比这时才注意到。房间里充满了软件开发者，他们都穿着工装短裤、Birkenstock凉鞋和300美元的复古*金属乐队*T恤复制品。菲比敲响法槌，大声喊道，“*法庭秩序！*”她曾在电影中看到过这一幕，一直想这么做。随着陪审团安静下来，书记员没有抬头，继续从电脑屏幕上发言。“*这些是非常严重的指控，埃尔顿先生；你将如何答辩？*”
- en: Elton’s counsel, a wiry nervous man in an inexpensive blue suit stood and in
    a squeaky voice said, “*Not guilty!*”
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 埃尔顿的律师，一个瘦弱的紧张男人，穿着廉价的蓝色西装，站起来，用尖锐的声音说，“*无罪！*”
- en: The clerk entered the plea and the trial began. The prosecutor rose for his
    opening remarks, delivered in a slow Southern drawl reminiscent of a cowboy Western
    movie. “*Your honor, we intend to show beyond a reasonable doubt that Sing Elton
    is not a pattern as he represents himself but is an antipattern. He is openly
    a member of an outlaw coding organization called The Golden Hammers.*” The prosecutor
    sat down, flashing a wry smile with far too many teeth to be human. Do you know
    why sharks never attack attorneys? Professional courtesy.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 书记员记录了答辩，审判开始了。检察官站起来发表开场白，他的南方口音缓慢而拖沓，让人联想到牛仔西部电影。他说，“*尊敬的法官，我们打算证明，辛·埃尔顿并非像他自己所宣称的那样是一个模式，而是一个反模式。他公然是名为“金锤”的非法编码组织的成员。*”检察官坐下，露出一个带有太多牙齿的狡猾微笑，这让人怀疑他是否是人类。你知道为什么鲨鱼从不攻击律师吗？职业礼节。
- en: The defense called Mr. Elton to the stand and as he questioned him, the defense
    was able to establish several salient premises aiming to prove Sing Elton was
    a pattern.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 辩护方叫埃尔顿先生出庭作证，在审问他时，辩护方能够确立几个关键前提，旨在证明辛·埃尔顿是一个模式。
- en: First, it’s a widely used, popular pattern that was published in the *Gang of
    Four* book. This book is considered by many to be unassailable, given it is a
    seminal work in software design patterns.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个广泛使用、受欢迎的模式，它被收录在*四人帮*这本书中。这本书被许多人视为不可动摇的，因为它被认为是软件设计模式的奠基之作。
- en: “*OBJECTION!,*” the prosecutor yelled as he pounded his fist on the table. “*Your
    honor, neither popularity nor inclusion in a single book is sufficient evidence
    to prove this is a pattern.*”
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: “*反对！*”检察官大声喊道，同时用拳头猛击桌子。“*尊敬的法官，受欢迎程度或被收录在单一书籍中并不足以证明这是一个模式。*”
- en: Phoebe tapped her gavel lightly on the bench and said, “*Sustained. The defense
    will continue, but you’re on thin ice, counselor. To be a pattern, Sing Elton
    must solve a common problem faced by many software developers. This isn’t a popularity
    contest. You’ll have to do better.*”
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比轻轻地在法官台上敲了敲她的法槌，说道，“*维持原判。辩护将继续进行，但你的立场很脆弱，律师。要成为一个模式，辛·埃尔顿必须解决许多软件开发者面临的一个共同问题。这不是一场受欢迎的竞赛。你必须做得更好。*”
- en: “*Yes, your honor.*” The counselor blushed and was flustered, as though he were
    hoping the case would be dismissed based on this opening argument. He continued
    to question Mr. Elton.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: “*是的，尊敬的法官。*”律师脸红，显得有些慌乱，好像他希望这个案件能基于这个开场白被驳回。他继续审问埃尔顿先生。
- en: “*Can you tell the court exactly what problems you solve?*”
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: “*你能向法庭准确说明你解决了哪些问题吗？*”
- en: “*Sometimes,*” began Mr. Elton, “*you need to ensure there is only one copy
    of a class instantiated at any given time while your program is running. For example,
    you need access to a database, perhaps via an object pool, or maybe you need access
    to a file or a configuration service. In these cases, you should only have one
    instance to handle that. The instance is available to all parts of your program,
    giving you tight control over the global state. These are problems I can solve,
    and I do it in one place within a single class rather than them being scattered
    throughout your code.*”
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: “*有时候，*”埃尔顿先生开始说，“*你需要确保在程序运行期间任何时候只有一个类的实例。例如，你可能需要访问数据库，可能通过对象池，或者你可能需要访问文件或配置服务。在这些情况下，你应该只有一个实例来处理这些。该实例对程序的所有部分都是可用的，这让你能够紧密控制全局状态。这些问题我可以解决，而且我是在一个类中的一个地方解决的，而不是分散在代码的各个部分。*”
- en: 'At one point during the trial, the bailiffs brought in a big whiteboard, and
    Mr. Elton was asked to draw a diagram of himself. It looks as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在审判过程中某个时刻，法警带来了一块大白板，并要求埃尔顿先生画一幅自己的图。它看起来如下：
- en: '![Figure 3.21 – The Singleton pattern uses a private constructor (not shown)
    to create an instance of the object (itself) held in a private field. Any calls
    to new for that class will check to see whether an instance already exists. If
    it does, the existing object is returned. ](img/B18605_Figure_4.18.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 单例模式使用一个私有的构造函数（未显示）来创建一个对象（它自己）的实例，该实例存储在一个私有字段中。对该类调用 new 时，会检查是否已存在实例。如果存在，则返回现有对象。](img/B18605_Figure_4.18.jpg)'
- en: Figure 3.21 – The Singleton pattern uses a private constructor (not shown) to
    create an instance of the object (itself) held in a private field. Any calls to
    new for that class will check to see whether an instance already exists. If it
    does, the existing object is returned.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 单例模式使用一个私有的构造函数（未显示）来创建一个对象（它自己）的实例，该实例存储在一个私有字段中。对该类调用 new 时，会检查是否已存在实例。如果存在，则返回现有对象。
- en: 'The defense continued and summarized its arguments this way:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 辩护方继续并这样总结了其论点：
- en: Shared resources used by your application, whether they be databases, files,
    remote services, or robotic arms, are granted and guaranteed a single point of
    access.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序使用的共享资源，无论是数据库、文件、远程服务还是机械臂，都保证只有一个访问点。
- en: The global state of the program is protected because there is only one point
    of access.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的全局状态受到保护，因为只有一个访问点。
- en: Singletons are only initialized once, so any performance hit is taken only when
    the singleton is initialized.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式只初始化一次，因此只有在单例初始化时才会产生性能影响。
- en: The defense attorney concluded with “*The defense rests.*”
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 辩护律师以“*辩护结束。*”作为结论。
- en: The nearly silent courtroom suddenly boomed with the echoing sound of a loud
    slow golf clap. The prosecutor stood up and straightened his tie while hungrily
    eyeing the jury. You could feel the confidence emanating from him. It was electric.
    As he spoke, it almost sounded as if his Southern drawl was intentionally more
    pronounced.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎无声的法庭突然爆发出一阵响亮的慢速高尔夫掌声。检察官站起来，整理了一下领带，贪婪地盯着陪审团。你能感觉到从他身上散发出的自信。那是一种电击般的感觉。当他说话时，几乎听起来就像他的南方口音故意更加明显。
- en: “*Your honor, members of the jury, let me tell you why everything the defense
    just said is a gigantic load of BAM!*” The *BAM* came from Judge Phoebe, who saw
    where this was going and slammed her gavel on the bench. She’d only been a judge
    for a few minutes, and might never be again, so there was no way she was going
    to let that kind of language into her courtroom. A girl’s gotta have standards.
    Having admonished the prosecutor, to the bemusement of the clerk and defense attorney,
    the prosecutor called several witnesses who offered anecdotal evidence of Sing
    Elton being an antipattern and a Golden Hammer.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: “*尊敬的法官，陪审团成员们，让我告诉你们为什么辩护方刚才说的每一件事都是一大堆胡言乱语！*” “胡言乱语”这个词是法官菲比说的，她看到了事情的发展方向，用力敲击了法槌。她只做了几分钟的法官，可能再也不会做了，所以她绝对不允许那种语言出现在她的法庭上。女孩得有自己的标准。在警告了检察官后，这让书记员和辩护律师感到困惑，检察官叫了几位证人，他们提供了关于
    Sing Elton 是一个反模式和黄金锤子的轶事证据。
- en: One software engineering manager testified that Sing Elton must be a Golden
    Hammer because in every job interview he had ever conducted, the applicants always
    claimed to have studied patterns. When the manager asked for an example of a pattern,
    the only pattern anyone could name was the singleton pattern. There are quite
    a few classes out there (you’d think there would be only one example) where the
    implementation doesn’t need to be a singleton. Everyone uses it because it’s the
    one pattern they understand and remember.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一位软件工程经理作证说，辛·埃尔顿肯定是一个黄金锤子，因为在每一次他主持的面试中，应聘者总是声称他们研究过设计模式。当经理要求提供一个模式的例子时，唯一能被提到的模式就是单例模式。现在有很多类（你可能会认为只有一个例子）其实不需要实现为单例。每个人都使用它，因为它是最容易理解和记住的模式。
- en: 'One software developer employed by a major software company specializing in
    defenestration pointed out the most damning arguments:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一家专注于窗户破碎修复的软件公司的一名软件工程师指出了最令人信服的论点：
- en: According to the widely accepted tenet, every class should have one responsibility;
    it should only solve one problem. Ironically, a singleton solves two. It ensures
    only one single instance of the class exists and it provides a single point of
    access to some shared or constrained resource.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据广泛接受的原理，每个类都应该有一个职责；它应该只解决一个问题。讽刺的是，单例模式解决了两个问题。它确保只有一个类的实例存在，并且提供了一个访问某些共享或受限资源的单一入口点。
- en: The Singleton pattern smells a lot like a global variable. Instead of just a
    variable, it’s a whole class. Globals are universally vilified throughout coder-land
    because they are considered unsafe. Any method on any given object within your
    running program can modify the global state, which typically leads to unstable
    software. This has compounded ramifications for software designed for threading
    or concurrency.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式闻起来非常像全局变量。它不仅仅是一个变量，而是一个完整的类。在程序员的世界里，全局变量普遍受到谴责，因为它们被认为是不安全的。运行程序中任何给定对象的任何方法都可以修改全局状态，这通常会导致软件不稳定。对于设计用于线程或并发的软件，这有更严重的后果。
- en: Singletons are cited as promoting tight coupling between classes. You really
    can’t get around this since there is no such thing as an abstract singleton.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式被认为促进了类之间的紧密耦合。你真的无法避免这一点，因为没有抽象单例这种东西。
- en: Implementations of singletons are impossible to unit - test effectively. Besides
    our earlier stated problem of tight coupling, which is itself anathema to testing,
    you can’t mock the singleton class. It’s sealed and has no parent class, so using
    Liskov substitution is impossible as a tool for testing. Unit tests should be
    isolable and the effects of one test shouldn’t affect other tests. With a singleton
    in the mix, they probably will.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例的实现很难进行有效的单元测试。除了我们之前提到的紧密耦合问题，这本身就是测试的大忌，你无法模拟单例类。它是密封的，没有父类，因此使用Liskov替换作为测试工具是不可能的。单元测试应该是可隔离的，一个测试的效果不应该影响其他测试。有了单例的参与，它们很可能会受到影响。
- en: The prosecutor concluded with, “*So you see, your honor, ladies and gentlemen
    of the jury, Sing Elton is nothing but a low-down dirty fraud. He’s no pattern
    at all and should be stripped of the title.*”
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 检察官总结道：“*所以，尊敬的法官，陪审团的女士们和先生们，辛·埃尔顿不过是一个卑鄙无耻的骗子。他没有任何模式，应该被剥夺这个头衔。*”
- en: A chorus of harumphs erupted from the gallery. Phoebe smiled because that was
    her cue to bang the gavel again. She could get used to this. She hit the bench
    so hard that the resulting sound shook her from her dream. It was like that dream
    everybody has had at least once – the one where you dream you’re falling and you
    wake up just as you hit the ground.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 画廊里爆发出一阵不满的哼声。菲比微笑，因为那是她再次敲响法槌的信号。她可以习惯这种生活。她重重地敲击了长凳，以至于产生的声音将她从梦中惊醒。这就像每个人至少做过一次的梦——那个你梦见自己在坠落，当你即将触地时突然醒来的梦。
- en: “*I’m never eating tacos again!”* Phoebe exclaimed sleepily. She knew she was
    lying. She had a not-taco breakfast and went back to work. The details of her
    dream had some valid points, but she felt this was a case where she truly needed
    a singleton, given the very real constraints at play.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: “*我再也不会吃玉米卷了！*”菲比昏昏欲睡地喊道。她知道她在撒谎。她吃了一顿非玉米卷的早餐，然后回去工作了。她梦中的细节有一些合理的观点，但她觉得这是一个她真正需要单例模式的案例，考虑到实际存在的非常真实的限制。
- en: 'Phoebe models an object pool using a singleton to represent her constrained
    shared collection of robot arms in the control software:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比使用单例模式来模拟一个对象池，用单例来代表她在控制软件中受限的共享机器人手臂集合：
- en: '![Figure 3.22 – Phoebe has refactored her object pool into a singleton. Now,
    only one robot arm pool can exist within her running program at any given time.
    ](img/B18605_Figure_4.19.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22 – 菲比已经将她的对象池重构为单例。现在，在她的运行程序中任何时候只能存在一个机器人臂池。](img/B18605_Figure_4.19.jpg)'
- en: Figure 3.22 – Phoebe has refactored her object pool into a singleton. Now, only
    one robot arm pool can exist within her running program at any given time.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – 菲比已经将她的对象池重构为单例。现在，在她的运行程序中任何时候只能存在一个机器人臂池。
- en: 'Phoebe moves to her IDE and starts refactoring the object pool for her robotic
    arms into a singleton. It’s pretty short work. First, she renames the class and
    seals it so that it can’t be extended. If the class were able to be extended,
    it would lose the protection afforded by the pattern. You can start to see why
    people hate the Singleton pattern. It’s breaking a lot of the rules we’ve come
    to admire about keeping things open for extension:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比转向她的IDE，开始将她的机器人臂对象池重构为单例。这是一项相当简单的工作。首先，她重命名了类并将其密封，这样它就不能被扩展。如果类能够被扩展，它就会失去模式提供的保护。你可以开始看到为什么人们讨厌单例模式。它打破了我们一直钦佩的许多关于保持事物可扩展性的规则：
- en: '[PRE54]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For a Singleton pattern to work, it needs a private static method to hold the
    singleton instance. In effect, this is a class that has a reference to itself,
    which is kinda odd. The key is that there can only be one of them, which is why
    we need the field to be static:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使单例模式工作，它需要一个私有静态方法来持有单例实例。实际上，这是一个有自我引用的类，这有点奇怪。关键是只能有一个这样的实例，这就是为什么我们需要将字段设置为静态：
- en: '[PRE55]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The next oddity you don’t see often is a private constructor. There isn’t a
    public one. Right about now is when your IDE, if it is equipped with static analysis
    tools, will start to complain. It will tell you there is no way to instantiate
    the object. That’s good. That’s what we’re after. Phoebe keeps her `Reset()` logic
    in place. All she did was rename the constructor so that it matches the class
    name and changed the access modifier to private:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个你不太常见的怪癖是私有构造函数。没有公共的构造函数。就在这个时候，如果你的IDE配备了静态分析工具，它将开始抱怨。它会告诉你无法实例化对象。这是好事。这正是我们想要的。菲比保留了她的`Reset()`逻辑。她所做的只是将构造函数重命名，使其与类名匹配，并将访问修饰符更改为私有：
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The last piece to the Singleton is a static method to gain access to the instance
    property we started with. Phoebe uses C#’s property syntax to expose it. The first
    time the client program references the `Instance` property, the getter checks
    to see whether an instance already exists. If not, it creates one and sets the
    backing field’s `_instance`. If `_instance` is not `null`, that means it’s been
    called once already, so it just returns the instance that is already there. Since
    it’s a static field, all references point to the same location in memory. Voila
    – you have a class that is impossible to instantiate twice:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式最后一块拼图是一个静态方法，用于访问我们最初开始的实例属性。菲比使用C#的属性语法来暴露它。当客户端程序第一次引用`Instance`属性时，获取器会检查是否已经存在一个实例。如果没有，它会创建一个并设置后备字段的`_instance`。如果`_instance`不是`null`，这意味着它已经被调用过一次，所以它只是返回已经存在的实例。由于它是一个静态字段，所有引用都指向内存中的同一位置。就这样——你得到了一个无法实例化两次的类：
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The rest of Phoebe’s code remains unchanged. You can find the complete refactor
    in the `SingletonExample` project of this chapter’s source code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比的其余代码保持不变。你可以在本章源代码的`SingletonExample`项目中找到完整的重构。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented one idiom, the simple factory, and four patterns
    – the Factory Method pattern, the Abstract Factory pattern, the Object Pool pattern,
    and the Singleton pattern.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一个惯用方法，即简单工厂，以及四个模式——工厂方法模式、抽象工厂模式、对象池模式和单例模式。
- en: All of these patterns are classified as Creational patterns. This means they
    govern the creation of objects by encapsulating the creation logic in a structure
    that is more flexible than using strictly concrete objects with the `new` keyword.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模式都被归类为创建型模式。这意味着它们通过封装创建逻辑在一个比使用严格的具体对象和`new`关键字更灵活的结构中来控制对象的创建。
- en: The Factory Method pattern is what most people think of when they hear “factory
    pattern.” Using it entails abstracting creation logic into a factory class called
    a creator. The creator object is defined by an interface to maximize flexibility.
    We also create an interface for the objects the factory is producing. We call
    this the product. Each factory creator class is responsible for a subset of all
    the products in your program.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式是当人们听到“工厂模式”时首先想到的。使用它意味着将创建逻辑抽象成一个称为创建者的工厂类。创建者对象由一个接口定义以最大化灵活性。我们还为工厂生产的对象创建了一个接口。我们称之为产品。每个工厂创建者类负责程序中所有产品的一个子集。
- en: The Abstract Factory pattern involves creating families of objects that organically
    go together. Using it entails creating an abstract definition for multiple creator
    classes. Each creator is responsible for a concrete object.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式涉及创建一系列自然搭配的对象。使用它意味着为多个创建者类创建一个抽象定义。每个创建者负责一个具体对象。
- en: The Builder pattern is used when you need to make objects using a complex set
    of steps. Using it is similar to the Abstract Factory pattern, but your builder
    classes are defined by an interface. Each method in the builder represents a step
    of the build process. It might be tempting to put a single method in each builder
    class to call the steps in order. However, this is usually delegated to a `Director`
    class. The builder houses the methods to build the object, but the `Director`
    class contains the logic behind the order in which those methods are called.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要使用一系列复杂步骤来创建对象时，会使用建造者模式。使用它类似于抽象工厂模式，但您的建造者类由一个接口定义。建造者中的每个方法代表构建过程的一个步骤。可能会诱使您在每个建造者类中放置一个单独的方法来按顺序调用这些步骤。然而，这通常委托给一个`Director`类。建造者包含构建对象的函数，但`Director`类包含调用这些方法的顺序背后的逻辑。
- en: The Object pool Pattern is designed to help you manage objects that are either
    limited through a real constraint, such as our robot arms, or objects that are
    computationally expensive to create, such as a database, network service, or file
    connections. The idea is to pay the creation penalty once by creating a list of
    those objects that are kept available during your program’s run. When one of these
    objects is needed, the object is taken from the pool and it’s returned when it’s
    no longer needed. This allows other processes to use it later, without having
    to go through normal instantiation.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式旨在帮助您管理那些由于实际约束而受限的对象，例如我们的机器人手臂，或者那些创建成本高昂的对象，例如数据库、网络服务或文件连接。其理念是在程序运行期间一次性支付创建成本，创建一个包含这些对象的列表，这些对象在程序运行期间保持可用。当需要其中一个对象时，它从池中取出，不再需要时再返回。这允许其他进程稍后使用它，而无需经历正常的实例化过程。
- en: The Object Pool pattern can be effectively combined with the Singleton pattern.
    The Singleton pattern is controversial and often considered an antipattern because
    it cannot be extended, and it promotes tight coupling. Phoebe was able to use
    it in combination with her robot arm pool to ensure she didn’t accidentally create
    multiple robot arm pools. She only has 10 physical arms to work with, so duplicating
    pools could prove to be problematic.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式可以有效地与单例模式结合使用。单例模式是有争议的，通常被认为是一个反模式，因为它不能扩展，并且它促进了紧密耦合。菲比能够将其与她的机器人手臂池结合使用，以确保她不会意外地创建多个机器人手臂池。她只有10个物理手臂可以工作，因此复制池可能会带来问题。
- en: These patterns were presented as progression. The sisters started with the simple
    factory and worked iteratively to the builder pattern. This wasn’t intentional
    – that’s just the way it worked out. You shouldn’t take this progression as an
    indication that the Builder pattern is better than the Factory Method or Abstract
    Factory. Each of these patterns has its place and often, patterns can be paired
    together like a fine wine and a good steak.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式被展示为一种渐进。姐妹们从简单的工厂开始，迭代地工作到建造者模式。这并非有意为之——这只是事情发展的结果。您不应将这种渐进视为建造者模式比工厂方法或抽象工厂更好的指示。每个模式都有其位置，并且通常，模式可以像美酒和好牛排一样搭配使用。
- en: In the next chapter, we’ll look at structural patterns, which are patterns designed
    to refine the way you structure your class hierarchies for maximum flexibility
    and to fully achieve the open-closed principle.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨结构模式，这些模式旨在优化您构建类层次结构的方式，以实现最大灵活性和完全实现开闭原则。
- en: Questions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is a programming idiom and how are they different from patterns?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程惯用法是什么，它们与模式有何不同？
- en: What are some popular programming idioms besides `Hello, World`?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 `Hello, World` 之外，还有一些流行的编程惯用法吗？
- en: What is the downside to relying on the simple factory idiom?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖于简单工厂惯用法有什么缺点？
- en: Is the Singleton a pattern or an antipattern? Why?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例模式是一个模式还是一个反模式？为什么？
- en: What pattern should you use when you are dealing with creating a family of related
    objects?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你处理创建一系列相关对象时，你应该使用哪种模式？
- en: What pattern should you use for objects that have a complex build process?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有复杂构建过程的对象，你应该使用哪种模式？
- en: Which class in the Builder pattern is responsible for controlling the execution
    of the build steps in the proper order?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式中哪个类负责以正确的顺序控制构建步骤的执行？
- en: Further reading
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Ritchie, D. M., Kernighan, B. W., & Lesk, M. E. (1988). *The C programming
    language*. Englewood Cliffs: Prentice Hall.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ritchie, D. M., Kernighan, B. W., & Lesk, M. E. (1988). 《C程序设计语言》。Englewood
    Cliffs: Prentice Hall.'
- en: '[https://sites.google.com/site/steveyegge2/singleton-considered-stupid](https://sites.google.com/site/steveyegge2/singleton-considered-stupid)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sites.google.com/site/steveyegge2/singleton-considered-stupid](https://sites.google.com/site/steveyegge2/singleton-considered-stupid)'
