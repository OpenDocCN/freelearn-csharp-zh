<html><head></head><body>
        

                            
                    <h1 class="header-title">Dependency Injection in ASP.NET Core</h1>
                
            
            
                
<p>In <a href="087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml" target="_blank">Chapter 3</a>, <em>Introducing Dependency Injection in .NET Core 2.0</em>, we were focusing on .NET Core exclusively, analyzing the possibilities the platform offers in relation to Dependency Injection and distinct ways to implement it. In this chapter, we'll continue analyzing DI, but, this time, focusing on the implementation of ASP.NET Core and the possibilities offered to the programmer at the time of configuring websites and other related functionality which spreads along the whole life cycle.</p>
<p>The idea is to start with the CLI (command-line tools) and see how to modify a console application and turn it into a web app, so you can better understand the concept of middleware and the way it's used in ASP.NET Core.</p>
<p>With that, we will be ready to move onto an analysis of the default templates that Visual Studio 2017 offers for ASP.NET Core apps, and the specific features linked to DI in those initial models.</p>
<p>Finally, we'll see how to tune up our own services and how to use them via Dependency Injection in registration options, controllers, and views.</p>
<p>In all, we will cover the following topics in this chapter:</p>
<ul>
<li>Building ASP .NET Core apps using command-line tools.</li>
<li>Middleware architecture in ASP .NET Core.</li>
<li>Analyzing the default templates offered by Visual Studio.</li>
<li>Features of DI in ASP.NET applications. Customized services.</li>
</ul>
<p>Notice the official documentation site uses the same code as the templates offered by Visual Studio 2017. You can find it at <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc">https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ASP.NET Core from the command-line tools</h1>
                
            
            
                
<p>Once we have installed .NET Core in our boxes and updated (if necessary) to version 2.0, we can start a very simple, but explanatory, website from scratch using command-line tools and see how we can move from that minimum .NET Core Console app to an ASP.NET Core app in a few steps.</p>
<p>This process will help you understand the profound changes in architecture that ASP.NET Core carries, and how some of the SOLID principles that we have seen are applied in a variety of ways to achieve this goal.</p>
<p>Thus, the first step should be to check out our installed version of .NET Core, which we can do in a command-line window (remember that Visual Studio 2017 installs several links to these windows in the Windows menu, and that the Developer Command Prompt already has environment variables defined to suit the main needs of a programmer).</p>
<p>If you do not already have the .NET Core command-line tools installed, remember that you can do it in a separate install from the site <a href="https://www.microsoft.com/net/download/core">https://www.microsoft.com/net/download/core</a> in the Command-Line/Other section, which lets you download the installer for all versions currently supported. When run, the installer should look as follows:</p>
<div><img height="329" width="443" class=" image-border" src="img/b275b9f4-c822-417a-b523-a698ca3f9a57.png"/></div>
<p>After installation, a new folder should appear at <kbd>C:\Program Files\dotnet\sdk</kbd> named 2.0, (or whichever is the latest version available at the time).</p>
<p>So, we can just check the current version's details with the <kbd>dotnet -version and dotnet --info</kbd> commands, and see if we have version 2.0 installed:</p>
<div><img height="311" width="462" class=" image-border" src="img/7f441d89-37a8-487c-a579-975db3284c70.png"/></div>
<p>The window will show some basic commands, such as <kbd>--help</kbd> and <kbd>--version</kbd>. To check the types of templates available for the latest version, just type <kbd>dotnet new</kbd> (with no extra parameters), and you'll be presented a list of this kind:</p>
<div><img height="238" width="589" class=" image-border" src="img/fa8e1542-c4ac-4f29-98dd-de37b409f4fa.png"/></div>
<p>Notice that the first time you type that command it will decompress some files (it takes a few seconds), to initially populate your local package cache. That will only happen once, improving restore speed and enabling offline access.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the minimum possible application</h1>
                
            
            
                
<p>We have 11 default types of templates (you can install extra ones from GitHub) for as many project types, plus a solution option that creates a <kbd>.sln</kbd> file including the projects inside the depending folders, and distinct options related to configuration and Web/ASP.NET solutions.</p>
<p>To test this latest version, inside the Command Prompt, create a new folder, move to it, and just type a <kbd>dotnet new console</kbd> command. This creates two files that define the simplest app (console app) for .NET Core.</p>
<p>At that moment, you should see a <kbd>program.cs</kbd> and a <kbd>[NameOfDirectory].csproj</kbd> file, which contains dependency information for your app.</p>
<p>Notice that previous versions used a <kbd>project.json</kbd> file instead, with the same information, but if you open any previous project with V. Studio 2017 it will recognize it and migrate it automatically.</p>
<p>The contents of the <kbd>.csproj</kbd> file, contain a few basic directives in XML format.</p>
<p>To keep working with very basic resources in this initial demo, I'm going to use Notepad++ for code coloring and some other editing features.</p>
<p>You should see the following content in the <kbd>.csproj</kbd> file:</p>
<div><img height="219" width="442" class=" image-border" src="img/0be4c177-7e07-4c2f-ab76-a0d51b1513af.png"/></div>
<p>As you see, it indicates we're using the .NET SDK, the output is an <kbd>exe</kbd> file, and we're targeting NET Core 2.0.</p>
<p>The contents of our <kbd>program.cs</kbd> file are as expected (no changes from a typical Console application, in a classical .NET Framework):</p>
<pre>    class Program 
   { 
      static void Main(string[] args) 
      { 
         Console.WriteLine("Hello World!"); 
      } 
   }  </pre>
<p>But, still, we need to download the dependencies, a task that is performed using a <kbd>dotnet restore</kbd> command previous to any other options. After issuing that command, you'll see how it downloads all required packages, and a new <kbd>obj</kbd> directory shows up.</p>
<p>And that's it. You can finally issue the <kbd>dotnet run</kbd> command, which, in turn, compiles and executes the app, showing the expected message in the console (nothing new, I omited the output).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing to ASP .NET Core</h1>
                
            
            
                
<p>Now, to change our application into an ASP.NET Core app, the first thing to do is to install the package called <kbd>Microsoft.AspNetCore</kbd>. We can do this by issuing the <kbd>dotnet add package Microsoft.AspNetCore</kbd> command.</p>
<p>When we do that, the command-line tool will download the appropriate package and modify our <kbd>.csproj</kbd> accordingly, so it is included in our solution as well (see the new version of <kbd>csproj</kbd> after issuing the command):</p>
<div><img height="290" width="657" class=" image-border" src="img/ef2bb94e-08b9-42aa-8ff6-3a586b085d2f.png"/></div>
<p>We see the presence of a new <kbd>&lt;ItemGroup&gt;</kbd> tag, indicating the reference to include and the version that has been downloaded and added to the project.</p>
<p>We're now ready to create our web starting now that will take the form of a class named <kbd>Startup.cs</kbd> (of course you can name it as you want as long as you configure it later. It's not a convention name).</p>
<p>Inside that file, we'll reference the three extra namespaces required to create a website (although a basic one):</p>
<ul>
<li><kbd>Microsoft.AspNetCore.Builder</kbd>: To actually build a web server using the <kbd>config</kbd> parameters we've defined</li>
<li><kbd>Microsoft.AspNetCore.Hosting</kbd>: To hold the web application</li>
<li><kbd>Microsoft.AspNetCore.Http</kbd>: For all HTTP-related activities</li>
</ul>
<p>With those references, we need to add a method named <kbd>Configure</kbd> (and this is by convention), where we will indicate the minimum actions to perform when the server is launched.</p>
<p>Here, we will start seeing DI in action, because the shape of this very basic method is as follows:</p>
<pre>    using Microsoft.AspNetCore.Builder; 
    using Microsoft.AspNetCore.Hosting; 
    using Microsoft.AspNetCore.Http; 
 
    namespace WebApplication1 
    { 
      public class Startup 
      { 
        public void Configure(IApplicationBuilder app, <br/>            IHostingEnvironment env) 
        { 
          if (env.IsDevelopment()) 
          { 
            app.UseDeveloperExceptionPage(); 
          } 
          app.Run(async (context) =&gt; 
          { 
            await context.Response.WriteAsync("This is a first<br/>                  web app..."); 
          }); 
        } 
      } 
    } </pre>
<p>But, before we start explaining the inner details of that file, let's make sure it compiles correctly and that we redirect our application to the new website.</p>
<p>So, we will issue another <kbd>dotnet restore</kbd> command, so all new references are located properly, and the next step will be to modify our main entry point, to create a new web host that uses the <kbd>Startup</kbd> class just created.</p>
<p>With that purpose, the new <kbd>Main()</kbd> entry point will use a reference to <kbd>Microsoft.AspNetCore.Hosting</kbd> namespace, and define the following:</p>
<pre>    using Microsoft.AspNetCore; 
    using Microsoft.AspNetCore.Hosting; 
 
    namespace WebApplication1 
    { 
      public class Program 
      { 
        public static void Main(string[] args) 
        { 
            BuildWebHost(args).Run(); 
        } 
 
        public static IWebHost BuildWebHost(string[] args) =&gt; 
            WebHost.CreateDefaultBuilder(args) 
                .UseStartup&lt;Startup&gt;() 
                .Build(); 
      } 
    } </pre>
<p>Finally, we can repeat the <kbd>dotnet run</kbd> command and we will see two different outputs. On one side, the CLI environment, we will generate a web host and run it (by default, using port number <kbd>5000</kbd>), indicating that in the console output:</p>
<div><img height="141" width="578" class=" image-border" src="img/af29f757-4ed4-4201-85d3-1a87a2859dea.png"/></div>
<p>That host will keep on running and listen on that port until we stop it using <em>Ctrl</em> + <em>C</em>. Now, we can open a browser and type the URL to see the following page:</p>
<div><img height="119" width="393" class=" image-border" src="img/e08ab7b6-8bbb-41a9-b255-a85a7d515ce5.png"/></div>
<p>Of course, that page doesn't contain any HTML, only the text we order the server to send back to the user when a request is received on that port. Just take a look at the source code if you want to check this out.</p>
<p>But, before we continue the explanation of the previous code, it's important to understand the concept of Middleware, present from the beginning in ASP.NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Middleware</h1>
                
            
            
                
<p>Of course, middleware refers to software, but to a software that is assembled using an application pipeline in a manner that facilitates handling requests and responses.</p>
<p>Obviously, you may wonder what an application pipeline is. Wikipedia defines the terms like this: "<em>In software engineering, a pipeline consists of a chain of processing elements (processes, threads, coroutines, functions, etc.), arranged so that the output of each element is the input of the next; the name is by analogy to a physical pipeline</em>".</p>
<p>These pipelines are common in many software languages, even in modern constructions as in JavaScript Promises, which define asynchronous pipelines for a sequence of calls, improving execution control.</p>
<p>One important feature of pipelines is that each component of the pipeline can decide whether it passes information to the next component or returns directly, and has the ability to perform custom actions before and after that component is invoked.</p>
<p>In ASP.NET Core, to build a request pipeline, we use delegates to handle each request. And, again, we find some of the SOLID principles present in this architecture.</p>
<p>Every time you need to configure one of these delegates, you use one method belonging to the method's families called <kbd>Use*</kbd>, <kbd>Run*</kbd> and <kbd>Map*</kbd> (they are sets of predefined extension methods starting with these prefixes, each one with a specific purpose).</p>
<p>These methods are linked to the <kbd>IApplicationBuilder</kbd> object that the <kbd>Configure</kbd> method receives via Dependency Injection. The following schema visually explains this structure (notice that the thread of execution follows the black arrows):</p>
<div><img height="392" width="543" src="img/e904ea53-abd1-4178-941b-77b86fa9fec2.png"/></div>
<p>In this manner, it's totally up to the programmer to keep on passing the <kbd>IApplicationBuilder</kbd> object to another middleware piece (notice the call to <kbd>next()</kbd>) or avoid any other call, in which case it returns to the calling method.</p>
<p>If one of these delegates decides not to pass a request to the next delegate, that's called <strong>short-circuiting</strong> the request pipeline. This is often convenient to avoid having to perform any unnecessary work.</p>
<p>In the case of exception handling delegates, they need to be called early in the pipeline, to allow them to catch exceptions that might occur later in the sequence.</p>
<p>Let's go now for the explanation of the previous code with all this in mind.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Startup class and Dependency Injection</h1>
                
            
            
                
<p>The <kbd>Startup</kbd> class coded previously is, therefore, the component in charge of configuring the request pipeline and handling all requests made to the application.</p>
<p>This class is mandatory (although, as mentioned, it could be named differently) because the runtime will look inside it for the methods that take care of configuration aspects, and that includes services as well. You can consider it as a convenient way to achieve independent configurations via the first SOLID principle (SoC).</p>
<p>One of the interesting features linked to this separation of responsibility is that you can define distinct <strong>Startup</strong> classes depending on the environment (development, production, and so on). The appropriate one will be selected at runtime.</p>
<p>This class is defined in such a way that accepts dependencies provided via Dependency Injection, as well. For instance, you can declare variables of types <kbd>IHostingEnvironment</kbd> or <kbd>ILoggerFactory</kbd> to gain the ability to configure diverse functionality related to hosting or logging (remember in, <a href="" target="_blank">Chapter 3</a>, <em>Introducing Dependency Injection in .Net Core 2.0</em>).</p>
<p>So, what is mandatory in this class and what is optional? The <kbd>Configure</kbd> method is mandatory. No matter what the name of the class, the runtime will look for it inside and call it to make sure the required conditions apply.</p>
<p>However, the <kbd>ConfigureServices()</kbd> method is optional, but if it is present, it will be called prior to <kbd>Configure()</kbd> during that initial process. The following schema illustrates this sequence:</p>
<div><img height="181" width="198" src="img/c606338c-ce7b-447d-8d4c-ad99ecd6ffad.png"/></div>
<p>(Image courtesy: <a href="http://developer.telerik.com/featured/understanding-asp-net-core-initialization/">http://developer.telerik.com/featured/understanding-asp-net-core-initialization/</a>)</p>
<p>Before going any further in demos, let's explain the previous code in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code explanation</h1>
                
            
            
                
<p>Starting with the <kbd>Main()</kbd> method, after a reference to the <kbd>Hosting</kbd> subspace that we mentioned previously, we build a new web server by calling the <kbd>WebHostBuilder</kbd> class. This class permits configuration and building of a web server using various middleware pieces and entry point conditions.</p>
<p>Thus, after calling the constructor, we piped another three calls:</p>
<ul>
<li>One to <kbd>UseKestrel()</kbd>, which is the default, light-weight server for development that Visual Studio 2017 (and the CLI) uses (we'll explain that in a while)</li>
<li>Another call to <kbd>UseStartup&lt;Startup&gt;()</kbd>, to indicate where the server will find the <kbd>Configure()</kbd> method to initiate its process (remember the name of the class is irrelevant, as far as it contains the method <kbd>Kestrel</kbd> looks for initially)</li>
<li>And, finally, another one to <kbd>Build()</kbd>, which creates and initializes the new server with those previous values</li>
</ul>
<p>With all that in place, that last sentence simply calls the <kbd>Run()</kbd> method to launch the process.</p>
<p>When launching that process, the <kbd>Configure</kbd> method turns on. Its only parameter (in this case), is of type <kbd>IApplicationBuilder</kbd>, and, as you see, is served to this method by Dependency Injection (no previous references or instantiation were made by our code).</p>
<p>Consequently, when a server is created, the main, basic objects implied in the communication process are served in this manner, expecting from the user all required behaviors in the form of subsequent calls to its methods.</p>
<p>It's pretty self-explanatory if we take a look at the interface definition:</p>
<div><img height="202" width="576" class=" image-border" src="img/fa04f5a6-c91e-46c7-844a-ad9e9c73504a.png"/></div>
<p>By the time the <kbd>Configure</kbd> method receives an instance of the <kbd>IApplicationBuilder</kbd> class, a bunch of extra functionality is available. As mentioned previously, it has been made available via extension methods, adopting the form of <kbd>Use*</kbd>, <kbd>Run*</kbd>, and <kbd>Map*</kbd> methods, which help the programmer in coding configuration aspects and obtaining more independence and granularity.</p>
<p>Notice how the following screenshot shows different configuration options and suggests the use of middleware:</p>
<div><img height="207" width="560" class=" image-border" src="img/6e14830b-65c3-4608-afee-98d832519948.png"/></div>
<p>Each of these extension methods supplies a way to call the implied delegate. Notice that while the <kbd>Use*</kbd> family of methods calls <kbd>Next()</kbd> implicitly many times to keep on going in the pipeline (actually it depends on other features), the <kbd>Run*</kbd> family stops the propagation and short-circuits the pipeline (therefore, it doesn't call a next request delegate).</p>
<p>Also, the <kbd>Map*</kbd> family allows branching the pipeline, making calls that return to that point and extending functionality accordingly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The New ASP.NET servers</h1>
                
            
            
                
<p>Let's quickly review some important aspects of the servers used when programming for ASP.NET Core since that is one of the main changes linked to this new platform.</p>
<p>First of all, an ASP.NET Core application runs an in-process HTTP server implementation. That implementation is listening for HTTP requests and sends those requests to the application wrapped in an object named <kbd>HttpContext</kbd> that holds a set of features composed into it.</p>
<p>This version of ASP.NET provides two distinct server implementations: <kbd>Kestrel</kbd> and <kbd>WebListener</kbd>. As the official documentation reminds us:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Kestrel</h1>
                
            
            
                
<p><kbd>Kestrel</kbd> is a cross-platform HTTP server based on <kbd>libuv</kbd>, a cross-platform asynchronous I/O library:</p>
<p><kbd>libuv</kbd> is defined as a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js, but it's also used by Luvit, Julia, pyuv, and others.</p>
<p>Kestrel is the web server included by default in the ASP.NET Project templates. The advantage is that if your application accepts requests exclusively from an internal network, it can be used by itself.</p>
<p>This is the working scheme of a default scenario with Kestrel:</p>
<div><img height="103" width="389" src="img/eda9b927-3790-45fd-b410-dad0faef0c7a.png"/></div>
<p>(Image courtesy: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</a>)</p>
<p>However, if you expose the application to the internet, there are some security issues for which Kestrel is not prepared to cope (it's relatively new and still doesn't have the whole required set of defense resources). For those cases, the recommended configuration is to use a reverse proxy server, such as IIS, Apache, or Nginx, to provide functionality.</p>
<p>Notice that a reverse proxy server, as the documentation states, <em>receives HTTP requests from the Internet and forwards them to Kestrel after some preliminary handling</em> (see the following screenshot):</p>
<div><img height="93" width="548" src="img/bcbed41a-719b-4b2f-a69e-ef755a25a391.png"/></div>
<p>(Image courtesy: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</a>)</p>
<p>Another important point is that you can't use any of those reverse proxy servers without Kestrel or a custom server implementation. This is because ASP.NET Core was designed to run in its own process so it can behave consistently across platforms.</p>
<p>The problem that we might face here is that IIS, Nginx, and Apache prescribe their own startup process and environment. The consequence is that to use them directly it should adapt to the requirements of each one.</p>
<p>In this way, Kestrel gives ASP.NET Core the ability to code <kbd>Program</kbd> and <kbd>Startup</kbd> classes in any required form to suit the user's needs, while avoiding another dependency on a concrete, specific server. That's one of the reasons why middleware is so important in this context.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WebListener</h1>
                
            
            
                
<p><kbd>WebListener</kbd> is a Windows-only HTTP server based on the <kbd>Http.Sys</kbd> kernel driver. It serves as an alternative for those scenarios where exposing our app to the internet is mandatory, but we don't wish to use IIS if we cannot do it for some reason.</p>
<p>The following schema represents the role of WebListener in a similar scenario as the one presented previously with Kestrel:</p>
<div><img height="100" width="382" src="img/c4bb5714-625b-4f2c-ad9f-25e870db28dd.png"/></div>
<p>(Image courtesy: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</a>)</p>
<p>In the same way, if you need some of the features that Kestrel doesn't support while working on an internal network, you could use WebListener in a quite comparable configuration:</p>
<div><img height="99" width="378" src="img/7796eaba-9226-486a-822e-513f4c0a8157.png"/></div>
<p>(Image courtesy: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</a>)</p>
<p>Finally, keep in mind that for internal network scenarios, Kestrel is recommended because it provides improved performance. In any case, if you want to know more about the features provided by WebListener, the official documentation is available at <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency Inversion in the architecture - OWIN</h1>
                
            
            
                
<p>It's also possible to create your own server implementation to work with ASP.NET Core. <strong>Open Web Interface for .NET</strong> (<strong>OWIN</strong>) is the third possible implementation supported by the platform.</p>
<p>In some ways, the implementation of OWIN also relates to the Dependency Inversion Principle. Its main goal is to make web applications decoupled from web servers.</p>
<p>With that purpose, it defines standard ways to create middleware that can be used in the pipeline, to configure and tune your server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Analyzing the default template</h1>
                
            
            
                
<p>Now it's time to open Visual Studio 2017 (or 2015, with ASP.NET Core installed) and take a look at it and explain how the default templates behave.</p>
<p>Remember that ASP.NET Core can execute using the classical.NET Framework as well, so, when you create a new Web project you'll be asked, initially, to choose between three main options: classical ASP.NET, ASP.NET Core with NET Core, and ASP.NET Core with classical .NET Framework:</p>
<div><img class=" image-border" src="img/d5a62e2e-b436-405f-b72b-1ded0e64ec91.png"/></div>
<p>Once selected, you'll be offered another choice window: Empty, Web API, Web Application, Web Application (Model-View-Controller), and some new options added to version 2.0 for third-party libraries, which include Angular, React.js, and React.js and Redux.</p>
<p>In the first case, the one we're using now creates an application with the minimum configuration to be able to create and run a web server using Kestrel and present some text in the browser. It's simple, but it allows us to check out how it is done with more detail and to make some changes.</p>
<p>The other three (Web API, Web Application, and Web App MVC) remind their counterpart in classic ASP.NET, with the difference that they use the new architecture and configuration files. In this manner, we'll be able to better appreciate the migration process needed to pass from the old architecture to the new one.</p>
<p>You should see the following dialog box:</p>
<div><img height="376" width="577" class=" image-border" src="img/ed226be6-21c8-4aae-b66f-e4f0e56055a2.png"/></div>
<p>Notice that you can also change authentication as in previous versions and that you have a checkbox that allows enabling Docker support.</p>
<p>The resulting project is a bit more complex than the basic demo we did previously, although the basic pieces are the same. However, there are some noticeable changes in configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration files</h1>
                
            
            
                
<p>Once you compile the application and activate the See all files option in the Solution Explorer, you'll notice some extra configuration files that take care of a few tasks, such as launching the browser on the default URL. These options are defined inside the <kbd>launchSettings.json</kbd> file available inside the <kbd>Properties</kbd> directory.</p>
<p>A look at it is also quite explanatory:</p>
<pre>    { 
      "iisSettings": { 
        "windowsAuthentication": false, 
        "anonymousAuthentication": true, 
        "iisExpress": { 
          "applicationUrl": "http://localhost:57539/", 
          "sslPort": 0 
        } 
      }, 
      "profiles": { 
        "IIS Express": { 
          "commandName": "IISExpress", 
          "launchBrowser": true, 
          "environmentVariables": { 
            "ASPNETCORE_ENVIRONMENT": "Development" 
          } 
        }, 
        "ASPNETCoreDemo1": { 
          "commandName": "Project", 
          "launchBrowser": true, 
          "environmentVariables": { 
           "ASPNETCORE_ENVIRONMENT": "Development" 
          }, 
          "applicationUrl": "http://localhost:57540" 
        } 
      } </pre>
<p>As you see, three main areas of configuration apply here: <kbd>iisSettings</kbd>, to indicate IIS behavior, including the URL to use, a <kbd>profiles</kbd> section that only contains one profile for <kbd>IISExpress</kbd>, indicating that a browser should be launched and a hint on the development mode, and a final one under the name of the application itself (<kbd>ASPNETCoreDemo1</kbd>), with similar information.</p>
<p>Of course, if you dig into the <kbd>\bin</kbd> or <kbd>\obj</kbd> directories, you'll see some more, such as <kbd>ASPNETCoreDemo1.runtimeconfig.json</kbd> with extra information. And, finally, if you examine the .<kbd>csproj</kbd> you'll see some additions as well:</p>
<p>Remember that on the project's context menu option at the Solution Explorer you now have an option that allows you to open it directly in Visual Studio 2017.</p>
<pre>     &lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt; 
     &lt;PropertyGroup&gt; 
      &lt;TargetFramework&gt;netcoreapp1.1&lt;/TargetFramework&gt; 
     &lt;/PropertyGroup&gt; 
 
     &lt;ItemGroup&gt; 
      &lt;Folder Include="wwwroot\" /&gt; 
    &lt;/ItemGroup&gt; 
    &lt;ItemGroup&gt; 
      &lt;PackageReference Include= "Microsoft.ApplicationInsights.AspNetCore" <br/>           Version="2.0.0" /&gt; 
      &lt;PackageReference Include="Microsoft.AspNetCore" Version="1.1.1" /&gt; 
    &lt;/ItemGroup&gt; 
    &lt;/Project&gt; </pre>
<p>Not many changes, but now it indicates the use of the <kbd>wwwroot</kbd> folder and it adds the <kbd>ApplicationInsights</kbd> call. And, obviously, there's no indication of filetype, since, by default, the compiled assembly is a DLL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Entry Point</h1>
                
            
            
                
<p>Let's start with <kbd>program.cs</kbd>. Its <kbd>main()</kbd> method is similar, but it contains new middleware:</p>
<pre>    public static void Main(string[] args)<br/>    {<br/>      var host = new WebHostBuilder()<br/>      .UseKestrel()<br/>      .UseContentRoot(Directory.GetCurrentDirectory())<br/>      .UseIISIntegration()<br/>      .UseStartup&lt;Startup&gt;()<br/>      .UseApplicationInsights()<br/>      .Build();<br/>      host.Run();<br/>    }</pre>
<p>The three main differences are: <kbd>UseContentRoot()</kbd>, <kbd>UseIISIntegration()</kbd>, and <kbd>UseApplicationInsights()</kbd>.</p>
<p><kbd>UseContentRoot(Directory.GetCurrentDirectory())</kbd>, indicates that whenever the user requests a physical resource, that's the directory to search in. By default, it's going to point to the <kbd>wwwroot</kbd> directory.</p>
<p><kbd>UseIISIntegration()</kbd> is there to indicate that IIS will be used as a reverse proxy (as we mentioned previously), and finally, <kbd>UseApplicationInsights()</kbd> helps monitor and audit your application.</p>
<p>As the official documentation states (<a href="https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core">https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core</a>) it allows us to <em>Monitor your live ASP.NET Core applications with Visual Studio Application Insights. Application Insights is an extensible analytics platform that monitors the performance and usage of your live web applications. With the feedback you get about the performance and effectiveness of your app in the wild, you can make informed choices about the direction of the design in each development lifecycle.</em></p>
<p>So, we have an entry point reinforced with new middleware, and thus, we can use DI from the start. Let's see what it's done in the <kbd>Startup</kbd> class (the configuration).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The default Startup class</h1>
                
            
            
                
<p>The first point to notice is the presence of <kbd>ConfigureServices</kbd> (even if it's empty). As you can see in the following screenshot, it allows adding distinct services to our pipeline, storing them in the <kbd>services</kbd> collection. This will be the place to register our own services as well.</p>
<p>Also notice that some of these methods are ready to add services with distinct lifetime configuration (<kbd>AddSingleton</kbd>, <kbd>AddScoped</kbd>, and <kbd>AddTransient</kbd>). Later, we'll see how to add services at this point to allow applications to use a given functionality, such as Database Access, and so on, using this <kbd>IServiceCollection</kbd> object that it received through Dependency Injection (see the following screenshot):</p>
<div><img height="250" width="618" class=" image-border" src="img/0d92032f-eea0-49fc-804b-c8bf0531f737.png"/></div>
<p>As for the <kbd>Configure()</kbd> method, this time it receives (via Dependency Injection, of course), three instances of types <kbd>IApplicationBuilder</kbd>, <kbd>IHostingEnvironment</kbd>, and <kbd>ILoggerFactory</kbd> as the following code shows:</p>
<pre>    // This method gets called by the runtime. Use this method to //<br/>    // configure the HTTP request pipeline. 
    public void Configure(IApplicationBuilder app, <br/>       IHostingEnvironment env, ILoggerFactory loggerFactory) 
    { 
      loggerFactory.AddConsole(); 
 
      if (env.IsDevelopment()) 
      { 
        app.UseDeveloperExceptionPage(); 
      } 
 
      app.Run(async (context) =&gt; 
      { 
        await context.Response.WriteAsync("Hello World!"); 
      }); 
    } </pre>
<p>The first one is used at the end to launch the application, only this time using the <kbd>async/await</kbd> structure to guarantee a formal asynchronous call, returning a string.</p>
<p><kbd>ILoggerFactory</kbd> is used in a similar manner as we did in <a href="" target="_blank">Chapter 3</a>, <em>Introducing Dependency Injection in .NET Core 2.0</em>, to configure messages that will be output to the console.</p>
<p>Finally, the <kbd>IHostingEnvironment</kbd> variable is used to check if the application is in development mode, and, in that case, to configure a developer exception page, which we can define elsewhere.</p>
<p>ASP.NET Core distinguishes four possible development modes: <kbd>development</kbd>, <kbd>production</kbd>, <kbd>staging</kbd>, and a fourth one <kbd>environment</kbd> that allows defining your own. That value is configurable inside the <kbd>Project/Properties/Debug</kbd> window, where you can now add distinct environment variables, as you can see in the following screenshot:</p>
<div><img height="325" width="535" class=" image-border" src="img/67749781-f661-4470-910e-e6817c4b0d8c.png"/></div>
<p>These values are read by the <kbd>IHostingEnvironment</kbd> object allowing the insertion of actions prior to the application launching process. Notice it's not a single value, but a collection, so you can add as many environment values as needed and use this object's methods to read whether some of them are true.</p>
<p>You could also use something like <kbd>ASPNETCORE_ENVIRONMENT"="MyCompany</kbd> to define your own and check this value easily, using the <kbd>IsEnvironment()</kbd> method, as you can see in the following screenshot:</p>
<div><img height="183" width="568" class=" image-border" src="img/f9d6845f-e431-40aa-b5e7-8af821d6c4da.png"/></div>
<p>So, if we change the previous <kbd>development</kbd> value for a customized one, such as <kbd>PACKT</kbd>, we can modify the exit in the browser with the following:</p>
<pre>    app.Run(async (context) =&gt; 
    { 
       if (env.IsEnvironment("Packt")) 
       { 
        await context.Response.WriteAsync("We're in PACKT <br/>             development mode!"); 
       } 
       else await context.Response.WriteAsync("Hello World!"); 
    }); </pre>
<p>The output will be different in this case, so we're free to configure anything and mix it with other values to have a totally customized, mode-dependent, experience:</p>
<div><img height="134" width="406" class=" image-border" src="img/029c6027-b9b3-4666-aeb9-0b9ebc5ec85e.png"/></div>
<p>But, there's much more in relation to DI, as we're going to see in the next sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency Injection in ASP.NET Core</h1>
                
            
            
                
<p>Of course, this behavior is possible thanks to the presence of a DI Container inside the ASP.NET Core engine. The official documentation states it very clearly: <em>if a given type has declared that it has dependencies, and the container has been configured to provide the dependency types, it will create the dependencies as part of creating the requested instance</em>.</p>
<p>The container, in this way, manages an object's lifetime and avoids the need for hard-coded object construction.</p>
<p>Besides other built-in implementations, remember that ASP.NET Core provides a simple DI Container (that we already tested in <a href="" target="_blank">Chapter 3</a>, <em>Introducing Dependency Injection in .Net Core 2.0</em>), represented by the <kbd>IServiceProvider</kbd> interface.</p>
<p>As we mentioned, the place to configure services using that interface in this platform is the <kbd>ConfigureServices</kbd> method, which we will analyze in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Services provided by ASP.NET Core</h1>
                
            
            
                
<p>There's quite a large list of services available inside ASP.NET Core via Dependency Injection. The following table shows these services together with an indication of its lifetime:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Service Type</strong></td>
<td><strong>Lifetime</strong></td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Hosting.IHostingEnvironment</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.Extensions.Logging.ILoggerFactory</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.Extensions.Logging.ILogger&lt;T&gt;</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</kbd></td>
<td>Transient</td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Http.IHttpContextFactory</kbd></td>
<td>Transient</td>
</tr>
<tr>
<td><kbd>Microsoft.Extensions.Options.IOptions&lt;T&gt;</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>System.Diagnostics.DiagnosticSource</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>System.Diagnostics.DiagnosticListener</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Hosting.IStartupFilter</kbd></td>
<td>Transient</td>
</tr>
<tr>
<td><kbd>Microsoft.Extensions.ObjectPool.ObjectPoolProvider</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.Extensions.Options.IConfigureOptions&lt;T&gt;</kbd></td>
<td>Transient</td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Hosting.Server.IServer</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Hosting.IStartup</kbd></td>
<td>Singleton</td>
</tr>
<tr>
<td><kbd>Microsoft.AspNetCore.Hosting.IApplicationLifetime</kbd></td>
<td>Singleton</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As you see, this is a pretty comprehensive list of choices, to which we have to add the functionality already available and "installable" via <kbd>Run*</kbd>, <kbd>Use*</kbd>, and <kbd>Map*</kbd> methods commented on previously.</p>
<p>So, we can distinguish two flavors of method, here: those already available and ready to include at will (the ones shown in <kbd>Program/Main</kbd>), and those that you can customize (using the <kbd>Startup</kbd> class), either by addition or by creating your own classes and interfaces and adding them to the <kbd>ConfigureServices</kbd> initial process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The relation of services available at startup</h1>
                
            
            
                
<p>In summary, we have several ways to include functionality via Dependency Injection in ASP.NET Core 2.0, via the Startup class:</p>
<ul>
<li>By creating your own constructor for the Startup class, which refers to a previously define map Interface =&gt; Class</li>
<li>By referring to the service required in the <kbd>ConfigureServices</kbd> method</li>
<li>By using the <kbd>Configure()</kbd> method in the ways we've seen</li>
</ul>
<p>If you consider the methods of <kbd>Startup</kbd> in the order they are executed, the following services are at your disposal:</p>
<ul>
<li>Constructor: <kbd>IHostingEnvironment</kbd>, <kbd>ILoggerFactory</kbd></li>
<li><kbd>* ConfigureServices</kbd>: <kbd>IServiceCollection</kbd></li>
<li>Configure: <kbd>IApplicationBuilder</kbd>, <kbd>IHostingEnvironment</kbd>, <kbd>ILoggerFactory</kbd>, <kbd>IApplicationLifetime</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying Services in the Web Application template</h1>
                
            
            
                
<p>The Web Application template is much more revealing regarding the use of services and the role of Dependency Injection, so we're going to create a project equivalent to the classic ASP.NET MVC 5 available for a classic .NET Framework so we can compare both, identifying this functionality.</p>
<p>Once you create one of these new projects, you'll probably identify many of the elements that were present in the previous version: folders for controllers and views, Razor files defining the distinct views in the application, and so on.</p>
<p>But, now that we've seen some of the main changes, a review of the critical files is quite enlightening. There are no changes in <kbd>Program/Main</kbd>, but we'll find a lot in the <kbd>Startup</kbd> class. The references (<kbd>using</kbd> statements) are the same as in the basic demo, so I'm omitting the code here.</p>
<p>The most interesting come inside the <kbd>Startup</kbd> class itself:</p>
<pre>    public class Startup 
    { 
      public Startup(IHostingEnvironment env) 
      { 
        var builder = new ConfigurationBuilder() 
            .SetBasePath(env.ContentRootPath) 
            .AddJsonFile("appsettings.json", optional: false,  
                         reloadOnChange: true) 
          .AddJsonFile($"appsettings.{env.EnvironmentName}.json",  
                         optional: true) 
            .AddEnvironmentVariables(); 
        Configuration = builder.Build(); 
      }   
 
      public IConfigurationRoot Configuration { get; } 
 
      // This method gets called by the runtime. Use this method to  
      // add services to the container. 
      public void ConfigureServices(IServiceCollection services) 
      { 
        // Add framework services. 
        services.AddMvc(); 
      } </pre>
<p>Up to this point, the default template only initializes the MVC engine, considering it an extra service, totally optional to the user.</p>
<p>Further on, we'll see how to use this method to register and configure other built-in or customized services:</p>
<pre>    // This method gets called by the runtime. Use this method to  
    // configure  the HTTP request pipeline. 
    public void Configure(IApplicationBuilder app,  
        IHostingEnvironment env, ILoggerFactory loggerFactory) 
    { 
        loggerFactory.AddConsole(Configuration.GetSection("Logging")); 
        loggerFactory.AddDebug(); 
 
        if (env.IsDevelopment()) 
        { 
            app.UseDeveloperExceptionPage(); 
            app.UseBrowserLink(); 
        } 
        else 
        { 
            app.UseExceptionHandler("/Home/Error"); 
        } 
 
        app.UseStaticFiles(); 
 
        app.UseMvc(routes =&gt; 
        { 
            routes.MapRoute( name: "default", 
                template:{controller=Home}/{action=Index}/{id?}"); 
        }); 
     } </pre>
<p>First of all, we now have a constructor and a read-only private property (<kbd>Configuration</kbd>) of type <kbd>IConfigurationRoot</kbd>. Well, it happens that the <kbd>builder.Build()</kbd> method called at the end of the constructor, is of this type and provides a convenient way to include and access all configuration information loaded from several <kbd>.json</kbd> files in the distinct application's folders.</p>
<p>All that information is collected at the very beginning of the process of initialization, so whatever has to be read from the outside is ready before <kbd>ConfigureServices</kbd> and <kbd>Configure</kbd> come into play (see the following screenshot showing the value of <kbd>Configuration</kbd> after loading):</p>
<div><img height="350" width="652" class=" image-border" src="img/973d5311-1183-457c-ad0f-8d1af9f5db9f.png"/></div>
<p>As you see, the <kbd>ConfigurationBuilder</kbd> class is created in the first sentence of the constructor, and takes care of loading and reading the content of all these .<kbd>json</kbd> files, and adding environment variables. This allows further access to any <kbd>json</kbd>-defined value, and the ability to tune-up the application with external information.</p>
<p>With all that info collected, the <kbd>ConfigureServices</kbd> method comes and registers a set of services, such as MVC, by adding a <kbd>UseMvc</kbd> call (yes, it's not available by default, and has to be explicitly added to the pipeline if we want to use that architecture).</p>
<p>As you've seen along these samples, this ASP.NET middleware, such as MVC, follows a convention of using a single <kbd>Add<em>ServiceName</em></kbd> extension method to register all of the services required by that feature. Also, notice that this call only adds the service to the collection of services, but it does not configure it (that comes later).</p>
<p>Then, the <kbd>Configure()</kbd> method comes in. It first recovers information from the <kbd>Configuration</kbd> object (<kbd>Logging</kbd> section) and adds debugging capabilities in the way we saw in the previous chapter.</p>
<p>It follows with error handling, by checking if we are in development mode or another one (it also enables <kbd>BrowserLink</kbd> capabilities), and goes on with a call to <kbd>UseStaticFiles()</kbd>, to allow recovering and serving local files (you guessed it, it's not available by default, either).</p>
<p>Notice that this feature can be configured to point someplace else (relative request path) on the server (see the screenshot):</p>
<div><img height="94" width="564" class=" image-border" src="img/3c44a65c-ad4a-4160-8695-e06c9ca28e45.png"/></div>
<p>The last step is configuring MVC routes with a call to <kbd>UseMvc()</kbd>, in which the route's configuration is provided. Notice how different this approach is in comparison to classical ASP.NET MVC 4/5, in which you would register these routes in a different file. However, the syntax is similar, only this time you define it via lambda expressions.</p>
<p>As you can deduct from the code, the first lambda argument is given by Dependency Injection and it's of type <kbd>IRootBuilder</kbd>. Take a look at the Intellisense information provided by the IDE to check this feature, which is shown in the following screenshot:</p>
<div><img height="65" width="508" class=" image-border" src="img/af2577e7-c2ee-40f8-a2ee-8d4ffc87c0b9.png"/></div>
<p>The default route is then configured to point to the <kbd>HomeController</kbd> class and the <kbd>Index</kbd> action method if no other combination is supplied by the request (the syntax has also been a bit simplified).</p>
<p>So, our conclusion after this trip through the <kbd>Startup</kbd> class is that the most important architectural aspects of ASP.NET Core and its MVC variant are provided via Dependency Injection, and that it is the developer's duty to tune up their application in this manner having the ability to include/exclude only those pieces that are needed by the application, with the minimum overload.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Dependency Injection in ASP.NET MVC Views</h1>
                
            
            
                
<p>Steve Smith proposes a demo (<a href="http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app">http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app</a>) that can clarify the total of services available at a given moment.</p>
<p>This gave me an idea for another demo about how to include the namespace <kbd>Microsoft.Extensions.DependencyInjection</kbd> inside a view, using MVC to obtain a list of all services available. So let's start with the default template we just analyzed, and make the proper modifications.</p>
<p>First, if we want to integrate the list as a new option inside the main menu of the Web Application template, we need to add a new link inside the <kbd>_Layout.cshtml</kbd> file that points to the corresponding view that will show all our services. That's quite straightforward (notice that there's no <kbd>ActionLinks</kbd> here as in the previous version):</p>
<div><img height="106" width="612" class=" image-border" src="img/7e975755-6c3a-42ad-8fae-71d1dd60d6cf.png"/></div>
<p>With this new line, we're creating a new application menu element and the corresponding view (later named <kbd>ServicesAvailable</kbd>) will take advantage of Bootstrap classes loaded in the <kbd>_Layout.cshtml</kbd> header, to format the output and make it more readable.</p>
<p>Now, if we think about the controller (<kbd>HomeController</kbd> in this case), we can add a new action method, following the syntax of the other methods, using the <kbd>ViewData</kbd> object to pass the required information to our new view.</p>
<p>The information we need is stored in the instance of the <kbd>IServiceCollection</kbd> object defined inside <kbd>Startup.cs</kbd>, and we want to make it available for the controller so we can later assign it to our <kbd>ViewData</kbd> messenger.</p>
<p>Let's revisit the <kbd>Startup</kbd>, and make a few changes (not many). Actually, only these are required:</p>
<pre>    public static IServiceCollection _services { get; private set; } 
    public void ConfigureServices(IServiceCollection services) 
    { 
      // Add framework services. 
      services.AddMvc(); 
      _services = services; 
   } </pre>
<p>We create a public static variable (<kbd>_services</kbd>) to hold all services once they have been configured and assign the <kbd>services</kbd> variable to it with the sole purpose of accessing its content from the controller.</p>
<p>Now, back to the <kbd>HomeController</kbd>, we can add a new controller with this code:</p>
<pre>    public IActionResult ServicesAvailable() 
    { 
      ViewData["Services"] = Startup._services; 
      return View(); 
    } </pre>
<p>With these few lines, our services are now available inside the controller, and we can pass them to the view in a very simple way (notice there's no data model here since it's just a simple collection of data and the <kbd>ViewData</kbd> object serves just fine for this purpose).</p>
<p>Finally, the last step will be to add the <kbd>ServicesAvailable</kbd> view. The code will be the following (I'll start with the header's explanation):</p>
<pre>    @using Microsoft.Extensions.DependencyInjection; 
    @{ 
      ViewData["Title"] = "Services Available"; 
      var _services = @ViewData["Services"]; 
    } 
    &lt;h2&gt;@ViewData["Title"]&lt;/h2&gt; 
    &lt;h1&gt;All Services&lt;/h1&gt; </pre>
<p>First, recall that when we make a reference to a namespace inside a view, the <kbd>using</kbd> sentence shall not belong to a block of code. Instead, it will be a standalone sentence headed by the <kbd>@</kbd> sign (we need the <kbd>DependencyInjection</kbd> namespace to cast the information passed inside the <kbd>ViewData</kbd> object into a real <kbd>IServiceCollection</kbd> object).</p>
<p>Next, we recover that info inside a variable (that will be available locally in the whole view). Observe that I'm using the <kbd>var</kbd> keyword instead of the interface name because otherwise the compiler will complain. It's easier to do it this way and make the casting later in the code.</p>
<p>Finally, we'll use a table to present some information hold in three of the services of <kbd>IServiceCollection</kbd> (called <kbd>_services</kbd> in the view). Notice also the casting is made here with the <kbd>as</kbd> operator to get a real <kbd>IServiceCollection</kbd> object:</p>
<pre>    &lt;table class="table table-bordered"&gt; 
    &lt;thead&gt; 
        &lt;tr&gt; 
            &lt;th&gt;Type&lt;/th&gt; 
            &lt;th&gt;Lifetime&lt;/th&gt; 
            &lt;th&gt;Instance&lt;/th&gt; 
        &lt;/tr&gt; 
    &lt;/thead&gt; 
    &lt;tbody&gt; 
     @foreach (var svc in _services as IServiceCollection) 
     { 
       &lt;tr&gt; 
       &lt;td&gt;@svc.ServiceType.Name&lt;/td&gt;           <br/>        &lt;td&gt;@svc.Lifetime&lt;/td&gt;            <br/>        &lt;td&gt;@svc.ImplementationType?.Name&lt;/td&gt; 
        &lt;/tr&gt; 
     } 
    &lt;/tbody&gt; 
    &lt;/table&gt; </pre>
<p>And that's all! Now we can launch the application and select the new menu element <em>List of Services</em>. A new view will show up containing a, pretty long list of services available in this architecture, showing at the same time how we can make use of the <kbd>DependencyInjection</kbd> namespace (or any other) inside a view (see the following screenshot):</p>
<div><img height="479" width="630" class=" image-border" src="img/a075f92c-562f-47fe-8bcb-068821d7d668.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Garbage Collection and Custom Services</h1>
                
            
            
                
<p>In relation to Garbage Collection behavior, ASP.NET MVC automates some operations and leaves others to the user's discretion.</p>
<p>The main rule is as follows: if you register a service and call its constructor inside the process, it's your obligation to dispose of that object, otherwise if the container is in charge of creating the object, it will call <kbd>Dispose()</kbd> on any object it implements.</p>
<p>In practice, imagine we have a couple of services (<kbd>Service1</kbd> and <kbd>Service2</kbd>) located in a folder (<kbd>Services</kbd>), and that both implement the <kbd>Disposable</kbd> interface. To simplify this part, I collapsed the code, so I'm just showing the relevant lines to understand this idea (see the following screenshot):</p>
<div><img height="160" width="295" class=" image-border" src="img/1359a310-8963-41da-ae98-a8389a0eb133.png"/></div>
<p>The behavior will be different depending on the instantiation of each service (I've commented on each case so you'll see the difference):</p>
<pre>    publicvoidConfigureServices<strong>(</strong><strong>IServiceCollection</strong>services<strong>)<br/></strong><strong>    {<br/></strong>     // Add framework services<br/>     services<strong>.</strong>AddMvc<strong>();<br/></strong>     // container will create the instance(s) of these types<br/>     // and will dispose themservices<br/>     AddScoped<strong>&lt;</strong><strong>Service1</strong><strong>&gt;();<br/></strong>     // Here, the container did not create instance (we do it)<br/>     // so it will NOT dispose itservices<br/>     AddSingleton<strong>(</strong>new<strong>Service2</strong><strong>());<br/></strong><strong>    }</strong></pre>
<p>In all, it is a pretty convenient way to manage garbage collection of services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Custom Services through Dependency Injection</h1>
                
            
            
                
<p>With this architecture, it is very easy to create any class belonging to our data model, or any other part of the application, and have it ready and available for Dependency Injection, with all the advantages linked to it.</p>
<p>For example, imagine that we want some adornment in one of our views in the form of a random sentence (about programmers and software engineers, for instance), and that we would like the classes that hold the information to be treated as a service, via Dependency Injection, so we can use that content in distinct application's views.</p>
<p>We can rename the classes used in the previous sample as <kbd>ProgrammerSentenceSvc</kbd> and <kbd>EngineerSentenceSvc</kbd> and add some very simple information: a <kbd>List&lt;string&gt;</kbd> of sentences that will be used later inside our controller to randomly retrieve a couple of these sentences and pass them to the corresponding view.</p>
<p>So let's modify our services to hold the required information (I'm just showing these captures, to focus on the relevant code):</p>
<div><img height="198" width="446" class=" image-border" src="img/a6432441-aa7a-425b-ab22-2004c42d6e48.png"/></div>
<div><img height="213" width="442" class=" image-border" src="img/0fbe71e2-7b9f-4116-bf79-1334804b7ca8.png"/></div>
<p>The next step will be to register these classes in the <kbd>Startup</kbd> class via <kbd>ConfigureServices</kbd>, as we've seen before (I'm using two distinct syntaxes just to show):</p>
<pre>    publicvoidConfigureServices<strong>(</strong><strong>IServiceCollection</strong>services<strong>)<br/></strong><strong>   {<br/></strong>    // Add framework services.<br/>    services<strong>.</strong>AddMvc<strong>();<br/></strong>    // container will create the instance(s) of these types<br/>    // and will dispose them<br/>    services<strong>.</strong>AddScoped<strong>&lt;</strong><strong>ProgrammerSentenceSvc</strong><strong>&gt;();<br/></strong>    // Here, the container did not create instance (we do it)<br/>    // so it will NOT dispose it<br/>    services<strong>.</strong>AddSingleton<strong>(</strong>new<strong>EngineerSentenceSvc</strong><strong>());<br/></strong><strong>  }</strong></pre>
<p>That's all we need to have our services available inside any controller. So, let's revisit our <kbd>HomeController</kbd>, and add the following action method (remember that we have to make a reference to our Services namespace, via <kbd>using ASPNETCoreDisposeDemo.Services;</kbd>):</p>
<pre>    publicIActionResultSentences(ProgrammerSentenceSvcsvc,<br/>        EngineerSentenceSvcsvc2<br/>     {<br/>      Randomrnd = newRandom();ViewData["ProgSentence"] = <br/>          svc.programmersSentences[rnd.Next(1,5)];<br/>      ViewData["EngSentence"] = svc2.engineersSentences[rnd.Next(1,5)];<br/>      returnView();<br/>     }</pre>
<p>And that's it! Any service registered in that manner is automatically available inside a controller via Dependency Injection, merely by making a reference to it as a parameter of the corresponding action method.</p>
<p>The last step is to create the view named <kbd>Sentences</kbd> to recover the information and present it to the user:</p>
<pre>    @{ViewData["Title"] = "Random sentences about programmers<br/>       and engineers";<br/>    }<br/>     &lt;h1&gt;@ViewData["Title"].&lt;/h1&gt;<br/>     &lt; hr /&gt;<br/>     &lt; h1 &gt; Programmer's Sentence &lt;/ h1 &gt;<br/>     &lt;h2&gt;@ViewData["ProgSentence"]&lt;/h2&gt;<br/>     &lt; h1 &gt; Engineers' Sentence &lt;/ h1 &gt;<br/>     &lt;h2&gt;@ViewData["EngSentence"]&lt;/h2&gt;</pre>
<p>If we have added (just like before), a new link next to the default menu pointing to the name of this action method, we'll see the following output:</p>
<div><img height="409" width="541" class=" image-border" src="img/995a1979-bb06-4548-8fc9-ea56097b31b8.png"/></div>
<p>As you see, the output is the expected one, and the general architecture of the application with respect to the MVC model is quite similar to previous versions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Services and data management</h1>
                
            
            
                
<p>Although data management is not the target of this book, I'd like to mention that the architecture proposed when accessing data inside ASP.NET Core MVC applications is relatively alike.</p>
<p>To test this feature and highlight those parts directly related to Dependency Injection, follow the initial instructions at <a href="https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db">https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db</a>. That creates a very simple database using SQLLocalDb called <kbd>Blogging</kbd>. It creates a <kbd>Blogs</kbd> table and adds three registers, just to have some data to work with. You'll also find a link to the complete sample it proposes using several approaches: Database First, New Database, and so on.</p>
<p>What I would like to point out here is those fragments of code that imply the use of DI inside that solution.</p>
<p>In the <kbd>Models'</kbd> application folder you'll find the definition of the model based on that database in a similar way to the usual result when you scaffold an existing database using classic Entity Framework. The main class inherits from <kbd>DbContext</kbd>, defines public virtual properties pointing to the existing entities, and names the <kbd>DBContext</kbd> instance <kbd>BloggingContext</kbd>.</p>
<p>Consequently, the first step is to register that context inside the <kbd>ConfigureServices</kbd> method, for which it does the following:</p>
<div><img height="111" width="595" src="img/58d934a3-79f8-442f-9b63-1cfd15f74918.png"/></div>
<p>As you see, the connection string is defined directly so that it points to the newly created database (<kbd>Blogging</kbd>).</p>
<p>Next, the services variable is populated with a new entry via the generic method <kbd>AddDbContext&lt;BlogginContext&gt;.</kbd> And, to link that <kbd>DbContext</kbd> to the <kbd>Blogging</kbd> database and <kbd>Action</kbd> delegate is passed to the method, allowing it to override the <kbd>OnConfiguring</kbd> method of the <kbd>BloggingContext</kbd> class. In this manner, the real connection configuration can be delayed until this method is called.</p>
<p>Finally, how does the <kbd>BloggingController</kbd> class access this <kbd>BloggingContext</kbd>? By Dependency Injection in its constructor. It operates in a similar way to what we did in the previous sample:</p>
<div><img height="139" width="357" src="img/f9857b83-0a7e-46c5-a34b-3f7a5a705364.png"/></div>
<p>The output shows the three entries loaded in the <kbd>Blogs</kbd> table, just as expected, with the typical CRUD options, presenting the information via Razor views, but it's interesting to highlight the role of DI in this architecture as well (see the following screenshot):</p>
<div><img height="304" width="514" src="img/ff666b1a-21c5-4c90-96f0-f0ef01760a83.png"/></div>
<p>Again, you've seen how DI is also present in .NET Core-related platforms, such as Entity Framework Core.</p>
<p>However, there's an interesting point we haven't covered yet. We saw how to make a reference to the <kbd>DependencyInjection Namespace</kbd> inside a view, but we were not really using DI. Let's see how to use the new <kbd>@inject</kbd> directive inside a view with a simple demo.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Dependency Injection inside Views</h1>
                
            
            
                
<p>For completeness, I'm going to explain a simple demo of how to use DI inside a Razor view. It's a quite interesting feature and it can be useful to access data, service-related information, or even your own Razor helpers.</p>
<p>The idea is to create another view that is able to access the same data as our previous <kbd>Services</kbd> View, but this time without implying the controller in the business logic. Besides that, I'll create a Razor helper just to show how we can do both tasks thanks to the <kbd>@inject</kbd> directive.</p>
<p>First, inside a new folder (<kbd>Helpers</kbd>), let's create a simple helper that provides some kind of information (for instance the current system's time):</p>
<pre>    namespaceASPNETCoreDisposeDemo.Helpers{<br/>      publicclassDateTimeHelpers<br/>      {<br/>        publicDateTimeHelpers()<br/>        {<br/>          LocalTime = DateTime.Now.TimeOfDay.ToString();<br/>        }<br/>          publicstringLocalTime { get; privateset; }<br/>      }<br/>    }</pre>
<p>With this new service in place, we need to register it as we did with the <kbd>Sentences*</kbd> services. The new version of the <kbd>ConfigureServices</kbd> method will look as follows:</p>
<pre>    publicvoidConfigureServices(IServiceCollectionservices)<br/>    {<br/>      // Add framework services.<br/>      services.AddMvc();<br/>      // container will create the instance(s) of these types<br/>      // and will dispose them<br/>      services.AddScoped&lt;ProgrammerSentenceSvc&gt;();<br/>      // Here, the container did not create instance (we do it)<br/>      // so it will NOT dispose it<br/>      services.AddSingleton(newEngineerSentenceSvc());<br/>      services.AddTransient&lt;DateTimeHelpers&gt;();<br/>    }</pre>
<p>This is all we need on the business logic side since we can use the existing services, only in a different way. So, I'll create another action method as part of the <kbd>HomeController</kbd> named <kbd>ServicesDI</kbd>, and try to replicate the previous functionality.</p>
<p>We can also use the <kbd>[Route("key")]</kbd> attribute to redirect URL queries to this action method. Actually, it's even simpler than the others:</p>
<pre>    [Route("SentencesDI")]publicIActionResultSentencesDI()<br/>    {<br/>       returnView();<br/>    }</pre>
<p>The rest of the programming logic is deferred to the view itself. Thus, the <kbd>SentencesDI</kbd> View will have to reference the namespaces related to the services it is going to use, and declare any service required:</p>
<pre>    @usingASPNETCoreDisposeDemo.Helpers<br/>    @usingASPNETCoreDisposeDemo.Services<br/>    @inject DateTimeHelpersTimeHelpers<br/>    @inject ProgrammerSentenceSvcPSentences<br/>    @inject EngineerSentenceSvcESentences<br/>    @{<br/>      Randomrnd = newRandom();<br/>       ViewData["Title"] = "Random sentences obtained via<br/>            Dependency Injection";<br/>     }<br/>     &lt;h1&gt;@ViewData["Title"]&lt;/h1&gt;<br/>     &lt;h3&gt;Local Time: @TimeHelpers.LocalTime&lt;/h3&gt;<br/>     &lt; hr /&gt;<br/>     &lt; h2 &gt; Programmer's Sentences (DI) &lt;/ h2 &gt;<br/>     &lt;h3&gt;@PSentences.programmersSentences[rnd.Next(1,5)]&lt;/h3&gt;<br/>     &lt; h2 &gt; Engineers' Sentences (DI) &lt;/ h2 &gt;<br/>     &lt;h3&gt;@ESentences.engineersSentences[rnd.Next(1,5)]&lt;/h3&gt;</pre>
<p>As you can see, the rest of the code is pretty self-explanatory. Once services are registered and references made, we can use the <kbd>@inject</kbd> directive to instruct the DI container about the resources that our view is going to need. The syntax is:</p>
<pre>    @inject [Type] [Name/Alias]  </pre>
<p>In this way, any functionality related to a service that is injected in a view can access the data inside the service without having to process it in the controller. You might say that this breaks in some way the architecture of the MVC foundations, but there are some circumstances in which it might be interesting to separate certain data from the controller if it is only related to a particular view.</p>
<p>And, surely, you'll find more useful possibilities. By the way, you can type <kbd>localhost:[port]/ServicesDI</kbd> in the browser to get the corresponding output:</p>
<div><img height="373" width="505" src="img/f711fe22-b931-4bf8-a799-3ee618634c7c.png"/></div>
<p>In short, another feature related to Dependency Injection, this time inside the Razor views, that we can use inside the ASP.NET Core platform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we focused on ASP.NET Core and Dependency Injection, analyzing how the whole architecture and configuration process is based on the internal DI Container of ASP.NET Core.</p>
<p>We also saw how to move from a simple Console app to an ASP.NET Core app, and finally, how the distinct servers for development and production can be tuned up.</p>
<p>Then, we analyzed the main templates offered by Visual Studio 2017 in relation to ASP.NET Core apps and reviewed how they used DI in order to configure and manage the required information and functionality.</p>
<p>Finally, we saw how to use our own custom services and integrate them inside ASP.NET Core using DI, either in the controllers or in the Razor Views.</p>
<p>In <a href="c2b6c427-7a04-43d9-93bf-076daeb0f024.xhtml" target="_blank">Chapter 5</a>, <em>Object Composition</em>, we will analyze Object Composition and its use within DI contexts.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>