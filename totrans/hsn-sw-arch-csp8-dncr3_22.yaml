- en: Deploying Your Application with Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on so-called **service design thinking**, that is, keeping
    in mind the software you are designing as a service offered to an organization/part
    of an organization. The main takeaway of this approach is that the highest priority
    is the value your software gives to the target organization. Moreover, you are
    not offering just working code and an agreement to fix bugs, but a solution for
    all of the needs that your software was conceived for. In other words, your job
    includes everything it needs to satisfy those needs, such as monitoring users'
    satisfaction and adapting the software when the user needs change.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is easier to monitor the software to reveal issues and new needs
    and to modify it to adapt it quickly to ever-changing needs.
  prefs: []
  type: TYPE_NORMAL
- en: Service design thinking is strictly tied to the **Software as a Service** (**SaaS**)
    model, which we discussed in [Chapter 4](049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml),
    *Deciding the Best Cloud-Based Solution*. In fact, the simplest way to offer solutions
    based on web services is to offer the usage of web services as a service instead
    of selling the software that implements them.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, this chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SaaS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a solution for a service scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – deploying our package-management application with Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to design software according to
    service design thinking principles and use Azure Pipelines to deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2017 or 2019 free Community Edition or better
    with all database tools installed. It requires a free Azure account. If you have
    not already created one, the *Creating an Azure account* subsection of [Chapter
    1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the Importance
    of Software Architecture*, explains how to do so. This chapter uses the same code
    as [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing Your Code
    with Unit Test Cases and TDD*, which is available here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selling/using software as a service is connected with a wider set of solutions
    design principles called service design thinking. Service design thinking is not
    just a software development technique and/or a software deployment approach, but
    it impacts several business areas, namely, organization and human resources, software
    development processes, and finally, hardware infrastructures and software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsections that follow, we will briefly discuss the implications for
    each of the business areas we listed, and in the last subsection, we will focus
    specifically on the SaaS deployment model.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting your organization to a service scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first organizational implication comes from the need to optimize the value
    of the software for the target organization. This requires a human resource or
    a team—in charge of planning and monitoring the impact of the software in the
    target organization—to maximize the value added by the software. This strategic
    role is not needed just during the initial design stage but during the whole lifetime
    of the application. In fact, this role is in charge of keeping the software fine-tuned
    with the ever-changing needs of the target organization.
  prefs: []
  type: TYPE_NORMAL
- en: Another important area of impact is **human resource management**. In fact,
    since the main priority is the value added by the software and not exploiting
    existing resources and competences, human resources must be adapted to the project
    needs. This means acquiring new resources as soon as they are needed and developing
    the required competencies through new human resources and/or adequate training
    of existing resources.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection deals with the implications of all processes involved in
    software development.
  prefs: []
  type: TYPE_NORMAL
- en: Developing software in a service scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main constraint that impacts software development processes is the need
    to keep the software fine-tuned with the organization's needs. This need can be
    satisfied by any agile methodology based on a CI/CD approach. For a short review
    of CI/CD, please refer to the *Organizing your work using Azure DevOps* section
    of [Chapter 3](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml), *Documenting Requirements
    with Azure DevOps*, while for a detailed discussion of CI/CD, please refer to
    [Chapter 17](b444cf5c-311d-4f74-80b0-0e86c0c13307.xhtml), *Deploying Your Application
    with Azure DevOps,* which is completely dedicated to CI/CD. It is worth pointing
    out that any well-designed CI/CD cycle should include the processing of user feedback
    and user satisfaction reports.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, to optimize the value added by the software, it is a good practice
    to organize stages where the development team (or part of it) is placed in close
    contact with the system users so that developers can better understand the impact
    of the software on the target organization.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the value added by the software must always be kept in mind when writing
    both functional and non-functional requirements. For this reason, it is useful
    to annotate *user stories* with consideration of *why* and *how* they contribute
    to value. The process of collecting requirements is discussed in [Chapter 2](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml),
    *Functional and Nonfunctional Requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: More technical implications are discussed in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Technical implications of a service scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a service scenario, both the hardware infrastructure and software architecture
    are constrained by the three main principles mentioned as follows, which are an
    immediate consequence of the requirement to keep the software fine-tuned with
    the organization''s needs, namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There's the need to monitor the software to discover any kind of issue that
    might have been caused by system malfunctions or changes in software usage and/or
    user needs. This implies extracting health checks and load statistics from all
    hardware/software components. Good hints for discovering changes in the organization's
    needs are also given by statistics on the operations performed by the users—more
    specifically, the average time spent by both the user and the application on each
    operation instance, and the number of instances of each operation performed per
    unit of time (day, week, or month).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also the need to monitor user satisfaction. Feedback on user satisfaction
    can be obtained by adding to each application screen a link to an easy-to-fill
    user-satisfaction report page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, there''s the need to adapt both hardware and software quickly, both
    to the traffic received by each application module and to the changes in the organization''s
    needs. This means the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paying extreme attention to software modularity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the door open for changes in the database engine and preferring SOA
    or microservices-based solutions to monolithic software
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the door open to new technologies
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the hardware easy to adapt means allowing hardware scaling, which in
    turn implies either the adoption of cloud infrastructures, hardware clusters,
    or both. It is also important to keep the door open to changes in cloud service
    suppliers, which in turn means encapsulating the dependence on the cloud platform
    in a small number of software modules.
  prefs: []
  type: TYPE_NORMAL
- en: The maximization of the value added by the software can achieved by choosing
    the best technology available for the implementation of each module, which in
    turn means being able to mix different technologies. Here is where container-based
    technologies, such as Docker, come into play. Docker and related technologies
    were described in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, all of the requirements we have listed converge toward most of the
    advanced technologies we have described in this book, such as cloud services,
    scalable web applications, distributed/scalable databases, Docker, SOA, and microservices
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: More details on how to prepare your software for a service environment are given
    in the next section, while the next subsection focuses specifically on the advantages
    and disadvantages of SaaS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a SaaS solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main attraction of SaaS solutions is their flexible payment model, which
    offers the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid abandoning big investments in favor of more affordable monthly
    payments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can start with a cheap system and then move toward more expansive solutions
    only when the business grows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, SaaS solutions also offer other advantages, namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In all cloud solutions, you can easily scale up your solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application is automatically updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since SaaS solutions are delivered over the public internet, they are accessible
    from any location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unluckily, SaaS advantages come at a cost, since SaaS also has not negligible
    disadvantages, namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Your business is strictly tied to the SaaS provider, which might discontinue
    the service and/or modify it in a way that is not acceptable to you anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, you can't implement any kind of customization, being limited to the
    few standard options offered by the SaaS supplier. However, sometimes SaaS suppliers
    also offer the possibility to add custom modules written either by them or by
    you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing up, SaaS solutions offer interesting advantages but also some disadvantages,
    so you, as a software architect, must perform a detailed analysis to decide how
    to adopt them.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to adapt software to be used in a service scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a solution for a service scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, *preparing a solution for a service scenario* means designing
    it specifically for the cloud and/or for a distributed environment. In turn, this
    means designing it with scalability, fault tolerance, and automatic fault recovery
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The main implications of the preceding three points are concerned with the way
    the *state* is handled. Stateless module instances are easy to scale and to replace,
    so you should carefully plan which modules are stateless and which ones have states.
    Moreover, as explained in [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml),
    *How to Choose Your Data Storage in the Cloud*, you have to keep in mind that
    write and read operations scale in a completely different way. In particular,
    read operations are easier to scale with replication, while write operations do
    not scale well with relational databases and often require NoSQL solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'High scalability in a distributed environment prevents the usage of distributed
    transactions and of synchronous operations, in general. Therefore, data coherence
    and fault tolerance can be achieved only with more complex techniques based on
    asynchronous messages, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One technique is storing all messages to send in a queue so that asynchronous
    transmissions can be retried in the event of errors or timeouts. Messages can
    be removed from the queue either when confirmation of reception is received or
    when the module decides to abort the operation that produced the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another is handling the possibility that the same message is received several
    times because timeouts caused the same message to be sent several times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If needed, use techniques such as optimistic concurrency and event sourcing
    to minimize concurrency problems in databases. Optimistic concurrency is explained
    in *The data layer* subsection of the use case at the end of [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml),
    *Presenting ASP.NET Core MVC*, while event sourcing is described together with
    other data layer stuff in the *Using SOLID principles to map your domains* section
    of [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml), *Understanding the
    Different Domains in a Software Solution*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two points in the preceding list are discussed in detail together
    with other distributed processing techniques in the *How does .NET Core deal with
    Microservices?* section of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance and automatic fault recovery require that software modules implement
    health check interfaces that the cloud framework might call, to verify whether
    the module is working properly or whether it needs to be killed and replaced by
    another instance. ASP.NET Core and all Azure microservices solutions offer off-the-shelf
    basic health checks, so the developer doesn't need to take care of them. However,
    more detailed custom health checks can be added by implementing a simple interface.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty increases if you have the goal of possibly changing the cloud
    provider of some of the application modules. In this case, the dependency from
    the cloud platform must be encapsulated in just a few modules, and solutions that
    are too strictly tied to a specific cloud platform must be discarded. Hence, for
    instance, you should avoid the use of stateful/stateless native Service Fabric
    services since their architecture is specific to Azure Service Fabric, so they
    can't be ported to a different cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application is conceived for a service scenario, everything must be
    automated: new versions testing and validation, the creation of the whole cloud
    infrastructure needed by the application, and the deployment of the application
    on that infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: All cloud platforms offer languages and facilities to automate the whole software
    CI/CD cycle, that is, building the code, testing it, triggering manual version
    approvals, hardware infrastructure creation, and application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Pipelines allows the complete automatization of all of the steps listed.
    The use case in [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*, shows how to automatize all steps up
    to and including software testing with Azure Pipelines. The use case in the next
    section will show how to automatize the application deployment on the Azure web
    app platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automatization has a more fundamental role in SaaS applications since the whole
    creation of a new tenant for each new customer must be automatically triggered
    by the customer subscription. More specifically, multi-tenant SaaS applications
    can be implemented with three fundamental techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: All customers share the same hardware infrastructure and data storage. This
    solution is the easiest to implement since it requires the implementation of a
    standard web application. However, it is possible just for very simple SaaS services
    since, for more complex applications, it becomes always more difficult to ensure
    that storage space and computation time are split equally between users. Moreover,
    as the database becomes more and more complex, it is always more difficult to
    keep the data of different users safely isolated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All customers share the same infrastructure but each customer has its own data
    storage. This option solves all database problems of the previous solution, and
    it is quite easy to automatize since the creation of a new tenant requires just
    the creation of a new database. This solution offers a simple way to define pricing
    strategies, by linking them to storage consumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each customer has their private infrastructure and data storage. This is the
    most flexible strategy. From the user's point of view, its only disadvantage is
    the higher price. Therefore, it is convenient only above a minimum threshold of
    computational power required by each user. It is more difficult to automate since
    a whole infrastructure must be created for each new customer and a new instance
    of the application must be deployed on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever of the three strategies is chosen, you need the possibility to scale
    out your cloud resources as your consumers increase.
  prefs: []
  type: TYPE_NORMAL
- en: If you also need the possibility to ensure your infrastructure creation scripts
    work across several cloud providers, then, on the one hand, you can't use features
    that are too specific to a single cloud platform, and on the other, you need a
    unique infrastructure creation language that can be translated into the native
    languages of the more common cloud platforms. Terraform and Ansible are two very
    common choices for describing hardware infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – deploying our package-management application with Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will configure an automatic deployment to the Azure App
    Service platform for the DevOps project that we already defined in the use case
    at the end of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*. Azure DevOps can also automatically create
    a new web app, but to prevent configuration errors (which might consume all your
    free credit), we will create it manually and let Azure DevOps just deploy the
    application. All of the required steps are organized into various subsections
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Azure Web App and the Azure database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Azure Web App can be defined by following the simple steps that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Azure portal and select App Services, and then click the Add button
    to create a new Web App. Fill in all data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77c50b71-036b-4bab-9652-79586dbe7438.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, you may use a Resource Group you already have, and the most convenient
    region for you. For Runtime stack, please select the same .NET Core version you
    used in the Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you have enough credit, let's create a SQL Server database for the application,
    and let's call it `PackagesManagementDatabase`. If you don't have enough credit,
    don't worry—you can still test application deployment, but the application will
    return an error when it tries to access the database. Please refer to the *Relational
    databases* subsection of [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*, for how to create a SQL Server database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring your Visual Studio solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you''ve defined the Azure Web App, you need to configure the application
    for running in Azure by following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you defined an Azure database, you need two different connection strings
    in your Visual Studio solution, one of the local databases for development and
    one of the Azure database for the web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open both `appsettings.Development.json` and `appsettings.json` in your
    Visual Studio solution, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/093806cf-72b4-4ed2-974c-b0d131f3aa94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, copy the whole `ConnectionStrings` node of `appsettings.json` into `appsettings.Development.json`, 
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now you have the local connection string in the development settings, so you
    can change `DefaultConnection` in `appsettings.json` with one of the Azure databases.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the database in the Azure portal, copy the connection string, and fill
    it with the username and password you got when you defined the database server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, commit your changes locally and then synchronize with the remote repository.
    Now, your changes are on DevOps Pipelines, which is already processing them to
    get a new build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, you can configure an Azure Pipeline for the automatic delivery of
    your application on Azure by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect Visual Studio with your DevOps project by clicking the Manage Connections link
    in the Connection tab of the Visual Studio Team Server window. Then, click the
    DevOps link to go to your online project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `PackagesManagementWitTests` build pipeline by adding a further step
    after the unit test step. In fact, we need a step that prepares all files to be
    deployed in a ZIP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the Edit button of the `PackagesManagementWitTests` pipeline, and then
    go to the end of the file and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the Settings link appears above the new task, click it to configure the
    new task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d18768bf-5ff7-4c30-af29-7099052337b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Accept the default Path to publish since it is already synchronized with the
    path of the task that will deploy the application, and just insert the artifact
    name, and then select Azure Pipeline as the location. As soon as you save, the
    pipeline will start, and the newly added task should succeed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployments and other release artifacts are added to different pipelines called
    Release Pipelines, to decouple them from build related artifacts. With Release
    Pipelines, you cannot edit a `.yaml` file, but you will work with a graphic interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Releases left menu tab to create a new Release Pipeline. As soon as
    you click add a new pipeline, you will be prompted to add the first task of the
    first pipeline stage. In fact, the whole release pipeline is composed of different
    stages, each grouping sequences of tasks. While each stage is just a sequence
    of tasks, the stages diagram can branch and we can add several branches after
    each stage. This way, we can deploy to different platforms that each require different
    tasks. In our simple example, we will use a single stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Deploy Azure App Service task. As soon as you add this task, you
    will be prompted to fill in missing information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ed18539-0b6e-4d06-831e-aa16c837b8f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the error link and fill in the missing parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ce57687-4bd6-4e9c-b11b-deaf1c0ca177.png)'
  prefs: []
  type: TYPE_IMG
- en: Select your subscription, and then, if an authorization button appears, please
    click it to authorize Azure Pipelines to access your subscription. Then, select
    Windows as the deployment platform, and finally, select the App Service you created
    from the App service name drop-down list. Task settings are automatically saved
    while you write them, so you need just to click the Save button for the whole
    pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to connect this pipeline to a source artifact. Click the Add Artifact button
    and then select Build as the source type, because we need to connect the new release
    pipeline with the ZIP file created by our build pipeline. A settings window appears:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d56d9886-b242-4819-9247-cb86d7ba59e0.png):'
  prefs: []
  type: TYPE_NORMAL
- en: Select our previous build pipeline from the drop-down list, and keep Latest as
    the version. Finally, accept the suggested name in Source alias.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our release pipeline is ready and can be used as it is. The image of the source
    artifact you just added contains a trigger icon in its top-right corner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/545778d2-3408-4a06-8ae9-00ffbe915f1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the trigger icon, you are given the option to automatically
    trigger the release pipeline as soon as a new build is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75c52940-6e05-41d2-8f18-b10d7a0cc45f.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep it disabled; we can enable it after we have completed and manually tested the
    release pipeline. In preparation for an automatic trigger, we need to add a human
    approval task before the application is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a manual approval for the release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since tasks are usually executed by software agents, we need to embed human
    approval in a manual job. Let''s add it with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the three dots on the right of the Stage 1 header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/97463b10-1754-4141-a811-9aac460bc4ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, select Add an agentless job. Once the agentless job has been added, click
    its add button and add a Manual intervention task. The following screenshot shows
    the Manual intervention settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79d2f557-6ec8-4678-84d4-24d7c85c41e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Add instructions for the operator and select your account in the Notify users field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, drag the whole Agentless job with the mouse, to place it before the application
    deployment task. The final screenshot should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d9096ac-64a7-46f4-9b9f-492b3051e83a.png)'
  prefs: []
  type: TYPE_IMG
- en: Finished! Click the save button in the top-left to save the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, everything is ready to create our first automatic release.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have everything in place, a new release can be prepared and deployed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click the Create release button to start the creation of a new release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21a6cf8f-2a74-4143-8cc9-dd86229788f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that the Source alias is the last available, add a release description,
    and then click Create. In a short time, you should receive an email for the release
    approval. Click the link it contains, and go to the approval page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6db8064f-c8ed-4c53-8ccd-bf56055ae639.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Resume / Reject button and then approve the release. Wait for the
    deployment to complete. You should have all of the tasks successfully completed,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70a11166-c5b1-4c65-a402-700d04f035b8.png)'
  prefs: []
  type: TYPE_IMG
- en: You have run your first successful release pipeline!
  prefs: []
  type: TYPE_NORMAL
- en: In a real-life project, the release pipeline would contain some more tasks.
    In fact, applications (before being deployed in the actual production environment)
    are deployed in a staging environment where they are beta-tested. Hence, probably,
    after this first deployment, there would be some manual tests, manual authorization
    for the deployment in production, and the final deployment in production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We described *service design thinking* principles and the SaaS software deployment
    model. Now, you should be able to analyze all of the implications of these approaches
    for an organization, and you should be able to adapt pre-existing software development
    processes and hardware/software architectures to take advantage of the opportunities
    they offer.
  prefs: []
  type: TYPE_NORMAL
- en: We also explained the need for, and the techniques involved in, the automatization
    of the software cycle, cloud hardware infrastructure configuration, and application
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have implemented the example in the last use case section, you should
    be able to use Azure Pipelines to automate infrastructure configuration and application
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter gives more insights into DevOps, which, together with CI/CD,
    which is discussed in detail in [Chapter 19](db7586ff-b06d-4503-a64a-9a6678d09acb.xhtml),
    *Challenges of Applying CI Scenarios in DevOps*, plays a fundamental role in service
    scenarios and, in particular, the maintenance of SaaS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main goal of service design thinking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that service design thinking requires the optimal usage of all competencies
    already available in the company?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a complete automatization fundamental in the life cycle of SaaS applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to define hardware cloud infrastructures with a platform-independent
    language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the preferred Azure tool for the automatization of the whole application
    lifecycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If two SaaS suppliers offer the same software product, should you prefer the
    most reliable or the cheapest one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is scalability the only important requirement in a service scenario?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main references in this chapter are references to other chapters/sections
    of this book and have already been given throughout this chapter. Here, we give
    just the link to the Azure Pipelines documentation: [https://docs.microsoft.com/en-us/azure/devops/pipelines/?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/?view=azure-devops),
    and to the two infrastructure description languages cited in this chapter, Terraform
    ([https://www.terraform.io/](https://www.terraform.io/)) and Ansible ([https://www.ansible.com/](https://www.ansible.com/)).
  prefs: []
  type: TYPE_NORMAL
