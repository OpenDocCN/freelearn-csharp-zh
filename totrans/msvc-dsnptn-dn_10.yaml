- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing Health Checks on Your Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining maximum uptime is an important aspect of any system. In the previous
    chapter, we saw where we can write code in a fault-tolerant manner that will reduce
    the prevalence of outages in our infrastructure and network. This, however, is
    not a long-term solution, and things fail regardless of these measures. It then
    leads to the notion that we need to know when there are failures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This is where we start thinking about health checks. Health checks exist as
    a mechanism to inform us of outages in our services and supporting databases and
    connections in our application. Generally, this can be accomplished with a simple
    ping request to a resource. The resource is available and operating as expected
    if we get a response. In the absence of a response, we assume that the resource
    is down and trigger an alert.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: There are statuses between the service’s up and down status, and we will discover
    those options in this chapter. We will also explore some of the functionality
    that .NET Core provides to implement these checks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at various scenarios and countermeasures that
    we can implement when navigating possible failures in our microservices architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this chapter, we will be able to do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Understand why health checks are necessary
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to implement health checks in ASP.NET Core
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how orchestrators monitor and respond to failures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at this URL: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Health checks and microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A health check allows us to monitor the health of our services. Frankly, another
    service or resource that exposes an HTTP endpoint becomes a capable candidate
    for health checks. We can simply make a request to this endpoint and hope for
    a response that indicates a successful response. The simplest form of a health
    check can come from implementing a simple `GET` request, which returns a `200OK`
    HTTP response. We can add further intelligence to such an endpoint, check connectivity
    to other key services, and use those to influence the response code returned.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Health checks are useful mechanisms for both monolithic and microservices applications.
    In the context of microservices, however, we have an increased challenge of monitoring
    and maintaining several services. Even more so if they are configured to scale
    on individual levels. Health checks can be used to monitor the health and uptime
    of interdependent services and carry out some form of corrective action when a
    service is down.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Core, we can return a successful response and include additional
    information that gives some details on the health of the service. In this case,
    we cannot simply go by the `200OK` response, but we need to interrogate the actual
    response body to check whether the service is healthy, degraded, or unhealthy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.1* shows a typical health check:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Shows a health check request and healthy response after verifying
    that all services are available](img/Figure_10.1_B19100.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Shows a health check request and healthy response after verifying
    that all services are available
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down what each state entails:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Healthy**: This indicates that the service is healthy and the application
    is operating as expected'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degraded**: This indicates that the service is live, but some functionality
    may be unavailable'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unhealthy**: This indicates that the service is failing and is not operating
    as expected'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 10.2* shows a failed health check:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Shows a health check that sent a failure response since one
    of the services was not available](img/Figure_10.2_B19100.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Shows a health check that sent a failure response since one of
    the services was not available
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The health of a service depends on several things, including correct configuration,
    access to keys and dependencies, the status of the hosting platform and infrastructure,
    and the connection to the database. They may also be used for external application
    monitoring and overall application health.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A common deployment model for microservices is using container orchestrators,
    such as *Kubernetes*, to deploy and run our services in production. Most orchestrators
    perform periodical *liveness health checks* on their pods during runtime and *readiness
    health checks* during deployments. Health checks help the orchestrator determine
    which pods are in a ready state and are capable of handling traffic. It is important
    to understand the differences between the liveness health check and the readiness
    health check and when which one is most suitable. The easier one to implement
    is the liveness health check; we will discuss this next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The liveness health check
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The liveness health check endpoint is a specific endpoint that is implemented
    for the sole purpose of the health check. In this health probe, the service is
    considered healthy when it responds to the *liveness health check*. A failure
    to respond to this endpoint indicates a serious issue with the application. This
    issue could be caused by a range of reasons, such as a crash or unplanned application
    restart. For this reason, restarting an application that has failed this check
    is a common course of action.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Applications that monitor the infrastructure, such as *Kubernetes* monitoring
    Docker containers, use *liveness health checks* to determine the health of pods
    and trigger restarts as needed. Cloud providers also offer health probe functionality
    with load balancers, which can check the availability of the deployed application
    by periodically sending a request to the liveness check endpoint. This approach
    is generally sufficient for web applications and services as we do not need a
    complicated liveness check endpoint. If the service can accept the request and
    return a response, then we consider it healthy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the application or services is alive is simple enough, but
    we may also need to mitigate false positives after application deployments and/or
    upgrades. This can occur when the application might not be completely ready for
    usage, yet we are getting positive responses from the liveness checks. At this
    point, we need to consider implementing *readiness health checks*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Readiness health checks
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Readiness health checks* are used in situations where we need to verify more
    than just an HTTP response. An application with several third-party dependencies
    might take longer to be ready for use. So, while it is operational and able to
    respond to a simple HTTP request, the databases or message bus services, for instance,
    might not yet be ready. We want to ensure that we have a full picture of the status
    of the application from a startup perspective before proceeding to use it or continuing
    with the deployment activity.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: A *readiness health check* will generally only return a healthy status once
    the startup task has been completed. These checks will then take a bit longer
    to return a healthy status than a *liveness health check* will. With readiness
    health checks in place, an orchestrator will not attempt to restart the application,
    but it will not route request traffic. *Kubernetes* can perform readiness probes
    periodically during the application’s runtime, but it can also be configured to
    only perform this probe during the startup of the application. Once the application
    reports that it is healthy, then this probe will not be executed again for the
    lifetime of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: This *readiness health check* is best used for applications where there are
    long-running tasks that must finish before the application can be considered ready
    and operational. Recall that with microservices, we introduce several additional
    infrastructure dependencies, and we need to monitor and confirm the overall health
    of the system to ensure that only the healthiest pods get traffic directed to
    them. Therefore, properly configuring health checks is essential to ensuring that
    we have the best representation of our application’s health.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored how health checks work and how orchestrators and monitoring
    systems use them, we can explore implementing health checks in our ASP.NET Core
    API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ASP.NET Core health checks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core has a built-in health check middleware that allows us to natively
    implement very robust health checks. This middleware is not limited to API projects,
    and it comes in handy to help us to monitor the health of our application. Both
    readiness and liveness health checks can be created natively, and there is support
    for a UI dashboard. Using the liveness health check, which is relatively simple
    to implement, we can implement a simple API endpoint that returns a simple response,
    as expected. We can also check on the health of the dependencies of the app using
    a more comprehensive readiness health check.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will be adding liveness and readiness health checks to
    our appointment booking service. This service has several dependencies and is
    integral to several operations in our application. We need to ensure that it is
    always healthy and react quickly if it degrades.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Let us start off by exploring how we can outfit an ASP.NET Core API with a liveness
    health check.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Adding liveness health checks
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed, a liveness check is the most basic health check that can be implemented.
    The basic configuration needed for this in our ASP.NET Core application is to
    register the `AddHealthChecks` service and the addition of the health check middleware,
    where we define a URL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'We make the following changes to the `Program.cs` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any attempt to navigate to the `/healthcheck` endpoint will yield a simple plain
    text response as `HealthStatus`. The possible `HealthStatus` values are `HealthStatus.Healthy`,
    `HealthStatus.Degraded`, or `HealthStatus.Unhealthy`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Health checks are created using the `IHeathCheck` interface. This interface
    allows us to extend the default health checks and add more logic to our health
    check and further customize the possible response values. We can create a health
    check extension using the following code block:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This inheriting from `IHeathCheck` forces us to implement the `CheckHealthAsync`
    method. This method gets called when a health check is triggered, and we can include
    additional code to check other factors and determine whether we deem our application
    to be healthy or not. Based on the value of `healthy`, we can return a custom
    message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to add `HealthCheack` to our services, we modify the `AddHealthChecks`
    service registration like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we add our new health check logic and give it a name for a specific reference
    in other parts of the application. This `AddCheck` method allows us to define
    a name for the health check, a default failure status value, tags to map to custom
    health check endpoints, and a default timeout value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Now building on the notion that our orchestrators and load balancers that are
    performing health checks will also prefer to see appropriate responses relative
    to the health status, we can extend the `app.MapHealthChecks` middleware code
    to return a specific HTTP response relative to the health status. While we are
    at it, we can also disable cached responses:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next thing we may want to investigate is returning details in our response.
    As it stands, we are only returning the plain text response with the status. We
    can use methods found in the `System.Text.Json` library to create a custom delegate
    method that can be implemented as follows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to indicate to the middleware that we have a custom `ResponseWriter`
    called `WriteJsonResponse`. We need to add this to the list of `HealthCheckOptions`,
    using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then define the `WriteJsonResponse` writer with the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 10.3* shows the results of a health check:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Shows a health check response where both the service and database
    are available and in good health](img/Figure_10.3_B19100.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Shows a health check response where both the service and database
    are available and in good health
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Now we can include details about the health status if the API reports an unhealthy
    or degraded status. Furthermore, when we add more health checks, the content of
    this JSON response will be populated with each check’s details.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.4* shows the results of an unhealthy check:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Shows a health check response where the database is not available](img/Figure_10.4_B19100.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Shows a health check response where the database is not available
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have more detailed responses, we can add more detailed checks,
    such as a database probe. This will serve as a check to verify that the API can
    communicate with the database through the configured database. By extension, since
    we are using Entity Framework for this connection, we can implement a `DbContext`
    check. We start with the `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    NuGet package. We then modify the `AddHealthChecks` method registration using
    the following piece of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This context health calls Entity Framework Core’s built-in `CanConnectAsync`
    method and uses that response to infer the database connectivity health.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can check on the health of our service and its connectivity to our
    database let us configure it for readiness checks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Adding readiness health checks
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have discussed, the readiness check indicates when the application and
    its dependencies have started successfully and are ready to begin receiving requests.
    We can define a separate endpoint for the readiness check and further customize
    the checks that should be performed based on the URL used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement liveness and readiness checks on different URLs, we can add a
    `tags` parameter to the extensions to the `AddHealthChecks` method. This allows
    us to pass in an array of tag names. We can tag our health checks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have tagged our health checks, we can proceed to create our specific
    check endpoints and associate them with the tags:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this new code, the `/healthcheck/ready` endpoint will filter only health
    checks that are tagged as `ready`. In the `/health/live` endpoint, we set the
    predicate value to `false` to ignore all tags and conduct all health checks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段新代码，`/healthcheck/ready`端点将仅过滤标记为`ready`的健康检查。在`/health/live`端点中，我们将谓词值设置为`false`以忽略所有标签并执行所有健康检查。
- en: While we will not be exploring Kubernetes or other orchestrators in detail,
    we want to look at how orchestrators interact with our health check endpoints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细探讨Kubernetes或其他编排器，但我们想看看编排器如何与我们的健康检查端点交互。
- en: Configuring health probes in orchestrators
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编排器中配置健康探针
- en: Monitoring is not unique to orchestrators, as we have already established. There
    are services that offer monitoring services for our applications and allow us
    to configure probes into our applications. These services generally allow us to
    add alerts and configure response time thresholds. These alerts can come in handy
    in helping us to respond to failures or situations of concern based on our configured
    thresholds.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 监控并非仅限于编排器，正如我们之前已经确立的。有一些服务为我们提供监控服务，并允许我们将探针配置到我们的应用程序中。这些服务通常允许我们添加警报并配置响应时间阈值。这些警报在帮助我们根据配置的阈值响应故障或关注的情况时非常有用。
- en: In a microservices application, we need a way of monitoring many services as
    efficiently as possible. The fewer unique configurations we need to do, the better.
    We have several deployment models that can be used, and most predominantly, containers
    managed by orchestrators. Microsoft Azure has several web application deployment
    models, including **Web App for Containers** (**WAC**), **Azure Container Instances**
    (**ACI**), and **Azure Kubernetes Service** (**AKS**).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务应用程序中，我们需要一种尽可能高效地监控许多服务的方法。我们需要做的唯一配置越少，越好。我们有几种部署模型可以使用，其中最突出的是由编排器管理的容器。Microsoft
    Azure有几种Web应用程序部署模型，包括**容器Web应用程序**（**WAC**）、**Azure容器实例**（**ACI**）和**Azure Kubernetes服务**（**AKS**）。
- en: WAC is a part of App Service, so the health check works the same way as it would
    for an Azure web app. It allows you to specify a health check endpoint that will
    return a response within the 2xx and 3xx HTTP response range. It should also return
    this health check response within a minute for the service to be considered healthy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: WAC是App Service的一部分，因此健康检查的工作方式与Azure Web应用程序相同。它允许你指定一个健康检查端点，该端点将在2xx和3xx
    HTTP响应范围内返回响应。它还应在1分钟内返回此健康检查响应，以便服务被认为是健康的。
- en: The next option is the ACI, where health checks are called health probes. These
    probes are configured with a check period, which determines the frequency with
    which checks are made. When the health check is completed successfully, then the
    container is considered healthy, and if not, then it is unhealthy or just unavailable.
    With the ACI, we can configure both liveness and readiness health checks. Our
    probes can either execute a command on the container or perform an HTTP `GET`
    request. When we perform a liveness probe, we verify that our container is healthy,
    and if not, the ACI might proceed to shut down the container and spin up a new
    instance. The readiness probe is designed to confirm whether a container is available
    for request processing, which, as we discussed, is more important during the application
    startup process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是ACI，其中健康检查被称为健康探针。这些探针配置了检查周期，它决定了检查的频率。当健康检查成功完成时，容器被认为是健康的；如果不成功，则容器是不健康的或只是不可用。使用ACI，我们可以配置存活和就绪健康检查。我们的探针可以在容器上执行命令或执行HTTP
    `GET`请求。当我们执行存活探针时，我们验证容器是否健康；如果不健康，ACI可能会关闭容器并启动一个新的实例。就绪探针旨在确认容器是否可用于请求处理，正如我们之前讨论的，在应用程序启动过程中这一点更为重要。
- en: In the Azure Kubernetes Service of AKS, we have a very similar approach to health
    checks and probes, as we saw in the ACI. Out of the box, Kubernetes supports both
    liveness and readiness probes; as seen before, the major difference is that Kubernetes
    suggests that you have a separate probe for checking the application’s health
    at startup, separate from the readiness probe that is continuous during the application
    runtime. We can also implement HTTP `GET` request probes as well as TCP probes
    to check on our containers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Kubernetes 服务（AKS）中，我们有一个与 ACI 中非常相似的健康检查和探针方法。开箱即用，Kubernetes 支持存活和就绪探针；如之前所见，主要区别是
    Kubernetes 建议您为检查应用程序启动时的健康状态有一个单独的探针，这个探针与在应用程序运行期间持续进行的就绪探针是分开的。我们还可以实现 HTTP
    `GET` 请求探针以及 TCP 探针来检查我们的容器。
- en: Kubernetes is configured using a markup language called `spec.template` field
    of the YAML configuration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用一种名为 `spec.template` 字段的标记语言进行配置。
- en: 'The following is an example of a YAML configuration that creates a deployment
    object that performs startup, liveness, and readiness health checks on a container:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 YAML 配置，它创建了一个执行容器启动、存活和就绪健康检查的部署对象：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The sections of the YAML file that outline the health checks are `livenessProbe`,
    `startupProbe`, and `readinessProbe`. The probe definition with the major difference
    is the readiness probe, which executes a command as opposed to making a call to
    an endpoint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 描述健康检查的 YAML 文件部分是 `livenessProbe`、`startupProbe` 和 `readinessProbe`。与其它探针定义相比，就绪探针的主要区别在于它执行一个命令，而不是调用一个端点。
- en: With this, we have gained some fundamental knowledge of health checks, how they
    work, and why we need them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们获得了一些关于健康检查的基本知识，了解它们是如何工作的，以及为什么我们需要它们。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Health checks are simple yet powerful constructs that aid us in ensuring that
    our applications are running at maximum efficiency. We see where it is important
    for us to not only monitor and report on the uptime of the service but also the
    dependencies, such as the database and other services that may be needed for the
    application to operate properly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是简单而强大的结构，帮助我们确保应用程序以最大效率运行。我们认识到，对于我们来说，不仅要监控和报告服务的正常运行时间，还要监控和报告依赖项，例如数据库和其他可能需要应用程序正常运行的其它服务。
- en: Using ASP.NET Core, we have access to a built-in health check mechanism that
    can be customized and extended to implement specific checks and associate them
    with different endpoints. This is especially useful when we need to separate the
    types of tests that are conducted relative to the endpoint being called.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core，我们可以访问一个内置的健康检查机制，该机制可以自定义和扩展以实现特定的检查，并将它们与不同的端点关联。这在我们需要区分针对被调用端点的测试类型时特别有用。
- en: We have also explored how orchestrators can be configured to poll our health
    check endpoints. Orchestrators make monitoring and responding to failures easier
    since they will handle the routing of traffic to healthy instances and restart
    instances as needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何配置编排器以轮询我们的健康检查端点。编排器使得监控和响应故障变得更容易，因为它们将处理将流量路由到健康实例，并在需要时重启实例。
- en: Health checks help us not only monitor the target web service, but we can also
    configure health checks to report on downstream services as well. This will come
    in handy, especially when we implement dependencies between our microservices
    through patterns like the API gateway pattern. We will investigate implementing
    this pattern in the next chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查不仅帮助我们监控目标网络服务，我们还可以配置健康检查来报告下游服务。这在我们将微服务通过如 API 网关模式等模式实现依赖关系时特别有用。我们将在下一章中探讨实现此模式的方法。
