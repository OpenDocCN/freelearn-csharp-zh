- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adopting Code Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll talk about the importance of establishing clear **code
    standards** with the right degree of flexibility. We’ll also cover some built-in
    tooling in Visual Studio that will help your team adopt a consistent set of coding
    standards. This in turn helps you focus on the right things during code review.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing code standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and code cleanup in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying code standards with `EditorConfig`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter16/Ch16BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to explore the idea of code standards.
  prefs: []
  type: TYPE_NORMAL
- en: Code standards are an agreed-upon set of standards your team decides should
    be applied to any new code created by the team.
  prefs: []
  type: TYPE_NORMAL
- en: These standards have an important role in resolving disputes, focusing attention
    on the areas that truly matter, reducing the amount of technical debt teams naturally
    accumulate, and helping pay down existing technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of code standards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most frustrating experiences I’ve ever had as a developer is when
    I’ve sent a carefully thought-out change to another developer for review and I’ve
    heard back remarks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I don’t like your curly* *brace formatting*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your indentation doesn’t match mine. I use spaces instead* *of tabs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I’d like it if you’d use* `var` *instead of* *the Type*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these scenarios, the developer in question ignores the *substance* of the
    change and instead focuses on the *style* of the change – specifically where the
    style differs from their preferences.
  prefs: []
  type: TYPE_NORMAL
- en: The cure for this is to adopt a set of code standards that you and your team
    agree upon. These standards establish what your team cares about with regard to
    new code going forward. The standards might also contain the rationale behind
    the team’s style and code preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of code standard decisions might include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We use file-scoped namespaces because they result in less nesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test classes should be named after the classes they test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We prefer using target-typed `new` when instantiating objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class definitions should be clearly organized and start with fields, then move
    on to constructors, properties, and finally methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These standards don’t have to be so rigid that developers don’t have any decisions
    to make or live in constant fear of violating them.
  prefs: []
  type: TYPE_NORMAL
- en: Your code standards should be prescriptive enough that they address the major
    points of contention and confusion. This helps you focus on creating and maintaining
    code in a way that maximizes your ability to provide value to the organization.
  prefs: []
  type: TYPE_NORMAL
- en: How code standards influence refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have a definitive set of standards that you and your team agree on,
    it opens the floodgates for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Without a set of standards, when you talk about old code, you might say “I don’t
    like this very much,” or “This isn’t how I would have written this,” or “This
    seems poorly put together.”
  prefs: []
  type: TYPE_NORMAL
- en: These things may be true, but they aren’t compelling arguments for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, when you can say “This class violates our code standards in these areas,”
    the conversation becomes much more productive. This is especially true when you
    can establish that some of your standards are critical while others are important
    but less critical.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain aspects of code standards that I believe are critical and
    worth going in and making changes to just to get the code onto the new standards.
    For me, these areas often revolve around the handling of `IDisposable` resources
    and using proper exception management practices.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you and your team agree upon is critical. These standards will impact
    your priorities and the decisions you make while maintaining code. Standards violations
    can be issues that get dedicated work items assigned to people to go in and fix
    without any other reason for touching the code in question. We’ll talk more about
    this in the final chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Applying code standards to existing code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The non-critical standards are used to guide the work developers do every day.
    All code changes are expected to comply with these code standards. Often, the
    standards encourage developers to update nearby pre-existing code that is out
    of compliance.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your team might have a code standard to not use the `var` keyword
    when you can help it (or to always prefer `var`, if that’s your jam). The team’s
    expectation would be that as developers write new code, the new code will comply
    with this rule.
  prefs: []
  type: TYPE_NORMAL
- en: When standards are defined, teams sometimes expect that code near the code you’re
    changing will also be updated to comply with the standards. This is particularly
    true for code in the same method. After all, you’ve spent effort testing your
    new code to validate the changes you made. This testing effort can help catch
    any issues introduced by refactoring the rest of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, these code standards will help reduce the rate at which your team
    accumulates technical debt. This ongoing improvement of the existing code will
    also help pay down existing technical debt in frequently changed areas.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing code standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now that I’ve convinced you how code standards can reduce conflict in your
    team, focus code reviews, and guide refactoring efforts, let’s talk about where
    these standards come from and how we adopt them in our teams.
  prefs: []
  type: TYPE_NORMAL
- en: Collective code standards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every software development team already has code standards.
  prefs: []
  type: TYPE_NORMAL
- en: I say this because each software development team already has, by definition,
    at least one developer. Every developer, whether they’re aware of it or not, has
    their own set of internalized code standards.
  prefs: []
  type: TYPE_NORMAL
- en: They may not have thought about their preferences or be able to list them out,
    but if you look at each developer on your team and the code they write in isolation,
    there will be a certain amount of consistency to it.
  prefs: []
  type: TYPE_NORMAL
- en: The problem teams encounter is not that they don’t have standards, but rather
    that they have too many standards. Each developer operates from their own internal
    set of standards and preferences and the team must now come together and interact
    with each other’s unique styles and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, teams will gravitate toward certain styles as developers tend to mimic
    the existing style in code files. As time goes on and teams grow, there are usually
    conflicts over certain choices. When this happens, your team will need to decide
    whether the creative freedom of not having defined any collective standards is
    worth the friction and distractions caused by these differing preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, most teams formalize a set of standards around the things that really
    matter to those teams. Let’s talk about what should go on that list.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting what is important
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programming is a creative endeavor and so we don’t want to place too many restrictions
    on how developers write code. On the other hand, when there are too few rules,
    it can result in somewhat eclectic areas of code that are suited to one developer’s
    preferences but not the larger team.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does a development team figure out what should go in its standards?
  prefs: []
  type: TYPE_NORMAL
- en: I like to start with the standards that keep teams safe. These involve following
    established best practices such as those defined in the .NET’s **Framework Design
    Guidelines** (see *Further reading* for more information). These practices are
    less oriented around individual opinions. This lets them have a high impact while
    being relatively free of drama as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Next, look at the major sticking points your team bumps into in code review.
    If you’re sick of discussions around tabs versus spaces – whether or not the `{`
    belongs on its own line, or the use of `var` – these are things to consider adding
    to your team’s standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'If these areas are major sources of disagreements, you have a couple of choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick a stance on the area of contention and adopt it as a team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make having no official stance on the topic your team’s official position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking a stance and adopting it as a team may cause temporary arguments and
    hurt feelings. In the long term, adopting a stance tends to be beneficial since
    your team can operate with a consistent style. While developers may feel less
    appreciated or valued by the position, most tend to naturally warm to the new
    style over time, though this can lead to turnover in some cases when developers
    feel very strongly about a topic or that their opinions weren’t considered.
  prefs: []
  type: TYPE_NORMAL
- en: You may not think that explicitly saying your team has no stance on an aspect
    of code would be very beneficial. However, I’ve seen this approach have a massive
    impact on the conversations teams have. By explicitly having no policy on the
    topic, the contentious topic now becomes something quickly resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of debating whether `var` belongs in your code, the team can point to
    its standards that say individual developers can make their own choices on this
    matter. This moves your team past contentious areas and on to more productive
    topics. The primary downside is that your overall code will be less consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The value of consistency
  prefs: []
  type: TYPE_NORMAL
- en: Code that follows consistent styling and design decisions feels more professional,
    makes it easier for developers to work in areas they’ve not worked in before and
    keeps developers productive and focused on the function of code instead of its
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the engineering team is represented when creating code standards and
    determining what goes in those standards. This can be done by involving the entire
    team or by picking a subset that represents the various experience levels and
    preferences of the engineers in your organization. Additionally, if you have individuals
    who may react particularly strongly to a new style, make sure their concerns are
    fully heard and – where possible – involve them in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Sources of code standards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, creating a standard of your own can be too difficult or polarizing,
    or you may find that you don’t know where to start when creating code standards.
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, I recommend starting from an established set of code standards
    and customizing those as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259), we covered the built-in
    code analysis rulesets and how you can progressively move your ruleset from the
    latest ruleset to the latest minimum, then the latest recommended, and finally
    all the latest rulesets. These code analysis rules can help enforce best practices.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like a little more formality to things, Microsoft has documented C#
    coding conventions and framework design guidelines that give you a good starting
    point for your team. Both documents are referenced at the end of this chapter
    in the *Further reading* section and are fantastic, evergreen sources of wisdom
    around .NET and C#.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving code standards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mention “evergreen” because C# is not a dormant language. Every November,
    Microsoft ships new versions of C# with new language features building upon the
    previous year’s improvements. This makes the C# language feel more organic as
    it evolves over time.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the context in which we program changes over time. When .NET was
    first introduced, it was essentially a productivity improvement for developers
    primarily performing Windows desktop development. Since then, we’ve seen .NET
    become open source and cross-platform. At the same time, many organizations have
    migrated from on-premises data centers as cloud computing on platforms such as
    Azure and AWS has become the norm.
  prefs: []
  type: TYPE_NORMAL
- en: Things that were best practices back in the original days of C# have since faded
    in popularity as new language features have arrived to take their place and as
    the .NET platform grows new features.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been working with .NET since the beginning and have felt this in my own
    coding style. Throughout this book, I’ve discussed `var` because it’s an easy
    language feature to talk about, but it is a good example of how C# changes over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to `var`, you’d declare a dictionary of `Guid` keys and `int` values
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When `var` was introduced, the standard shifted to using `var` to simplify
    your declaration since the Type was obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This resulted in less duplicated syntax and improved developer productivity
    while still keeping the Type obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the recent addition of target-typed `new`, my preference changed to use
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I’m sharing my own personal journey on standards here because it’s a microcosm
    of what engineering teams will go through.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll adapt to standards and then C# will change over time, and you’ll adjust
    your standards to keep up. What you may consider a “best” practice right now may
    later turn out to not work well a few months into implementation. It’s also natural
    for the obstacles facing your team to change. When this happens, this forces you
    and your team to adopt new strategies to overcome these obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: It’s okay to change your standards over time. That’s normal and is a sign of
    an evolving language and the evolving context of our daily programming jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating standards into your processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code standards affect a few different places in software development, from how
    you approach building new features to the way in which you maintain code.
  prefs: []
  type: TYPE_NORMAL
- en: Your code standards should be clearly documented and stored in a central location,
    such as a team wiki or shared document. These standards should be communicated
    to new developers who join the team to help them familiarize themselves with the
    team’s expectations on code standards.
  prefs: []
  type: TYPE_NORMAL
- en: Code standards should also be reinforced in the code review process after all
    other concerns on the substance of code changes are discussed. These issues should
    be resolved before the code is approved and the work item is completed, but this
    shouldn’t be done in a punitive manner.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that internalizing code standards takes some time
    for new developers on the team. It’s normal for it to take a few months with the
    team before your new developers think in terms of the team’s standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that can help is to incorporate tools into the process that make
    it easy for your team to validate whether its code meets standards before it sends
    the code on for peer review. Code analysis rules and Roslyn Analyzers can help
    with this, but Visual Studio places a few more tools at your disposal that can
    help standardize code before code reaches human review: code formatting and `.``editorconfig`
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and code cleanup in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that Visual Studio can automatically arrange and even clean up
    your code in a consistent manner through built-in features.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the easiest ways to do this is with the **Format Document** feature,
    either by pressing *Ctrl* + *K* and then *Ctrl* + *D* or by opening the **Edit**
    menu, then going to **Advanced** and selecting **Format Document**, as shown in
    *Figure 16**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Formatting the active editor document](img/B21324_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Formatting the active editor document
  prefs: []
  type: TYPE_NORMAL
- en: This will change the code in your current file to match the preferences you’ve
    configured in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: These settings can be configured by opening the **Tools** menu and then selecting
    **Options…**. From there, expand the **Text Editor**, **C#**, **Code Style**,
    and **Formatting** nodes until you see the various preferences for indentation,
    new lines, spacing, and wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'These settings blades allow you to configure the formatting preferences of
    Visual Studio and preview the formatting choices, as shown in *Figure 16**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Changing how Visual Studio formats catch statements](img/B21324_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Changing how Visual Studio formats catch statements
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve customized your settings, these settings will be used any time you
    use the **Format** **Document** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers learn the *Ctrl* + *K* and *Ctrl* + *D* shortcuts to format
    documents early on and use them reflexively, but you can actually get Visual Studio
    to apply code cleanup automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically formatting documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio has a **Code Cleanup** feature that allows you to format your
    code either manually or automatically whenever the file is saved.
  prefs: []
  type: TYPE_NORMAL
- en: This is done through `using` statements, sort the members in your classes into
    a more consistent order, and apply your code formatting preferences to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a code cleanup profile, go to the **Options** dialog again and
    this time, find **Code Cleanup** in the **Text Editor** node, as shown in *Figure
    16**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Enabling code cleanup when files are saved](img/B21324_16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – Enabling code cleanup when files are saved
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can check **Run Code Cleanup profile on Save** to have your cleanup
    profile automatically applied.
  prefs: []
  type: TYPE_NORMAL
- en: I also recommend you click **Configure Code Cleanup** to view your cleanup profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows you the fixers that will be applied as part of each profile, as
    shown in *Figure 16**.4*, and allows you to configure what is and isn’t included
    in the code cleanup action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Configuring code cleanup profiles](img/B21324_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Configuring code cleanup profiles
  prefs: []
  type: TYPE_NORMAL
- en: Automatically cleaning up code on save can be helpful, but it does have some
    downsides. If your code hasn’t been cleaned up in a while, your cleanup action
    could appear to create many changes in the file. This can be confusing in git
    when multiple authors are trying to modify the same file or even see what has
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring code style settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Believe it or not, when we covered the C# settings for new lines and indentation
    earlier, this wasn’t the limit of what Visual Studio can do.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio provides a **Code Style** settings section that allows you to
    configure your individual preferences around most language features found in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'These settings are found in the **Options** dialog under **Text Editor**, **C#**,
    **Code Style**, and then **General**, as shown in *Figure 16**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Configuring Code Style rules in Visual Studio](img/B21324_16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Configuring Code Style rules in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: In this user interface, you can configure which rules you care about, what your
    preferences are on each rule, and how much you care about each rule. Also notice
    the **Generate .editorconfig file from settings** button, as we’ll talk about
    that more later.
  prefs: []
  type: TYPE_NORMAL
- en: For each rule, you get to select whether the rule only appears as a refactoring
    option, whether Visual Studio subtly suggests the rule through green underlines
    on identifiers, or whether Visual Studio should be more aggressive, such as using
    compiler warnings or compiler errors for violations from standards.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of these settings, but they allow you to fine-tune your individual
    preferences for which C# features you prefer and how you like them formatted.
  prefs: []
  type: TYPE_NORMAL
- en: However, these are your *individual* settings that get applied to the code you
    work with on your own machine. In the next section, we’ll talk about how to make
    these settings apply to your entire team.
  prefs: []
  type: TYPE_NORMAL
- en: Applying code standards with EditorConfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a look at how you can take the same code style settings found in
    the options dialog and attach them to a project through an `.``editorconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `.editorconfig` files that contain style and language usage rules that apply
    to your project. Any violation of your `EditorConfig` rules will result in compiler
    warnings and suggestions in the Visual Studio editor.
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig files outside of Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, `.editorconfig` files work in Visual Studio and
    JetBrains Rider natively. In VS Code, EditorConfig files are supported as long
    as you install the C# Dev Kit and the EditorConfig for VS Code extension. See
    the *Further reading* section for instructions on enabling these features in VS
    Code and JetBrains Rider.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of `EditorConfig` files is that they allow all developers working
    on a project to work with a consistent set of formatting and styling preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing our starter code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code we’ll be formatting lives in our [*Chapter 16*](B21324_16.xhtml#_idTextAnchor341)
    solution, which has a `FlightQueryDecoder` console app and an associated `xUnit`
    test project. This code is minimal for this chapter and revolves around the `FlightQueryParser`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the first half of `FlightQueryParser`, which parses a flight
    search string such as `AD08FEBDENLHR` into a `FlightQuery` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The actual logic here isn’t the focus. What I want to highlight to you is the
    inconsistency in how the code is formatted within the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the other half of the file, which takes a flight search result string
    such as `DEN LHR 05:50P 09:40A E0/789 8:50` and converts it to a `FlightQueryResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While this code is deliberately bad and inconsistently formatted to serve as
    an example, I’m sure you’ve seen many larger files in the real world with equally
    inconsistent styling.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced this code with its different styling choices, let’s
    add an `.editorconfig` file to the project and see how that can help enforce styles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an EditorConfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the `.editorconfig` file, right-click on the `Packt.FlightQueryDecoder`
    project and choose **Add** and then **New EditorConfig** or **New** **EditorConfig
    (IntelliCode)**.
  prefs: []
  type: TYPE_NORMAL
- en: What is EditorConfig (IntelliCode)?
  prefs: []
  type: TYPE_NORMAL
- en: There’s a difference between the `.editorconfig` file with the default options,
    whereas the IntelliCode choice analyzes your project and generates an `.editorconfig`
    file from the conventions it observes in your current code. Both are viable options
    for creating a starting point for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which option you selected, you may need to select which folder
    the `.editorconfig` file should live in. If you’re prompted, select the default
    choice of the `Packt.FlightQueryDecoder` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once this completes, you should see a new `.editorconfig` file present in your
    project in **Solution Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on to work with this `.editorconfig` file, it’s worth pointing
    out that the `.editorconfig` file based on your current code style choices. This
    allows you to customize your styles and then create an `.editorconfig` file out
    of these choices.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an `.editorconfig` file, let’s customize it.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing EditorConfigs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Double-click on the `.editorconfig` file to open its properties view.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see an editor with tabs allowing you to customize various properties
    related to white space, code style, naming style, and Roslyn Analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of options here, so we’ll focus on just a few very specific
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Code Style** tab and then scroll down to the bottom for the **var**
    **preferences** group.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can state your team’s preferences and the severity of violations
    of those preferences. For example, if your team wants to avoid `var`, you could
    set all three `var` rules to **Prefer explicit type** and increase the severity
    to **Warning** or **Error**, as shown in *Figure 16**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Customizing the var preferences for your project](img/B21324_16_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Customizing the var preferences for your project
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file and go back into `FlightQueryParser.cs`, and you should now
    see warnings and errors in your editor for violations of these rules, as seen
    in *Figure 16**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Visual Studio warnings against using var based on code style
    rules](img/B21324_16_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 – Visual Studio warnings against using var based on code style rules
  prefs: []
  type: TYPE_NORMAL
- en: 'These rule violations do not cause your code to not compile but they do appear
    in the **Error List** view, as shown in *Figure 16**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Code violations appearing in Error List](img/B21324_16_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – Code violations appearing in Error List
  prefs: []
  type: TYPE_NORMAL
- en: Because `.editorconfig` files are added to source control when you commit your
    code, other developers on your team will pull down that file and see the exact
    same styling preferences and warnings you see on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: This makes code standards apparent during the development process and reduces
    the odds of a peer review of important code changes breaking down into a discussion
    of the appropriate placement of opening curly braces or the use of `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code standards are important for helping your team focus on productive things
    and ensuring source code can be easily maintained by all developers on your team.
  prefs: []
  type: TYPE_NORMAL
- en: While code standards don’t need to include everything, it can be helpful to
    codify stances on commonly contested items or best practices your team wants to
    make sure absolutely every change follows.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio provides a number of features that help ensure a consistent and
    high-quality codebase including code formatting, code cleanup profiles, formatting
    on save, code analysis warning profiles, code styles at the editor level, and
    EditorConfigs to configure code styles inside of your editor.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter of this book, we’ll discuss refactoring code as part of
    a larger organization and as part of an agile software development team.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you determine what code standards your team should adopt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some ways you can handle disagreements on style rules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some options for configuring how Visual Studio formats code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the **New EditorConfig (IntelliCode)** option do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about materials from this chapter at these URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Framework design* *guidelines*: [https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET coding style* *guidelines*: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Create portable, custom editor settings with* *EditorConfig*: [https://learn.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options](https://learn.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginner friendly EditorConfig* *settings*: [https://newdevsguide.com/2022/11/22/beginner-friendly-csharp/](https://newdevsguide.com/2022/11/22/beginner-friendly-csharp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using EditorConfig in VS Code with C# Dev* *Kit*: [https://code.visualstudio.com/docs/csharp/formatting-linting#_how-to-support-editorconfig-with-c-dev-kit](https://code.visualstudio.com/docs/csharp/formatting-linting#_how-to-support-editorconfig-with-c-dev-kit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using EditorConfig in JetBrains* *Rider*:[https://www.jetbrains.com/help/rider/Using_EditorConfig.html](https://www.jetbrains.com/help/rider/Using_EditorConfig.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
