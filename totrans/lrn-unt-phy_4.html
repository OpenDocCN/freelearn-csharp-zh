<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Rigidbody Types and Their Properties</h1></div></div></div><p class="calibre8">In this chapter, we will learn about the types of Rigidbody components and their properties. To detect collision, add gravity, and several other Physics functionalities, a game object must have a Rigidbody component.</p><p class="calibre8">In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Types of Rigidbody components</li><li class="listitem">Properties of Rigidbody components</li><li class="listitem">Example using Rigidbody components</li></ul></div><p class="calibre8">We can handle a Rigidbody component using a script as well as by manually applying linear and angular velocity.</p><div><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre8">For accurate Physics calculation, a Rigidbody component requires a collider component.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec20" class="calibre1"/>Types of Rigidbody components</h1></div></div></div><p class="calibre8">We enable our game objects to<a id="id156" class="calibre1"/> act under the control of Physics using Rigidbodies. Here, we will learn how to use and handle a Rigidbody component. A Rigidbody can be handled in two ways:</p><div><ul class="itemizedlist"><li class="listitem">Physics Rigidbody</li><li class="listitem">Kinematic Rigidbody</li></ul></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec18" class="calibre1"/>Physics Rigidbody</h2></div></div></div><p class="calibre8">To influence a <a id="id157" class="calibre1"/>game <a id="id158" class="calibre1"/>object by gravity or forces, the game object must have a Rigidbody. When a Rigidbody is completely controlled by the engine, it is called a Physics Rigidbody. We can manually apply forces and torque to handle linear and angular velocity of a game object. Manual implementation of forces and torque gives you the freedom to get the desired effect. Let's look at an example of a Rigidbody.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec23" class="calibre1"/>An example of creating a Physics Rigidbody </h3></div></div></div><p class="calibre8">Use the following steps to<a id="id159" class="calibre1"/> apply a Physics Rigidbody:</p><div><ol class="orderedlist"><li class="listitem" value="1">We will start by creating a new scene and save it as <code class="email">Physics Rigidbody</code>.</li><li class="listitem" value="2">Create a <strong class="calibre9">Cube</strong> game object, as shown in the following screenshot:<div><img src="img/00044.jpeg" alt="An example of creating a Physics Rigidbody" class="calibre11"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">To enable our game objects to act under the control of Physics, we use Rigidbodies. Add the <strong class="calibre9">Rigidbody</strong> component to the cube game object, as shown in the following screenshot:<div><img src="img/00045.jpeg" alt="An example of creating a Physics Rigidbody" class="calibre11"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">In the <strong class="calibre9">Inspector</strong><a id="id160" class="calibre1"/> panel, make sure that the <strong class="calibre9">Is Kinematic</strong> property is unchecked. If we enable <strong class="calibre9">Is Kinematic</strong>, the object can only be manipulated by its Transform property. Generally, we use this for moving platforms or if we want to animate a Rigidbody that has a HingeJoint attached.<div><img src="img/00046.jpeg" alt="An example of creating a Physics Rigidbody" class="calibre11"/></div><p class="calibre14"> </p></li></ol><div></div><p class="calibre8">As shown in the previous <a id="id161" class="calibre1"/>steps, we can get the desired effect using the different properties.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec19" class="calibre1"/>Kinematic Rigidbody</h2></div></div></div><p class="calibre8">When we check the <strong class="calibre9">Is Kinematic</strong> property of a<a id="id162" class="calibre1"/> Rigidbody, it is known as a Kinematic Rigidbody. We cannot apply forces or torque manually to a Kinematic Rigidbody. We<a id="id163" class="calibre1"/> can move a Kinematic Rigidbody by changing the values of a GameObject's Transform component. This is useful for moving platforms or animated HingeJoint GameObjects where the engine does not handle the object directly and where we can manipulate its Transform property as per our requirement.</p><div><img src="img/00047.jpeg" alt="Kinematic Rigidbody" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We can use this property by checking it in the <strong class="calibre9">Inspector</strong> panel, as shown in the previous screenshot. Now, we will learn about the properties of a Rigidbody and their implementation.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec21" class="calibre1"/>Properties of Rigidbody components</h1></div></div></div><p class="calibre8">Let's get familiar with the properties<a id="id164" class="calibre1"/> of a Rigidbody:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Mass</strong>: If we look at the <strong class="calibre9">Inspector</strong> panel of a Rigidbody component, we will see <strong class="calibre9">Mass</strong><a id="id165" class="calibre1"/> as one of the listed properties. This property of a Rigidbody defines the mass that should be based on the relative size and density of the object that is attached to it. The mass of a Rigidbody defines how much force is required to move the Rigidbody fast or slow. We can calculate the force using Newton's law of motion as follows:<p class="calibre16">
<em class="calibre10">F=ma</em>, that is, Force = Mass x Acceleration</p></li><li class="listitem"><strong class="calibre9">Drag</strong>: This <a id="id166" class="calibre1"/>property defines the linear velocity due to air resistance. For example, if we need to add an outer-space behavior to a game object, we set this value as <code class="email">0</code>. An object with mass <code class="email">1</code> should have a <strong class="calibre9">Drag</strong> value of <code class="email">998</code> to resist the force of gravity.</li><li class="listitem"><strong class="calibre9">Angular Drag</strong>: This <a id="id167" class="calibre1"/>property defines the angular velocity due to air resistance. For example, if we need to add an infinitely-spinning-unless-used external force behavior on a game object, we set this value as <code class="email">0</code>.</li><li class="listitem"><strong class="calibre9">Use Gravity</strong>: If we <a id="id168" class="calibre1"/>want our game object to be affected by gravity, we use this behavior.</li><li class="listitem"><strong class="calibre9">Is Kinematic</strong>: To add <a id="id169" class="calibre1"/>kinematic behavior, we set this to true. By setting its behavior to true, we can directly change the position and orientation of the Rigidbody using its Transform properties.</li><li class="listitem"><strong class="calibre9">Interpolate</strong>: Using<a id="id170" class="calibre1"/> this property, we make a Rigidbody move smoothly. We can adjust the <strong class="calibre9">Interpolate</strong> method using <strong class="calibre9">None</strong>, <strong class="calibre9">Interpolate</strong>, and <strong class="calibre9">Extrapolate</strong>, as seen in the following screenshot:<div><img src="img/00048.jpeg" alt="Properties of Rigidbody components" class="calibre11"/></div><p class="calibre14"> </p><p class="calibre16">Using <strong class="calibre9">None</strong>, no interpolation is applied; using <strong class="calibre9">Interpolate</strong>, we smoothly transform based on its previous frame; and in <strong class="calibre9">Extrapolate</strong>, we <a id="id171" class="calibre1"/>smoothly transform based on its estimated next frame.</p></li><li class="listitem"><strong class="calibre9">Collision Detection</strong>: Using <a id="id172" class="calibre1"/>this property, we can determine how the Rigidbody will perform collision detection with other Rigidbodies. This property consists of the following subproperties:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre9">Discreet</strong>: By setting <a id="id173" class="calibre1"/>this property, we use the simplest form of collision detection. At each frame, an intersection test is done. The drawback of this property is that small, fast moving objects will pass directly through solid objects.</li><li class="listitem"><strong class="calibre9">Continuous</strong>: By setting<a id="id174" class="calibre1"/> this property, a Rigidbody performs continuous collision detection against all the other static colliders.</li><li class="listitem"><strong class="calibre9">Continuous Dynamic</strong>: By <a id="id175" class="calibre1"/>setting this property, a Rigidbody detects the collision with fast moving objects.</li></ul></div></li><li class="listitem"><strong class="calibre9">Constraints</strong>: This property<a id="id176" class="calibre1"/> is used for Physics Rigidbodies. Using this property, we can make the position and orientation of a <a id="id177" class="calibre1"/>Rigidbody constraint. This property consists of the following subproperties:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre9">FreezePosition</strong>: By <a id="id178" class="calibre1"/>setting this property, a Rigidbody constrains the linear motion</li><li class="listitem"><strong class="calibre9">FreezeRotation</strong>: By setting this<a id="id179" class="calibre1"/> property, the rotation of a Rigidbody is prevented</li></ul></div></li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec22" class="calibre1"/>Example using a Rigidbody</h1></div></div></div><p class="calibre8">Let's assume that in our<a id="id180" class="calibre1"/> game, we require a cube to be our character. In this case, we won't be using the character controller. Let's follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new scene and save it as <code class="email">Rigidbody example</code>.</li><li class="listitem" value="2">As shown in the following screenshot, create a <strong class="calibre9">Plane</strong> game object and set its properties to position <code class="email">0</code> (all axes), rotation <code class="email">0</code> (all axes), and scale <code class="email">20</code>, <code class="email">1</code>, <code class="email">20 </code>for the <em class="calibre10">x</em>, <em class="calibre10">y</em>, and <em class="calibre10">z</em> axes respectively:<div><img src="img/00049.jpeg" alt="Example using a Rigidbody" class="calibre11"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Add a <strong class="calibre9">Cube</strong> game<a id="id181" class="calibre1"/> object and a Rigidbody Collider. Place it above the plane.</li><li class="listitem" value="4">As shown in the following screenshot, add material to the red cube:<div><img src="img/00050.jpeg" alt="Example using a Rigidbody" class="calibre11"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Create another <a id="id182" class="calibre1"/><strong class="calibre9">Cube</strong> game object. I have used a white cube without a Rigidbody.</li><li class="listitem" value="6">Create another <strong class="calibre9">Cube</strong> object without a Rigidbody. I have used a blue cube, as shown in the following screenshot, and have set the <strong class="calibre9">Is Trigger</strong> property to true:<div><img src="img/00051.jpeg" alt="Example using a Rigidbody" class="calibre11"/></div><p class="calibre14"> </p><p class="calibre16">In the <a id="id183" class="calibre1"/>preceding screenshot, we have set the <strong class="calibre9">Is Trigger</strong> property in the blue cube.</p></li><li class="listitem" value="7">Create a new script and save it as <code class="email">TriggerController.js</code>; add it to the <strong class="calibre9">Trigger Collider</strong> game object and put the following code inside it:<div><pre class="programlisting">functionOnTriggerEnter( other : Collider )
{
  Debug.Log("OnTrigger Event");
}

functionOnTriggerExit( other : Collider )
{
  Debug.Log("OnTriggerExit Event");
}</pre></div><p class="calibre16">The preceding code will show the logon events in the console window: <strong class="calibre9">OnTriggerEnter</strong> and <strong class="calibre9">OnTriggerExit</strong>.</p></li><li class="listitem" value="8">Let's move to the next step. Create a new script and save it as <code class="email">RigidbodyController.js</code>. Add it to the <strong class="calibre9">Red Cube</strong> game object, as shown in the following screenshot:<div><img src="img/00052.jpeg" alt="Example using a Rigidbody" class="calibre11"/></div><p class="calibre14"> </p></li></ol><div></div><p class="calibre8">Add the following <a id="id184" class="calibre1"/>code to the <code class="email">RigidbodyController.js</code> script file:</p><div><pre class="programlisting">#pragma strict
@scriptRequireComponent(Rigidbody) 
/******* RequirementComponent ensure there should be a Rigid body as it asks for Rigidbody as required component/ 
privatevaronPlane = false; 
// Multiply the velocity when using the velocity.
varvelocityMultiplier = 100.0f;
// Multiply the move distance.
varmoveMultiplier= 8.0f;
// Multiply the force to make the cube jump.
varjumpMultiplier= 700.0f;


functionFixedUpdate(){
// Calculate the velocity/move direction based on the user input.
  varmoveDirection = Vector3( Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical") ) * Time.deltaTime;
moveDirection = Camera.main.transform.TransformDirection( moveDirection );
// Here TransformDirection transforms direction from local space
// to world space.

  if ( rigidbody != null &amp;&amp; !rigidbody.isKinematic )
    {
    rigidbody.MovePosition( rigidbody.position + ( moveDirection * moveMultiplier ) );
rigidbody.velocity = Vector3( 0, rigidbody.velocity.y, 0 );

  }

if ( Input.GetButtonDown("Jump") &amp;&amp;onPlane )
  {

    rigidbody.AddForce( Vector3.up * jumpMultiplier );
     }

}



functionOnCollisionStay(collisionInfo : Collision)
{
  onPlane = true;
}


functionOnCollisionExit( collisionInfo : Collision )
{
onPlane = false;

}</pre></div><p class="calibre8">Run the project<a id="id185" class="calibre1"/> and you will see the Rigidbody actions on the red cube by clicking on the <strong class="calibre9">Jump</strong> button.</p><p class="calibre8">In the preceding example, we have learned how to apply actions on a Rigidbody using scripts.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we have learned about the types of Rigidbodies and their properties. We have seen the properties and uses of the Physics Rigidbody and Is Kinematic Rigidbody. We have learned how to implement actions on them using scripts. In the next chapter, we will learn about the types of joints and their properties. We will also see how we can implement joints on the game objects using different examples.</p></div></body></html>