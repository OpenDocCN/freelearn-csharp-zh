- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing, Debugging, and Testing Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about writing functions to reuse code, debugging logic errors
    during development, unit testing your code to remove bugs, and improving stability
    and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: In an optional online-only section, you will learn about logging exceptions
    during runtime. You can find information on this at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging during development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot reloading during development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing and catching exceptions in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fundamental principle of programming is **don’t repeat yourself** (**DRY**).
  prefs: []
  type: TYPE_NORMAL
- en: While programming, if you find yourself writing the same statements over and
    over again, then turn those statements into a **function**. Functions are like
    tiny programs that complete one small task. For example, you might write a function
    to calculate sales tax and then reuse that function in many places in a financial
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Like programs, functions usually have inputs and outputs. They are sometimes
    described as black boxes, where you feed in some raw materials at one end and
    a manufactured item emerges at the other. Once created and thoroughly debugged
    and tested, you don’t need to think about how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring top-level programs, functions, and namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Hello, C#! Welcome, .NET!*, we learned that since C# 10 and
    .NET 6, the default project template for console apps uses the top-level program
    feature introduced with C# 9.
  prefs: []
  type: TYPE_NORMAL
- en: Once you start writing functions, it is important to understand how they work
    with the automatically generated `Program` class and its `<Main>$` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how the top-level program feature works when you define functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new solution and project, as defined
    in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project template**: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project file and folder**: `TopLevelFunctions`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution file and folder**: `Chapter04`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT** (**ahead-of-time**) **publish**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, define a local function at
    the bottom of the file, and call it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Functions do not need to be at the bottom of the file, but
    it is good practice rather than mixing them up with other top-level statements.
    Types, like classes, *must* be declared at the bottom of the `Program.cs` file
    rather than in the middle of the file or you will see the compiler error `CS8803`,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803).
    It would be better to define types like classes in a separate file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app and note that the namespace for the `Program` class is
    `null`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is automatically generated for a local function?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compiler automatically generates a `Program` class with a `<Main>$` function,
    then moves your statements and function inside the `<Main>$` method, which makes
    the function local, and renames the function, as shown highlighted in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the compiler to know what statements need to go where, you must follow
    some rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Import statements (`using`) must go at the top of the `Program.cs` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that will go in the `<Main>$` function can be mixed with functions
    in the middle of the `Program.cs` file. Any functions will become **local functions**
    in the `<Main>$` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is important because local functions have limitations, such as
    they cannot have XML comments to document them.
  prefs: []
  type: TYPE_NORMAL
- en: If the contents of the file which is code were the .NET SDK or some other tool
    that generated this code, then the code would need to be in a source code file
    that the compiler would then find in the filesystem and compile it. Because this
    code is generated by the compiler itself, there is no need for a source code file.
    The only way to discover what the compiler does is to use a decompiler on the
    assembly and reverse engineer the original code. You can also throw exceptions
    in the functions and methods to see some of the information, as I showed in *Chapter
    1*, *Hello, C#! Welcome, .NET!*.
  prefs: []
  type: TYPE_NORMAL
- en: You are about to see some C# keywords like `static` and `partial`, which will
    be formally introduced in *Chapter 5*, *Building Your Own Types with Object-Oriented
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a partial Program class with a static function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A better approach is to write any functions in a separate file and define them
    as `static` members of the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Functions.cs`. The name of this file does
    not actually matter but using this naming convention is sensible. You could name
    the file `Gibberish.cs` and it would have the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, delete any existing statements and then add statements
    to define a `partial Program` class. Cut and paste the `WhatsMyNamespace` function
    to move it from `Program.cs` into `Program.Functions.cs`, and then add the `static`
    keyword to the function, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, confirm that its entire content is now just three statements,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console app and note that it has the same behavior as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is automatically generated for a static function?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use a separate file to define a `partial Program` class with `static`
    functions, the compiler defines a `Program` class with a `<Main>$` function and
    merges your function as a member of the `Program` class, as shown in the following
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Solution Explorer** shows that your `Program.Functions.cs` class file merges
    its `partial Program` with the auto-generated `partial Program` class, as shown
    in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Solution Explorer showing the merged partial Program class'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Create any functions that you will call in `Program.cs`
    in a separate file and manually define them inside a `partial Program` class.
    This will merge them into the automatically generated `Program` class *at the
    same level* as the `<Main>$` method, instead of as local functions *inside* the
    `<Main>$` method.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note the lack of namespace declarations. Both the automatically
    generated `Program` class and the explicitly defined `Program` class are in the
    default `null` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Do not define a namespace for your `partial Program` class. If
    you do, it will be in a different namespace and therefore will not merge with
    the auto-generated `partial Program` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, all the `static` methods in the `Program` class could be explicitly
    declared as `private` but this is the default anyway. Since all the functions
    will be called within the `Program` class itself, the access modifier is not important.
  prefs: []
  type: TYPE_NORMAL
- en: Times table example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that you want to help your child learn their times tables, so you
    want to make it easy to generate a times table for a number, such as the 7 times
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Most times tables have 10, 12, or 20 rows, depending on how advanced the child
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned about the `for` statement earlier in this book, so you know that
    it can be used to generate repeated lines of output when there is a regular pattern,
    such as a 7 times table with 12 rows, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, instead of always outputting the 7 times table with 12 rows, we want
    to make this more flexible so it can output times tables of any size for any number.
    We can do this by creating a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore functions by creating one to output any times table for numbers
    0 to 255 of any size up to 255 rows (but it defaults to 12 rows):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WritingFunctions`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter04`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `WritingFunctions.csproj`, after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to statically import `System.Console` for all C# files using
    the implicit usings .NET SDK feature, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class file to the project named `Program.Functions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, replace any existing code with new statements to
    define a function named `TimesTable` in the `partial` `Program` class, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TimesTable` must have a `byte` value passed to it as a parameter named `number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` can optionally have a `byte` value passed to it as a parameter
    named `size`. If a value is not passed, it defaults to `12`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` is a `static` method because it will be called by the `static`
    method `<Main>$`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` does not return a value to the caller, so it is declared with
    the `void` keyword before its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` uses a `for` statement to output the times table for the `number`
    passed to it with its number of rows equal to `size`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then call the function.
    Pass in a `byte` value for the `number` parameter, for example, `7`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and then view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `size` parameter to `20`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console app and confirm that the times table now has 20 rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: If a function has one or more parameters where just passing
    the values may not provide enough meaning, then you can optionally specify the
    name of the parameter as well as its value, as shown in the following code: `TimesTable(number:
    7, size: 10)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Change the number passed into the `TimesTable` function to other `byte` values
    between `0` and `255` and confirm that the output times tables are correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that if you try to pass a non-`byte` number, for example, an `int`, `double`,
    or `string`, an error is returned, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A brief aside about arguments and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In daily usage, most developers will use the terms **argument** and **parameter**
    interchangeably. Strictly speaking, the two terms have specific and subtly different
    meanings. But just like a person can be both a parent and a doctor, the two terms
    often apply to the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *parameter* is a variable in a function definition. For example, `startDate`
    is a parameter of the `Hire` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When a method is called, an *argument* is the data you pass into the method’s
    parameters. For example, `when` is a variable passed as an argument to the `Hire`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You might prefer to specify the parameter name when passing the argument, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When talking about the call to the `Hire` function, `startDate` is the parameter,
    and `when` is the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you read the official Microsoft documentation, they use the phrases **named
    and optional arguments** and **named and optional parameters** interchangeably,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets complicated because a single object can act as both a parameter and
    an argument, depending on the context. For example, within the `Hire` function
    implementation, the `startDate` parameter could be passed as an argument to another
    function like `SaveToDatabase`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Naming things is one of the hardest parts of computing. A classic example is
    the parameter to the most important function in C#, `Main`. It defines a parameter
    named `args`, short for arguments, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, parameters define inputs to a function; arguments are passed to
    a function when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Try to use the correct term depending on the context, but
    do not get pedantic with other developers if they “misuse” a term. I must have
    used the terms **parameter** and **argument** thousands of times in this book.
    I’m sure some of those times I’ve been imprecise. Please do not @ me about it.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a function that returns a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous function performed actions (looping and writing to the console),
    but it did not return a value. Let’s say that you need to calculate sales or **value-added
    tax** (**VAT**). In Europe, VAT rates can range from 8% in Switzerland to 27%
    in Hungary. In the **United States** (**US**), state sales taxes can range from
    0% in Oregon to 8.25% in California.
  prefs: []
  type: TYPE_NORMAL
- en: Tax rates change all the time, and they vary based on many factors. The values
    used in this example do not need to be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement a function to calculate taxes in various regions around the
    world:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, in the `Program` class, write a function named `CalculateTax`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CalculateTax` has two inputs: a parameter named `amount`, which will be the
    amount of money spent, and a parameter named `twoLetterRegionCode`, which will
    be the region where the amount is spent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculateTax` will perform a calculation using a `switch` expression and then
    return the sales tax or VAT owed on the amount as a `decimal` value; so, before
    the name of the function, we have declared the data type of the return value to
    be `decimal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the top of `Program.Functions.cs`, import the namespace to work with cultures,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, in the `Program` class, write a function named `ConfigureConsole`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function enables UTF-8 encoding for the console output. This is necessary
    to output some special symbols like the Euro currency symbol. This function also
    controls the current culture used to format dates, times, and currency values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out any `TimesTable` method calls, and then call the
    `ConfigureConsole` method and the `CalculateTax` method, passing values for the
    amount, such as `149`, and a valid region code, such as `FR`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that it uses the US English culture,
    meaning US dollars for the currency, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, change the `ConfigureConsole` method to use your local computer
    culture, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the currency should now show your
    local currency. For example, for me in the UK, I would see `£29.80`, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, change the `ConfigureConsole` method to use the French culture,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the currency should now show Euros,
    as used in France, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can you think of any problems with the `CalculateTax` function as written? What
    would happen if the user entered a code such as `fr` or `UK`? How could you rewrite
    the function to improve it? Would using a `switch` *statement* instead of a `switch`
    *expression* be clearer?
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers from cardinal to ordinal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numbers that are used to count are called **cardinal** numbers, for example,
    1, 2, and 3, whereas numbers used to order are **ordinal** numbers, for example,
    1st, 2nd, and 3rd. Let’s create a function to convert cardinals to ordinals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `CardinalToOrdinal` that
    converts a cardinal `uint` value into an ordinal `string` value; for example,
    it converts the `uint` value of `1` into the `string` value `"1st"`, the `uint`
    value of `2` into the `string` value of `"2nd"`, and so on, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CardinalToOrdinal` has one input, a parameter of the `uint` type named `number`,
    because we do not want to allow negative numbers, and one output: a return value
    of the `string` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `switch` *statement* is used to handle the special cases of `11`, `12`, and
    `13`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `switch` *expression* then handles all other cases: if the last digit is
    `1`, then use `st` as the suffix; if the last digit is `2`, then use `nd` as the
    suffix; if the last digit is `3`, then use `rd` as the suffix; and if the last
    digit is anything else, then use `th` as the suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `RunCardinalToOrdinal` that
    uses a `for` statement to loop from 1 to 150, calling the `CardinalToOrdinal`
    function for each number and writing the returned `string` to the console, separated
    by a space character, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the `CalculateTax` statements and call the `RunCardinalToOrdinal`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `RunCardinalToOrdinal` function, change the maximum number to `1500`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calculating factorials with recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factorial of 5 is 120 because factorials are calculated by multiplying
    the starting number by one less than itself, and then by one less again, and so
    on until the number is reduced to 1\. An example can be seen here: 5 x 4 x 3 x
    2 x 1 = 120.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The factorial function is defined for non-negative integers only, i.e., for
    0, 1, 2, 3, and so on, and it is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We could leave it to the compiler to reject negative numbers by declaring the
    input parameter as `uint` as we did for the `CardinalToOrdinal` function, but
    this time, let’s see an alternative way to handle that: throwing an argument exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Factorials are written like this: `5!`, where the exclamation mark is read
    as “bang,” so `5!` = 120, or *five bang equals one hundred and twenty*. Bang is
    a good term to use in the context of factorials because they increase in size
    very rapidly, just like an explosion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a function named `Factorial`; this will calculate the factorial
    for an `int` passed to it as a parameter. We will use a clever technique called
    **recursion**, which refers to a function that calls itself within its implementation,
    either directly or indirectly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `Factorial`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As before, there are several noteworthy elements in the preceding code, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the input parameter `number` is negative, `Factorial` throws an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input parameter `number` is `0`, `Factorial` returns `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input parameter `number` is more than `0` (which it will be in all other
    cases), `Factorial` multiplies the number by the result of calling itself and
    passing one less than `number`. This makes the function recursive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More Information**: Recursion is clever but it can lead to problems, such
    as a stack overflow due to too many function calls because memory is used to store
    data on every function call, and it eventually uses too much. Iteration is a more
    practical, if less succinct, solution in languages such as C#. You can read more
    about this at the following link: [https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `RunFactorial` that uses
    a `for` statement to output the factorials of numbers from 1 to 15, calls the
    `Factorial` function inside its loop, and then outputs the result, formatted using
    the code `N0`, which refers to a number format using thousand separators with
    zero decimal places, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the `RunCardinalToOrdinal` method call and call the `RunFactorial`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the project and view the results, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is not immediately obvious in the previous output, but factorials of 13 and
    higher overflow the `int` type because they are so big. `12!` is 479,001,600,
    which is about half a billion. The maximum positive value that can be stored in
    an `int` variable is about two billion. `13!` is 6,227,020,800, which is about
    six billion, and when stored in a 32-bit integer, it overflows silently without
    showing any problems.
  prefs: []
  type: TYPE_NORMAL
- en: What should you do to get notified when an overflow happens? Of course, we could
    solve the problem for `13!` and `14!` by using a `long` (64-bit integer) instead
    of an `int` (32-bit integer), but we will quickly hit the overflow limit again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of this section is to understand and show you that numbers can overflow,
    and not specifically how to calculate factorials higher than `12!`. Let’s take
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Factorial` function to check for overflows in the statement that
    calls itself, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `RunFactorial` function to change the starting number to `-2` and
    to handle overflow and other exceptions when calling the `Factorial` function,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Documenting functions with XML comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when calling a function such as `CardinalToOrdinal`, code editors
    will show a tooltip with basic information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s improve the tooltip by adding extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using VS Code with the **C#** extension, you should navigate to
    **View** | **Command Palette** | **Preferences: Open Settings (UI)**, and then
    search for `formatOnType` and make sure that it is enabled. C# XML documentation
    comments are a built-in feature of Visual Studio and Rider, so you do not need
    to do anything to use them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the line above the `CardinalToOrdinal` function, type three forward slashes,
    `///`, and note that they are expanded into an XML comment that recognizes that
    the function has a single parameter named `number`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter suitable information for the XML documentation comment for the `CardinalToOrdinal`
    function. Add a summary and describe the input parameter and the return value,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when calling the function, you will see more details, as shown in *Figure
    4.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: A tooltip showing the more detailed method signature'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth emphasizing that this feature is primarily designed to be used
    with a tool that converts the comments into documentation, like Sandcastle, which
    you can read more about at the following link: [https://github.com/EWSoftware/SHFB](https://github.com/EWSoftware/SHFB).
    The tooltips that appear while entering code or hovering over the function name
    are a secondary feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Local functions do not support XML comments because local functions cannot be
    used outside the member in which they are declared, so it makes no sense to generate
    documentation from them. Sadly, this also means no tooltip, which would still
    be useful, but neither Visual Studio nor VS Code recognizes that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Add XML documentation comments to all your functions except
    your local functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using lambdas in function implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**F#** is Microsoft’s strongly typed functional-first programming language
    that, like C#, compiles to **Intermediate Language** (**IL**) to be executed by
    .NET. Functional languages evolved from lambda calculus, a computational system
    based only on functions. The code looks more like mathematical functions than
    steps in a recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important attributes of functional languages are defined in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity**: The same benefit of defining functions in C# applies to functional
    languages. This breaks up a large, complex code base into smaller pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutability**: Variables in the C# sense do not exist. Any data value inside
    a function cannot change. Instead, a new data value can be created from an existing
    one. This reduces bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Functional code is cleaner and clearer (for mathematically
    inclined programmers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since C# 6, Microsoft has worked to add features to the language to support
    a more functional approach, for example, adding **tuples** and **pattern matching**
    in C# 7, **non-null reference types** in C# 8, and improving pattern matching
    and adding records, that is, potentially **immutable objects**, in C# 9.
  prefs: []
  type: TYPE_NORMAL
- en: In C# 6, Microsoft added support for **expression-bodied function members**.
    We will look at an example of this now. In C#, lambdas are the use of the `=>`
    character to indicate a return value from a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Fibonacci sequence** of numbers always starts with 0 and 1\. Then, the
    rest of the sequence is generated using the rule of adding together the previous
    two numbers, as shown in the following sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The next term in the sequence would be 34 + 55, which is 89.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Fibonacci sequence to illustrate the difference between an
    imperative and declarative function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `FibImperative`, which will
    be written in an imperative style, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, write a function named `RunFibImperative` that calls
    `FibImperative` inside a `for` statement that loops from 1 to 30, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment out the other method calls and call the `RunFibImperative`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and view the results, as shown in the following partial
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, write a function named `FibFunctional` written in
    a declarative style, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, write a function to call it inside a `for` statement
    that loops from 1 to 30, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment out the `RunFibImperative` method call and call the
    `RunFibFunctional` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and view the results (which will be the same as before).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have seen some examples of functions, let’s see how you can fix
    them when they have bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging during development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to debug problems at development time. You
    must use a code editor that has debugging tools, such as Visual Studio or VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code with a deliberate bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore debugging by creating a console app with a deliberate bug, which
    we will then use the debugger tools in your code editor to track down and fix:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Debugging` to the `Chapter04` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `Debugging.csproj` to statically import `System.Console` for all code
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete any existing statements, and then, at the bottom of
    the file, add a function with a deliberate bug, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the `Add` function, write statements to declare and set some variables
    and then add them together using the buggy function, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console application and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But wait, there’s a bug! 4.5 added to 2.5 should be 7, not 11.25!
  prefs: []
  type: TYPE_NORMAL
- en: We will use the debugging tools to hunt for and squish the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a breakpoint and starting debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints allow us to mark a line of code that we want to pause at to inspect
    the program state and find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s set a breakpoint and then start debugging using Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Click in line 1, which is the statement that declares the variable named `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to **Debug** | **Toggle Breakpoint** or press *F9*. A red circle will
    appear in the margin bar on the left-hand side and the statement will be highlighted
    in red to indicate that a breakpoint has been set, as shown in *Figure 4.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Toggling breakpoints using Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off or right-click a breakpoint to
    see more options, such as delete, disable, or edit conditions, or actions for
    an existing breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Debug** | **Start Debugging** or press *F5*. Visual Studio starts
    the console application and then pauses when it hits the breakpoint. This is known
    as *break mode*. Extra windows titled **Locals** (showing the current values of
    local variables), **Watch 1** (showing any watch expressions you have defined),
    **Call Stack**, **Exception Settings**, and **Immediate Window** may appear. The
    **Debugging** toolbar appears. The line that will be executed next is highlighted
    in yellow, and a yellow arrow points at the line from the margin bar, as shown
    in *Figure 4.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Break mode in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to see how to use VS Code to start debugging, then you can
    skip the *Using VS Code* section and continue to the section titled *Navigating
    with the debugging toolbar*.
  prefs: []
  type: TYPE_NORMAL
- en: Using VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s set a breakpoint and then start debugging using VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Click in line 1, which is the statement that declares the variable named `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** | **Toggle Breakpoint** or press *F9*. A red circle will
    appear in the margin bar on the left-hand side to indicate that a breakpoint has
    been set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off; right-click to see more options,
    such as remove, edit, or disable an existing breakpoint; or add a breakpoint,
    conditional breakpoint, or Logpoint when a breakpoint does not yet exist. **Logpoints**,
    also known as **Tracepoints**, indicate that you want to record some information
    without having to stop executing the code at that point.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **View** | **Run**, or in the left navigation bar, you can click
    the **Run and Debug** icon (the triangle “play” button and “bug”) or press *Ctrl*
    + *Shift* + *D* (on Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the **RUN AND DEBUG** window, click the **Run and Debug** button,
    and then select the **Debugging** project, as shown in *Figure 4.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Selecting the project to debug using VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: If you are first prompted to choose a debugger, select **C#**, not .NET 5+ or
    .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code starts the console app and then pauses when it hits the breakpoint.
    This is known as **break mode**. The line that will be executed next is highlighted
    in yellow, and a yellow block points at the line from the margin bar, as shown
    in *Figure 4.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Break mode in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating with the debugging toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio has two debug-related buttons in its **Standard** toolbar to start
    or continue debugging and to hot reload changes to the running code, and a separate
    **Debug** toolbar for the rest of the tools.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code shows a floating toolbar with buttons to make it easy to access debugging
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both are shown in *Figure 4.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Debugging toolbars in Visual Studio and VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list describes the most common buttons in the toolbars:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start**/**Continue**/*F5*: This button is context-sensitive. It will either
    start running a project or continue running the project from the current position
    until it ends or hits a breakpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hot Reload**: This button will reload compiled code changes without needing
    to restart the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break All**: This button will break into the next available line of code
    in a running app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop Debugging**/**Stop**/*Shift* + *F5* (red square): This button will stop
    the debugging session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restart**/*Ctrl* or *Cmd* + *Shift* + *F5* (circular arrow): This button
    will stop and then immediately restart the program with the debugger attached
    again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Next Statement**: This button will move the current cursor to the next
    statement that will execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Into**/*F11*, **Step Over**/*F10*, and **Step Out**/*Shift* + *F11*
    (blue arrows over dots): These buttons step through the code statements in various
    ways, as you will see in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Threads in Source**: This button allows you to examine and work with
    threads in the application that you’re debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging, both Visual Studio and VS Code show extra windows that allow
    you to monitor useful information, such as variables, while you step through your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful windows are described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VARIABLES**, including **Locals**, which shows the name, value, and type
    of any local variables automatically. Keep an eye on this window while you step
    through your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WATCH**, or **Watch 1**, which shows the value of variables and expressions
    that you manually enter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CALL STACK**, which shows the stack of function calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BREAKPOINTS**, which shows all your breakpoints and allows finer control
    over them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When in break mode, there is also a useful window at the bottom of the edit
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUG CONSOLE**, or **Immediate Window**, enables live interaction with your
    code. You can interrogate the program state, for example, by entering the name
    of a variable. For example, you can ask a question such as “What is 1+2?” by typing
    `1+2` and pressing *Enter*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping through code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore some ways to step through the code using either Visual Studio
    or VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: The menu commands for debugging are on the **Debug** menu in Visual Studio or
    the **Run** menu in VS Code and Rider.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Run** or **Debug** | **Step Into**, click on the **Step Into**
    button in the toolbar, or press *F11*. The yellow highlight steps forward one
    line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** or **Debug** | **Step Over**, click on the **Step Over**
    button in the toolbar, or press *F10*. The yellow highlight steps forward one
    line. At the moment, you can see that there is no difference between using **Step
    Into** or **Step Over** because we are executing single statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be on the line that calls the `Add` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The difference between **Step Into** and **Step Over** can be seen when you
    are about to execute a method call.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **Step Into**, the debugger steps *into* the method so that
    you can step through every line in that method.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **Step Over**, the whole method is executed in one go; it does
    not skip over the method without executing it.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Step Into** to step inside the `Add` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse pointer over the `a` or `b` parameters in the code editing
    window and note that a tooltip appears showing their current value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the expression `a * b`, right-click the expression, and select **Add
    to Watch** or **Add Watch**. The expression is added to the **WATCH** or **Watch
    1** window, showing that this operator is multiplying `a` by `b` to give the result
    `11.25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **WATCH** or **Watch 1** window, right-click the expression and choose
    **Remove Expression** or **Delete Watch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the bug by changing `*` to `+` in the `Add` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart debugging by clicking the circular arrow **Restart** button or pressing
    *Ctrl* or *Cmd* + *Shift* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the function, take a minute to note how it now calculates correctly,
    and click the **Continue** button or press *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With VS Code, note that when writing to the console during debugging, the output
    appears in the **DEBUG CONSOLE** window instead of the **TERMINAL** window, as
    shown in *Figure 4.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Writing to the DEBUG CONSOLE during debugging'
  prefs: []
  type: TYPE_NORMAL
- en: Using the VS Code integrated terminal during debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the console is set to use the internal **DEBUG CONSOLE** during
    debugging, which does not allow interactions like entering text from the `ReadLine`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the experience, we can change the setting to use the integrated
    terminal instead. First, let’s modify the code to require interaction with the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, add statements to prompt the user to enter a number
    and parse that as a `double` into the variable `a`, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set a breakpoint on line 1 that writes the prompt `Enter a number`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **RUN AND DEBUG** window, click the **Run and Debug** button,
    and then select the **Debugging** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `Enter a number` prompt is not written to either **TERMINAL**
    or **DEBUG CONSOLE** and neither window is waiting for the user to enter a number
    and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the **RUN AND DEBUG** window, click the **create a launch.json
    file** link, and then, when prompted for the debugger, select **C#**, as shown
    in *Figure 4.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Selecting a debugger for the launch.json file'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `launch.json` file editor, click the **Add Configuration...** button,
    and then select **.NET: Launch .NET Core Console App**, as shown in *Figure 4.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Adding a launch configuration for a .NET console app'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `launch.json`, make the following additions and changes, as shown highlighted
    in the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the `preLaunchTask` setting.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `program` path, add the `Debugging` project folder after the `workspaceFolder`
    variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `program` path, change `<target-framework>` to `net9.0`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `program` path, change `<project-name.dll>` to `Debugging.dll`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change the `console` setting from `internalConsole` to `integratedTerminal`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that with VS Code, we open the `Chapter04` folder to process the solution
    file, so the workspace folder is `Chapter04`, not the `Debugging` project.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the **RUN AND DEBUG** window, note the drop-down list of launch
    configurations, and click the **Start Debugging** button (green triangle), as
    shown in *Figure 4.11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Terminal** and note the **TERMINAL** window is attached
    to `Debugging.dll`, as shown in *Figure 4.11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the statement that writes `Enter a number:` to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the statement that calls `ReadLine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `5.5` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue stepping through the statements or press *F5* or click **Continue**,
    and note the output written to the integrated terminal, as shown in *Figure 4.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: A launch configuration set to use the integrated terminal for
    user interaction'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to make more complex breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are still debugging, click the **Stop** button in the debugging toolbar,
    navigate to **Run** or **Debug** | **Stop Debugging**, or press *Shift* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** | **Remove All Breakpoints** or **Debug** | **Delete All
    Breakpoints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `WriteLine` statement that outputs the answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a breakpoint by pressing *F9* or navigating to **Run** or **Debug** | **Toggle
    Breakpoint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click the breakpoint and choose the appropriate menu for your code editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, choose **Edit Breakpoint...**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Visual Studio, choose **Conditions...**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type an expression, such as the `answer` variable must be greater than `9`,
    and then press *Enter* to accept it, and note the expression must evaluate to
    `true` for the breakpoint to activate, as shown in *Figure 4.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Customizing a breakpoint with an expression using VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Start debugging and note the breakpoint is not hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the breakpoint or its conditions and change its expression to less than
    `9`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging and note the breakpoint is hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the breakpoint or its conditions (in Visual Studio, click **Add condition**),
    select **Hit Count**, then enter a number such as `3`, meaning that you would
    have to hit the breakpoint three times before it activates, as shown in *Figure
    4.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Customizing a breakpoint with an expression and hit count using
    Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover your mouse over the breakpoint’s red circle to see a summary, as shown
    in *Figure 4.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: A summary of a customized breakpoint in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: You have now fixed a bug using some debugging tools and seen some advanced possibilities
    for setting breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading during development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hot Reload** is a feature that allows a developer to apply changes to code
    while the app is running and immediately see the effect. This is great for fixing
    bugs quickly. Hot Reload is also known as **Edit and Continue**. A list of the
    types of changes you can make that support Hot Reload is found at the following
    link: [https://aka.ms/dotnet/hot-reload](https://aka.ms/dotnet/hot-reload).'
  prefs: []
  type: TYPE_NORMAL
- en: Just before the release of .NET 6, a high-level Microsoft employee caused controversy
    by attempting to make the feature exclusive to Visual Studio. Luckily the open-source
    contingent within Microsoft successfully had the decision overturned. Hot Reload
    remains available using the command-line tool as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `HotReloading` to the `Chapter04` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `HotReloading.csproj` to statically import `System.Console` for all code
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then write a message to
    the console every two seconds, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hot reloading using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, Hot Reload is built into the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, start the project and note that the message is output every
    two seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the project running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, change `Hello` to `Goodbye`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Apply Code Changes** or click the **Hot Reload** button
    in the toolbar, as shown in *Figure 4.15*, and note the change is applied without
    needing to restart the console app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drop down the **Hot Reload** button menu and select **Hot Reload on File Save**,
    as shown in *Figure 4.15*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Changing Hot Reload options'
  prefs: []
  type: TYPE_NORMAL
- en: Change the message again, save the file, and note the console app updates automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hot reloading using VS Code and dotnet watch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using VS Code, you must issue a special command when starting the
    console app to activate Hot Reload:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In VS Code, in **TERMINAL**, start the console app using `dotnet watch`, and
    note the output that shows that Hot Reload is active, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In VS Code, change `Hello` to `Goodbye`, and note that, after a couple of seconds,
    the change is applied without needing to restart the console app, as shown in
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press *Ctrl* + *C* to stop it running, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you’ve seen tools for finding and removing bugs during development,
    let’s see how you can track down less obvious problems that might happen during
    development and production by writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixing bugs in code is expensive. The earlier that a bug is discovered in the
    development process, the less expensive it will be to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a good way to find bugs early in the development process because
    they test a small unit before they are integrated together or seen by user acceptance
    testers. Some developers even follow the principle that programmers should create
    unit tests before they write code, and this is called **test-driven development**
    (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has a proprietary unit testing framework known as **MSTest**. There
    is also a framework named **NUnit**. However, we will use the free and open-source
    third-party framework **xUnit.net**. All three do basically the same thing. xUnit
    was created by the same team that built NUnit, but they fixed the mistakes they
    felt they made previously. xUnit is more extensible and has better community support.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious about the pros and cons of the various testing systems,
    then there are hundreds of articles written by proponents of each. Just google
    them: [https://www.google.com/search?q=xunit+vs+nunit](https://www.google.com/search?q=xunit+vs+nunit).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing is just one of many types of testing, as described in *Table 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Unit | Tests the smallest unit of code, typically a method or function. Unit
    testing is performed on a unit of code isolated from its dependencies by mocking
    them if needed. Each unit should have multiple tests: some with typical inputs
    and expected outputs, some with extreme input values to test boundaries, and some
    with deliberately wrong inputs to test exception handling. |'
  prefs: []
  type: TYPE_TB
- en: '| Integration | Tests if the smaller units and larger components work together
    as a single piece of software. Sometimes involves integrating with external components
    for which you do not have source code. |'
  prefs: []
  type: TYPE_TB
- en: '| System | Tests the whole system environment in which your software will run.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Tests the performance of your software; for example, your code
    must return a web page full of data to a visitor in under 20 milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: '| Load | Tests how many requests your software can handle simultaneously while
    maintaining required performance, for example, 10,000 concurrent visitors to a
    website. |'
  prefs: []
  type: TYPE_TB
- en: '| User Acceptance | Tests if users can happily complete their work using your
    software. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Types of testing'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library that needs testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a function that needs testing. We will create it in a
    class library project separate from a console app project. A class library is
    a package of code that can be distributed and referenced by other .NET applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `CalculatorLib` to the `Chapter04` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you will have created about a dozen new console app projects
    and added them to a solution. The only difference when adding a **Class Library**
    / `classlib` project is selecting a different project template. The rest of the
    steps are the same as adding a **Console App** / `console` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** | **Add** | **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add a new project** dialog, search for and select **Class Library [C#]**
    and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure your new project** dialog, for the **Project name**, enter
    `CalculatorLib`, leave the location as `C:\cs13net9\Chapter04`, and then click
    **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Additional information** dialog, select **.NET 9.0 (Standard Term Support)**,
    and then click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: In **TERMINAL**, switch to a terminal in the `Chapter04` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `dotnet` CLI to create a new class library project named `CalculatorLib`,
    as shown in the following command: `dotnet new classlib -o CalculatorLib`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `dotnet` CLI to add the new project folder to the solution, as shown
    in the following command: `dotnet sln add CalculatorLib`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note the results, as shown in the following output: ``Project `CalculatorLib\CalculatorLib.csproj`
    added to the solution``.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all code editors, in the `CalculatorLib` project, rename the file named
    `Class1.cs` to `Calculator.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Calculator.cs`, modify the file to define a `Calculator` class (with a
    deliberate bug), as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile your class library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Build** | **Build CalculatorLib**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In VS Code, in a **TERMINAL** window for the `CalculatorLib` folder, enter the
    command `dotnet build`. (You could also run this command in the `Chapter04` folder
    but that would build the whole solution, which is unnecessary in this scenario.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **xUnit Test Project [C#]** / `xunit`
    project named `CalculatorLibUnitTests` to the `Chapter04` solution. For example,
    at the command prompt or terminal in the `Chapter04` folder, enter the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `CalculatorLibUnitTests` project, add a project reference to the `CalculatorLib`
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio, in **Solution Explorer**, select the `CalculatorLibUnitTests`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `CalculatorLib` project, and then click **OK**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using VS Code, use the `dotnet add reference` command, or in the
    file named `CalculatorLibUnitTests.csproj`, modify the configuration to add an
    item group with a project reference to the `CalculatorLib` project, as shown highlighted
    in the following markup:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The path for a project reference can use either forward `(/)` or back slashes
    `(\)` because the paths are processed by the .NET SDK and changed if necessary
    for the current operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Build the `CalculatorLibUnitTests` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A well-written unit test will have three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write some unit tests for the `Calculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the file `UnitTest1.cs` to `CalculatorUnitTests.cs` and then open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, rename the class to `CalculatorUnitTests`. (Visual Studio prompts
    you to rename the class when you rename the file.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `CalculatorUnitTests`, import the `CalculatorLib` namespace, and then modify
    the `CalculatorUnitTests` class to have two test methods, one for adding 2 and
    2, and another for adding 2 and 3, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visual Studio still uses an older project item template that uses a nested namespace.
    The preceding code shows the modern project item template used by `dotnet new`
    and Rider that uses a file-scoped namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Build the `CalculatorLibUnitTests` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running unit tests using Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Test** | **Run All Tests**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Test Explorer**, note that the results indicate that two tests ran, one
    test passed, and one test failed, as shown in *Figure 4.16*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: The unit test results in Visual Studio’s Test Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests using VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not recently built the test project, then build the `CalculatorLibUnitTests`
    project to make sure that the new testing feature in the C# Dev Kit extension
    recognizes the unit tests that you have written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, navigate to **View** | **Testing**, and note the **TESTING** window
    has a mini toolbar with buttons to **Refresh Tests**, **Run Tests**, **Debug Tests**,
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **TESTING** window, expand the **CalculatorLibUnitTests** project to
    show the two tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse pointer over **CalculatorUnitTests** and then click the **Run
    Tests** button (black triangle icon) defined in that class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **TEST RESULTS** tab and note that the results indicate that two
    tests ran, one test passed, and one test failed, as shown in *Figure 4.17*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: The unit test results in VS Code’s TEST RESULTS'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the bug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can fix the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: Fix the bug in the `Add` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the unit tests again to see that the bug has now been fixed and both tests
    have passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve written, debugged, logged, and unit-tested functions, let’s finish
    this chapter by looking at how to throw and catch exceptions in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying multiple parameter values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created two unit test methods: the first to test adding 2 and 2, and the
    second to test adding 2 and 3\. Instead of writing two separate methods decorated
    with `[Fact]`, we could have written one method decorated with `[Theory]` and
    passed different parameter values using `[InlineData]`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The order of parameters passed in the `[InlineData]` attribute must match the
    order of parameters in the test method.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to throw and catch exceptions when something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing and catching exceptions in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*,*Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to exceptions and how to use a `try-catch` statement to handle
    them. But you should only catch and handle an exception if you have enough information
    to mitigate the issue. If you do not, then you should allow the exception to pass
    up through the call stack to a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding usage errors and execution errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Usage errors** are when a programmer misuses a function, typically by passing
    invalid values as parameters. They could be avoided by that programmer changing
    their code to pass valid values. When some programmers first learn C# and .NET,
    they sometimes think exceptions can always be avoided because they assume all
    errors are usage errors. Usage errors should all be fixed before production runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution errors** are when something happens at runtime that cannot be fixed
    by writing “better” code. Execution errors can be split into **program errors**
    and **system errors**. If you attempt to access a network resource but the network
    is down, you need to be able to handle that system error by logging an exception,
    and possibly backing off for a time and trying again. However, some system errors,
    such as running out of memory, simply cannot be handled. If you attempt to open
    a file that does not exist, you might be able to catch that error and handle it
    programmatically by creating a new file. Program errors can be programmatically
    fixed by writing smart code. System errors often cannot be fixed programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Commonly thrown exceptions in functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very rarely should you define new types of exceptions to indicate usage errors.
    .NET already defines many that you should use.
  prefs: []
  type: TYPE_NORMAL
- en: When defining your own functions with parameters, your code should check the
    parameter values and throw exceptions if they have values that will prevent your
    function from properly functioning.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a parameter to a function should not be `null`, throw `ArgumentNullException`.
    For other problems, throw `ArgumentException`, `NotSupportedException`, or `InvalidOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any exception, include a message that describes the problem for whoever
    will have to read it (typically a developer audience for class libraries and functions,
    or end users if it is at the highest level of a GUI app), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: If a function cannot successfully perform its operation,
    you should consider it a function failure and report it by throwing an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions using guard clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of instantiating an exception using `new`, you can use static methods
    on the exception itself. When used in a function implementation to check argument
    values, they are known as **guard clauses**. Some were introduced with .NET 6,
    and more were added in .NET 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common guard clauses are shown in *Table 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Exception** | **Guard clause methods** |'
  prefs: []
  type: TYPE_TB
- en: '| `ArgumentException` | `ThrowIfNullOrEmpty`, `ThrowIfNullOrWhiteSpace` |'
  prefs: []
  type: TYPE_TB
- en: '| `ArgumentNullException` | `ThrowIfNull` |'
  prefs: []
  type: TYPE_TB
- en: '| `ArgumentOutOfRangeException` | `ThrowIfEqual`, `ThrowIfGreaterThan`, `ThrowIfGreaterThanOrEqual`,
    `ThrowIfLessThan`, `ThrowIfLessThanOrEqual`, `ThrowIfNegative`, `ThrowIfNegativeOrZero`,
    `ThrowIfNotEqual`, `ThrowIfZero` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2: Common guard clauses'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing an `if` statement and then throwing a `new` exception, we
    can simplify the previous example, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: To get a sense of how often Microsoft source code uses
    its own guard clauses, you can read the following section of an online blog article:
    [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions).
    For example, `ThrowIfNull` is called 4,795 times from within the `src` for the
    core libraries in `dotnet/runtime`.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the call stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entry point for a .NET console application is the `Main` method (if you
    have explicitly defined this class) or `<Main>$` (if it was created for you by
    the top-level program feature) in the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method will call other methods, which call other methods, and so
    on; these methods could be in the current project or referenced projects and NuGet
    packages, as shown in *Figure 4.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_04_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: A chain of method calls that create a call stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a similar chain of methods to explore where we could catch and
    handle exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `CallStackExceptionHandlingLib` to the `Chapter04` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Class1.cs` file to `Processor.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Processor.cs`, modify its contents, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `CallStackExceptionHandling` to the `Chapter04` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `CallStackExceptionHandling` console app project, add a reference to
    the `CallStackExceptionHandlingLib` class library project, as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `CallStackExceptionHandling` console app project to make sure dependent
    projects are compiled and copied to the local `bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, add statements to define two
    methods, and chain calls to them and the methods in the class library, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app *without* the debugger attached, and note the results,
    as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the call stack is upside down. Starting from the bottom, you see:'
  prefs: []
  type: TYPE_NORMAL
- en: The first call is to the `<Main>$` entry point function in the auto-generated
    `Program` class. This is where arguments are passed in as a `String` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second call is to the `<<Main>$>g__Alpha|0_0` function. (The C# compiler
    renames it from `Alpha` when it adds it as a local function.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third call is to the `Beta` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth call is to the `Gamma` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth call is to the `Delta` function. This function attempts to open a
    file by passing a bad file path. This causes an exception to be thrown. Any function
    with a `try-catch` statement could catch this exception. If it does not, the exception
    is automatically passed up the call stack until it reaches the top, where .NET
    outputs the exception (and the details of this call stack).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Unless you need to step through your code to debug it, you
    should always run your code without the debugger attached. In this case, it is
    especially important not to attach the debugger because, if you do, it will catch
    the exception and show it in a GUI dialog box instead of outputting it as shown
    in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Where to catch exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers can decide if they want to catch an exception near the failure point
    or centralized higher up the call stack. This allows your code to be simplified
    and standardized. You might know that calling a function could throw one or more
    types of exception but you do not need to handle any of them at the current point
    in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want to catch an exception, log it, and then rethrow it. For
    example, if you are writing a low-level class library that will be called from
    an application, your code may not have enough information to programmatically
    fix the error in a smart way, but the calling application might have more information
    and be able to. Your code should log the error in case the calling application
    does not, and then rethrow it up the call stack in case the calling application
    chooses to handle it better.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to rethrow an exception inside a `catch` block, as shown
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: To throw the caught exception with its original call stack, call `throw`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To throw the caught exception as if it was thrown at the current level in the
    call stack, call `throw` with the caught exception, for example, `throw ex`. This
    is usually poor practice because you have lost some potentially useful information
    for debugging but it can be useful when you want to deliberately remove that information
    when it contains sensitive data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To wrap the caught exception in another exception that can include more information
    in a message that might help the caller understand the problem, throw a new exception,
    and pass the caught exception as the `innerException` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an error occurs when we call the `Gamma` function, then we could catch the
    exception and perform one of the three techniques of rethrowing an exception,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: This code is just illustrative. You would never use all three techniques in
    the same `catch` block!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see this in action with our call stack example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CallStackExceptionHandling` project in `Program.cs`, in the `Beta`
    function, add a `try-catch` statement around the call to the `Gamma` function,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note your code editor will show a squiggle under the `throw ex` to warn you
    that you will lose call stack information, as described in the code analyzer message
    `Re-throwing caught exception changes stack information`; more details can be
    found at the following link: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the console app and note that the output excludes some details of the call
    stack, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `ex` by replacing the statement `throw ex;` with `throw;`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the console app and note that the output includes all the details of the
    call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the tester-doer and try patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **tester-doer pattern** can avoid some thrown exceptions (but not eliminate
    them completely). This pattern uses pairs of functions: one to perform a test
    and the other to perform an action that would fail if the test was not passed.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET implements this pattern itself. For example, before adding an item to a
    collection by calling the `Add` method, you can test to see if it is read-only,
    which would cause `Add` to fail and, therefore, throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, before withdrawing money from a bank account, you might test that
    the account is not overdrawn, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The tester-doer pattern can add performance overhead, so you can also implement
    the **try pattern**, which, in effect, combines the test and do parts into a single
    function, as we saw with `TryParse`.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the tester-doer pattern occurs when you are using multiple
    threads. In this scenario, one thread calls the test function, and it returns
    a value that indicates that it is okay to proceed. But then another thread executes,
    which changes the state. Then the original thread continues executing, assuming
    that everything is fine, but it is not fine. This is called a *race condition*.
    This topic is too advanced to cover how to handle it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use the try pattern in preference to the tester-doer pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you implement your own try pattern function and it fails, remember to set
    the `out` parameter to the default value of its type and then return `false`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: Now that you’ve been introduced to the basics of exceptions,
    you can learn more about the details by reading the official documentation at
    the following link: [https://learn.microsoft.com/en-us/dotnet/standard/exceptions/](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/).'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring, with deeper research, the topics covered in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.1 – online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Logging during development and runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should add code throughout your application to log what is happening, especially
    when exceptions occur, so that you can review the logs and use them to trace the
    issue and fix the problem. In an online-only section, you will learn how to implement
    basic logging; this is found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.2 – practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions with debugging and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prime factors are a combination of the smallest prime numbers that, when multiplied
    together, will produce the original number. Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Prime factors of 4 are 2 x 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factor of 7 is 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factors of 30 are 5 x 3 x 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factors of 40 are 5 x 2 x 2 x 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factors of 50 are 5 x 5 x 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create three projects:'
  prefs: []
  type: TYPE_NORMAL
- en: A class library named `Exercise_PrimeFactorsLib` with a static class and static
    method named `PrimeFactors`, which, when passed an `int` variable as a parameter,
    returns a `string` showing its prime factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit test project named `Exercise_PrimeFactorsTests` with a few suitable unit
    tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A console application to use it, named `Exercise_PrimeFactorsApp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep it simple, you can assume that the largest number entered will be 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: Use the debugging tools and write unit tests to ensure that your function works
    correctly with multiple inputs and returns the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.3 – test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions. If you get stuck, try googling the answers,
    if necessary, while remembering that if you get totally stuck, the answers are
    in the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the C# keyword `void` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some differences between imperative and functional programming styles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code or Visual Studio, what is the difference between pressing *F5*, *Ctrl*
    or *Cmd* + *F5*, *Shift* + *F5*, and *Ctrl* or *Cmd* + *Shift* + *F5*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the `Trace.WriteLine` method write its output to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the five trace levels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Debug` and `Trace` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing a unit test, what are the three “A”s?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing a unit test using xUnit, which attribute must you decorate the
    test methods with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What `dotnet` command executes xUnit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What statement should you use to rethrow a caught exception named `ex` without
    losing the stack trace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 4.4 – explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to write reusable functions with input parameters and return values, in
    both an imperative and functional style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Visual Studio and VS Code debugging and diagnostic features like
    logging and unit tests to identify and fix any bugs in them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to throw and catch exceptions in functions and understand the call stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build your own types using object-oriented
    programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code281224304227278796.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  Description automatically generated](img/review1.png)'
  prefs: []
  type: TYPE_IMG
