- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Up and Running with Minimal API Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As users, we associate interacting with an application with a **User Interface**
    ( **UI** ). This interface consists of interactive elements that allow for interaction
    between the code and user. You can think of this like the *storefront* , a place
    where you can browse the available wares or request appropriate action, for example,
    booking a vacation or adding items to your shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: If the UI is where customers interact with our *store* , an **Application Programming
    Interface** ( **API** ) is the back of the store. This is where we receive deliveries,
    move goods, process orders, and manage inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers have some experience in interacting with or writing APIs, but
    what makes **minimal** **APIs** different?
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs were introduced by Microsoft in 2021 with the release of .NET 6.
    The aim was to empower developers to create APIs with a minimum of boilerplate
    code, allowing them to focus on the essentials of the business logic in use between
    requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: They offer a lightweight solution to API development, which is often a good
    starting point for projects, as they require much less effort to set them up.
    This is a key advantage when you’re looking to get a system up and running quickly,
    or where there is a low number of dependencies. It can also mean that performance
    is better in minimal APIs thanks to the reduced overhead compared to more traditional
    API formats. In this book, we will learn how to leverage these benefits of minimal
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrasting minimal APIs with traditional API approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of minimal APIs in modern development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing required tools and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring development environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the directions in this chapter, you’ll need to have the following
    installed on your Windows, macOS, or Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET 9.0 **Software Development** **Kit** ( **SDK** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio or Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# extension for Visual Studio Code (if you are using Visual Studio Code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re working in Windows, it’s recommended that you use Visual Studio, although
    Visual Studio Code will still work. If you’re a Mac or Linux user, you should
    use Visual Studio Code. (At the time of writing, Visual Studio for Mac is set
    to be retired on August 31, 2024.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to designing and building APIs, we’re spoilt for choice with varying
    styles, approaches, and templates. .NET has proven itself over the years to be
    a fantastic choice for general-purpose API development. Modern .NET provides us
    with two main types of API framework, one more traditional than the other. One
    of the options is, of course, the minimal API, which is still a relatively new
    feature within .NET compared to its predecessor, the controller-based API.
  prefs: []
  type: TYPE_NORMAL
- en: With minimal APIs, the aim is simplicity. Less code, less ceremony, and less
    complexity. As a result, minimal APIs are well suited to microservice architectures,
    where you have lots of small components all requiring a means of transferring
    data between each other.
  prefs: []
  type: TYPE_NORMAL
- en: Their simplicity also makes them easier to read, as a small block of code can
    take care of all the classic features of an API, such as receiving HTTP requests,
    routing, utilizing dependencies, accessing services, and sending responses to
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more admirable aspects of minimal APIs is the way they lower the
    barrier of entry to API development. They provide an alternative means of structuring
    your code that is more accessible, easier to read, and, in most cases, more performant
    owing to the decreased overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple API can be created using minimal APIs in just four lines of code.
    Here’s the classic *hello* *world* example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You just created an API! Let’s dig deeper into what’s happening
    in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, we create an instance of **WebApplicationBuilder** by calling
    **CreateBuilder** and passing in any command-line arguments that we might need.
    Think of this as a blueprint for the API we’re creating. The minimal API is an
    ASP.NET core application like any other, and so it needs a pipeline for it to
    be run. **WebApplicationBuilder** provides us with this pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we call **Build()** on this instance we created, which results in an instance
    of **WebApplication** that we have called **app** . This is our API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third line maps any incoming HTTP GET requests on the root path of the
    application: **("/")** . Following this, we use a lambda statement to indicate
    the logic that should be executed when the request is received. In this case,
    we are returning the string **Hello World!** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the fourth line starts the application, making it listen for incoming
    requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a high-level understanding of minimal APIs, let’s compare
    them with more traditional API f ormats.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting minimal APIs with traditional API approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more traditional API format in .NET compared to minimal APIs is **controller-based
    APIs** . These are more commonly seen in ASP.NET **Model-View-Controller** ( **MVC**
    ) projects, or in ASP.NET web API projects. However, whether you’re building an
    MVC project or not, both API types utilize controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Controllers are simply classes, with many responsibilities within the API,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling incoming requests via *actions* , which are interacted with using various
    HTTP methods, such as **GET** , **POST** , **PUT** , **DELETE** , and **PATCH**
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing data sent in the request via query string parameters or within the
    request body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with data models and processing of business logic via services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation of responses to calling clients. These responses could be in JSON,
    XML, or many other formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing of requests to other areas of the application, that is, directing to
    a page at a specific URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using a controller-based API, each controller tends to be focused on one
    specific application domain. For example, you may have a controller dedicated
    to all things *employees* , and another dedicated to *inventory* . This is great
    for segregating business logic into relevant areas, but requires a lot of ceremony,
    such as the need to *inherit* from a base *controller* class, the need to add
    attributes for defining HTTP methods, or management of folder structures for each
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of an **Employee** controller. Notice the use of attributes
    for labeling the controller type ( **[ApiController]** ) and routing. Also observe
    how the class is required to derive from **ControllerBase** , along with dependency
    injection managed via a class constr uctor to get **IEmployeeRepository** , and
    this is only for *employees* ! We’d have to do it all over again in a separate
    class for our *inventory* controller, and so the ceremony continues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, you can create a minimal API endpoint directly in the entry point
    of your application, with routing, dependency injection, and handlers all defined
    inline, like in the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, within a much simpler, smaller block of code (and without the
    need for a separate controller class), we’ve registered a service for dependency
    injection, added an HTTP **GET** endpoint, injected our service, ran the required
    logic, and retu rned a result.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in minimal APIs versus controllers
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover dependency injection later in the book, but it’s important to know
    that dependency injection as shown in the example requires more configuration
    in a controller-based API, as you typically register your dependencies at the
    startup of the application in **Startup.cs** . minimal APIs allow you to inject
    dependencies in a much lighter, straightforward way, wherever they are needed,
    without the need for **Startup.cs** . It’s also important to note that for the
    shown examples, you would need to create your own **IEmployeeRepository** for
    the code to work.
  prefs: []
  type: TYPE_NORMAL
- en: Having an overall understanding of minimal APIs and how they differ from other
    development approaches is critical for their optimal use. For more context, let
    us look at how minimal APIs fit within the context of modern software development.
  prefs: []
  type: TYPE_NORMAL
- en: The significance of minimal APIs in modern development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of creating more lightweight and simple APIs has been around for
    some time, but the adoption of minimal APIs has increased over the years. Flask
    and Express.js have historically promoted some elements of minimalism in API development
    within Python and Node.js, respectively, but compared to its counterparts, .NET’s
    recent entry into the market is specifically designed to exploit the advantages
    of lightweight, simple APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that minimal APIs have arrived and are being used in mainstream development
    projects, developers are enjoying the benefits of not having to perform lots of
    setup and configuration. They can have a working API up and running in two minutes
    and deploy it to the cloud in another two. This provides phenomenal advantages
    for industries in which getting software to market quickly is critical to success.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the APIs you write can take advantage of .NET’s mature, cross-platform
    ecosystem, with robust libraries and off-the-shelf security solutions for request
    validation, **cross-site request forgery** ( **CSRF** ) protection, and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have taken a generic look at minimal APIs and their place within
    modern software development. Moving forward, we are going to start configuring
    our environment for building minimal API projects. As with most project setups,
    the first things to be configured are the tools and dependencies. Follow the steps
    in the next section to start preparing your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing required tools and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to begin working with minimal APIs, we need to install some tools.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start by installing the .NET 9.0 SDK. Navigate to Microsoft’s .NET SDK
    downloads page at [https://dotnet.microsoft.com/en-us/download/dotnet](https://dotnet.microsoft.com/en-us/download/dotnet)
    . (This can be skipped if you already have the SDK installed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the SDK is available by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Choos e the appropriate build for your operating system and system architecture.
    For example, if you are running 64-bit Windows, you would download **x64** . Likewise,
    if you were running a Mac with an ARM CPU, you would select **Arm64** next to
    **macOS** . Linux tends to be a little different because a package manager is
    used to obtain the SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are a Linux user, follow the relevant Microsoft documentation for your
    specific Linux distribution:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.1: Choosing the right installer](img/B20968_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Choosing the right installer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let us quickly differentiate between installers and binaries.
    When software is added to a system, it usually consists of multiple files containing
    code to be executed when the program runs. These files are binaries: libraries
    or modules of code that make up the overall application. An installer automatically
    places all these components in the relevant locations on the host system. Because
    binaries are managed by installers, if you simply download the binaries, you will
    not automatically have them placed in specific locations. The configuration that
    would normally be orchestrated by an installer will not have taken place. This
    is sometimes necessary if you want to configure an application differently from
    how an installer would normally do it.'
  prefs: []
  type: TYPE_NORMAL
- en: When you download .NET SDKs from Microsoft’s website, you usually get the choice
    between downloading an installer or a binary. The simplest option is to use an
    installer, as this will configure your .NET development environment for you automatically.
    It is the version used in examples shown in this book and I recommend you use
    it also.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installer has downloaded, open it and follow the prompts. You will
    need administrator permissions to install the SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.2: The .NET SDK installer](img/B20968_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: The .NET SDK installer'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the SDK installed, it’s time to install Visual Studio (on Windows)
    or Visual Studio Code (on macOS or Linux). Either application can be obtained
    from the Visual Studio website at [https://visualstudio.microsoft.com/downloads](https://visualstudio.microsoft.com/downloads)
    .
  prefs: []
  type: TYPE_NORMAL
- en: .NET versions
  prefs: []
  type: TYPE_NORMAL
- en: The version of .NET shown after installation and the version of .NET shown in
    this example may differ.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to install Visual Studio on your device:'
  prefs: []
  type: TYPE_NORMAL
- en: On the downloads page, choose your desired Visual Studio edition. If you don’t
    have a Visual Studio license, you can select the **Community** edition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like when using the installer for the SDK, simply follow the prompts in the
    Visual Studio wizard to install to the desired location on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be prompted to choose relevant workloads during the setup process.
    At a minimum, you would need to select **ASP.NET and web development** to develop
    minimal APIs. Following this, you will be asked about optional additions. None
    of these will be crucial for minimal API development, so you can simply click
    **Next** once you have passed the screen shown in *Figure 1* *.3* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3: Workloads selection when installing Visual Studio](img/B20968_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Workloads selection when installing Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s install Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code for Mac and Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio Code is a free application. Simply download the relevant installer
    for your target operating system. Then, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Once downloaded, run the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Visual Studio Code and click the **Extensions** button in the left ribbon
    (or use the keyboard shortcut, *Ctrl* + *Shift* + *X* ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search bar at the top of the extensions pane, search for **C#** . You
    will see an extension appear with the same name. This is the **C# for Visual Studio
    Code** extension, which you will need to program in C# in Visual Studio Code.
    Click I **nstall** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4: Microsoft’s official C# extension for Visual Studio Code](img/B20968_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Microsoft’s official C# extension for Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: You now have all the prerequisite tools for writing minimal APIs in .NET installed.
    Next, we will set up our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring development environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start to develop our first minimal API in the next chapter, but before
    that, let’s create the project structure needed for us to start writing code.
  prefs: []
  type: TYPE_NORMAL
- en: To build minimal APIs, we need to be working within an ASP.NET Core project.
    Depending on whether you are using Visual Studio or Visual Studio Code, there
    are several ways you can create this type of project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by creating a project in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The screen shown in the following figure gives you the option to search for
    the type of project you wish to create. Search for **ASP.NET Core Empty** and
    select it from the list, before clicking **Next** . (Make sure you choose the
    C# version of the template. Do not use the F# version, as this is not within the
    scope of this book.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5: Visual Studio’s new project creation screen](img/B20968_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Visual Studio’s new project creation screen'
  prefs: []
  type: TYPE_NORMAL
- en: Give your new project a name and choose a folder location in which it should
    be saved. Then, click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6: Project configuration (ASP.NET Core Empty) in Visual Studio](img/B20968_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Project configuration (ASP.NET Core Empty) in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Choose your preferred .NET version. This book uses .NET 9, and we have just
    installed the .NET 9 SDK, so select this version from the list. **Configure for
    HTTPS** should be checked by default. This can be left checked. Finally, click
    **Create** . Your project will then be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio is arguably the most used IDE for this kind of project. However,
    it is possible to create minimal API projects in newer IDEs, such as Visual Studio
    Code. Let us explore how we can set up the same project in Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s create a project in Visual Studio Code in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio Code and open a terminal window by clicking **Terminal**
    and then **New Terminal Window** (or use the keyboard shortcut, *Ctrl* + *Shift*
    ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following commands into the terminal window, replacing **MyProjectName**
    with the name of your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When presented with dialog boxes asking whether you want to trust the authors
    and add required assets to the project, select **Yes** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Both project configurations will create the same minimal API example that we
    explored earlier in the chapter, returning **Hello World!** on an HTTP **GET**
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You now have the basic foundations of a minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: We can get the output from this example in Visual Studio Code and Visual Studio
    by clicking the **Play** button. This will run the project in debug mode, opening
    a browser window that, in the case of this example, simply displays **Hello World!**
    . This button is in slightly different places depending on which IDE you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7: Debugging the project in Visual Studio Code](img/B20968_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Debugging the project in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the button in Visual Studio looks like *Figure 1* *.8* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: Debugging the project in Visual Studio](img/B20968_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Debugging the project in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recap what we learnt in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the role of minimal APIs in modern application
    development, and you should now have a good general understanding of their advantages.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how minimal APIs differ from controller-based APIs in .NET, and
    gained an understanding of the advantages and disadvantages of these two formats.
  prefs: []
  type: TYPE_NORMAL
- en: You installed the basic required libraries and tools to get started on your
    journey and learned how to create a new project in Visual Studio or Visual Studio
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway from this chapter is that minimal APIs promote simplicity,
    high performance, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start writing our first Minimal API endpoints,
    which will be able to handle various HTTP methods on different routes. We will
    minimal build responses to send back to clients and make calls to our API.
  prefs: []
  type: TYPE_NORMAL
