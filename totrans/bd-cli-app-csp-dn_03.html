<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-35" class="chapter-number"><a id="_idTextAnchor035"/>3</h1>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Basic Concepts of Console Applications in .NET</h1>
			<p>Now that our development environment has been set up, it’s time to start our journey through the development of CLI applications <span class="No-Break">using .NET.</span></p>
			<p>However, first, we will explore <span class="No-Break">console applications!</span></p>
			<p>You’re probably familiar with console applications, and you may be wondering why we need to discuss console applications in a book dedicated to CLI applications. The reason is that at the core of every CLI application is a console application. That’s why, in this chapter, we’ll take a moment to explore console applications. Plus, you know what they say: a reminder never <span class="No-Break">hurts </span><span class="No-Break">😉</span><span class="No-Break">.</span></p>
			<p>Console applications can be seen as the simplest CLI applications one <span class="No-Break">can build.</span></p>
			<p>Hence, by exploring how we create, run, and interact with a console application, we will gain a basic understanding of how to work with CLI applications and how to build them by leveraging the console application template provided with the .<span class="No-Break">NET SDK.</span></p>
			<p>We will then create a very simple .NET console application, which takes some arguments as input and displays a message as an output. We will then enhance this application so it can perform some basic validations on the inputs and display the appropriate message as an output. This message will be displayed in a given color, depending on <span class="No-Break">its severity.</span></p>
			<p>Specifically, the chapter covers the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Learn how to create and execute <span class="No-Break">console applications</span></li>
				<li>Leverage the <strong class="source-inline">System.Console</strong> class for reading user input and <span class="No-Break">outputting responses</span></li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Creating (and executing) a simple console application</h1>
			<p>Let’s start by opening Visual Studio Code and displaying the integrated terminal window by going to <strong class="bold">View</strong> | <span class="No-Break"><strong class="bold">Terminal</strong></span><span class="No-Break">.</span></p>
			<p>Next, position<a id="_idIndexMarker065"/> yourself where you want the code folder to be created (I always create a <strong class="source-inline">code</strong> folder in my <strong class="source-inline">C:</strong> drive where all my code folders are located; I find it convenient to centralize all my code at the <span class="No-Break">same location).</span></p>
			<p>After ensuring that you are in the right working directory, type the following command to create a .NET <span class="No-Break">console application:</span></p>
			<pre class="console">
$ dotnet new console -n helloConsole -o helloConsole --use-program-main</pre>			<p>Let’s break down this command to understand what <span class="No-Break">it does:</span></p>
			<ul>
				<li><strong class="source-inline">dotnet new console</strong>: This will ask the .NET CLI tool to create a new console application. This will use C# as a language and .NET 8 as a framework (since these are the <span class="No-Break">default values).</span></li>
				<li><strong class="source-inline">-n helloConsole</strong>: Our application will be <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">helloConsole</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-o helloConsole</strong>: A <strong class="source-inline">helloConsole</strong> folder will be created that will contain all the code files for <span class="No-Break">our application.</span></li>
				<li> <strong class="source-inline">--use-program-main</strong>: The <strong class="source-inline">Program</strong> class containing the <strong class="source-inline">Main</strong> method will be added to the created <strong class="source-inline">Program.cs</strong> file. This method is the entry point of our program, and we will use its parameter to pass input values to our console application when we execute it. You can skip using <strong class="source-inline">--use-program-main</strong>, of course, but I prefer using it since it makes the <strong class="source-inline">Program</strong> class more explicit and familiar to developers coming from older versions <span class="No-Break">of .NET.</span></li>
			</ul>
			<p>Once the <a id="_idIndexMarker066"/>command completes, you should see an output that looks <span class="No-Break">like this:</span></p>
			<pre class="console">
PS C:\code&gt; dotnet new console -n helloConsole -o helloConsole --use-program-main
The template "Console App" was created successfully.
Processing post-creation actions...
Restoring C:\code\helloConsole\helloConsole.csproj:
  Determining projects to restore...
  Restored C:\code\helloConsole\helloConsole.csproj (in 121 ms).
Restore succeeded.</pre>			<p>This confirms that the application has been <span class="No-Break">successfully created.</span></p>
			<p class="callout-heading">A brief tour of the generated project</p>
			<p class="callout">The generated project contains <span class="No-Break">three files:</span></p>
			<p class="callout">- <strong class="bold">Program.cs</strong>: This <a id="_idIndexMarker067"/>file is typically the entry point for every program (through the <strong class="source-inline">Main</strong> method). While it may contain all the application’s logic in very simple applications, it usually serves as a starting point, delegating to other classes and methods <span class="No-Break">as needed.</span></p>
			<p class="callout">- <strong class="bold">helloConsole.csproj</strong>: A project (<strong class="source-inline">.csproj</strong>) file is<a id="_idIndexMarker068"/> essential for .NET development as it centralizes project configuration, making it easier to manage, build, and share projects across different development environments and build systems. It’s particularly important in the modern .NET ecosystem, which emphasizes cross-platform development and flexible project structures. In this file, we typically find information about<a id="_idIndexMarker069"/> the project definition, the build configuration, the dependency management (both project references and references to NuGet packages), the compilation settings, resource inclusion, any build process customization, project-wide properties (such as assembly name and version), cross-platform compatibility, and <span class="No-Break">IDE integration.</span></p>
			<p class="callout">- <strong class="bold">helloConsole.sln</strong>: A solution (<strong class="source-inline">.sln</strong>) file <a id="_idIndexMarker070"/>is a text-based file that serves as a container for organizing and managing related projects. It plays a crucial role in the development workflow, especially for larger applications that comprise multiple projects. Its purpose is to organize multiple related projects into a single solution, define build configurations and platforms for all projects, store solution-wide settings and metadata, and allow Visual Studio to load all related <span class="No-Break">projects simultaneously.</span></p>
			<p>Now, let’s load the<a id="_idIndexMarker071"/> project into Visual Studio Code by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
$ code ./helloConsole</pre>			<p>A new instance of Visual Studio Code will open, and you’ll see the content of the newly created project, which looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B22400_03_01.jpg" alt="Figure 3.1 – The helloConsole project opened in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The helloConsole project opened in Visual Studio Code</p>
			<p class="callout-heading">Do not confuse code with code!</p>
			<p class="callout">The preceding <strong class="source-inline">code</strong> command is the executable name for Visual Studio Code. It should not be confused with the <strong class="source-inline">code</strong> <span class="No-Break">folder </span><span class="No-Break">😉</span><span class="No-Break">.</span></p>
			<p>The code<a id="_idIndexMarker072"/> contained in the <strong class="source-inline">Main</strong> method of the <strong class="source-inline">Program.cs</strong> file doesn’t do much at the moment. In fact, it only displays a <strong class="source-inline">"Hello, World!"</strong> message when the application <span class="No-Break">is executed:</span></p>
			<pre class="source-code">
namespace helloConsole;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}</pre>			<p>Let’s execute<a id="_idIndexMarker073"/> this application and see what it returns. For that matter, we will need to type <span class="No-Break">this command:</span></p>
			<pre class="console">
$ dotnet run</pre>			<p>It is important to note that this command can be executed in any terminal: the PowerShell terminal, the CMD console, or the Bash terminal (if you are running Linux or macOS). However, since we are using Visual Studio Code, the easiest way to run commands is to use the integrated terminal within Visual Studio Code. That being said, you must ensure that you are in the project folder, which means that the <strong class="source-inline">dotnet run</strong> command should be executed in the same working directory as the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csproj</strong></span><span class="No-Break"> file.</span></p>
			<p>This will build and then execute the application. The output looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B22400_03_02.jpg" alt="Figure 3.2 – Hello, World! output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Hello, World! output</p>
			<p>This is not very useful at the moment, <span class="No-Break">is it?</span></p>
			<p>However, we<a id="_idIndexMarker074"/> can notice that the <strong class="source-inline">Main</strong> method takes an array of strings as an argument (that is, as an input parameter). So, let’s use that to pass some parameters to <span class="No-Break">our program.</span></p>
			<p>First, we modify our application code to show the value of that parameter, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace helloConsole;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine($"Hello, {args[0]}!");
    }
}</pre>			<p>Now, once executed, our program will display the <strong class="source-inline">Hello</strong> message, followed by the value we<a id="_idIndexMarker075"/> passed in as <span class="No-Break">a parameter.</span></p>
			<p>Let’s <span class="No-Break">try it:</span></p>
			<pre class="console">
$ dotnet run Packt</pre>			<p>The result will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B22400_03_03.jpg" alt="Figure 3.3 – Passing in one parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Passing in one parameter</p>
			<p>We can, of course, pass in more than one parameter, <span class="No-Break">like <a id="_idTextAnchor039"/>this:</span></p>
			<pre class="console">
$ dotnet run Packt Publishing</pre>			<p>This time, the result will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B22400_03_04.jpg" alt="Figure 3.4 – Passing in more than one parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Passing in more than one parameter</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are three remarks you need to be <span class="No-Break">aware of:</span></p>
			<p class="callout">1. The parameter to be passed to the <strong class="source-inline">Main</strong> method<a id="_idIndexMarker076"/> is an array of <strong class="bold">strings</strong>. This means that you’ll need to parse these strings if the program is expecting an input of another data type (such as an integer, <span class="No-Break">for example).</span></p>
			<p class="callout">2. Since this parameter is an array of strings, you can use the passed-in values by specifying their index, which represents their position from the <span class="No-Break">program execution.</span></p>
			<p class="callout">3. If you use a parameter value in the code but don’t pass it when executing the program, an exception will <span class="No-Break">be thrown.</span></p>
			<p>What do these remarks mean from a code perspective? Let’s consider some <span class="No-Break">illustrative examples.</span></p>
			<p>First, we’ll address the first remark. This example shows that the input parameter is of the <strong class="source-inline">string</strong> type<a id="_idIndexMarker077"/> despite its value, <strong class="source-inline">42</strong>, representing an integer. In order to use that value as an integer, we need to <span class="No-Break">parse it.</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B22400_03_05.jpg" alt="Figure 3.5 – Parsing input parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Parsing input parameters</p>
			<p>Next, let’s consider the second remark. This example shows that by switching the indexes of the parameters, we also switch the display of <span class="No-Break">their values.</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B22400_03_06.jpg" alt="Figure 3.6 – Switching input parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Switching input parameters</p>
			<p>Finally, regarding<a id="_idIndexMarker078"/> the third remark, this example demonstrates that failing to provide a value for the input parameter when executing the program will cause it to crash and throw <span class="No-Break">an exception.</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B22400_03_07.jpg" alt="Figure 3.7 – Missing an input parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Missing an input parameter</p>
			<p>We now know<a id="_idIndexMarker079"/> how to create and execute .NET console applications. Let’s see how we can interact with user inputs and better format <span class="No-Break">our outputs.</span></p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Working with the System.Console class</h1>
			<p>You may have <a id="_idIndexMarker080"/>noticed that in all our examples up to this point, we have used the <strong class="source-inline">Console</strong> class. More specifically, we only used one of its methods (namely <strong class="source-inline">WriteLine</strong>). This method displays the value of the expression passed as a parameter, and then gets to the next line. If we don’t want to get to the next line, we can use the <strong class="source-inline">Write</strong> <span class="No-Break">method instead.</span></p>
			<p>However, the <strong class="source-inline">Console</strong> class provides other useful properties and methods. We won’t go into the details of all of them (for that matter, I’d recommend that you visit <a href="https://learn.microsoft.com/en-us/dotnet/api/system.console">https://learn.microsoft.com/en-us/dotnet/api/system.console</a>). Instead, I’ll highlight the most interesting ones when it comes to <span class="No-Break">console applications.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Useful properties</h2>
			<p>There<a id="_idIndexMarker081"/> are three properties I would like to tell you about in particular: <strong class="source-inline">BackgroundColor</strong>, <strong class="source-inline">ForegroundColor</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Title</strong></span><span class="No-Break">.</span></p>
			<p>The first two, as their names suggest, are used to alter the background and foreground color of <span class="No-Break">the terminal.</span></p>
			<p>The third one, <strong class="source-inline">Title</strong>, is used to alter the title of the terminal window. Keep in mind that you will need to execute the program in an external terminal (not in the Visual Studio Code integrated terminal) to see the effect of changing the <span class="No-Break">terminal’s title.</span></p>
			<p>Here is an <span class="No-Break">illustrative example:</span></p>
			<pre class="source-code">
class Program
{
    static void Main(string[] args)
    {
        // performing a backup of the background and
        //foreground colors
        var originalBackroungColor = Console.BackgroundColor;
        var originalForegroundColor = Console.ForegroundColor;
        // changing the background and foreground colors
        Console.BackgroundColor = ConsoleColor.Blue;
        Console.ForegroundColor = ConsoleColor.Yellow;
     // setting the title of the terminal while the
     //application is running
        Console.Title = "Packt Publishing Console App";
        // displaying a message
        Console.WriteLine($"Hello from Packt Publishing!");
        // restoring the background and foreground colors
        // to their original values
        Console.BackgroundColor = originalBackroungColor;
        Console.ForegroundColor = originalForegroundColor;
        // waiting for the user to press a key to end the program.
        // this is useful to see the altering of the terminal's title
        Console.ReadKey(true);
    }
}</pre>			<p>As you<a id="_idIndexMarker082"/> can see, at the beginning of the program, we performed a backup of both the foreground and the background colors, and we restored them at the end of <span class="No-Break">the program.</span></p>
			<p>There is no need to do this for the terminal’s title since the set value is only effective during the execution of <span class="No-Break">the program.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Useful methods</h2>
			<p>There <a id="_idIndexMarker083"/>are also a few interesting (and useful) methods I would like to talk about. These are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">ReadLine</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">ReadKey</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Clear</strong></span></li>
			</ul>
			<p>Let’s start with <strong class="source-inline">ReadLine</strong>. This method reads all the characters from the user input until they hit <em class="italic">Enter</em> and returns the user input as a <strong class="source-inline">string</strong>. So, it is useful to gather user inputs, such<a id="_idIndexMarker084"/> as a name, an age, or <span class="No-Break">an address.</span></p>
			<p>Here is <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B22400_03_08.jpg" alt="Figure 3.8 – Reading user input from the console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Reading user input from the console</p>
			<p>Next, Let’s talk about <strong class="source-inline">ReadKey</strong>. This method reads the character or function key the user pressed. It returns an object of the <strong class="source-inline">ConsoleKeyInfo</strong> type, which includes information about the pressed key. It also takes an optional Boolean parameter that, if set to <strong class="source-inline">true</strong>, will not display the pressed key to the console, and if set to <strong class="source-inline">false</strong>, will <span class="No-Break">display it.</span></p>
			<p>Here’s an example with the Boolean parameter set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B22400_03_09.jpg" alt="Figure 3.9 – A ReadKey method with the Boolean parameter set to true"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – A ReadKey method with the Boolean parameter set to true</p>
			<p>Now, notice the <a id="_idIndexMarker085"/>output when the Boolean parameter is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B22400_03_10.jpg" alt="Figure 3.10 – A ReadKey method with the Boolean parameter set to false"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – A ReadKey method with the Boolean parameter set to false</p>
			<p>Have you noticed <a id="_idIndexMarker086"/>that the pressed key is displayed twice: once after it is pressed, and a second time with the <span class="No-Break">output message?</span></p>
			<p>By the way, you can visit <a href="https://learn.microsoft.com/en-us/dotnet/api/system.consolekey">https://learn.microsoft.com/en-us/dotnet/api/system.consolekey</a> to find a list of all of the values of the <span class="No-Break"><strong class="source-inline">ConsoleKey</strong></span><span class="No-Break"> enumeration.</span></p>
			<p>Finally, let’s see the <strong class="source-inline">Clear</strong> method. As its name suggests, it clears <span class="No-Break">the console:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B22400_03_11.jpg" alt="Figure 3.11 – Clearing the console with the Clear method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Clearing the console with the Clear method</p>
			<p>After the user<a id="_idIndexMarker087"/> presses the <em class="italic">C</em> key, the console <span class="No-Break">is cleared.</span></p>
			<p>This command is typically used in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li><strong class="bold">At the startup of the program</strong>: It is used here so that your program gets a clean interface by removing all previous outputs from other programs <span class="No-Break">or commands</span></li>
				<li><strong class="bold">When entering a new section or menu item</strong>: This prevents outputs from previous sections from polluting the <span class="No-Break">current one</span></li>
			</ul>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Useful event</h2>
			<p>If you’ve<a id="_idIndexMarker088"/> ever run a CLI application, you’re probably aware of the <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em> key combinations that make you exit the program at any time by <span class="No-Break">terminating it.</span></p>
			<p>In a .NET console application, these key combinations raise an event called <strong class="source-inline">CancelKeyPress</strong>. When one of the key combinations is pressed, the event is raised and interrupts the operation being executed. Our code can handle this event to allow for a graceful shutdown of the program, cleaning and freeing up resources before <span class="No-Break">the shutdown.</span></p>
			<p>Let’s illustrate this <a id="_idIndexMarker089"/>with an example. Consider the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
using System.Threading.Tasks;
class Program
{
    static void Main(string[] args)
    {
        int counter = 1;
        while(true)
        {
            Console.WriteLine($"Printing line number {counter}");
            counter++;
            Task delayTask = Task.Run(async () =&gt; await Task.
            Delay(1000));
            delayTask.Wait();
        }
    }
}</pre>			<p>As you may notice, this code uses an infinite loop with no exit condition. Hence, the only way to exit from it is by using one of the canceling key combinations (<em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em>). However, when pressed, this will abruptly terminate the program without giving it a chance to perform some actions in order to exit gracefully, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Saving the <span class="No-Break">execution state</span></li>
				<li>Logging out <span class="No-Break">of services</span></li>
				<li>Closing <span class="No-Break">database connections</span></li>
			</ul>
			<p>We will <a id="_idIndexMarker090"/>then modify the previous code to handle that termination event, allowing the program to <span class="No-Break">gracefully terminate:</span></p>
			<pre class="source-code">
using System.Threading.Tasks;
class Program
{
    static void Main(string[] args)
    {
        Console.CancelKeyPress += (sender, e) =&gt;
        {
            e.Cancel = true; // This will prevent the program from 
                             // terminating immediately
            Console.WriteLine("CancelKeyPress event raised!\
            nPerforming cleanup...");
            // Performing cleanup operations (logging out of services, 
            saving progress state, closing database connections,...)
            Environment.Exit(0); // This will terminate the program 
                                 // when cleanup is done
        };
        int counter = 1;
        while(true)
        {
            Console.WriteLine($"Printing line number {counter}");
            counter++;
            Task delayTask = Task.Run(async () =&gt; await Task.
            Delay(1000));
            delayTask.Wait();
        }
    }
}</pre>			<p>Now, the result <a id="_idIndexMarker091"/>of the execution looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B22400_03_12.jpg" alt="Figure 3.12 – Canceling the current operation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Canceling the current operation</p>
			<p>So, if your CLI application<a id="_idIndexMarker092"/> interacts with external resources or services (as we will do in the upcoming chapters), you should leverage the <span class="No-Break"><strong class="source-inline">Console.CancelKeyPress</strong></span><span class="No-Break"> event.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor044"/>One more thing</h1>
			<p>Up to this <a id="_idIndexMarker093"/>point, we have executed the program using the .NET CLI <span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></p>
			<p>However, if you are familiar with CLI applications, you will know that this type of application is usually executed by the name of its <span class="No-Break">executable file.</span></p>
			<p>The first question that comes to mind is “Why have we executed our program using the .NET CLI <strong class="source-inline">run</strong> command?”. The answer is “because this is how you will do it when developing and testing your <span class="No-Break">CLI application.”</span></p>
			<p>The next question that comes to mind is “Well, how do I execute my program using its executable?”. The answer to that question is “by reaching the location of that executable file and running the program <span class="No-Break">from there.”</span></p>
			<p>Let’s see how we <span class="No-Break">do this.</span></p>
			<p>When you build the program, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ dotnet build</pre>			<p>This will generate the executable file in the <strong class="source-inline">bin\Debug\net8.0</strong> folder on your <span class="No-Break">hard drive.</span></p>
			<p>On a Windows machine, this will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B22400_03_13.jpg" alt="Figure 3.13 – The generated executable file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – The generated executable file</p>
			<p>To run the <a id="_idIndexMarker094"/>program using its executable file name, open a terminal window, navigate to that location, and then type the following command (here, we are passing <strong class="source-inline">42</strong> as <span class="No-Break">a parameter):</span></p>
			<pre class="console">
$ .\helloConsole 42</pre>			<p>The result should be similar <span class="No-Break">to this:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B22400_03_14.jpg" alt="Figure 3.14 – Running the program from its executable file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Running the program from its executable file</p>
			<p class="callout-heading">Should I use dotnet run or run the executable file?</p>
			<p class="callout">There are some differences between running the program using the <strong class="source-inline">dotnet run</strong> command and running the program from its executable file. Here are the most <span class="No-Break">significant ones:</span></p>
			<p class="callout">- <strong class="bold">Build ^tprocess</strong>: The <strong class="source-inline">dotnet run</strong> command <a id="_idIndexMarker095"/>builds the project before running it, which ensures that we are always running the most up-to-date version of the code. The executable file represents the last compiled version of <span class="No-Break">the code.</span></p>
			<p class="callout">- <strong class="bold">Performance</strong>: <strong class="source-inline">dotnet run</strong> is slower (due to the build step) compared to running the program from its executable file. While the <strong class="source-inline">dotnet run</strong> command may take a few seconds to build and execute the code, the executable file usually executes in a matter <span class="No-Break">of milliseconds.</span></p>
			<p>It is important to keep <a id="_idIndexMarker096"/>this in mind since, during the development phase, you’ll likely rely on <strong class="source-inline">dotnet run</strong> to execute your program. However, in the testing and production phases, you’ll rely on the name of the executable. So, make sure you carefully choose the name for your program (and its <span class="No-Break">executable) </span><span class="No-Break">😉</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor045"/>Summary</h1>
			<p>In this chapter, we explored what lies at the core of a CLI application: a console application! This is why it is crucial to learn how to work with console applications, as they are the foundation for building more complex <span class="No-Break">CLI applications.</span></p>
			<p>We saw how we can execute a console application, providing values as input parameters and parsing these input parameters’ values in order to convert them into the data type expected by our program. We saw how we can gather user inputs through the use of the <strong class="source-inline">ReadKey</strong> and <strong class="source-inline">ReadLine</strong> methods of the <strong class="source-inline">Console</strong> class. Finally, we saw how we can handle exceptions raised as the result of a missing input <span class="No-Break">parameter value.</span></p>
			<p>However, a CLI application is more than a console one. It contains named parameters, flags, <span class="No-Break">and subcommands.</span></p>
			<p>In the upcoming chapters, we will see how we can leverage these capabilities into a fully functional CLI application. In the next chapter, we will start by creating the CLI application and learning how to parse its inputs, including commands, flags, <span class="No-Break">and parameters.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to achieve the <span class="No-Break">following task:</span></p>
			<p>Create a console application that does <span class="No-Break">the following:</span></p>
			<ul>
				<li>Sets the title of the terminal window to <span class="No-Break"><strong class="bold">GUESSING GAME!</strong></span></li>
				<li>Generates a random integer value between 1 <span class="No-Break">and 20</span></li>
				<li>Tells the player that they have three chances to figure out <span class="No-Break">that number</span></li>
				<li>After each player’s trial, it should then do <span class="No-Break">the following:</span><ul><li>If the player figured out the number, the program displays, in green text, <strong class="bold">Congratulations, you won!</strong>, along with the number of trials it took the player to figure <span class="No-Break">it out</span></li><li>If the player was not able to figure out the number within the three granted trials, the program should display, in red text, <strong class="bold">Better luck next time! The number to be guessed was</strong> along with the value to <span class="No-Break">be guessed</span></li><li>If the player hits <em class="italic">Enter</em> without providing a number, the program should consider that the value is zero and proceed <span class="No-Break">with it</span></li><li>If the player hits <em class="italic">Ctrl </em>+ <em class="italic">C</em>, the program should exit and display, in yellow text, <strong class="bold">Thank you </strong><span class="No-Break"><strong class="bold">for playing!</strong></span></li></ul></li>
			</ul>
		</div>
	

		<div id="_idContainer047" class="Content">
			<h1 id="_idParaDest-46" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor047"/>Part 2: Foundations of Building CLI Applications</h1>
			<p>In this part, you will delve into the essential components of CLI application development. You'll explore command-line parsing techniques, learning how to effectively handle user input and parse arguments using libraries. Next, you'll learn about input/output operations and file handling, covering methods to read from and write to files, as well as manipulate file streams for efficient data processing. Finally, you'll discover best practices for error handling and logging, including implementing structured logging with different severity levels, gracefully managing exceptions, and providing informative error messages to users while maintaining detailed logs for <span class="No-Break">debugging purposes.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B22400_04.xhtml#_idTextAnchor048"><em class="italic">Chapter 4</em></a><em class="italic">, Command-Line Parsing</em></li>
				<li><a href="B22400_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a><em class="italic">, Input/Output and File Handling</em></li>
				<li><a href="B22400_06.xhtml#_idTextAnchor084"><em class="italic">Chapter 6</em></a><em class="italic">, Error Handling and Logging</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer048">
			</div>
		</div>
		<div>
			<div id="_idContainer049">
			</div>
		</div>
		<div>
			<div id="_idContainer050">
			</div>
		</div>
		<div>
			<div id="_idContainer051">
			</div>
		</div>
		<div>
			<div id="_idContainer052">
			</div>
		</div>
		<div>
			<div id="_idContainer053" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer054" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer055">
			</div>
		</div>
		<div>
			<div id="_idContainer056">
			</div>
		</div>
		<div>
			<div id="_idContainer057" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>