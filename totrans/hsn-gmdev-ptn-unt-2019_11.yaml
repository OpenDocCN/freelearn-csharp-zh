- en: Strategy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: 'Strategy is one of those patterns whose name doesn''t indicate its intent explicitly.
    This uncertainty can make it hard to grasp and remember its purpose. But the Strategy
    pattern is quite simple: it offers a way to dynamically select algorithms and
    assign them to an object at runtime. We could imagine the Strategy pattern acting
    as a master chess player, analyzing the chessboard and choosing what strategy
    is best depending on the context.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是那些其名称并不明确表示其意图的模式之一。这种不确定性可能会使其难以理解和记忆其目的。但策略模式相当简单：它提供了一种在运行时动态选择算法并将它们分配给对象的方法。我们可以想象策略模式就像一个大师棋手，分析棋盘并根据上下文选择最佳策略。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of the Strategy pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式的基础
- en: Implementing a series of target-seeking behaviors for missiles using the Strategy
    pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略模式实现一系列导弹的寻的行为的实现
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is a hands-on chapter, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个实践性章节，因此你需要对Unity和C#有一个基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Composition over inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: If unfamiliar with this concept, please review them before starting this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不熟悉这个概念，请在开始本章之前复习它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[http://bit.ly/2UlVjVG](http://bit.ly/2UlVjVG)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2UlVjVG](http://bit.ly/2UlVjVG)'
- en: An overview of the Strategy pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式概述
- en: The primary goal of the Strategy pattern is to defer the decision of which algorithm
    to use until runtime. This approach allows more flexibility and reusability of
    segments of code that implement logic and behaviors. This idea may sound very
    complicated, but it's a simple mechanism that's possible because of the object-oriented
    programming concept of *composition*. So, instead of sharing reusable algorithms
    by implementing them in a parent class that can be inherited by other classes,
    we instead wrap each algorithm into self-contained individual *components* that
    we attach to objects at runtime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的根本目标是将选择使用哪种算法的决定推迟到运行时。这种方法使得实现逻辑和行为的代码段更加灵活和可重用。这个想法可能听起来非常复杂，但它是一个简单的机制，这是由于面向对象编程中的*组合*概念所实现的。因此，我们不是通过在可以被其他类继承的父类中实现它们来共享可重用的算法，而是将每个算法封装成独立的*组件*，在运行时将这些组件附加到对象上。
- en: If this sounds familiar and resembles a lot how Unity's component system works,
    it's because the engine has what we call in object-oriented programming a *composition
    over inheritance* approach. So, this makes the Strategy pattern harmonious with
    Unity's architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很熟悉，并且与Unity的组件系统工作方式相似，那是因为引擎采用了面向对象编程中的*组合优于继承*方法。因此，这使得策略模式与Unity的架构相协调。
- en: 'Let''s review the following simple diagram of this pattern:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个模式的简单图示：
- en: '![](img/53644f50-1166-4f66-95a1-c4603bca9f51.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53644f50-1166-4f66-95a1-c4603bca9f51.png)'
- en: As we can see, this example of the Strategy pattern implements an interface
    that permits us to assign various seeking behaviors to any objects of the **Missile**
    type. But like most patterns, it can be tough to follow it's design just by looking
    at a UML diagram. Therefore, we can only truly understand the mechanism behind
    this pattern by implementing it in code, which we will see in the next sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个策略模式的例子实现了一个接口，允许我们将各种寻的行為分配给任何**导弹**类型的对象。但像大多数模式一样，仅通过查看UML图很难理解其设计。因此，我们只能通过在代码中实现它，才能真正理解这个模式背后的机制，我们将在下一节中看到。
- en: In this chapter, we will often use the terms algorithms, logic, and behaviors
    as synonyms because, in the context of the Strategy pattern, they are manageable
    as individual components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经常使用算法、逻辑和行为这些术语作为同义词，因为在策略模式的上下文中，它们可以作为独立的组件进行管理。
- en: Benefits and drawbacks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: The Strategy pattern has a good reputation, but like most sophisticated patterns,
    its complexity can cause some drawbacks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式享有良好的声誉，但像大多数复杂的模式一样，其复杂性可能导致一些缺点。
- en: 'These are the benefits:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是好处：
- en: '**An alternative to subclassing**: Because it focuses on composition over inheritance,
    the Strategy offers a way to avoid hardwiring behaviors in each subclass of a
    parent type'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替代子类化**：因为它侧重于组合而非继承，策略提供了一种避免在父类型每个子类中硬编码行为的方法'
- en: '**Fewer condition statements to manage**: By implementing each behavior into
    individual components that can be managed by the Strategy pattern, the need for
    long conditional statements when dealing with complex contextual behavior selection is
    eliminated'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少条件语句管理**：通过将每个行为实现为可以由策略模式管理的单独组件，当处理复杂上下文行为选择时，消除了需要长条件语句的需求'
- en: 'Here are the drawbacks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是缺点：
- en: '**Client must be aware of the various strategies**: The Strategy pattern doesn''t
    abstract itself from the client, so it must be aware of the different strategies
    and how to call them'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端必须了解各种策略**：策略模式没有从客户端抽象出来，因此客户端必须了解不同的策略以及如何调用它们'
- en: '**Increased code complexity**: A common drawback of this type of sophisticated
    pattern is that it does increase the number of classes and objects to manage'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加代码复杂性**：这种复杂模式的常见缺点是它确实增加了要管理的类和对象的数量'
- en: One of the main reasons that a lot of programmers hesitate to use sophisticated
    patterns is because they are afraid that junior members of the team might get
    lost in the complexity that it adds to a code base. So, it's important to diagram
    and document complex parts of your code and also list the patterns you are using
    to implement a system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员犹豫使用复杂模式的主要原因是他们担心团队中的初级成员可能会迷失在它给代码库增加的复杂性中。因此，重要的是要绘制和记录代码的复杂部分，并列出你正在使用的实现系统的模式。
- en: Use case example
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: 'For this use case, let''s imagine we are working on a military simulation game
    and we are assigned to implement the following behaviors for the missile homing
    system:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个用例，让我们假设我们正在开发一个军事模拟游戏，并且我们被分配实现导弹寻家系统的以下行为：
- en: '**Heat**: The missile seeks a target by its heat signature'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heat**：导弹通过其热特征来寻找目标'
- en: '**Sonar**: The missile uses sound propagation to find a target'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sonar**：导弹使用声波传播来寻找目标'
- en: '**GPS**: The missile uses GPS coordinates to home onto the target'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPS**：导弹使用GPS坐标来定位目标'
- en: 'The design document also emphasizes that there will be three types of missiles
    using a homing system. But at the moment, it''s not decided which missile will
    be using which homing system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设计文档还强调，将有三种类型的导弹使用寻家系统。但到目前为止，尚未决定哪种导弹将使用哪种寻家系统：
- en: '**Tomahawk**: Usually launched from a carrier'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tomahawk**：通常从航母发射'
- en: '**SideWinder**: They are intended for jet fighters'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SideWinder**：它们是为喷气式战斗机设计的'
- en: '**Torpado**: They are designed to destroy underwater targets'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Torpado**：它们被设计用来摧毁水下目标'
- en: 'So, now we have technical choices to make:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在必须做出技术选择：
- en: Do we hard code each seeking behavior in the class of each type of missile?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否在每个导弹类型的类中硬编码每种寻求行为？
- en: Do we write a single homing system class that will contain all the missile-seeking
    behaviors?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否编写一个包含所有导弹寻求行为的单一寻家系统类？
- en: Do we instead write each missile-seeking behavior as a separate component that
    we can attach dynamically to any missile?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否相反地编写每个导弹寻求行为作为一个单独的组件，我们可以将其动态地附加到任何导弹上？
- en: The third option is the best one because it removes any duplicate code and offers
    flexibility in the form of composition. In the next section, we will implement
    this use case, and we will see how the Strategy pattern provides us a lot of extensibility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是最好的，因为它消除了任何重复的代码，并以组合的形式提供了灵活性。在下一节中，我们将实现这个用例，并看看策略模式如何为我们提供很多可扩展性。
- en: Good code is flexible and never rigid. Rigidity might seem more stable, but
    it makes changes difficult and expensive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码是灵活的，永远不会僵化。僵化可能看起来更稳定，但它使更改变得困难和昂贵。
- en: Code example
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'We are going to keep this example very simple, so we can focus on understanding
    the Strategy pattern and not get lost in wordiness. Let''s follow a step-by-step
    procedure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使这个例子非常简单，这样我们就可以专注于理解策略模式，而不是迷失在冗长的描述中。让我们遵循以下步骤：
- en: 'Let''s start by implementing the following critical element that makes this
    pattern work, which is the interface that will be used to access the seeking behaviors:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先实现使这个模式工作的重要元素，即用于访问寻求行为的接口：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have a standard interface for all our seeking behaviors, let's implements
    them in individual concrete classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为所有的寻求行为提供了一个标准接口，让我们在单个具体类中实现它们。
- en: 'Our first one is our `SeekWithGPS` behavior, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们第一个是 `SeekWithGPS` 行为，如下所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have our `SeekWithHeat` behavior, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有 `SeekWithHeat` 行为，如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, we have our `SeekWithSonar` behavior, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的 `SeekWithSonar` 行为，如下所示：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, now that we have encapsulated each seeking behavior into individual classes,
    the next step is to find a way to assign them dynamically to missiles.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经将每种寻求行为封装到单独的类中，下一步就是找到一种方法将它们动态地分配给导弹。
- en: 'Let''s write an abstract class that will group each type of missile with a
    common parent and permit us to give them a shared interface, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个抽象类，它将每种导弹与一个共同的父类分组，并允许我们为它们提供一个共享的接口，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are two key things to notice: the `ApplySeek()` and `SetSeekBehaviour()`
    functions will apply a specified behavior to any missile type that derives from
    the `Missile` class. We have given ourselves a single point of access to all our
    missile types and a way to apply a seek behavior dynamically. Let''s see how this
    looks in our concrete missile classes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键点需要注意：`ApplySeek()` 和 `SetSeekBehaviour()` 函数将应用指定的行为到任何从 `Missile` 类派生的导弹类型。我们为自己提供了一个访问所有导弹类型的单一入口点，以及动态应用寻求行为的方法。让我们看看这在我们的具体导弹类中是如何表现的。
- en: 'We are starting with our `Torpedo`. By default, let''s give it the `SeekWithSonar`
    behavior, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从我们的 `Torpedo` 开始。默认情况下，让我们给它 `SeekWithSonar` 行为，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next up is our `SideWinder`. We should give it the `SeekWithHeat` behavior,
    as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的 `SideWinder`。我们应该给它 `SeekWithHeat` 行为，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our final missile type is going to be `Tomahawk`. Let''s give it the `SeekWithGPS`
    behavior because it''s a long-distance missile, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后的导弹类型将是 `Tomahawk`。让我们给它 `SeekWithGPS` 行为，因为它是一种远程导弹，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can notice that each concrete missile class assigns an instance of the seeking
    behavior to `this.seekBehaviour` at `Awake()`, and this is because we want to
    make sure each missile type has a default seeking behavior associated with it
    at initialization.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，每个具体的导弹类在 `Awake()` 方法中将寻求行为的实例分配给 `this.seekBehaviour`，这是因为我们想要确保每种导弹类型在初始化时都与一个默认的寻求行为相关联。
- en: 'We will see in our `Client` class example that we can reassign a new behavior
    to a missile at any time we want, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的 `Client` 类示例中看到，我们可以在任何时候重新分配一个新的行为给导弹，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, we are now able to attach dynamically a seek behavior to any
    missile. This mechanism is beneficial because it means we could launch a missile
    and switch its seeking behavior mid-flight; a very cool feature to have in a game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们现在能够动态地将寻求行为附加到任何导弹上。这种机制是有益的，因为它意味着我们可以在飞行途中切换导弹的寻求行为；这是一个在游戏中非常酷的功能。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have just learned how to implement the Strategy pattern by building a series
    of targeting seeking behaviors that can be attached to any missile at runtime.
    An important takeaway from this pattern is the importance of isolating behaviors
    into separate classes that can be assigned dynamically to objects. This approach
    has become a pillar of good architecture and very popular among game programmers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何通过构建一系列可以在运行时附加到任何导弹上的目标寻求行为来实现策略模式。从这个模式中，我们学到的很重要的一点是将行为隔离到可以动态分配给对象的单独类中的重要性。这种方法已经成为良好架构的支柱，并且在游戏程序员中非常受欢迎。
- en: In the next chapter, we will explore the command pattern, a behavioral pattern
    that is often used to manage the triggering of events.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨命令模式，这是一种经常用于管理事件触发的行为模式。
- en: Practice
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践
- en: In the preceding code example, we only implemented a simple prototype of missile
    targeting seeking behaviors to keep the chapter within a reasonable length and
    focus on learning the core concepts behind the Strategy pattern. However, it would
    be a great exercise to complete the implementation of those targeting behaviors
    and build a demo of a launching system that can dynamically switch a missile's
    homing system from a heat, sonar, or GPS seeking behavior.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们只实现了一个简单的导弹目标搜索行为的原型，以保持章节长度合理并专注于学习策略模式背后的核心概念。然而，完成这些目标行为的实现并构建一个可以动态切换导弹制导系统从热、声纳或GPS搜索行为的发射系统演示将是一个很好的练习。
- en: Further reading
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Composition over inheritance:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优于继承：
- en: '[https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[组合优于继承](https://en.wikipedia.org/wiki/Composition_over_inheritance)'
