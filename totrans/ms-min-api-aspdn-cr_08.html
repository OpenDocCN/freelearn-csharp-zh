<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer059">
<h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor109"/>8</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/>Adding Authentication and Authorization</h1>
<p>Any kind of application must deal with <strong class="bold">authentication</strong> and <strong class="bold">authorization</strong>. Often, these terms are used interchangeably, but they actually refer to different scenarios. In this chapter of the book, we will explain the difference between authentication and authorization and show how to add these features to a minimal API project.</p>
<p>Authentication can be performed in many different ways: using local accounts with external login providers, such as Microsoft, Google, Facebook, and Twitter; using Azure Active Directory and Azure B2C; and using authentication servers such as Identity Server and Okta. Moreover, we may have to deal with requirements such as two-factor authentication and refresh tokens. In this chapter, however, we will focus on the general aspects of authentication and authorization and see how to implement them in a minimal API project, in order to provide a general understanding of the topic. The information and samples that will be provided will show how to effectively work with authentication and authorization and how to customize their behaviors according to our requirements.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Introducing authentication and authorization</li>
<li>Protecting a minimal API</li>
<li>Handling authorization – roles and policies</li>
</ul>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Technical requirements</h1>
<p>To follow the examples in this chapter, you will need to create an ASP.NET Core 6.0 Web API application. Refer to the <em class="italic">Technical requirements</em> section in <a href="B17902_02.xhtml#_idTextAnchor023"><em class="italic">Chapter 2</em></a><em class="italic">, Exploring Minimal APIs and Their Advantages</em>, for instructions on how to do so.</p>
<p>If you’re using your console, shell, or Bash terminal to create the API, remember to change your working directory to the current chapter number: <strong class="source-inline">Chapter08</strong>.</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter08">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter08</a>.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor112"/>Introducing authentication and authorization</h1>
<p>As said at the beginning, the terms <a id="_idIndexMarker397"/>authentication and authorization<a id="_idIndexMarker398"/> are often used interchangeably, but they represent different security functions. Authentication is the process of verifying that users are who they say they are, while authorization is the task of granting an authenticated user permission to do something. So, authorization must always follow authentication.</p>
<p>Let’s think about the security in an airport: first, you show your ID to authenticate your identity; then, at the gate, you present the boarding pass to be authorized to board the flight and get access to the plane.</p>
<p>Authentication and authorization in ASP.NET Core are handled by corresponding middleware and work in the same way in minimal APIs and controller-based projects. They allow the restriction of access to endpoints depending on user identity, roles, policies, and so on, as we’ll see in detail in the following sections.</p>
<p>You can find a great overview of ASP.NET Core authentication<a id="_idIndexMarker399"/> and authorization<a id="_idIndexMarker400"/> in the official documentation available at <a href="https://docs.microsoft.com/aspnet/core/security/authentication">https://docs.microsoft.com/aspnet/core/security/authentication</a> and <a href="https://docs.microsoft.com/aspnet/core/security/authorization">https://docs.microsoft.com/aspnet/core/security/authorization</a>.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor113"/>Protecting a minimal API</h1>
<p>Protecting a <a id="_idIndexMarker401"/>minimal API means correctly setting up authentication and authorization. There are many types of authentication solutions that are adopted in modern applications. In web applications, we typically use cookies, while when dealing with web APIs, we use methods such as an API key, basic authentication, and <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>). JWTs <a id="_idIndexMarker402"/>are the most commonly used, and in the rest of the chapter, we’ll focus on this solution.</p>
<p class="callout-heading">Note</p>
<p class="callout">A good starting point to <a id="_idIndexMarker403"/>understand what JWTs are and how they are used is available at <a href="https://jwt.io/introduction">https://jwt.io/introduction</a>. </p>
<p>To enable authentication and authorization based on JWT, the first thing to do is to a<a id="_idTextAnchor114"/>dd the <strong class="source-inline">Microsoft.AspNetCore.Authentication.JwtBearer</strong> NuGet package to our project, using one of the following ways:</p>
<ul>
<li><strong class="bold">Option 1</strong>: If you’re using Visual Studio 2022, right-click on the project and choose the <strong class="bold">Manage NuGet Packages</strong> command to open <strong class="bold">Package Manager GUI</strong>, then search for <strong class="source-inline">Microsoft.AspNetCore.Authentication.JwtBearer</strong> and click on <strong class="bold">Install</strong>.</li>
<li><strong class="bold">Option 2</strong>: Open <strong class="bold">Package Manager Console</strong> if you’re inside Visual Studio 2022, or open your console, shell, or Bash terminal, go to your project directory, and execute the following command:<p class="source-code"><strong class="bold">dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer</strong></p></li>
</ul>
<p>Now, we need to add<a id="_idIndexMarker404"/> authentication and authorization services to the service provider, so that they are available through dependency injection:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
//...
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer();
builder.Services.AddAuthorization();</pre>
<p>This is the minimum code that is necessary to add JWT authentication and authorization support to an ASP.NET Core project. It isn’t a real working solution yet, because it is missing the actual configuration, but it is enough to verify how endpoint protection works.</p>
<p>In the <strong class="source-inline">AddAuthentication()</strong> method, we specify that we want to use the <strong class="bold">bearer</strong> <strong class="bold">authentication scheme</strong>. This is an<a id="_idIndexMarker405"/> HTTP authentication scheme that involves security tokens that are in fact called <strong class="bold">bearer tokens</strong>. These<a id="_idIndexMarker406"/> tokens must be sent in the <strong class="source-inline">Authorization</strong> HTTP header with the format <strong class="source-inline">Authorization: Bearer &lt;token&gt;</strong>. Then, we call <strong class="source-inline">AddJwtBearer()</strong> to tell ASP.NET Core that it must expect a bearer token in the JWT format. As we’ll see later, the bearer token is an encoded string generated by the server in response to a login request. After that, we use <strong class="source-inline">AddAuthorization()</strong> to also add authorization services. </p>
<p>Now, we need to insert <a id="_idIndexMarker407"/>authentication and authorization middleware in the pipeline so that ASP.NET Core will be instructed to check the token and apply all the authorization rules:</p>
<pre class="source-code">
var app = builder.Build();
//..
app.UseAuthentication();
app.UseAuthorization();
//...
app.Run();</pre>
<p class="callout-heading">Important Note</p>
<p class="callout">We have said that authorization must follow authentication. This means that the authentication middleware must come first; otherwise, the security will not work as expected.</p>
<p>Finally, we can protect our endpoints using the <strong class="source-inline">Authorize</strong> attribute or the <strong class="source-inline">RequireAuthorization()</strong> method:</p>
<pre class="source-code">
app.MapGet("/api/attribute-protected", [Authorize] () =&gt; "This endpoint is protected using the Authorize attribute");
app.MapGet("/api/method-protected", () =&gt; "This endpoint is protected using the RequireAuthorization method")
.RequireAuthorization();</pre>
<p class="callout-heading">Note</p>
<p class="callout">The ability to specify an attribute directly on a lambda expression (as in the first endpoint of the previous example) is a new feature of C# 10.</p>
<p>If we now try to call<a id="_idIndexMarker408"/> each of these methods using Swagger, we’ll get a <strong class="source-inline">401 unauthorized</strong> response, which should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 8.1 – Unauthorized response in Swagger " height="153" src="image/Figure_8.1_B17902.jpg" width="285"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Unauthorized response in Swagger</p>
<p>Note that the message contains a header indicating that the expected authentication scheme is <strong class="source-inline">Bearer</strong>, as we have declared in the code.</p>
<p>So, now we know how to restrict access to our endpoints to authenticated users. But our work isn’t finished: we need to generate a JWT bearer, validate it, and find a way to pass such a token to Swagger so that we can test our protected endpoints.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor115"/>Generating a JWT bearer</h2>
<p>We have said that a<a id="_idIndexMarker409"/> JWT bearer is generated by the server as a response to a login request. ASP.NET Core provides all the APIs we need to create it, so let’s see how to perform this task.</p>
<p>The first thing to do is to define the login request endpoint to authenticate the user with their username and password: </p>
<pre class="source-code">
app.MapPost("/api/auth/login", (LoginRequest request) =&gt;
{
    if (request.Username == "marco" &amp;&amp; request.Password == 
        "P@$$w0rd")
    {
        // Generate the JWT bearer...
    }
    return Results.BadRequest();
});</pre>
<p>For the sake of <a id="_idIndexMarker410"/>simplicity, in the preceding example, we have used hardcoded values, but in a real application, we’d use, for example, <strong class="bold">ASP.NET Core Identity</strong>, the part of ASP.NET Core that is responsible for user management. More information on this topic<a id="_idIndexMarker411"/> is available in the official documentation at <a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity">https://docs.microsoft.com/aspnet/core/security/authentication/identity</a>.</p>
<p>In a typical login workflow, if the credentials are invalid, we return a <strong class="source-inline">400 Bad Request</strong> response to the client. If, instead, the username and password are correct, we can effectively generate a JWT bearer, using the classes available in ASP.NET Core:</p>
<pre class="source-code">
var claims = new List&lt;Claim&gt;()
{
    new(ClaimTypes.Name, request.Username)
};
var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("mysecuritystring"));
var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);
var jwtSecurityToken = new JwtSecurityToken(
    issuer: "https://www.packtpub.com",
    audience: "Minimal APIs Client",
    claims: claims, expires: DateTime.UtcNow.AddHours(1), 
      signingCredentials: credentials);
var accessToken = new JwtSecurityTokenHandler()
  .WriteToken(jwtSecurityToken);
return Results.Ok(new { AccessToken = accessToken });</pre>
<p>JWT bearer <a id="_idIndexMarker412"/>creation involves many different concepts, but through the preceding code example, we’ll focus on the basic ones. This kind of bearer contains information that allows verifying the user identity, along with other declarations that describe the properties of the user. These properties are called <strong class="bold">claims</strong> and are <a id="_idIndexMarker413"/>expressed as string key-value pairs. In the preceding code, we created a list with a single claim that contains the username. We can add as many claims as we need, and we can also have claims with the same name. In the next sections, we’ll see how to use claims, for example, to enforce authorization.</p>
<p>Next in the preceding code, we defined the credentials (<strong class="source-inline">SigningCredentials</strong>) to sign the JWT bearer. The signature depends on the actual token content and is used to check that the token hasn’t been tampered with. In fact, if we change anything in the token, such as a claim value, the signature will consequentially change. As the key to sign the bearer is known only by the server, it is impossible for a third party to modify the token and sustain its validity. In the preceding code, we used <strong class="source-inline">SymmetricSecurityKey</strong>, which is never shared with clients.</p>
<p>We used a short string to create the credentials, but the only requirement is that the key should be at least 32 bytes or 16 characters long. In .NET, strings are Unicode and therefore, each <a id="_idIndexMarker414"/>character takes 2 bytes. We also needed to set the algorithm that the credentials will use to sign the token. To this end, we have specified the <strong class="bold">Hash-Based Message Authentication Code</strong> (<strong class="bold">HMAC</strong>) and the <a id="_idIndexMarker415"/>hash function, SHA256, specifying the <strong class="source-inline">SecurityAlgorithms.HmacSha256</strong> value. This algorithm is quite a common choice in these kinds of scenarios.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information about the HMAC and the SHA256 hash function<a id="_idIndexMarker416"/> at <a href="https://docs.microsoft.com/dotnet/api/system.security.cryptography.hmacsha256#remarks">https://docs.microsoft.com/dotnet/api/system.security.cryptography.hmacsha256#remarks</a>.</p>
<p>By this point in the preceding code, we finally have all the information to create the token, so we can instantiate a <strong class="source-inline">JwtSecurityToken</strong> object. This class can use many parameters to build the token, but for the sake of simplicity, we have specified only the minimum set for a working example:</p>
<ul>
<li><strong class="bold">Issuer</strong>: A string (typically a URI) that identifies the name of the entity that is creating the token</li>
<li><strong class="bold">Audience</strong>: The recipient that the JWT is intended for, that is, who can consume the token</li>
<li>The list of claims</li>
<li>The expiration time of the token (in UTC)</li>
<li>The signing credentials</li>
</ul>
<p class="callout-heading">Tip</p>
<p class="callout">In the preceding code example, values used to build the token are hardcoded, but in a real-life application, we should place them in an external source, for example, in the <strong class="source-inline">appsettings.json</strong> configuration file.</p>
<p>You can find further information on creating a token at <a href="https://docs.microsoft.com/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytoken">https://docs.microsoft.com/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytoken</a>. </p>
<p>After all the <a id="_idIndexMarker417"/>preceding steps, we could create <strong class="source-inline">JwtSecurityTokenHandler</strong>, which is responsible for actually generating the bearer token and returning it to the caller with a <strong class="source-inline">200 OK</strong> response.</p>
<p>So, now we can try the <strong class="source-inline">login</strong> endpoint in Swagger. After inserting the correct username and password and clicking the <strong class="bold">Execute</strong> button, we will get the following response:</p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 8.2 – The JWT bearer as a result of the login request in Swagger " height="435" src="image/Figure_8.2_B17902.jpg" width="567"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The JWT bearer as a result of the login request in Swagger</p>
<p>We can copy the token value and insert it in the URL of the site <a href="https://jwt.ms">https://jwt.ms</a> to see what it contains. We’ll get something like this:</p>
<pre class="source-code">
{
  "alg": "HS256",
  "typ": "JWT"
}.{
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "marco",
  "exp": 1644431527,
  "iss": "https://www.packtpub.com",
  "aud": "Minimal APIs Client"
}.[Signature]</pre>
<p>In particular, we see<a id="_idIndexMarker418"/> the claims that have been configured:</p>
<ul>
<li><strong class="source-inline">name</strong>: The name of the logged user</li>
<li><strong class="source-inline">exp</strong>: The token expiration time, expressed in Unix epoch</li>
<li><strong class="source-inline">iss</strong>: The issuer of the token</li>
<li><strong class="source-inline">aud</strong>: The audience (receiver) of the token</li>
</ul>
<p>This is the raw view, but we can switch to the <strong class="bold">Claims</strong> tab to see the decoded list of all the claims, with a description of their meaning, where available.</p>
<p>There is one important point that requires attention: by default, the JWT bearer isn’t encrypted (it’s just a Base64-encoded string), so everyone can read its content. Token security does not depend on the inability to be decoded, but on the fact that it is signed. Even if the token’s content is clear, it is impossible to modify it because in this case, the signature (which uses a key that is known only by the server) will become invalid.</p>
<p>So, it’s important not to insert sensitive data in the token; claims such as usernames, user IDs, and roles are usually fine, but, for example, we should not insert information related to privacy. To give a deliberately exaggerated example, we mustn’t insert a credit card number in the token! In any case, keep in mind that even Microsoft for Azure Active Directory uses JWT, with no encryption, so we can trust this security system.</p>
<p>In conclusion, we have described how to obtain a valid JWT. The next steps are to pass the token to our protected endpoints and instruct our minimal API on how to validate it.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor116"/>Validating a JWT bearer</h2>
<p>After creating the <a id="_idIndexMarker419"/>JWT bearer, we need to pass it in every HTTP request, inside the <strong class="source-inline">Authorization</strong> HTTP header, so that ASP.NET Core can verify its validity and allow us to invoke the protected endpoints. So, we have to complete the <strong class="source-inline">AddJwtBearer()</strong> method invocation that we showed earlier with the description of the rules to validate the bearer:</p>
<pre class="source-code">
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
.AddJwtBearer(options =&gt;
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(
          Encoding.UTF8.GetBytes("mysecuritystring")),
        ValidIssuer = "https://www.packtpub.com",
        ValidAudience = "Minimal APIs Client"
    };
});</pre>
<p>In the preceding code, we added a lambda expression with which we defined the <strong class="source-inline">TokenValidationParameter</strong> object that contains the token validation rules. First of all, we checked the issuer signing key, that is, the signature of the token, as shown in the <em class="italic">Generating a JWT bearer</em> section, to verify that the JWT has not been tampered with. The security string that has been used to sign the token is required to perform this check, so we specify the same value (<strong class="source-inline">mysecuritystring</strong>) that we inserted during the login request.</p>
<p>Then, we specify what valid values for the issuer and the audience of the token are. If the token has been emitted from a different issuer, or was intended for another audience, the validation fails. This is an important security check; we should be sure that the bearer has been issued by someone we expected to issue it and for the audience we want.</p>
<p class="callout-heading">Tip</p>
<p class="callout">As already pointed out, we should place the information used to work with the token in an external source, so that we can reference the correct values during token generation and validation, avoiding hardcoding them or writing their values twice.</p>
<p>We don’t need to specify that we also want to validate the token expiration because this check is automatically enabled. A clock skew is applied when validating the time to compensate for slight differences in clock time or to handle delays between the client request and the instant at which it is processed by the server. The default value is 5 minutes, which means that an expired token is considered valid for a 5-minute timeframe after its actual expiration. We can reduce the clock skew, or disable it, using the <strong class="source-inline">ClockSkew</strong> property of the <strong class="source-inline">TokenValidationParameter</strong> class.</p>
<p>Now, the <a id="_idIndexMarker420"/>minimal API has all the information to check the bearer token validity. In order to test whether everything works as expected, we need a way to tell Swagger how to send the token within a request, as we’ll see in the next section.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor117"/>Adding JWT support to Swagger</h2>
<p>We have said that <a id="_idIndexMarker421"/>the bearer token is sent in the <strong class="source-inline">Authorization</strong> HTTP header of a request. If we want to use Swagger to verify the authentication system and test our protected endpoints, we need to update the configuration so that it will be able to include this header in the requests.</p>
<p>To perform this task, it is necessary to add a bit of code to the <strong class="source-inline">AddSwaggerGen()</strong> method:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
//...
builder.Services.AddSwaggerGen(options =&gt;
{
    options.AddSecurityDefinition(JwtBearerDefaults.AuthenticationScheme, new OpenApiSecurityScheme
    {
        Type = SecuritySchemeType.ApiKey,
        In = ParameterLocation.Header,
        Name = HeaderNames.Authorization,
        Description = "Insert the token with the 'Bearer ' 
                       prefix"
    });
    options.AddSecurityRequirement(new
      OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = 
                     JwtBearerDefaults.AuthenticationScheme
                }
            },
            Array.Empty&lt;string&gt;()
        }
    });
});</pre>
<p>In the <a id="_idIndexMarker422"/>preceding code, we defined how Swagger handles authentication. Using the <strong class="source-inline">AddSecurityDefinition()</strong> method, we described how our API is protected; we used an API key, which is the bearer token, in the header with the name <strong class="source-inline">Authorization</strong>. Then, with <strong class="source-inline">AddSecurityRequirement()</strong>, we specified that we have a security requirement for our endpoints, which means that the security information must be sent for every request.</p>
<p>After adding the preceding code, if we now run our application, the Swagger UI will contain something new.</p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 8.3 – Swagger showing the authentication features " height="506" src="image/Figure_8.3_B17902.jpg" width="801"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Swagger showing the authentication features</p>
<p>Upon<a id="_idIndexMarker423"/> clicking the <strong class="bold">Authorize</strong> button or any of the padlock icons at the right of the endpoints, the following window will show up, allowing us to insert the bearer token:</p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 8.4 – The window that allows setting the bearer token " height="330" src="image/Figure_8.4_B17902.jpg" width="354"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The window that allows setting the bearer token</p>
<p>The last thing to<a id="_idIndexMarker424"/> do is to insert the token in the <strong class="bold">Value</strong> textbox and confirm by clicking on <strong class="bold">Authorize</strong>. From now on, the specified bearer will be sent along with every request made with Swagger.</p>
<p>We have finally completed all the required steps to add authentication support to minimal APIs. Now, it’s time to verify that everything works as expected. In the next section, we’ll perform some tests.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor118"/>Testing authentication</h2>
<p>As described in the <a id="_idIndexMarker425"/>previous sections, if we call one of the protected endpoints, we get a <strong class="source-inline">401 Unauthorized</strong> response. To verify that token authentication works, let’s call the <strong class="source-inline">login</strong> endpoint to get a token. After that, click on the <strong class="bold">Authorize</strong> button in Swagger and insert the obtained token, remembering the <strong class="source-inline">Bearer&lt;space&gt;</strong> prefix. Now, we’ll get a <strong class="source-inline">200 OK</strong> response, meaning that we are able to correctly invoke the endpoints that require authentication. We can also try changing a single character in the token to again get the <strong class="source-inline">401 Unauthorized</strong> response, because in this case, the signature will not be the expected one, as described before. In the same way, if the token is formally valid but has expired, we will obtain a <strong class="source-inline">401</strong> response.</p>
<p>As we have defined endpoints that can be reached only by authenticated users, a common requirement is to access user information within the corresponding route handlers. In <a href="B17902_02.xhtml#_idTextAnchor023"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Minimal APIs and Their Advantages</em>, we showed that minimal APIs provide a special binding that directly provides a <strong class="source-inline">ClaimsPrincipal</strong> object representing the logged user:</p>
<pre class="source-code">
app.MapGet("/api/me", [Authorize] (ClaimsPrincipal user) =&gt; $"Logged username: {user.Identity.Name}");</pre>
<p>The <strong class="source-inline">user</strong> parameter <a id="_idIndexMarker426"/>of the route handler is automatically filled with user information. In this example, we just get the name, which in turn is read from the token claims, but the object exposes many properties that allow us to work with authentication data. We can refer to the official documentation at <a href="https://docs.microsoft.com/dotnet/api/system.security.claims.claimsprincipal.identity">https://docs.microsoft.com/dotnet/api/system.security.claims.claimsprincipal.identity</a> for further details.</p>
<p>This ends our overview of authentication. In the next section, we’ll see how<a id="_idTextAnchor119"/> to handle authorization.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor120"/>Handling authorization – roles and policies</h1>
<p>Right after the<a id="_idIndexMarker427"/> authentication, there is the authorization step, which grants an authenticated user permission to do something. Minimal APIs provide the same authorization features as <a id="_idIndexMarker428"/>controller-based projects, based on the concepts<a id="_idIndexMarker429"/> of <strong class="bold">roles</strong> and <strong class="bold">policies</strong>.</p>
<p>When an identity is created, it may belong to one or more roles. For example, a user can belong to the <strong class="source-inline">Administrator</strong> role, while another can be part of two roles: <strong class="source-inline">User</strong> and <strong class="source-inline">Stakeholder</strong>. Typically, each user can perform only the operations that are allowed by their roles. Roles are<a id="_idIndexMarker430"/> just claims that are inserted in the JWT bearer upon authentication. As we’ll see in a moment, ASP.NET Core provides built-in support to verify whether a user belongs to a role. </p>
<p>While role-based authorization covers many scenarios, there are cases in which this kind of security isn’t enough because we need to apply more specific rules to check whether the user has the right to perform some activities. In such a situation, we can create custom policies that allow us to specify more detailed authorization requirements and even completely define the authorization logic based on our algorithms.</p>
<p>In the next sections, we’ll <a id="_idIndexMarker431"/>see how to manage both role-based and policy-based authorization in our APIs, so that we can cover all our requirements, that is, allowing access to certain endpoints only to users with specific roles or claims, or based on our custom logic.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Handling role-based authorization</h2>
<p>As already introduced, roles<a id="_idIndexMarker432"/> are claims. This means that they must be<a id="_idIndexMarker433"/> inserted in the JWT bearer token upon authentication, just like any other claims:</p>
<pre class="source-code">
app.MapPost("/api/auth/login", (LoginRequest request) =&gt;
{
    if (request.Username == "marco" &amp;&amp; request.Password == 
        "P@$$w0rd")
    {
        var claims = new List&lt;Claim&gt;()
        {
            new(ClaimTypes.Name, request.Username),
            new(ClaimTypes.Role, "Administrator"),
            new(ClaimTypes.Role, "User")
        };
        
    //...
}</pre>
<p>In this example, we statically add two claims with name <strong class="source-inline">ClaimTypes.Role</strong>: <strong class="source-inline">Administrator</strong> and <strong class="source-inline">User</strong>. As said in the previous sections, in a real-world application, these values typically come from a complete user management system built, for example, with ASP.NET Core Identity.</p>
<p>As in all the other <a id="_idIndexMarker434"/>claims, roles are inserted in the JWT bearer. If now we try to invoke the <strong class="source-inline">login</strong> endpoint, we’ll notice that the token is longer because it contains a lot of information, which we can verify using the <a href="https://jwt.ms">https://jwt.ms</a> site again, as follows:</p>
<pre class="source-code">
{
  "alg": "HS256",
  "typ": "JWT"
}.{
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "marco",
  "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": [
    "Administrator",
    "User"
  ],
  "exp": 1644755166,
  "iss": "https://www.packtpub.com",
  "aud": "Minimal APIs Client"
}.[Signature]</pre>
<p>In order to restrict access to a particular endpoint only for users that belong to a given role, we need to specify this role as an argument in the <strong class="source-inline">Authorize</strong> attribute or the <strong class="source-inline">RequireAuthorization()</strong> method:</p>
<pre class="source-code">
app.MapGet("/api/admin-attribute-protected", [Authorize(Roles = "Administrator")] () =&gt; { });
app.MapGet("/api/admin-method-protected", () =&gt; { })
.RequireAuthorization(new AuthorizeAttribute { Roles = "Administrator" });</pre>
<p>In this way, only users who are assigned the <strong class="source-inline">Administrator</strong> role can access the endpoints. We can also specify more roles, separating them with a comma: the user will be authorized if they have at least one of the specified roles.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Role names are case sensitive.</p>
<p>Now suppose we have the following endpoint:</p>
<pre class="source-code">
app.MapGet("/api/stackeholder-protected", [Authorize(Roles = "Stakeholder")] () =&gt; { });</pre>
<p>This method can only be consumed by a user who is assigned the <strong class="source-inline">Stakeholder</strong> role. However, in our example, this role isn’t assigned. So, if we use the previous bearer token and try to invoke this endpoint, of course, we’ll get an error. But in this case, it won’t be <strong class="source-inline">401 Unauthorized</strong>, but rather <strong class="source-inline">403 Forbidden</strong>. We see this behavior because the user is actually authenticated (meaning the token is valid, so no <strong class="source-inline">401</strong> error), but they don’t have the authorization to execute the method, so access is forbidden. In other words, authentication errors and authorization errors lead to different HTTP status codes.</p>
<p>There is another<a id="_idIndexMarker435"/> important scenario that involves roles. Sometimes, we don’t need to restrict endpoint access at all but need to adapt the behavior of the handler according to the specific user role, such as when retrieving only a certain type of information. In this case, we can use the <strong class="source-inline">IsInRole()</strong> method, which is available on the <strong class="source-inline">ClaimsPrincipal</strong> object:</p>
<pre class="source-code">
app.MapGet("/api/role-check", [Authorize] (ClaimsPrincipal user) =&gt;
{
    if (user.IsInRole("Administrator"))
    {
        return "User is an Administrator";
    }
    return "This is a normal user";
});</pre>
<p>In this endpoint, we only use the <strong class="source-inline">Authorize</strong> attribute to check whether the user is authenticated or not. Then, in the route handler, we check whether the user has the <strong class="source-inline">Administrator</strong> role. If yes, we just return a message, but we can imagine that administrators can retrieve all the available information, while normal users get only a subset, based on the values of the information itself.</p>
<p>As we have seen, with<a id="_idIndexMarker436"/> role-based authorization, we can perform different types of authorization checks in our endpoints, to cover many scenarios. However, this approach cannot handle all situations. If roles aren’t enough, we need to use authorization based on policies, which we will discuss in the next section.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Applying policy-based authorization</h2>
<p>Policies<a id="_idIndexMarker437"/> are a more <a id="_idIndexMarker438"/>general way to define authorization rules. Role-based authorization can be considered a specific policy authorization that involves a roles check. We typically use policies when we need to handle more complex scenarios.</p>
<p>This kind of authorization requires two steps:</p>
<ol>
<li>Defining a policy with a rule set</li>
<li>Applying a certain policy on the endpoints</li>
</ol>
<p>Policies are added in the context of the <strong class="source-inline">AddAuthorization()</strong> method, which we saw in the previous section, <em class="italic">Protecting a minimal API</em>. Each policy has a unique name, which is used to later reference it, and a set of rules, which are typically described in a fluent manner.</p>
<p>We can use policies when role authorization is not enough. Suppose that the bearer token also contains the ID of the tenant to which the user belongs:</p>
<pre class="source-code">
var claims = new List&lt;Claim&gt;()
{
    // ...
    new("tenant-id", "42")
};</pre>
<p>Again, in a real-world scenario, this value could come from a database that stores the properties of the user. Suppose that we want to only allow users who belong to a particular tenant to reach an endpoint. As <strong class="source-inline">tenant-id</strong> is a custom claim, ASP.NET Core doesn’t know how to use it to enforce authorization. So, we can’t use the solutions shown earlier. We need to define a custom policy with the corresponding rule:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("Tenant42", policy =&gt;
    {
        policy.RequireClaim("tenant-id", "42");
    });
});</pre>
<p>In the preceding code, we <a id="_idIndexMarker439"/>created a policy named <strong class="source-inline">Tenant42</strong>, which requires that the token contains the <strong class="source-inline">tenant-id</strong> claim with the value <strong class="source-inline">42</strong>. The <strong class="source-inline">policy</strong> variable is an instance of <strong class="source-inline">AuthorizationPolicyBuilder</strong> and exposes methods that allow us to fluently specify the authorization rules; we can specify that a policy requires certain users, roles, and claims to be satisfied. We can also chain multiple requirements in the same policy, writing, for example, something such as <strong class="source-inline">policy.RequireRole(“Administrator”).RequireClaim(“tenant-id”)</strong>. The full list of methods is available on the documentation page at <a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder">https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder</a>.</p>
<p>Then, in the method we want to protect, we have to specify the policy name, as usual with the <strong class="source-inline">Authorize</strong> attribute or the <strong class="source-inline">RequireAuthorization()</strong> method:</p>
<pre class="source-code">
app.MapGet("/api/policy-attribute-protected", [Authorize(Policy = "Tenant42")] () =&gt; { });
app.MapGet("/api/policy-method-protected", () =&gt; { })
.RequireAuthorization("Tenant42");</pre>
<p>If we try to execute these preceding endpoints with a token that doesn’t have the <strong class="source-inline">tenant-id</strong> claim, or its value isn’t <strong class="source-inline">42</strong>, we get a <strong class="source-inline">403 Forbidden</strong> result, as happened with the role check.</p>
<p>There are scenarios in<a id="_idIndexMarker440"/> which declaring a list of allowed roles and claims isn’t enough: for example, we would need to perform more complex checks or verify authorization based on dynamic parameters. In these cases, we can use the so-called <strong class="bold">policy requirements</strong>, which <a id="_idIndexMarker441"/>comprise a collection of authorization rules for which we can provide custom verification logic.</p>
<p>To adopt this solution, we need two objects:</p>
<ul>
<li>A <em class="italic">requirement class</em> that implements the <strong class="source-inline">IAuthorizationRequirement</strong> interface and defines the requirement we want to manage</li>
<li>A <em class="italic">handler class</em> that inherits from <strong class="source-inline">AuthorizationHandler</strong> and contains the logic to verify the requirement</li>
</ul>
<p>Let’s suppose we don’t want users who don’t belong to the <strong class="source-inline">Administrator</strong> role to access certain endpoints during a maintenance time window. This is a perfectly valid authorization rule, but we cannot afford it using the solutions we have seen up to now. The rule involves a condition that considers the current time, so the policy cannot be statically defined.</p>
<p>So, we start by creating a custom requirement:</p>
<pre class="source-code">
public class MaintenanceTimeRequirement : IAuthorizationRequirement
{
    public TimeOnly StartTime { get; init; }
    public TimeOnly EndTime { get; init; }
}</pre>
<p>The requirement contains the start and end times of the maintenance window. During this interval, we only want administrators to be able to operate.</p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="source-inline">TimeOnly</strong> is a new<a id="_idIndexMarker442"/> data type that has been introduced with C# 10 and allows us to store only only the time of the day (and not the date). More information is available at <a href="https://docs.microsoft.com/dotnet/api/system.timeonly">https://docs.microsoft.com/dotnet/api/system.timeonly</a>.</p>
<p>Note that the <strong class="source-inline">IAuthorizationRequirement</strong> interface is just a placeholder. It doesn’t contain any method or property to be implemented; it serves only to identify that the class is a <a id="_idIndexMarker443"/>requirement. In other words, if we don’t need any additional information for the requirement, we can create a class that implements <strong class="source-inline">IAuthorizationRequirement</strong> but actually has no content at all.</p>
<p>This requirement must be enforced, so it is necessary to create the corresponding handler:</p>
<pre class="source-code">
public class MaintenanceTimeAuthorizationHandler
    : AuthorizationHandler&lt;MaintenanceTimeRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        MaintenanceTimeRequirement requirement)
    {
        var isAuthorized = true;
        if (!context.User.IsInRole("Administrator"))
        {
            var time = TimeOnly.FromDateTime(DateTime.Now);
            if (time &gt;= requirement.StartTime &amp;&amp; time &lt;
                requirement.EndTime)
            {
                isAuthorized = false;
            }
        }
        if (isAuthorized)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}</pre>
<p>Our handler inherits from <strong class="source-inline">AuthorizationHandler&lt;MaintenanceTimeRequirement&gt;</strong>, so we need to override the <strong class="source-inline">HandleRequirementAsync()</strong> method to verify the requirement, using the <strong class="source-inline">AuthorizationHandlerContext</strong> parameter, which contains a reference to the current user. As said at the beginning, if the user is not assigned the <strong class="source-inline">Administrator</strong> role, we<a id="_idIndexMarker444"/> check whether the current time falls in the maintenance window. If so, the user doesn’t have the right to access.</p>
<p>At the end, if the <strong class="source-inline">isAuthorized</strong> variable is <strong class="source-inline">true</strong>, it means that the authorization can be granted, so we call the <strong class="source-inline">Succeed()</strong> method on the <strong class="source-inline">context</strong> object, passing the requirement that we want to validate. Otherwise, we don’t invoke any method on the context, meaning that the requirement hasn’t been verified.</p>
<p>We haven’t yet finished implementing the custom policy. We still have to define the policy and register the handler in the service provider:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("TimedAccessPolicy", policy =&gt;
    {
        policy.Requirements.Add(new
          MaintenanceTimeRequirement
        {
            StartTime = new TimeOnly(0, 0, 0),
            EndTime = new TimeOnly(4, 0, 0)
        });
    });
});
builder.Services.AddScoped&lt;IAuthorizationHandler, MaintenanceTimeAuthorizationHandler&gt;();</pre>
<p>In the preceding code, we <a id="_idIndexMarker445"/>defined a maintenance time window from midnight till 4:00 in the morning. Then, we registered the handler as an implementation of the <strong class="source-inline">IAuthorizationHandler</strong> interface, which in turn is implemented by the <strong class="source-inline">AuthorizationHandler</strong> class.</p>
<p>Now that we have everything in place, we can apply the policy to our endpoints:</p>
<pre class="source-code">
app.MapGet("/api/custom-policy-protected", [Authorize(Policy = "TimedAccessPolicy")] () =&gt; { });</pre>
<p>When we try to reach this endpoint, ASP.NET Core will check the corresponding policy, find that it contains a requirement, and scan all the registrations of the <strong class="source-inline">IAuhorizationHandler</strong> interface to see whether there is one that is able to handle the requirement. Then, the handler will be invoked, and the result will be used to determine whether the user has the right to access the route. If the policy isn’t verified, we’ll get a <strong class="source-inline">403 Forbidden</strong> response.</p>
<p>We have shown how <a id="_idIndexMarker446"/>powerful policies are, but there is more. We can also use them to define global rules that are automatically applied to all endpoints, using the concepts of default and fallback policies, as we’ll see in the next section.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Using default and fallback policies</h2>
<p>Default and fallback policies<a id="_idIndexMarker447"/> are useful when we want to define global rules that <a id="_idIndexMarker448"/>must be automatically applied. In fact, when we use the <strong class="source-inline">Authorize</strong> attribute or the <strong class="source-inline">RequireAuthorization()</strong> method, without any other parameter, we implicitly refer to the default policy defined by ASP.NET Core, which is set to require an authenticated user.</p>
<p>If we want to use different conditions by default, we just need to redefine the <strong class="source-inline">DefaultPolicy</strong> property, which is available in the context of the <strong class="source-inline">AddAuthorization()</strong> method:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;
{
    var policy = new AuthorizationPolicyBuilder()
      .RequireAuthenticatedUser()
        .RequireClaim("tenant-id").Build();
    options.DefaultPolicy = policy;    
});</pre>
<p>We use <strong class="source-inline">AuthorizationPolicyBuilder</strong> to define all the security requirements, then we set it as a default policy. In this way, even if we don’t specify a custom policy in the <strong class="source-inline">Authorize</strong> attribute or the <strong class="source-inline">RequireAuthorization()</strong> method, the system will always verify whether the user is authenticated, and the bearer contains the <strong class="source-inline">tenant-id</strong> claim. Of course, we can override this default behavior by just specifying roles or policy names in the authorization attribute or method.</p>
<p>A fallback policy, on the other hand, is the policy that is applied when there is no authorization information on the endpoints. It is useful, for example, when we want all our endpoints to be automatically protected, even if we forget to specify the <strong class="source-inline">Authorize</strong> attribute or just don’t want to repeat the attribute for each handler. Let us try and understand this using the following code:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;
{
    options.FallbackPolicy = options.DefaultPolicy;
});</pre>
<p>In the preceding code, <strong class="source-inline">FallbackPolicy</strong> becomes equal to <strong class="source-inline">DefaultPolicy</strong>. We have said that the default policy requires that the user be authenticated, so the result of this code is that now, all the endpoints automatically need authentication, even if we don’t explicitly protect them.</p>
<p>This is a typical solution to adopt when most of our endpoints have restricted access. We don’t need to specify the <strong class="source-inline">Authorize</strong> attribute or use the <strong class="source-inline">RequireAuthorization()</strong> method anymore. In other words, now all our endpoints are protected by default.</p>
<p>If we decide to use<a id="_idIndexMarker449"/> this approach, but a bunch of endpoints need <a id="_idIndexMarker450"/>public access, such as the <strong class="source-inline">login</strong> endpoint, which everyone should be able to invoke, we can use the <strong class="source-inline">AllowAnonymous</strong> attribute or the <strong class="source-inline">AllowAnonymous()</strong> method:</p>
<pre class="source-code">
app.MapPost("/api/auth/login", [AllowAnonymous] (LoginRequest request) =&gt; { });
// OR
app.MapPost("/api/auth/login", (LoginRequest request) =&gt; { })
.AllowAnonymous();</pre>
<p>As the name implies, the preceding code will bypass all authorization checks for the endpoint, including the default and fallback authorization policies.</p>
<p>To deepen our <a id="_idIndexMarker451"/>knowledge of policy-based authentication, we can refer to the official documentation at <a href="https://docs.microsoft.com/aspnet/core/security/authorization/policies">https://docs.microsoft.com/aspnet/core/security/authorization/policies</a>.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor124"/>Summary</h1>
<p>Knowing how authentication and authorization work in minimal APIs is fundamental to developing secure applications. Using JWT bearer authentication roles and policies, we can even define complex authorization scenarios, with the ability to use both standard and custom rules.</p>
<p>In this chapter, we have introduced basic concepts to make a service secure, but there is much more to talk about, especially regarding ASP.NET Core Identity: an API that supports login functionality and allows managing users, passwords, profile data, roles, claims, and more. We can look further into this topic by checking out the official documentation, which is available at <a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity">https://docs.microsoft.com/aspnet/core/security/authentication/identity</a>.</p>
<p>In the next chapter, we will see how to add multilanguage support to our minimal APIs and how to correctly handle applications that work with different date formats, time zones, and so on.</p>
</div>
</div></body></html>