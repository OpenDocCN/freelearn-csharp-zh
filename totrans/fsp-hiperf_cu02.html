<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.200rem;">
<head><title>Chapter&#160;2.&#160;Performance Measurement</title>
<link rel="stylesheet" href="../Styles/style0001.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<div class="chapter" title="Chapter&#160;2.&#160;Performance Measurement"><div class="titlepage" id="aid-K0RQ2"><div><div><h1 class="title"><a id="ch02"></a>Chapter&#160;2.&#160;Performance Measurement</h1>
</div>
</div>
</div>
<p>Performance measurement is often subject to many debates, but we should approach the ways of solving performance problems as straightforwardly as possible while maintaining objective processes. The results must be as objective as they can. To correctly define that a performance optimization is needed or not, we must be able to measure the running code objectively. To ensure the objectiveness of the performance measurement, the result must be visible as quantitative (in numbers) and qualitative by analyzing how the code behaves when it runs, how fast it runs, and how big the code is in memory.</p>
<p>As a rule of thumb, it is easier to analyze quantitatively as data can be seen and compared more directly than when analyzed qualitatively. Understanding how to measure and how to interpret the measurement result can be used as a foundation for deducing the cause of any performance bottlenecks and can be further used in combination with qualitative analytics, such as deciding the best language construct and choosing the best strategy when dealing with concurrencies.</p>
<p>There are many ways to measure performance quantitatively, and we can use the existing tools in Visual Studio and in the .NET SDK/runtime. Understanding data qualitatively means that we have to understand the nature of the running code of F#, from the way it compiles to the way the result of the compilation works, which we can use to then reason the way the code runs.</p>
<div class="note" title="Note"><h3 class="title"><a id="note16"></a>Note</h3>
<p>A basic understanding of the .NET SDK tool is recommended (including how to install it with Visual Studio) although this chapter will also describe the tools inside Visual Studio since Visual Studio 2015. Please ensure that the installation of .NET and Visual Studio is correct to ensure that the journey to measuring performance described in this chapter is a smooth one.</p>
</div>
<p>This chapter will cover the introduction to performance measurement, tooling, and the approaches to quantitative measurement with the following topics:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Introduction to the nature of F# code compilation, including IL assembly generated</li>
<li class="listitem">Using CLR Profiler 4.5</li>
<li class="listitem">Ways to measure F# code performance using tools, libraries including timers, API in .NET, and Visual Studio's unit test to measure performance</li>
<li class="listitem">Collective time data gathering in unit tests</li>
</ul>
</div>
<div class="section" title="Introduction to the nature of F# code compilation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"></a>Introduction to the nature of F# code compilation</h1>
</div>
</div>
</div>
<p>Before we measure .NET, we need to understand the nature of F# code and the nature of compiling the F# code. Of course, we can just analyze and look at the source code. We can also try to search for any patterns of non-performing code of known bottlenecks, which will be explained in <a class="link" title="Chapter&#160;3.&#160;Optimizing Data Structures" href="fsp-hiperf_cu03.html#aid-NQU22">Chapter 3</a>,<span class="emphasis"><em>Optimizing Data Structures</em></span> and <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
<div class="section" title="General overview of F# compiler processes and results"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"></a>General overview of F# compiler processes and results</h2>
</div>
</div>
</div>
<p>All of the code in F# is compiled into byte codes of the IL assembly (as it's also an assembly language) either by the F# compiler or by using F# in interactive mode (by using FSI). This IL is then run in either <span class="strong"><strong>Debug</strong></span> mode as Just In Time (JIT) code is further optimized by compiling it in <span class="strong"><strong>Release</strong></span> mode. Running it in Release mode will yield compiled code to be optimized for .NET native by the Ahead Of Time (AOT) method.</p>
<p>For more information about .NET native, here is the official explanation in the MSDN Library:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx</a>
</p>
<p>The IL is guaranteed to work well with other ILs as it has to conform to IL compliance before being enabled to run on top of .NET runtime. Therefore, running codes written in F# on .NET is essentially the same as running C#/VB codes on .NET. Both of them are coded in .NET IL. Therefore, any programming language compiler that runs on top of .NET has to support compiling into (sometimes called generating) .NET IL.</p>
<p>The IL is executed on top of .NET runtime. The .NET runtime itself is one of the implementations of <span class="strong"><strong>Common Language Runtime</strong></span> (<span class="strong"><strong>CLR</strong></span>). This CLR defines the environment to run any IL assembly, and it also provides isolation and virtualization as well. This concept is known as a <span class="emphasis"><em>managed environment</em></span>. Although it's not tightly tied with an underlying operating system (OS), it can provide an interop service with the underlying OS. In .NET runtime, the call to the Windows API is provided as a Platform Invoke or simply called P/Invoke.</p>
<p>This is the latest official description of .NET CLR on the MSDN Library: <a class="ulink" href="https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx</a>.</p>
<p>The .NET IL (Intermediate Language) is basically a .NET specific assembly that is part of the <span class="strong"><strong>Common Language Infrastructure</strong></span> (<span class="strong"><strong>CLI</strong></span>) implementation standard. The CLI defines rules, foundations, processes, and IL instruction sets (including the byte codes). This CLI serves as an infrastructure for all languages on top of .NET runtime (or other CLR compliants such as Mono). Microsoft had submitted an initial version of the CLI standard in the beginning of 2001, and the first edition of the CLI standard was released on December 2001. The CLI standard is always revised and synchronized with the release of .NET runtime rather than with the framework version. For example, the latest edition of CLI is now sixth edition and it conforms with .NET 4.0 CLR.</p>
<p>This is the official source of information about the IL and CLI standards in ECMA:</p>
<p>
<a class="ulink" href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">http://www.ecma-international.org/publications/standards/Ecma-335.htm</a>
</p>
<p>The CLI standard is also implemented in Mono, not just in .NET CLR. The .NET CLR itself defines the corresponding related version of the .NET Framework, and as there are different versions of .NET CLR and the .NET Framework, this is often overlooked.</p>
<div class="note" title="Note"><h3 class="title"><a id="note17"></a>Note</h3>
<p>The releases of .NET Framework versions are not the same as the releases of .NET runtime. For example, .NET Framework 3.5 (often called .NET 3.5) uses the runtime of .NET 2.0 runtime, whereas .NET 4.5 and .NET 4.6 use .NET 4.0 runtime. We should pay attention to this if we really want to understand the underlying foundation of .NET runtime/CLR.</p>
</div>
<p>Although most developers don't often care about IL, it may be useful to show you how the code is executed. This takes place at a very low level of the compiled code. It is easier to start from the source code before it's compiled, therefore it is recommended to start with the simple one rather than the code itself at a higher level.</p>
<p>It is also a best practice to always start from high level thinking first and to then go deeper to the lower level, as in IL.</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00258.jpeg" alt="General overview of F# compiler processes and results"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>From the perspective of F# code, the highest level is the source code. The source code can be quickly checked for correctness by compiling it or by sending it to FSI. This is considered an important step as we can rely on the compiler when performing syntax and grammar checks. The language design of F# is more abstract than the source code, and it is used as our foundation for checking for correctness. This correctness checking is performed by the parser in the compiler. It is more abstract than the source code that has already been compiled successfully.</p>
<p>This is a common practice, and it is also understandable from a language design perspective; we cannot directly analyze it as it is not easy to apply optimization.</p>
<p>From the compiler side, the compiler interprets and compiles the code by steps in phases, from lexing to parsing the resultant compiled code as IL.</p>
<p>In general, F# compiles the code in the following steps:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00259.jpeg" alt="General overview of F# compiler processes and results"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>We will only focus on the behavior of the code as related in the phases from <span class="strong"><strong>Lexing</strong></span> to <span class="strong"><strong>Type checking</strong></span> and the result of the IL (related to the <span class="strong"><strong>IL Emit</strong></span> phase). The <span class="strong"><strong>Code generation</strong></span> phase heavily depends on the previous phases, and it will only produce abstract IL code before going to the next phase: the <span class="strong"><strong>IL Emit</strong></span> phase.</p>
<p>At the time of the current release of F# 4.0, the steps are focused on the phases of the F# 4.0 compiler. The compiler is open source, and although we could dive deep into the work of the compiler itself, a deeper understanding of all the elements of the F# language specifications are beyond the scope of this book. From the perspective of performance optimization, we shall focus only on the code constructs, IL emitted, and instrumentations. We are not going to touch any further on the internal detail of how the F# compiler works.</p>
<p>If you want to know more, the previous steps are part of an open contribution process that is part of F# Foundation's missions because the F# Foundation always encourages open contributions to the F# compiler, language design standards, and other elements related to the F# Foundation architecture. This group is called the F# Core Engineering group.</p>
<p>The homepage of F# Core Engineering is at <a class="ulink" href="https://fsharp.github.io/">https://fsharp.github.io/</a>.</p>
<p>These compilation steps are described in detail in the F# Foundation's F# Core Engineering group's F# compiler guide section on their GitHub page:</p>
<p>
<a class="ulink" href="https://fsharp.github.io/2015/09/29/fsharp-compiler-guide.html">https://fsharp.github.io/2015/09/29/fsharp-compiler-guide.html</a>
</p>
</div>
<div class="section" title="A quick overview of IL in F#"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"></a>A quick overview of IL in F#</h2>
</div>
</div>
</div>
<p>Let's start with the IL emitted by the F# compiler. Although the declared compatibility is as simple as it sounds, F# has a richer and more unique IL emitted than its C#/VB counterpart, but there are features in C#/VB that, currently, F# has no support for in the language yet. From .NET Core's perspective, the IL of F# and C#/VB are being developed at the same time.</p>
<p>This table summarizes the overall differences:</p>
<div class="informaltable"><table border="1"><colgroup><col/>
<col/>
<col/>
</colgroup>
<tbody><tr><td>
<p>
<span class="strong"><strong>Feature</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>F#</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>C#/VB</strong></span>
</p>
</td>
</tr>
<tr><td>
<p>Tailcall recursion (the <code class="literal">.tail</code> IL)</p>
</td>
<td>
<p>Yes. By default, F# will optimize simple recursion by translating it into a loop.</p>
</td>
<td>
<p>No. By default, tailcall recursion is not enabled in the Debug mode. But when enabled, IL emitted is not guaranteed to have tailcall IL.</p>
</td>
</tr>
<tr><td>
<p>Covariance/contravariance</p>
</td>
<td>
<p>Not available. Support is under review.</p>
</td>
<td>
<p>Yes.</p>
</td>
</tr>
<tr><td>
<p>Platform Invoke (P/Invoke)</p>
</td>
<td>
<p>Yes.</p>
</td>
<td>
<p>Yes.</p>
</td>
</tr>
<tr><td>
<p>COM objects</p>
</td>
<td>
<p>Partial. Because some COM objects can't be used as dynamic, they must be declared as <code class="literal">Type.Missing</code>,&#160;especially when writing code that interops with Office COM. This is as expected because F# has no direct support for late bounds.</p>
</td>
<td>
<p>Yes. Supports COM object as late bound by marking it as dynamic typed.</p>
</td>
</tr>
<tr><td>
<p>No PIA project and compile support</p>
</td>
<td>
<p>Not available. No definite plan in near future.</p>
</td>
<td>
<p>Yes. Not compatible with .NET Core by design because No PIA is only available on Windows.</p>
</td>
</tr>
<tr><td>
<p>.NET Core IL (for .NET Core, CoreCLR, and CoreFX) for cross platform support</p>
</td>
<td>
<p>The .NET Core is not yet released, but the development is keeping up with both languages.</p>
</td>
<td>
<p>Same state as F#. The overall source code of .NET CoreCLR is mostly written in C#.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>For more information about the progress of .NET CoreCLR, have a look at the official open source repository of .NET CoreCLR at <a class="ulink" href="https://github.com/dotnet/coreclr">https://github.com/dotnet/coreclr</a>.</p>
<p>Now, let's dive into the IL and the generated byte codes.</p>
</div>
<div class="section" title="IL tooling in .NET"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"></a>IL tooling in .NET</h2>
</div>
</div>
</div>
<p>Visual Studio comes with .NET SDK by default, and we can use the whole tooling available in .NET SDK in conjunction with the IDE experience inside Visual Studio. This includes everything from compiling to checking the IL generated.</p>
<p>To quickly see the IL, we can use the existing tools in .NET that relate to the IL emitter and disassembler, ILASM, and ILDASM.</p>
<p>.NET itself, in particular .NET SDK, has many tools available for developers to perform development tasks, including ILDASM and ILASM. For more information about .NET tools in Visual Studio 2015, consult this MSDN Library:</p>
<p>
<a class="ulink" href="https://github.com/dotnet/coreclr">https://msdn.microsoft.com/en-us/library/d9kh6s92(v=vs.110).aspx</a>
</p>
<p>These concepts of using ILASM to assemble IL assembly into machine code and ILDASM to disassemble are almost similar in terms of other assembler ecosystems. For example, the ILASM is conceptually equal to the Microsoft Macro Assembler compiler, known as MASM. It compiles Intel's processors (and its compatible) assembly language into byte codes that truly translate into code that the runtime can execute. ILASM takes the IL assembly and compiles it into a Windows PE (Portable Executable) file that can be in the form of EXE or DLL. ILDASM disassembles the byte code into the IL assembly code.</p>
<p>Unfortunately, there is no direct way to generate F# code into IL assembly code. In fact, the F# compiler compiles F# source codes into Window PE executable machine code as its final result. This is also true when compiling C#/VB source codes. We can see and check the generated assembly code by looking at the result of the disassembly first. We shall start with the easiest one: disassembly using ILDASM.</p>
<div class="section" title="Using ILDASM and ILASM to understand low-level IL assembly"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec0"></a>Using ILDASM and ILASM to understand low-level IL assembly</h3>
</div>
</div>
</div>
<p>To illustrate the simplest sample to disassemble simple code, let's create an F# console project in Visual Studio 2015 and name the project as <code class="literal">FSConsole01</code>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00260.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>A file will be opened in the Visual Studio editor, named <code class="literal">Program.fs</code>,&#160;which&#160;contains basic entry point of the F# console project. Replace the line 6 with this code:</p>
<pre class="programlisting">printfn "Hello F# world" 
</pre>
<p>Then, build the project. We can directly build and run it by pressing <span class="emphasis"><em>F5</em></span>, but the console will pop out and close instantly.</p>
<p>The recommended way to build is to use the key combination of <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F5</em></span> to instruct Visual Studio to run the code without debugging. This action will also pause after the code has finished running in the console:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00261.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Press any key or close the window.</p>
<p>Let's examine the IL by disassembling the executable using ILDASM. Search for Visual Studio's <span class="strong"><strong>Developer Command Prompt for Visual Studio 2015</strong></span> and select it:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00262.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>A window that shows the Command Prompt will appear. The window has a title bar of <span class="strong"><strong>Developer Command Prompt for VS 2015</strong></span>. It is basically a Command Prompt (it is an instance of a Windows <code class="literal">CMD</code>&#160;Command Prompt) that has its environment variables set (including system's <code class="literal">PATH</code> environment variable).</p>
<div class="note" title="Note"><h3 class="title"><a id="note18"></a>Note</h3>
<p>NOTE: <span class="strong"><strong>Developer Command Prompt for VS 2015</strong></span> is not available in the Visual Studio 2015 Express Edition installation. It is available in the Visual Studio 2015 Community Edition and above.</p>
</div>
<p>For more information about this developer&#160;Command Prompt, consult the MSDN Library:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms229859(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/ms229859(v=vs.110).aspx</a>
</p>
<p>In the command prompt, type <code class="literal">ILDASM</code> and then press <span class="emphasis"><em>Enter</em></span>. An <span class="strong"><strong>ILDASM</strong></span> window will show the following:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00263.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>To start disassembling <code class="literal">FSConsole01</code>, perform the following steps:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From the main menu, open the <span class="strong"><strong>File</strong></span> menu.</li>
<li class="listitem">Select <span class="strong"><strong>Open</strong></span> and then go to the folder that stores <code class="literal">FSConsole01</code>.</li>
<li class="listitem">Select the subfolder <code class="literal">bin</code>, the <code class="literal">Debug</code> subfolder.</li>
<li class="listitem">Open <code class="literal">FSConsole01.exe</code>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Let's resize a little bit so that now ILDASM will display the content of the EXE file as organized into metadata that contains IL:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00264.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The ILDASM of <code class="literal">FSConsole01.exe</code> has three nodes:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><strong>MANIFEST</strong></span> node is a manifest of runtime information that contains the .NET runtime assembly it targets.</li>
<li class="listitem"><span class="strong"><strong>&lt;StartupCode$FSConsole01&gt;</strong></span> contains the necessary metadata of the <code class="literal">AssemblyInfo</code>, the main class of Program, and other assembly attributes.</li>
<li class="listitem"><span class="strong"><strong>Program</strong></span> contains the actual IL of the F# source code compiled into IL assembly, related to the <code class="literal">&lt;EntryPoint&gt;</code> attribute.</li>
</ul>
</div>
<p>Now let's expand the Program node and select the <span class="strong"><strong>main : int32(string[])</strong></span> node:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00265.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>To further explore the source code, double-click the <span class="strong"><strong>main</strong></span> node. ILDASM will display a new window that contains the IL assembly of <code class="literal">main</code>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00266.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Let's look again at the source code:</p>
<pre class="programlisting">[&lt;EntryPoint&gt;] 
let main argv =  
    printfn <span class="strong"><strong>"Hello F# world"</strong></span> 
    0 // return an integer exit code 
</pre>
<p>Now we will dive into the translation of IL.</p>
<p>The <code class="literal">let main argv</code> function declaration is translated into the following IL:</p>
<pre class="programlisting">.method public static int32  main(string[] argv) cil managed 
</pre>
<p>This is crucial and it's quite similar to the main console of C#/VB as it's also generated as a method that uses the <code class="literal">public static</code> modifier. In F#, the <code class="literal">main</code> method has <code class="literal">int32</code> as its return value instead of <code class="literal">void</code> in C# (Sub in VB).</p>
<p>The <code class="literal">EntryPoint</code> attribute is translated as <code class="literal">.entrypoint</code> combined with the instantiation of the <code class="literal">EntryPoint</code> attribute inside the method.</p>
<p>The <code class="literal">"Hello F# world"</code> string is loaded into memory as indicated by the <code class="literal">ldstr</code> IL assembly command. Then, the next line prepares the call to F# <code class="literal">PrintfFormatLine</code> (as compiled from the translation of the abbreviated name of <code class="literal">printf</code>) by calling the <code class="literal">static</code> constructor of <code class="literal">Microsoft.FSharp.Core.PrintfFormat</code> and then calling the <code class="literal">PrintFormatLine</code>.</p>
<p>This is the behavior of any call to the static method, and it is related to .NET CLR, not the convention or the IL result from F#. When calling any static method for the first time, the static constructor of the class that has the static method (if this constructor is available) is always called first. It behaves the same as in C# and VB.</p>
<p>Now let's examine the IL emitted by the recursive function in F# even further. Let's add the recursive factorial function. To make it more interesting, we are using pattern matching to match the conditions of the recursive calls. Add the following code before the main entry point:</p>
<pre class="programlisting">let rec fact x =  
    match x with 
    | 1 -&gt; 1 
    | a when a &lt; 1 -&gt; 1 
    | _ -&gt; x * fact (x-1)   
</pre>
<p>Run ILDASM and open the compiled <code class="literal">FSConsole01</code> executable. Navigate to the <code class="literal">fact</code> node and then double-click the node. We will see that the IL is translated into a loop in the IL assembly:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00267.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>There are three branch instructions: <code class="literal">br.false</code> and two <code class="literal">br.s</code> instructions. These three correspond to the match branches in the code.</p>
<p>In this sample recursive function of factorial, the recursive construct is optimized as a loop in the IL emitted. The usage of a loop also implies that the stack overflow will not happen as the code is not performing recursion; therefore, there is no need to store the function entry in the stack as with most recursive functions in other languages such as C# and VB. It is intrinsically faster and more efficient than using a stack frame to store the recursion returning point.</p>
<div class="note" title="Note"><h3 class="title"><a id="note19"></a>Note</h3>
<p>The choice of optimization from a recursive into a loop is what separates F# from C#/VB. It is faster to have a loop than to use recursion that requires stack frames because stack frame usage adds more overhead of pushing and popping values in stack manipulations.</p>
</div>
<p>A deeper discussion on recursive function and tail calls is available in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
<p>For more information on IL assembly instructions, consult the ECMA 335 standard.</p>
<p>We now have IL assemblies available to use. The output produced by ILDASM can be used to be the foundation of understanding IL deeper, but we need to be able to produce the whole IL assembly of the executable.</p>
<p>Using the existing <code class="literal">FSConsole01</code>, we are going to transform the compiled EXE to a text file that contains the IL assembly.</p>
<p>Open the <span class="strong"><strong>Developer Command Prompt for Visual Studio 2015</strong></span> and change the folder to the <code class="literal">bindebug</code> subfolder of your <code class="literal">FSConsole01</code> project. Then, type the following:</p>
<pre class="programlisting">ildasm FSConsole01.exe /OUT=FSConsole.IL 
</pre>
<p>The <code class="literal">/OUT</code> parameter means that we are not going to display ILDASM UI because we are going to dump the IL into a file to contain the IL assembly code as a result of the disassembler of ILDASM. It is a recommended best practice to name the extension of the file as <span class="emphasis"><em>IL</em></span> because it is a source code of .NET IL assembly code, although .NET will not register IL as a filename extension on Windows.</p>
<p>We now have <code class="literal">FSConsole.IL</code>. Open the <code class="literal">FSConsole.IL</code> using Notepad:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00268.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F</em></span> and search for <code class="literal">Program</code> and then we see that the F# compiler emitted the class declaration of Program as <code class="literal">public abstract</code>:</p>
<pre class="programlisting">// =============== CLASS MEMBERS DECLARATION =================== 
 
.class public abstract auto ansi sealed Program 
       extends [mscorlib]System.Object 
</pre>
<p>This is also a form of optimization by the F# compiler because the <code class="literal">Program</code> class as the entrypoint <span class="emphasis"><em>doesn't have to be a concrete class</em></span>. This is different from C# as the default compile result is a concrete class. For example:</p>
<pre class="programlisting">// =============== CLASS MEMBERS DECLARATION =================== 
 
.class private auto ansi beforefieldinit Imperative.Program 
       extends [mscorlib]System.Object 
</pre>
<p>However, we can modify the corresponding C#'s <code class="literal">Program</code> class to have a similar abstract class explicitly in the code before building and compiling it again.</p>
<p>Let's directly modify the IL assembly code and compile it back to an executable using ILASM.</p>
<p>Search for this line of code:</p>
<pre class="programlisting">IL_0001:  ldstr      "Hello F# world" 
</pre>
<p>Change the <code class="literal">Hello F# world</code> to <code class="literal">Hello world!</code> and then save the IL using a different name, for example, <code class="literal">FSConsole01a.IL</code>.</p>
<p>Then, go back to the developer's Command Prompt and type this:</p>
<pre class="programlisting">ilasm FSConsole01a.IL /exe 
</pre>
<p>Then, execute <code class="literal">FSConsole01a.exe</code> on the Command Prompt; it should now display <code class="literal">Hello world!</code>, as shown here:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00269.jpeg" alt="Using ILDASM and ILASM to understand low-level IL assembly"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Now, we can have qualitative optimization based on IL! We also have learned this example of recursion as loop-one good example use case of IL analyzing. This IL use of a loop instead of recursion using a stack is also proof of optimization: F# is already one step ahead of other languages (especially non-functional languages) in terms of handling basic recursive functions.</p>
<p>We have grabbed the basic understanding of the F# compiler and IL. Now that we understood the underlying IL assembly generated by F#, we can profile it using the CLR Profiler, a profiler tool from Microsoft.</p>
</div>
</div>
</div>
</div>


<div class="section" title="Using CLR Profiler 4.5"><div class="titlepage" id="aid-KVCC2"><div><div><h1 class="title"><a id="ch02lvl1sec14"></a>Using CLR Profiler 4.5</h1>
</div>
</div>
</div>
<p>CLR Profiler is a profiler tool used to profile any compiled PE of .NET. It is free and open source, although it is not available by default in the current installation of .NET and Visual Studio 2015.</p>
<p>A profiler is basically a helper tool to analyze the elements of a running program that relates to performances, such as:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory consumptions</li>
<li class="listitem">Execution time allocations in terms of classes and modules into smaller elements such as functions and subroutines</li>
<li class="listitem">Examining garbage collections (if the platform has support for garbage collection)</li>
</ul>
</div>
<p>Based on the previous definitions, the CLR Profiler is simply a profiler to examine (or <span class="emphasis"><em>to profile</em></span>) any application that runs on top of .NET CLR.</p>
<p>There are profilers toolings for .NET, not just CLR Profiler, out there, unfortunately not all the toolings are free. Fortunately, CLR Profiler has complete features to profile .NET application, and it is also free and open source. We can also build our own profiler based on the existing CLR Profiler.</p>
<div class="section" title="A quick overview of CLR Profiler"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"></a>A quick overview of CLR Profiler</h2>
</div>
</div>
</div>
<p>CLR Profiler has been developed since .NET 1.1, although it is not supported anymore. The latest CLR Profiler is available for .NET 4.5, and it can only be used effectively for profiling any .NET 4.0 CLR-based application, including .NET 4.0 to .NET 4.6 applications. The next version of .NET may or may not be compatible.</p>
<p>CLR Profiler has been developed since .NET 1.1, and it is always released to match with the .NET runtime releases. For example, CLR Profiler version 2.0 supports .NET 2.0 runtime. This version 2.0 release supports .NET generics that were introduced in .NET 2.0 runtime. The version 3.5 supports .NET 2.0 SP1 runtime that was released with .NET Framework 3.5 and so do the next versions, as illustrated:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00270.jpeg" alt="A quick overview of CLR Profiler"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>There were some maintenance releases of CLR Profiler between the themed releases from version 2.0 to version 4 that were in sync with .NET runtime, but these maintenance releases were mostly bug fixes that addressed minor test cases involving profiling Platform interop with Win32 API and COM. After the release of CLR Profiler 4, the maintenance releases are not available, particularly, because the source code of CLR Profiler is also open sourced.</p>
<p>An initial version of CLR Profiler, until version 2.0, was developed within a closed-source model, and it was then opened as open source. The repository of the CLR Profiler was located at CodePlex until now.</p>
<p>It was maintained originally by the CLR team, and was then lead by David Broman until now. The most interesting fact is that the CLR Profiler is written entirely in C++, using a mix of native Win32 C++ with managed C++. It can hook into the running code of the application to be profiled by first loading and examining the IL and then injecting some hooks as IL to monitor the execution.</p>
<p>To catch up with the development of CLR Profiler on CodePlex, have a look at this landing page:</p>
<p>
<a class="ulink" href="http://clrprofiler.codeplex.com/">http://clrprofiler.codeplex.com/</a>
</p>
<p>David Broman, Microsoft's original developer of CLR Profiler, has a blog on MSDN as well. His blog is available at <a class="ulink" href="https://blogs.msdn.microsoft.com/davbr/">https://blogs.msdn.microsoft.com/davbr/</a>.</p>
</div>
<div class="section" title="A quick walkthrough of CLR Profiler in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"></a>A quick walkthrough of CLR Profiler in action</h2>
</div>
</div>
</div>
<p>On the download page of CLR Profiler, choose binaries. Since we are going to use CLR Profiler to profile our running code, we are going to use the compiled CLR Profiler instead of building and compiling it from the CLR Profiler source code.</p>
<p>After we have downloaded the CLR Profiler 4.5 binaries as a ZIP file, unzip it to any folder. It's recommended not to use a deep folder with nested folders because it may not be searchable, unless we put the folder into <code class="literal">PATH</code> environment variable.</p>
<p>This CLR Profiler can be used to profile 32-bit and 64-bit CLR executables and CLR DLL. There are two binaries for the 32-bit and 64-bit versions, respectively. For the most common case and best practices, we should use the 32-bit CLR Profiler to profile 32-bit CLR executables and DLL.</p>
<p>Before we use CLR Profiler to profile our executable, these are some limitations and warnings about the known consequences of running CLR Profiler to mention:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">CLR Profiler is an intrusive tool; seeing a 10 to 100x slowdown in the application being profiled is not unusual. Therefore, it is not the right tool to find out where time is spent-use other profilers for that.</li>
<li class="listitem">Log files can be huge. By default, every allocation and every call is logged, which can consume gigabytes of disk space. However, allocation and call logging can be turned on and off selectively, either by the application or in the CLR Profiler UI.</li>
<li class="listitem">CLR Profiler cannot <span class="emphasis"><em>attach</em></span> to an application that is already running.</li>
<li class="listitem">CLR Profiler might get caught and be considered harmful by some antivirus programs such as Trend Micro, ESET, and even the older versions of Symantec and Kaspersky. These antiviruses might have treated CLR Profiler as harmful malware or security exploit software. This is truly a false alarm. CLR Profiler must be listed as <span class="emphasis"><em>white list</em></span> for these antivirus programs. Also, update your antivirus detection data.</li>
</ul>
</div>
<p>Now, let's examine our current <code class="literal">FSConsole01</code> project. Open the solution that contains your <code class="literal">FSConsole01</code> project and build it. To ensure that Visual Studio will not interfere with CLR Profiler, close the solution and close Visual Studio.</p>
<p>Go to the folder that you downloaded and extract the CLR Profiler. You shall see two subfolders and one file: subfolders named <code class="literal">32</code>, <code class="literal">64</code>, and a Word document file named <code class="literal">CLRProfiler.doc</code>. The DOC file is actually a complete documentation of how to use CLR Profiler. Open the subfolder of <code class="literal">32</code> and then execute the <code class="literal">CLRProfiler.exe</code> file by opening or by double-clicking it.</p>
<p>A Command Prompt and CLR Profiler UI is shown:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00271.jpeg" alt="A quick walkthrough of CLR Profiler in action"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Ignore the Command Prompt, but do not close it, as it will also close CLR Profiler. Before you start profiling, check the <span class="strong"><strong>Allocations</strong></span> and <span class="strong"><strong>Calls</strong></span> under the <span class="strong"><strong>Profile</strong></span> frame:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00272.jpeg" alt="A quick walkthrough of CLR Profiler in action"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Also ensure that the checkbox of <span class="strong"><strong>Profiling active</strong></span> is always checked.</p>
<p>This is the reason given in the CLR Profiler documentation as to why <span class="strong"><strong>Profiling active</strong></span> is checked:</p>
<div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>The Profiling active check box lets you turn profiling on and off selectively. You can do that either to save time (for example during application startup), or to profile selectively. For example, if you wanted to see what happens in your Windows Forms application when a certain button gets clicked, you would clear this box, start your application, then check the box, click your button, and then clear the box again. Another usage would be to turn this off when starting to profile your ASP.NET application, load a specific page, and then turn it on to see what gets allocated in the steady state for that specific page.</em></span>
</p>
</blockquote>
</div>
<p>Our <code class="literal">FSConsole01</code> is a console application, and it is also a desktop application by nature although it is running as a console application. Therefore, we need to ensure that this checkbox of <span class="strong"><strong>Profiling active</strong></span> is checked.</p>
<p>Click the <span class="strong"><strong>Start Desktop App...</strong></span> button and open <code class="literal">FSConsole01.exe</code> in the <code class="literal">bindebug</code> folder.
</p>
<p>Then, CLR Profiler will show a UI that acts as container of profiling summary:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00273.jpeg" alt="A quick walkthrough of CLR Profiler in action"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>This summary is very important, as it is the starting point before starting to analyze the graphical data generated by CLR Profiler. The data summaries are grouped into sections.</p>
<p>The important sections of the summary are explained here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The section labeled <span class="strong"><strong>Garbage Collection Statistics</strong></span> gives statistics about the garbage collections that happen during the program run. The garbage collector in the .NET CLR is generational, which means that many garbage collections only consider the newest objects on the heap. These are referred to as generation 0 collections and are quite fast. <span class="strong"><strong>Gen 1 collections</strong></span> consider a bigger portion of the heap and are thus a bit slower, while <span class="strong"><strong>Gen 2 collections</strong></span> (also referred to as <span class="emphasis"><em>full collections</em></span>) consider the complete heap and can take a significant amount of time if the heap is large. Thus, you want to see a relatively small number of <span class="strong"><strong>Gen 2 collections</strong></span> compared to <span class="strong"><strong>Gen 1 collections</strong></span> and <span class="strong"><strong>Gen 0 collections</strong></span>. Finally, <span class="strong"><strong>Induced collections</strong></span> are the collections triggered outside of the garbage collector, for example, by calling <code class="literal">GC.Collect</code> from the application. The view reachable via the <span class="strong"><strong>Time Line</strong></span> button will be explained in detail in a short while.</li>
<li class="listitem">The section <span class="strong"><strong>Garbage Collector Generation Sizes</strong></span> gives the sizes of the various garbage collector generations. One additional twist is that there is a special area for large objects called <span class="strong"><strong>Large Object Heap bytes</strong></span>. Note that these numbers are averages over the program run, which may not reflect the situation at the end of the run.</li>
<li class="listitem">The section <span class="strong"><strong>GC Handle Statistics</strong></span> lists how many GC handles have been created, destroyed, and how many are surviving at the end of the program run. If the last number is particularly large, you may have a GC handle leak, which you can investigate by clicking on the <span class="strong"><strong>Allocation Graph</strong></span> button next to the number.</li>
</ul>
</div>
<p>So, why do we focus mainly on garbage collectors (GC)? Because analyzing GCs is very useful for analyzing memory usages when running .NET applications. Examining GCs using CLR Profiler is also helpful when identifying memory leaks before, at, or after garbage collection.</p>
<p>Garbage collections in .NET happen on the heap, and they are available after GC has started. GC manages and stores objects used in the running program in the heap, and this is why it is called a <span class="strong"><strong>managed heap</strong></span>.</p>
<p>The terms gen 0 and gen 1 are the generations of how it handles long-lived and short-lived objects.</p>
<p>There are three generations, as mentioned in the MSDN Library:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Generation 0</strong></span>: This is the youngest generation and contains short-lived objects. An example of a short-lived object is a temporary variable. Garbage collection occurs most frequently in this generation. Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection. Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation. This generation is also called gen 0 or simply Gen0.</li>
<li class="listitem"><span class="strong"><strong>Generation 1</strong></span>: This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects. This generation is also called gen 1 or simply Gen1.</li>
<li class="listitem"><span class="strong"><strong>Generation 2</strong></span>: This generation contains long-lived objects. An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</li>
</ul>
</div>
<p>If there are many objects that are characterized as long-lived objects during the runtime of an application, GC overheads will always occur at the finalization of the garbage collecting. This stage of finalization means that many long-lived objects are often called as having a condition of high cost object finalizations. Analyzing the GC using CLR Profiler will provide us with data on when and where GC overheads occur, especially when GC has many objects to handle (this will be shown as handles in CLR Profiler).</p>
<p>We can reduce the cost of finalization by using objects that implement the <code class="literal">IDisposable</code> interface correctly.</p>
<p>This tip is explained in detail in the following MSDN article by Rico Mariani, one of the architects of .NET BCL: <a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms973837.aspx">https://msdn.microsoft.com/en-us/library/ms973837.aspx</a>.</p>
<p>In this article, it is recommended to use <code class="literal">IDisposable</code> interface for the following reason:</p>
<div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>In many cases it is possible for objects that would otherwise always need to be finalized to avoid that cost by implementing the IDisposable interface. This interface provides an alternative method for reclaiming resources whose lifetime is well known to the programmer, and that actually happens quite a bit. Of course it's better still if your objects simply use only memory and therefore require no finalization or disposing at all; but if finalization is necessary and there are many cases where explicit management of your objects is easy and practical, then implementing the IDisposable interface is a great way to avoid, or at least reduce, finalization costs.</em></span>
</p>
</blockquote>
</div>
<p>The <code class="literal">IDisposable</code> interface has only one method: the <code class="literal">Dispose</code> method. It is crucial if we want to implement <code class="literal">IDisposable</code>, particularly, if the class that implements <code class="literal">IDisposable</code> is available to inherit (not marked with <code class="literal">SealedAttribute</code> in F#). Its detail implementation must obey the rules in the MSDN documentation:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It should provide one <code class="literal">public</code>, non-virtual <code class="literal">Dispose()</code> method and a <code class="literal">protected virtual Dispose(Boolean disposing)</code> method</li>
<li class="listitem">The <code class="literal">Dispose()</code> method must call <code class="literal">Dispose(true)</code> and should suppress finalization for performance</li>
<li class="listitem">The base type should not include any finalizers</li>
</ul>
</div>
<p>Unfortunately, there is no <code class="literal">protected</code> and <code class="literal">virtual</code> modifier support in F#; therefore, we could only use the F# default modifier on the <code class="literal">Dispose</code> method.</p>
<p>It is quite easy in F# to ensure that the <code class="literal">Dispose</code> method is always called after we are done using the object by using F# syntactic sugar of <code class="literal">use</code> or <code class="literal">using</code> keywords, which translate to always call for disposal after the object is no longer in use. It is quite similar to the syntactic <code class="literal">using</code> in C# and VB. More details on this can be found in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
<p>For a starting point to understand more on .NET Garbage Collector, visit the MSDN Library article titled <span class="emphasis"><em>Fundamentals of Garbage Collection</em></span>:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx</a>
</p>
<p>Let's see a sample data of GC handles. In order to have this data presented to us, let's go back and focus our attention on the CLR Profiler's summary window.</p>
<p>Click the <span class="strong"><strong>Allocation Graph</strong></span> button under <span class="strong"><strong>GC Handle Statistics</strong></span> to see and check <span class="strong"><strong>GC handle allocations</strong></span>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00274.jpeg" alt="A quick walkthrough of CLR Profiler in action"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>In the graph, there are some lines and rectangular bars that flow from the leftmost rectangle. These represent the flow of how many handles the GC has. The thicker lines represent the biggest number of handles. These handles are further described in detail as thinner handles that comes from thicker rectangles. In the following text, the rectangular bar represents the program elements.</p>
<p>We can also drill down further by double-clicking the element that we want to examine.</p>
<p>Let's examine the <code class="literal">Program::main</code> element:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00275.jpeg" alt="A quick walkthrough of CLR Profiler in action"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Double-click the rectangular bar above the <code class="literal">Program::main</code>. A new graph window will appear, and it will only display the handles from <code class="literal">Program::main</code>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00276.jpeg" alt="A quick walkthrough of CLR Profiler in action"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Hover the mouse over the rectangle that is labeled <code class="literal">ExtraTopLevelOperators::PrintFormatLine</code>, and a tooltip will show you that this object comes from <code class="literal">FSharp.Core.dll</code>. This tooltip hint is also important if we use references and not just F# core libraries and .NET BCL. We could pinpoint which part of an object holds many handles, drill down into the object, and then hover on it to see which object refers to which DLL library or executable.</p>
<p>We have used CLR Profiler to profile an F# console application. Combined with the knowledge of IL assembly language, CLR Profiler and ILDASM/ILASM provides us with a qualitative point of view for analyzing potential bottlenecks or even opportunities for further optimizations of our code.</p>
<p>Again, it's harder to analyze qualitative data than quantitative, but we can set the qualitative knowledge to further understand quantitative measurement because understanding qualitative data at initial preparation of performance measurement gives us reasoning capability when we analyze our running code using simpler quantitative ways.</p>
</div>
</div>


<div class="section" title="Ways to measure performance quantitatively"><div class="titlepage" id="aid-LTSU2"><div><div><h1 class="title"><a id="ch02lvl1sec15"></a>Ways to measure performance quantitatively</h1>
</div>
</div>
</div>
<p>There are many ways to measure performances of any running .NET code on top of CLR, including F#. So, any tool used to measure F# code is essentially usable for other programming languages on .NET CLR as well.</p>
<p>Again, the easiest way to objectively measure performance is by using quantitative measurements. The following are some common ways of measuring running codes:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Using .NET timers</li>
<li class="listitem">Using native Win32 timer</li>
<li class="listitem">Using Visual Studio Diagnostic</li>
<li class="listitem">Running functions inside unit tests</li>
</ul>
</div>
<p>The previous numbers are ordered from the subtlest and difficult to the quickest way of having statistical timing as performance measurements.</p>
<div class="section" title="Using .NET timers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"></a>Using .NET timers</h2>
</div>
</div>
</div>
<p>There are many timer classes in the .NET Framework but not all of them have a general purpose from the perspective of implementation details and in the context of execution environments.</p>
<p>In the context of execution environments, .NET timers are divided as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">UI timers (timers that are run on an UI thread)</li>
<li class="listitem">Non-UI timer (timers that are run on the common CPU thread)</li>
</ul>
</div>
<p>All UI timers are not always synchronized with a non-UI thread, so they are not guaranteed to have high precision. An example of this is when using <code class="literal">System.Windows.Forms.Timer</code>, while at the same time having a background thread run. In the internal implementation of <code class="literal">System.Windows.Forms.Timer</code>, this object uses the <code class="literal">Win32 WM_TIMER</code> message and processes it in a message loop.</p>
<p>In addition, the behavior of <code class="literal">System.Windows.Forms.Timer</code> is synchronous relative to the other UI thread, and therefore the UI thread processes this message loop of <code class="literal">WM_TIMER</code> as long as it is not processing other Windows messages that come in the middle.</p>
<p>Therefore, an elapsed event of this timer may slip as the timer has no lock on the current UI thread of Windows message loops, especially when there are blocking threads running, such as when downloading from the Internet or printing to a printer.</p>
<p>For the sake of objective measurement and also calculating with as high precision as possible, we are not going to use UI timers and will instead focus on non-UI timers.</p>
<p>The following non-UI timers are available:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">System.Timers.Timer</code></li>
<li class="listitem"><code class="literal">System.Threading.Timer</code></li>
<li class="listitem"><code class="literal">System.Diagnostic.Stopwatch</code></li>
</ul>
</div>
<p>The <code class="literal">System.Timers.Timer</code> is a special case of timers. It may run indirectly on a UI thread, not just on a system worker thread. <code class="literal">System.Threading.Timer</code> always runs on a worker thread, and we cannot mix worker threads and UI threads easily. This condition is raised because the nature of <code class="literal">System.Threading.Timer</code> is asynchronous. But this is also a nice feature to use as it will not lock the running UI thread, since the thread has to be explicitly treated or handled in a different manner.</p>
<p>Using <code class="literal">System.Timer.Timer</code> is easier to use than <code class="literal">System.Threading.Timer</code> as it uses an event model instead of forcing to use callbacks. It's also easier to understand because we can control the number of ticks for triggering the elapsed event.</p>
<p>Let's create a separate project to test the timer of <code class="literal">System.Timers.Timer</code> to measure our function.</p>
<p>Create a new F# console project and name it <code class="literal">FSTimer01</code>. A window editor that shows the opened <code class="literal">Program.fs</code> is now open.</p>
<p>Change the code of <code class="literal">Program.cs</code> as follows:</p>
<pre class="programlisting">open System 
let rec fact x =  
    match x with 
    | 1 -&gt; 1 
    | a when a &lt; 1 -&gt; 1 
    | _ -&gt; x * fact (x-1)  
 
[&lt;EntryPoint&gt;] 
let main argv =  
    let timer1 = new System.Timers.Timer(1.0) 
    let mutable timeElapsed = 0 
    timer1.Enabled &lt;- true 
    timer1.AutoReset &lt;- true 
    timer1.Elapsed.Add (fun _ -&gt; timeElapsed &lt;- timeElapsed + 1) 
    timer1.Start() 
    for cnt = 1 to 3000000 do 
        fact 5 |&gt; ignore  
    timer1.Stop() 
    Console.WriteLine(String.Concat("time elapsed for ", timeElapsed)) 
    0 // return an integer exit code 
</pre>
<p>Run the code by means of running without debugging, and the time elapsed will kick for every 1 millisecond.</p>
<p>On my machine, it shows <code class="literal">time elapsed for 6</code>, meaning the code takes roughly about 6 milliseconds to execute. Again, this may vary on different machines with different configurations.</p>
<p>The previous sample code is not quite accurate in terms of precision because it relies heavily on the elapsed event when it triggered. There might be something that comes before and after the timer has elapsed, and this might block the current thread before the elapsed event and even after the elapsed event is triggered. To use <code class="literal">System.Timers.Timer</code> more accurately, we should not use timer mixed with another blocking thread, such as I/O, or another thread that might change the system state, such as querying or updating operating system settings.</p>
<p>For more details of comparison on these timers (other than Stopwatch), we can see the timers in action in this archived article in MSDN Magazine February 2004 edition (in CHM format):</p>
<p>
<a class="ulink" href="http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineFebruary2004en-us.chm">http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineFebruary2004en-us.chm</a>
</p>
<p>Next, we use <code class="literal">System.Diagnostic.Stopwatch</code>, which is often called Stopwatch. Although this timer is quite similar to <code class="literal">System.Timers.Timer</code>, Stopwatch has its own algorithm flow, and it is clever enough to use a performance counter, as defined in the MSDN Library:</p>
<div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>The Stopwatch measures elapsed time by counting timer ticks in the underlying timer mechanism. If the installed hardware and operating system support a high-resolution performance counter, then the Stopwatch class uses that counter to measure elapsed time. Otherwise, the Stopwatch class uses the system timer to measure elapsed time.</em></span>
</p>
</blockquote>
</div>
<p>A high resolution performance counter is obtained by calling the native (unmanaged) Win32 API of <code class="literal">QueryPerformanceCounter</code>. But this Win32 API should not be used directly as it may require some privileges. particularly elevated privileges. To safely determine that we have a high resolution performance counter available, we should use the properties of Stopwatch, <code class="literal">Frequency</code> and <code class="literal">IsHighResolution</code>.</p>
<p>For more information about <code class="literal">System.Diagnostics.Stopwatch</code>, have a look at the official MSDN documentation:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx</a>
</p>
<p>It is quite easy to use Stopwatch as we do not need to pay attention to any time-elapsed event, because there is no specific elapsed event to handle manually. Stopwatch also uses .NET <code class="literal">TimeSpan</code> to measure how much time has passed from beginning to end.</p>
<p>Using the solution as a timer beforehand, we can test Stopwatch by creating a new project on top of the current solution.</p>
<p>Create a new console project called <code class="literal">FSTimer02</code>. A default <code class="literal">Program.fs</code> editor appears, so then copy the codes from the previous <code class="literal">Program.fs</code> that has the <code class="literal">System.Timers.Timer</code> example, as we are reusing the <code class="literal">fact</code> function.</p>
<p>Change the function body into the following code:</p>
<pre class="programlisting">[&lt;EntryPoint&gt;] 
let main argv =  
    let stopwatch1 = new System.Diagnostics.Stopwatch() 
    stopwatch1.Reset() 
    stopwatch1.Start() 
    for cnt = 1 to 3000000 do 
        fact 5 |&gt; ignore  
    stopwatch1.Stop() 
    let timeDuration = stopwatch1.ElapsedMilliseconds 
    Console.WriteLine(String.Concat("time elapsed in milliseconds:", timeDuration)) 
    0 // return an integer exit code 
</pre>
<p>This time it will show the time duration at a point after the execution of <code class="literal">Stopwatch.Start</code> until the point before <code class="literal">Stopwatch.Stop</code> is executed. The number of milliseconds of the <code class="literal">ElapsedMilliseconds</code> property is actually the same result of <code class="literal">Elapsed</code> as <code class="literal">TimeSpan</code>. Both properties call the same <code class="literal">private</code> method of Stopwatch: the <code class="literal">GetElapsedDateTimeTicks</code> method.</p>
<p>Set the <code class="literal">FSTimer02</code> project as a startup project and then run it. The time shown has a tendency to be higher than the time shown by <code class="literal">System.Timers.Timer</code>. This is as expected because Stopwatch queries to the system performance counter first and then tries to decide whether a performance counter with a higher resolution is available. If it is available, it will try to use it; otherwise, it will use the existing system CPU ticks.</p>
<p>We have experienced how to use .NET timers to measure the duration of the running code. The data available is very useful for comparison, especially when testing different functions, language constructs, and when performing optimizations on inline functions.</p>
<p>But using these timers is not always the best practice, as they may be subject to the Windows' thread scheduler, and other running background Windows processes with the most administrative privileges may interfere, although, it is somehow possible.</p>
</div>
<div class="section" title="Running functions inside unit tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"></a>Running functions inside unit tests</h2>
</div>
</div>
</div>
<p>One of the most common ways to measure is by running and testing our code inside a unit test. It is recommended because you are forced to think about all of the possible scenarios for errors or exceptions that might occur, not just successful scenarios. Here, the term <span class="emphasis"><em>scenario</em></span> means considering various inputs to be tested (including having incorrect or undesirable inputs) that are taken as parameters.
</p>
<div class="section" title="A quick introduction to unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec1"></a>A quick introduction to unit tests</h3>
</div>
</div>
</div>
<p>There are many definitions of a unit test, but a unit test is simply a test that focuses on testing the smallest testable part of a program; this might be a simple function or a complex function that has calls to other functions. To cover the objectivity of the unit test, the test must also cover any scenario of having various inputs to test the results and the possibility of exceptions that may occur.</p>
<p>It is known that unit tests are closely related to <span class="strong"><strong>Test-Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>), where developers focus on possible scenarios that may produce different results or even errors as exceptions. By thinking of the possible scenarios upfront, the chance of having bugs in the implementation is minimized or even close to zero. You can also identify the failing scenarios, particularly when you consider an invalid input for certain functions that contain any operation with potential exceptions, such as division operations, square roots, or even out of memory situations. This is why unit test is one of the examples of TDD in action, as testing scenarios are being thought out before the implementation of the function.</p>
</div>
<div class="section" title="Unit test support in Visual Studio"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec2"></a>Unit test support in Visual Studio</h3>
</div>
</div>
</div>
<p>There are many unit test frameworks in .NET ecosystems, the most popular and widely used being xUnit and NUnit. These two have their own integration with Visual Studio through a test runner UI. Visual Studio itself has built-in support for unit tests; it is a Microsoft Test Framework often called <span class="strong"><strong>MS Test</strong></span>. MS Test provides tooling, classes, and attributes for use to support unit tests, and in conjunction with Visual Studio, the unit test has its own test runner UI support as well.</p>
<p>All of the test frameworks, such as MS Test, xUnit, and NUnit, have integration support as part of the Visual Studio SDK. This extension of test runners inside Visual Studio has been available since Visual Studio 2010. The extensibility is done to extend the base test runner, and the available tests are displayed at Visual Studio <span class="strong"><strong>Test Explorer</strong></span>. The Visual Studio test runner extensibility runs on .NET 4 CLR, so it is language agnostic. We could also create our own extensions in F#, not just by using C# and VB.</p>
<p>For documentation on the Visual Studio Testing Tool API, please visit MSDN at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd465178(v=vs.120).aspx">https://msdn.microsoft.com/en-us/library/dd465178(v=vs.120).aspx</a>.</p>
<p>For more information about the Visual Studio test runner, this is the official starting documentation of Visual Studio SDK:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/bb166441.aspx">https://msdn.microsoft.com/en-us/library/bb166441.aspx</a>
</p>
<p>Unfortunately, F# in Visual Studio has no inherent or template support in the form of a unit test project template, unlike C# and VB. However, we can still leverage MS Test by using the open source library of FsUnit for MS Test. The best part of this FsUnit for the MS Test library is how easy it is to install as a NuGet package.</p>
<div class="note" title="Note"><h3 class="title"><a id="note20"></a>Note</h3>
<p>It is recommended to use F# code files (<code class="literal">.fs</code>), instead of F# scripting, to implement and run F# unit tests. Running a unit test in script mode will yield undesirable results, including runtime exceptions, as the Visual Studio test runner is not meant to run integrated with F# FSI.</p>
</div>
<p>Using FSIUnit is better than using xUnit, NUnit, or MS Test directly because FsUnit is created with the functional programming style at the beginning instead of using the common <code class="literal">Assert</code> method to test the result of a function.</p>
<p>Let's set up FsUnit and use it to implement a unit test in F#.</p>
</div>
<div class="section" title="Using FsUnit to implement a unit test in F#"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec3"></a>Using FsUnit to implement a unit test in F#</h3>
</div>
</div>
</div>
<p>FsUnit itself has support not just for MS Test but also for xUnit and NUnit. FsUnit is part of many F# open source projects under the governance umbrella of the F# Software Foundation (FSSF). All of the F# open source projects have a landing page at this GitHub page, <a class="ulink" href="http://fsprojects.github.io/">http://fsprojects.github.io/</a>.</p>
<p>For more information about FsUnit, visit the official landing page at <a class="ulink" href="https://fsprojects.github.io/FsUnit/index.html">https://fsprojects.github.io/FsUnit/index.html</a>.</p>
<p>Let's import FsUnit for the MS Test NuGet package. First, right-click the project name of <code class="literal">FSConsole01</code>, then choose the <span class="strong"><strong>Manage NuGet packages..</strong></span> menu item. Then, a tab of <span class="strong"><strong>NuGet Package Manager</strong></span> for the &#160;<code class="literal">FSConsole01</code> project appears as&#160;shown in the following screenshot:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00277.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Let's do the following steps to add FsUnit NuGet package into our sample project:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the search text box, type FsUnit and press <span class="emphasis"><em>Enter</em></span>. A list of FsUnit related NuGet packages is shown:<p>
</p><div class="mediaobject"><img src="../Images/image00278.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">Scroll down and choose <span class="strong"><strong>FSUnit30Unit.MSTest</strong></span>:<p>
</p><div class="mediaobject"><img src="../Images/image00279.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">Then, click the <span class="strong"><strong>Install</strong></span> button to download and install this package. Note that the <span class="strong"><strong>Package source</strong></span> is pointing to <span class="strong"><strong>nuget.org</strong></span>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note21"></a>Note</h3>
<p>Throughout the rest of this book, we use NuGet packages to enrich our base experience of coding in F#. The NuGet source itself is not just from <span class="strong"><strong>nuget.org</strong></span>; there are many other NuGet package sources. These NuGet package sources are often called NuGet feeds as these sources are displayed in actual RSS feeds before being listed in the Visual Studio NuGet package manager.</p>
</div>
<p>For more information on NuGet, including how to host and to create your own NuGet packages, visit the NuGet official website at <a class="ulink" href="https://www.nuget.org/">https://www.nuget.org/</a>.</p>
<p>The download and installation process is always projected at the <span class="strong"><strong>Output</strong></span> window of the NuGet package manager.</p>
<p>If the package already exists (hence, installed), then NuGet will check the existing version of the NuGet package. If the version is older, by default it will try to update the existing version and install the newer version.</p>
<p>The successful NuGet installation is shown in the <span class="strong"><strong>Output</strong></span> window of <span class="strong"><strong>Package Manager</strong></span> as <span class="strong"><strong>Finished</strong></span>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00280.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>We can now be sure that <code class="literal">FS30Unit.MsTest</code> is available to use to perform a unit test in F#. However, the main MS Test framework is not yet installed. We have to add this library manually.</p>
<p>The name of the MS Test framework library is <code class="literal">Microsoft.VisualStudio.QualityTools.UnitTestFramework</code>.</p>
<p>This library is available as an extension library in the .NET project. It is also in the existing .NET <span class="strong"><strong>global assembly cache</strong></span> (<span class="strong"><strong>GAC</strong></span>) in Windows, installed by default by Visual Studio 2015 Community Edition and above.</p>
<p>In previous versions of Visual Studio before Visual Studio 2010, the name of the library was different, and it was named <code class="literal">Microsoft.VisualStudio.TestTools.UnitTesting</code>. The change of the name reflects that the Visual Studio Unit Test Framework has been part of Microsoft Visual's Studio Quality Tools since the release of Visual Studio 2010, including Microsoft Coded UI Test, Web Test, and Windows Store Test.</p>
<p>The documentation of the classes and attributes of Visual Studio Unit Test Framework in Visual Studio 2015 is available at&#160;<a class="ulink" href="https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting(v=vs.140).aspx">https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting(v=vs.140).aspx</a>.</p>
<p>Add this <code class="literal">Microsoft.VisualStudio.QualityTools.UnitTestFramework</code> by adding references to the project, and then choose the&#160;<span class="strong"><strong>Extensions</strong></span> tab:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00281.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Now that we have that set up, and it is available for use, we can now code the unit test. We can also combine our entrypoint for the F# console with the factorial function and the unit test. It is also recommended to separate the factorial function from the main module that has an entrypoint as the concern of the module that has the entrypoint is actually different from the factorial function.</p>
<p>Always pay attention to the indentation inside the modules, types, and the functions. F# always relies on the indentation to mark wrong indentation as that will always result in compiling errors.</p>
<p>This is the official guideline on code indentation in F#:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/code-formatting-guidelines-%5Bfsharp%5D">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/code-formatting-guidelines-%5Bfsharp%5D</a>
</p>
<p>First, we have to set multiple module files to be compiled correctly for this console project. The entrypoint of <code class="literal">Program.fs</code> needs to be modified to be included in an explicit module under the namespace, <code class="literal">FSConsole01</code>.</p>
<p>In <code class="literal">Program.fs</code> in the code window, type the following code:</p>
<pre class="programlisting">namespace FSConsole01 
 
module Program = 
 
    [&lt;EntryPoint&gt;] 
    let main argv =  
        printfn "Hello F# world" 
        0 // return an integer exit code 
</pre>
<p>Build it, and an error warning will show the following message:</p>
<pre class="programlisting">A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence, and can only be used when compiling to a .exe 
</pre>
<p>Ignore this error for now, as we will fix this later.</p>
<p>Let's move our factorial function into the unit test.</p>
<p>Create a new F# source file and name it <code class="literal">FSConsoleUnitTest</code>.</p>
<p>Type the following in the code window:</p>
<pre class="programlisting">namespace FSConsole01 
    open Microsoft.VisualStudio.TestTools.UnitTesting 
    open FsUnit.MsTest 
 
    module MathFunc = 
            let rec fact x =  
                match x with 
                | 1 -&gt; 1 
                | a when a &lt; 1 -&gt; 1 
                | _ -&gt; x * fact (x-1)  
 
    module FSConsoleUnitTest = 
 
        [&lt;TestClass&gt;] 
        type FactTest() = 
            class 
                [&lt;TestMethod&gt;] 
                member this.FactTest01() = 
                    MathFunc.fact 3 |&gt; should equal 6 
            end 
</pre>
<p>The code in the <code class="literal">FSConsoleUnitTest</code> module shows that we now have a class of <code class="literal">FactTest</code> and the method to be our unit test.</p>
<p>The <code class="literal">TestClass</code> attribute on <code class="literal">FactTest</code> means that this class will be used by the test runner as the starting class to hold the unit test. The <code class="literal">TestMethod</code> attribute on <code class="literal">FactTest01</code> means that this method is our unit test under the <code class="literal">FactTest</code> class.</p>
<p>This is a common convention as the class to be used for a unit test cannot be a static class. The nature of a unit test is instantiating the class that has the attribute of <code class="literal">TestClass</code> before running the tests inside the methods with the <code class="literal">TestMethod</code> attribute.</p>
<p>For more information on creating, running, and debugging unit tests using MS Test (and also for other test frameworks) in Visual Studio 2015, visit this MSDN Library:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/library/dd264975">https://msdn.microsoft.com/library/dd264975</a>
</p>
<p>Let's fix the previous error by reordering <code class="literal">Program.fs</code> to be the last order of the file order. We do this by right-clicking <code class="literal">Program.fs</code> and moving down <code class="literal">Program.fs</code>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00282.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Ensure that <code class="literal">Program.fs</code> is the last file.</p>
<div class="note" title="Note"><h3 class="title"><a id="note22"></a>Note</h3>
<p>Note that file ordering in F# is very important.</p>
</div>
<p>Build the project. Then, display the <span class="strong"><strong>Test Explorer</strong></span> window if it's not open. On the General collection default setting, the <span class="strong"><strong>Test Explorer</strong></span> menu item is available under the main menu <span class="strong"><strong>Test</strong></span>.</p>
<p>The <code class="literal">FactTest01</code> test will be shown in the <span class="strong"><strong>Test Explorer</strong></span> as follows:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00283.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Let's run the test by clicking <span class="strong"><strong>Run All</strong></span> on the <span class="strong"><strong>Test Explorer</strong></span>. <span class="strong"><strong>Test Explorer</strong></span> will display the number of milliseconds it takes to run the unit test on the right of the test method name:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00284.jpeg" alt="Using FsUnit to implement a unit test in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The number of milliseconds may vary depending on different hardware, because it is influenced by the speed of the CPU and the number of CPU cores. The function we have tested is a simple function, but we can have a function that has parallel calls by utilizing .NET Task Parallel Library (TPL). The consequences of the usage of .NET TPL are that numbers can vary greatly across different systems with different configurations, such as the operating system used (in this context, the Windows version and edition) and different CPU specifications.</p>
<p>For example, testing using a machine that has a 4th generation core i7 2.4 Ghz CPU might be a little bit faster than a machine that has a 6th generation core i5 2.2 Ghz CPU. The number of cores may have some influence as well, as the number of cores in a modern CPU is always increasing.</p>
<p>In our code, there is no direct use of MS Test's Assert at all. This is actually available under the cover of FsUnit. We can look at FsUnit source codes in the GitHub repository of FsUnit, in particular, FsUnit code to support MS Test. All the code related to MS Test is under the folder named <code class="literal">FsUnit.MsTestUnit</code>.</p>
<p>To recap again, FsUnit has support for the NUnit and xUnit test frameworks, and both of them use the same context of implementing <code class="literal">Assert</code> methods under the cover of a functional FsUnit. You may use test frameworks other than MS Test, as long as they are supported by FsUnit. It is recommended to participate with or contribute to FsUnit as this project is encouraging contributors to support other test frameworks such as MbUnit.</p>
<p>At the time of writing, FsUnit supports both F# 3.1 and F# 4.0. But it is recommended to use FsUnit with F# 4.0 because this will provide you with the highest compatibility with the .NET 4.5 and .NET 4.6 frameworks. In addition, F# 4.0 is the closest work in progress to the future release of F#, which will provide support for .NET Core.</p>
<p>The FsUnit GitHub repository is available at <a class="ulink" href="https://github.com/fsprojects/FsUnit">https://github.com/fsprojects/FsUnit</a>.</p>
</div>
</div>
</div>


<div class="section" title="Summary" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"></a>Summary</h1>
</div>
</div>
</div>
<p>You learned that you can measure performance quantitatively and qualitatively. Although it is easier to have quantitative measurement than qualitative measurement, it is quite straightforward and common to have quantified data as a foundation to have qualitative analysis.</p>
<p>With the help of .NET tooling ecosystem and libraries available at our disposal, we can ensure the objectiveness of our performance measurement. It is also recommended to have a basic understanding of .NET CLR memory management as our foundation to have performance measurement from the perspective of qualitative analysis.</p>
<p>We will start exploring the aspects of performance optimizations with the knowledge and concept in this chapter, starting from F# data structures in <a class="link" title="Chapter&#160;3.&#160;Optimizing Data Structures" href="fsp-hiperf_cu03.html#aid-NQU22">Chapter 3</a>, <span class="emphasis"><em>Optimizing Data Structures</em></span>.</p>
</div>
</body>
</html>