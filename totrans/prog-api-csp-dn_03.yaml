- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Implementing with REST
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST实现
- en: In the previous chapter, we created a simple database and object ( **Car** )
    to interact with. In this chapter, we’ll look at the **Representation State Transfer**
    ( **REST** ) protocol and how it is used in APIs. REST is the most popular protocol
    for creating APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个简单的数据库和对象（**Car**）来与之交互。在本章中，我们将探讨**表示状态转移**（**REST**）协议及其在API中的应用。REST是创建API最流行的协议。
- en: 'We will see how REST contributes to creating a client/server architecture,
    and with it, desirable separation of concerns. We will cover the following topics
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到REST如何有助于创建客户端/服务器架构，以及与之相关的职责分离。在本章中，我们将涵盖以下主题：
- en: Understanding what REST is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解REST是什么
- en: Looking at standard web protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看标准网络协议
- en: The first implementation of a REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个REST API的实现
- en: What **Data Transfer Objects** ( **DTOs** ) are and how to use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输对象**（**DTOs**）是什么以及如何使用它们'
- en: Using Postman as our frontend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postman作为我们的前端
- en: By the time you finish this chapter, you will understand the fundamentals of
    creating simple APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到你完成本章时，你将理解创建简单API的基础知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need **Visual Studio** , **AutoMapper** , and **Dapper**
    . Please see [*Chapter 1*](B21998_01.xhtml#_idTextAnchor013) , *Getting Started*
    , for how to obtain these. The code files for this chapter can be found in the
    GitHub repository here: [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要**Visual Studio**、**AutoMapper**和**Dapper**。请参阅[*第1章*](B21998_01.xhtml#_idTextAnchor013)，“入门”，了解如何获取这些工具。本章的代码文件可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03)
- en: REST
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: One of the key concepts in REST is the separation of concerns. This idea will
    be familiar to you as a C# programmer. Here, we are separating the concerns of
    the server and the client.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的一个关键概念是职责分离。这个想法对于C#程序员来说应该是熟悉的。在这里，我们正在分离服务器和客户端的职责。
- en: The API can only respond to calls from the client, and cannot generate calls
    of its own. Note that within the logic of the API implementation, it is possible
    to call other APIs, but not back to the client.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: API只能响应来自客户端的调用，不能生成自己的调用。请注意，在API实现的逻辑中，可以调用其他API，但不能反向调用客户端。
- en: The server is in no way dependent on the design or implementation of the client.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在没有任何方式上依赖于客户端的设计或实现。
- en: Client/server
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器
- en: 'The key to a REST application is that the API can be called by any type of
    client: web application, phone application, and so on. Further, the client can
    be located anywhere and there are no constraints on the architecture of the client.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: REST应用程序的关键在于API可以被任何类型的客户端调用：Web应用程序、手机应用程序等等。此外，客户端可以位于任何地方，并且对客户端架构没有约束。
- en: 'The same is true for the backend, behind the API. Typically, this will be a
    database, but it can be any type of data storage: relational, object, in memory,
    and so on.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 后端也是如此，在API之后。通常，这将是一个数据库，但它可以是任何类型的数据存储：关系型、对象型、内存型等等。
- en: One way to accomplish this, is to use the standard web protocols such as **GET**
    , **PUT** , and so forth. This approach is essential to REST. In fact, for many
    people this is the virtual definition of REST.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法，是使用标准Web协议，如**GET**、**PUT**等等。这种方法对于REST至关重要。事实上，对于许多人来说，这是REST的虚拟定义。
- en: Using web protocols
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web协议
- en: 'In REST, we use the same verbs as we do in HTTP: **GET** , **PUT** , **POST**
    , and **DELETE** . In addition, the API returns standard web values to the client,
    for example, **404 (not found)** , **200 (success)** , **201 (created)** , and
    so on.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，我们使用与HTTP相同的动词：**GET**、**PUT**、**POST**和**DELETE**。此外，API会向客户端返回标准Web值，例如，**404（未找到）**、**200（成功）**、**201（已创建）**等等。
- en: Each request from the client to the API will consist of an HTTP header, body,
    and meta-data. The client expresses which API is wanted by calling a URL, and
    passes needed data (e.g., the **id value for the requested entity** either in
    the URL or, if passing too much data for a URL, in the body of the request. For
    example, here is a POST to add a car to the backend database. Don’t worry about
    the syntax for now; rather, take a look at the URL and the body of the request
    in *Figure 3* *.1* .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向API的每个请求将包括一个HTTP头部、正文和元数据。客户端通过调用URL来表示想要的API，并传递所需的数据（例如，请求实体的**id值**，要么在URL中，要么如果传递给URL的数据过多，则在请求的正文里。例如，这里是一个向后端数据库添加汽车的POST请求。现在不必担心语法；而是看看图3.1中的URL和请求正文。
- en: '![Figure 3.1 – Sending data for insertion](img/B21988_03_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 插入数据](img/B21988_03_1.jpg)'
- en: Figure 3.1 – Sending data for insertion
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 插入数据
- en: At the top of the figure, we see the URL (https://localhost:7025/Car). This
    is the “address” of the API. Notice that the last part of the URL is *Car* . This
    is the name of the controller.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的最上方，我们看到URL（https://localhost:7025/Car）。这是API的“地址”。请注意，URL的最后部分是*Car*。这是控制器的名称。
- en: Below the URL is a menu allowing you to see the parameters being sent, the Authorization
    any headers that go along as meta-data (see *Figure 3* *.2* ), the body that we
    see in *Figure 3* *.1* , any scripts to run before sending the request, tests
    to ensure we are getting back the right data (see [*Chapter 8*](B21998_08.xhtml#_idTextAnchor105)
    , *Advanced Topics* ), and any settings we need for the request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL下方有一个菜单，允许您查看正在发送的参数、作为元数据一起发送的授权和任何头部（参见*图3.2*），我们在*图3.1*中看到的正文，在发送请求之前要运行的任何脚本，确保我们得到正确数据的测试（参见[*第8章*](B21998_08.xhtml#_idTextAnchor105)
    ，*高级主题*），以及我们需要的任何请求设置。
- en: The numbered lines 1-12 in the preceding figure are the body of this request.
    We are inserting a car into the database and so all the data for the insertion
    is here in JSON format. Notice that there is no ID; that will be assigned on the
    backend.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中编号为1-12的行是此请求的主体。我们正在将一辆车插入数据库，因此所有插入数据都在这里以JSON格式提供。请注意，这里没有ID；这将在后端分配。
- en: '![Figure 3.2 – Headers](img/B21988_03_2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 头部](img/B21988_03_2.jpg)'
- en: Figure 3.2 – Headers
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 头部
- en: These headers provide vital information to the server. They must be sent for
    each interaction because REST is inherently stateless.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头部向服务器提供了关键信息。由于REST本质上是无状态的，因此必须为每次交互发送它们。
- en: Statelessness and caching
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态和缓存
- en: REST APIs are stateless, so you must treat each call to the API as independent
    from all other calls.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: REST API是无状态的，因此您必须将每个API调用视为与其他所有调用独立。
- en: Note that if you need state and you are on Azure, you’ll want a durable function,
    which is covered in [*Chapter 7*](B21998_07.xhtml#_idTextAnchor094) , *Azure*
    *Durable Functions* .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您需要在Azure上使用状态，您将需要一个持久化函数，这在[*第7章*](B21998_07.xhtml#_idTextAnchor094)中有所介绍，即*Azure*
    *持久化函数*。
- en: While you cannot maintain state between calls, the server can cache data for
    faster retrieval. This can significantly improve performance There are a number
    of platforms that can support REST APIs; the one we will focus on for this book,
    and the platform of choice for .NET, is ASP.NET Core.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您不能在调用之间保持状态，但服务器可以缓存数据以实现更快的检索。这可以显著提高性能。有许多平台可以支持REST API；我们将在这本书中关注的一个平台，也是.NET的首选平台，是ASP.NET
    Core。
- en: 'An alternative to REST is GraphQL. There are two problems this designed to
    solve: overfetching and underfetching. The user wants to send a single API call
    to the server. In order to do this, they must designate what data is needed. If
    a Car entity is requested, it may be that they don’t care at all about some of
    the features of the car but they get the entire car as part of the API. This is
    called overfetching. On the other hand, if they designate an API that only gets
    the type of car, this may be under fetching (they have to make a second call for
    the rest of what they need). GraphQL is designed to solve this problem, allowing
    the client to specify exactly which properties are requested.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: REST的替代方案是GraphQL。这个设计旨在解决两个问题：过度获取和不足获取。用户希望向服务器发送单个API调用。为了做到这一点，他们必须指定所需的数据。如果请求了Car实体，他们可能根本不关心汽车的一些特性，但他们作为API的一部分收到了整个汽车。这被称为过度获取。另一方面，如果他们指定了一个只获取汽车类型的API，这可能就是不足获取（他们必须进行第二次调用以获取所需的其他部分）。GraphQL旨在解决这个问题，允许客户端指定确切请求哪些属性。
- en: That said, the downside of GraphQL is that each API query must be hand-crafted
    to designate what is wanted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，GraphQL 的缺点是每个 API 查询都必须手工制作以指定所需的内容。
- en: Because of this, and other technical constraints, not the least of which is
    inertia, REST is by far the most popular way to write APIs and we will not cover
    GraphQL in this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点和其他技术限制，尤其是惯性，REST 是编写 API 最受欢迎的方式，我们不会在本书中涵盖 GraphQL。
- en: Implementing REST in ASP.NET Core
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中实现 REST
- en: 'An API created in ASP.NET Core will typically have three major components:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 中创建的 API 通常有三个主要组件：
- en: Controllers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Services
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Repositories
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: There is an alternative to controller-based APIs known as Minimal APIs. We discuss
    this in brief towards the end of this chapter (refer to the *Minimal APIs* box).
    We do not cover Minimal APIs for the rest of the book as they have too many limitations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于控制器的 API 之外，还有一种称为 Minimal APIs 的替代方案。我们将在本章末尾简要讨论这一点（参见图表 *Minimal APIs*）。由于它们有很多限制，本书的其余部分不会涵盖
    Minimal APIs。
- en: When you invoke an API with a URL, that address is resolved to a controller.
    For example, using the URL we saw earlier, if you call https://localhost:7025/Car,
    you will invoke the **CarController** at that address. Note that ASP.NET uses
    “convention over configuration,” by which we mean that *by convention* , the part
    of the word Controller is left off the address but is implied. So in this case,
    **CarController** , the address just uses **Car** (leaving off Controller).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 URL 调用一个 API 时，该地址会被解析为一个控制器。例如，使用我们之前看到的 URL，如果你调用 https://localhost:7025/Car，你将调用该地址处的
    **CarController**。请注意，ASP.NET 使用“约定优于配置”，这意味着*按照惯例*，单词 Controller 的一部分被从地址中省略，但隐含在其中。所以在这种情况下，**CarController**，地址只使用
    **Car**（省略 Controller）。
- en: The job of the controller is to ensure that the user has been authenticated
    (it’s really them) and authorized (they have permission to take whatever action
    is invoked). The controller then assembles any needed data and passes it along
    to the Service. Typically, but not necessarily, this will be called **CarService**
    and will sit in a folder with other services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的任务是确保用户已经认证（确实是他们）并且授权（他们有权执行所调用的任何操作）。然后控制器组装所需的数据并将其传递给服务。通常，但不一定，这将被称为
    **CarService**，并将位于包含其他服务的文件夹中。
- en: The job of the Service is to handle any business logic and prepare the data
    to go into the database. It then passes the data to the repository.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的任务是处理任何业务逻辑并将数据准备好输入数据库。然后它将数据传递给存储库。
- en: Similar to the Service, the repository would typically be called **CarRepository**
    and would be located in a folder along with other repositories. The job of the
    repository is to interact with the underlying data storage (for example, a database).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务类似，存储库通常被称为 **CarRepository**，并将位于与其他存储库相同的文件夹中。存储库的任务是与底层数据存储（例如，数据库）交互。
- en: Often, you will want to separate the properties of the database from the properties
    of an object to be sent through the API. For that, we use DTOs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你将想要将数据库的属性与通过 API 发送的对象的属性分开。为此，我们使用 DTOs。
- en: DTOs
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTOs
- en: It is common to use DTOs to separate the representation of the structure of
    the database from a supporting **Plain Old C#** **Object** ( **POCO** )
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DTOs 将数据库结构的表示与支持 **Plain Old C#** **Object** ( **POCO** ) 分离是很常见的。
- en: Let’s take an example from a relational database. Each row may have twelve columns
    but for a specific API request, only seven are needed. The DTO will be a class
    with seven properties, and we’ll use a tool ( **AutoMapper** ) to map the values
    in the seven columns to the seven properties.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个关系型数据库的例子开始。每一行可能有十二列，但对于特定的 API 请求，只需要七列。DTO 将是一个具有七个属性的类，我们将使用一个工具（**AutoMapper**）将七个列中的值映射到七个属性。
- en: Installing AutoMapper
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 AutoMapper
- en: 'The easiest way to install **AutoMapper** is to download the NuGet packages,
    as shown in *Figure 3* *.3* :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 **AutoMapper** 最简单的方法是下载 NuGet 包，如图 *图 3.3* 所示：
- en: '![Figure 3.3 – Installing AutoMapper](img/B21988_03_3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 安装 AutoMapper](img/B21988_03_3.jpg)'
- en: Figure 3.3 – Installing AutoMapper
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 安装 AutoMapper
- en: 'There is a bit of configuration for **AutoMapper** , but it is only done once.
    In **Program.cs** , add the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **AutoMapper** 来说，有一些配置要做，但只需做一次。在 **Program.cs** 中添加以下内容：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next step is to create the DTO class itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 DTO 类本身。
- en: Creating the DTO class
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 DTO 类
- en: 'The POCO classes we’ve created directly track the columns in the database,
    as described earlier. The DTO class tracks some or all of these columns as properties:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 POCO 类直接跟踪数据库中的列，如前所述。DTO 类跟踪这些列的一些或全部属性：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once your DTO is in place, you need a way to map the properties in the DTO to
    the properties in the database (POCO) class. We can do that in a profile.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的 DTO 设置好，你需要一种方法将 DTO 中的属性映射到数据库（POCO）类中的属性。我们可以在配置文件中做到这一点。
- en: Setting up the profile
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: While we are here, let’s set up the profile file for the **Car** entity. The
    **AutoMapper** tool (no pun intended) provides a base class, **Profile** , that
    we will derive from.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们为 **Car** 实体设置配置文件。**AutoMapper** 工具（无意中）提供了一个基类，**Profile**，我们将从中派生。
- en: 'Create a file called **CarProfile.cs** and put this code in it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 **CarProfile.cs** 的文件，并将此代码放入其中：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that for every member that we want to share between the DTO and the POCO
    class, there is an entry. At the bottom is **ReverseMap** , which, as you may
    have guessed, reverses the mapping (for example, it causes the map to go from
    **DTO > Car** to **Car >** **DTO** ).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于每个我们想要在 DTO 和 POCO 类之间共享的成员，都有一个条目。底部是 **ReverseMap**，正如你可能猜到的，它反转了映射（例如，它使映射从
    **DTO > Car** 转换为 **Car > DTO**）。
- en: We have taken care of the DTO; now we need to connect our POCO to the database.
    We’ll do that with Dapper.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了 DTO；现在我们需要将我们的 POCO 连接到数据库。我们将使用 Dapper 来完成这项工作。
- en: Dapper
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dapper
- en: As noted earlier, we will use Dapper as our **Object Relational Model** ( **ORM**
    ). This will greatly simplify our interaction between the repository and the database.
    Dapper has its own syntax but it is very (very) close to SQL and the points of
    departure will be obvious.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用 Dapper 作为我们的 **对象关系模型** ( **ORM** )。这将极大地简化我们与数据库的交互。Dapper 有自己的语法，但它非常（非常）接近
    SQL，起点将很明显。
- en: Installing Dapper
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Dapper
- en: To install and use Dapper, please see their very straightforward and comprehensive
    instructions at [https://www.learndapper.com/](https://www.learndapper.com/)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装和使用 Dapper，请参阅他们非常直接且全面的说明，见 [https://www.learndapper.com/](https://www.learndapper.com/)
- en: 'Here, for example, is the Dapper code to get a car by ID:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是通过 ID 获取汽车的 Dapper 代码：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can create more complex statements with conditional logic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用条件逻辑创建更复杂的语句。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dapper uses C# rather than SQL syntax except for the query itself. This makes
    interacting with the database much easier for C# programmers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper 使用 C# 而不是 SQL 语法（除了查询本身）。这使得 C# 程序员与数据库的交互变得更加容易。
- en: That is really all you need to know to get started creating your API. Let’s
    try inserting a car into the database using the API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要知道的所有内容，以便开始创建你的 API。让我们尝试使用 API 将一辆车插入到数据库中。
- en: Examining the SQL
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 SQL
- en: The SQL (pronounced See-Quill) in the above example can almost be read as an
    English sentence. First, we use the keyword SELECT to indicate that we want to
    pick out and return a subset of the data in the Database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的 SQL（发音为 See-Quill）几乎可以读作一个英文句子。首先，我们使用关键字 SELECT 来表示我们想要选择并返回数据库中的数据子集。
- en: Next comes the asterisk ( ***** ) which indicates that we want all the columns.
    The alternative is to list the columns we want.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是星号（ ***** ），它表示我们想要所有列。另一种选择是列出我们想要的列。
- en: '**From Cars C** indicates that we want the data to come from the **Cars** table,
    and that we will be using the alias **C** to refer to that table.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**From Cars C** 表示我们希望数据来自 **Cars** 表，并且我们将使用别名 **C** 来引用该表。'
- en: The **Where** statement constrains the search to the criteria that follows it,
    in this case where the id of the car (using the alias C) matches the id we’re
    looking for. We then tack on “ **where is_deleted = 0** ” indicating that we only
    want entries that are not marked as deleted.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Where** 语句将搜索限制为随后的条件，在这种情况下，汽车的 id（使用别名 C）与我们要查找的 id 匹配。然后我们附加“ **where
    is_deleted = 0** ”，表示我们只想获取未标记为已删除的条目。'
- en: Here is where Dapper comes in. We set up an array of parameters, and then
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Dapper 用来通过 ID 获取汽车的代码：
- en: 'call: **QueryFirstOrDefaultAsync<Car>(sql, param);**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'call: **QueryFirstOrDefaultAsync<Car>(sql, param);**'
- en: This invokes the **QueryFirstOrDefault** method in dapper. We pass in the type
    of object we are looking for (Car) and then two parameters. For our purposes,
    the first will always be SQL, and the second will always be the name of the collection
    we created above (param).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 dapper 中的 **QueryFirstOrDefault** 方法。我们传入我们正在寻找的对象类型（Car）和两个参数。在我们的情况下，第一个始终是
    SQL，第二个始终是我们上面创建的集合的名称（param）。
- en: We assign the result (in this case one car) to a variable, and return that value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果（在这种情况下是一辆车）分配给一个变量，并返回该值。
- en: Please note that the constructor for this class will have interfaces passed
    in through Dependency Injection, and those parameters will be assigned to member
    variables (for example, _ **carService** ). If you are not familiar with Dependency
    Injection, please refer to the code in the repository.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此类的构造函数将通过依赖注入传递接口，并将这些参数分配给成员变量（例如，_ **carService**）。如果您不熟悉依赖注入，请参阅存储库中的代码。
- en: Putting it all together (inserting a car)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容组合起来（插入一辆车）
- en: 'Let’s put this together using controller, service, and repository to insert
    a car with Dapper and AutoMapper:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用控制器、服务和存储库结合Dapper和AutoMapper来插入一辆车：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that we’ve transformed the DTO to a database object ( **Car** ), which
    we then pass to the service:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将DTO转换为数据库对象（**Car**），然后将其传递到服务：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are now ready to pass this car to the repository for storage in our database:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备将这辆车传递到存储库，以便在我们的数据库中存储：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we get a valid new car, we pass back the **newId value** , which we check
    for in the service. However, that is a lot of data we are passing to the API.
    We’ll look at solving that problem in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个有效的新车，我们将返回**newId值**，这在服务中进行检查。然而，我们传递给API的数据量很大。我们将在下一节中探讨解决这个问题。
- en: 'A note on dependency injection: as you know, we pass in interfaces to our methods
    so that we can support dependency injection. This is set up in **Program.cs**
    , and the injection itself is automatic.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于依赖注入的说明：正如您所知，我们向方法传递接口，以便支持依赖注入。这已在**Program.cs**中设置，而注入本身是自动的。
- en: Creating the body in Postman
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Postman中创建正文
- en: 'As you can see, the data that we want to pass into the API will be too much
    for the query string, and so we will pass it into the body. We can signal this
    in the definition of the API by writing the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们想要传递给API的数据对于查询字符串来说太多，因此我们将将其传递到正文。我们可以在API定义中通过编写以下内容来表示这一点：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Every API call will have zero or more **FromQuery** , **FromUrl** , and **FromBody**
    attributes. In this case, we are just using **FromBody** . Our call through Postman
    is seen in *Figure 3* *.4* :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API调用都将有零个或多个**FromQuery**、**FromUrl**和**FromBody**属性。在这种情况下，我们只是使用**FromBody**。我们的Postman调用如图*3.4*所示：
- en: '![Figure 3.4 – Inserting a car](img/B21988_03_4.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 插入一辆车](img/B21988_03_4.jpg)'
- en: Figure 3.4 – Inserting a car
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 插入一辆车
- en: Here, we are inserting all the properties of the car (except the ID value) as
    seen in the top window. To do this, we would adjust the SQL statement to take
    all the properties. Notice that the API returns the properties of the inserted
    car, including its **id** (bottom window). The return code will be **201** (created).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将车辆的除ID值之外的所有属性（如顶部窗口所示）插入。为此，我们需要调整SQL语句以获取所有属性。请注意，API返回插入车辆的属性，包括其**id**（底部窗口）。返回代码将是**201**（已创建）。
- en: Since we are looking for the data in the body of the request, the URL is just
    the address of the controller.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在查找请求正文中的数据，因此URL只是控制器的地址。
- en: We have inserted a single car, but I have pre-seeded the database with many
    more. Let’s use the API to see them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已插入一辆车，但我已经预先在数据库中插入了更多。让我们使用API来查看它们。
- en: Get all
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取所有
- en: 'To get a list of all the cars in the database, we begin in the controller:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数据库中所有车的列表，我们从控制器开始：
- en: 'Warning: the following example shows calling the repository directly for illustration
    purposes. Shortly afterwards we will discuss the correct way to do this.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：以下示例仅用于说明目的，直接调用存储库。不久之后，我们将讨论正确的方法。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we call the repository directly. This is an alternative to calling the
    service, and is generally a bad practice, but I wanted to show how it is done.
    Notice that we include a Boolean parameter as to whether to return the deleted
    records as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接调用存储库。这是调用服务的一种替代方法，但通常是一种不好的做法，但我想要展示如何进行。请注意，我们包括一个布尔参数，以确定是否返回已删除的记录。
- en: Normally, we would use a **Service** class for separation of concerns. The service
    class would contain the program logic and would sit between the controller and
    the repository.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会使用**Service**类来实现关注点的分离。服务类将包含程序逻辑，并位于控制器和存储库之间。
- en: 'In the repository, we build our **SqlBuilder** (as we saw earlier in the section
    on *Dapper* ) and obtain the records:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，我们构建我们的**SqlBuilder**（如我们在*Dapper*部分中之前所见）并获取记录：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s take that one line at a time. The first line indicates that we will return
    a list of **Car** objects and the decision as to whether or not to return deleted
    records defaults to **false** .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析。第一行表示我们将返回一个**Car**对象的列表，而是否返回已删除记录的决策默认为**false**。
- en: We next create a **SqlBuilder** object and then set the **SqlTemplate** object
    to select everything from the car.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来创建一个**SqlBuilder**对象，然后设置**SqlTemplate**对象以选择所有车辆。
- en: Notice the **/**where**/** statement. This is a Dapper convention indicating
    that a **where** clause may be placed here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到**/**where**/**语句。这是一个Dapper约定，表示可以在这里放置一个**where**子句。
- en: We will now check to see whether the deleted records are to be included, and
    if not, we add a where clause using the builder we created on the first line.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查是否需要包含已删除的记录，如果不包含，我们将使用我们在第一行创建的构建器添加一个where子句。
- en: We are ready to get the Database from the factory we created and then query
    the database, passing in the **RawSql** code created for use in the **SqlTemplate
    object** and the parameters. In this case, there are no parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好从我们创建的工厂获取数据库，然后查询数据库，传入用于在**SqlTemplate对象**中使用的**RawSql**代码和参数。在这种情况下，没有参数。
- en: What we get back is an array of **Car** objects, which we return to the calling
    method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个**Car**对象的数组，我们将它返回给调用方法。
- en: 'To test this, we set Postman to **Get** and the URL to https://localhost:7025/Car.
    Since no ID is provided, our code will get them all, as shown in *Figure 3* *.5*
    :'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我们将Postman设置为**Get**，并将URL设置为https://localhost:7025/Car。由于没有提供ID，我们的代码将获取所有车辆，如图*图3*.*5*所示：
- en: '![Figure 3.5 – Getting all the cars in the database](img/B21988_03_5.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 获取数据库中的所有车辆](img/B21988_03_5.jpg)'
- en: Figure 3.5 – Getting all the cars in the database
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 获取数据库中的所有车辆
- en: Having inserted records, we may want to change one or another. To do that, we’ll
    want to use the **Put** verb.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 插入记录后，我们可能想要更改一个或多个。为此，我们将想要使用**Put**动词。
- en: Update
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: Updating uses the HTTP **Put** verb. Let’s trace through how it is done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作使用HTTP **Put**动词。让我们追踪一下它是如何完成的。
- en: 'We return to the controller and add an **HttpPut** attribute. We then indicate
    that the contents will be in the body of the request (rather than the query) as
    we saw in the insert:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到控制器，添加一个**HttpPut**属性。然后我们指出内容将位于请求体中（而不是查询中），正如我们在插入时所见：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we can’t be certain that the record we want to update is still in the
    database, we put the call in a try block, and if we get an exception, we call
    **BadRequest** . Interestingly, if we succeed, we call **NoContent** as we are
    not adding anything to the database:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法确定我们想要更新的记录是否仍然在数据库中，我们将调用放在try块中，如果发生异常，我们调用**BadRequest**。有趣的是，如果我们成功，我们调用**NoContent**，因为我们没有向数据库添加任何内容：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As shown, from here we call the **carService** ’s **Update** method, passing
    in the car we want to update. Note that some programmers use **OK** rather than
    **NoContent** .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，从这里我们调用**carService**的**Update**方法，传入我们想要更新的车辆。请注意，一些程序员使用**OK**而不是**NoContent**。
- en: 'In the service, we’ll make sure we got a valid car **id value** and then call
    **UpsertAsync** , passing in the car. If we get back any **id** value except the
    original, we throw an exception; otherwise, we return the **Car** object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们将确保我们得到了有效的车辆**id值**，然后调用**UpsertAsync**，传入车辆。如果我们得到除了原始ID之外的任何**id**值，我们抛出异常；否则，我们返回**Car**对象：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the **Upsert** method, we check to see whether this is a new car (insert)
    or an update:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Upsert**方法中，我们检查这是否是一辆新车辆（插入）或更新：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice, in the final two lines, that we obtain the **newId** value from the
    query and if it is **0** , we return the original car ID. Otherwise, we return
    the **newid** value from the car we inserted.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后两行中，我们从查询中获取**newId**值，如果它是**0**，则返回原始车辆ID。否则，我们返回插入的车辆的**newid**值。
- en: Soft delete
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软删除
- en: For the sake of completeness, let’s take a quick look at soft delete. You’ll
    remember that when the user asks to delete a record, rather than actually removing
    it from the database, we mark it as deleted (in the **is_deleted** column) so
    that we can obtain those records as needed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们快速了解一下软删除。你会记得，当用户请求删除一条记录时，我们并不是真正地从数据库中移除它，而是将其标记为已删除（在**is_deleted**列中），这样我们就可以根据需要获取这些记录。
- en: 'We start back in the controller:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从控制器开始：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Delete** takes the ID of the car to mark as deleted and then calls the service.
    All the service does is make sure that the ID is valid and then call the repository
    to do the actual deletion:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**操作接受要标记为已删除的汽车的ID，然后调用服务。服务所做的只是确保ID有效，然后调用存储库执行实际删除：'
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code in the repo is dead simple. It gets the connection to the database
    and creates the query to set **is_deleted** to **1** . It then executes that query:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中的代码非常简单。它获取数据库连接并创建查询以将**is_deleted**设置为**1**。然后执行该查询：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, you have a complete API for **Create, Read, Update, Delete**
    ( **CRUD** ) operations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经拥有了一个完整的API，用于**创建、读取、更新、删除**（**CRUD**）操作。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you were introduced to using Dapper and AutoMapper, the latter
    for DTO objects. You also dove into the workings of the CRUD operations, using
    the typical three classes: controller, service, and repository.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您介绍了使用Dapper和AutoMapper，后者用于DTO对象。您还深入研究了CRUD操作的工作原理，使用了典型的三个类：控制器、服务和存储库。
- en: You saw that for simple operations, you can bypass the Service, but this is
    considered bad practice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，对于简单操作，您可以绕过服务，但这被认为是不良实践。
- en: In an enterprise application, you will want to use DTOs to separate the layout
    of the database from the layout of the object being passed around. As we delve
    into the realm of enhancing API usability and understanding, the next chapter
    will highlight the significance of documenting your project with Swagger.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，您会希望使用DTOs（数据传输对象）来分离数据库布局与传递对象布局。随着我们深入探讨增强API可用性和理解领域，下一章将强调使用Swagger记录项目的重要性。
- en: You try it
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您尝试一下
- en: Create a simple database to track your music collection. Put this in a database
    and use Dapper and AutoMapper to implement the four CRUD operations. For this
    exercise, create DTOs that provide only a subset of the columns in the database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的数据库来跟踪您的音乐收藏。将此放入数据库，并使用Dapper和AutoMapper实现四个CRUD操作。为此练习，创建只提供数据库部分列的DTOs。
- en: Minimal APIs
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化API
- en: Minimal APIs offer an alternative way to create APIs without using Controllers.
    While they still allow for the injection of required services, they are primarily
    intended for smaller endpoints with minimal dependencies.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化API提供了一种创建API的替代方法，无需使用控制器。虽然它们仍然允许注入所需的服务，但它们主要用于具有最小依赖项的小型端点。
- en: In contrast, Controllers come with a larger hierarchy of endpoint components
    to consider. This includes features such as versioning, controller naming, and
    manual route attributes, which can introduce extra boilerplate that may not always
    be necessary. Minimal APIs simplify this process by allowing you to declare and
    handle requests in a single expression.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，控制器附带了一个更大的端点组件层次结构，需要考虑。这包括版本控制、控制器命名和手动路由属性，这些可能会引入不必要的额外模板代码。最小化API通过允许您在单个表达式中声明和处理请求来简化此过程。
- en: 'To illustrate, let’s reimplement the call to get all cars. Start with the code
    from [*Chapter 3*](B21998_03.xhtml#_idTextAnchor038) , then use the app variable
    to add calls to **MapGet** . The route will be **/car-minimal** , and the handler
    can remain the same as the **GetAll** method: a call to **ICarRepository.GetAll**
    . But how will we access the service interface without a constructor? Minimal
    APIs solve this by using parameter injection. Simply pass **ICarRepository carRepository**
    as an argument to the delegate for **MapGet** parameter, and use it to call the
    **.** **GetAll** method.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们重新实现获取所有汽车的调用。从[*第3章*](B21998_03.xhtml#_idTextAnchor038)的代码开始，然后使用app变量添加对**MapGet**的调用。路由将是**/car-minimal**，处理程序可以保持与**GetAll**方法相同：调用**ICarRepository.GetAll**。但如果没有构造函数，我们如何访问服务接口？最小化API通过使用参数注入来解决此问题。只需将**ICarRepository
    carRepository**作为参数传递给**MapGet**的委托参数，并使用它来调用**.** **GetAll**方法。
- en: Many different types can be injected into the handlers for Minimal APIs. Model-bound
    types are differentiated by applying attributes to individual parameters. Commonly
    used ones include **[FromRoute]** , **[FromBody]** , and **[FromServices]** .
    Additional special types include **HttpContext** , **HttpRequest** , **HttpResponse**
    , **IFormFile** , and a **Stream** of the request body. The full list is available
    in the official Microsoft documentation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同类型都可以注入到最小化API的处理程序中。通过将属性应用于单个参数来区分模型绑定类型。常用的包括**[FromRoute]**、**[FromBody]**和**[FromServices]**。其他特殊类型包括**HttpContext**、**HttpRequest**、**HttpResponse**、**IFormFile**和请求体的**Stream**。完整列表可在官方Microsoft文档中找到。
