["```cs\nlet function-name parameter-list [: return-type] = body-expression \n\n```", "```cs\nlet circleArea radius = System.Math.PI * radius * radius \n\n```", "```cs\n> circleArea 5.0;; \nval it : float = 78.53981634 \n> \n\n```", "```cs\n> circleArea;; \nval it : (float -> float) = <fun:it@7> \n\n```", "```cs\nlet opaque arg = \n  System.DateTime.Now.Second * (if arg % 2 = 0 then 2 else 1) \n\n```", "```cs\n> opaque 15;; \nval it : int = 46 \n> opaque 15;; \nval it : int = 49 \n> opaque 16;; \nval it : int = 112 \n> opaque 16;; \nval it : int = 6 \n\n```", "```cs\nlet circleArea radius = \n  System.Math.PI * radius * radius \n\n```", "```cs\ncircleArea 15.0 \n\n```", "```cs\nlet dateParts = (2016,\"Feb\",29) \n\n```", "```cs\nlet (perimeter,area) = \n  (System.Math.PI * 2\\. * r, System.Math.PI * r * r) \n\n```", "```cs\n() \n\n```", "```cs\nlet getNextRandom () = (%) System.DateTime.Now.Ticks 1000L \n\n```", "```cs\nlet getNextRandom () = \n  printfn \"%d\" ((%) System.DateTime.Now.Ticks 1000L) \n\n```", "```cs\nlet myPrintFunC header value = printfn \"%s %d\" header value \n\n```", "```cs\nlet myPrintFunT (header,value) = printfn \"%s %d\" header value \n\n```", "```cs\n(myPrintFunC \"The Answer is\") 42 \n\n```", "```cs\nfun parameter-list -> expression \n\n```", "```cs\nfun x y -> if x = y then 1 else 0 \n\n```", "```cs\nArray2D.init 5 5 (fun x y -> if x = y then 1 else 0) \n\n```", "```cs\nlet stopWatchGenerator (f:('a->'b)) (x: 'a) : (('a->'b)->'a->'b) = \n  let whoRunsMe = \n    System \n    .Diagnostics \n    .Process \n    .GetCurrentProcess() \n    .MainModule \n    .FileName \n    |> System.IO.Path.GetFileNameWithoutExtension \n    |> sprintf \"[%s]:\" in \n  fun f x -> \n    let stopWatch = System.Diagnostics.Stopwatch() in \n    try \n      stopWatch.Start() \n      f x \n    finally \n      printf \"Took %dms in %s\\n\" \n      stopWatch.ElapsedMilliseconds \n      whoRunsMe \n\nlet whatItTakes f x = (stopWatchGenerator f x) f x \n\n```", "```cs\n> whatItTakes (fun x -> seq {1L .. x} |> Seq.sum) 10000000L;; \nTook 242ms in [fsianycpu]: \nval it : int64 = 50000005000000L \n> \n\n```", "```cs\n> whatItTakes (fun cutoff -> \n  (Seq.initInfinite (fun k -> (if k%2 = 0 then - 1.0 else  1.0)/((float k) * 2.0 - 1.0)) \n  |> Seq.skip 1 \n  |> Seq.take cutoff \n  |> Seq.sum) * 4.0) 2000000;; \nTook 361ms in [fsianycpu]: \nval it : float = 3.141592154 \n> \n\n```", "```cs\nlet apply case arg = \n  if case = 0 then \n    sin arg \n  elif case = 1 then \n    cos arg \n  elif case = 2 then \n    asin arg \n  elif case = 3 then \n    acos arg \n  else \n    arg \n\n```", "```cs\nlet apply' case arg = \n  try \n    [|sin; cos; asin; acos|].[case] arg \n  with \n    | :?System.IndexOutOfRangeException -> arg \n\n```", "```cs\nlet simpleClosure = \n  let scope = \"old lexical scope\" \n  let enclose() = \n    sprintf \"%s\" scope \n  let scope = \"new lexical scope\" \n  sprintf \"[%s][%s]\" scope (enclose()) \n\n```", "```cs\nlet trackState seed = \n  let state = ref seed in \n  fun () -> incr state; (!state, seed) \n\n```", "```cs\nlet mutable x = \"I'm x\" \nlet mutable y = x \ny <- \"I'm y\" \nsprintf \"%s|%s\" x y \n\nlet rx = ref \"I'm rx\" \nlet ry = rx \nry := \"I'm ry\" \nsprintf \"%s|%s\" !rx !ry \n\n```", "```cs\nlet s = \"I'm a string\" \nlet dict = \n  System.Collections.Generic.Dictionary<string, string list>() \n\n```", "```cs\nlet gameOutcome isWin = \"you \" + if isWin then \"win\" else \"loose\" \n\n```", "```cs\nlet truncator limit s = \n  if s.Length > limit then \n    s.Substring(0, limit) \n  else \n    s \n\n```", "```cs\nlet truncator' limit s = \n  if not (System.String.IsNullOrEmpty s) && s.Length > limit then \n    s.Substring(0, limit) \n  else \n    s \n\n```", "```cs\nlet logAndTrash ss = \n  let log = System.Text.StringBuilder() \n  for s in ss do \n    sprintf \"%A\" s|> log.AppendLine |> ignore \n  (ss :> System.IDisposable).Dispose() \n  log \n\n```", "```cs\n'a -> System.Text.StringBuilder \n  when 'a :> seq<'b> and 'a :> System.IDisposable \n\n```", "```cs\nlet cutter s = \n  let cut s = \n    printfn \"imitator cut: %s\" s \n  let cut (s: string) = \n    if s.Length > 0 then \n      printfn \"real cut: %s\" s \n      cut s.[1..] \n    else \n      printfn \"finished cutting\" \n  cut s \n\n```", "```cs\n(%) 10 3 = 10 % 3 \n\n```", "```cs\n('a -> 'a -> bool) when 'a : equality \n\n```"]