- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Fortify Your Code With Structural Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用结构型模式加固您的代码
- en: 'Recently, my wife asked a question that should have been simple to answer:
    “What did you do for fun when you were a little boy, say 9 or 10 years old?” I
    had to think about it. When I was 9 or 10, computers in the home were not possible,
    unless you lived in a military bunker that had a steady high voltage continuous
    sine wave power feed. The bunker would also have needed several thousand square
    feet of raised flooring, industrial-grade air conditioning, and a steady supply
    of clean water to use for CPU cooling. This wasn’t a normal living environment
    for most of my friends when we were 9 or 10\. The question was difficult because
    as soon as I turned 12, I got my first computer. It was the Radio Shack TRS-80,
    complete with a level 1 8-bit Z-80 processor, 4 K (as in 4,000 bytes – just bytes
    - not Kilo, Mega, nor Giga) of memory, a monochrome monitor with a resolution
    of 128 by 48 very blocky pixels, and a cassette tape deck for loading and storing
    programs and data. The new computer occupied my every waking moment and since
    then, I’ve devoted probably far more of my life to screen time than I would care
    to admit. However, the question was: what did I do for fun before my computer?
    After a minute of thinking, I remembered that I built model rockets.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我的妻子问了一个应该很容易回答的问题：“你小时候（比如9岁或10岁）有什么娱乐活动？”我不得不思考。当我9岁或10岁的时候，家里不可能有电脑，除非你住在有稳定高电压连续正弦波电源的军事掩体里。掩体还需要几千平方英尺的架空地板、工业级空调和稳定的清洁水源来用于CPU冷却。这并不是我们大多数朋友9岁或10岁时正常的居住环境。这个问题很难回答，因为当我12岁的时候，我就得到了我的第一台电脑。它是Radio
    Shack TRS-80，配备了一个级别1的8位Z-80处理器，4K（即4,000字节——只是字节，不是千字节、兆字节或吉字节）的内存，一个分辨率为128×48像素的单色显示器，以及一个磁带机用于加载和存储程序和数据。这台新电脑占据了我醒着的每一刻，从那时起，我可能比愿意承认的更多地将我的生命奉献给了屏幕时间。然而，问题是：在我有电脑之前，我有什么娱乐活动？经过一分钟思考，我想起了我建造模型火箭。
- en: Just up the street from the house where I grew up was a hobby shop that sold
    model rocket kits along with engines and launchers. On Saturday mornings, I’d
    paw through mom’s purse, scrape together 5 USD, and walk to the shop to grab a
    kit. In the beginning, they were simple “level 1” kits that you could assemble
    and launch in a few hours. As I grew more adept, the models became more complicated
    with elements such as parachutes that deployed when the rocket had spent its fuel
    and reached its apogee. One rocket even had a single-shot camera that would take
    an aerial picture on its way back to Earth. The fancy kits had rockets that resembled
    spaceships from the Star Wars movie (there was only one back then) and Battlestar
    Galactica.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就在我长大的那所房子附近，有一个爱好店，出售模型火箭套件以及引擎和发射器。在周六早上，我会翻遍妈妈的包，凑够5美元，然后走到店里买一个套件。一开始，它们是简单的“级别1”套件，你可以在几小时内组装和发射。随着我越来越熟练，模型变得越来越复杂，比如降落伞，当火箭耗尽燃料并达到最高点时会展开。甚至有一枚火箭配备了一个单次使用的相机，可以在返回地球的路上拍摄空中照片。这些花哨的套件中的火箭看起来像《星球大战》电影中的宇宙飞船（当时只有一部），以及《银河战舰》。
- en: The rockets generally had a similar structure. However, as they became more
    sophisticated, more instructions were required to assemble them correctly and
    launch them safely. This reminds me of our next collection of patterns.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 火箭通常具有相似的结构。然而，随着它们变得更加复杂，组装它们并安全发射所需的指令也越来越多。这让我想起了我们接下来要介绍的模式集合。
- en: 'Structural patterns are designed to help you assemble objects into larger,
    more complex structures, thus avoiding the stovepipe monolithic structure that
    we’ve come to abhor. Structural patterns are to larger systems what creation patterns
    are to individual object instances. Structural patterns help us maintain flexibility
    and efficiency. There are quite a few documented structural patterns, but this
    chapter focuses on four of the most important patterns:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型模式旨在帮助您将对象组装成更大、更复杂的结构，从而避免我们逐渐厌恶的管道式单体结构。结构型模式对于大型系统的作用，类似于创建型模式对于单个对象实例的作用。结构型模式帮助我们保持灵活性和效率。已经有许多结构型模式被记录下来，但本章重点介绍四个最重要的模式：
- en: '**The Decorator pattern**'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰者模式**'
- en: '**The Façade pattern**'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观模式**'
- en: '**The Composite pattern**'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合模式**'
- en: '**The Bridge pattern**'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接模式**'
- en: As in earlier chapters, these structural patterns will be demonstrated within
    the context of simple command-line programs. This will limit the amount of noise
    you would encounter with more complex, though probably more interesting, desktop,
    web, or gaming projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，这些结构模式将在简单的命令行程序的环境中演示。这将限制您在更复杂（尽管可能更有趣）的桌面、Web或游戏项目中遇到的噪音量。
- en: This chapter assumes you understand the basics of the **Unified Modeling Language**
    (**UML**). All patterns are diagrammed using UML class diagrams throughout the
    book.  If UML is a new concept for you, check out [*Appendix 2*](B18605_Appendix_2.xhtml#_idTextAnchor204)
    of this book.  You don’t need to understand all of UML’s 14 diagram types. I only
    use class diagrams because that is all we need for our pattern work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您了解**统一建模语言**（**UML**）的基础知识。本书中所有模式都使用UML类图进行图示。如果您对UML是一个新概念，请参阅本书的[*附录2*](B18605_Appendix_2.xhtml#_idTextAnchor204)。您不需要理解UML的14种图示类型中的所有内容。我只使用类图，因为这是我们模式工作所需的所有内容。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Throughout the book, I assume you know how to create new C# projects in your
    favorite **integrated development environment** (**IDE**). I do not spend any
    time on the mechanics of setting up and running projects in this chapter. However,
    if you need a tutorial on IDEs or how to set up a project, check out [*Appendix
    1*](B18605_Appendix_1.xhtml#_idTextAnchor178) of this book. Should you decide
    to code along with me, you’ll need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我假设您知道如何在您喜欢的**集成开发环境**（**IDE**）中创建新的C#项目。我在本章中不花时间讲解设置和运行项目的机制。然而，如果您需要有关IDE或如何设置项目的教程，请参阅本书的[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)。如果您决定与我一起编写代码，您将需要以下内容：
- en: A computer running the Windows operating system. I’m using Windows 10\. Since
    the projects are simple command-line projects, I’m pretty sure everything here
    would also work on a Mac or Linux, but I haven’t tested the projects on those
    operating systems.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Windows操作系统的计算机。我使用的是Windows 10。由于项目是简单的命令行项目，我相当确信这些内容在Mac或Linux上也能工作，但我还没有在这些操作系统上测试过这些项目。
- en: A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code
    with C# extensions. I’m using Rider 2021.3.3.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的IDE，如Visual Studio、JetBrains Rider或带有C#扩展的Visual Studio Code。我使用的是Rider 2021.3.3。
- en: Some version of the .NET SDK. Again, the projects are simple enough that our
    code shouldn’t be reliant on any particular version. I am using the .NET Core
    6 SDK.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK的某个版本。再次强调，项目足够简单，我们的代码不应该依赖于任何特定版本。我正在使用.NET Core 6 SDK。
- en: If you’d like the code, you can find the completed project files for this chapter
    on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-4](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-4).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要代码，您可以在GitHub上找到本章的完整项目文件，网址为[https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-4](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-4)。
- en: B2B (back to bicycles)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B2B（回到自行车）
- en: 'In our last episode, sisters Kitty and Phoebe had decided to open their own
    bicycle factory: Bumble Bikes. They intend to leverage Kitty’s expertise and design
    the most innovative bicycles on the road. Phoebe is capitalizing on her own engineering
    skills by designing and building robotics. Although neither sister is a professionally
    trained software developer, their father, a retired time-traveling software engineer,
    had taught the girls to code at a young age. The sisters know their way around
    an IDE, but they are only just learning about patterns. Therefore, the coding
    task at hand is to write the robotic control software that will run an automated
    factory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一集中，姐妹Kitty和Phoebe决定开设自己的自行车工厂：Bumble Bikes。她们打算利用Kitty的专业知识，设计路上最创新的自行车。Phoebe通过设计和构建机器人来利用她自己的工程技能。尽管姐妹俩都不是受过专业训练的软件开发人员，但她们的父亲，一位退休的时间旅行软件工程师，在她们很小的时候就教她们编程。姐妹们熟悉IDE的使用，但她们刚刚开始学习模式。因此，当前的编码任务是编写将运行自动化工厂的机器人控制软件。
- en: The robotic manufacturing systems take instances of `Bicycle` classes and translate
    those into physical bicycles. The girls have mastered Creational patterns and
    they have settled on using the Builder pattern. The Builder pattern will be used
    to create any type of bicycle component needed and assemble those components into
    a finished bicycle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人制造系统将`Bicycle`类的实例转换为实物自行车。女孩们已经掌握了创建型模式，并且决定使用Builder模式。Builder模式将被用来创建所需的任何类型的自行车组件，并将这些组件组装成成品自行车。
- en: The Decorator pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: It was a hectic Monday morning for Kitty and Phoebe. Over the weekend, Kitty
    had ridden a prototype mountain bike around some of the trails near her home in
    the rocky desert of West Texas. She wanted a challenging test, so she chose Black
    Gap Road in Big Bend, a US national park. Big Bend derives its name from a large
    bend in the Rio Grande river, which forms the park’s border, as well as the United
    States’ southern border with Mexico. Black Gap Road is well known as a challenging
    trail. It has washouts, shallow creek crossings, and an actual gap (after which
    the road is named). The gap consists of a narrow passage between two large hills
    formed from volcanic rock. In the middle of the gap is a ledge that drops about
    3 feet (about 1 meter) into the next section. Kitty had driven over the ledge
    in her Jeep many times, but never on a bike. She misjudged the drop and wound
    up flat on her back. After catching her breath, she got back on her bicycle and
    completed the trail. Phoebe was waiting at the trailhead for Kitty to pick her
    up with the Jeep.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基蒂和菲比来说，周一早上是个忙碌的开始。周末，基蒂在她家附近的西德克萨斯州岩石沙漠的一些小径上骑了一辆原型山地自行车。她想要一个有挑战性的测试，所以她选择了美国国家公园大弯的Black
    Gap Road。大弯的名字来源于里奥格兰德河的一个大弯，它形成了公园的边界，以及美国与墨西哥的南部边界。Black Gap Road因其具有挑战性的小径而闻名。它有冲刷地、浅溪流和实际的缺口（道路因此得名）。缺口由火山岩形成的大山之间的狭窄通道组成。在缺口中间是一个约3英尺（约1米）高的悬崖，悬崖下方是下一部分。基蒂曾多次驾驶她的吉普车越过悬崖，但从未骑自行车。她误判了落差，结果背部着地。在喘过气来后，她重新骑上自行车完成了小径。菲比在起点等待基蒂用吉普车来接她。
- en: 'On Monday morning, their phones started ringing. Phoebe spent almost an hour
    on the phone speaking with a raw material supplier. Based on the amount of material
    the girls were projecting, the supplier informed them they would need to set up
    an account on the supplier’s extranet, which is a private network available to
    larger customers. Bumble Bikes could get favorable pricing on raw materials. However,
    to take advantage of the pricing, Bumble Bikes had to commit to creating an interface
    between their robotic manufacturing system and the supplier’s inventory control
    system. Phoebe saw this as a positive because it meant that in the short term,
    she could leverage the inventory control system of her supplier, rather than having
    to create this system herself. The only downside was that Phoebe would need to
    modify her software, in particular the `Bicycle` class, to provide notifications
    to the supplier’s API. The `Bicycle` class had been internally released and was
    already in use. Cracking open the class to add the notifiers required by the supplier
    would force her to violate the open-closed principle that states: you should never
    modify code that is in production by changing the class. Instead, she should find
    a way to extend the class.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 周一早上，他们的电话开始响起。菲比花了一小时的时间在电话里和一个原材料供应商交谈。根据女孩们预测的原材料数量，供应商告诉她们需要在该供应商的外部网络（这是一个仅对大客户开放的私有网络）上设置账户。Bumble
    Bikes可以在原材料上获得优惠价格。然而，为了利用这个价格优势，Bumble Bikes必须承诺在其机器人制造系统和供应商的库存控制系统之间创建一个接口。菲比认为这是一个积极的信号，因为它意味着在短期内，她可以利用供应商的库存控制系统，而不必自己创建这个系统。唯一的缺点是菲比需要修改她的软件，特别是`Bicycle`类，以便向供应商的API提供通知。`Bicycle`类已经内部发布并投入使用。为了添加供应商所需的通知器而打开这个类将迫使她违反开放封闭原则，该原则指出：你不应该通过更改类来修改正在生产的代码。相反，她应该找到一种方法来扩展这个类。
- en: Meanwhile, Kitty was on her phone talking to the president of a company that
    owns a large number of bicycle dealerships across the United States. The company
    wants to become the exclusive dealer for Bumble Bikes in the US. The sisters had
    envisioned selling directly to customers as well as forming agreements with small
    local bicycle shops. They were surprised a big chain of stores would be interested
    in their nascent product line. After a long discussion with the president, Kitty
    learned one of the requirements for doing business with the dealerships was that
    each bicycle ordered would need an owner’s manual and would have to be printed
    with each dealership’s details scattered throughout the manual. A large-scale
    printing system would be provided by the company that owned the dealerships, so
    the girls wouldn’t have to come up with the capital for any equipment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，凯蒂正在用手机和一个拥有美国大量自行车经销商的公司总裁通话。这家公司希望成为美国 Bumble Bikes 的独家经销商。姐妹俩原本设想直接向客户销售，并与小型当地自行车店建立协议。她们对大型连锁店对其新兴产品线感兴趣感到惊讶。在与总裁长时间讨论后，凯蒂了解到与经销商做生意的一个要求是，每辆订购的自行车都需要一份车主手册，并且必须带有散布在手册中的每个经销商的详细信息。经销商所属的公司将提供大规模印刷系统，因此女孩们不需要为任何设备筹集资金。
- en: As fate would have it, the two hung up from their respective calls at the exact
    same time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 命运就是这样，两人在各自通话的同一时间挂断了电话。
- en: '*“You won’t believe this!”* Phoebe exclaimed.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “你不会相信这个！”菲比惊呼。
- en: '*“No, you won’t believe this!”* Kitty countered.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “不，你不会相信这个！”凯蒂反驳道。
- en: The two were excited as they discussed what had transpired. On Friday, they
    were a small bicycle start-up. The next Monday morning, they were positioned to
    be a serious competitor in the US bicycle market. Their dreams were coming true
    more quickly than they could have imagined. All they had to do was make a few
    modifications to their code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们讨论所发生的事情时，两人都很兴奋。周五，他们是一家小型自行车初创公司。到了下周一早上，他们已经定位为美国自行车市场的一个严肃的竞争对手。他们的梦想比他们想象的实现得更快。他们所需要做的只是对他们的代码进行一些修改。
- en: '*“It’s simple!”* said Phoebe. *“We can just change the* *Bicycle class and
    add the new properties and methods to meet our new requirements.”*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “很简单！”菲比说，“我们只需更改 *Bicycle 类，并添加新的属性和方法以满足我们的新要求。”*
- en: '*“Not so fast,”* replied Kitty, and then she continued, *“The Bicycle classes
    are already in production. Changing* *them conflicts with the open-closed principle.
    Besides, not every bicycle object needs the new manual printing behavior. If we
    force the behavior on every subclass, we’re violating the interface segregation
    principle. We’d be violating two SOLID principles!”*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “别这么快，”凯蒂回答说，然后她继续说，“自行车类已经投入生产。改变它们与开闭原则相冲突。此外，并非每个自行车对象都需要新的手动打印行为。如果我们强迫每个子类都具有这种行为，我们就是在违反接口隔离原则。我们将会违反两个
    SOLID 原则！”
- en: '*“Oh, yeah,”* Phoebe said dejectedly. The two did some research and came across
    an idea that seemed sound. If they could create a class that wrapped or decorated
    the `Bicycle` class, they could create an extended class with new behaviors without
    breaking any of their existing implementations.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，是的，”菲比沮丧地说。两人进行了一些研究，发现了一个似乎可行的想法。如果他们能够创建一个包装或装饰 `Bicycle` 类的类，他们就可以创建一个具有新行为但不会破坏现有实现的扩展类。
- en: 'The Decorator pattern allows you to add properties and methods to a class without
    touching the original class, while still honoring any concrete implementations.
    You can see a generic drawing for the Decorator pattern in *Figure 4.1*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式允许你在不接触原始类的同时，向类添加属性和方法，同时仍然尊重任何具体实现。你可以在 *图 4.1* 中看到装饰者模式的通用绘图：
- en: '![Figure 4.1: The Decorator pattern. ](img/B18605_Figure_4.1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：装饰者模式。](img/B18605_Figure_4.1.jpg)'
- en: 'Figure 4.1: The Decorator pattern.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：装饰者模式。
- en: 'The parts of the pattern are categorized and explained here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的各个部分在此进行了分类和解释：
- en: '`IComponent` is the interface that defines the behavior we intend to wrap.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IComponent` 是定义我们要包装的行为的接口。'
- en: '`ConcreteComponent` is the original implementation. In the example presented
    thus far, this would be the API from the microcontroller vendor.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteComponent` 是原始实现。在迄今为止提供的示例中，这将是从微控制器供应商的 API。'
- en: '`Decorator` is an abstract class that holds a reference to the concrete component
    via the interface.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Decorator` 是一个抽象类，它通过接口持有对具体组件的引用。'
- en: '`ConcreteDecorator1` is a concrete class that extends the decorator class but
    adds some additional state definitions in the form of properties or fields.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteDecorator1`是一个扩展装饰器类的具体类，但它添加了一些额外的状态定义，以属性或字段的形式出现。'
- en: '`ConcreteDecorator2` extends the decorator with additional operations.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteDecorator2`通过添加额外的操作扩展了装饰器。'
- en: 'Kitty and Phoebe needed to add two different behaviors to their `Bicycle` class.
    One behavior would interface with the raw material supplier’s inventory control
    system. The other behavior would allow customized manuals to be printed at the
    factory and shipped with the bicycles to hundreds of dealerships throughout the
    US. Ideally, there should also be a way to add both behaviors to their `Bicycle`
    objects. In other words, they really wanted their decorators to stack. Stacking
    would allow them to potentially modify all their `Bicycle` classes to work with
    the raw material supplier’s system, but only deal with printing manuals for bikes
    sold through their dealership agreement. They should be able to add these behaviors
    or omit them as appropriate. Kitty headed to the whiteboard and ultimately settled
    on the structure shown in *Figure 4.2*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty和Phoebe需要向他们的`Bicycle`类添加两种不同的行为。一种行为将与原材料供应商的库存控制系统接口。另一种行为将允许在工厂打印定制的手册，并与自行车一起运送到美国各地的数百个经销商处。理想情况下，还应该有一种方法可以将这两种行为添加到他们的`Bicycle`对象中。换句话说，他们真的希望他们的装饰器可以堆叠。堆叠将允许他们潜在地修改所有`Bicycle`类以与原材料供应商的系统协同工作，但只需处理通过他们的经销商协议销售的自行车的打印手册。他们应该能够根据需要添加或省略这些行为。Kitty走到白板前，最终确定了*图4.2*中所示的结构：
- en: '![Figure 4.2: Kitty’s implementation of the Decorator pattern. ](img/B18605_Figure_4.21.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：Kitty对装饰器模式的实现](img/B18605_Figure_4.21.jpg)'
- en: 'Figure 4.2: Kitty’s implementation of the Decorator pattern.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：Kitty对装饰器模式的实现。
- en: 'Let’s go over the classes in the diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看图中的类：
- en: This is the interface we created in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*,
    Getting Creative with Creational Patterns*, to represent our bicycles. Nothing
    has changed.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们创建的[*第3章*](B18605_03.xhtml#_idTextAnchor063)“使用创建型模式进行创意”，用来表示我们的自行车界面。这里没有任何变化。
- en: This is the abstract `Bicycle` class that implements the interface. Nothing
    has changed here either. In fact, neither the interface nor the abstract class
    has changed.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是实现接口的抽象`Bicycle`类。这里也没有任何变化。实际上，接口和抽象类都没有变化。
- en: This is the abstract decorator class. Strictly speaking, you don’t necessarily
    need the word *decorator* in the class name. It’s here for the sake of clarity.
    Note that it uses composition to include a `protected` property, which contains
    a reference to a class that implements `IBicycle`. This object is set by the constructor
    while simultaneously implementing the `IBicycle` interface. At first glance, this
    doesn’t seem very DRY. As you’ll see, it will be. This will make sense when you
    see it in the code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是抽象装饰器类。严格来说，类名中不一定需要包含单词*装饰器*。这里是为了清晰起见。请注意，它使用组合来包含一个`protected`属性，该属性包含对实现`IBicycle`的类的引用。此对象由构造函数设置，同时实现`IBicycle`接口。乍一看，这似乎不太符合DRY原则。正如你将看到的，它会。当你看到代码时，这会变得有意义。
- en: 'The Decorator classes. Here we have two: `DocumentedBicycle` and `NotifyingBicycle`.
    You can have as many as you need. You can stack them in your implementation, making
    it possible to have a `Bicycle` object with either a manual printer or a notifier,
    or both or neither. As Bumble Bikes expands and new business requirements are
    realized, we can potentially add and selectively stack more decorators without
    disturbing the original bicycle class itself.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器类。这里有两个：`DocumentedBicycle`和`NotifyingBicycle`。你可以根据需要创建任意多个。你可以在实现中堆叠它们，使得可以有一个既带有手动打印机又带有通知器，或者两者都有或都没有的`Bicycle`对象。随着Bumble
    Bikes的扩展和新业务需求的实现，我们有可能添加并选择性地堆叠更多的装饰器，而不会干扰原始的自行车类本身。
- en: The `IDocumentor` and `INotifier` interfaces define the decorating behaviors.
    Keeping them as interfaces prevents the decorator from being tightly coupled to
    concrete implementation.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IDocumentor`和`INotifier`接口定义了装饰行为。将它们作为接口可以防止装饰器与具体实现紧密耦合。'
- en: Decorators are used to add new properties and methods (or if you prefer, behaviors)
    to objects without modifying the original class. This allows you to honor the
    open-closed principle by cleverly extending the class. In this case, we are extending
    the class by wrapping it, rather than merely extending using inheritance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器用于在不修改原始类的情况下向对象添加新的属性和方法（或者如果你更喜欢，行为）。这允许你通过巧妙地扩展类来遵守开闭原则。在这种情况下，我们通过包装类来扩展类，而不是仅仅通过继承来扩展。
- en: 'There are three steps involved in decorating a class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰一个类涉及三个步骤：
- en: Create a class with a `private` member containing the class you want to decorate.
    In our case, we’ll be decorating the `AbstractBicycle` class. We need a class
    that contains a `private` property of the `IBicycle` type, and a constructor that
    allows us to set this property.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含要装饰的类的 `private` 成员的类。在我们的例子中，我们将装饰 `AbstractBicycle` 类。我们需要一个包含 `IBicycle`
    类型的 `private` 属性的类，以及一个允许我们设置此属性的构造函数。
- en: We need to implement all the properties and methods that are already in the
    `IBicycle` interface. When we implement the getter, setter, and regular methods
    for the decorator, we pass them through to the private instance. In effect, we’ve
    wrapped the class and the decorator performs exactly as in the original class.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现 `IBicycle` 接口中已经存在的所有属性和方法。当我们为装饰器实现获取器、设置器和常规方法时，我们将它们传递给私有实例。实际上，我们已经包装了类，装饰器执行得与原始类完全一样。
- en: We add the decorating properties and methods. If you intend to stack your decorators,
    it is important to have a common method that can link them together. We’ll be
    using the `Build()` method.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加装饰属性和方法。如果你打算堆叠装饰器，有一个可以链接它们的公共方法是很重要的。我们将使用 `Build()` 方法。
- en: 'Let’s look at Kitty’s code implementation. We’ll work from the bottom up, beginning
    with the two interfaces. She adds the `IDocumentor` interface. This allows dealership
    customized manuals to be printed when the bicycle is built:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Kitty的代码实现。我们将从底部开始，从两个接口开始。她添加了 `IDocumentor` 接口。这允许在构建自行车时打印定制的经销商手册：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then she adds the `INotifier` interface, which defines a function to communicate
    with the raw material supplier’s inventory control system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后她添加了 `INotifier` 接口，该接口定义了一个与原材料供应商的库存控制系统通信的功能：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let’s look at the `AbstractBicycleDecorator` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `AbstractBicycleDecorator` 类：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `protected` field to hold the original `IBicyle` object is crucial here.
    This is the original, undecorated object instance we’ll be decorating:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，保存原始 `IBicyle` 对象的 `protected` 字段至关重要。这是我们将要装饰的原始、未装饰的对象实例：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to implement the `IBicycle` interface in the decorating class.
    We do this by passing everything through to the private undecorated object set
    by the constructor. Each call to the decorator class will be passed along to the
    undecorated instance:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在装饰类中实现 `IBicycle` 接口。我们通过将一切传递给构造函数设置的私有未装饰对象来完成此操作。对装饰器类的每次调用都将传递给未装饰的实例：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we’ll implement the `Build()` function as abstract. In our original
    `Bicycle` class, which was also abstract, we implemented this method within the
    class. This is important because we’re actually making changes to the way the
    bicycles are built. As you’ll see, this method provides the means to stack our
    decorators:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `Build()` 函数实现为抽象的。在我们的原始 `Bicycle` 类中，这个类也是抽象的，我们在类中实现了这个方法。这是因为我们实际上正在改变自行车的构建方式。正如你将看到的，这个方法提供了堆叠我们的装饰器的方法：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s finally move into the two decorator classes. Kitty’s requirement to print
    manuals comes first because she’s the elder sister. At least, that’s what she’s
    always arguing. Here, the `DocumentedBicycle` class is extending `AbstractBicycleDecorator`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们进入两个装饰器类。首先考虑Kitty打印手册的需求，因为她是大姐。至少，她总是这样争辩。在这里，`DocumentedBicycle` 类扩展了
    `AbstractBicycleDecorator`：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There’s a `private` field to hold an `IDocumentor` object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `private` 字段来保存 `IDocumentor` 对象：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the actual decoration. The `Build()` method that exists on any object
    passed into the constructor is called. Then, the additional decorating behavior
    – in this case calling the `PrintManual()` method on the decoration – is called:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实际的装饰。在构造函数中传递给任何对象的 `Build()` 方法被调用。然后，调用额外的装饰行为——在这种情况下是在装饰上调用 `PrintManual()`
    方法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Phoebe’s requirement to notify the supplier’s inventory control system is implemented
    in its own decorator class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Phoebe要求通知供应商的库存控制系统是在其自己的装饰器类中实现的：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The structure is identical, except, of course, for the decoration. This time,
    we pass in an object that meets the `INotifier` interface. We call the appropriate
    method when the `Build()` method of the original undecorated object is called.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结构是相同的，当然，除了装饰部分。这次，我们传入了一个符合 `INotifier` 接口的对象。当调用原始未装饰对象的 `Build()` 方法时，我们调用相应的方法。
- en: 'Now, we need some concrete classes to satisfy the `INotifier` and `IDocumentor`
    interfaces. We’ll keep these simple. The `IDocumentor` interface is realized with
    a class called `ManualPrinter`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些具体的类来满足 `INotifier` 和 `IDocumentor` 接口。我们将保持这些类简单。`IDocumentor` 接口通过一个名为
    `ManualPrinter` 的类来实现：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `PrintManual()` method is our added behavior. All this does for this example
    is print the line `The manual is printing!` Since there is a lot of text flying
    around in our console, I elected to make the decorator’s output cyan-colored to
    make it easy to spot. An implementation of the `INotifier` interface might look
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintManual()` 方法是我们添加的行为。对于这个示例来说，它所做的只是打印出 `The manual is printing!` 这一行。由于我们的控制台中有大量的文本，我选择让装饰器的输出为青色，以便更容易辨认。`INotifier`
    接口的一个实现可能如下所示：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, I added a splash of color to the output to make it easier to spot. This
    time, it is yellow. It has been a while since I’ve punned, so let’s wrap this
    up with some code that makes use of our decorator classes!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我在输出中添加了一些颜色，以便更容易辨认。这次，它是黄色。我已经很久没有开玩笑，让我们用一些使用我们的装饰器类的代码来结束这个话题！
- en: 'These are the contents of the `Program.cs` file in the sample project files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是示例项目文件中 `Program.cs` 文件的内容：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a normal, undecorated `RoadBike` object. BORING! We’ve seen that one
    before!  Let’s decorate it with the ability to print a custom manual:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通的、未装饰的 `RoadBike` 对象。无聊！我们之前见过这个！让我们用打印自定义手册的能力来装饰它：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This time, we instantiated `DocumentedBicycle`, which is our decorator. It needs
    an undecorated `RoadBike` and a `ManualPrinter`. When we call the build method,
    the `DocumentedBicycle` class calls the `Build()` method on the `RoadBike` class.
    Then, it calls its own `Build()` method that adds the new manual-printing behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们实例化了 `DocumentedBicycle`，这是我们的装饰器。它需要一个未装饰的 `RoadBike` 和一个 `ManualPrinter`。当我们调用构建方法时，`DocumentedBicycle`
    类调用 `RoadBike` 类的 `Build()` 方法。然后，它调用自己的 `Build()` 方法，添加新的打印手册行为。
- en: 'If you didn’t pick up on it, I’m adding some separators, so when we run the
    example, it will be easy to see each part of the run:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有注意到，我在这里添加了一些分隔符，这样当我们运行示例时，就可以轻松地看到每个运行部分：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That was a blast! Let’s do another one! This time, let’s try out the `NotifyingBicycle`
    decorator. It works the same way. First, we make an instance of `MaterialsInventoryNotifier`,
    which embodies the new behavior the decorator is adding to `RoadBike`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是一次愉快的经历！让我们再来一次！这次，让我们尝试 `NotifyingBicycle` 装饰器。它的工作方式相同。首先，我们创建一个 `MaterialsInventoryNotifier`
    的实例，它体现了装饰器要添加到 `RoadBike` 中的新行为：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we instantiate the `NotifyingBicycle` class, passing in a new `RoadBike`
    for decoration, along with `manufacturingInventoryNotifier`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化 `NotifyingBicycle` 类，传入一个新的 `RoadBike` 对象用于装饰，以及 `manufacturingInventoryNotifier`：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we call the decorator’s `Build()` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们调用装饰器的 `Build()` 方法：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Remember how this works: the decorator (`NotifyingBicycle`) has a `Build()`
    method. So does the `RoadBike` class it decorates. The decorator calls the `Build()`
    method on `RoadBike`, which produces a `RoadBike` object. Then, the decorator
    calls its own `Build()` method, which adds the notification behavior.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个工作原理：装饰器（`NotifyingBicycle`）有一个 `Build()` 方法。被装饰的 `RoadBike` 类也有一个 `Build()`
    方法。装饰器调用 `RoadBike` 的 `Build()` 方法，生成一个 `RoadBike` 对象。然后，装饰器调用自己的 `Build()` 方法，添加通知行为。
- en: 'The cool thing about decorators is that they stack. For the pièce de résistance,
    we’ll put both decorators on the `RoadBike` object at the same time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的酷之处在于它们可以堆叠。对于压轴之作，我们将同时将两个装饰器放在 `RoadBike` 对象上：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Yikes! That’s hard to read. Let’s break it apart. In the middle, you’ll find
    a new undecorated `RoadBike` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这太难读了。让我们把它拆分开来。在中间，你会找到一个新的未装饰的 `RoadBike` 类：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, move out from there and you’ll find where we make `DocumentedBicycle`
    using this new `RoadBike`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从这里向外移动，你会找到我们使用这个新的 `RoadBike` 创建 `DocumentedBicycle` 的地方：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We passed in `bikeManualPrinter`. In real life, be careful of re-using your
    instances in this way. We used `bikeManualPrinter` before and now we’re passing
    it into a second bike. These are passed by reference, meaning if you change any
    property on `bikeManualPrinter`, it will affect both the value of `documentedBike`
    from the earlier example and this `notifyingDocumentedBike` we’re building now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了 `bikeManualPrinter`。在现实生活中，小心以这种方式重复使用你的实例。我们之前使用了 `bikeManualPrinter`，现在我们将其传递给第二辆自行车。这些是通过引用传递的，这意味着如果你在
    `bikeManualPrinter` 上更改任何属性，它将影响早期示例中的 `documentedBike` 的值以及我们现在构建的 `notifyingDocumentedBike`。
- en: 'Now, let’s move all the way to the outer constructor:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一直移动到最外层的构造器：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The outermost constructor creates an instance of `NotifyingBicycle` using the
    new `DocumentedBicycle`, which uses a new `RoadBike`. At each level, we pass in
    a decorating behavior.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的构造器使用新的 `DocumentedBicycle` 创建了一个 `NotifyingBicycle` 的实例，而 `DocumentedBicycle`
    又使用了新的 `RoadBike`。在每一层，我们都传递了一个装饰行为。
- en: To put this another way, `notifyingDocumentedBike` is created using a new `DocumentedBicycle`,
    plus `ManualPrinter`. `DocumentedBicycle` is created using a new `RoadBike`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用另一种方式来说，`notifyingDocumentedBike` 是使用新的 `DocumentedBicycle` 和 `ManualPrinter`
    创建的。`DocumentedBicycle` 是使用新的 `RoadBike` 创建的。
- en: 'You can see the output from the run program. *Figure 4.3* shows a run of the
    `DocumentedBicycle` decorator, followed by the `NotifyingBicycle` decorator. The
    final run shows both decorators on the same object running successfully. The code
    indicates color coding for the output, but this book is not printed in color.
    Or maybe it is and you need an eye exam:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到程序运行的输出。*图 4.3* 显示了 `DocumentedBicycle` 装饰器的运行，接着是 `NotifyingBicycle` 装饰器。最后的运行显示了在同一对象上成功运行的两个装饰器。代码指示了输出结果的彩色编码，但这本书并没有彩色印刷。或者也许它是有彩色的，你需要做一次眼科检查：
- en: '![Figure 4.3: The output from the run of Program.cs for the DecoratorExample
    project (to save space, the output from the undecorated RoadBike is not shown).
    ](img/B18605_Figure_4.31.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：DecoratorExample 项目的 Program.cs 运行的输出结果（为了节省空间，未装饰的 RoadBike 的输出未显示）](img/B18605_Figure_4.31.jpg)'
- en: 'Figure 4.3: The output from the run of Program.cs for the DecoratorExample
    project (to save space, the output from the undecorated RoadBike is not shown).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：DecoratorExample 项目的 Program.cs 运行的输出结果（为了节省空间，未装饰的 RoadBike 的输出未显示）。
- en: You can see why the Decorator pattern is a crowd favorite among developers.
    You can use it when you need to add behaviors to an object without breaking existing
    implementations. Decorators can be used to create layers of business logic that
    can be stacked or combined as needed. For example, only bikes sold through the
    dealership network will need the `DocumentedBicycle` decorator, but all of them
    that use raw materials from our supplier will need the `NotifyingBicycle` decorator.
    If we make a bicycle with raw materials from another source that won’t be sold
    through the dealer network, then we do not need any of the decorators.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以理解为什么装饰模式是开发者中的热门选择。当你需要在不破坏现有实现的情况下向对象添加行为时，你可以使用它。装饰器可以用来创建可以按需堆叠或组合的业务逻辑层。例如，只有通过经销商网络销售的自行车需要
    `DocumentedBicycle` 装饰器，但所有使用我们供应商的原始材料的自行车都需要 `NotifyingBicycle` 装饰器。如果我们使用来自另一个来源的原始材料制作自行车，而这些自行车不会通过经销商网络销售，那么我们就不需要任何装饰器。
- en: You can also use a decorator to extend classes that are awkward or impossible
    to extend through regular inheritance. Consider a class that is sealed, meaning
    it can’t be extended through inheritance. You can still extend it using a decorator!
    This can result in you feeling as though you’re an outlaw. This is normal and
    may lead you to obtaining a black cowboy hat and learning the lyrics to every
    song written by Johnny Cash. You’ve been warned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用装饰器来扩展那些难以或无法通过常规继承扩展的类。考虑一个密封的类，这意味着它不能通过继承来扩展。你仍然可以使用装饰器来扩展它！这可能会让你感觉自己像是一个亡命之徒。这是正常的，可能会让你得到一顶黑色牛仔帽，并学会演唱约翰尼·卡什创作的每一首歌。你已经得到了警告。
- en: The Façade pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: '*“Ugh!”* Phoebe exclaims. It’s 4 a.m. at Phoebe’s workshop. Her formerly white
    lab coat is covered in grease and she’s wading through aluminum shavings shed
    by an industrial lathe. She’s trying to build one of her robotic arms. She has
    several different designs, but this one is a heavy model that’s bolted to the
    floor. There are three variations of the arm. One arm is equipped with a welder
    used to weld the aluminum alloy bicycle frames together, another one has a buffer
    used to perfect the finish on the bicycles after they are painted, and the last
    one is equipped with a gripper used to hold the bicycle during assembly. Phoebe
    wanted to build several arms of each type. She was constrained by her budget and
    could only afford to build 10 arms. She decided the best combination for the arms
    would be three welders, three buffers, and four grippers. After whiteboarding
    the process, she realized her factory would not be able to keep up with the demand
    generated by the sisters’ stellar marketing campaigns. The Kickstarter alone had
    already generated hundreds of orders and the factory wasn’t even operational yet!
    Phoebe was having trouble coming up with a way to make this factory work.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*“呃！”* 菲比惊呼。现在时间是凌晨4点，在菲比的工坊里。她原本白色的实验服已被油污覆盖，她正踩着由工业车床散落的铝屑。她正在尝试制作她的一只机器人手臂。她有几个不同的设计，但这个是一个重型的模型，固定在了地板上。手臂有三种不同的型号。一只手臂装备了焊接机，用于焊接铝合金自行车框架，另一只装备了抛光机，用于在自行车喷漆后进行抛光处理，最后一只装备了夹具，用于在组装过程中固定自行车。菲比想要制作每种型号的手臂。由于预算限制，她只能负担起制作10只手臂。她决定手臂的最佳组合是三个焊接机、三个抛光机和四个夹具。在白板规划了这个流程后，她意识到她的工厂将无法满足姐妹们出色的营销活动带来的需求。仅Kickstarter项目就已经产生了数百个订单，而工厂甚至还没有开始运营！菲比正苦于想出让这个工厂运转的方法。'
- en: Her sister Kitty had been working on the control software. The two had agreed
    on how the software would work in advance of creating the robotics because sometimes
    making the software before the hardware is practical. The software design is fluid
    and easy to change. It can drive the hardware design, which is less fluid and
    more expensive to change. This is one of those cases. On a whim, Phoebe pulls
    Kitty’s GitHub repo and switches to the branch where Kitty had designed the object
    structure for the control arms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 她的妹妹基蒂一直在做控制软件。在创建机器人之前，两人就软件的工作方式达成了共识，因为有时在硬件之前制作软件是实用的。软件设计灵活且易于更改。它可以驱动硬件设计，而硬件设计则不那么灵活，更改成本也更高。这是一个这样的例子。一时兴起，菲比打开了基蒂的GitHub仓库，切换到了基蒂为控制手臂设计对象结构的分支。
- en: Phoebe finds Kitty’s implementation of the Decorator pattern and it gives her
    an idea. She can think of the attachments for the robot arm as decorators! This
    way she can make 10 arms, but the arms can perform whatever action is needed by
    switching the decorator. To be clear, Phoebe isn’t creating software. She’s taking
    inspiration from the Decorator pattern and making a robotic arm with interchangeable
    attachments, thus allowing the basic arm to perform many functions as needed without
    building a new arm for each task.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比发现了基蒂对装饰者模式的实现，这给了她一个灵感。她可以把机器人手臂的附件看作装饰者！这样她就可以制作10只手臂，但通过切换装饰者，手臂可以执行所需的任何动作。为了明确，菲比并不是在创建软件。她是从装饰者模式中汲取灵感，制作了一个带有可互换附件的机器人手臂，这样基本手臂就可以根据需要执行许多功能，而无需为每个任务构建新的手臂。
- en: '![Figure 4.4: Phoebe finds inspiration in the Decorator pattern. ](img/B18605_Figure_4.41.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：菲比从装饰者模式中获得了灵感。](img/B18605_Figure_4.41.jpg)'
- en: 'Figure 4.4: Phoebe finds inspiration in the Decorator pattern.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：菲比从装饰者模式中获得了灵感。
- en: This is fantastic! However, there’s another problem. Each attachment will be
    built from components from different suppliers and each will have a different
    API to control the arm’s attachment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！然而，还有一个问题。每个附件将由不同供应商的组件制成，并且每个都将有不同的API来控制手臂的附件。
- en: A few weeks ago, Kitty left the s mall town of Alpine, Texas, where she was
    finishing up her Industrial Design degree at Sul Ross University. She drove her
    bright yellow Jeep Wrangler eight hours northeast to Dallas, Texas where her sister
    Phoebe was finishing her studies in engineering at Southern Methodist University.
    The purpose of Kitty’s visit, aside from the superior collegiate nightlife in
    Dallas, was to research and source potential parts for their factory robotics.
    They already had access to some of the more basic needs for manufacturing bicycles.
    At one point during their father’s career, he had spent a few years working for
    a helicopter factory in Fort Worth, Texas. Fort Worth is adjacent to Dallas and
    the residents refer to the area as the Dallas Fort-Worth metroplex. During their
    father’s time at the helicopter factory, he made many contacts that could help
    the girls achieve their goals. Everything they needed from machine shops to advanced
    computer-controlled laser cutting and fabrication was but a phone call away. The
    electronics, however, were a different story. The girls had decided to develop
    the robotics using readily available **commercial off-the-shelf** (**COTS**) components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 几周前，Kitty 离开了德克萨斯州阿尔卑斯小镇，她在 Sul Ross 大学完成工业设计学位。她驾驶着她明亮的黄色吉普 Wrangler 向东北方向开了八个小时，到达德克萨斯州的达拉斯，她的妹妹
    Phoebe 正在南方卫理公会大学完成她的工程学学业。Kitty 来访的目的，除了达拉斯优越的大学夜生活外，是为了研究和寻找他们工厂机器人的潜在部件。他们已经能够获得一些基本的自行车制造需求。在他们父亲职业生涯的某个时刻，他在德克萨斯州沃斯堡的一家直升机工厂工作了几年。沃斯堡与达拉斯相邻，居民们将这个地区称为达拉斯-沃斯堡都会区。在他们父亲在直升机工厂的时期，他结识了许多可以帮助女孩们实现目标的联系人。他们需要的从机床到先进的计算机控制激光切割和制造的一切，只需一个电话即可获得。然而，电子设备却是一个不同的情况。女孩们决定使用现成的
    **商业现货** (**COTS**) 组件来开发机器人技术。
- en: Servomotors are electrical motors that allow for precise control of angular
    or linear positioning, along with velocity and acceleration. They are widely deployed
    in the development of robotic and human-controlled industrial machinery. The objective
    for Bumble Bikes is to have an automated factory. Kitty began looking into microcontrollers.
    Microcontrollers are tiny computers that allow **application programmer interface**-(**API**-)
    level interactions to control anything, including servomotors. The servomotors
    might be connected to the computer using pin connectors, sometimes called “hats”,
    that seat onto the microcontroller’s printed circuit board. The local computer
    store in Dallas had a robust section of their supermarket-sized facility dedicated
    to the purveyance of microcontrollers, servomotors, and all the related electronics
    needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机是允许精确控制角或线性定位、速度和加速度的电动机。它们在开发机器人和人控制的工业机械中得到广泛应用。Bumble Bikes 的目标是拥有一个自动化的工厂。Kitty
    开始研究微控制器。微控制器是小型计算机，允许 **应用程序编程接口**-(**API**-) 级别的交互来控制任何东西，包括伺服电机。伺服电机可能通过引脚连接器连接到计算机，有时被称为“帽子”，它们安装在微控制器的印制电路板上。达拉斯当地的电脑店在他们的超市大小的设施中有一个专门的区域，专门用于销售微控制器、伺服电机以及所有相关的电子设备。
- en: 'One week and one large workbook of Libre Office Calc spreadsheets later, they
    had a working bill of materials for building the robot arms and their three different
    attachments. Assembling the parts into an electrically viable robotic arm is elementary.
    The hardest part is writing the software. The girls sourced three different microcontrollers
    with three different APIs for each arm attachment: one for the grabber, one for
    the welder, and another for the buffer.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一周后，他们已经制作了一份包含 Libre Office Calc 电子表格的机器人手臂及其三个不同附件的物料清单。将这些部件组装成一个电气的机器人手臂是基础性的。最难的部分是编写软件。女孩们为每个手臂附件找到了三个不同的微控制器和三个不同的
    API：一个用于抓取器，一个用于焊接机，另一个用于缓冲器。
- en: A simple solution would be to write a stovepipe application that calls the APIs
    directly based on any required logic dictated by the needs of the manufacturing
    process. The sisters’ recent experience with factory patterns has trained them
    to be wary of such strategies. Quick and easy solutions are neither sustainable
    nor maintainable in the long term, and they are thinking long-term. They want
    to build their robots once and those robots, being well maintained, conceivably
    could run forever.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是编写一个烟囱式应用程序，根据制造过程需要的任何逻辑直接调用API。姐妹们最近在工厂模式上的经验使她们对这种策略持谨慎态度。快速简单的解决方案在长期内既不可持续也不可维护，而且他们正在考虑长期。他们希望一次就构建好机器人，而这些机器人如果得到良好的维护，理论上可以永远运行。
- en: 'One of Kitty’s professors, Professor Charles Dexter Ward, had taught a class
    titled *Introduction to Smart Product Design*. It was an entire semester on the
    exact problem the girls are solving: how to design efficient automated systems
    using sensors and microcontrollers. Dr. Ward had cautioned Kitty and her academic
    colleagues about vendor lock-in. Kitty and Phoebe are starting a business by turning
    a passion project into an enterprise they can pass to their children and grandchildren.
    It doesn’t make sense to trust that the microcontrollers they buy now, and their
    related APIs, will remain unchanged for the long term or even a few years into
    the future. By tightly coupling to the current APIs directly, the sisters would
    be trusting that the API developers they use today will remain in business as
    long as Bumble Bikes. This would also assume that the APIs will continue to evolve
    and be maintained in accordance with their application’s needs. Naturally, this
    would be a very naïve assumption.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty的一位教授，查尔斯·德克斯特·沃德教授，曾教授一门名为《智能产品设计导论》的课程。这是一整个学期都在解决女孩们面临的问题：如何使用传感器和微控制器设计高效的自动化系统。沃德博士曾警告Kitty和她的学术同事们关于供应商锁定。Kitty和Phoebe正在通过将一个激情项目转变为可以传给他们的孩子和孙子的企业来开始创业。现在购买的微控制器及其相关的API在长期或未来几年内保持不变是没有意义的。通过直接紧密耦合到当前的API上，姐妹们将信任他们今天使用的API开发者将像Bumble
    Bikes一样继续经营。这也假设API将继续根据其应用需求进行演变和维护。自然，这将会是一个非常天真的假设。
- en: A safer bet is that new microcontroller APIs will be introduced into the market
    and from different companies every few years. The method signatures and the way
    the API itself is invoked will be different than they are today. Consider common
    technology for remote API calls 20 years ago. **Common Object Request Broker**
    Architecture (**CORBA**) was replaced by **Simple Object Access Protocol** (**SOAP**).
    SOAP, in turn, has been entirely displaced by **Representational State Transfer**
    (**REST**), common in web development and the **Internet-of-Things** (**IoT**)
    industry, which is still nascent in the year 2022\. I’ll wager many well-trained
    software developers reading this book have little to no exposure to CORBA or SOAP,
    just as your descendent colleagues will likely have something very different from
    REST. Any system that is tightly coupled to any API has a life span equal to the
    shortest life span of its tightly coupled components. Kitty has taken this particular
    lesson to heart. Within the software, Kitty had represented the control arm with
    an interface that implemented the robot arms performing abstract operations. These
    can be mapped to the API. She’s using **the Façade pattern**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全的赌注是，每过几年市场上就会引入新的微控制器API，并且来自不同的公司。方法签名以及API本身的调用方式将不同于今天。回想一下20年前远程API调用的常见技术。**通用对象请求代理**架构（**CORBA**）被**简单对象访问协议**（**SOAP**）所取代。SOAP反过来又完全被**表示状态转移**（**REST**）所取代，这在网络开发和**物联网**（**IoT**）行业中很常见，但在2022年仍然处于起步阶段。我敢打赌，许多受过良好训练的软件开发者阅读这本书时，对CORBA或SOAP的了解很少，甚至没有，就像你的后代同事可能对REST有非常不同的看法。任何紧密耦合到任何API的系统，其寿命等于其紧密耦合组件中最短寿命。Kitty已经深刻地吸取了这个教训。在软件中，Kitty使用一个实现了执行抽象操作的机器人手臂的接口来表示控制臂。这些可以映射到API上。她正在使用**外观模式**。
- en: '*Façade,* in regular English, or in this case, French, means “face”. In architecture
    (the kind with buildings, not software), it refers to the front of a building.
    A façade is usually ornate and represents what designers call *curb appeal*. One
    of the most famous façades I can think of is the castle at Walt Disney World in
    Florida, seen in *Figure 4.5.*  A sidenote: Dear Internal Revenue Service, please
    accept my amended return with my deduction labeled “book research trip to Disney.”
    It was purely business, I assure you.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通英语中，或者在这个案例中，法语中，“门面”意味着“面孔”。在建筑学（指有建筑物的，而不是软件）中，它指的是建筑物的正面。门面通常是华丽的，代表着设计师所说的*吸引力*。我能想到的最著名的门面之一是佛罗里达州奥兰多迪士尼世界的城堡，如图4.5所示。顺便说一句：亲爱的美国国税局，请接受我修改后的申报表，我的扣除项标记为“迪士尼研究之旅”。我向你保证，这纯粹是业务。
- en: '![Figure 4.5: The front façade of the castle at Walt Disney World in Florida
    presents an ornate appearance to the outside world. ](img/B18605_Figure_4.51.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：佛罗里达州奥兰多迪士尼世界城堡的前门面向外界呈现了一种华丽的外观。](img/B18605_Figure_4.51.jpg)'
- en: 'Figure 4.5: The front façade of the castle at Walt Disney World in Florida
    presents an ornate appearance to the outside world.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：佛罗里达州奥兰多迪士尼世界城堡的前门面向外界呈现了一种华丽的外观。
- en: In software architecture, the Façade pattern works in reverse. Instead of a
    fancy ornate face to an object or API, it’s a simplified point of access. This
    nifty pattern can insulate your programs from vendor lock-in by situating itself
    between your code and the APIs you’re calling. As an added bonus, the façade also
    allows you to simplify the interface to the API, or even multiple APIs by only
    exposing the parts that matter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件架构中，门面模式是相反的。它不是面向对象或API的华丽外观，而是一个简化的访问点。这个巧妙的模式可以通过将自己置于代码和所调用的API之间来隔离你的程序，从而避免供应商锁定。作为额外的奖励，门面还允许你简化API的接口，甚至通过仅公开重要的部分来简化多个API的接口。
- en: In the case of Bumble Bikes, Phoebe and Kitty only need basic functions that
    allow the robotic arm attachments to move and then call the specific API routines
    that allow for welding, buffing, and grabbing. The respective APIs could have
    thousands of exposed objects, methods, and properties between them, but we only
    need a few. Likewise, there might be a dozen of these APIs, but from our code’s
    perspective, there is one library we’re calling. The API could even be called
    in a non-obvious way such as CORBA (hopefully not), REST, or directly as an imported
    assembly dependency. The façade would take care of all this seamlessly. When the
    APIs change in future releases or are replaced with different APIs from different
    vendors, you only need to replace the façade. The underlying code remains untouched.
    If you’ve used an **Object Relational Mapper** (**ORM**) with a database, that
    qualifies as a façade because it gives you simplified access to the database.
    This often allows you to switch out the database, say from Oracle to SQL Server,
    without changing your code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bumble Bikes的情况下，Phoebe和Kitty只需要允许机器人手臂附件移动以及调用允许焊接、抛光和抓取的特定API例程的基本功能。这些API之间可能有数千个公开的对象、方法和属性，但我们只需要其中的一小部分。同样，可能有十几个这样的API，但从我们的代码角度来看，我们只调用一个库。API甚至可以通过非明显的方式调用，例如CORBA（希望不是），REST或直接作为导入的组件依赖。门面将无缝地处理所有这些。当API在未来版本中更改或被不同供应商的不同API替换时，你只需要替换门面。底层代码保持不变。如果你使用了一个与数据库的**对象关系映射器**（**ORM**），那么它就相当于一个门面，因为它为你提供了简化对数据库的访问。这通常允许你更换数据库，比如从Oracle更改为SQL
    Server，而无需更改你的代码。
- en: 'This is how Kitty solved the API problem in the software. She created an interface
    that defined the behaviors of the robot arms. Then, she created a decorator, which
    is code that implements the interface. She then wraps the API calls, successfully
    mapping the abstractly defined behaviors to the specific calls to the API. Kitty,
    by designing the software in this way, has broken the dependency on the APIs,
    and by extension, prevented vendor lock-in. Any API can be decorated or wrapped
    following Kitty’s behavioral interface. When the next generation of microcontroller
    APIs becomes available, Kitty just needs to write a wrapper for the new API that
    conforms it to her software’s requirements encapsulated in the interface. The
    robotic control software remains closed for modification. This would not be the
    case if she tightly coupled it to the microcontroller’s API. Had she done that,
    every revision to the API would require a partial rewrite, along with serious
    testing and validation efforts for Kitty’s entire software suite. How often have
    you encountered, or even performed, a fix to one part of your software and the
    fix breaks something somewhere else? Have you ever said, “That’s impossible! There’s
    no way changing something in library A could affect the operation of library B!”?
    This is indicative of a program built on tightly coupled operations. Changing
    anything can and will have a cascading effect. The more complex the system, the
    more likely some stage of the cascade will have a deleterious effect on the overall
    system. This has been avoided by using the Façade pattern. While closed for modification,
    Kitty’s program is open for extension because she can easily add new wrappers
    that follow the interfaces used by her software. She need only develop and test
    the new software, not the entire control program. The program at large is insulated
    from rippling failures through de-coupling. Kitty’s engineering notebook documents
    her implementation of this pattern using *Figure 4.6*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kitty 在软件中解决 API 问题的方法。她创建了一个接口，定义了机器人臂的行为。然后，她创建了一个装饰器，这是实现接口的代码。接着，她包装了
    API 调用，成功地将抽象定义的行为映射到具体的 API 调用。通过以这种方式设计软件，Kitty 打破了对外部 API 的依赖，并由此防止了供应商锁定。任何
    API 都可以按照 Kitty 的行为接口进行装饰或包装。当下一代微控制器 API 可用时，Kitty 只需要为新 API 编写一个包装器，使其符合她软件中封装的接口要求。机器人控制软件保持封闭状态，不进行修改。如果她将软件紧密耦合到微控制器的
    API 上，情况就不会是这样。如果她那样做，API 的任何修订都需要部分重写，以及 Kitty 整个软件套件的严重测试和验证工作。你遇到过多少次，甚至执行过修复软件某一部分而影响到其他地方的情况？你是否曾说过，“那是不可能的！改变库
    A 中的任何东西都不可能影响库 B 的操作！”？这表明程序是基于紧密耦合的操作构建的。改变任何东西都可能产生级联效应。系统越复杂，级联的某个阶段对整体系统产生有害影响的可能性就越大。这是通过使用
    Façade 模式来避免的。虽然 Kitty 的程序对修改是封闭的，但她可以轻松地添加遵循她软件接口的新包装器。她只需要开发和测试新的软件，而不需要整个控制程序。整个程序通过解耦免受连锁失败的波及。Kitty
    的工程笔记本使用 *图 4.6* 记录了她对这个模式的实现：
- en: '![Figure 4.6: Kitty’s engineering notebook diagram of her implementation of
    the Facade pattern. ](img/B18605_Figure_4.61.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：Kitty 的工程笔记本中关于她 Facade 模式实现的示意图](img/B18605_Figure_4.61.jpg)'
- en: 'Figure 4.6: Kitty’s engineering notebook diagram of her implementation of the
    Facade pattern.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：Kitty 的工程笔记本中关于她 Facade 模式实现的示意图。
- en: 'The parts of the pattern implementation can be explained by the numbers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模式实现的各个部分可以通过以下数字进行解释：
- en: The `RobotArmFacade` class is consumed by the client in place of direct references
    to the three third-party APIs represented by numbers `SomeOtherSubSystemOperation300()`,
    `SomeOtherSubsystemOperation400()`, and `SomeOtherSubSystemOperation99()` are
    my clever way of hinting these third-party APIs are massive without drawing a
    diagram that fills the page with imaginary API methods. Our application only needs
    a few of these methods, so only those we need are exposed in the façade.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用 `RobotArmFacade` 类代替对三个第三方 API 的直接引用，这些 API 分别由数字 `SomeOtherSubSystemOperation300()`、`SomeOtherSubsystemOperation400()`
    和 `SomeOtherSubSystemOperation99()` 表示。这是我的巧妙提示，表明这些第三方 API 是庞大的，而不需要绘制一个填满整个页面的想象中的
    API 方法图。我们的应用程序只需要这些方法中的一小部分，因此在门面中只暴露了我们需要的那些。
- en: '`WelderAttachmentAPI` represents a third-party library, perhaps a NuGet package,
    that controls the welding arm attachment on Phoebe’s robot arm.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WelderAttachmentAPI` 代表一个第三方库，可能是一个 NuGet 包，用于控制 Phoebe 机器人臂上的焊接臂附件。'
- en: '`BuffingAPI` represents a third-party library, perhaps a NuGet package, that
    controls the buffing attachment.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BuffingAPI` 代表一个第三方库，可能是一个 NuGet 包，用于控制抛光附件。'
- en: '`GrabbingAPI` represents a third-party library, perhaps a NuGet package, that
    controls the grabbing attachment.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GrabbingAPI` 代表一个第三方库，可能是一个 NuGet 包，用于控制抓取附件。'
- en: Note that many of the methods within the three third-party classes are similar.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，三个第三方类中的许多方法都是相似的。
- en: '`WelderAttachmentAPI` exposes `MoveTo(int, int, int)`, allowing the control
    software to position the welding attachment in three-dimensional space. `BuffingAPI`
    uses `Quaternion`, which is a three-dimensional coordinate combined with an angular
    rotation. If you ever work with the Unity3D game engine, which uses C# as its
    flagship coding language, you’ll get to know and love quaternions despite their
    very complicated mathematical nature. Thankfully, with the Façade pattern, you
    don’t need to fully understand the inner workings, such as Euler angles and the
    concept of gimbal lock, to use them. `GrabbingAPI` provides `SetLocation(int,
    int)` with two coordinates since that attachment only needs to move in two dimensions.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`WelderAttachmentAPI` 提供了 `MoveTo(int, int, int)` 方法，允许控制软件在三维空间中定位焊接附件。`BuffingAPI`
    使用 `Quaternion`，这是一个结合了角旋转的三维坐标。如果你曾经使用过使用 C# 作为其旗舰编程语言的 Unity3D 游戏引擎，你会了解并喜爱四元数，尽管它们的数学性质非常复杂。幸运的是，有了外观模式，你不需要完全理解内部工作原理，例如欧拉角和陀螺仪锁定概念，就可以使用它们。`GrabbingAPI`
    提供了 `SetLocation(int, int)` 方法，使用两个坐标，因为该附件只需要在两个维度上移动。'
- en: All three APIs have a common feature that moves the robot arm into position,
    but they are not identical in the way they are implemented or called. Each has
    a different method signature. This is a perfect use case for a façade because
    you can expose a single method to control movement and selectively call the correct
    API method based on which arm attachment is in use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个 API 都有一个共同的功能，即移动机械臂到位置，但它们在实现或调用方式上并不相同。每个都有不同的方法签名。这是一个完美的外观模式用例，因为你可以公开一个单一的方法来控制移动，并根据使用的机械臂附件选择性地调用正确的
    API 方法。
- en: 'Similarly, each API has some method for activating is main function: `Weld()`,
    `Buff()`, and `Grab()` respectively. Again, the façade can hide the complexity
    of calling multiple methods. While it may seem they achieve different goals, we
    can hide that complexity behind a single method that calls the correct API method
    based again on the type of attachment in use.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，每个 API 都有一些激活其主要功能的方法：分别是 `Weld()`、`Buff()` 和 `Grab()`。再次强调，外观模式可以隐藏调用多个方法的复杂性。虽然它们似乎实现不同的目标，但我们可以在一个方法后面隐藏这种复杂性，这个方法根据所使用的附件类型调用正确的
    API 方法。
- en: 'Let’s look at the code in the `RobotArmFaçade` class. First, we have an `enum`
    that defines the attachments:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `RobotArmFaçade` 类中的代码。首先，我们有一个 `enum` 定义了附件：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next comes the class itself and its constituent member variables:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是类本身及其组成部分变量：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You might note a similarity here with the Decorator pattern. We have private
    instances of the three APIs in the façade itself. It will be the job of the façade
    class to pass instructions through to the correct API in the correct format. The
    private members are initialized with a constructor:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这里注意到与装饰器模式的相似之处。我们在外观本身中有三个 API 的私有实例。外观类的任务将是将指令传递到正确的 API，并使用正确的格式。私有成员通过构造函数初始化：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ActiveAttachment` member is arbitrarily set to default to the welder.
    Next, our façade will expose the methods for activating the currently active attachment.
    If it’s a welder, it will weld. A grabber will grab and a buffer will buff, but
    it doesn’t make sense to expose the methods by name. The façade makes things simpler.
    Kitty elects to call the façade method `Actuate()` and this method determines
    what is actually called behind the curtain:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActiveAttachment` 成员被任意设置为默认的焊接器。接下来，我们的外观将公开激活当前活动附件的方法。如果是焊接器，它将焊接；如果是抓取器，它将抓取；如果是抛光器，它将抛光，但按名称公开这些方法没有意义。外观使事情变得更简单。Kitty
    选择调用外观方法 `Actuate()`，这个方法确定幕后实际调用的是什么：'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, we need to expose a simple way to move the arms and position the attachments.
    This one requires a little more thought since each API method has a different
    method signature. Kitty decides the obvious solution is to pick the most complicated
    requirement, `Quaternion`. Quaternions are part of the .NET `System.Numerics`
    library. This struct holds four values, W, X, Y, and Z of the `Single` type per
    the documentation. Since it is the most complicated requirement, it can be made
    to service the simpler method signatures by ignoring the parts of the quaternion
    we don’t need:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要提供一个简单的方法来移动手臂和定位附件。这需要更多的思考，因为每个API方法都有不同的方法签名。凯蒂决定最明显的解决方案是选择最复杂的要求，即`Quaternion`。根据文档，四元数是.NET
    `System.Numerics`库的一部分。这个结构体包含四个值，W、X、Y和Z，每个都是`Single`类型。由于它是最复杂的要求，可以通过忽略我们不需要的四元数部分来使其为更简单的方法签名提供服务：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two APIs, `WelderAttachmentAPI` and `GrabbingAPI`, need integers. First,
    we’ll convert the single numbers in the quaternion into integers by rounding as
    shown in the preceding code. Next, we’ll call the appropriate API based on the
    active attachment:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 两个API，`WelderAttachmentAPI`和`GrabbingAPI`需要整数。首先，我们将四元数中的单个数字四舍五入为整数，如前述代码所示。然后，根据活动附件调用适当的API：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The buffer attachment requires a quaternion, so our code will just be passing
    through the original argument. The X, Y, and Z coordinates can be made compatible
    with the other two method signatures by rounding the numbers and ignoring anything
    in the quaternion you don’t need.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区附件需要一个四元数，所以我们的代码只是传递原始参数。X、Y和Z坐标可以通过四舍五入与另外两个方法签名兼容，忽略四元数中不需要的部分。
- en: Phoebe decides her assembly line should be very simple. The robotics generally
    only need to worry about where along the assembly line they are positioned, so
    her control program will vary the X coordinate in every case. As a further measure
    of control, Phoebe decides to create a control program that knows precisely what
    the X coordinates are for each station on her assembly line.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比决定她的装配线应该非常简单。机器人通常只需要担心它们在装配线上的位置，所以她的控制程序将在每种情况下都改变X坐标。作为进一步的控制措施，菲比决定创建一个控制程序，该程序精确知道她装配线每个站点的X坐标。
- en: 'Her control program consists of this code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 她的控制程序由以下代码组成：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we see a set of constants. We have a maximum of ten robotic arms owing
    to Phoebe’s material and financial constraints. Since the arms can be made to
    work as a team, Phoebe discovers she can power 20 stations by systematically moving
    the robots from station to station, swapping out arm attachments as needed. She
    carefully calibrates her equipment and finds the ideal Y and Z coordinates. She
    sets them as constants along with a default rotational angle of 90 degrees, which
    works with all her processes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到一组常量。由于菲比的材料和财务限制，我们最多有十个机器人手臂。由于手臂可以组成一个团队工作，菲比发现她可以通过系统地移动机器人从站点到站点，并在需要时更换手臂附件，来供电20个站点。她仔细校准了她的设备，并找到了理想的Y和Z坐标。她将它们设置为常量，以及默认的旋转角度90度，这对于她的所有过程都适用。
- en: 'Next, Phoebe creates an array to hold the coordinates of her 20 stations as
    quaternions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，菲比创建了一个数组来存储她20个站点的坐标，作为四元数：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the assembly line is literally a straight line, it is easy to evenly
    space the stations 25 feet apart along the line’s X axis. A simple loop can then
    pre-populate the array of quaternions that represent the workstations on the assembly
    line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于装配线实际上是一条直线，因此很容易沿着线的X轴均匀地间隔25英尺设置各个站点。然后，一个简单的循环可以预先填充表示装配线工作站的四元数数组：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are now ready to set the robotic dance in motion.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备启动机器人舞蹈。
- en: 'Let’s instantiate our `RobotArmFacade`, set the attachment to a welder, and
    move it to station zero, which is the first position in the array of quaternions.
    Once it’s there, we’ll tell it to perform a weld using the `Actuate()` method
    on the façade:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实例化我们的`RobotArmFacade`，将附件设置为焊接机，并将其移动到站点零，这是四元数数组中的第一个位置。一旦到达那里，我们将告诉它使用外观上的`Actuate()`方法进行焊接：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let’s move the arm to station `3` where we need a buffer to smooth out
    a metal extrusion on a bicycle frame. Once the arm is in place, we’ll buff using
    the `Actuate()` method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将手臂移动到站点`3`，在那里我们需要一个缓冲区来平滑自行车框架上的金属挤出物。一旦手臂到位，我们将使用`Actuate()`方法进行抛光：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Splendid! The arm is now needed to grab a part and hold it in place for painting
    at station `7`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在需要手臂去抓取一个部件并在站点`7`上将其固定以进行喷漆：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Initially, we needed to deal with three different APIs from three different
    vendors to work with three different pieces of hardware. By using the Façade pattern,
    we were able to deal with one common interface for all three APIs, which isolates
    the bulk of our code from changes made in the API. When the API changes, we may
    need to change the façade, but we won’t need to change anything else.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们需要处理来自三个不同供应商的三个不同的API，以与三套不同的硬件协同工作。通过使用外观模式，我们能够处理所有三个API的共同接口，这使我们的大部分代码免受API更改的影响。当API发生变化时，我们可能需要更改外观，但不需要更改其他任何东西。
- en: The Composite pattern
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: Phoebe continued to work on the electronics. Kitty, however, was starting to
    worry about some of the fundamental considerations for her designs. Initially,
    the girls had agreed to use commercially available components, but Phoebe realized
    they could manufacture all the parts they need themselves. That way, assuming
    Bumble Bikes had access to all the raw materials, such as aluminum alloys, plastic,
    and rubber, they could have tighter control over the cost, durability, and weight
    of their final product. These factors influence everything from how Bumble Bikes
    sources its raw materials to the final sales price. The final sales price is factored
    by adding in the cost of goods sold, or in this case, the cost to manufacture,
    package, and deliver a bicycle. Kitty had some preliminary spreadsheets on her
    iPad. They were complicated, though. Kitty really wanted to ditch the two-dimensional
    thinking presented by her spreadsheets and come up with a better way to represent
    the cost of making a bicycle.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比继续工作在电子设备上。然而，契蒂开始担心她设计中的一些基本考虑因素。最初，女孩们同意使用商业可用的组件，但菲比意识到他们可以自己制造所有需要的部件。这样，假设Bumble
    Bikes能够获得所有原材料，如铝合金、塑料和橡胶，他们就能更紧密地控制最终产品的成本、耐用性和重量。这些因素影响着从Bumble Bikes如何获取原材料到最终销售价格的一切。最终销售价格是通过加上商品销售成本来计算的，在这种情况下，就是制造、包装和交付自行车的成本。契蒂在她的iPad上有一些初步的电子表格。虽然很复杂，但她真的很想摆脱电子表格展示的二维思维，并找到一种更好的方式来表示制造自行车的成本。
- en: Kitty opened her backpack and her heart sank. Her iPad, or what was left of
    it, spilled on to the worktable as a collection of broken glass and jagged plastic
    shards. She remembered her crash at Big Bend last weekend. She had misjudged the
    drop on a 3-foot (1-meter) ledge on Black Gap Road, flipped over her front handlebar,
    and landed on her back. Her backpack, which contained her iPad, had broken her
    fall. Everything was on that iPad! Thankfully, her father had drilled the number
    one house rule into her head. *“Always protect the gear!”* he would say. *“We
    make our livelihood with our tablets and our laptops. Others use them to play
    games and watch movies. There’s nothing wrong with that, but we use ours to make
    our mortgage, so take care of your gear!”* He would usually shout this epithet
    very early in the morning when he would invariably trip trying to avoid someone’s
    tablet, phone, or computer that had been left on the floor right along the path
    he took as he sleepily lumbered to the kitchen in the mornings in search of caffeine.
    Owing to this sage wisdom, the tablet was backed up. When Kitty had purchased
    it in Dallas from her favorite computer store, she had opted to get the extra
    99 USD replacement guarantee that covered everything, including accidental damage.
    The new iPad arrived in the mail the next day and Kitty, being a student of industrial
    design, reveled in the unboxing of her new digital compatriot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 契蒂打开她的背包，她的心沉了下去。她的iPad，或者说它剩下的部分，散落在了工作台上，形成了一堆破碎的玻璃和锋利的塑料碎片。她想起了上周末在Big Bend的意外。她在Black
    Gap Road上3英尺（1米）高的悬崖上判断失误，翻过了前轮把手，背部着地。装有iPad的背包帮她缓冲了落地时的冲击。所有东西都在那个iPad上！幸运的是，她的父亲已经将第一条家规深深地刻在了她的脑海中。“**永远保护你的装备**！”他会说。“**我们用平板电脑和笔记本电脑谋生。其他人用它们玩游戏和看电影。这没什么不好，但我们用它们来还房贷，所以照顾好你的装备**！”他通常会在一大早，当他不可避免地踩到某人遗忘在地板上的平板电脑、手机或电脑时，大声说出这个咒语。当他睡眼惺忪地沿着他每天早上带着咖啡因去厨房的路上，他会踩到这些东西。正因为这明智的智慧，平板电脑才得到了备份。当契蒂在达拉斯她最喜欢的电脑店购买它时，她选择了额外99美元的更换保证，涵盖了所有内容，包括意外损坏。新的iPad第二天就通过邮件寄到了，契蒂作为一个工业设计的学生，对她的新数字伙伴的拆箱感到非常兴奋。
- en: 'For all the criticisms she had about Apple products, such as the inability
    to upgrade or repair them, there was one thing nobody could deny. They have the
    coolest packaging of any product in the tech industry. The packaging itself is
    a work of industrial art: from the heavier than necessary gauge of cardboard to
    the way all the packages fit together to take up as little space as possible.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管她对苹果产品有很多批评，比如无法升级或维修，但有一件事没有人能否认。它们是科技行业中任何产品中最酷的包装。这个包装本身就是一件工业艺术品：从比必要的纸板厚度更重的纸板到所有包装件如何配合以尽可能少地占用空间。
- en: 'As Kitty was waiting for her cloud backup to restore all her data and apps,
    a lightning bolt thought struck her. Apple had solved the very problem she was
    considering. The way the packages fit together, where some are inside of others,
    reminded her of a tree structure. The iPad shipped with the tablet, a charger,
    a USB-C style cable, and a tiny box containing a beautifully printed instruction
    manual that everybody just throws away. There was a warranty card and a few other
    printed cards touting Apple’s responsible stance on the environment and an advert
    for AppleCare, Apple’s own service plan. The iPad itself was housed inside a coated
    cardboard insert where all the pieces in the package fit together precisely. The
    charger and cord fit in a niche below a sunken niche carved out for the iPad itself.
    Everything was coated with plastic, so nothing would be marred or scratched during
    shipment. The intricate package, depicted in *Figure 4.7* in a way that will not
    get me sued, contained as many small boxes and cardboard pieces as the actual
    electronics they held. Naturally, a product designer at Apple could tell precisely
    how much any of the smaller boxes or wrapped components within the larger package
    weighed at any time, as well as how much each of the intricate die-cut cardboard
    components cost to make. That designer probably agonized for months looking for
    ways to shave fractions of pennies off the package material cost, just as the
    iPad’s designers had stressed over weight, power, and heat concerns:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当凯蒂等待她的云备份恢复所有数据和应用程序时，一个闪电般的想法闪过她的脑海。苹果公司已经解决了她正在考虑的问题。这些包装件如何相互配合，其中一些位于其他包装件内部，这让她想起了树状结构。与平板电脑一起发货的还有充电器、USB-C风格的电缆，以及一个包含精美印刷说明书的小盒子，而每个人都会把它扔掉。还有一个保修卡和一些其他宣传苹果对环境负责立场的印刷卡片，以及苹果自己的服务计划AppleCare的广告。iPad本身被放置在一个涂层的纸板插套中，所有包装件中的部件都精确地组合在一起。充电器和电缆被放置在一个凹槽中，这个凹槽是为iPad本身挖出的。所有东西都涂上了塑料，这样在运输过程中就不会有任何损坏或划痕。这个复杂的包装，如*图4.7*所示，以一种不会让我被起诉的方式，包含了与实际电子产品一样多的小型纸盒和纸板部件。自然，苹果公司的一名产品设计师可以精确地知道任何较小的盒子或包装件中包装的组件在任何时候的重量，以及每个复杂的模切纸板组件的制造成本。那位设计师可能为了寻找削减包装材料成本几分钱的方法而痛苦了数月，就像iPad的设计师们对重量、功率和热量问题感到担忧一样：
- en: '![Figure 4.7: Kitty’s new tablet came intricately packaged. She realized it
    could be modeled as a tree structure, and perhaps bicycle components might be
    modeled in the same way.  ](img/B18605_Figure_4.71.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![*图4.7*：凯蒂的新平板电脑被精心包装。她意识到它可以被建模为树状结构，也许自行车的部件也可以用同样的方式建模。](img/B18605_Figure_4.71.jpg)'
- en: 'Figure 4.7: Kitty’s new tablet came intricately packaged. She realized it could
    be modeled as a tree structure, and perhaps bicycle components might be modeled
    in the same way.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.7*：凯蒂的新平板电脑被精心包装。她意识到它可以被建模为树状结构，也许自行车的部件也可以用同样的方式建模。'
- en: So far, Kitty had successfully created class models for high-level bicycle components,
    such as the frame. She and Phoebe had committed themselves to the idea that they
    would manufacture everything for the bicycles themselves, including the crankset.
    The crankset consists of all the parts that make the bicycle move when you push
    down on the pedals. Bumble Bikes intended to position itself on the market as
    a cut above big-box stores in terms of its build quality. That meant every gram
    would be scrutinized by sophisticated customers who were conditioned to having
    to buy a bicycle, discard most of the components it came with, and replace them
    with better, lighter components. There is always a perfect balance between the
    weight and cost of the crankset for many riders. The racing community will pay
    a premium for parts that are several grams lighter, while casual riders want a
    product that’s less expensive and they don’t mind the extra weight.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Kitty已经成功地为高级自行车组件，如车架，创建了类模型。她和Phoebe致力于自己制造所有自行车的想法，包括曲柄组。曲柄组由所有使你在踩踏板时推动自行车移动的部件组成。Bumble
    Bikes打算在市场上将自己定位为比大型百货商店更高的水平，就其制造质量而言。这意味着每一克都会被经过训练的、习惯于购买自行车、丢弃大部分随车组件并替换为更好、更轻组件的复杂客户仔细检查。对于许多骑行者来说，曲柄组的重量和成本之间总是有一个完美的平衡。赛车社区愿意为轻几克的部件支付溢价，而休闲骑行者则希望购买更便宜的产品，并且不介意额外的重量。
- en: 'The crankset, as with the boxes, can be modeled as a tree, as we’ll soon see.
    If you’re not personally familiar with the parts on a bicycle that comprise a
    crankset, and you’re curious, see Kitty’s CAD drawing in *Figure 4.8* where she
    was kind enough to diagram most of them for us:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像盒子一样，曲柄组可以被建模为树，正如我们很快就会看到的。如果你不熟悉组成曲柄组的自行车部件，并且对此感到好奇，请参阅Kitty在*图4.8*中的CAD图纸，她很友好地为我们图解了其中大部分：
- en: '![Figure 4.8: The crankset for a typical bicycle involves components that can
    be nested in a tree-like structure to solve our immediate problems with cost and
    weight. ](img/B18605_Figure_4.81.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：典型自行车的曲柄组涉及可以嵌套在树状结构中的组件，以解决我们关于成本和重量的即时问题。](img/B18605_Figure_4.81.jpg)'
- en: 'Figure 4.8: The crankset for a typical bicycle involves components that can
    be nested in a tree-like structure to solve our immediate problems with cost and
    weight.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：典型自行车的曲柄组涉及可以嵌套在树状结构中的组件，以解决我们关于成本和重量的即时问题。
- en: 'When you are presented with modeling a tree-like structure of objects that
    can conform to a common interface, you should immediately think of the Composite
    pattern. The Composite pattern allows you to compose a tree of objects and then
    work with the structure as if it were a single object. The tree is composed of
    containers and leaves. A leaf is a tree element that doesn’t have any sub-elements.
    A container is a tree element that has other leaves and containers within it.
    Graphically, this looks similar to a file folder structure on your computer. The
    files are leaves and the folders are containers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你面对建模一个可以符合通用接口的对象树状结构时，你应该立刻想到组合模式。组合模式允许你组合一个对象树，然后像处理单个对象一样与该结构一起工作。树由容器和叶子组成。叶子是一个没有子元素的树元素。容器是一个包含其他叶子和容器在内的树元素。从图形上看，这类似于你电脑上的文件文件夹结构。文件是叶子，文件夹是容器：
- en: '![Figure 4.9: The file structure of your computer’s hard drive is represented
    as a tree consisting of leaves (files) and containers (folders). ](img/B18605_Figure_4.91.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：你的电脑硬盘的文件结构被表示为一个由叶子（文件）和容器（文件夹）组成的树。](img/B18605_Figure_4.91.jpg)'
- en: 'Figure 4.9: The file structure of your computer’s hard drive is represented
    as a tree consisting of leaves (files) and containers (folders).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：你的电脑硬盘的文件结构被表示为一个由叶子（文件）和容器（文件夹）组成的树。
- en: 'We can model part of our group set this way as well. For our mechanically inclined
    readers, I’m not necessarily suggesting these parts literally fit inside each
    other in the physical world. I’m suggesting they can be modeled this way to solve
    the problem at hand in terms of weight and cost. In this model, the crankset consists
    of the bottom bracket, which is basically a big hole at the bottom of the bicycle
    frame fitted with bearings, and a shaft extends through the bottom bracket. The
    shaft is connected to a set of chainrings. Most bicycles have one, two, or three
    chainrings depending on what kind of bicycle it is. Road bikes usually have two:
    a large chainring for general riding and a small chairing that is used to climb
    hills. In our model, the small chain ring is treated as a leaf where all other
    components so far have been containers.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用这种方式来模拟我们小组的一部分。对于那些对机械感兴趣的读者，我并不一定是在建议这些部分在物理世界中真的可以相互嵌套。我是在建议它们可以用这种方式来模拟，以解决关于重量和成本的问题。在这个模型中，曲柄组由底座组成，底座基本上是自行车框架底部的一个大洞，并装有轴承，一个轴穿过底座。轴连接到一组链轮。大多数自行车根据类型的不同，有一个、两个或三个链轮。公路自行车通常有两个：一个大链轮用于一般骑行，一个小链轮用于爬坡。在我们的模型中，小链轮被处理为叶子，而到目前为止所有其他组件都是容器。
- en: The chainrings connect to the crank arms, which are one big piece, even though
    they might appear to be two separate arms. The arms attach to the left and right
    pedals, which are the leaves and the end of our tree structure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 链轮连接到曲柄臂，尽管它们可能看起来是两个独立的臂，但实际上它们是一个大部件。臂连接到左右踏板，踏板是叶子，也是我们树结构的末端。
- en: 'The composite pattern allows you to work with complex tree structures elegantly
    by allowing you to make full use of recursion and polymorphism. Just be careful
    that you work with classes that have a very common interface. You might be introducing
    code smell if you must shoe-horn a bunch of classes that don’t really fit together.
    This pattern pairs nicely with the Builder pattern already in use because the
    builder can be made to assemble the tree structure. The basic structure of the
    composite pattern is shown in *Figure 4.10*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许你通过充分利用递归和多态性优雅地处理复杂的树结构。只是要小心，确保你处理的是具有非常通用接口的类。如果你必须强行将一大堆实际上并不搭配的类放在一起，你可能会引入代码异味。这个模式与已经使用的
    Builder 模式配合得很好，因为 Builder 可以被用来组装树结构。组合模式的基本结构在 *图 4.10* 中显示：
- en: '![Figure 4.10: The Composite pattern. ](img/B18605_Figure_4.101.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：组合模式。](img/B18605_Figure_4.101.jpg)'
- en: 'Figure 4.10: The Composite pattern.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：组合模式。
- en: 'Let’s understand this figure in detail:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解这个图：
- en: The `Component` class will implement some interface with the methods needed
    to access the overall functionality. Here, we’re calling that `Run()`. Components
    can contain leaves and other components.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Component` 类将实现一些接口，包含访问整体功能所需的方法。这里，我们称之为 `Run()`。组件可以包含叶子和其他组件。'
- en: The `Leaf` class represents nodes in the tree that can’t contain anything else.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Leaf` 类代表树中不能包含其他内容的节点。'
- en: The `Composite` object allows for the creation and maintenance of a tree structure
    using components and leaves.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Composite` 对象允许使用组件和叶子创建和维护树结构。'
- en: The client program accesses the composite tree as it needs and can treat simple
    and complex objects identically.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端程序在需要时访问组合树，并且可以像对待简单和复杂对象一样对待它们。
- en: I want to reiterate that we are *not* attempting to model the physical structure
    of our bicycle. This model is a cost model and defines the relationships within
    a group of components, not the order of physical assembly. The fields we’re interested
    in are cost and weight, and those fields will form an interface that describes
    the common properties of any bicycle component regardless of its form, construction,
    or purpose.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我要重申，我们 *不是* 试图模拟自行车的物理结构。这个模型是一个成本模型，定义了组件组内的关系，而不是物理组装的顺序。我们感兴趣的领域是成本和重量，这些字段将形成一个接口，描述任何自行车组件的通用属性，无论其形式、构造或用途。
- en: 'Kitty’s version looks as follows in *Figure 4.11*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty 的版本在 *图 4.11* 中如下所示：
- en: '![Figure 4.11: Kitty has changed the structure of the basic pattern found in
    Figure 4.x to suit her needs. Note this isn’t the diagram of the full hierarchy,
    it’s just the structure of the pattern  ](img/B18605_Figure_4.111.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：Kitty 将图 4.x 中找到的基本模式的结构进行了修改以适应她的需求。注意这并不是完整层次结构的图，它只是模式的结构](img/B18605_Figure_4.111.jpg)'
- en: 'Figure 4.11: Kitty has changed the structure of the basic pattern found in
    Figure 4.x to suit her needs. Note this isn’t the diagram of the full hierarchy,
    it’s just the structure of the pattern'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：Kitty将图4.x中找到的基本模式的结构改变以适应她的需求。注意，这不是整个层次结构的图，只是模式的结构
- en: 'The implementation of this pattern only requires one abstract class and a horde
    of concrete classes based on the abstract class. The following are the contents
    of Kitty’s abstract `BicycleComponent` class, which forms the vital common interface
    needed by the pattern. We need two private properties to hold the `weight` and
    `cost` values of the component:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的实现只需要一个抽象类和基于该抽象类的一群具体类。以下是在Kitty的抽象`BicycleComponent`类中的内容，它形成了模式所需的关键通用接口。我们需要两个私有属性来保存组件的`weight`和`cost`值：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we need a list to hold any subcomponents. Kitty specified an interface
    for the type instead of directly coupling to the `List<>` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个列表来持有任何子组件。Kitty指定了一个接口来表示类型，而不是直接耦合到`List<>`类：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These three properties are initialized in a constructor where we pass in `weight`
    and `cost` as floats. The `SubComponents` list is initialized as an empty list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性在构造函数中初始化，我们传递`weight`和`cost`作为浮点数。`SubComponents`列表初始化为一个空列表：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we need two methods to display the weights and costs of the components
    along with any subcomponents. These can leverage recursion to print out the entire
    tree, which is handy for Kitty’s cost analysis. We only need to do this on containers,
    not leaves, since leaves will be printed with their containers. We determine whether
    we’re dealing with a leaf by checking `SubComponents.Count`. If it is zero, we
    are dealing with a leaf, and we simply return. Otherwise, we loop and print the
    weight and cost of the subcomponents:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要两个方法来显示组件及其任何子组件的重量和成本。这些方法可以利用递归来打印出整个树，这对于Kitty的成本分析很有用。我们只需要在容器上做这件事，而不是在叶子上，因为叶子会与其容器一起打印。我们通过检查`SubComponents.Count`来确定我们是否在处理叶子。如果它是零，我们就是在处理叶子，我们只需简单地返回。否则，我们循环并打印子组件的重量和成本：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we do the same thing with cost:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用同样的方式处理成本：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The concrete code for the Composite pattern is generally very repetitive, as
    you’ll see. In fact, Kitty does something here she doesn’t do anywhere else. She
    makes one file containing many classes. She names the file `CompositeParticipants.cs`,
    the partial contents of which follow in the code below. She did it this way because
    effectively it’s a collection of very simple concrete classes that inherit from
    a base class. If you want to see the whole class, consult Kitty’s code in the
    chapter’s sample code project:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式的具体代码通常非常重复，您很快就会看到。事实上，Kitty在这里做了一件在其他地方没有做过的事情。她创建了一个包含许多类的文件。她将文件命名为`CompositeParticipants.cs`，下面是代码的局部内容。她这样做是因为实际上它是一个继承自基类的非常简单的具体类的集合。如果您想看到整个类，请查阅章节示例代码项目中的Kitty的代码：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, this isn’t rocket surgery. Every part is simply modeled as a
    concrete implementation of the abstract class. I’ve shown three classes here.
    There are seven in total that all look the same save for the class name.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这并不是什么火箭科学。每个部分都简单地被建模为抽象类的具体实现。我在这里展示了三个类。总共有七个类，除了类名不同，它们看起来都一样。
- en: 'At first glance, this might seem odd until you see how the composite’s tree
    is constructed in the client code within the `Program.cs` file. Within that file,
    Kitty builds the tree from the bottom up. This isn’t a requirement, but it does
    make it easy to understand. The leaves at the bottom of the tree are the petals
    or pedals:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能会显得有些奇怪，直到你看到客户端代码中`Program.cs`文件内如何构建组合的树。在该文件中，Kitty从下往上构建树。这不是一个要求，但它确实使理解变得容易。树的底部的叶子是花瓣或踏板：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The pedals connect to the crank arm. I’m suddenly reminded of the old song
    *Dem Bones* where the toe bone is connected to the foot bone. The foot bone is
    connected to the heel bone. The song continues up to the head bone followed by
    an invocation of the songwriter’s creator. Here, the pedal bone is connected to
    the crank arm bone, except they aren’t bones:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 踏板连接到曲柄臂。我突然想起了那首老歌《Dem Bones》，其中脚趾骨连接到脚骨。脚骨连接到跟骨。歌曲继续到头骨，然后是歌曲创作者的召唤。在这里，踏板骨连接到曲柄臂骨，但它们并不是骨头：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We create the instance of `CrankArm`, then add the pedals to its `SubComponents`
    list. `crankArm` is connected to `largeChainRing`. So is `smallChainRing`, which
    itself becomes a leaf:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`CrankArm`的实例，然后将踏板添加到其`SubComponents`列表中。`crankArm`连接到`largeChainRing`。同样，`smallChainRing`也连接到它，它本身成为一个叶节点：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The large chainring is connected to the shaft:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 大飞轮连接到轴上：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The shaft fits through the bottom bracket:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 轴穿过下轴杯：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That’s our crank set, but I’ll add a top-level instance of `CrankSet` and pass
    in zeros for the cost and weight since the crank set itself comprises its subcomponents:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们的曲柄组，但我会添加一个`CrankSet`的顶层实例，并将成本和重量设为零，因为曲柄组本身由其子组件组成：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now for the magical part of our show. We’ll call the two methods and get a
    recursive detail of the whole structure:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示的神奇部分。我们将调用两个方法，并获取整个结构的递归细节：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The result of the run is shown in *Figure 4.12*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行结果如图4.12所示：
- en: '![Figure 4.12: The run results of our Composite pattern project. ](img/B18605_Figure_4.121.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12：我们的组合模式项目的运行结果。](img/B18605_Figure_4.121.jpg)'
- en: 'Figure 4.12: The run results of our Composite pattern project.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：我们的组合模式项目的运行结果。
- en: The Composite pattern is used whenever you need to process a hierarchical structure
    as a tree. The main requirement for the pattern to be effective is that every
    node in the tree must conform to a common interface. If that can be managed, you
    can use this pattern to process the tree in any manner you might need. You can
    add new class types to your tree, so long as they conform to the common interface.
    Using this pattern, you can create novel processing capabilities while honoring
    the open-closed principle. Recursion and polymorphism can be exploited to expedite
    your processing. The client code will treat nodes and containers identically since
    they have a common structure, which is really the hard part. You have to find
    a way to make everything in the tree conform to the common interface, which isn’t
    always easy.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式用于您需要将层次结构作为树来处理时。该模式有效的主要要求是树中的每个节点都必须符合一个公共接口。如果这一点可以管理，您就可以使用这种模式以任何您可能需要的任何方式处理树。只要它们符合公共接口，您就可以向您的树中添加新的类类型。使用这种模式，您可以在遵守开闭原则的同时创建新的处理能力。递归和多态可以用来加速您的处理。客户端代码将节点和容器同等对待，因为它们具有公共结构，这实际上是难点所在。您必须找到一种方法使树中的所有内容都符合公共接口，这并不总是容易的。
- en: The Bridge pattern
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接模式
- en: 'The **Bridge pattern** is a structural design pattern that lets you split a
    large class or set of closely related classes into two separate hierarchies: abstraction
    and implementation. Kitty and Phoebe set up a Kickstarter page to promote Bumble
    Bikes and gauge the interest on the market. Backers can preview and pre-order
    the *Palo Duro Canyon Ranger*, Bumble Bike’s flagship mountain bike design. The
    project has been well received, but the Kickstarter backers are complaining about
    the lack of color choices on the bikes. In the original design, the girls purposefully
    limited the color choices because they were using inheritance for almost everything.
    The problem with using inheritance is becoming a clear theme: it can lead to a
    run-away proliferation of classes, as seen in *Figure 4.13*. Can you imagine supporting
    20 colors per bicycle model, and expanding to 20 models of bicycles? That’s a
    lot of subclasses!'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**桥接模式**是一种结构型设计模式，它允许您将一个大类或一组密切相关的大类拆分为两个独立的层次：抽象和实现。Kitty和Phoebe创建了一个Kickstarter页面来推广Bumble
    Bikes并衡量市场上的兴趣。支持者可以预览并预购Bumble Bike的旗舰山地车设计——*Palo Duro Canyon Ranger*。该项目受到了好评，但Kickstarter的支持者对自行车上颜色选择的缺乏表示不满。在原始设计中，女孩们故意限制了颜色选择，因为她们几乎在所有事情上都使用了继承。使用继承的问题正在成为一个明显的主题：它可能导致类的大量无序膨胀，如图4.13所示。你能想象支持每个自行车模型20种颜色，并扩展到20种自行车模型吗？那会有很多子类！'
- en: '![Figure 4.13: Class proliferation may sound as if it’s a Marxist political
    construct, but it becomes a problem when you over-use inheritance (we clearly
    need a better way to represent a finite set of supported colors for our bicycles).
    ](img/B18605_Figure_4.131.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13：类膨胀听起来可能像是一个马克思主义政治结构，但当您过度使用继承（我们显然需要一个更好的方法来表示我们自行车支持的有限颜色集）时，它就会成为一个问题。](img/B18605_Figure_4.131.jpg)'
- en: 'Figure 4.13: Class proliferation may sound as if it’s a Marxist political construct,
    but it becomes a problem when you over-use inheritance (we clearly need a better
    way to represent a finite set of supported colors for our bicycles).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：类膨胀听起来可能像是一个马克思主义政治概念，但当过度使用继承时（我们显然需要一个更好的方法来表示我们自行车支持的有限颜色集）就会成为一个问题。
- en: Perhaps the simplest way to solve this is to simply create a property on your
    base bicycle class to hold the color. Maybe have it store a common color structure
    such as **Red Green Blue** (**RGB**) or **Cyan Magenta Yellow Black** (**CMYK**),
    which is the color model used by printers. This works fine if you’re dealing 100%
    with software and you need to represent a color within a gamut supported by your
    user’s graphics card or printer.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法可能是简单地在你基自行车类上创建一个属性来保存颜色。也许可以存储一个常见的颜色结构，如**红绿蓝**（**RGB**）或**青色品红色黄色黑色**（**CMYK**），这是打印机使用的颜色模型。如果你完全在软件中处理，并且需要在你用户的显卡或打印机支持的色域内表示颜色，这工作得很好。
- en: In an industry such as bicycle manufacturing, this won’t work, because we aren’t
    just representing any possible color of light or paint. We need to represent a
    finite set of paints to be mixed and applied using machinery. This dimension of
    realism means there are limits to how the color system can work. The girls must
    keep the base colors and topcoats in stock, and they must take into account the
    setup and cleaning costs of their painting machinery. Limiting each bike to one
    available color handles all this nicely without any design problems. In effect,
    they were counting on controlling a variable in their software by making a single
    color a business requirement. As it turns out, the market won’t bear that constraint.
    Competitors can offer a range of colors. Phoebe herself remembers the most important
    aspect of her new bike when she was 9 was that it was pink. She didn’t care about
    where it came from or whether it had a fancy label on the frame. It had to be
    pink.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在自行车制造等行业中，这种方法是不可行的，因为我们不仅仅要表示任何可能的光或漆的颜色。我们需要表示一组有限的油漆，这些油漆需要通过机器混合和涂装。这个现实层面的维度意味着颜色系统的工作有局限性。女孩们必须保持基础颜色和清漆的库存，并且必须考虑到他们涂装机械的安装和清洁成本。将每辆自行车限制为一种可用的颜色可以很好地处理所有这些问题，而不会出现任何设计问题。实际上，他们依靠通过将单一颜色作为业务需求来控制他们软件中的一个变量。结果证明，市场无法承受这种约束。竞争对手可以提供一系列颜色。菲比自己记得当她9岁时，她新自行车的最重要的方面就是它是粉红色的。她不在乎它来自哪里，或者车架上是否有花哨的标签。它必须是粉红色的。
- en: When we looked at the Decorator pattern earlier in this chapter, the problem
    was similar. We added external features, such as bells and lights, which could
    also be represented with an exponentially growing tree of subclasses. So, why
    not use a decorator here? Perhaps, you could think of a paint job as a decorator.
    Decorators, though, are designed to stack. We can stack a bell, headlights, taillights,
    fenders, mirrors, and even bicycle theft alarms on top of one another within the
    object hierarchy to build the perfect bicycle without altering the abstract bicycle
    base class. There’s something not quite right about stacking paint jobs or even
    stacking your bell or lights onto a paint job. The paint, conceptually speaking,
    is more a part of the frame than something that decorates it. Beware of learning
    a pattern and then wielding it as a golden hammer. The decorator doesn’t really
    fit here, even though not using the pattern has a similar side effect.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章早期讨论装饰者模式时，遇到的问题类似。我们添加了外部特性，例如铃铛和灯光，这些特性也可以用指数增长的子类树来表示。那么，为什么不用装饰者呢？也许，你可以把喷漆工作想象成一个装饰者。然而，装饰者被设计成可以堆叠的。我们可以在对象层次结构中堆叠铃铛、前大灯、尾灯、挡泥板、镜子，甚至自行车防盗警报器，以构建一个完美的自行车，而不需要修改抽象的自行车基类。将喷漆工作堆叠，甚至将铃铛或灯光堆叠在喷漆工作上，在概念上似乎不太合适。喷漆，从概念上讲，更多的是车身的一部分，而不是装饰它的东西。当学习到一个模式后，要小心不要把它当作金锤来使用。装饰者在这里并不适用，尽管不使用该模式也有类似的副作用。
- en: When you read about the Bridge pattern in the GoF book, and I always encourage
    you to go to the original academic sources when you can, you will find it couched
    in very academic language. They talk about a bridge between an abstraction and
    its implementation. We can vary each independently of one other by keeping the
    two separate. We have a business requirement for a new dimension that is an integral
    part of our bicycle’s frame and we need to vary that dimension independently of
    the abstract bicycle. When you want to vary two or more dimensions independently,
    while avoiding a combinatorically increasing number of subclasses, you need the
    Bridge pattern.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 GoF 书中阅读关于桥接模式的内容时，我总是鼓励你在可能的情况下查阅原始的学术来源，你会发现它用非常学术性的语言来描述。他们谈论的是抽象与其实现之间的桥梁。我们可以通过保持两者分离来独立地改变它们。我们有一个新的维度业务需求，它是我们自行车框架的组成部分，我们需要独立于抽象自行车来改变这个维度。当你想要独立地改变两个或更多维度，同时避免子类数量组合增加时，你需要桥接模式。
- en: 'You can see a representation of the Bridge pattern in *Figure 4.14*. I may
    have had a little fun with the visuals, but it does make it easy to see why this
    pattern is called a *bridge*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*图 4.14*中看到桥接模式的表示。我可能在视觉上玩了一点小花样，但这确实使得理解为什么这个模式被称为*桥接*变得容易：
- en: '![Figure 4.14: The Bridge pattern allows you to vary two sides of your object
    structure independently along two different dimensions. ](img/B18605_Figure_4.141.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14：桥接模式允许你独立于两个不同的维度，独立地改变你的对象结构两边的属性。](img/B18605_Figure_4.141.jpg)'
- en: 'Figure 4.14: The Bridge pattern allows you to vary two sides of your object
    structure independently along two different dimensions.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：桥接模式允许你独立于两个不同的维度，独立地改变你的对象结构两边的属性。
- en: 'Let’s review the elements of the Bridge pattern in our diagram by the numbers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过数字来回顾我们图中桥接模式的元素：
- en: This is the client that accesses the functionality in the abstraction.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是访问抽象中功能性的客户端。
- en: This is the abstraction side of the bridge. This is usually the class structure
    that you started with and the structure that worked well until you realized you
    had additional dimensions you needed to model.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是桥接模式中的抽象方面。这通常是你在开始时使用的类结构，以及直到你意识到你需要对额外的维度进行建模之前工作良好的结构。
- en: Refinements to the abstraction are subclasses that make sense and that don’t
    create a runaway multi-dimensional class structure. We have several refinements
    by way of four different types of bicycles that inherit from the abstract bicycle
    class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对抽象的细化是具有意义且不会导致多维类结构失控的子类。我们通过四种不同类型的自行车来继承抽象自行车类，有几种细化方式。
- en: The implementation interface is on the other side of the bridge. This is where
    you model the dimension that will vary independently of the abstraction. Note
    the bridge itself between the two consists of a compositional relationship. The
    abstraction has an implementation of the second dimension.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口位于桥的另一侧。这是你建模将独立于抽象变化的维度的位置。注意，连接这两个维度的桥本身是一个组合关系。抽象具有第二维度的实现。
- en: This is the concrete implementation of the second dimension based on the interface.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是基于接口的第二维度的具体实现。
- en: That’s a shark. Studies have shown that you are 68.342% more likely to be attacked
    by a shark if you don’t use the Bridge pattern to decouple your complicated classes.
    It doesn’t even matter if you live inland. Nobody knows why. It’s SCIENCE! Don’t
    argue.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那是一条鲨鱼。研究表明，如果你不使用桥接模式来解耦你的复杂类，你被鲨鱼攻击的可能性会增加 68.342%。即使你住在内陆，这也无关紧要。没有人知道为什么。这是科学！不要争论。
- en: 'Let’s take a look at Kitty’s version of the Bridge pattern diagram applied
    to the bicycle paint problem in *Figure 4.15*:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看凯蒂在*图 4.15*中应用的桥接模式图，它用于自行车涂装问题：
- en: '![Figure 4.15: Kitty’s whiteboard rendition of the bridge pattern applied to
    her paint problem. ](img/B18605_Figure_4.151.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15：凯蒂对她的绘画问题应用桥接模式的白板演示。](img/B18605_Figure_4.151.jpg)'
- en: 'Figure 4.15: Kitty’s whiteboard rendition of the bridge pattern applied to
    her paint problem.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：凯蒂对她的绘画问题应用桥接模式的白板演示。
- en: '*“Whoa, whoa, WHOA! Wait one fluffy minute!”* Phoebe exclaimed as she stomped
    her foot on the ground. *“You can’t do this! The only way to make this work is
    to break the open-closed principle! We’ve held this rule as sacrosanct!”* Kitty
    stared blankly at the board. Phoebe is right. She usually was, especially when
    she stomped her feet, a trait she got from her mother.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*“哇，哇，哇！等一下，别急！”* 菲比一边跺着脚，一边大声说道。*“你不能这么做！让这一切运作的唯一方法就是打破开闭原则！我们一直把这条规则视为神圣不可侵犯！”*
    基蒂茫然地看着黑板。菲比是对的。她通常都是对的，尤其是在她跺脚的时候，这是她从母亲那里继承来的一个特点。'
- en: '*“We already* *have a color attribute in the abstract Bicycle class,”* Kitty
    observed. *“But because it’s a stinkin’ enum, we can’t extend it, nor can we subclass
    it,”* Phoebe added. *“What about a decorator?”* Kitty asked. *“Maybe, but it seems
    as though we’re going to wind up with a lot more code and complexity than we would
    if we just changed the original design,”* Phoebe said. Neither wanted to give
    up. For the next few hours, the two pored over articles on other patterns that
    might help them. The problem here is that the original model used an enumeration
    to define the colors. A limitation of the C# language holds that an enumeration
    cannot be extended.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我们在抽象的自行车类中已经有了颜色属性，”* 基蒂观察到。*“但因为它是一个讨厌的枚举，我们无法扩展它，也无法子类化它，”* 菲比补充道。*“装饰器怎么样？”*
    基蒂问道。*“也许吧，但看起来我们可能会得到比仅仅改变原始设计更多的代码和复杂性，”* 菲比说。他们都不想放弃。接下来的几个小时里，他们翻阅了其他可能帮助他们解决问题的模式的文章。这里的问题是原始模型使用枚举来定义颜色。C#语言的限制是枚举不能被扩展。'
- en: If they subclass or decorate the original `IBicycle` interface or the abstract
    `Bicycle` class, they’ll need to add the `PaintJob` attribute, but they’ll be
    stuck with the existing `Color` attribute. Inheritance doesn’t give us a way to
    hide or remove deprecated code. Covering it up with a façade doesn’t feel right
    either. Even if you covered the unused member with a façade, it would also change
    the interface you use to work with the bicycle classes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们子类化或装饰原始的`IBicycle`接口或抽象的`Bicycle`类，他们需要添加`PaintJob`属性，但他们将不得不保留现有的`Color`属性。继承不能给我们隐藏或删除过时代码的方法。用外观来掩盖它也不觉得合适。即使你用外观掩盖了未使用的成员，它也会改变你用来与自行车类交互的接口。
- en: '*“Gaga! We are going to* *have to change the type in the bicycle base class!”*
    Phoebe said angrily. “Gaga” is a word Phoebe had trained herself to say in place
    of less socially acceptable words, such as the ones most people say when they
    stub their toe really, really, hard. The two railed against the realization with
    the fervor of defense attorneys trying to free an innocent man accused of capital
    murder. They pored over software engineering books and books on patterns. A common
    thread in all those books is that never once did any of the authors ever make
    a design mistake. They either presented trivial examples such as shapes, circles,
    and squares, or they presented patterns in a way that was too hypothetical – `ClassA`
    inherits from `ClassB`, and so on. The examples weren’t very useful, but they
    were very safe, as far as examples go. The GoF book presents real-world use cases
    via a windowed software project mainly aimed at Unix users working with SmallTalk,
    which isn’t widely used outside of government and academic circles.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*“天哪！我们* *得改变自行车基类中的类型了！”* 菲比愤怒地说。“天哪”是菲比训练自己用来代替不那么社会可接受的话的一个词，比如大多数人当脚趾被重重地踢到时说的那些话。他们像辩护律师试图为被指控犯有死刑的无辜者辩护一样，对这一认识进行了激烈的反驳。他们翻阅了软件工程书籍和关于模式的书籍。所有这些书籍的共同主题是，所有作者从未犯过设计错误。他们要么提供了诸如形状、圆形和正方形这样的简单示例，要么以过于假设的方式展示了模式——`ClassA`从`ClassB`继承，等等。这些示例不太有用，但它们在示例方面非常安全。GoF书籍通过一个面向Unix用户的窗口软件项目展示了现实世界的用例，该项目主要针对使用SmallTalk的Unix用户，而SmallTalk在政府和非学术圈外并不广泛使用。'
- en: Late one night, the sisters found the clarity that had been eluding them. Two
    of the most important books in the world of agile development with patterns are
    Robert Martin’s books titled *Agile Software Development, Principles, Patterns
    and Practices*, as well as the rewrite for C# developers titled *Agile Software
    Development, Principles, Patterns and Practices in C#*. The GoF book introduced
    the world to formalized software patterns, but Uncle Bob’s books introduced the
    world to SOLID and agile principles coupled with those patterns. Don’t worry.
    They aren’t tightly coupled. That would be a horribly recursive nightmare.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个深夜，姐妹们找到了一直逃避他们的清晰。在敏捷开发模式的世界中，两本最重要的书籍是Robert Martin所著的《敏捷软件开发：原则、模式与实践》，以及为C#开发者重写的《敏捷软件开发：原则、模式与实践（C#版）》。GoF书籍向世界介绍了正式的软件模式，但Uncle
    Bob的书籍向世界介绍了SOLID和敏捷原则，以及与之相结合的模式。别担心，它们并不是紧密耦合的。那将是一个可怕的递归噩梦。
- en: If you’re reading the e-book version of this book, assuming there is one, get
    out your e-highlighter for the next three sentences. Analog highlighters can be
    used on analog books.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书的电子书版本（假设有），请在接下来的三句话中拿出你的电子高亮笔。在纸质书上可以使用模拟高亮笔。
- en: Uncle Bob reminds us that it is impossible to foresee every design consideration
    ahead of time. Nobody is prescient, which is a point we made in the first chapter
    of this book. Lack of prescience leads to design problems that are usually solved
    with stovepipe-style fixes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Uncle Bob提醒我们，事先预见每一个设计考虑是不可能的。没有人是先知，这是我们在这本书的第一章中提到的一个观点。缺乏先见会导致通常用烟囱式解决方案解决的问题设计问题。
- en: It may seem as though we’re abandoning our open-closed principle. You should
    never abandon the SOLID principles. But sometimes you must break them for the
    greater good.  Martin’s books describe this as taking a bullet and realizing the
    opportunity to learn from the mistake. He also reasons for you to consider every
    element within your code that can be refactored in an identical manner with the
    hope that you need only to take one such bullet. In the real world, as software
    grows, you will need to adhere to good principles, but you can’t be shackled by
    them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们正在放弃我们的开闭原则。你永远不应该放弃SOLID原则。但有时你必须为了更大的利益而打破它们。Martin的书籍将此描述为承受一枪并意识到从错误中学习的机会。他还为你推理出，你应该考虑代码中可以以相同方式重构的每个元素，希望你只需要承受一枪。在现实世界中，随着软件的增长，你需要遵守良好的原则，但你不能被它们束缚。
- en: Patterns can help you avoid the need to change the base class, but occasionally
    you will need to change the design because not changing it will make everything
    worse. Equally as important is the exercise of removing dead code from the software.
    This too necessitates breaking SOLID principles. It is far better to remove the
    dead code than leave it in for the sake of dogma.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以帮助你避免需要更改基类，但有时你需要改变设计，因为不改变它会使一切变得更糟。同样重要的是，从软件中移除死代码的练习。这也需要打破SOLID原则。从教条的角度来看，移除死代码远比留下它要好。
- en: In this particular case, changing the way we implement the property allows us
    to serve our business requirements in a flexible way true to the spirit of SOLID
    principles without being fettered by them. This is a call you should find yourself
    making on rare occasions. Changing the interface to use the new `IPaintJob` interface
    adds significant business value to the overall design.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，改变我们实现属性的方式，使我们能够以符合SOLID原则精神的方式灵活地满足业务需求，而不受其束缚。这是一个你很少会做出的决定。将接口更改为使用新的`IPaintJob`接口，为整体设计增加了显著的业务价值。
- en: We now have a way to model the bicycle, which we’ve had for a while, and a business-savvy
    way to model the paint job. Kitty and Phoebe can now offer their customers bicycles
    in a variety of colors. We’ve gone from limiting customers to a finite set of
    one color per bicycle to a set that is limited only by the gamut of the paints.
    We’ve shifted from a software limitation on the business to a limitation of real-world
    chemistry and machinery. I’ve personally always held that business should define
    software, not the other way around.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了建模自行车的途径，这是我们一直拥有的，以及一种商业敏感的建模喷漆工作方式。Kitty和Phoebe现在可以向他们的客户提供各种颜色的自行车。我们已经从限制客户只能选择每辆自行车的一种颜色，转变为仅受油漆色域限制的选择。我们已经从软件对业务的限制转变为现实世界化学和机械的限制。我个人一直认为，业务应该定义软件，而不是反过来。
- en: The Bridge pattern isolates the `Bicycle` classes from being tightly coupled
    to an equally complicated model. There is little doubt that over time, the painting
    model and the bicycle model will continue to grow in complexity, but now they
    do so in isolation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式将 `Bicycle` 类与一个同样复杂的模型紧密耦合的情况隔离开来。毫无疑问，随着时间的推移，涂装模型和自行车模型将继续变得更加复杂，但现在它们是在隔离的情况下发展的。
- en: Let’s look at the code for the Bridge pattern. For this book’s example code,
    I’ll be leaving all the code we have written so far intact. In real life, I’d
    begrudgingly modify the `IBicycle` interface. For the sake of the book and continuity,
    I’ll be putting Kitty and Phoebe’s code into a slightly different format. Phoebe
    sternly objected, but the editor stepped in and she ultimately capitulated.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看桥接模式的代码。对于本书的示例代码，我将保留我们迄今为止所写的所有代码。在现实生活中，我会不情愿地修改 `IBicycle` 接口。为了本书的连贯性，我将把
    Kitty 和 Phoebe 的代码放入一个稍微不同的格式。Phoebe 强烈反对，但编辑介入后，她最终屈服了。
- en: 'I’ll start by making a new interface to use in place of `IBicycle`. All I’m
    going to do here is take out the offending `Color` property:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建一个新的接口来替代 `IBicycle`。在这里我所要做的就是移除那个令人讨厌的 `Color` 属性：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The bridge we’re building has two sides. The bicycle side is represented by
    this new `ISimplifiedBicycle` interface, and the implementation side is used to
    independently model a complex object that describes how the bicycles might be
    painted.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的桥梁有两个方面。自行车方面由这个新的 `ISimplifiedBicycle` 接口表示，而实现方面用于独立地建模一个复杂对象，该对象描述了自行车可能被涂装的方式。
- en: Since classes and interfaces describing a paint job will probably be used across
    several different projects, Kitty adds a new namespace to the `BumbleBikesLibrary`
    we saw her create in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063). She adds
    a new folder called `PaintableBicycle`. The rest of the code presented in this
    chapter can be found in the library project which is in `chapter-3/BumbleBikesLibrary/PaintableBicycle`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述涂装工作的类和接口可能会被用于多个不同的项目中，Kitty 为她在 [*第 3 章*](B18605_03.xhtml#_idTextAnchor063)
    中创建的 `BumbleBikesLibrary` 添加了一个新的命名空间。她添加了一个名为 `PaintableBicycle` 的新文件夹。本章中展示的其余代码可以在
    `chapter-3/BumbleBikesLibrary/PaintableBicycle` 中的库项目中找到。
- en: 'For the latter, Phoebe devised an interface she thinks can describe anything
    her robots can paint:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后者，Phoebe 设计了一个她认为可以描述任何她的机器人可以涂装的东西的接口：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Every paint job created in the system will have a marketable name, which is
    stored in the `Name` property. The paint system Kitty wants to use is based on
    the same CMYK color space used by traditional printing. She also intends to use
    a paint finish she calls `TopCoat`. Since this too is likely going to be reused
    later, it belongs in the library Kitty created in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063).
    You’ll find this in the book’s sample code in `chapter-3/BumbleBikesLibrary/PaintableBicycle`.
    The paint finish will make the bicycle’s paint job take on a beautiful glossy
    sheen and protect the paint from scratches and sun exposure. Here’s an interface
    that describes the paint finish:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中创建的每个涂装工作都将有一个可销售的名字，该名字存储在 `Name` 属性中。Kitty 想要使用的涂装系统基于传统印刷所使用的相同的 CMYK
    颜色空间。她还打算使用一种她称之为 `TopCoat` 的涂装效果。由于这也可能稍后会被重用，它属于 Kitty 在 [*第 3 章*](B18605_03.xhtml#_idTextAnchor063)
    中创建的库。你可以在本书的示例代码中的 `chapter-3/BumbleBikesLibrary/PaintableBicycle` 找到它。这种涂装效果会使自行车的涂装呈现出美丽的亮光光泽，并保护涂装免受划痕和阳光照射。下面是一个描述涂装效果的接口：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*“Hold up, Kitty!”* Phoebe exclaimed. *“Why are we using another enum? That
    was nothing but trouble last time!”*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*“等等，Kitty！”* 菲比大声说道。*“我们为什么要使用另一个枚举？上次那只是麻烦的开始！”*'
- en: 'Kitty defended her design decision by saying, “We were short-sighted thinking
    we could get away with one color per bicycle. But when it comes to primers and
    paint finishes, there are classifications for each that rarely ever change. The
    code for the primer is probably going to be reused, so Kitty puts the code in
    the library she created in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063). You
    can find it in `chapter-3/BumbleBikesLibrary/PaintableBicycle`. The `PaintTopCoatTypes`
    enum contains the same set that has been in use for several decades. The makers
    improve the chemistry in the products, but they never introduce anything revolutionary.
    The same goes for primer.” Kitty brought up her `Primer` interface:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty通过说，“我们短视地认为我们可以通过每辆自行车一种颜色来解决问题。但当涉及到底漆和油漆表面处理时，每种都有很少改变的分类。底漆的代码可能会被重用，所以Kitty把代码放在她创建的库中[*第3章*](B18605_03.xhtml#_idTextAnchor063)。你可以在
    `chapter-3/BumbleBikesLibrary/PaintableBicycle` 中找到它。`PaintTopCoatTypes` 枚举包含了几十年一直在使用的相同集合。制造商改进了产品的化学成分，但他们从未引入任何革命性的东西。底漆也是如此。”Kitty提出了她的
    `Primer` 接口：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Naturally, a good paint job starts with a good primer. To expand on Kitty’s
    point, these primers have been around for a long time. Kitty put more in the enum
    than she’d likely use just to be careful. The girls source a few they might use,
    but for the most part, the good old-fashioned gray primer used for automotive
    painting seems to work best. She has fields for the manufacturer’s `isLovVoc`,
    that tells her whether the paint is considered to be low in `false`, we’d want
    to be sure to wear a respirator around the painting equipment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，一个好的油漆工作从好的底漆开始。为了扩展Kitty的观点，这些底漆已经存在很长时间了。Kitty在枚举中添加了比她可能使用的更多的内容，只是为了谨慎起见。女孩们找到了一些可能会使用的底漆，但大部分情况下，用于汽车喷漆的古老灰色底漆似乎效果最好。她有制造商的
    `isLovVoc` 字段，这告诉她油漆是否被认为是低 `false`，我们希望在喷漆设备周围戴上呼吸器。
- en: The structure of the paint job model is taking shape. Compared to a simple color
    term, it is relatively complex. As you can see, the Bridge pattern truly helps
    us. The main objective of the Bridge pattern is to allow two complex object structures
    to be developed and maintained independently of one another. The bicycle models
    have gone through many interactions by name and have become more and more robust
    models. Now, we have this complex paint job model. The two need to go together,
    but a day could come when either the bicycle model or the paint model might undergo
    drastic changes. The bridge is, as with many of the patterns we’ve studied so
    far, insulating parts of our code from change while simultaneously making all
    of our code flexible and reusable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 油漆工作模型的结构正在形成。与简单的颜色术语相比，它相对复杂。正如你所见，桥接模式确实帮了我们。桥接模式的主要目标是允许两个复杂对象结构独立于彼此开发和维护。自行车模型通过名称进行了许多交互，并成为越来越健壮的模型。现在，我们有了这个复杂的油漆工作模型。这两个需要一起使用，但有一天，自行车模型或油漆模型可能需要进行剧烈的变化。桥接，就像我们迄今为止研究的大多数模式一样，隔离了代码的一部分，同时使所有代码灵活且可重用。
- en: 'To handle our use case for the Bridge pattern, I’ll make another interface
    that inherits from `ISimplifiedBicycle` called `IPaintableBicycle`. We’re doing
    it this way to maintain as much flexibility as we can:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们针对桥接模式的用例，我将创建另一个从 `ISimplifiedBicycle` 继承的接口，称为 `IPaintableBicycle`。我们这样做是为了尽可能保持最大的灵活性：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Kitty and Phoebe have four bicycle designs that need to implement this interface.
    It makes sense to set up an abstract class to implement the interface:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty和Phoebe有四种自行车设计需要实现这个接口。设置一个抽象类来实现这个接口是有意义的：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Build()` method requires an update as well. The `Bicycle` class has a
    line that prints the color of the bicycle. We still need to do that, but instead
    of deriving it from the enum, we’ll work with the name of the paint job:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build()` 方法也需要更新。`Bicycle` 类有一行打印自行车的颜色。我们仍然需要这样做，但不是从枚举中派生出来，我们将与油漆工作的名称一起工作：'
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We also need to apply the other parts of the paint job:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要应用油漆工作的其他部分：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The rest of the class can remain the same. You will find the full code in the
    chapter’s source code available on GitHub.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分可以保持不变。你可以在GitHub上找到该章节的完整代码。
- en: The new paint system exceeds the Kickstarter backers’ expectations. Not only
    can Bumble Bikes support custom colors for every bicycle but they can also support
    custom gradient paint jobs. This is a feature rarely seen in the bicycle industry
    outside of shops specializing in custom paint and assembly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 新的喷漆系统超出了Kickstarter支持者的预期。Bumble Bikes不仅能够支持每辆自行车的定制颜色，还能支持定制渐变喷漆工作。这在自行车行业中很少见，除了那些专门从事定制喷漆和组装的商店。
- en: The Bridge pattern can be implemented any time you have two or more class hierarchies
    that are complicated and need to be used together. At its core, the Bridge pattern
    is little more than composition. The reason it is recognized as a pattern is it
    becomes a thoughtful exercise in decoupling. It usually arises within the design
    phase. You start with a class and it gets more and more complex as you design
    it. Ideally, you find this growth in complexity when you are modeling the class,
    and you decouple it before it ever reaches code. In the real world, it comes up
    several iterations or even several years into the project, and you need to remember
    this has happened before. It will happen again. Eventually, it will happen to
    you. There is a solution, and that’s the heart and soul of software development
    patterns.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个或更多复杂且需要一起使用的类层次结构时，可以实施桥接模式。在核心上，桥接模式不过是组合。它之所以被认可为一个模式，是因为它成为了一种深思熟虑的解耦练习。它通常出现在设计阶段。你从一个类开始，随着设计的深入，它变得越来越复杂。理想情况下，当你建模这个类时，你会发现这种复杂性的增长，并在它变成代码之前将其解耦。在现实世界中，这种情况可能在项目进行了几次迭代甚至几年之后才会出现，你需要记住这种情况已经发生过。它还会再次发生。最终，它可能发生在你身上。有一个解决方案，那就是软件开发模式的核心和灵魂。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Kitty and Phoebe’s modeling of the bicycle products and the automated manufacturing
    process and apparatus is growing more sophisticated as the two learn and invent
    their new business. This is how it works, and from the outside looking in, I’d
    say they’re doing an amazing job. It is very normal for a software developer to
    be an expert at software design and development, but far less of an expert in
    their understanding of the business problems they are tasked to solve. Software
    projects are really an evolution involving the developer’s understanding of the
    business and the needs of their customers and stakeholders.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 奇蒂和菲比对自行车产品和自动化制造过程及设备的建模正变得越来越复杂，随着他们学习和发明新的业务，这种情况也在不断发生。这就是它的运作方式，从外面看进去，我认为他们做得非常出色。对于一个软件开发者来说，成为软件设计和开发的专家是很正常的，但在理解他们被分配去解决的问题的业务问题上，却远没有那么精通。软件项目实际上是一个涉及开发者对业务及其客户和利益相关者需求的理解的演变过程。
- en: 'In this chapter, we learned several structural patterns that allow us to continue
    to make our software more sophisticated yet simple to maintain and extend. You’ve
    also noticed a common theme: the basic tools of inheritance and composition afforded
    by an object-oriented programming language are not, by themselves, enough to build
    robust software. These structural patterns allow us to use the tools of composition
    and inheritance to maximum effect without boxing our designs into a quagmire of
    spaghetti-like object hierarchies.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了几个结构模式，这些模式允许我们继续使我们的软件更加复杂，同时保持简单易维护和扩展。你也注意到了一个共同的主题：面向对象编程语言提供的继承和组合的基本工具，本身并不足以构建健壮的软件。这些结构模式允许我们最大限度地利用组合和继承的工具，而不会将我们的设计困入像意大利面一样的对象层次结构的泥潭中。
- en: The Decorator pattern allows us to extend existing classes by decorating or
    wrapping new functionality around the original class. The decorators can stack
    as a Russian Matryoshka doll does, where one doll is nested inside another.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们通过装饰或围绕原始类添加新功能来扩展现有类。装饰器可以像俄罗斯套娃一样堆叠，其中一个娃娃嵌套在另一个娃娃里面。
- en: '![Figure 4.16: A Russian Matryoshka doll (each doll nests inside the larger
    one, the same way decorators wrap around base classes or stack on other decorators).
    ](img/B18605_Figure_4.161.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16：俄罗斯套娃（每个娃娃都嵌套在更大的一个里面，就像装饰器围绕基类或堆叠在其他装饰器周围一样）](img/B18605_Figure_4.161.jpg)'
- en: 'Figure 4.16: A Russian Matryoshka doll (each doll nests inside the larger one,
    the same way decorators wrap around base classes or stack on other decorators).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：俄罗斯套娃（每个娃娃都嵌套在更大的一个里面，就像装饰器围绕基类或堆叠在其他装饰器周围一样）。
- en: Phoebe mastered the Façade pattern, which allows us to abstract and insulate
    our software from complex dependencies. The pattern allows you to put a simple
    face on a complex API by uniformly exposing operations, even if they aren’t uniform
    under the covers. You can also use a façade to only expose the elements in a complex
    API or structure that are important to your implementations. If in the future,
    the third-party API changes significantly, you can replace the façade without
    having tightly coupled API calls sprinkled throughout your code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比掌握了外观模式（Façade pattern），该模式允许我们抽象并隔离我们的软件，使其免受复杂依赖的影响。该模式允许你通过统一暴露操作，即使它们在底层并不统一，也能将一个简单的界面放在复杂的API上。你也可以使用外观模式仅暴露复杂API或结构中对你实现重要的元素。如果将来第三方API发生重大变化，你可以在代码中无需紧密耦合的API调用的情况下替换外观。
- en: Kitty was able to model the bicycles’ group sets in a tree-like structure that
    allowed her to easily use recursion to find the cost and weight of the components
    together or in combination. Any time you need to deal with a tree, you should
    think, as Kitty did, of the Composite pattern.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂能够以树状结构对自行车的组集进行建模，这使她能够轻松地使用递归来找到组件的成本和重量，或者它们的组合。任何需要处理树的时候，你应该像凯蒂那样，考虑使用组合模式（Composite
    pattern）。
- en: With the cost and weight analysis problem solved, the girls teamed up to deal
    with the market’s demand for a wider color choice in the Bumble Bikes line-up.
    Initially, Kitty and Phoebe had decided to limit color selections to make the
    job of modeling the bicycles easier. However, their Kickstarter campaign indicated
    a high demand for more color choices. When Kitty tried to solve the problem using
    inheritance, she found herself faced with a huge number of subclasses. For each
    model of bicycle and each color, the number of classes grew out of control. Kitty
    solved the problem by modeling the two dimensions, the bicycle and the paint colors,
    independently using the Bridge pattern. They were even able to create a system
    capable of custom gradient paint jobs, to the delight of their Kickstarter backers.
    Having applied the Bridge pattern, the bicycle and the paint systems can grow
    independently from each other yet remain related through composition.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了成本和重量分析问题后，女孩们联手应对Bumble Bikes系列中市场对更广泛颜色选择的需求。最初，凯蒂和菲比决定限制颜色选择，以使自行车建模工作更容易。然而，他们的Kickstarter活动显示了对更多颜色选择的强烈需求。当凯蒂试图使用继承来解决问题时，她发现自己面临着大量子类。对于每种自行车型号和每种颜色，类的数量失控增长。凯蒂通过使用桥接模式（Bridge
    pattern）独立地对自行车和油漆颜色这两个维度进行建模，解决了这个问题。他们甚至能够创建一个能够进行定制渐变油漆工作的系统，这让他们在Kickstarter的支持者中非常受欢迎。应用了桥接模式后，自行车和油漆系统可以独立增长，同时通过组合保持相关。
- en: At this point, we’ve covered two of the three groups of patterns. Creational
    patterns helped us with object instantiation. Structural patterns helped us with
    new ways of thinking about how we build complicated objects with more sophistication
    than simply using inheritance and composition. The last group, covered in the
    next chapter, is a set of patterns to help you design “well-behaved” classes with
    behavioral patterns.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了三组模式中的两组。创建型模式帮助我们处理对象实例化。结构型模式帮助我们以比简单使用继承和组合更复杂的方式思考构建复杂对象的新方法。最后一组模式，将在下一章中介绍，是一组帮助您使用行为模式设计“表现良好”的类的模式。
- en: Questions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is the Decorator pattern sometimes referred to as a wrapper?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么装饰器模式有时被称为包装器？
- en: How can you use a decorator to extend a sealed class?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用装饰器来扩展一个密封的类？
- en: Which pattern is most effective at decoupling complex object structures in a
    way that allows them to mature separately?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模式最有效地解耦复杂对象结构，使它们能够分别成熟？
- en: When is the best time to consider using the Façade pattern?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时是考虑使用外观模式（Façade pattern）的最佳时机？
- en: Which pattern allows you to leverage recursion and polymorphism with a tree-like
    structure?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模式允许你利用递归和多态性以及树状结构？
- en: Have you ever run into a situation where you had to violate SOLID principles?
    Can you think of any way to avoid Phoebe and Kitty’s resolution when applying
    the Bridge pattern?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否遇到过必须违反SOLID原则的情况？你能想到任何避免在应用桥接模式时凯蒂和菲比解决方案的方法吗？
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Martin, Robert C., James Newkirk, and Robert S. Koss. *Agile software development:
    principles, patterns, and practices*. Vol. 2\. Upper Saddle River, NJ: Prentice
    Hall, 2003.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁，罗伯特·C·，詹姆斯·纽柯克，和罗伯特·S·科斯。*敏捷软件开发：原则、模式和惯例*。第2卷。新泽西州上萨德尔河：普伦蒂斯·霍尔，2003年。
- en: Martin, Robert C., and Micah Martin. *Agile principles, patterns, and practices
    in C# (Robert C. Martin)*. Prentice Hall PTR, 2006.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin, Robert C., 和 Micah Martin. 《敏捷原则、模式和C#实践（Robert C. Martin）》. Prentice
    Hall PTR, 2006.
- en: The companion website for this book is [https://www.csharppatterns.dev](https://www.csharppatterns.dev).
    Go check in and see what’s new.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书配套网站为 [https://www.csharppatterns.dev](https://www.csharppatterns.dev)。请访问查看最新动态。
