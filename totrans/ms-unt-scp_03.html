<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Singletons, Statics, GameObjects, and the World"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Singletons, Statics, GameObjects, and the World</h1></div></div></div><p>Every level or game world in Unity is represented by a scene, and a scene is a collection of game objects situated inside a Cartesian 3D coordinate system with <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span> axes. Units in a scene are measured in Unity units, and these correspond (for practical purposes) to meters. In order to script masterfully with Unity, it's critical to understand the anatomy of both scenes and objects and how interobject communication happens; that is, it's important to know how separate and independent objects in a scene can communicate with each other to make things happen as you expect. Consequently, this chapter focuses on the native Unity methods available to optimally search, reference, and access objects in a scene. It also focuses on additional concepts such as statics and singletons for the creation of objects that travel between scenes, retaining their data as they move. Of course, this chapter will not only consider these methods individually, but it'll try to appraise them in practical contexts, with performance and efficiency in mind.</p><div class="section" title="The GameObject"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec41"/>The GameObject</h1></div></div></div><p>The <code class="literal">GameObject</code> is, in many senses, the fundamental unit or entity inside a scene. It corresponds most naturally to what we'd call a <span class="emphasis"><em>thing</em></span> in the everyday sense. It doesn't really matter what kind of context-specific behaviors or things you'll actually need inside your own games, because in all<a id="id227" class="indexterm"/> cases, you'll need <code class="literal">GameObjects</code> to implement them. <code class="literal">GameObjects</code> don't need to be visible to the gamer; they can be, and often are, invisible. Sounds, colliders, and manager classes are some examples of invisible <code class="literal">GameObjects</code>. On the other hand, many <code class="literal">GameObjects</code> will be visible: meshes, animated meshes, sprites, and so on. In all cases, however, whether visible or invisible, the <code class="literal">GameObject</code> is instantiated inside a scene as a collection of related components. A <span class="strong"><strong>component</strong></span> is <a id="id228" class="indexterm"/>essentially a class derived from <code class="literal">MonoBehaviour</code>, and it can be attached to a <code class="literal">GameObject</code> in the scene to change its behavior. Every <code class="literal">GameObject</code> has at least one minimal component in common, and it's impossible to remove it, namely, the <a id="id229" class="indexterm"/>
<span class="strong"><strong>Transform</strong></span> component (or the RectTransform for GUI objects). This component keeps track of an object's position, rotation, and scale. For example, if you create a blank, empty game object in the scene by going to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu, as shown in the following screenshot, you would end up with a new game <a id="id230" class="indexterm"/>object in the scene, featuring only a Transform component. Thus, even a new and empty <code class="literal">GameObject</code> is not, strictly speaking, empty, but it's as empty as a <code class="literal">GameObject</code> ever gets. The object still needs a Transform component to maintain its physical location in a scene.</p><div class="mediaobject"><img src="graphics/0655OT_03_01.jpg" alt="The GameObject"/><div class="caption"><p>All GameObjects feature a Transform component</p></div></div><p>Of course, a <code class="literal">GameObject</code> can have many components, and the behavior of an object arises from the combination and interaction of its components. You can add more premade components to an object using the <span class="strong"><strong>Component</strong></span> menu, and you can add your own custom components by dragging-and-dropping your scripts onto an object.</p><div class="mediaobject"><img src="graphics/0655OT_03_02.jpg" alt="The GameObject"/><div class="caption"><p>Components are attached to GameObjects</p></div></div><p>So, <code class="literal">GameObjects</code> are composed of components. At a higher level, scenes are composed of a collection of <code class="literal">GameObjects</code> inside a single world space. Furthermore, objects themselves exist in an<a id="id231" class="indexterm"/> important relationship with each other, as defined by the scene hierarchy. Objects can be the children of others, who are in turn their parents (<code class="literal">transform.parent</code>). This relationship has important implications for how objects move and transform. In short, values for an object's Transform component will cascade downwards and be added to the transform of all its children. In this way, a child <code class="literal">GameObject</code> is always offset and transformed relative to its parent; the parent position is the origin of the child position. However, if an object has no parent, then it would be transformed away from the world origin at (0, 0, 0). The following screenshot shows the <span class="strong"><strong>Hierarchy</strong></span> panel:</p><div class="mediaobject"><img src="graphics/0655OT_03_03.jpg" alt="The GameObject"/><div class="caption"><p>GameObjects exist in a scene hierarchy that determines their transformations</p></div></div></div></div>
<div class="section" title="Component interactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec42"/>Component interactions</h1></div></div></div><p>We've seen the anatomy of a <code class="literal">GameObject</code> as a collection of components and nothing more. This raises logistical issues about how components should interact and communicate with <a id="id232" class="indexterm"/>each other. Each component is effectively implemented as a self-contained script file, separate from any other component, yet a component must often interact with others. Specifically, you'll often need to access variables and call functions on other components on the same <code class="literal">GameObject</code>, and you might even need to do this on every frame. This section explores such intercomponent communication.</p><p>One way to call functions on other components is to use <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code>, as shown in <a class="link" href="ch01.html" title="Chapter 1. Unity C# Refresher">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>. These functions are type agnostic. Specifically, they're functions we might call anywhere in the script to invoke methods by names on <span class="emphasis"><em>all</em></span> other components attached to the same object, regardless of their type. These functions don't care about the component type at all. This makes both <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> convenient to use. However, the problem with them is twofold. First, they're an all or nothing affair; we might call a function by name on all components or on none at all. We can't pick and choose which component the message is dispatched to, because it's always dispatched to them all. Second, both methods (<code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code>) rely internally on reflection, which can cause performance issues when used often, such as by calling these functions in <code class="literal">Update</code> events or, even worse, in <code class="literal">OnGUI</code> events. For these reasons, seek to use alternative methods wherever practically possible. Let's consider these in the following sections.</p><div class="section" title="GetComponent"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>GetComponent</h2></div></div></div><p>If you need direct access to a specific and single component on an object and you know its data type, try using<a id="id233" class="indexterm"/> <code class="literal">GetComponent</code> as shown in the following code sample 3-1. This function gives you access to the<a id="id234" class="indexterm"/> first component of a matching type attached to a <code class="literal">GameObject</code>. Once you get a reference to it, you can access the component like any regular object, setting and getting its public variables and invoking its methods:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------
04 public class MyCustomComponent : MonoBehaviour
05 {
06   //Reference to transform of object
07   private Transform ThisTransform = null;
08 //-----------------------------------------------------
09   // Use this for initialization
10   void Start ()
11   {
12     //Get cached reference to transform
13     ThisTransform = GetComponent&lt;Transform&gt;();
14   }
15 //-----------------------------------------------------
16   // Update is called once per frame
17   void Update ()
18   {
19     //Update position

20     if(ThisTransform !=null) {ThisTransform.localPosition += Time.deltaTime * 10.0f * ThisTransform.forward;}

21   }
22 //-----------------------------------------------------
23 }
24 //-----------------------------------------------------</pre></div><p>The following are the comments on the code sample 3-1:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 07 and 13</strong></span>: The variable <code class="literal">ThisTransform</code> is declared as private. This variable is assigned a reference to the Transform component attached to the <code class="literal">GameObject</code>, and it achieves this inside the <code class="literal">Start</code> event using the <code class="literal">GetComponent</code> function. In the case of accessing the Transform component specifically, we could also have used an inherited <code class="literal">transform</code> property, such as <code class="literal">ThisTransform= transform;</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 20</strong></span>: Here, the <code class="literal">ThisTransform</code> variable<a id="id235" class="indexterm"/> is used directly to set the <code class="literal">localPosition</code> of the <code class="literal">GameObject</code>. Again, for the Transform component specifically, we could also have used <code class="literal">transform.localPosition</code>. However, this <a id="id236" class="indexterm"/>approach internally invokes an extra function call, because the member <code class="literal">transform</code> is a C# property and not a standard variable. More on properties can be found in <a class="link" href="ch01.html" title="Chapter 1. Unity C# Refresher">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>. For this reason, using <code class="literal">GetComponent</code> inside a <code class="literal">Start</code> or <code class="literal">Awake</code> event to retrieve a component reference to a private class variable is typically one of the most efficient ways to access external components, especially if the component must be accessed regularly, such as inside an <code class="literal">Update</code> function.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>
<span class="strong"><strong>localPosition versus position</strong></span>
</p><p>The Transform<a id="id237" class="indexterm"/> component exposes two main position members: <code class="literal">position</code> and <code class="literal">localPosition</code>. Setting either of these will change an object's position in specific and distinct ways. The position member always defines an object's position in world space as a measure from the world origin. Setting this variable in script, therefore, might not correspond to the numbers you actually see for the Transform component in the Object Inspector when the object is selected. If your object is a child of another<a id="id238" class="indexterm"/> object that's not positioned to the world origin, for example, then Unity would offset the object's local position away from its parent, by however much is necessary, to position it at the world space location that is specified. The <code class="literal">localPosition</code> member, in contrast, corresponds directly to the <code class="literal">position</code> value shown for the Transform component in the Object Inspector. Specifically, it specifies the position of an object as a measured offset away from its parent location or else from the world origin if the object has no parent. In the latter case, both the <code class="literal">position</code> and <code class="literal">localPosition</code> members will be identical.</p><p>More information on the <a id="id239" class="indexterm"/>
<code class="literal">GetComponent</code> function can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html">http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html</a>.</p><p>You can also access the Unity documentation from the MonoDevelop <span class="strong"><strong>Help</strong></span> menu, by navigating to <span class="strong"><strong>Help</strong></span> | <span class="strong"><strong>Unity API Reference</strong></span>.</p></div></div></li></ul></div></div><div class="section" title="Getting multiple components"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Getting multiple components</h2></div></div></div><p>Occasionally, you'll want to retrieve multiple components in a list: sometimes, a list of all components and<a id="id240" class="indexterm"/> sometimes, a list matching only<a id="id241" class="indexterm"/> a specific type. You can get this using the <code class="literal">GetComponents</code> function. See the following code sample 3-2. As with the <code class="literal">GetComponent</code> function, it's good practice to call <code class="literal">GetComponents</code> during one-off events such as <code class="literal">Start</code> and <code class="literal">Awake</code> as opposed to frequent events such as <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------
04 public class MyCustomComponent : MonoBehaviour
05 {
06   //Reference to all components as array
07   private Component[] AllComponents = null;
08   //-----------------------------------------------------
09   // Use this for initialization
10   void Start ()
11   {
12     //Gets a list of all components attached to this object
13     AllComponents = GetComponents&lt;Component&gt;();
14
15     //Loops through each and list it to the console
16     foreach(Component C in AllComponents)
17     {
18       //Print to console
19       Debug.Log (C.ToString());
20     }
21   }
22 }
23 //-----------------------------------------------------</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>
<span class="strong"><strong>More on Components</strong></span>
</p><p>Unity offers additional variations on<a id="id242" class="indexterm"/> the <code class="literal">GetComponent</code> and <code class="literal">GetComponents</code> functions that facilitate interobject communication and not just communication between components in the same object. These functions include <code class="literal">GetComponentsInChildren</code> to retrieve an accumulative list of all components in all children and also <code class="literal">GetComponentsInParent</code> to retrieve all components in an object's parent.</p><p>More information on the <code class="literal">GetComponents</code> function can be found in the online Unity<a id="id243" class="indexterm"/> documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Component.GetComponents.html">http://docs.unity3d.com/ScriptReference/Component.GetComponents.html</a>.</p></div></div></div><div class="section" title="Components and messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Components and messages</h2></div></div></div><p>The <code class="literal">GetComponent</code> family <a id="id244" class="indexterm"/>of functions work well and should meet almost all your needs for intercomponent communication. They certainly perform better than either <code class="literal">SendMessage</code> or <code class="literal">BroadcastMessage</code> when used appropriately. Yet, there are situations where it'd be ideal if, given a <code class="literal">GameObject</code>, you could invoke a method with <code class="literal">SendMessage</code> on <span class="emphasis"><em>only one</em></span> component as opposed to all, without having to know anything about the component type in advance. Now, you could achieve this behavior to some extent using delegates<a id="id245" class="indexterm"/> and interfaces (covered in the next chapter). However, here we'll consider the <code class="literal">SendMessage</code> approach. One scenario where this would be especially useful is for the creation of extendable behaviors. For example, perhaps your game has many enemy types and you need to leave open the possibility of adding more, all of which could be implemented in different ways. Yet, despite their differences, all enemies will need to save their data to a persistent file when the game is saved. It'd then be useful for the enemy to handle an <code class="literal">OnSave</code> function, which will be implemented by a specific component. This is fine, but you want the<a id="id246" class="indexterm"/> <code class="literal">OnSave</code> function on that component alone to be called by the <code class="literal">SendMessage</code> system. You don't want the method invoked for other components on the object, in case they too handle a function <code class="literal">OnSave</code> that you don't want called inadvertently. In short, you can achieve this using the <code class="literal">Invoke</code> method. Consider the following code sample 3-3:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------
04 public class MyCustomComponent : MonoBehaviour
05 {
06   //Reference to component on which function must be called
07   <span class="strong"><strong>public MonoBehaviour Handler = null;</strong></span>
08
09   //-----------------------------------------------------
10   // Use this for initialization
11   void Start ()
12   {
13     //Call function immediately
14 <span class="strong"><strong>    Handler.Invoke("OnSave",0.0f);</strong></span>
15   }
16 }
17 //-----------------------------------------------------</pre></div><p>The following are the comments on the code sample 3-3:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 07</strong></span>: This class features a public reference variable <code class="literal">Handler</code>. Using this field, you can drag-and-drop any component via the Object Inspector into the <code class="literal">Handler</code> slot. This represents the component to which a message will be dispatched. Notice that its class type is <code class="literal">MonoBehaviour</code> or any class derived from this. This means type agnosticism is achieved and we don't need to know the object type in advance.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 14</strong></span>: The <code class="literal">Invoke</code> method of <code class="literal">MonoBehaviour</code> is called to run any method of matching name. The second floating point argument specifies the time in seconds, after which the function should be invoked. A time of 0 specifies immediate invoking.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>More information <a id="id247" class="indexterm"/>on the <code class="literal">Invoke</code> function can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html</a>.</p></div></div></li></ul></div></div></div>
<div class="section" title="GameObjects and the world"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec43"/>GameObjects and the world</h1></div></div></div><p>Another pivotal task in Unity involves searching for objects in the scene from script, especially if objects are instantiated at runtime. Tasks such as "get me the player object" and "get me all enemies in the scene" are important for many operations, from respawning enemies<a id="id248" class="indexterm"/> and power-ups to repositioning the player and checking collisions between objects. To retrieve references to specific <code class="literal">GameObjects</code>, Unity offers a set of functions associated with the <code class="literal">GameObject</code> class. These functions can be useful but expensive, so be sure to call them during one-off events, such as <code class="literal">Start</code> and <code class="literal">Awake</code>, wherever possible. Let's explore these further, in addition to other techniques and methods to work with found objects.</p><div class="section" title="Finding GameObjects"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Finding GameObjects</h2></div></div></div><p>Finding an object in the scene<a id="id249" class="indexterm"/> can be achieved through either the <code class="literal">GameObject.Find</code> or <code class="literal">GameObject.FindObjectWithTag</code> function. Of these two, the latter should almost always be preferred for performance reasons. However, let's consider <code class="literal">GameObject.Find</code> first. This function searches the scene for the first occurrence of an object with an exactly matching name (case-sensitive) and then returns that object. The name that's searched should match the object name as it appears in the <span class="strong"><strong>Hierarchy</strong></span> panel. Unfortunately, the function performs string comparisons to determine the match, so it's a slow and cumbersome option. Besides, it's only truly effective for objects guaranteed to have unique names, and many times, objects won't have. However, that said, <code class="literal">GameObject.Find</code> is still highly useful when objects are appropriately named:</p><div class="informalexample"><pre class="programlisting">//Find Object with the name of player
ObjPlayer = GameObject.Find ("Player");</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>
<span class="strong"><strong>GameObject Finding</strong></span>
</p><p>If you notice the <code class="literal">GameObject</code>, you would realize that the <code class="literal">Find</code> function is static. This means that you don't <a id="id250" class="indexterm"/>need an instantiation of any specific <code class="literal">GameObject</code> to call the function. You can call it directly from any source file via <code class="literal">GameObject.Find</code>. The concept of static and global scope is considered later in this chapter.</p><p>More information <a id="id251" class="indexterm"/>on the <code class="literal">GameObject.Find</code> function can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.Find.html">http://docs.unity3d.com/ScriptReference/GameObject.Find.html</a>.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<code class="literal">GameObject.Find</code> can be a slow function. For this reason, use it only inside one-fire events, such as <code class="literal">Awake</code> and <code class="literal">Start</code>.</p></div></div><p>A more effective search is<a id="id252" class="indexterm"/> by tag. Every object in the scene has a tag member that is assigned <span class="strong"><strong>Untagged</strong></span> by default. This member is a unique identifier that can mark a single object or multiple objects bringing them together into a collection. Generally, to search for objects by tag, you'll first need to explicitly assign an object with a tag. You can do this in script, using the <code class="literal">GameObject.tag</code> public member. However, you'll use the Unity Editor more commonly. You can assign a tag to a selected object from the Unity Editor by clicking the <span class="strong"><strong>Tag</strong></span> drop-down list in the Object Inspector and picking a tag. In addition, you can create new, custom tags by selecting the <span class="strong"><strong>Add Tag</strong></span> option. Common tags include <span class="strong"><strong>Player</strong></span>, <span class="strong"><strong>Enemy</strong></span>, <span class="strong"><strong>Weapon</strong></span>, <span class="strong"><strong>Bonus</strong></span>, <span class="strong"><strong>Prop</strong></span>, <span class="strong"><strong>Environment</strong></span>, <span class="strong"><strong>Light</strong></span>, <span class="strong"><strong>Sound</strong></span>, and <span class="strong"><strong>GameController</strong></span>, among others. Take a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_03_04.jpg" alt="Finding GameObjects"/><div class="caption"><p>Assigning a tag to an object</p></div></div><p>After one or more objects are assigned a tag in the scene, you can effectively search for objects by tag in code. The <a id="id253" class="indexterm"/>
<code class="literal">GameObject.FindGameObjectWithTag</code> function searches the scene for an object <a id="id254" class="indexterm"/>with a matching tag and returns the first occurrence. The <code class="literal">GameObject.FindObjectsWithTag</code> returns an array of all occurrences. See the following code sample 3-4 for an example. Note that although the <code class="literal">FindGameObjectsWithTag</code> function requires a string argument, Unity internally converts the string into a numerical form to increase the speed of tag comparisons:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//-----------------------------------------------------
public class ObjectFinder : MonoBehaviour
{
  //Tag name of objects to find
  public string TagName = "Enemy";
  //Array of found objects matching tag
  public GameObject[] FoundObjects;

  //-----------------------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Find objects of matching tag

    FoundObjects = GameObject.FindGameObjectsWithTag(TagName);

  }
}
//-----------------------------------------------------</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Sometimes, you'd like to assign multiple tags to a single object. Unfortunately, Unity doesn't support this behavior yet. However, you can work around the limitation by parenting <a id="id255" class="indexterm"/>empty game objects to your main object and assigning each of the children the tag you need. When searching for objects by tag, though, just remember to get a reference to the parent object, which is actually the object you need.</p></div></div></div><div class="section" title="Comparing objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Comparing objects</h2></div></div></div><p>The <code class="literal">GameObject</code> searching functions are helpful when searching scene-wide for specific objects, but there are times<a id="id256" class="indexterm"/> when you'll need to compare two objects that you've found already. Typically, you'll want compare the names or tags of two objects. You can achieve a tag comparison using the <code class="literal">CompareTag</code> function:</p><div class="informalexample"><pre class="programlisting">//Compares tag of this object with another Obj_Y
bool bMatch = gameObject.CompareTag(Obj_Y.tag);</pre></div><p>In addition, you'll sometimes want to compare two objects for equality to determine whether they're the same object and not simply whether they share the same tag. This is especially important when coding decision-making behaviors. For example, in determining whether an enemy character should fight or flee from the player during combat, it'd be helpful to ascertain whether the enemy has supporting units nearby to help him. To answer this, you can find all enemies in the scene with a tag search, as we saw earlier. However, the results will also include the enemy who made the call originally and who is now deciding what to do, so we'll want to exclude him from the results. Code sample 3-4 demonstrates how <code class="literal">GetInstanceID</code> can help us:</p><div class="informalexample"><pre class="programlisting">01 //Find objects of matching tag
02 FoundObjects = GameObject.FindGameObjectsWithTag(TagName);
03
04 //Search through all objects and exclude ourselves
05 foreach(GameObject O in FoundObjects)
06 {
07   //If two objects are the same
08   if(O.GetInstanceID() == gameObject.GetInstanceID())
09     continue; //Skip this iteration
10
11   //[...] Do stuff here
12 }</pre></div></div><div class="section" title="Getting the nearest object"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Getting the nearest object</h2></div></div></div><p>Given an array of <code class="literal">GameObjects</code>, perhaps returned from a search, how can you find the one nearest to you in the scene in terms of linear distance? The following code sample 3-5 demonstrates how you can<a id="id257" class="indexterm"/> find this object using the <code class="literal">Vector3.Distance</code> function to retrieve the shortest distance (in meters) between any two points in the scene:</p><div class="informalexample"><pre class="programlisting">//Returns the nearest game object
GameObject GetNearestGameObject(GameObject Source, GameObject[] DestObjects)
{
  //Assign first object
  GameObject Nearest = DestObjects[0];

  //Shortest distance
  float ShortestDistance = Vector3.Distance(Source.transform.position, DestObjects[0].transform.position);

  //Loop through all objects
  foreach(GameObject Obj in DestObjects)
  {
    //Calculate distance
    float Distance = Vector3.Distance(Source.transform.position, Obj.transform.position);
    //If this is shortest, then update
    if(Distance &lt; ShortestDistance)
    {
      //Is shortest, now update
      Nearest = Obj;
      ShortestDistance = Distance;
    }
  }

  //Return nearest
  return Nearest;
}</pre></div></div><div class="section" title="Finding any object of a specified type"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Finding any object of a specified type</h2></div></div></div><p>Sometimes, you just want<a id="id258" class="indexterm"/> a list of all the components of a specified type in the scene, regardless of which game objects they're actually attached to; these components include all enemies, all collectible objects, all transform components, all colliders, and so on. Achieving this from script is simple but expensive, as shown in the following code sample 3-6. Specifically, by calling the <code class="literal">Object.FindObjectsOfType</code> function, you can retrieve a complete list of all instances of a specified object in the scene, unless an object is deactivated. Due to the expense of this method, avoid calling<a id="id259" class="indexterm"/> it during frame-based events such as <code class="literal">Update</code>. Use the <code class="literal">Start</code> and <code class="literal">Awake</code> events, as well as infrequent functions instead:</p><div class="informalexample"><pre class="programlisting">void Start()
{
  //Get a list of all colliders in the scene
  Collider[] Cols = Object.FindObjectsOfType&lt;Collider&gt;();
}</pre></div></div><div class="section" title="Clearing a path between GameObjects"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Clearing a path between GameObjects</h2></div></div></div><p>Given any two <code class="literal">GameObjects</code> in the scene, such as the <span class="strong"><strong>Player</strong></span> and an <span class="strong"><strong>Enemy</strong></span> character, it's common to test for a clear path between them, that is, to test whether there are any colliders intersecting an<a id="id260" class="indexterm"/> imaginary line drawn between the two objects. This can be helpful in line-of-sight systems, as we'll see later, but also more generally for object culling, to determine AI functionality and others.</p><div class="mediaobject"><img src="graphics/0655OT_03_05.jpg" alt="Clearing a path between GameObjects"/><div class="caption"><p>Testing for a clear path between two GameObjects using Physics.LineCast</p></div></div><p>There are many ways to achieve this behavior. One way is to use the <code class="literal">Physics.LineCast</code> function, as shown in the following code sample 3-7:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //Determines if a clear line or path exists between two objects
04 public class ObjectPath : MonoBehaviour
05 {
06   //Reference to sample enemy object
07   public GameObject Enemy = null;
08
09   //Layer mask to limit line detection
10   public LayerMask LM;
11   //----------------------------------------------------
12   // Update is called once per frame
13   void Update ()
14   {
15     //Check if clear path between objects

16     if(!Physics.Linecast(transform.position, Enemy.transform.position, LM))

17     {
18       //There is clear path
19       Debug.Log ("Path clear");
20     }
21   }
22   //----------------------------------------------------
23   //Show helper debug line in viewport
24   void OnDrawGizmos()
25   {
26     Gizmos.DrawLine(transform.position, Enemy.transform.position);
27   }
28   //----------------------------------------------------
29 }</pre></div><p>The following are the<a id="id261" class="indexterm"/> comments on the code sample 3-7:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 07</strong></span>: This sample class should be attached to the <code class="literal">Player</code>; otherwise, another source object accepts a public member variable <code class="literal">Enemy</code> to whom a clear path should be tested.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 10</strong></span>: The <code class="literal">LayerMask</code> variable specifies a bitmask, indicating which layers in the scene the collision test applies to. More information on bitmasks can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Layers.html">http://docs.unity3d.com/Manual/Layers.html</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 16</strong></span>: The <code class="literal">Physics.Linecast</code> function is used to determine whether a clear and nonbroken path exists between two objects in the scene. Note that if the two objects themselves have colliders, such as <code class="literal">BoxColliders</code>, then these will be included in the collision detection; they will not be ignored. In other words, an <a id="id262" class="indexterm"/>object's own collider can affect the results of any <code class="literal">LineCast</code> calls. For this reason, use the <code class="literal">LayerMask</code> variable to include or exclude specific layers.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>A <code class="literal">Physics.LineCast</code> project is included in the book's companion files in the <code class="literal">Chapter03/LineCast</code> folder.</p></div></div></li></ul></div></div><div class="section" title="Accessing object hierarchies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Accessing object hierarchies</h2></div></div></div><p>The <span class="strong"><strong>Hierarchy</strong></span> panel in Unity offers a graphical illustration of the parent-child relationship that holds among all <code class="literal">GameObjects</code> in a scene. This relationship is important because child objects are<a id="id263" class="indexterm"/> contained by, and inherit, the transformations of their parents. However, being able to define and edit the hierarchical relationship in the editor is usually not enough. You'll frequently need to parent one object to another in code and also cycle through all children of a specified object to process data or invoke functionality on them. Let's first see how to parent objects. The following code sample 3-8 demonstrates how to attach one object X to another object Y as its child, through the Transform component:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//----------------------------------------------------
public class Parenter : MonoBehaviour
{
  //Reference to child object in scene
  private GameObject Child;
  //Reference to parent object in scene
  private GameObject Parent;
  //----------------------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Get parent and child objects
    Child = GameObject.Find("Child");
    Parent = GameObject.Find("Parent");

    //Now parent them
    Child.transform.parent = Parent.transform;
  }
  //----------------------------------------------------
}
//----------------------------------------------------</pre></div><p>Now, let's see how to cycle through all the child objects attached to a parent. Again, this is achieved through<a id="id264" class="indexterm"/> the Transform component, as shown in the following code sample 3-9:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class CycleChildren : MonoBehaviour
{
  //------------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Cycle though children of this object
    for(int i=0; i&lt;transform.childCount; i++)
    {
      //Print name of child to console
      Debug.Log (transform.GetChild(i).name);
    }
  }
  //------------------------------------------
}
//------------------------------------------</pre></div></div></div>
<div class="section" title="The world, time, and updates"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec44"/>The world, time, and updates</h1></div></div></div><p>A Unity scene represents a collection of finite <code class="literal">GameObjects</code> inside the same 3D space and that also share the same timeframe. Every game needs to establish a unified concept of time to achieve synchronized animation and change, because animation means change over time. In Unity, the<a id="id265" class="indexterm"/> <code class="literal">Time</code> class is available for reading and understanding time and its passing in script. Working with this class is therefore a critical skill for the creation of predictable and consistent motion in your games. More on this shortly.</p><p>Every game has a frame rate, which is defined in<a id="id266" class="indexterm"/> <span class="strong"><strong>frames per second</strong></span> (<span class="strong"><strong>FPS</strong></span>). This rate is viewable from the <span class="strong"><strong>Stats</strong></span> panel in the <span class="strong"><strong>Game</strong></span> tab. The FPS tells you how many times in 1 second Unity is able to loop or iterate through your game code to draw a new render from the cameras to the screen. Each iteration is called a <span class="strong"><strong>frame</strong></span>. The<a id="id267" class="indexterm"/> frame rate varies dramatically over time and across different computers. It's influenced by the power of your computer, other processes that might be running, and by how much content it needs to render in the current frame, among other factors. This means you can <a id="id268" class="indexterm"/>never rely on FPS being consistent over time or the same across different computers; there'll often be a different number of FPS. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_03_06.jpg" alt="The world, time, and updates"/><div class="caption"><p>FPS is important for the creation of time-based behavior and animations</p></div></div><p>To approximate the concept of a frame, Unity offers three class events that every <code class="literal">MonoBehaviour</code> class can implement to perform functionality that must continually update or change over time. These events have already been seen, but now, we'll consider them in more depth, specifically <code class="literal">Update</code>, <code class="literal">FixedUpdate</code> and <code class="literal">LateUpdate</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Update</code>: The<a id="id269" class="indexterm"/> <code class="literal">Update</code> event is called <span class="emphasis"><em>once</em></span> per frame for every active component on every active <code class="literal">GameObject</code> in the scene. If an object is deactivated by the <code class="literal">MonoBehaviour.SetActive</code> method, then <code class="literal">Update</code> events will not be called for that object until it is activated. In short, the <code class="literal">Update</code> event most accurately represents the concept of a frame in Unity, so it's useful for performing repetitive behaviors or functionality that must be updated and monitored over time, such as player input events, keyboard presses, and mouse clicks. Note that the order in which <code class="literal">Update</code> events are invoked across all components for each frame is not guaranteed; that is, you cannot be sure whether the <code class="literal">Update</code> function on object X will be called before that on object Y during any one frame.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FixedUpdate</code>: Like <code class="literal">Update</code>, this<a id="id270" class="indexterm"/> event is typically called multiple times per frame. However, its calling pattern is regular and normalized, with fixed time intervals between each call. The most common use of <code class="literal">FixedUpdate</code> is to work with Unity physics. If you need to update the velocity or properties of a Rigidbody component over time, then <code class="literal">FixedUpdate</code> rather than <code class="literal">Update</code> would be the place to do it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LateUpdate</code>: This is called on each frame, like <code class="literal">Update</code>. However, <code class="literal">LateUpdate</code> is <a id="id271" class="indexterm"/>always called after <code class="literal">Update</code> and <code class="literal">FixedUpdate</code>. This means that when <code class="literal">LateUpdate</code> is called, you can be sure that <code class="literal">Update</code> and <code class="literal">FixedUpdate</code> have already been called for every object on the current frame. This makes <code class="literal">LateUpdate</code> a useful place to update camera movement, especially third-person cameras, ensuring that the camera always follows objects at their latest positions on the current frame.</li></ul></div><p>The details of <code class="literal">Update</code>, <code class="literal">FixedUpdate</code> and <code class="literal">LateUpdate</code>, in combination with the concepts of time and FPS, have significant implications on how you should or should not code your games when creating motion over time. Specifically, two main guidelines emerge, and these are considered over the next two subsections.</p><div class="section" title="Rule #1 – frames are precious"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Rule #1 – frames are precious</h2></div></div></div><p>Frames should occur many<a id="id272" class="indexterm"/> times per second; if they don't, your game will look laggy and broken. On each frame, an <code class="literal">Update</code> event is called once for every active <code class="literal">MonoBehaviour</code> in the scene. This means the computational complexity (and performance) of your scenes on each frame<a id="id273" class="indexterm"/> depends, in large measure, on what you do inside <code class="literal">Update</code> events. More functionality demands more processing time and workload, either for the CPU or GPU. For large scenes with many objects and components, it would be easy then for things to get out of hand if you don't reduce the workload inside <code class="literal">Update</code> functions by careful code planning. It's important, therefore, to think of <code class="literal">Update</code> events or any regularly called frame-based events as precious. In short, you should only put code inside them when you really need to, such as to read player input or observe cursor movement. It's helpful to start thinking of event-driven programming, as this can help you seriously reduce the workload inserted inside <code class="literal">Update</code> functions. The next chapter considers event-driven programming and event systems.</p></div><div class="section" title="Rule #2 – motion must be relative to time"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Rule #2 – motion must be relative to time</h2></div></div></div><p>As you cannot guarantee<a id="id274" class="indexterm"/> the frequency of frames (frame rate differs over time and across computers), then you need to code motion and change very carefully to achieve a consistent experience for the gamer. Consider the simple case of moving a cube object in the scene smoothly over time. One way (a bad way) to create<a id="id275" class="indexterm"/> motion will be as shown in the following code sample 3-10:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour
{
  //Amount to move cube per frame
  public float AmountToMove = 1.0f;

  // Update is called once per frame
  void Update ()
  {
    //Move cube along x axis
    transform.localPosition += new Vector3(AmountToMove,0,0);
  }
}</pre></div><p>This code is effective insofar as it will move the attached object by the variable <code class="literal">AmountToMove</code> on each frame. The problem is that it's frame-rate dependent. Now, because frames are inconsistent over time and across computers, each user will ultimately receive a different experience; specifically, they'll see the cube moving at different speeds. This is bad <a id="id276" class="indexterm"/>because we simply cannot predict how the game will run for any specific user. To fix this, we need to map motion to time as opposed to frames. Frames are variable, but time is constant; one second is exactly that. To achieve this, we can use the <code class="literal">deltaTime</code> variable, which is part of the <code class="literal">Time</code> class. See the following code sample 3-11. This is an amended version of sample 3-10.</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour
{
  //Speed of cube
  public float Speed = 1.0f;

  // Update is called once per frame
  void Update ()
  {
    //Move cube along forward direction by speed
<span class="strong"><strong>    transform.localPosition += transform.forward * Speed * Time.deltaTime;</strong></span>
  }
}</pre></div><p>The <code class="literal">deltaTime</code> variable is a floating-point value and always expresses how much time, in seconds, has elapsed since<a id="id277" class="indexterm"/> the previous <code class="literal">Update</code> function was called. A value of 0.5, for example, means half a second has elapsed since the previous frame and so on. This is useful because <code class="literal">deltaTime</code> can act as a multiplier. By multiplying a speed variable by <code class="literal">deltaTime</code> on each frame, we can know how far an object should move because <span class="emphasis"><em>distance = speed x time</em></span>. Thus, <code class="literal">deltaTime</code> gives us frame-rate independence for object motion.</p></div></div>
<div class="section" title="Immortal objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec45"/>Immortal objects</h1></div></div></div><p>By default, Unity regards every object as existing within the self-enclosed time and space of a scene. The difference between scenes is like the difference between separate universes. Consequently, objects don't survive outside the scene to which they belong; this means that they die whenever<a id="id278" class="indexterm"/> the active scene changes. This is typically how you want objects to behave, because scenes are usually very different and separate from one another. However, even so, there will be objects that you don't want destroyed. There will be objects that you need <span class="emphasis"><em>carried over</em></span> between scenes, such as the <span class="strong"><strong>Player</strong></span> character, a high-score system, or a <code class="literal">GameManager</code> class. These are normally high-order objects whose existence shouldn't be limited to specific scenes; they should rather span or arc across multiple scenes. You can create object <a id="id279" class="indexterm"/>persistence easily using the <code class="literal">DontDestroyOnLoad</code> function, but it has important consequences worth considering. Take a look at the following code sample 3-12:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//-------------------------------------------
//This object will survive scene changes
public class PersistentObj : MonoBehaviour
{
  //-------------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Make this object survive
<span class="strong"><strong>    DontDestroyOnLoad(gameObject);</strong></span>
  }
}
//-------------------------------------------</pre></div><p>Object persistence between scenes is important, but <span class="emphasis"><em>travelling objects</em></span> take their baggage with them as they move between scenes. This means any and all child objects will survive with the persistent object as well as any assets or resources it uses, such as meshes, textures, sounds, and others. This is not a problem per se, but it is important to be aware of it. For this reason, many persistent objects are created light, that is, as empty game objects with no children, featuring only the basic component makeup they need to work properly. This ensures that only the essential, critical data survives between scene changes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>
<span class="strong"><strong>Scene Changing</strong></span>
</p><p>To change<a id="id280" class="indexterm"/> the active scene in Unity, use the <code class="literal">Application.LoadLevel</code> function. There are variations on this, including <code class="literal">LoadLevelAsync</code>, <code class="literal">LoadLevelAdditive</code>, and <code class="literal">LoadLevelAdditiveAsync</code>. More information <a id="id281" class="indexterm"/>on the level-loading functions can<a id="id282" class="indexterm"/> be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Application.html">http://docs.unity3d.com/ScriptReference/Application.html</a>.</p></div></div><p>As we saw earlier, the <code class="literal">DontDestroyOnLoad</code> function is called on an existing object in the active scene and prevents that object from being destroyed on future scene changes. From this, however, an issue sometimes arises concerning object duplication. Specifically, if you later reload or return to the original scene in which the persistent object first existed, then a <a id="id283" class="indexterm"/>persistent duplicate of the object is made, namely, the persistent original that came with you from the previous scene and a newer instantiation of the object created for the newly entered instance of the scene. This problem is, of course, magnified for each occasion you re-enter the scene, as each time a new duplicate will be made. Such duplication is usually not what you want. You typically want only one instance of the object to exist at any one time: one player, one game manager, or one high-score board. To achieve this, you'll need to create a singleton object, as explained in the next section.</p></div>
<div class="section" title="Understanding singleton objects and statics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec46"/>Understanding singleton objects and statics</h1></div></div></div><p>Some classes are<a id="id284" class="indexterm"/> fundamentally different from others in the way they should be instantiated. Most classes define a template for a collection of properties and behaviors that might be<a id="id285" class="indexterm"/> instantiated many times in a scene as <code class="literal">GameObjects</code>. An enemy class can be used to instantiate many enemy objects, a power-up class for many power-up objects, and so on. However, some classes such as <code class="literal">GameManager</code>, <code class="literal">HighScoreManager</code>, <code class="literal">AudioManager</code>, or <code class="literal">SaveGameManager</code> are intended to exist as a lone entity, one that consolidates a unified set of behaviors. In short, there should only ever be one instance of the class at any one time and never more than one. To have more than one instance would either be nonsensical or damage the object's authority and usefulness in some way. These kinds of objects are known as singletons. Singletons are often persistent objects that survive across scenes, though they need not be. The only essential ingredient in a singleton (which makes it what it is) is that there cannot be more than one instance of the class in memory at any one time. Let's now create a singleton object in the context of making a sample <code class="literal">GameManager</code> class.</p><p>Practically, every game has a <code class="literal">GameManager</code> or <code class="literal">GameController</code> class; and these are almost always singleton objects that persist. The <code class="literal">GameManager</code> is essentially responsible for all high-level functionality in a game. It must determine whether a game is paused, whether the win condition has been satisfied, and have a reliable way of knowing what's happening in the game at any one time, among others. Consider the sample beginnings of a <code class="literal">GameManager</code> in the following code sample 3-13:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//-----------------------------------------
//Sample Game Manager class
public class GameManager : MonoBehaviour
{
  //-----------------------------------------
  //High score
  public int HighScore = 0;

  //Is game paused
  public bool IsPaused = false;

  //Is player input allowed
  public bool InputAllowed = true;
  //-----------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Make game manager persistent
    DontDestroyOnLoad(gameObject);
  }
  //-----------------------------------------
}
//-----------------------------------------</pre></div><p>This object will<a id="id286" class="indexterm"/> persist across scenes, but how can it (or any class like it) become a singleton<a id="id287" class="indexterm"/> object? The following code sample 3-14 demonstrates how:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------
04 //Sample Game Manager class - Singleton Object
05 public class GameManager : MonoBehaviour
06 {
07   //-----------------------------------------
08   //C# Property to get access to singleton instance
09   //Read only - only has get accessor
10 <span class="strong"><strong>  public static GameManager Instance</strong></span>
11   {
12     //return reference to private instance
13 <span class="strong"><strong>    get</strong></span>
14     {
15       return instance;
16     }
17   }
18
19   //-----------------------------------------
20 <span class="strong"><strong>  private static GameManager instance = null;</strong></span>
21   //-----------------------------------------
22   //High score
23   public int HighScore = 0;
24
25   //Is game paused
26   public bool IsPaused = false;
27
28   //Is player input allowed
29   public bool InputAllowed = true;
30   //-----------------------------------------
31   // Use this for initialization
32   void Awake ()
33   {
34     //Check if existing instance of class exists in scene
35     //If so, then destroy this instance
36 <span class="strong"><strong>    if(instance)</strong></span>
37 <span class="strong"><strong>    {</strong></span>
38 <span class="strong"><strong>      DestroyImmediate(gameObject);</strong></span>
39 <span class="strong"><strong>      return;</strong></span>
40 <span class="strong"><strong>    }</strong></span>
41
42 <span class="strong"><strong>    //Make this active and only instance</strong></span>
43 <span class="strong"><strong>    instance = this;</strong></span>
44
45     //Make game manager persistent
46     DontDestroyOnLoad(gameObject);
47   }
48   //-----------------------------------------
49 }
50 //-----------------------------------------</pre></div><p>The following are the<a id="id288" class="indexterm"/>  comments on the code sample 3-14:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 10-20</strong></span>: A private member <code class="literal">instance</code> is added to the <code class="literal">Manager</code> class, which is declared as <code class="literal">static</code>. This means the variable is shared across all instances of the class if there are multiple instances, as opposed to being a variable whose value is specific to each instance. This allows each new instance, when created, to <a id="id289" class="indexterm"/>determine whether there is any existing instance of the class in memory. This variable is made publically accessible too via the <code class="literal">Instance</code> property, which only has a <code class="literal">get</code> member to make it read-only.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 36-43</strong></span>: Here, in the <code class="literal">Awake</code> event (called at object creation), the instance variable is checked to see whether any valid instance of the class exists in the current scene<a id="id290" class="indexterm"/> already. If it does, then the current object is deleted, because only one instance of this class is allowed and already exists. This means the <code class="literal">GameManager</code> will persist across scene changes, and there will always be only<a id="id291" class="indexterm"/>  one original instance of the object in the scene.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>
<span class="strong"><strong>Awake versus Start</strong></span>
</p><p>The <code class="literal">GameManager</code> class uses the <code class="literal">Awake</code> function, as opposed to <code class="literal">Start</code>, in code sample 3-12. The difference between <code class="literal">Start</code> and <code class="literal">Awake</code> is as follows:</p><p>
<code class="literal">Awake</code> is always called before <code class="literal">Start</code>.</p><p>
<code class="literal">Awake</code> is always called at object creation. <code class="literal">Start</code> is called on the first frame in which the <code class="literal">GameObject</code> becomes active. If a <code class="literal">GameObject</code> starts the scene deactivated, then <code class="literal">Start</code>
<a id="id292" class="indexterm"/> will not be called until the object is activated. For objects that are activated by default, <code class="literal">Start</code> is called at the beginning of the scene, after the <code class="literal">Awake</code> event.</p><p>If you need to cache <a id="id293" class="indexterm"/>component references into local variables of a class, such as the Transform component in <code class="literal">ThisTransform</code>, then use the <code class="literal">Awake</code> event rather than <code class="literal">Start</code>. During the <code class="literal">Start</code> event, the assumption should be that all local references to objects are already valid.</p></div></div><p>The great benefit of having a global, static <code class="literal">Instance</code> property for <code class="literal">GameManager</code> is that it becomes instantly and directly accessible to any other script file, without the need for any local variables or object references. This means every class has instant access to all <code class="literal">GameManager</code> properties and can call upon high-order game functionality. For example, to set the game score variable on the <code class="literal">GameManager</code> from a different class, the following code sample 3-15 can be used:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//-------------------------------------------
public class ScoreSetter : MonoBehaviour
{
  //-------------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Set score on GameManager
    GameManager.Instance.HighScore = 100;
  }
  //-------------------------------------------
}
//-------------------------------------------</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>More<a id="id294" class="indexterm"/> information on<a id="id295" class="indexterm"/> singleton objects can be found online at <a class="ulink" href="http://unitypatterns.com/singletons/">http://unitypatterns.com/singletons/</a>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec47"/>Summary</h1></div></div></div><p>This chapter considered <code class="literal">GameObjects</code>, scenes, and components, as well as their general usage throughout scenes. These issues might superficially seem simple, but understanding their usage and being able to employ them to manage objects is a powerful skill that's required in almost all Unity game development projects. Specifically, we've seen the <code class="literal">GameObject</code>, a collection of components that interact to produce a unified behavior. The Transform component is especially important. We also looked at scenes. A scene is a single time and space inside which <code class="literal">GameObjects</code> exist. Typically, a scene is a self-enclosed entity that prevents any objects from existing outside it. Further, every scene works through a concept of time that makes change and animation possible. Time can be measured through <code class="literal">deltaTime</code>, which acts like a multiplier and allows us to achieve frame-rate-independent motion. Finally, we explored the singleton design pattern, which uses static members to define classes that, in practice, can only have one instantiation active in memory at any one time. In the next chapter, we'll move on to event-driven programming.</p></div></body></html>