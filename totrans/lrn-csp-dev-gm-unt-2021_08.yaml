- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Scripting Game Mechanics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏机制脚本化
- en: In the last chapter, we focused on using code to move the player and camera,
    with a trip into Unity physics on the side. However, controlling a playable character
    isn't enough to make a compelling game; in fact, it's probably the one area that
    remains fairly constant across different titles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专注于使用代码来移动玩家和摄像机，并在Unity物理方面进行了一次探索。然而，仅控制可玩角色还不足以制作出引人入胜的游戏；实际上，这可能是不同游戏标题中相对保持不变的一个领域。
- en: A game's unique spark comes from its core mechanics, and the feeling of power
    and agency those mechanics give to the players. Without fun and engrossing ways
    to affect the virtual environment you've created, your game doesn't stand a chance
    of repeat play, to say nothing of fun. As we venture into implementing the game's
    mechanics, we'll also be upgrading our knowledge of C# and its intermediate-level
    features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一款游戏独特的火花来自于其核心机制，以及这些机制给玩家带来的力量感和自主感。如果没有有趣且引人入胜的方式来影响您所创造的虚拟环境，您的游戏就不太可能被重复游玩，更不用说有趣了。当我们着手实现游戏机制时，我们也会提升我们对C#及其中级特性的了解。
- en: 'This chapter will build on the *Hero Born* prototype by focusing on individually
    implemented game mechanics, as well as the basics of system design and **user
    interfaces** (**UIs**). You''ll be diving into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将基于《英雄降世》原型，重点关注单独实现的游戏机制，以及系统设计和**用户界面**（**UI**）的基础知识。您将深入研究以下主题：
- en: Adding jumps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加跳跃
- en: Shooting projectiles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击弹丸
- en: Creating a game manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏管理器
- en: Creating a GUI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GUI
- en: Adding jumps
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加跳跃
- en: Remember from the last chapter that Rigidbody components add simulated real-world
    physics to GameObjects, and Collider components interact with each other using
    Rigidbody objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 记住上一章的内容，Rigidbody组件为GameObject添加了模拟的真实世界物理，而Collider组件通过Rigidbody对象相互交互。
- en: Another great thing that we didn't discuss in the previous chapter about using
    a Rigidbody component to control player movement is that we can easily add in
    different mechanics that rely on applied force, such as jumping. In this section,
    we'll get our player jumping and write our first utility function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们没有讨论的另一件关于使用Rigidbody组件来控制玩家移动的伟大事情是，我们可以轻松地添加依赖于施加力的不同机制，例如跳跃。在本节中，我们将让玩家跳跃并编写我们的第一个实用函数。
- en: A utility function is a class method that performs some kind of grunt work so
    that we don't clutter up gameplay code—for instance, wanting to check whether
    the player capsule is touching the ground to jump.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实用函数是一个类方法，它执行某种类型的粗活，以便我们不会使游戏代码变得杂乱无章——例如，想要检查玩家胶囊是否接触地面以便跳跃。
- en: Before that, you'll need to get acquainted with a new data type called enumerations,
    which you'll do in the following section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，您需要熟悉一种新的数据类型，即枚举类型，您将在下一节中进行学习。
- en: Introducing enumerations
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍枚举
- en: By definition, an enumeration type is a set, or collection, of named constants
    that belong to the same variable. These are useful when you want a collection
    of different values, but with the added benefit of them all being of the same
    parent type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，枚举类型是一个集合或集合，其中包含属于同一变量的命名常量。当您想要一组不同的值，但同时又希望它们都属于同一父类型时，这些类型非常有用。
- en: 'It''s easier to show rather than tell with enumerations, so let''s take a look
    at their syntax in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与其说，不如用枚举来展示，让我们看看以下代码片段中的语法：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s break down how this works, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解其工作原理：
- en: The `enum` keyword declares the type followed by the variable name.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum`关键字声明了类型，后跟变量名。'
- en: The different values an enum can have are written inside curly brackets, separated
    by a comma (except for the last item).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举可以具有的不同值写在花括号内，用逗号分隔（最后一项除外）。
- en: The `enum` has to end with a semicolon, just like all other data types we've
    worked with.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum`关键字必须以分号结尾，就像我们之前使用过的所有其他数据类型一样。'
- en: In this case, we're declaring a variable called `PlayerAction`, of type `enum`,
    which can be set to one of three values—`Attack`, `Defend`, or `Flee`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们声明了一个名为`PlayerAction`的变量，其类型为`enum`，可以设置为三个值之一——`攻击`、`防御`或`逃跑`。
- en: 'To declare an enumeration variable, we use the following syntax:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明枚举变量，我们使用以下语法：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, we can break this down, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以按以下方式分解：
- en: The type is set as `PlayerAction`, since our enumeration is just like any other
    type, like a string or integer.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型设置为`PlayerAction`，因为我们的枚举类型就像字符串或整数等其他类型一样。
- en: The variable is named `currentAction` and set equal to a `PlayerAction` value.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名为 `currentAction`，并设置为 `PlayerAction` 的一个值。
- en: Each enum constant can be accessed using dot notation.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个枚举常量都可以使用点符号访问。
- en: Our c`urrentAction` variable is now set to `Defend`, but it can be changed to
    `Attack` or `Flee` at any time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的 `currentAction` 变量现在设置为 `Defend`，但它可以随时更改为 `Attack` 或 `Flee`。
- en: Enumerations may look simple at first glance, but they are extremely powerful
    in the right situations. One of their most useful features is the ability to store
    underlying types, which is the next subject you'll be jumping into.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在第一眼看起来可能很简单，但在适当的情况下它们非常强大。它们最有用的特性之一是能够存储底层类型，这是你将要跳入的下一个主题。
- en: Underlying types
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 底层类型
- en: Enums come with an *underlying type*, meaning that each constant inside the
    curly brackets has an associated value. The default underlying type is `int` and
    starts at 0, just like arrays, with each sequential constant getting the next
    highest number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举带有底层类型，这意味着花括号内的每个常量都有一个关联的值。默认的底层类型是 `int`，从 `0` 开始，就像数组一样，每个连续的常量都会得到下一个最高的数字。
- en: Not all types are created equal—underlying types for enumerations are limited
    to `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`. These
    are called integral types, which are used to specify the size of numeric values
    that a variable can store.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型都是相同的——枚举的底层类型仅限于 `byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`
    和 `ulong`。这些被称为整型，用于指定变量可以存储的数值的大小。
- en: 'This is a bit advanced for this book, but you''ll be using `int` in most cases.
    More information on these types can be found here: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于本书来说有点高级，但你将在大多数情况下使用 `int`。有关这些类型的信息，请在此处查找：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)。
- en: 'For example, our `PlayerAction` enumeration values right now are listed as
    follows, even though they aren''t explicitly written out:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的 `PlayerAction` 枚举值目前如下所示，即使它们并没有明确写出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There''s no rule that says underlying values need to start at `0`; in fact,
    all you have to do is specify the first value and then C# increments the rest
    of the values for us, as illustrated in the following code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规则说底层值必须从 `0` 开始；实际上，你只需要指定第一个值，然后 C# 会为我们自动递增其余的值，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, `Defend` equals `6`, and `Flee` equals `7` automatically.
    However, if we wanted the `PlayerAction` enum to hold non-sequential values, we
    could explicitly add them in, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Defend` 等于 `6`，而 `Flee` 自动等于 `7`。然而，如果我们想让 `PlayerAction` 枚举持有非连续的值，我们可以显式地添加它们，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can even change the underlying type of `PlayerAction` to any of the approved
    types by adding a colon after the enum name, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过在枚举名称后添加冒号来将 `PlayerAction` 的底层类型更改为任何批准的类型，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Retrieving an enum''s underlying type takes an explicit conversion, but we''ve
    already covered those, so the following syntax shouldn''t be a surprise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 获取枚举的底层类型需要一个显式的转换，但我们已经讨论过这些，所以下面的语法不应该让你感到惊讶：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since `CurrentAction` is set to `Attack`, `ActionCost` would be `10` in the
    above example code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例代码中，由于 `CurrentAction` 被设置为 `Attack`，`ActionCost` 将是 `10`。
- en: Enumerations are extremely powerful tools in your programming arsenal. Your
    next challenge is to use your knowledge of enumerations to gather more specific
    user input from the keyboard.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是编程工具箱中非常强大的工具。你的下一个挑战是利用你对枚举的了解，从键盘获取更具体的用户输入。
- en: 'Now that we have a basic grasp of enumeration types, we can capture keyboard
    input using the `KeyCode` enum. Update the `PlayerBehavior` script with the following
    highlighted code, save it, and hit play:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对枚举类型有了基本的了解，我们可以使用 `KeyCode` 枚举来捕获键盘输入。更新 `PlayerBehavior` 脚本，如下所示的高亮代码，保存它，然后播放：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down this code, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解这段代码：
- en: First, we create two new variables—a public variable to hold the amount of applied
    jump force we want and a private boolean to check if our player should be jumping.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建了两个新的变量——一个公共变量用于存储我们想要施加的跳跃力的大小，一个私有布尔变量用于检查我们的玩家是否应该跳跃。
- en: We set the value of `_isJumping` to the `Input.GetKeyDown()` method, which returns
    a `bool` value depending on whether a specified key is pressed.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `_isJumping` 的值设置为 `Input.GetKeyDown()` 方法，该方法返回一个 `bool` 类型的值，取决于指定的键是否被按下。
- en: We use the `|=` operator to set `_isJumping`, which is the logical `or` condition.
    This operator makes sure that we don't have consecutive input checks override
    each other when the player is jumping.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`|=`运算符来设置`_isJumping`，这是一个逻辑“或”条件。这个运算符确保当玩家跳跃时，连续的输入检查不会相互覆盖。
- en: The method accepts a key parameter as either a `string` or a `KeyCode`, which
    is an enumeration type. We specify that we want to check for `KeyCode.Space`.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法接受一个键参数，可以是`string`或`KeyCode`，它也是一个枚举类型。我们指定我们想要检查`KeyCode.Space`。
- en: Checking for inputs in `FixedUpdate` can sometimes lead to input loss or even
    double inputs because it doesn't run once per frame. This is why we're checking
    for inputs in `Update` and then applying force or setting the velocity in `FixedUpdate`.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`FixedUpdate`中检查输入有时会导致输入丢失甚至双重输入，因为它不是每帧运行一次。这就是为什么我们在`Update`中检查输入，然后在`FixedUpdate`中应用力或设置速度的原因。
- en: We use an `if` statement to check if `_isJumping` is true, and trigger the jump
    mechanic if it is.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`if`语句来检查`_isJumping`是否为真，如果是，则触发跳跃机制。
- en: Since we already have the Rigidbody component stored, we can pass the `Vector3`
    and `ForceMode` parameters to `RigidBody.AddForce()` and make the player jump.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将Rigidbody组件存储起来，我们可以将`Vector3`和`ForceMode`参数传递给`RigidBody.AddForce()`，从而使玩家跳跃。
- en: We specify that the vector (or applied force) should be in the `up` direction,
    multiplied by `JumpVelocity`.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定向量（或施加的力）应在`up`方向上，乘以`JumpVelocity`。
- en: The `ForceMode` parameter determines how the force is applied and is also an
    enumeration type. `Impulse` delivers an instant force to an object while taking
    its mass into account, which is perfect for a jump mechanic.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForceMode`参数决定了力的应用方式，它也是一个枚举类型。`Impulse`在考虑物体的质量的同时向物体施加即时力，这对于跳跃机制来说非常完美。'
- en: 'Other `ForceMode` choices can be useful in different situations, all of which
    are detailed here: [https://docs.unity3d.com/ScriptReference/ForceMode.html](https://docs.unity3d.com/ScriptReference/ForceMode.html).'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他`ForceMode`选择在不同的场景中可能很有用，所有这些都在这里详细说明：[https://docs.unity3d.com/ScriptReference/ForceMode.html](https://docs.unity3d.com/ScriptReference/ForceMode.html)。
- en: At the end of every `FixedUpdate` frame, we reset `_isJumping` to false so the
    input check knows a complete jump and the landing cycle has been completed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个`FixedUpdate`帧的末尾，我们将`_isJumping`重置为false，这样输入检查就知道完整的跳跃和着陆周期已经完成。
- en: If you play the game now, you'll be able to move around and jump when you hit
    the spacebar. However, the mechanic allows you to keep jumping indefinitely, which
    isn't what we want. We'll work on limiting our jump mechanic to one at a time
    in the next section, using something called a layer mask.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你将能够移动并在按下空格键时跳跃。然而，这个机制允许你无限期地跳跃，这不是我们想要的。在下一节中，我们将通过使用所谓的层掩码来限制我们的跳跃机制，每次只能跳跃一次。
- en: Working with layer masks
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用层掩码
- en: Think of layer masks as invisible groups that a GameObject can belong to, used
    by the physics system to determine anything from navigation to intersecting collider
    components. While more advanced uses of layer masks are outside the scope of this
    book, we'll create and use one to perform a simple check—whether the player capsule
    is touching the ground, in order to limit the player to one jump at a time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将层掩码想象成GameObject可以属于的无形组，由物理系统用来确定从导航到相交的碰撞组件等任何事情。虽然层掩码的更高级用法超出了本书的范围，但我们将创建并使用一个来执行简单的检查——检查玩家胶囊是否接触地面，以便限制玩家每次只能跳跃一次。
- en: 'Before we can check that the player capsule is touching the ground, we need
    to add all the environment objects in our level to a custom layer mask. This will
    let us perform the actual collision calculation with the Capsule Collider component
    that''s already attached to the player. Proceed as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够检查玩家胶囊是否接触地面之前，我们需要将我们关卡中的所有环境对象添加到自定义层掩码中。这将使我们能够使用已经附加到玩家上的Capsule Collider组件执行实际的碰撞计算。按照以下步骤操作：
- en: Select any environment GameObject in the **Hierarchy** and in the corresponding
    **Inspector** pane, click on **Layer** | **Add Layer...**, as illustrated in the
    following screenshot:![](img/B17573_08_01.png)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择任何环境GameObject，并在相应的**检查器**面板中，点击**层** | **添加层...**，如图所示：![](img/B17573_08_01.png)
- en: 'Figure 8.1: Selecting layers in the Inspector pane'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1：在检查器面板中选择层
- en: Add a new layer called `Ground` by typing the name into the first available
    slot, which is Layer 6\. Layers 0-5 are reserved for Unity's default layers, even
    though Layer 3 is empty, as illustrated in the following screenshot:![](img/B17573_08_02.png)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在第一个可用槽位中输入名称来添加一个名为`Ground`的新层，该槽位是层6。层0-5是为Unity的默认层保留的，即使层3是空的，如以下截图所示！![img/B17573_08_02.png](img/B17573_08_02.png)
- en: 'Figure 8.2: Adding layers in the Inspector pane'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.2：在检查器面板中添加层
- en: Select the **Environment** parent GameObject in the **Hierarchy**, click on
    the **Layer** dropdown, and select **Ground**.![](img/B17573_08_03.png)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**环境**父GameObject，点击**层**下拉菜单，并选择**地面**。![img/B17573_08_03.png](img/B17573_08_03.png)
- en: 'Figure 8.3: Setting a custom layer'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.3：设置自定义层
- en: After you have selected the **Ground** option shown in the following screenshot,
    click **Yes, change children** when a dialog appears asking you if you want to
    change all child objects. Here, you've defined a new layer called **Ground** and
    assigned every child object of **Environment** to that layer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择以下截图所示的**地面**选项后，当出现对话框询问你是否要更改所有子对象时，点击**是，更改子对象**。在这里，你已定义了一个名为**地面**的新层，并将**环境**的每个子对象分配到该层。
- en: Going forward, all the objects on the **Ground** layer can be checked to see
    if they intersect with a specific object. You'll use this in the following challenge
    to make sure the player can perform a jump if it's on the ground; no unlimited
    jump hacks here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有位于**地面**层的对象都可以检查是否与特定对象相交。你将在下面的挑战中使用这个功能，确保玩家在地面时可以执行跳跃；这里没有无限跳跃的漏洞。
- en: 'Since we don''t want code cluttering up the `Update()` method, we''ll do our
    layer mask calculations in a utility function and return a `true` or `false` value
    based on the outcome. To do so, proceed as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望代码在`Update()`方法中变得杂乱，我们将我们的层掩码计算放在一个实用函数中，并根据结果返回一个`true`或`false`值。为此，请按照以下步骤操作：
- en: 'Add the following highlighted code to `PlayerBehavior` and play the scene again:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下高亮代码添加到`PlayerBehavior`中，并再次播放场景：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the `PlayerBehavior` script selected, set **Ground Layer** in the **Inspector**
    pane to **Ground** from the **Ground Layer** dropdown, as illustrated in the following
    screenshot:![](img/B17573_08_04.png)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`PlayerBehavior`脚本后，在**检查器**面板中将**地面层**从**地面层**下拉菜单设置为**地面**，如以下截图所示！![img/B17573_08_04.png](img/B17573_08_04.png)
- en: 'Figure 8.4: Setting the Ground Layer'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4：设置地面层
- en: 'Let''s break down the preceding code, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解前面的代码：
- en: We create a new variable for the distance we'll check between the player Capsule
    Collider and any **Ground Layer** object.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为将在玩家胶囊碰撞体和任何**地面层**对象之间检查的距离创建一个新变量。
- en: We create a `LayerMask` variable that we can set in the **Inspector** and use
    for the collider detection.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`LayerMask`变量，我们可以在**检查器**中设置它，并用于碰撞检测。
- en: We create a variable to store the player's Capsule Collider component.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个变量来存储玩家的胶囊碰撞体组件。
- en: We use `GetComponent()` to find and return the Capsule Collider attached to
    the player.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`GetComponent()`来查找并返回附加到玩家的胶囊碰撞体。
- en: We update the `if` statement to check whether `IsGrounded` returns `true` and
    the spacebar is pressed before executing the jump code.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新`if`语句以检查`IsGrounded`是否返回`true`以及空格键是否在执行跳跃代码之前被按下。
- en: We declare the `IsGrounded()` method with a `bool` return type.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个返回`bool`类型的`IsGrounded()`方法。
- en: We create a local `Vector3` variable to store the position at the bottom of
    the player's Capsule Collider, which we'll use to check for collisions with any
    objects on the **Ground** layer.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个局部`Vector3`变量来存储玩家胶囊碰撞体底部的位置，我们将使用它来检查与**地面**层上任何对象的碰撞。
- en: All Collider components have a `bounds` property, which gives us access to the
    min, max, and center positions of its *x*, *y*, and *z* axes.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有碰撞体组件都有一个`bounds`属性，它为我们提供了访问其*x*、*y*和*z*轴的最小、最大和中心位置的能力。
- en: The bottom of the collider is the 3D point at center *x*, min *y*, and center
    *z*.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体的底部是中心*x*、最小*y*和中心*z*的3D点。
- en: 'We create a local `bool` to store the result of the `CheckCapsule()` method
    that we call from the `Physics` class, which takes in the following five arguments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个局部`bool`变量来存储从`Physics`类中调用的`CheckCapsule()`方法的结果，该方法接受以下五个参数：
- en: The start of the capsule, which we set to the middle of the Capsule Collider
    since we only care about checking whether the bottom touches the ground.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊的起始位置，我们将其设置为胶囊碰撞体的中间，因为我们只关心底部是否接触地面。
- en: The end of the capsule, which is the `capsuleBottom` position we've already
    calculated.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊的末端，即我们已经计算出的 `capsuleBottom` 位置。
- en: The radius of the capsule, which is the `DistanceToGround` already set.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊的半径，即已经设置的 `DistanceToGround`。
- en: The layer mask we want to check collisions on, set to `GroundLayer` in the **Inspector**.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要检查碰撞的层掩码，在 **检查器** 中设置为 `GroundLayer`。
- en: The query trigger interaction, which determines whether the method should ignore
    colliders that are set as triggers. Since we want to ignore all triggers, we used
    the `QueryTriggerInteraction.Ignore` enum.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询触发器交互，它确定方法是否应该忽略设置为触发器的碰撞体。由于我们想忽略所有触发器，我们使用了 `QueryTriggerInteraction.Ignore`
    枚举。
- en: We could also use the `Distance` method from the `Vector3` class to determine
    how far we are from the ground since we know the height of the player capsule.
    However, we're going to stick with using the `Physics` class since that's the
    focus of this chapter.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用 `Vector3` 类的 `Distance` 方法来确定我们距离地面的距离，因为我们知道玩家胶囊的高度。然而，我们将坚持使用 `Physics`
    类，因为这是本章的重点。
- en: We return the value stored in `grounded` at the end of the calculation.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在计算结束时返回存储在 `grounded` 中的值。
- en: We could have done the collision calculation manually, but that would require
    more complex 3D math than we have time to cover here. However, it's always a good
    idea to use built-in methods when available.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动进行碰撞计算，但这将需要比我们在这里有时间覆盖的更复杂的 3D 数学。然而，当可用时，使用内置方法总是一个好主意。
- en: That was an involved piece of code that we just added into `PlayerBehavior`,
    but when you break it down, the only new thing we did was use a method from the
    `Physics` class. In plain English, we supplied `CheckCapsule()` with a start and
    endpoint, a collision radius, and a layer mask. If the endpoint gets closer than
    the collision radius to an object on the layer mask, the method returns `true`—meaning
    the player is touching the ground. If the player is in a mid-jump position, `CheckCapsule()`
    returns `false`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一段复杂的代码，我们刚刚添加到 `PlayerBehavior` 中，但当你分解它时，我们唯一的新操作是使用 `Physics` 类的一个方法。用简单的话说，我们向
    `CheckCapsule()` 提供了起始点和终点、碰撞半径以及层掩码。如果终点比碰撞半径更接近层掩码上的对象，该方法返回 `true`——这意味着玩家正在接触地面。如果玩家处于跳跃中的位置，`CheckCapsule()`
    返回 `false`。
- en: Since we're checking `IsGround` in the `if` statement every frame in `Update()`,
    our player's jump skills are only allowed when touching the ground.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `Update()` 中的每一帧都在检查 `IsGround`，因此我们的玩家的跳跃技能只有在接触地面时才被允许。
- en: That's all you're going to do with the jump mechanic, but the player still needs
    a way to interact and defend themself against the hordes of enemies that will
    eventually populate the arena. In the following section, you'll fix that gap by
    implementing a simple shooting mechanic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是跳跃机制的所有操作，但玩家仍然需要一个方式来交互并保护自己免受最终将充满竞技场的敌人群的攻击。在下一节中，你将通过实现简单的射击机制来填补这个空白。
- en: Shooting projectiles
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击弹体
- en: Shooting mechanics are so common that it's hard to think of a first-person game
    without some variation present, and *Hero Born* is no different. In this section,
    we'll talk about how to instantiate GameObjects from Prefabs while the game is
    running, and use the skills we've learned to propel them forward using Unity physics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 射击机制如此普遍，以至于很难想象一个没有某种变化的第一人称游戏，而《英雄降生》也不例外。在本节中，我们将讨论如何在游戏运行时从 Prefab 实例化 GameObject，并使用我们学到的技能利用
    Unity 物理将其推进。
- en: Instantiating objects
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化对象
- en: The concept of instantiating a GameObject in the game is similar to instantiating
    an instance of a class—both require starting values so that C# knows what kind
    of object we want to create and where it needs to be created. To create objects
    in the scene at runtime, we use the `Instantiate()` method and provide a Prefab
    object, a starting position, and a starting rotation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中实例化 GameObject 的概念与实例化类的实例类似——两者都需要起始值，以便 C# 知道我们想要创建什么类型的对象以及它需要在何处创建。为了在运行时创建场景中的对象，我们使用
    `Instantiate()` 方法并提供一个 Prefab 对象、起始位置和起始旋转。
- en: Essentially, we can tell Unity to create a given object with all its components
    and scripts at this spot, looking in this direction, and then manipulate it as
    needed once it's born in the 3D space. Before we instantiate an object, you'll
    need to create the object Prefab itself, which is your next task.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以告诉 Unity 在这个位置创建一个具有所有组件和脚本的指定对象，朝这个方向看，然后根据需要对其进行操作，一旦它在 3D 空间中诞生。在我们实例化对象之前，你需要创建对象
    Prefab 本身，这是你的下一个任务。
- en: 'Before we can shoot any projectiles, we''ll need a Prefab to use as a reference,
    so let''s create that now, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以射击任何投射物之前，我们需要一个用作参考的预制件，所以现在让我们创建它，如下所示：
- en: Select **+** | **3D** **Object** | **Sphere** in the **Hierarchy** panel and
    name it `Bullet`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**+** | **3D** **对象** | **球体**，并将其命名为`Bullet`。
- en: Change its **Scale** to 0.15 in the *x*, *y*, and *z* axes in the **Transform**
    component.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**变换**组件中将**缩放**的*x*、*y*和*z*轴的值更改为0.15。
- en: Select the **Bullet** in the **Inspector** and use the **Add Component** button
    at the bottom to search for and add a **Rigidbody** component, leaving all default
    properties as they are.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中选择**子弹**，并使用底部的**添加组件**按钮搜索并添加一个**刚体**组件，保留所有默认属性。
- en: 'Create a new material in the `Materials` folder using **Create** | **Material**,
    and name it `Bullet_Mat`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质**文件夹中使用**创建** | **材质**创建一个新的材质，并将其命名为`Bullet_Mat`：
- en: Change the **Albedo** property to a deep yellow.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Albedo**属性更改为深黄色。
- en: Drag and drop the material from the **Materials** folder onto the `Bullet` GameObject
    in the **Hierarchy** pane.![](img/B17573_08_05.png)
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**材质**文件夹中的材质拖放到**层次结构**面板中的`Bullet`GameObject上![img/B17573_08_05.png]
- en: 'Figure 8.5: Setting projectile properties'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5：设置投射物属性
- en: Select the **Bullet** in the **Hierarchy** panel and drag it into the `Prefabs`
    folder in the **Project** panel. Then, delete it from the **Hierarchy** to clean
    up the scene:![](img/B17573_08_06.png)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**子弹**，并将其拖动到**项目**面板中的`Prefabs`文件夹中。然后，从**层次结构**中删除它以清理场景![img/B17573_08_06.png]
- en: 'Figure 8.6: Creating a projectile Prefab'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.6：创建投射物预制件
- en: You created and configured a **Bullet** Prefab GameObject that can be instantiated
    as many times as we need in the game and updated as needed. This means you're
    ready for the next challenge—shooting projectiles.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建并配置了一个**子弹**预制件GameObject，可以在游戏中根据需要多次实例化并更新。这意味着您已经准备好迎接下一个挑战——射击投射物。
- en: Adding the shooting mechanic
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加射击机制
- en: 'Now that we have a Prefab object to work with, we can instantiate and move
    copies of the Prefab whenever we hit the left mouse button to create a shooting
    mechanic, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以操作的预制件对象，我们可以在按下左鼠标按钮时实例化和移动预制件的副本，从而创建射击机制，如下所示：
- en: 'Update the `PlayerBehavior` script with the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`PlayerBehavior`脚本，如下所示：
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the **Inspector**, drag the **Bullet** Prefab from the **Project** panel
    into the **Bullet** property of `PlayerBehavior`, as illustrated in the following
    screenshot:![](img/B17573_08_07.png)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**子弹**预制件从**项目**面板拖动到`PlayerBehavior`的**子弹**属性中，如图所示![img/B17573_08_07.png]
- en: 'Figure 8.7: Setting the Bullet Prefab'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.7：设置子弹预制件
- en: Play the game and use the left mouse button to fire projectiles in the direction
    the player is facing!
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放游戏并使用左鼠标按钮向玩家面向的方向发射投射物！
- en: 'Let''s break down the code, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解以下代码：
- en: 'We create two variables: one to store the Bullet Prefab, the other to hold
    the Bullet speed.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了两个变量：一个用于存储子弹预制件，另一个用于存储子弹速度。
- en: Like our jumping mechanic, we use a boolean in the `Update` method to check
    if our player should be shooting.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们的跳跃机制一样，我们在`Update`方法中使用布尔值来检查玩家是否应该射击。
- en: We set the value of `_isShooting` using the `or` logical operator and `Input.GetMouseButtonDown()`,
    which returns `true` if we're pushing the specified button, just like with `Input.GetKeyDown()`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用逻辑运算符`or`和`Input.GetMouseButtonDown()`来设置`_isShooting`的值，如果按下指定的按钮，则返回`true`，就像使用`Input.GetKeyDown()`一样。
- en: '`GetMouseButtonDown()` takes an `int` parameter to determine which mouse button
    we want to check for; `0` is the left button, `1` is the right button, and `2`
    is the middle button or scroll wheel.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMouseButtonDown()`接受一个`int`参数，用于确定我们想要检查哪个鼠标按钮；`0`是左按钮，`1`是右按钮，`2`是中间按钮或滚轮。'
- en: Then we check if our player is supposed to be shooting using the `_isShooting`
    input check variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查是否应该使用`_isShooting`输入检查变量来射击。
- en: 'We create a local GameObject variable every time the left mouse button is pressed:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次按下左鼠标按钮时，我们都会创建一个局部的GameObject变量：
- en: We use the `Instantiate()` method to assign a GameObject to `newBullet` by passing
    in the `Bullet` Prefab. We also use the player capsule's position to place the
    new `Bullet` Prefab in front of the player to avoid any collisions.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Instantiate()`方法通过传递`Bullet`预制件将GameObject分配给`newBullet`。我们还使用玩家胶囊的位置将新的`Bullet`预制件放置在玩家前方，以避免任何碰撞。
- en: We append it as a `GameObject` to explicitly cast the returned object to the
    same type as `newBullet`, which in this case is a GameObject.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将其作为`GameObject`附加，以显式地将返回的对象转换为与`newBullet`相同的类型，在这种情况下是一个GameObject。
- en: We call `GetComponent()` to return and store the Rigidbody component on `newBullet`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`GetComponent()`来返回并存储`newBullet`上的Rigidbody组件。
- en: 'We set the `velocity` property of the Rigidbody component to the player''s
    `transform.forward` direction multiplied by `BulletSpeed`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Rigidbody组件的`velocity`属性设置为玩家`transform.forward`方向乘以`BulletSpeed`：
- en: Changing the `velocity` instead of using `AddForce()` ensures that gravity doesn't
    pull our bullets down in an arc when fired.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变`velocity`而不是使用`AddForce()`确保子弹在发射时不会被重力拉成弧形。
- en: Finally, we set the `_isShooting` value to `false` so our shooting input is
    reset for the next input event.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`_isShooting`值设置为`false`，以便我们的射击输入在下一个输入事件之前被重置。
- en: Again, you've significantly upgraded the logic the player script is using. You
    should now be able to use the mouse to shoot projectiles that fly straight out
    from the player's position.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你已经显著提升了玩家脚本所使用的逻辑。现在你应该能够使用鼠标从玩家位置发射直线飞行的弹丸。
- en: However, the problem now is that your game scene, and hierarchy, are flooded
    with spent Bullet objects. Your next task is to clean those objects up once they've
    been fired, to avoid any performance issues.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在的问题是你的游戏场景和层次结构中充满了用过的子弹对象。你的下一个任务是清理这些对象，一旦它们被发射，以避免任何性能问题。
- en: Managing object build-up
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理对象累积
- en: Whether you're writing a completely code-based application or a 3D game, it's
    important to make sure that unused objects are regularly deleted to avoid overloading
    the program. Our bullets don't exactly play an important role after they are shot;
    they sort of just keep existing on the floor near whatever wall or object they
    collided with.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是编写完全基于代码的应用程序还是3D游戏，确保定期删除未使用的对象以避免程序过载是很重要的。子弹在发射后并不扮演特别重要的角色；它们似乎只是存在于地板上，靠近它们碰撞的墙壁或对象。
- en: With a mechanic such as shooting, this could result in hundreds, if not thousands,
    of bullets down the line, which is something we don't want. Your next challenge
    is to destroy each bullet after a set delay time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像射击这样的机制，这可能会导致数百甚至数千个子弹，这是我们不想看到的。你的下一个挑战是在设定延迟时间后销毁每个子弹。
- en: 'For this task, we can take the skills we''ve already learned and make the bullets
    responsible for their self-destructive behavior, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们可以利用我们已经学到的技能，使子弹负责它们的自毁行为，如下所示：
- en: Create a new C# script in the `Scripts` folder and name it `BulletBehavior`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，并将其命名为`BulletBehavior`。
- en: 'Drag and drop the `BulletBehavior` script onto the `Bullet` Prefab in the `Prefabs`
    folder and add the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BulletBehavior`脚本拖放到`Prefabs`文件夹中的`Bullet`预设上，并添加以下代码：
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down this code, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解这段代码：
- en: We declare a `float` variable to store how long we want the Bullet Prefabs to
    remain in the scene after they are instantiated.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个`float`变量来存储我们希望子弹预设在场景中保持多长时间。
- en: We use the `Destroy()` method to delete the GameObject.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Destroy()`方法删除GameObject。
- en: '`Destroy()` always needs an object as a parameter. In this case, we use the
    `this` keyword to specify the object that the script is attached to.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destroy()`始终需要一个对象作为参数。在这种情况下，我们使用`this`关键字来指定脚本附加到的对象。'
- en: '`Destroy()` can optionally take an additional `float` parameter as a delay,
    which we use to keep the bullets on screen for a short amount of time.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destroy()`可以可选地接受一个额外的`float`参数作为延迟，我们使用它来使子弹在屏幕上保持短暂的时间。'
- en: Play the game again, shoot some bullets, and watch as they are deleted from
    the **Hierarchy** by themselves in the scene after a specific delay. This means
    that the bullet executes its defined behavior, without another script having to
    tell it what to do, which is an ideal application of the *Component* design pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏，发射一些子弹，并观察它们在场景中经过特定延迟后自行从**层次结构**中删除。这意味着子弹执行其定义的行为，而无需另一个脚本告诉它做什么，这是*组件*设计模式的理想应用。
- en: Now that our housekeeping is done, you're going to learn about a key component
    of any well-designed and organized project—the manager class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了清理工作，你将学习任何设计良好且组织有序的项目的一个关键组件——管理类。
- en: Creating a game manager
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏管理器
- en: A common misconception when learning to program is that all variables should
    automatically be made public, but in general, this is not a good idea. In my experience,
    variables should be thought of as protected and private from the start, and only
    made public if necessary. One way you'll see experienced programmers protect their
    data is through manager classes, and since we want to build good habits, we'll
    be following suit. Think of manager classes as a funnel where important variables
    and methods can be accessed safely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习编程时，一个常见的误解是所有变量都应该自动设置为 `public`，但一般来说，这并不是一个好主意。根据我的经验，变量应该从一开始就被视为受保护的和私有的，只有在必要时才设置为
    `public`。你将看到经验丰富的程序员通过管理类来保护他们的数据，因此，为了养成良好的习惯，我们将效仿他们。将管理类想象成一个漏斗，其中重要的变量和方法可以安全地访问。
- en: When I say safely, I mean just that, which might seem unfamiliar in a programming
    context. However, when you have different classes communicating and updating data
    with each other, things can get messy. That's why having a single contact point,
    such as a manager class, can keep this to a minimum. We'll get into how to do
    that effectively in the following section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“安全地”时，我的意思就是如此，这在编程环境中可能看起来不熟悉。然而，当你有不同类相互通信并更新彼此的数据时，事情可能会变得混乱。这就是为什么有一个单一的接触点，比如管理器类，可以将其保持在最低限度。我们将在下一节中探讨如何有效地做到这一点。
- en: Tracking player properties
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪玩家属性
- en: '*Hero Born* is a simple game, so the only two data points we need to keep track
    of are how many items the player has collected and how much health they have left.
    We want these variables to be private so that they can only be modified from the
    manager class, giving us control and safety. Your next challenge is to create
    a game manager for *Hero Born* and populate it with helpful functionality.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*英雄诞生* 是一个简单的游戏，所以我们只需要跟踪的两个数据点是玩家收集了多少物品以及他们剩余多少生命值。我们希望这些变量是私有的，这样它们就只能从管理器类中修改，这给我们提供了控制和安全性。你的下一个挑战是为
    *英雄诞生* 创建一个游戏管理器，并填充它有用的功能。'
- en: 'Game manager classes will be a constant facet of any project you develop in
    the future, so let''s learn how to properly create one, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏管理器类将是您未来开发的任何项目中一个恒定的组成部分，因此让我们学习如何正确创建一个，如下所示：
- en: Create a new C# script in the `Scripts` folder and name it `GameBehavior`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的 C# 脚本，并将其命名为 `GameBehavior`。
- en: Usually, this script would be named `GameManager`, but Unity reserves that name
    for its own scripts. If you ever create a script and a cogwheel icon shows up
    next to its name instead of the C# file icon, that tells you it's restricted.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，这个脚本会被命名为 `GameManager`，但 Unity 为其自己的脚本保留了该名称。如果你创建了一个脚本，并且旁边出现了一个齿轮图标而不是
    C# 文件图标，那说明它是受限的。
- en: Create a new empty game object in the **Hierarchy** by using **+** | **Create
    Empty**, and name it `Game_Manager`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中创建一个新的空游戏对象，使用 **+** | **Create Empty**，并将其命名为 `Game_Manager`。
- en: Drag and drop the `GameBehavior.cs` script from the **Scripts** folder onto
    the `Game_Manager` object, as illustrated in the following screenshot:![](img/B17573_08_08.png)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GameBehavior.cs` 脚本从 **Scripts** 文件夹拖放到 `Game_Manager` 对象上，如图所示：![img/B17573_08_08.png]
- en: 'Figure 8.8: Attaching the game manager script'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.8：附加游戏管理器脚本
- en: Manager scripts, and other non-game files, are set up on empty objects to put
    them in the scene, even though they don't interact with the actual 3D space.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 管理脚本和其他非游戏文件被设置在空对象上，以便将它们放入场景中，即使它们不与实际的 3D 空间交互。
- en: 'Add the following code to `GameBehavior.cs`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `GameBehavior.cs` 文件中：
- en: '[PRE11]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's break down this code. We added two new `private` variables to hold the
    number of items picked up and how many lives the player has left; these are `private`
    because they should only be modifiable in this class. If they were made `public`,
    other classes could change them at will, which could lead to the variables storing
    incorrect or concurrent data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码。我们添加了两个新的 `private` 变量来存储拾取的物品数量和玩家剩余的生命值；这些变量是 `private` 的，因为它们只应该在这个类中可修改。如果它们被设置为
    `public`，其他类可以随意更改它们，这可能导致变量存储不正确或并发数据。
- en: Having these variables declared as `private` means that you are responsible
    for how they are accessed. The following topic on `get` and `set` properties will
    introduce you to a standard, safe way to accomplish this task going forward.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些变量声明为 `private` 意味着你负责它们如何被访问。以下关于 `get` 和 `set` 属性的主题将介绍你如何以标准、安全的方式完成这项任务。
- en: The get and set properties
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置属性
- en: We've got our manager script and private variables set up, but how do we access
    them from other classes if they're private? While we could write separate public
    methods in `GameBehavior` to handle passing new values to the private variables,
    let's see whether there is a better way of doing things.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了管理脚本和私有变量，但如果它们是私有的，我们如何从其他类访问它们？虽然我们可以在`GameBehavior`中编写单独的公共方法来处理将新值传递给私有变量，但让我们看看是否有更好的方法来做这件事。
- en: In this case, C# provides all variables with `get` and `set` properties, which
    are perfectly suited to our task. Think of these as methods that are automatically
    fired by the C# compiler whether we explicitly call them or not, similar to how
    `Start()` and `Update()` are executed by Unity when a scene starts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，C#为所有变量提供了`get`和`set`属性，这些属性非常适合我们的任务。想象一下，这些就像是由C#编译器自动调用的方法，无论我们是否显式调用它们，就像Unity在场景开始时执行`Start()`和`Update()`一样。
- en: '`get` and `set` properties can be added to any variable, with or without an
    initial value, as illustrated in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`属性可以添加到任何变量，无论是否有初始值，如下面的代码片段所示：'
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, using them like this doesn''t add any additional benefits; for that,
    you need to include a code block for each property, as illustrated in the following
    code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样使用它们并不会增加任何额外的优势；为了达到这个目的，你需要为每个属性包含一个代码块，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, the `get` and `set` properties are set up to execute additional logic,
    depending on where it's needed. We're not done yet though, as we still need to
    handle the new logic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`get`和`set`属性已经设置好，以执行额外的逻辑，具体取决于需要的地方。但我们还没有完成，因为我们还需要处理新的逻辑。
- en: Every `get` code block needs to return a value, while every `set` block needs
    to
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个get代码块都需要返回一个值，而每个set代码块都需要
- en: 'assign a value; this is where having a combination of a private variable, called
    a backing variable, and a public variable with `get` and `set` properties comes
    into play. The private variable remains protected, while the public variable allows
    controlled access from other classes, as shown in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个值；这就是为什么需要一个名为后置变量的私有变量和具有`get`和`set`属性的公共变量的组合。私有变量保持受保护状态，而公共变量允许其他类进行受控访问，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s break this down, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解：
- en: We can `return` the value stored in the private variable from the `get` property
    anytime another class needs it, without actually giving that outside class direct
    access.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从`get`属性返回存储在私有变量中的值，当另一个类需要它时，而不必实际上给那个外部类直接访问权限。
- en: We can update the private variable any time an outside class assigns a new value
    to the public variable, keeping them in sync.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部类将新值分配给公共变量时，我们可以随时更新私有变量，以保持它们同步。
- en: The `value` keyword is a stand-in for whatever new value is assigned.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`关键字是用于替代所分配的新值的占位符。'
- en: This can seem a little esoteric without an actual application, so let's update
    `GameBehavior` with public variables with getter and setter properties to go along
    with our existing private variables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 没有实际应用的情况下，这可能会显得有些晦涩难懂，所以让我们更新`GameBehavior`，添加具有getter和setter属性的公共变量，以配合我们现有的私有变量。
- en: Now that we understand the syntax of the `get` and `set` property accessors,
    we can implement them in our manager class for greater efficiency and code readability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了`get`和`set`属性访问器的语法，我们可以在我们的管理类中实现它们，以提高效率和代码可读性。
- en: 'Update the code in `GameBehavior`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式更新`GameBehavior`中的代码：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s break down the code, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解代码：
- en: We declare a new `public` variable called `Items` with `get` and `set` properties.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个新的名为`Items`的公共变量，具有`get`和`set`属性。
- en: We use the `get` property to `return` the value stored in `_itemsCollected`
    whenever `Items` are accessed from an outside class.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`get`属性在从外部类访问`Items`时返回存储在`_itemsCollected`中的值。
- en: We use the `set` property to assign `_itemsCollected` to the new `value` of
    `Items` whenever it's updated, with an added `Debug.LogFormat()` call to print
    out the modified value of `_itemsCollected`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`set`属性在更新`Items`的新值时将`_itemsCollected`分配给它，并添加了一个`Debug.LogFormat()`调用，以打印出`_itemsCollected`的修改后的值。
- en: We set up a `public` variable called `HP` with `get` and `set` properties to
    complement the private `_playerHP` backing variable.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一个名为`HP`的公共变量，具有`get`和`set`属性，以补充私有的`_playerHP`后置变量。
- en: Both private variables are now readable, but only through their public counterparts;
    they can only be changed in `GameBehavior`. With this setup, we ensure that our
    private data can only be accessed and modified from specific contact points. This
    makes it easier to communicate with `GameBehavior` from our other mechanical scripts,
    as well as to display the real-time data in the simple UI we'll create at the
    end of the chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个私有变量现在都是可读的，但只能通过它们的公共对应物来读取；它们只能在`GameBehavior`中更改。通过这种设置，我们确保我们的私有数据只能从特定的接触点访问和修改。这使得从我们的其他机械脚本与`GameBehavior`通信以及显示我们在本章末尾创建的简单UI中的实时数据变得更加容易。
- en: Let's test this out by updating the `Items` property when we successfully interact
    with an item pickup in the arena.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在竞技场中成功与物品拾取互动时更新`Items`属性来测试一下。
- en: Updating item collection
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新物品集合
- en: 'Now that we have our variables set up in `GameBehavior`, we can update `Items`
    every time we collect an `Item` in the scene, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`GameBehavior`中设置了变量，每次我们在场景中收集到`Item`时，都可以更新`Items`，如下所示：
- en: 'Add the following highlighted code to the `ItemBehavior` script:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下高亮代码添加到`ItemBehavior`脚本中：
- en: '[PRE16]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Hit play and collect the pickup item to see the new console log print out from
    the manager script, as illustrated in the following screenshot:![](img/B17573_08_09.png)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放游戏并收集拾取物品，以查看管理脚本中打印出的新控制台日志，如图所示：![](img/B17573_08_09.png)
- en: 'Figure 8.9: Collecting a pickup item'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：收集拾取物品
- en: 'Let''s break down the code, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解代码：
- en: We create a new variable of the `GameBehavior` type to store a reference to
    the attached script.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`GameBehavior`类型的变量来存储附加脚本的引用。
- en: We use `Start()` to initialize `GameManager` by looking it up in the scene with
    `Find()` and adding a call to `GetComponent()`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Start()`通过`Find()`在场景中查找`GameManager`并添加对`GetComponent()`的调用来初始化`GameManager`。
- en: You'll see this kind of code done in a single line quite often in Unity documentation
    and community projects. This is done for simplicity, but if you feel more comfortable
    writing out the `Find()` and `GetComponent()` calls separately, go right ahead;
    there's nothing wrong with clear, explicit formatting.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你在Unity文档和社区项目中经常会看到这种单行代码。这样做是为了简化，但如果你觉得单独编写`Find()`和`GetComponent()`调用更舒服，那就直接这么做吧；清晰的显式格式化没有问题。
- en: We increment the `Items` property in the `GameManager` class in `OnCollisionEnter()`
    after the Item Prefab is destroyed.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在销毁物品预制体后，我们在`GameManager`类的`OnCollisionEnter()`方法中增加`Items`属性。
- en: Since we already set up `ItemBehavior` to take care of collision logic, it's
    easy to modify `OnCollisionEnter()` to communicate with our manager class when
    an item is picked up by the player. Keep in mind that separating functionality
    like this is what makes the code more flexible and less likely to break as you
    make changes during development.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了`ItemBehavior`来处理碰撞逻辑，因此修改`OnCollisionEnter()`以在玩家拾取物品时与我们的管理类通信很容易。记住，像这样分离功能使得代码更加灵活，并且在开发过程中进行更改时更不容易出错。
- en: The last piece *Hero Born* is missing is some kind of interface that displays
    game data to the player. In programming and game development, this is called a
    UI. Your final task in this chapter is to familiarize yourself with how Unity
    creates and handles the UI code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺少的部分是某种显示游戏数据的界面，这在编程和游戏开发中被称为UI。本章的最终任务是熟悉Unity如何创建和处理UI代码。
- en: Creating a GUI
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GUI
- en: At this point, we have several scripts working together to give players access
    to movement, jumping, collecting, and shooting mechanics. However, we're still
    missing any kind of display or visual cue that shows our player's stats, as well
    as a way to win and lose the game. We'll focus on these two topics as we close
    out this last section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有几个脚本协同工作，为玩家提供移动、跳跃、收集和射击机制。然而，我们仍然缺少任何显示或视觉提示来显示玩家的统计数据，以及赢或输游戏的方式。在结束本节之前，我们将重点关注这两个主题。
- en: Displaying player stats
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示玩家统计数据
- en: UIs are the visual components of any computer system. The mouse cursor, folder
    icons, and programs on your laptop are all UI elements. For our game, we want
    a simple display to let our players know how many items they've collected, their
    current health, and a textbox to give them updates when certain events happen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: UI是任何计算机系统的视觉组件。鼠标光标、文件夹图标以及笔记本电脑上的程序都是UI元素。对于我们的游戏，我们想要一个简单的显示，让玩家知道他们收集了多少物品，他们的当前健康状态，以及当某些事件发生时提供更新的文本框。
- en: 'UI elements in Unity can be added in the following two ways:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，UI元素可以通过以下两种方式添加：
- en: Directly from the **+** menu in the **Hierarchy** panel, like with any other
    GameObject
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从**层级**面板中的**+**菜单添加，就像添加任何其他GameObject一样
- en: Using the built-in GUI class in code
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码中的内置GUI类
- en: We're going to stick with the first option, since the built-in GUI classes are
    part of the Unity legacy UI system, and we want to stay current, right? This isn't
    to say that you can't do everything programmatically, but for our prototype, the
    newer UI systems are a better fit.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持使用第一种方法，因为内置的GUI类是Unity遗留UI系统的一部分，而我们希望保持最新，对吧？这并不是说你不能完全通过编程实现，但对我们这个原型来说，较新的UI系统更合适。
- en: 'If you''re curious about programmatic UI in Unity, take a look at the documentation
    yourself: [https://docs.unity3d.com/ScriptReference/GUI.html](https://docs.unity3d.com/ScriptReference/GUI.html).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Unity中的程序化UI感兴趣，请亲自查看文档：[https://docs.unity3d.com/ScriptReference/GUI.html](https://docs.unity3d.com/ScriptReference/GUI.html).
- en: Your next task is to add a simple UI to the game scene that displays the items
    collected, player health, and progress information variables that are stored in
    `GameBehavior.cs`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是向游戏场景添加一个简单的UI，显示收集到的物品、玩家健康和存储在`GameBehavior.cs`中的进度信息变量。
- en: First, let's create three text objects in our scene. User interfaces in Unity
    work off of a canvas, which is exactly what it sounds like. Think of the canvas
    as a blank painting that you can draw on that Unity will render on top of the
    game world for you. Whenever you create your first UI element in the **Hierarchy**
    panel, a **Canvas** parent object is created along with it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的场景中创建三个文本对象。Unity中的用户界面是基于Canvas的，这正好符合其名称。将Canvas想象成一块空白画布，你可以在上面绘制，Unity会为你将其渲染在游戏世界之上。每次你在**层级**面板中创建第一个UI元素时，都会同时创建一个**Canvas**父对象。
- en: Right-click in the **Hierarchy** panel and select **UI** | **Text** and name
    the new object **Health**. This will create a **Canvas** parent object and the
    new **Text** object all at once:![](img/B17573_08_10.png)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中右键单击，选择**UI** | **文本**，并将新对象命名为**Health**。这将一次性创建一个**Canvas**父对象和新的**Text**对象！![img/B17573_08_10.png](img/B17573_08_10.png)
- en: 'Figure 8.10: Creating a Text element'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10：创建文本元素
- en: To see the canvas correctly, select **2D** mode at the top of the **Scene**
    tab. From this view, our entire level is that tiny white line in the lower-left
    hand corner.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要正确查看Canvas，请在上面的**场景**标签页中选择**2D**模式。从这种视图来看，我们的整个层级就是左下角的那条细小的白色线条。
- en: Even though the **Canvas** and level don't overlap in the scene, when the game
    plays Unity will automatically overlay them correctly.![](img/B17573_08_11.png)
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在场景中**Canvas**和层级没有重叠，当游戏运行时，Unity会自动正确地将它们叠加在一起！![img/B17573_08_11.png](img/B17573_08_11.png)
- en: 'Figure 8.11: Canvas in the Unity editor'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.11：Unity编辑器中的Canvas
- en: If you select the **Health** object in the **Hierarchy**, you'll see that the
    new text object was created in the lower-left corner of the canvas by default,
    and it has a whole list of customizable properties, like text and color, in the
    **Inspector** pane:![](img/B17573_08_12.png)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你选择**层级**中的**Health**对象，你会看到新创建的文本对象默认位于画布的左下角，并且在**检查器**面板中有一系列可自定义的属性，如文本和颜色！![img/B17573_08_12.png](img/B17573_08_12.png)
- en: 'Figure 8.12: Text element on the Unity Canvas'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.12：Unity Canvas上的文本元素
- en: With the **Health** object selected in the **Hierarchy** pane, click on the
    **Anchor** presets in the **Rect Transform** component of the **Inspector** and
    choose **Top Left**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中选择**Health**对象，然后点击**检查器**中**Rect Transform**组件的**锚点**预设，并选择**左上角**。
- en: Anchors set a UI element's point of reference on the canvas, meaning that whatever
    the size of the device screen, our health points will always be anchored to the
    top left of the screen:![](img/B17573_08_13.png)
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锚点设置UI元素在Canvas上的参考点，这意味着无论设备屏幕的大小如何，我们的健康点始终锚定在屏幕的左上角！![img/B17573_08_13.png](img/B17573_08_13.png)
- en: 'Figure 8.13: Setting anchor presets'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.13：设置锚点预设
- en: In the **Inspector** pane, change the **Rect Transform** position to **100**
    on the **X** axis and **–30** on the **Y** axis to position the text in the upper-right
    corner. Also change the **Text** property to say **Player Health:**. We'll be
    setting the actual value in code in a later step:![](img/B17573_08_14.png)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将**Rect Transform**的位置在**X**轴上设置为**100**，在**Y**轴上设置为**-30**，以将文本定位在右上角。同时，将**文本**属性更改为**玩家健康**：。我们将在稍后的步骤中通过代码设置实际值！![img/B17573_08_14.png](img/B17573_08_14.png)
- en: 'Figure 8.14: Setting text properties'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.14：设置文本属性
- en: 'Repeat steps 1-5 to create a new UI **Text** object and name it **Items**:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the anchor presets to **Top Left**, the **Pos X** to **100**, and the **Pos
    Y** to **–60**
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Text** to **Items Collected:**![](img/B17573_08_15.png)
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.15: Creating another Text element'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Repeat *steps 1-5* to create a new UI **Text** object and name it **Progress**:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the anchor presets to **Bottom Center**, the **Pos X** to **0**, the **Pos
    Y** to **15**, and the **Width** to **280**
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Text** to **Collect all the items and win your freedom!**![](img/B17573_08_16.png)
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.16: Creating a progress text element'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our UI set up, let''s connect the variables we already have
    in our game manager script. Proceed as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `GameBehavior` with the following code to collect an item and display
    on-screen text when items are collected:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Select **Game_Manager** in the **Hierarchy** and drag over our three text objects
    one by one into their corresponding `GameBehavior` script fields in the **Inspector**:![](img/B17573_08_17.png)
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.17: Dragging text elements to script components'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the game and take a look at our new onscreen GUI boxes, shown in the following
    screenshot:![](img/B17573_08_18.png)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.18: Testing UI elements in play mode'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We add the `UnityEngine.UI` namespace so we have access to the **Text** variable
    type.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new public variable for the max number of items in the level.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create three new **Text** variables, which we connect in the **Inspector**
    panel.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `Start` method to set the initial values of our health and
    items text using the **+=** operator.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time an item is collected, we update the `text` property of **ItemText**
    to show the updated `items` count.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare an `if` statement in the set property of `_itemsCollected`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player has gathered more than or equal to `MaxItems`, they've won, and
    `ProgressText.text` is updated.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, `ProgressText.text` shows how many items are still left to collect.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player's health is damaged, which we'll cover in the next chapter,
    we update the `text` property of `HealthText` with the new value.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we play the game now, our three UI elements show up with the correct values;
    when an Item is collected, the `ProgressText` and `_itemsCollected` counts update,
    as illustrated in the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_08_19.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Updating the UI text'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Every game can either be won or lost. In the last section of this chapter, your
    task is to implement those conditions and the UI that goes along with them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Win and loss conditions
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve implemented our core game mechanics and a simple UI, but *Hero Born*
    is still missing an important game design element: its win and loss conditions.
    These conditions will manage how the player wins or loses the game and execute
    different code depending on the situation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the game document from *Chapter 6*, *Getting Your Hands Dirty with
    Unity*, we set out our win and loss conditions as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Collecting all items in the level with at least 1 health point remaining to
    win
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking damage from enemies until health points are at 0 to lose
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These conditions are going to affect both our UI and game mechanics, but we've
    already set up `GameBehavior` to handle this efficiently. Our `get` and `set`
    properties will handle any game-related logic and changes to the UI when a player
    wins or loses.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We're going to implement the win condition logic in this section because we
    have the pickup system already in place. When we get to the enemy AI behavior
    in the next chapter, we'll add in the loss condition logic. Your next task is
    to determine when the game is won in code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We always want to give players clear and immediate feedback, so we''ll start
    by adding in the logic for a win condition, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `GameBehavior` to match the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Right-click in the **Hierarchy** and select **UI** | **Button**, then name
    it **Win Condition**:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win Condition** and set the **Pos X** and **Pos Y** to **0**, its **Width**
    to **225**, and its **Height** to **115**.![](img/B17573_08_20.png)
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.20: Creating a UI button'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the arrow to the right of the **Win Condition** button to expand its
    text child object, then change the text to say **You won!**:![](img/B17573_08_21.png)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.21: Updating button text'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Win Condition** parent object again and click the checkmark icon
    in the upper right of the **Inspector**.![](img/B17573_08_22.png)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.22: Deactivating the game object'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will hide the button until we''ve won the game:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_08_23.png)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.23: Testing the hidden UI button'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Game_Manager** in the **Hierarchy** and drag the **Win Condition**
    button from the **Hierarchy** to the **Game Behavior (Script)** in the **Inspector**,
    just like we did with the text objects:![](img/B17573_08_24.png)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.24: Dragging the UI button onto the script component'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change **Max Items** to `1` in the **Inspector** to test out the new screen,
    as illustrated in the following screenshot:![](img/B17573_08_25.png)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.25: Showing the win screen'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We created a UI button variable to connect to our Win Condition button in the
    **Hierarchy**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we set the Win Condition button as **Hidden** when the game starts, we
    reactivate it when the game is won.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Max Items** set to `1`, the **Win** button will show up on collecting
    the only `Pickup_Item` in the scene. Clicking the button doesn't do anything right
    now, but we'll address that in the following section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and restarting the game with using directives and namespaces
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, our win condition works as expected, but the player still has control
    over the capsule and doesn't have a way of restarting the game once it's over.
    Unity provides a property in the `Time` class called `timeScale`, which when set
    to `0` freezes the game scene. However, to restart the game, we need access to
    a **namespace** called `SceneManagement` that isn't accessible from our classes
    by default.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的胜利条件按预期工作，但玩家仍然可以控制胶囊，并且一旦游戏结束，就没有重启游戏的方法。Unity在`Time`类中提供了一个名为`timeScale`的属性，将其设置为`0`可以冻结游戏场景。然而，要重启游戏，我们需要访问一个名为`SceneManagement`的**命名空间**，默认情况下我们的类无法访问。
- en: A namespace collects and groups a set of classes under a specific name to organize
    large projects and avoid conflicts between scripts that may share the same names.
    A `using` directive needs to be added to a class to access a namespace's classes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间收集并按特定名称组织一组类，以组织大型项目并避免可能具有相同名称的脚本之间的冲突。需要向一个类添加一个`using`指令来访问命名空间的类。
- en: 'All C# scripts created from Unity come with three default `using` directives,
    shown in the following code snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unity创建的所有C#脚本都包含三个默认的`using`指令，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These allow access to common namespaces, but Unity and C# offer plenty more
    that can be added with the `using` keyword followed by the name of the namespace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许访问常见的命名空间，但Unity和C#提供了许多其他可以通过`using`关键字后跟命名空间名称来添加的命名空间。
- en: Since our game will need to be paused and restarted when a player wins or loses,
    this is a good time to use a namespace that isn't included in new C# scripts by
    default.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏在玩家获胜或失败时需要暂停和重启，这是一个使用默认情况下不包括在新的C#脚本中的命名空间的好时机。
- en: 'Add the following code to `GameBehavior` and play:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`GameBehavior`中并播放：
- en: '[PRE20]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Select **Win Condition** from the **Hierarchy**, scroll down in the **Inspector**
    to the **OnClick** section of the **Button** component, and hit the plus icon:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中选择**胜利条件**，在**检查器**中向下滚动到**按钮组件**的**OnClick**部分，然后点击加号图标：
- en: Every UI button has an **OnClick** event, which means you can assign a method
    from a script to execute when the button is pushed.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个UI按钮都有一个**OnClick**事件，这意味着你可以将脚本中的一个方法分配给按钮，以便在按钮被按下时执行。
- en: You can have multiple methods fire when a button is clicked, but we only need
    one in this case:![](img/B17573_08_26.png)
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，可以有多个方法被触发，但在这个情况下我们只需要一个！![图片](img/B17573_08_26.png)
- en: 'Figure 8.26: OnClick section of the button'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.26：按钮的OnClick部分
- en: From the **Hierarchy**, drag the **Game_Manager** into the slot underneath **Runtime**
    to tell the button we want to choose a method from our manager script to fire
    when the button is pushed:![](img/B17573_08_27.png)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中，将**Game_Manager**拖到**Runtime**下的槽中，告诉按钮我们想要选择一个来自我们的管理脚本的方法，以便在按钮被按下时触发：![图片](img/B17573_08_27.png)
- en: 'Figure 8.27: Setting the game manager object in On Click'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.27：在OnClick中设置游戏管理器对象
- en: Select the **No Function** dropdown and choose **GameBehavior** | **RestartScene
    ()** to set the method we want the button to execute:![](img/B17573_08_28.png)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**无功能**下拉菜单，选择**GameBehavior** | **RestartScene ()**来设置按钮要执行的方法！![图片](img/B17573_08_28.png)
- en: 'Figure 8.28: Choosing the restart method for the button click'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.28：选择按钮点击的重启方法
- en: 'Go to **Window** | **Rendering** | **Lighting** and select **Generate Lighting**
    at the bottom. Make sure **Auto Generate** is not selected:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口** | **渲染** | **照明**，在底部选择**生成照明**。确保**自动生成**没有被选中：
- en: This step is necessary to address a Unity issue that reloads scenes without
    any lighting.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤是解决Unity问题所必需的，该问题在没有任何照明的情况下重新加载场景。
- en: '![](img/B17573_08_29.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_08_29.png)'
- en: 'Figure 8.29: Lighting panel in the Unity editor'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：Unity编辑器中的照明面板
- en: 'Let''s break down the code, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解以下代码：
- en: We add the `SceneManagement` namespace with the `using` keyword, which handles
    all scene-related logic like creating loading scenes.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`using`关键字添加`SceneManagement`命名空间，它处理所有与场景相关的逻辑，如创建加载场景。
- en: We set `Time.timeScale` to `0` to pause the game when the win screen is displayed,
    which disables any input or movement.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`Time.timeScale`设置为`0`，以便在显示胜利屏幕时暂停游戏，这将禁用任何输入或移动。
- en: 'We create a new method called `RestartScene` and call `LoadScene()` when the
    win screen button is clicked:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的方法`RestartScene`，并在胜利屏幕按钮被点击时调用`LoadScene()`：
- en: '`LoadScene()` takes in a scene index as an `int` parameter.'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadScene()`接受一个场景索引作为`int`参数。'
- en: Because there is only one scene in our project, we use index `0` to restart
    the game from the beginning.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的项目中只有一个场景，我们使用索引`0`从开始重启游戏。
- en: We reset `Time.timeScale` to the default value of `1` so that when the scene
    restarts, all controls and behaviors will be able to execute again.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `Time.timeScale` 重置为默认值 `1`，这样当场景重新启动时，所有控制和行为将能够再次执行。
- en: Now, when you collect an item and click on the win screen button, the level
    restarts, with all scripts and components restored to their original values and
    set up for another round!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你收集物品并点击胜利屏幕按钮时，关卡将重新开始，所有脚本和组件都将恢复到其原始值，并设置好另一轮！
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! *Hero Born* is now a playable prototype. We implemented jumping
    and shooting mechanics, managed physics collisions and spawning objects, and added
    in a few basic UI elements to display feedback. We even got as far as resetting
    the level when the player wins.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！*英雄诞生* 现在是一个可玩的原型。我们实现了跳跃和射击机制，管理物理碰撞和对象生成，并添加了一些基本的 UI 元素来显示反馈。我们甚至做到了当玩家获胜时重置关卡。
- en: A lot of new topics were introduced in this chapter, and it's important to go
    back and make sure you understand what went into the code we wrote. Pay special
    attention to our discussions on enumerations, `get` and `set` properties, and
    namespaces. From here on in, the code is only going to get more complex as we
    dive further into the possibilities of the C# language.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引入了许多新主题，重要的是要回顾并确保你理解了我们编写的代码中包含的内容。特别关注我们对枚举、`get` 和 `set` 属性以及命名空间的讨论。从现在开始，随着我们进一步深入
    C# 语言的潜力，代码将变得更加复杂。
- en: In the next chapter, we'll start working on getting our enemy GameObjects to
    take notice of our player when we get too close, resulting in a follow-and-shoot
    protocol that will up the stakes for our player.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始工作，让我们的敌人 GameObject 在我们靠近时注意到我们，从而实现一个跟随和射击协议，这将提高玩家的赌注。
- en: Pop quiz – working with mechanics
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答 - 与机制一起工作
- en: What type of data do enumerations store?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举存储什么类型的数据？
- en: How would you create a copy of a Prefab GameObject in an active scene?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在活动场景中创建一个 Prefab GameObject 的副本？
- en: Which variable properties allow you to add functionality when their value is
    referenced or modified?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些变量属性允许你在引用或修改其值时添加功能？
- en: Which Unity method displays all UI objects in the scene?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Unity 方法显示场景中的所有 UI 对象？
- en: JOIN us on Discord!
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C# 专家和 Harrison Ferrone 一起阅读这本书。提出问题，为其他读者提供解决方案，通过 *Ask Me Anything*
    会话与作者聊天等等。
- en: Join Now!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
