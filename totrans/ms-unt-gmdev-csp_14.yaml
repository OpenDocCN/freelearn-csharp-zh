- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Optimizing the Game Using Unity’s Profiler, Frame Debugger, and Memory Profiler
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 的 Profiler、帧调试器和内存分析器优化游戏
- en: Welcome to [*Chapter 9*](B22017_09_split_000.xhtml#_idTextAnchor139) of your
    Unity game development journey, where we will explore optimizing game performance
    using Unity’s Profiler, Frame Debugger, and Memory Profiler. In this chapter,
    we will learn how to identify and address performance bottlenecks, optimize rendering,
    and manage memory efficiently. We’ll cover Unity’s profiling tools, dive into
    performance optimization techniques such as physics, audio, AI, and scripting
    optimizations, and delve into memory management and optimization, including Memory
    Profiler usage and asset importing optimizations. Mastering these skills will
    ensure smooth gameplay and an immersive player experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到您 Unity 游戏开发之旅的**第 9 章**，我们将探讨如何使用 Unity 的 Profiler、帧调试器和内存分析器来优化游戏性能。在本章中，我们将学习如何识别和解决性能瓶颈，优化渲染，并高效管理内存。我们将介绍
    Unity 的性能分析工具，深入探讨如物理、音频、人工智能和脚本优化的性能优化技术，并深入研究内存管理和优化，包括内存分析器使用和资产导入优化。掌握这些技能将确保流畅的游戏体验和沉浸式的玩家体验。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing Unity profiling tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Unity 性能分析工具
- en: Performance optimization techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化技术
- en: Memory management and optimization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理和优化
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need to install the following to follow along with me in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装以下内容才能跟随本章内容：
- en: '**Primary IDE – Visual Studio 2022**: The tutorials and code samples have been
    crafted using Visual Studio 2022\. Ensure it’s installed so that you can follow
    along seamlessly. Feel free to explore Rider or other IDEs if you prefer, though
    the instructions are tailored for Visual Studio.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要集成开发环境 – Visual Studio 2022**：教程和代码示例是使用 Visual Studio 2022 制作的。请确保已安装，以便您可以无缝地跟随。如果您更喜欢
    Rider 或其他 IDE，请随意探索，尽管说明是为 Visual Studio 定制的。'
- en: '**Unity version 2022.3.13**: Download and install Unity, choosing version 2022.3.13
    for optimal compatibility with the provided content.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 版本 2022.3.13**：下载并安装 Unity，选择版本 2022.3.13 以获得与提供内容最佳兼容性。'
- en: 'The code files of this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在以下位置找到：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009)。
- en: Introducing Unity profiling tools
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Unity 性能分析工具
- en: Welcome to Unity’s profiling tools! These tools are essential for understanding
    and improving the performance of our games. They provide valuable insights into
    how our games are running and help us optimize them for a smoother experience
    across different devices and platforms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用 Unity 的性能分析工具！这些工具对于理解和提升游戏性能至关重要。它们为我们提供了深入了解游戏运行情况的有价值见解，并帮助我们优化游戏，以实现跨不同设备和平台的流畅体验。
- en: So, why do we need to utilize profiling tools? Profiling tools are invaluable
    assets in the quest for optimization, which is the process of fine-tuning our
    games to run as efficiently as possible. These tools act as our detective companions
    in the world of game development, helping us investigate and identify areas where
    our game might be slowing down or using too much memory. By using these tools,
    we can make targeted improvements to our game’s performance, ensuring that players
    have a seamless and enjoyable gaming experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们需要利用性能分析工具呢？性能分析工具是优化过程中的宝贵资产，优化过程是将我们的游戏调整到尽可能高效运行的过程。这些工具在游戏开发的世界中充当我们的侦探伙伴，帮助我们调查和识别游戏可能减慢或使用过多内存的领域。通过使用这些工具，我们可以有针对性地改进游戏性能，确保玩家拥有无缝且愉快的游戏体验。
- en: So, what does optimization mean in game development? Optimization is the process
    of making our games run as efficiently as possible, involving finding ways to
    reduce unnecessary computations, minimize memory usage, and improve rendering
    performance. Just like a well-organized city ensures smooth traffic flow and efficient
    resource management, optimization ensures that our game’s code and graphics work
    together harmoniously to deliver a captivating experience to players. This optimization
    is crucial because it directly impacts the player’s experience. No one wants to
    play a game that lags, stutters, or crashes unexpectedly. By optimizing our games,
    we can ensure that they run smoothly on a variety of hardware configurations,
    providing players with a consistent and enjoyable gaming experience across different
    platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在游戏开发中，优化意味着什么？优化是一个使我们的游戏尽可能高效运行的过程，包括寻找减少不必要的计算、最小化内存使用和提高渲染性能的方法。就像一个组织良好的城市确保交通流畅和资源管理高效一样，优化确保我们的游戏代码和图形协同工作，为玩家提供引人入胜的体验。这种优化至关重要，因为它直接影响玩家的体验。没有人想玩一个卡顿、停滞或意外崩溃的游戏。通过优化我们的游戏，我们可以确保它们在各种硬件配置上运行顺畅，为玩家提供跨平台的持续和愉快的游戏体验。
- en: Exploring Unity’s profiling tools in depth
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探索Unity的性能分析工具
- en: Unity’s profiling tools offer a comprehensive suite of features to help us understand
    and improve our game’s performance. The Profiler allows us to analyze CPU and
    GPU usage in real time, giving us valuable insights into where optimizations are
    needed. The Frame Debugger, on the other hand, helps us visualize how our game’s
    graphics are rendered.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的性能分析工具提供了一套全面的特性，帮助我们理解和改进游戏性能。Profiler允许我们实时分析CPU和GPU使用情况，为我们提供宝贵的优化见解。另一方面，Frame
    Debugger帮助我们可视化游戏图形的渲染过程。
- en: In the upcoming sections, we’ll take a closer look at each of these profiling
    tools and learn how to use them effectively to optimize our games. So, let’s get
    ready to dive into the world of Unity profiling!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将逐一深入探讨这些性能分析工具，并学习如何有效地使用它们来优化我们的游戏。那么，让我们准备好深入Unity性能分析的世界吧！
- en: The Profiler
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Profiler
- en: The Profiler in Unity is like a helpful detective for your game. It checks how
    the game is doing – for example, how much the computer is thinking (CPU), how
    the graphics are doing (GPU), and how much memory is used. It’s like a tool to
    catch issues and make your game work better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的Profiler就像是你游戏的贴心侦探。它会检查游戏的表现——例如，计算机思考了多少（CPU），图形表现如何（GPU），以及使用了多少内存。它就像一个捕捉问题并使你的游戏运行得更好的工具。
- en: 'To open the Profiler, go to **Window** | **Analysis** | **Profiler**. A new
    window will appear, as shown in *Figure 9**.1*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开Profiler，请转到**窗口** | **分析** | **Profiler**。会出现一个新窗口，如图*图9.1*所示：
- en: '![Figure 9.1 – The Profiler](img/B22017_09_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Profiler](img/B22017_09_01.jpg)'
- en: Figure 9.1 – The Profiler
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Profiler
- en: Now that we’ve opened the Profiler, let’s dive into how it works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打开了Profiler，让我们深入了解它是如何工作的。
- en: Understanding the functionality of Unity’s Profiler
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解Unity的Profiler功能
- en: The Profiler in Unity works by continuously monitoring different aspects of
    your game’s performance while it’s running. It collects data on CPU usage, GPU
    usage, memory allocation, rendering performance, and more, allowing us to gain
    insights into how our game is utilizing system resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的Profiler通过在游戏运行时持续监控游戏性能的各个方面来工作。它收集有关CPU使用率、GPU使用率、内存分配、渲染性能等方面的数据，使我们能够深入了解游戏如何利用系统资源。
- en: When you open the Profiler in Unity, it displays a variety of graphs and charts
    that visualize this data in real time. These graphs show metrics such as CPU usage
    over time, memory usage by different components of the game, and the time it takes
    to render each frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Unity中打开Profiler时，它会显示各种图表和图形，实时可视化这些数据。这些图表显示了诸如CPU使用率随时间变化、游戏不同组件的内存使用量以及渲染每一帧所需的时间等指标。
- en: The Profiler gathers this data by instrumenting your game code with profiling
    markers. These markers track the time it takes for specific functions and operations
    to execute, allowing us to identify performance bottlenecks and areas for optimization.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Profiler通过在你的游戏代码中添加性能标记来收集这些数据。这些标记跟踪特定函数和操作执行所需的时间，使我们能够识别性能瓶颈和优化区域。
- en: For example, if the Profiler shows a spike in CPU usage during gameplay, we
    can use the Profiler’s **Call Stacks** view to pinpoint which functions are consuming
    the most CPU time. It can then analyze the code within those functions to identify
    inefficiencies or areas for optimization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果分析器在游戏过程中显示CPU使用量激增，我们可以使用分析器的**调用栈**视图来定位消耗最多CPU时间的函数。然后它可以分析这些函数内的代码，以识别低效或需要优化的区域。
- en: Similarly, if the Profiler detects excessive memory usage, we can use the memory
    allocation view to identify where memory is being allocated and deallocated in
    the code. This can help identify memory leaks or inefficient memory usage patterns
    that may be impacting performance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果分析器检测到过度的内存使用，我们可以使用内存分配视图来识别代码中内存分配和释放的位置。这有助于识别内存泄漏或可能影响性能的低效内存使用模式。
- en: Overall, the Profiler in Unity provides us with valuable insights into our game’s
    performance, allowing us to identify and address issues that could impact the
    player experience. By using the Profiler effectively, we can optimize our games
    to run smoothly and efficiently on a variety of platforms and devices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Unity中的分析器为我们提供了关于游戏性能的宝贵见解，使我们能够识别和解决可能影响玩家体验的问题。通过有效地使用分析器，我们可以优化游戏，使其在各种平台和设备上运行顺畅且高效。
- en: In Unity, optimizing the performance of your game is crucial for delivering
    a smooth and immersive player experience. The Unity Profiler is a powerful tool
    that offers insights into various aspects of your game’s performance through its
    diverse modules, each focusing on different areas of analysis.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，优化游戏的性能对于提供流畅和沉浸式的玩家体验至关重要。Unity分析器是一个强大的工具，通过其多样化的模块，为游戏性能的各个方面提供见解，每个模块都专注于不同的分析区域。
- en: 'The main modules of the Unity Profiler are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unity分析器的主要模块如下：
- en: '**CPU Profiler**: This module monitors the CPU usage of your game during runtime.
    It helps identify performance bottlenecks related to scripting, physics calculations,
    rendering, and other CPU-intensive tasks.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU分析器**：此模块监控游戏运行时的CPU使用情况。它有助于识别与脚本、物理计算、渲染和其他CPU密集型任务相关的性能瓶颈。'
- en: '**GPU Profiler**: The GPU Profiler focuses on monitoring the GPU usage of your
    game. It provides information about rendering performance, including the time
    spent on drawing calls, shaders, and graphics-related computations.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU分析器**：GPU分析器专注于监控游戏的GPU使用情况。它提供了有关渲染性能的信息，包括绘制调用、着色器和与图形相关的计算所花费的时间。'
- en: '**Memory Profiler**: This module tracks memory usage in your game, including
    allocations, deallocations, and memory leaks. It helps identify areas where memory
    is being used inefficiently or where resources are not managed properly.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分析器**：此模块跟踪游戏中的内存使用情况，包括分配、释放和内存泄漏。它有助于识别内存使用效率低下或资源管理不当的区域。'
- en: '**Audio Profiler**: The Audio Profiler monitors the performance of audio-related
    operations in your game, such as playing audio clips, mixing audio channels, and
    processing audio effects. It helps optimize audio performance and troubleshoot
    any issues related to audio playback.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频分析器**：音频分析器监控游戏中的音频相关操作性能，如播放音频剪辑、混合音频通道和处理音频效果。它有助于优化音频性能并解决与音频播放相关的问题。'
- en: '**Physics Profiler**: This module focuses on analyzing the performance of physics
    calculations in your game. It provides insights into the time spent on physics
    simulations, collisions, rigid body dynamics, and other physics-related computations.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理分析器**：此模块专注于分析游戏中的物理计算性能。它提供了关于物理模拟、碰撞、刚体动力学和其他与物理相关的计算所花费时间的见解。'
- en: '**UI Profiler**: The UI Profiler is specifically designed to analyze the performance
    of **user interface** (**UI**) elements in your game. It helps identify UI-related
    bottlenecks, such as layout calculations, rendering overhead, and event handling.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI分析器**：UI分析器专门设计用于分析游戏中的用户界面（UI）元素性能。它有助于识别与UI相关的瓶颈，例如布局计算、渲染开销和事件处理。'
- en: '**Network Profiler**: The Network Profiler monitors network activity in your
    game, including data transmission, latency, and network-related events. It helps
    optimize network performance and troubleshoot issues related to multiplayer networking
    or online gameplay.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络分析器**：网络分析器监控游戏中的网络活动，包括数据传输、延迟和网络相关事件。它有助于优化网络性能并解决与多人联网或在线游戏相关的问题。'
- en: '**Rendering Profiler**: This module focuses on analyzing rendering performance
    in your game. It provides insights into rendering overhead, draw calls, batching,
    and other graphics-related optimizations.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染分析器**：此模块专注于分析游戏中的渲染性能。它提供了关于渲染开销、绘制调用、批处理以及其他与图形相关的优化的见解。'
- en: Collectively, these modules provide a comprehensive view of your game’s performance,
    allowing you to identify and address performance issues effectively. By using
    the Unity Profiler’s various modules, we can optimize our games for better performance,
    smoother gameplay, and enhanced player experiences.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块共同为您提供了游戏性能的全面视图，使您能够有效地识别和解决性能问题。通过使用Unity分析器的各种模块，我们可以优化游戏以获得更好的性能、更流畅的游戏体验和增强的玩家体验。
- en: In this chapter, we will focus on the CPU Profiler and learn how to use it to
    identify performance related to the CPU.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注CPU分析器，并学习如何使用它来识别与CPU相关的性能问题。
- en: The CPU Profiler module
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU分析器模块
- en: The CPU Profiler module is an essential tool in Unity for analyzing the performance
    of your game. It provides a detailed breakdown of where your game spends its time
    during runtime, including areas such as rendering, scripting, and animation. This
    section delves into various aspects of the CPU Profiler module, covering chart
    categories, the module details pane, live settings, and more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CPU分析器模块是Unity中分析游戏性能的必备工具。它提供了游戏在运行时花费时间的详细分解，包括渲染、脚本和动画等领域。本节深入探讨了CPU分析器模块的各个方面，包括图表类别、模块详细信息面板、实时设置等。
- en: Chart categories
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图表类别
- en: The **CPU Usage** Profiler module’s chart categorizes the time spent on the
    game’s main thread into nine categories. These categories are **Rendering**, **Scripts**,
    **Physics**, **Animation**, **GarbageCollector**, **VSync**, **Global Illumination**,
    **UI**, and **Others**. By understanding the distribution of time across these
    categories, we can pinpoint areas of improvement and optimize our game’s performance
    accordingly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU使用率**分析器模块的图表将游戏主线程上花费的时间分为九个类别。这些类别是**渲染**、**脚本**、**物理**、**动画**、**垃圾回收器**、**垂直同步**、**全局照明**、**用户界面**和**其他**。通过了解这些类别的时间分布，我们可以确定改进的区域并相应地优化游戏性能。'
- en: 'By understanding each part and its role or impact, we can easily pinpoint the
    problem areas in scripts or animations. This allows us to focus our work on addressing
    these specific issues. You can refer to *Figure 9**.2* for the charts and their
    defined colors:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解每个部分及其作用或影响，我们可以轻松地确定脚本或动画中的问题区域。这使我们能够将工作重点放在解决这些具体问题上。您可以参考*图9.2*中的图表及其定义的颜色：
- en: '![Figure 9.2 – CPU module](img/B22017_09_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – CPU模块](img/B22017_09_02.jpg)'
- en: Figure 9.2 – CPU module
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – CPU模块
- en: 'In the following table, I have listed each category, along with common activities
    that may occur within it, indicating the time spent or the impact on performance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表格中，我列出了每个类别，以及可能在该类别中发生的常见活动，指出了所花费的时间或对性能的影响：
- en: '| **Category** | **Activities Performed in** **Real Time** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **实时执行的活动** |'
- en: '| Rendering | Processing data for the GPU and waiting for GPU operations. It
    includes tasks such as rendering meshes, handling shaders, managing textures,
    and other graphics-related computations. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 渲染 | 为GPU处理数据并等待GPU操作。这包括渲染网格、处理着色器、管理纹理以及其他与图形相关的计算任务。|'
- en: '| Scripts | `MonoBehaviour` update methods and coroutine executions. It involves
    executing script code, handling game logic, and managing interactions between
    game objects. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 脚本 | `MonoBehaviour`更新方法和协程执行。这涉及执行脚本代码、处理游戏逻辑以及管理游戏对象之间的交互。|'
- en: '| Physics | Executing physics simulations and related processes. including
    collision detection, rigid body interactions, joint handling, and other physics-related
    calculations. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 物理模拟 | 执行物理模拟和相关过程，包括碰撞检测、刚体交互、关节处理以及其他与物理相关的计算。|'
- en: '| Animation | Animation system processing and performance considerations, including
    processing keyframes, blend trees, animation state transitions, and other animation-related
    tasks. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 动画 | 动画系统处理和性能考虑，包括处理关键帧、混合树、动画状态转换以及其他与动画相关的任务。|'
- en: '| GarbageCollector | Garbage collection and memory allocation activities, which
    include memory allocation, deallocating unused memory, managing object life cycles,
    and optimizing memory usage. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 垃圾回收器 | 垃圾回收和内存分配活动，包括内存分配、释放未使用的内存、管理对象生命周期以及优化内存使用。|'
- en: '| VSync | Waiting for vertical synchronization activities. This includes syncing
    the frame rate of the game with the refresh rate of the display, ensuring smooth
    and tear-free rendering. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| VSync | 等待垂直同步活动。这包括将游戏帧率与显示刷新率同步，确保平滑且无撕裂的渲染。|'
- en: '| Global Illumination | Global illumination includes calculations related to
    lighting in scenes, such as lightmap baking, real-time GI computations, light
    probes, and reflection probes. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 全局照明 | 全局照明包括与场景中的照明相关的计算，例如光照贴图烘焙、实时GI计算、光照探针和反射探针。|'
- en: '| UI | UI activities involve rendering and interactive elements, such as canvases,
    text elements, buttons, panels, and other UI components. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| UI | UI活动涉及渲染和交互元素，例如画布、文本元素、按钮、面板以及其他UI组件。|'
- en: '| Others | These are additional CPU activities that are not part of the other
    categories. This can include various engine tasks, editor-related activities,
    audio processing, networking tasks, and other miscellaneous computations that
    occur during runtime but don’t fit into the defined categories. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | 这些是其他类别之外的附加CPU活动。这可能包括各种引擎任务、与编辑器相关的活动、音频处理、网络任务以及其他在运行时发生但不符合定义的类别的不规则计算。|'
- en: Understanding the activities within each category allows us to target specific
    areas based on our optimization requirements for the project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每个类别内的活动使我们能够根据项目的优化需求针对特定区域。
- en: Module details pane
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块详细信息面板
- en: 'You have the option to display the selected frame in three different views,
    allowing you to discern how to switch between them, as shown in *Figure 9**.3*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择以三种不同的视图显示所选帧，让您能够了解如何在这之间切换，如图 *图9**.3* 所示：
- en: '![Figure 9.3 – Views dropdown](img/B22017_09_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 视图下拉菜单](img/B22017_09_03.jpg)'
- en: Figure 9.3 – Views dropdown
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 视图下拉菜单
- en: 'Let’s understand how these views work:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这些视图是如何工作的：
- en: '**Timeline**: This view provides an overview of time distribution across different
    threads on a single time axis, aiding visualization of parallel execution'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：此视图提供了在不同线程上的单个时间轴上时间分布的概述，有助于可视化并行执行'
- en: '**Hierarchy**: This view groups timing data by internal hierarchical structure,
    offering detailed insights into function calls and memory allocations'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：此视图按内部层次结构分组时间数据，提供了关于函数调用和内存分配的详细见解'
- en: '**Raw Hierarchy**: This is similar to the **Hierarchy** view but provides additional
    details about performance warnings and thread groupings'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始层次结构**：这与**层次结构**视图类似，但提供了关于性能警告和线程分组的额外详细信息'
- en: Now that we’re aware of the available views in the Profiler, we can switch between
    them to gain a better understanding of how the frame operates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了分析器中可用的视图，我们可以切换它们以更好地了解帧的工作方式。
- en: Using Live settings while profiling
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在分析时使用实时设置
- en: The “Live” setting in the Unity CPU Profiler provides a dynamic and immediate
    view of performance metrics as we interact with our game, enabling efficient on-the-fly
    analysis and optimization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Unity CPU分析器中的“实时”设置提供了我们在与游戏交互时的性能指标动态和即时视图，使我们能够进行高效的即时分析和优化。
- en: 'Let’s enable Live settings and see how it works:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启用实时设置并看看它是如何工作的：
- en: Enable the Live setting in the CPU Profiler module before you start recording.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始录制之前，在CPU分析器模块中启用实时设置。
- en: As we interact with our game and trigger different events, the Profiler immediately
    displays real-time information about the current frame in the details pane.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们与游戏交互并触发不同事件时，分析器立即在详细信息面板中显示关于当前帧的实时信息。
- en: We can see how each action affects CPU usage, memory allocation, and other performance
    metrics instantly.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以立即看到每个动作如何影响CPU使用率、内存分配以及其他性能指标。
- en: This real-time feedback allows us to identify performance bottlenecks quickly,
    make adjustments on the fly, and see the impact of optimizations immediately.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种实时反馈使我们能够快速识别性能瓶颈，即时进行调整，并立即看到优化的影响。
- en: 'We can also enable the **Show Full Scripting Method Names** option to display
    the full method names. This can be particularly useful when you’re dealing with
    complex scripts or when you need precise visibility into the functions being executed.
    You can enable this option through the settings, as shown in *Figure 9**.4*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以启用**显示完整脚本方法名称**选项来显示完整的方法名称。这在处理复杂脚本或需要精确了解正在执行的功能时特别有用。您可以通过设置启用此选项，如图
    *图9**.4* 所示：
- en: '![Figure 9.4 – Show Full Scripting Method Names](img/B22017_09_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 显示完整的脚本方法名称](img/B22017_09_04.jpg)'
- en: Figure 9.4 – Show Full Scripting Method Names
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 显示完整的脚本方法名称
- en: Before diving into the practical part, it’s essential to understand common Profiler
    markers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实际部分之前，理解常见的 Profiler 标记是至关重要的。
- en: Common markers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见标记
- en: Unity’s code is instrumented with various Profiler markers, offering insights
    into performance-critical tasks and areas of optimization. By leveraging these
    markers, we can identify bottlenecks and streamline performance-critical operations,
    enhancing the overall efficiency and responsiveness of our games.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的代码被各种 Profiler 标记所增强，提供了对性能关键任务和优化区域的洞察。通过利用这些标记，我们可以识别瓶颈并简化性能关键操作，从而提高我们游戏的整体效率和响应速度。
- en: 'Unity’s code is marked with numerous Profiler indicators that offer insights
    into the performance of your game. These markers are invaluable for identifying
    bottlenecks and optimizing your code. Let’s delve into the main categories of
    Profiler markers and their functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的代码带有许多 Profiler 指示器，这些指示器提供了对您游戏性能的洞察。这些标记对于识别瓶颈和优化您的代码非常有价值。让我们深入了解
    Profiler 标记的主要类别及其功能：
- en: '**Main thread** **base markers**:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主线程** **基本标记**：'
- en: 'The main thread base markers serve to differentiate between time spent on your
    game and time devoted to Editor and Profiler tasks. These markers are crucial
    for understanding the timing of frames on the main thread. Here are some examples:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主线程基本标记用于区分在您的游戏上花费的时间和在编辑器和 Profiler 任务上花费的时间。这些标记对于理解主线程上的帧时间至关重要。以下是一些示例：
- en: '**PlayerLoop**: Contains samples originating from your game’s main loop. When
    targeting the Editor while the Player is active, **PlayerLoop** samples the nest
    under **EditorLoop**.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PlayerLoop**：包含来自您游戏主循环的样本。当在玩家活动时针对编辑器，**PlayerLoop** 样本在 **EditorLoop**
    之下。'
- en: '**EditorLoop** (Editor-only marker): Contains samples from the Editor’s main
    loop when profiling a player in the Editor. **EditorLoop** samples indicate time
    spent rendering and running the Editor alongside the Player.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EditorLoop**（仅编辑器标记）：包含在编辑器中分析玩家时的编辑器主循环的样本。**EditorLoop** 样本表示在玩家和编辑器同时运行时渲染和执行编辑器所花费的时间。'
- en: '**Profiler.CollectEditorStats** (Editor-only marker): Includes samples related
    to collecting statistics for active Profiler modules. These samples provide insight
    into the overhead that’s incurred by the Player when collecting module statistics.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Profiler.CollectEditorStats**（仅编辑器标记）：包括与收集活动 Profiler 模块统计信息相关的样本。这些样本提供了关于玩家在收集模块统计信息时产生的开销的洞察。'
- en: '**Editor-only markers**:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅编辑器标记**：'
- en: 'Certain markers exclusively appear when profiling in Unity Editor, offering
    insights into Editor-specific activities such as security checks and Prefab-related
    tasks. Here is an example:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 某些标记仅在 Unity 编辑器中进行分析时才会出现，提供了对编辑器特定活动（如安全检查和预制件相关任务）的洞察。以下是一个示例：
- en: '**GetComponentNullErrorWrapper**: A marker exclusive to the Unity Editor, aiding
    in identifying null component usage'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetComponentNullErrorWrapper**：一个仅适用于 Unity 编辑器的标记，有助于识别空组件的使用'
- en: '`MonoBehaviour` update methods and coroutine executions. Here is an example:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 更新方法和协程执行。以下是一个示例：'
- en: '**BehaviourUpdate**: Contains all samples of **MonoBehaviour.Update** methods'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BehaviourUpdate**：包含所有 **MonoBehaviour.Update** 方法的样本'
- en: '**Rendering and** **VSync markers**:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染和** **VSync 标记**：'
- en: 'These markers reveal CPU activities related to processing data for the GPU
    and waiting for GPU operations to complete. Here is an example:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些标记揭示了与处理 GPU 数据和等待 GPU 操作完成相关的 CPU 活动。以下是一个示例：
- en: '**WaitForTargetFPS**: Indicates the time spent waiting for the targeted FPS
    specified by **Application.targetFrameRate**'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WaitForTargetFPS**：表示等待由 **Application.targetFrameRate** 指定的目标帧率的所花费的时间'
- en: '**Backend** **scripting markers**:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端** **脚本标记**：'
- en: 'These markers highlight scripting backend activities, aiding in troubleshooting
    issues related to garbage collection and memory allocation. Here is an example:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些标记突出了脚本后端活动，有助于解决与垃圾收集和内存分配相关的问题。以下是一个示例：
- en: '**GC.Alloc**: Represents an allocation in the managed heap, subject to automatic
    garbage collection'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GC.Alloc**：表示在托管堆中的分配，受自动垃圾收集的影响'
- en: '**Multithreading markers**:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多线程标记**：'
- en: 'These markers focus on thread synchronization and the Job System, offering
    information about parallel processing and sync points. Here is an example:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些标记专注于线程同步和作业系统，提供了有关并行处理和同步点的信息。以下是一个示例：
- en: '**Idle**: Contains samples indicating the length of time a Worker Thread remains
    inactive'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲**：包含表示Worker线程保持不活跃时间的样本'
- en: '**Physics markers**:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理标记符**：'
- en: 'Physics markers provide insights into the execution of physics simulations
    and related processes such as collision detection and joint handling. Here is
    an example:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 物理标记符提供了对物理模拟及其相关过程（如碰撞检测和关节处理）执行的洞察。以下是一个示例：
- en: '**Physics.FetchResults**: Contains samples that collect the results of the
    physics simulation from the physics engine'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Physics.FetchResults**：包含收集物理引擎中物理模拟结果的样本'
- en: '**Animation markers**:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画标记**：'
- en: 'These markers pertain to the Animation system, offering details on animation
    processing stages and performance considerations. Here is an example:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些标记符与动画系统相关，提供了关于动画处理阶段和性能考虑的详细信息。以下是一个示例：
- en: '**Director.PrepareFrame**: Schedules and awaits **Director.PrepareFrameJob**
    jobs, evaluating the state machines for active Animator components'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Director.PrepareFrame**：安排并等待**Director.PrepareFrameJob**作业，评估活动Animator组件的状态机'
- en: '**Performance warnings**:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能警告**：'
- en: 'The CPU Profiler identifies common performance issues and displays warnings
    to alert developers, helping them optimize their code effectively. Here is an
    example:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CPU剖析器识别常见的性能问题，并向开发者显示警告，帮助他们有效地优化代码。以下是一个示例：
- en: '**Animation.DestroyAnimationClip**: Indicates a performance issue with calls
    related to destroying **AnimationClips**, triggering resource-intensive operations'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Animation.DestroyAnimationClip**：指示与销毁**AnimationClips**相关的调用存在性能问题，触发资源密集型操作'
- en: With a thorough understanding of these Profiler markers, we can pinpoint performance
    bottlenecks and optimize our Unity games for enhanced efficiency and responsiveness.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对这些剖析标记符的深入了解，我们可以定位性能瓶颈，并优化我们的Unity游戏以增强效率和响应性。
- en: 'You can learn more about common markers in the official Unity documentation:
    [https://docs.unity3d.com/Manual/profiler-markers.html](https://docs.unity3d.com/Manual/profiler-markers.html).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方Unity文档中了解更多关于常见标记符的信息：[https://docs.unity3d.com/Manual/profiler-markers.html](https://docs.unity3d.com/Manual/profiler-markers.html)。
- en: By becoming familiar with the common markers, we’ve seen that they prove to
    be invaluable tools in our optimization journey. They allow us to concentrate
    on specific areas efficiently, ensuring that our efforts are both effective and
    precise.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过熟悉常见的标记符，我们发现它们在我们的优化之旅中证明是无价之宝。它们使我们能够高效地专注于特定区域，确保我们的努力既有效又精确。
- en: Understanding the profiling process
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解剖析过程
- en: Let’s discuss general tips for the profiling process, including how to identify
    bottlenecks and gain a better understanding of the entire process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论剖析过程的一般技巧，包括如何识别瓶颈并更好地理解整个过程。
- en: 'Profiling is most effective when it’s used at three specific times:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 剖析在以下三个特定时间使用时最为有效：
- en: Establish a baseline by profiling before implementing major changes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实施重大更改之前，通过剖析建立基线
- en: Track changes during development and ensure they do not negatively impact performance
    or exceed resource budgets
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中跟踪更改，并确保它们不会对性能产生负面影响或超出资源预算
- en: After development, profile again to confirm that the changes that have been
    made have achieved the desired improvements in performance
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发完成后，再次进行剖析以确认所做的更改已实现预期的性能改进
- en: Avoid profiling until you identify issues in your game. Additionally, refrain
    from excessive profiling; determine the required frame rate for your game. Each
    frame should adhere to a time budget aligned with your target **frames per second**
    (**FPS**). For instance, a game aiming for 30 FPS should consume less than 33.33
    ms per frame (1,000 ms divided by 30 FPS). Similarly, targeting 60 FPS allows
    for 16.66 ms per frame.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定你的游戏中存在问题时再进行剖析。此外，避免过度剖析；确定你游戏所需的帧率。每一帧都应该遵循与你的目标**每秒帧数**（**FPS**）相匹配的时间预算。例如，目标为30
    FPS的游戏每帧应消耗少于33.33毫秒（1,000毫秒除以30 FPS）。同样，目标为60 FPS允许每帧16.66毫秒。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Achieving the most precise profiling outcomes necessitates running and profiling
    builds directly on the intended target devices.Top of Form
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现最精确的剖析结果，需要在目标设备上直接运行和剖析构建。表单顶部
- en: Identifying bottlenecks
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别瓶颈
- en: You should determine whether your game is CPU- or GPU-bound so that you can
    focus your optimization efforts correctly. For instance, note that while VSync
    is optional on all platforms, it’s typically enabled on mobile devices and may
    contribute to CPU time waiting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该确定你的游戏是CPU绑定还是GPU绑定，这样你就可以正确地集中优化努力。例如，请注意，虽然VSync在所有平台上都是可选的，但在移动设备上通常启用，可能会对CPU时间等待做出贡献。
- en: '**VSync**, short for **Vertical Synchronization**, is a graphics technology
    that synchronizes the frame rate of a game with the refresh rate of the monitor
    or display device. This synchronization prevents issues such as screen tearing,
    where parts of different frames appear on the screen simultaneously, leading to
    a visually jarring experience. VSync ensures that each frame is displayed in full
    before the next frame is rendered, creating a smoother and more visually pleasing
    experience for the player.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**VSync**，即**垂直同步**，是一种图形技术，它将游戏的帧率与显示器或显示设备的刷新率同步。这种同步防止了屏幕撕裂等问题，即不同帧的部分同时出现在屏幕上，导致视觉上的冲击。VSync确保在渲染下一帧之前，每个帧都完整显示，为玩家创造更平滑、更视觉上愉悦的体验。'
- en: 'The performance of a project is determined by the chip or thread that requires
    the most time to process. This area is where optimization efforts should be concentrated.
    For instance, consider a game with a target frame time budget of 16.66 ms with
    VSync enabled:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目的性能由需要最多时间处理的芯片或线程决定。这是优化努力应该集中的地方。例如，考虑一个目标帧时间预算为16.66 ms且启用了VSync的游戏：
- en: If the CPU frame time (excluding VSync) is 10 ms and the GPU time is 12 ms,
    there’s no issue as both are within budget.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果CPU帧时间（不包括VSync）为10 ms，而GPU时间为12 ms，那么没有问题，因为两者都在预算范围内。
- en: If the CPU frame time is 20 ms and the GPU time is 12 ms, the CPU performance
    needs to be optimized as the GPU won’t benefit from optimization. Consider transferring
    some CPU tasks to the GPU.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果CPU帧时间为20 ms，而GPU时间为12 ms，则需要优化CPU性能，因为GPU不会从优化中受益。考虑将一些CPU任务转移到GPU上。
- en: If the CPU frame time is 8 ms and the GPU time is 20 ms, focus on optimizing
    the GPU workload as it is GPU-bound.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果CPU帧时间为8 ms，而GPU时间为20 ms，则应专注于优化GPU工作负载，因为它受GPU绑定。
- en: If both the CPU and GPU times are at 20 ms, you’re bound by both and need to
    optimize them below 16.66 ms to achieve a frame rate of 60 FPS.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果CPU和GPU的时间都为20 ms，那么你将受到两者的限制，需要将它们优化到16.66 ms以下才能达到60 FPS的帧率。
- en: We’ll learn more about CPU- and GPU-bound issues in the following subsections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将了解更多关于CPU和GPU绑定问题的内容。
- en: CPU-bound issues
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CPU绑定问题
- en: 'It’s considered a CPU-bound issue when the CPU time exceeds the allocated time
    budget. Let’s walk through an example to illustrate how to identify and resolve
    such issues using the Profiler. Utilizing the **Timeline** and **Hierarchy** views
    in the Profiler helps us gain a clearer understanding of the specific issue. Refer
    to *Figure 9**.5* for detailed information on a spike frame:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU时间超过分配的时间预算时，被认为是CPU绑定问题。让我们通过一个例子来说明如何使用Profiler来识别和解决此类问题。利用Profiler中的**时间轴**和**层次结构**视图可以帮助我们更清楚地了解具体问题。请参阅*图9**.5*以获取关于峰值帧的详细信息：
- en: '![Figure 9.5 – A spike frame](img/B22017_09_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 峰值帧](img/B22017_09_05.jpg)'
- en: Figure 9.5 – A spike frame
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 峰值帧
- en: The `gfx.waitForCommandsFromMainThread` marker indicates a potential bottleneck
    on the main thread that affects overall performance. This occurs when the render
    thread waits for commands from the main thread, suggesting that tasks or commands
    that are being processed on the CPU are taking longer. Consequently, the game
    experiences a CPU-bound issue, causing delays in rendering. Addressing these bottlenecks
    and optimizing CPU-bound issues can significantly enhance game performance and
    responsiveness.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`gfx.waitForCommandsFromMainThread`标记表示主线程上可能存在的瓶颈，这会影响整体性能。这发生在渲染线程等待来自主线程的命令时，表明正在CPU上处理的任务或命令需要更长的时间。因此，游戏出现CPU绑定问题，导致渲染延迟。解决这些瓶颈和优化CPU绑定问题可以显著提高游戏性能和响应速度。'
- en: Identify the CPU bottleneck by analyzing which thread is the most active. Profiling
    helps pinpoint bottlenecks accurately for focused optimization. Guesswork can
    lead to ineffective optimizations or even worsen performance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析哪个线程最活跃来识别CPU瓶颈。性能分析有助于准确定位瓶颈，以便进行针对性的优化。猜测可能导致无效的优化甚至降低性能。
- en: 'The primary threads for identifying performance issues typically include the
    following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 识别性能问题的主要线程通常包括以下内容：
- en: '**The main thread**: This thread handles game logic and script execution, including
    tasks related to physics, animation, UI, and rendering. It accounts for a significant
    portion of the processing time.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主线程**：此线程处理游戏逻辑和脚本执行，包括与物理、动画、UI和渲染相关的任务。它占用了相当一部分的处理时间。'
- en: '**The render thread**: This thread is responsible for processing scene elements
    during rendering, such as camera culling, depth sorting, and draw call batching.
    It converts Unity’s scene representation into specific graphics API calls for
    GPU rendering.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染线程**：此线程负责在渲染过程中处理场景元素，例如相机剔除、深度排序和绘制调用批处理。它将Unity的场景表示转换为特定图形API调用以进行GPU渲染。'
- en: '**The job worker threads**: These threads utilize the C# Job System to offload
    specific tasks onto separate Worker Threads, reducing the main thread’s workload.
    Various Unity systems, such as physics, animation, and rendering, also leverage
    the Job System for improved performance.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作线程**：这些线程利用C#作业系统将特定任务卸载到单独的工作线程上，从而减少主线程的工作负载。Unity的各种系统，如物理、动画和渲染，也利用作业系统来提高性能。'
- en: You need to identify any loops in your code where spikes occur, determine what
    is causing the high CPU usage or prolonged processing time, and investigate if
    it corresponds to a common marker in the Profiler. Understanding the meaning of
    these markers helps you address the issue effectively. Optimize your code based
    on your findings, monitor the Profiler again after applying fixes, and continue
    this iterative process until you achieve your target frame rate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要识别代码中任何出现峰值的地方，确定导致高CPU使用率或处理时间延长的原因，并调查它是否对应于Profiler中的常见标记。理解这些标记的含义有助于您有效地解决问题。根据您的发现优化代码，在应用修复后再次监控Profiler，并继续此迭代过程，直到达到目标帧率。
- en: GPU-bound issues
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPU受限问题
- en: If your game experiences prolonged activity in Profiler markers such as `Gfx
    WaitForPresentOnGfxThread`, indicating idle time for the render thread, and simultaneously
    shows markers such as `Gfx PresentFrame` or `<GraphicsAPIName> WaitForLastPresent`,
    it suggests a GPU-bound scenario. In this context, GPU-boundness is characterized
    by heavy GPU utilization and potential delays in frame rendering and presentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的游戏在Profiler标记如`Gfx WaitForPresentOnGfxThread`（表示渲染线程的空闲时间）上出现长时间活动，同时显示如`Gfx
    PresentFrame`或`<GraphicsAPIName> WaitForLastPresent`等标记，这表明是一个GPU受限的场景。在这种情况下，GPU受限的特征是GPU利用率高，以及帧渲染和展示可能出现的延迟。
- en: If your game appears to be heavily using the GPU, you can use the Frame Debugger
    to quickly examine the batches of draw calls that are sent to the GPU. I’ll discuss
    this tool in more detail in the next section. However, it’s essential to note
    that while the Frame Debugger provides insights into scene construction, it doesn’t
    offer specific GPU timing details. So, you can switch between the Profiler and
    the Frame Debugger to fix any issues related to GPU.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的游戏看起来大量使用GPU，您可以使用帧调试器快速检查发送到GPU的绘制调用批次。我将在下一节中更详细地讨论此工具。然而，重要的是要注意，尽管帧调试器可以提供对场景构建的见解，但它不提供具体的GPU时间细节。因此，您可以在Profiler和帧调试器之间切换，以修复任何与GPU相关的问题。
- en: 'Let’s explore the factors that can lead to GPU performance issues in our projects.
    The following are some common issues:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨可能导致我们项目中GPU性能问题的因素。以下是一些常见问题：
- en: Complex particle systems with a high number of particles or intricate behaviors
    can impact GPU performance
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有大量粒子或复杂行为的复杂粒子系统可能会影响GPU性能
- en: Real-time reflections or refractions, particularly in scenes with many reflective
    surfaces, can be GPU-intensive
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时反射或折射，尤其是在有许多反射表面的场景中，可能会对GPU造成大量负载
- en: Shader permutations or shader variants for different materials or effects can
    increase GPU workload, especially if they’re not managed efficiently
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器排列或针对不同材质或效果的着色器变体可能会增加GPU的工作负载，尤其是如果它们没有被高效管理的话
- en: Dynamic weather or environmental effects, such as rain, fog, or dynamic skies,
    can add GPU overhead if they’re not optimized
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态天气或环境效果，如雨、雾或动态天空，如果未进行优化，可能会增加GPU开销
- en: Dynamic Occlusion culling and visibility calculations can affect GPU performance,
    especially in scenes with complex geometry or many moving objects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态遮挡剔除和可见性计算可能会影响GPU性能，尤其是在具有复杂几何形状或许多移动对象的场景中
- en: High screen resolutions, especially 4K displays or retina displays on mobile
    devices, can put a heavy load on the GPU
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高屏幕分辨率，尤其是4K显示器或移动设备上的视网膜显示器，可能会对GPU造成沉重的负载
- en: 'Here are some useful tips while using the Profiler:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Profiler时，以下是一些有用的提示：
- en: Turn off the **VSync** and **Others** categories in the **CPU Usage** Profiler
    module. The **VSync** marker indicates periods of inactivity in the CPU’s main
    thread, and hiding these markers can enhance the clarity of your profiling analysis.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**CPU使用率**Profiler模块中关闭**VSync**和**其他**类别。**VSync**标记表示CPU主线程的不活跃期，隐藏这些标记可以增强你的性能分析分析的清晰度。
- en: Disable **VSync** in your project build to gain a clear understanding of the
    interactions between the main thread, render thread, and GPU. Profiling a build
    with **VSync** disabled can simplify the interpretation of profiler data.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的项目构建中禁用**VSync**，以清晰地了解主线程、渲染线程和GPU之间的交互。禁用**VSync**的性能分析构建可以简化Profiler数据的解释。
- en: Be mindful of when to conduct profiling in either Play mode or Editor mode.
    Utilize Play mode for profiling game performance and Editor mode for monitoring
    Unity Editor processes. Profiling the Editor can aid in identifying performance
    bottlenecks and improving productivity.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意在播放模式或编辑模式中何时进行性能分析。使用播放模式进行游戏性能分析，使用编辑模式监控Unity编辑器进程。对编辑器进行性能分析有助于识别性能瓶颈并提高生产力。
- en: Opt for profiling in the Editor when you need to quickly iterate on resolving
    performance issues. After identifying problems, use Play mode profiling to efficiently
    iterate on changes and validate solutions.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要快速迭代解决性能问题时，选择在编辑器中进行性能分析。在识别问题后，使用播放模式性能分析来高效迭代更改并验证解决方案。
- en: Optimizing graphics performance and identifying rendering bottlenecks in Unity
    becomes streamlined and efficient with the powerful capabilities of the Frame
    Debugger tool. We’ll dive deeper into this in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 利用帧调试器的强大功能，优化Unity中的图形性能和识别渲染瓶颈变得流畅且高效。我们将在下一节中深入了解这一点。
- en: The Frame Debugger
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧调试器
- en: The Frame Debugger is a powerful tool that’s used for analyzing and debugging
    the rendering process of a frame in your game. It allows you to inspect each step
    involved in rendering, such as draw calls, batching, textures, and materials.
    This tool is crucial for optimizing graphics performance and identifying rendering
    bottlenecks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 帧调试器是一个强大的工具，用于分析和调试游戏中帧的渲染过程。它允许你检查渲染过程中涉及的每个步骤，如绘制调用、批量处理、纹理和材质。这个工具对于优化图形性能和识别渲染瓶颈至关重要。
- en: 'You can open the **Frame Debugger** tool from the **Window** | **Analysis**
    | **Frame** **Debugger** menu:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从**窗口** | **分析** | **帧** **调试器**菜单打开**帧调试器**工具：
- en: '![Figure 9.6 – Frame Debugger](img/B22017_09_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 帧调试器](img/B22017_09_06.jpg)'
- en: Figure 9.6 – Frame Debugger
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 帧调试器
- en: Now that we’ve learned how to open the Frame Debugger, let’s explore how it
    works and what it does.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何打开帧调试器，让我们探索它是如何工作的以及它做了什么。
- en: Understanding how the Frame Debugger operates
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解帧调试器的工作原理
- en: The Frame Debugger works by intercepting and analyzing the rendering commands
    that are sent to the graphics API (for example, DirectX or OpenGL). It captures
    information about each draw call, including the shaders, textures, materials,
    and meshes involved. This captured data is then presented in a visual interface,
    allowing developers to inspect and understand the rendering pipeline of a frame.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 帧调试器通过拦截和分析发送到图形API（例如DirectX或OpenGL）的渲染命令来工作。它捕获有关每个绘制调用的信息，包括涉及的着色器、纹理、材质和网格。然后，这些捕获的数据以可视化界面呈现，使开发者能够检查和理解帧的渲染管道。
- en: The Frame Debugger operates in real time, meaning you can pause the game in
    Play mode, analyze the current frame’s rendering, and make optimizations on the
    fly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 帧调试器实时运行，这意味着你可以在播放模式下暂停游戏，分析当前帧的渲染，并即时进行优化。
- en: Exploring the key functions of the Frame Debugger
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索帧调试器的关键功能
- en: 'The primary functions of the Frame Debugger are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 帧调试器的主要功能如下：
- en: Capturing and displaying each draw call that’s made during the rendering process
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获并显示在渲染过程中进行的每个绘制调用
- en: Showing how objects are batched together for optimized rendering performance
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示如何将对象批量处理以优化渲染性能
- en: Providing details about the shaders, textures, materials, and meshes that are
    used in rendering
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有关在渲染过程中使用的着色器、纹理、材质和网格的详细信息
- en: Identifying render targets and offscreen render textures
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别渲染目标和离屏渲染纹理
- en: 'Let’s explore the Frame Debugger. This is what the **Frame Debugger** window
    looks like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索帧调试器。这是**帧调试器**窗口的外观：
- en: '![Figure 9.7 – The Frame Debugger window has been enabled](img/B22017_09_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 帧调试器窗口已启用](img/B22017_09_07.jpg)'
- en: Figure 9.7 – The Frame Debugger window has been enabled
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 帧调试器窗口已启用
- en: 'After enabling the Frame Debugger, the game will pause, and you’ll be able
    to view all graphics-related details for that frame. This includes every draw
    call from the initial black screen to the current scene. In Unity 2022, which
    is the version we’re using, the Frame Debugger features an **Output / Mesh** section
    with two tabs: one displaying the full output or current state of the graphics/scene,
    and the other showing the drawn mesh, such as the example of a palm tree in this
    instance. You can see this mesh in *Figure 9**.8*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 启用帧调试器后，游戏将暂停，你将能够查看该帧的所有图形相关细节。这包括从初始黑屏到当前场景的每个绘制调用。在 Unity 2022 中，这是我们使用的版本，帧调试器具有一个
    **输出/网格** 部分带有两个标签：一个显示图形/场景的完整输出或当前状态，另一个显示绘制的网格，例如本例中的棕榈树示例。你可以在 *图 9.8* 中看到这个网格：
- en: '![Figure 9.8 – Mesh Preview](img/B22017_09_08.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 网格预览](img/B22017_09_08.jpg)'
- en: Figure 9.8 – Mesh Preview
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 网格预览
- en: 'The details about each draw call will be presented in a separate section that
    contains important information such as **RenderTarget**, **Vertices**, **Indices**,
    and **Used Shader**:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绘制调用的详细信息将在一个包含重要信息（如 **渲染目标**、**顶点**、**索引** 和 **使用的着色器**）的单独部分中展示：
- en: '![Figure 9.9 – The Details section](img/B22017_09_09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 详细信息部分](img/B22017_09_09.jpg)'
- en: Figure 9.9 – The Details section
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 详细信息部分
- en: 'Additionally, the Frame Debugger includes sections for the used **Textures**,
    **Vectors**, **Floats**, and other sections, as shown in *Figure 9**.10*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，帧调试器还包括用于使用的 **纹理**、**向量**、**浮点数**和其他部分的区域，如图 *图 9.10* 所示：
- en: '![Figure 9.10 – The other sections in the Frame Debugger](img/B22017_09_10.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 帧调试器中的其他部分](img/B22017_09_10.jpg)'
- en: Figure 9.10 – The other sections in the Frame Debugger
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 帧调试器中的其他部分
- en: Once you have identified the contents of the frame, the optimization process
    depends on employing specific strategies and techniques tailored to the unique
    aspects of each game. Addressing issues requires thorough research to pinpoint
    areas for optimization, and this process often involves iterative steps to achieve
    optimal performance. One of the most important ways to reduce draw calls is to
    use batching. Let’s take a closer look.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了帧的内容，优化过程就取决于采用针对每个游戏独特方面的特定策略和技术。解决问题需要彻底研究以确定优化区域，这个过程通常涉及迭代步骤以达到最佳性能。减少绘制调用的最重要方法之一是使用批处理。让我们更详细地看看。
- en: Draw call batching
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制调用批处理
- en: 'Draw call batching refers to a technique that’s used for optimizing draw calls
    by merging meshes, allowing Unity to render them in fewer draw calls. Unity offers
    two default draw call batching methods:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制调用批处理是一种通过合并多边形来优化绘制调用的技术，允许 Unity 在更少的绘制调用中渲染它们。Unity 提供了两种默认的绘制调用批处理方法：
- en: '**Static batching**:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态批处理**：'
- en: In this process, Unity combines and renders static GameObjects together.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此过程中，Unity 将静态游戏对象合并并一起渲染。
- en: 'Static batching in Unity refers to the process of optimizing draw calls by
    combining meshes either at build time or during runtime. When using static batching,
    it’s essential to ensure that certain criteria are met for GameObjects to be eligible
    for static batching:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity 中的静态批处理是指通过在构建时间或运行时合并网格来优化绘制调用的过程。当使用静态批处理时，确保某些标准得到满足对于游戏对象有资格进行静态批处理至关重要：
- en: The GameObject must be active
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象必须处于活动状态
- en: It should have a **Mesh Filter** component that is enabled and references a
    mesh with a vertex count greater than 0
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该有一个启用的 **网格过滤器** 组件，并引用一个顶点数大于 0 的网格
- en: The GameObject should also have a **Mesh Renderer** component that is enabled
    and uses a material without a shader that disables batching
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象还应有一个启用的 **网格渲染器** 组件，并使用一个没有禁用批处理的着色器的材质
- en: Meshes that are to be batched together must share the same vertex attributes
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要一起批处理的多边形必须共享相同的顶点属性
- en: When utilizing static batching, Unity allows the entire batch of meshes to be
    transformed collectively, such as moving, rotating, or scaling them as a single
    entity. However, transformations cannot be applied to individual meshes within
    the batch.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用静态批处理时，Unity 允许整个批处理的多边形作为一个整体进行变换，例如移动、旋转或缩放它们。然而，不能对批处理内的单个多边形应用变换。
- en: It’s worth noting that enabling read/write access for the mesh is necessary
    to use runtime static batching effectively. Overall, static batching is a useful
    technique for optimizing draw calls and improving performance in Unity projects.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，为了有效地使用运行时静态批处理，必须启用对网格的读写访问。总的来说，静态批处理是优化绘制调用并提高Unity项目中性能的有用技术。
- en: '**Dynamic batching**:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态批处理**:'
- en: Dynamic batching is a process where Unity combines small meshes by transforming
    their vertices on the CPU and grouping similar vertices, ultimately rendering
    them in a single draw call.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动态批处理是一个过程，其中Unity通过在CPU上变换小网格的顶点并将相似顶点分组，最终在一个绘制调用中渲染它们。
- en: 'To enable dynamic batching for meshes in Unity, follow these steps:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在Unity中启用网格的动态批处理，请按照以下步骤操作：
- en: Navigate to **Edit** | **Project Settings** | **Player**.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**编辑** | **项目设置** | **玩家**。
- en: In the **Other Settings** section, activate the **Dynamic** **Batching** option.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**其他设置**部分，激活**动态批处理**选项。
- en: Unity will automatically group moving meshes into a single draw call if they
    meet the specified criteria.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它们满足指定的标准，Unity将自动将移动网格分组到一个单独的绘制调用中。
- en: Dynamic batching in Unity doesn’t work on GameObjects with mirrored transformations
    in their **Transform** components. For instance, if one GameObject has a scale
    of 1 and another has a scale of -1, Unity cannot batch them together.Top of Form
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity中的动态批处理不适用于在**Transform**组件中具有镜像变换的GameObject。例如，如果一个GameObject的缩放为1，而另一个为-1，Unity无法将它们一起批处理。
- en: In general, Unity combines draw calls for GameObjects using identical materials,
    so it’s crucial to maximize batching efficiency by sharing materials among multiple
    GameObjects. If you have two material assets that are almost identical except
    for their textures, consider merging the textures into a single, larger texture
    within the same atlas. This allows you to use a single material asset instead
    of two. When accessing shared material properties from a C# script, ensure that
    you use `Renderer.sharedMaterial` instead of `Renderer.material`. Using `Renderer.material`
    creates a duplicate of the material, preventing Unity from batching draw calls
    for that renderer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Unity会结合使用相同材质的GameObject的绘制调用，因此通过在多个GameObject之间共享材质来最大化批处理效率至关重要。如果你有两个几乎相同的材质资产，除了它们的纹理外，考虑将纹理合并到同一个图集中，从而创建一个更大的纹理。这允许你使用一个材质资产而不是两个。从C#脚本访问共享材质属性时，请确保使用`Renderer.sharedMaterial`而不是`Renderer.material`。使用`Renderer.material`会创建材质的副本，从而阻止Unity为该渲染器批处理绘制调用。
- en: 'The following are the additional methods you can utilize to decrease the number
    of draw call batches:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以利用的额外方法来减少绘制调用批次的数量：
- en: Use Occlusion culling to eliminate objects that are hidden behind foreground
    elements and minimize overdraw. Keep in mind that this may increase CPU processing,
    so use the Profiler to evaluate the impact of transferring the workload from GPU
    to CPU.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遮挡剔除来消除隐藏在前景元素后面的对象并最小化过度绘制。请注意，这可能会增加CPU处理，因此请使用Profiler评估将工作负载从GPU转移到CPU的影响。
- en: Employ GPU instancing to reduce batches, particularly for numerous objects that
    share the same mesh and material. Limiting the number of models in your scene
    can enhance performance, and with careful implementation, you can create a complex
    scene without repetitiveness.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPU实例化来减少批次，特别是对于共享相同网格和材质的多个对象。限制场景中的模型数量可以提高性能，并且通过谨慎的实现，你可以创建一个复杂而不会重复的场景。
- en: Leverage the SRP Batcher to decrease GPU setup between draw calls by grouping
    **Bind** and **Draw** GPU commands. To maximize SRP batching benefits, utilize
    multiple Materials but restrict them to a few compatible shader variants, such
    as the **Lit** and **Unlit** shaders in the **Universal Render Pipeline** (**URP**)
    and **High Definition Render Pipeline** (**HDRP**), minimizing variations between
    keyword combinations.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用SRP批处理器通过分组**绑定**和**绘制**GPU命令来减少绘制调用之间的GPU设置。为了最大化SRP批处理的优势，使用多个材质，但将它们限制在几个兼容的着色器变体上，例如**通用渲染管线**（**URP**）和**高清渲染管线**（**HDRP**）中的**Lit**和**Unlit**着色器，最小化关键字组合之间的差异。
- en: Utilizing these techniques can significantly enhance rendering performance and
    streamline the development process in Unity games.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些技术可以显著提高渲染性能并简化Unity游戏开发过程。
- en: Now, let’s explore the optimization techniques for various categories in any
    game to improve performance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨任何游戏中各种类别的优化技术，以提高性能。
- en: Performance optimization techniques
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化技术
- en: In this section, we will delve into the crucial aspects of performance optimization
    techniques in Unity. Performance optimization plays a pivotal role in ensuring
    that your game runs smoothly, utilizes system resources efficiently, and delivers
    a seamless experience to players. By implementing optimization techniques, analyzing
    performance data, and adopting efficient scripting practices, developers can significantly
    enhance their game’s performance and overall quality. Let’s explore these skills
    in detail to understand how they contribute to creating high-performance games
    in Unity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究 Unity 中性能优化技术的关键方面。性能优化在确保游戏运行顺畅、高效利用系统资源并向玩家提供无缝体验方面发挥着关键作用。通过实施优化技术、分析性能数据并采用高效的脚本实践，开发者可以显著提高他们游戏的表现力和整体质量。让我们详细探讨这些技能，以了解它们如何有助于在
    Unity 中创建高性能游戏。
- en: The following subsections cover key areas for optimization techniques.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子节涵盖了优化技术的关键领域。
- en: Physics and collisions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理和碰撞
- en: 'To boost the performance and efficiency of physics and collisions in Unity,
    strategic optimization techniques play a crucial role. Here, we’ll explore two
    such techniques and detail their respective problems, solutions, examples, and
    outcomes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高 Unity 中物理和碰撞的性能和效率，战略性的优化技术起着至关重要的作用。在这里，我们将探讨两种这样的技术，并详细说明它们各自的问题、解决方案、示例和结果：
- en: '**Collision** **layer masking**:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞层掩码**:'
- en: '**Problem**: There are unnecessary collision checks between objects that don’t
    interact with each other, leading to wasted computational resources.'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：存在不必要的碰撞检查，这些对象之间没有交互，导致计算资源浪费。'
- en: '**Solution**: Use collision layer masking to specify which layers should interact
    with each other, avoiding unnecessary collision checks.'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：使用碰撞层掩码指定哪些层应该相互交互，避免不必要的碰撞检查。'
- en: '**How it works**: Assign different layers to objects based on their interaction
    requirements. Configure the physics settings to only enable collisions between
    specific layers that need to interact.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作原理**：根据对象的交互需求分配不同的层。配置物理设置以仅启用需要交互的特定层之间的碰撞。'
- en: '**Example**: Let’s consider a 2D platformer game where the player character
    interacts with enemies, collectibles, and environmental obstacles. By assigning
    different layers to these objects (for example, Player, Enemy, Collectible, and
    Obstacle), you can configure the physics settings to enable collisions only between
    specific layers. Here’s an example:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：让我们考虑一个 2D 平台游戏，其中玩家角色与敌人、收藏品和环境障碍物交互。通过将这些对象分配到不同的层（例如，玩家、敌人、收藏品和障碍物），您可以配置物理设置以仅允许特定层之间的碰撞。以下是一个示例：'
- en: The Player layer interacts with the Enemy and Obstacle layers but not with the
    Collectible layer
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家层与敌人和障碍物层交互，但不与收藏品层交互
- en: The Enemy layer interacts with the Player and Obstacle layers but not with the
    Collectible layer
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人层与玩家和障碍物层交互，但不与收藏品层交互
- en: 'The Collectible layer does not interact with the Player, Enemy, or Obstacle
    layers:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收藏品层不与玩家、敌人或障碍物层交互：
- en: '![Figure 9.11 – Physics settings](img/B22017_09_11.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 物理设置](img/B22017_09_11.jpg)'
- en: Figure 9.11 – Physics settings
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 物理设置
- en: In your scripts, when performing collision checks using raycasts or collider
    triggers, you can apply layer masks to filter out unnecessary collisions. For
    instance, when you’re checking for enemy collisions, you can specify a layer mask
    that includes only the Enemy layer, ignoring collisions with collectibles or obstacles.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的脚本中，当使用射线投射或碰撞触发器执行碰撞检查时，您可以应用层掩码以过滤掉不必要的碰撞。例如，当您检查敌人碰撞时，您可以指定仅包括敌人层的层掩码，忽略与收藏品或障碍物的碰撞。
- en: '**Result**: A reduced number of collision checks and improved performance by
    eliminating unnecessary physics calculations.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：通过消除不必要的物理计算，减少了碰撞检查的数量并提高了性能。'
- en: In Unity, optimizing physics and collisions through collision layer masking
    involves strategically assigning layers, configuring physics settings, and applying
    layer masks to streamline collision checks and enhance performance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，通过碰撞层掩码优化物理和碰撞涉及战略性地分配层、配置物理设置以及应用层掩码以简化碰撞检查并提高性能。
- en: '**Simplified** **collision detection**:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化** **碰撞检测**：'
- en: '**Problem**: Full physics calculations for collision detection on objects that
    don’t require realistic physical interactions can be resource-intensive.'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：对于不需要真实物理交互的对象进行碰撞检测的完整物理计算可能会消耗大量资源。'
- en: '**Solution**: Use triggers as simplified collision detection for non-essential
    objects.'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：使用触发器作为非必要对象的简化碰撞检测。'
- en: '**How it works**: Triggers in Unity are collider components that detect when
    another collider enters or exits their volume without physically colliding with
    them. They are ideal for scenarios where you need to detect interactions without
    simulating physical forces.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何工作**：Unity中的触发器是碰撞组件，它们可以检测当另一个碰撞体进入或退出它们的体积时，而无需与它们发生物理碰撞。它们非常适合需要检测交互而不需要模拟物理力的场景。'
- en: '**Example**: In a game where collectible coins are scattered around the level,
    instead of using rigid body-based collisions for the coins, you can attach trigger
    colliders to them. When the player’s character overlaps with a coin’s trigger
    collider, you can handle the collection logic without the need for full physics
    calculations.'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：在一个游戏中，收集品硬币散布在关卡周围，而不是为硬币使用基于刚体的碰撞，你可以将触发碰撞体附加到硬币上。当玩家的角色与硬币的触发碰撞体重叠时，你可以处理收集逻辑，而无需进行完整的物理计算。'
- en: '**Result**: Using triggers reduces the computational overhead associated with
    physics calculations for objects that only require collision detection without
    physical responses. This leads to improved performance, especially in scenarios
    with a large number of non-essential objects.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：使用触发器可以减少仅需要碰撞检测而不需要物理响应的对象的物理计算相关的计算开销。这有助于提高性能，尤其是在有大量非必要对象的情况下。'
- en: This technique is beneficial for optimizing performance in scenarios where objects
    do not require detailed physics interactions but still need basic collision detection
    functionality. By using simplified collision detection methods, you can conserve
    computational resources and improve overall performance in your Unity project.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术在优化场景中非常有用，其中对象不需要详细的物理交互，但仍然需要基本的碰撞检测功能。通过使用简化的碰撞检测方法，你可以节省计算资源，并提高Unity项目的整体性能。
- en: Audio
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频
- en: 'Optimizing audio in Unity is crucial for maintaining a smooth and immersive
    gameplay experience. Let’s explore an advanced technique to reduce memory usage
    and improve audio performance in your game:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中优化音频对于保持流畅和沉浸式的游戏体验至关重要。让我们探索一种高级技术，以减少内存使用并提高游戏中的音频性能：
- en: '**Audio** **compression technique**:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频** **压缩技术**：'
- en: '**Problem**: Large audio files can consume significant memory, leading to performance
    issues.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：大音频文件会消耗大量内存，导致性能问题。'
- en: '**Solution**: Compress audio files using formats such as Ogg Vorbis or MP3
    to reduce memory usage without compromising quality. You can learn more about
    Unity’s importing settings by referring to the official Unity documentation at
    https://docs.unity3d.com/Manual/class-AudioClip.html#:~:text=Whenever%20importing%20a%20file%2C%20Unity,to%20the%20original%20as%20possible:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：使用Ogg Vorbis或MP3等格式压缩音频文件，以减少内存使用而不影响质量。你可以通过参考Unity官方文档了解更多关于Unity的导入设置：https://docs.unity3d.com/Manual/class-AudioClip.html#:~:text=Whenever%20importing%20a%20file%2C%20Unity,to%20the%20original%20as%20possible:'
- en: '![Figure 9.12 – Imported audio settings](img/B22017_09_12.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 导入音频设置](img/B22017_09_12.jpg)'
- en: Figure 9.12 – Imported audio settings
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 导入音频设置
- en: '**Example**: Compressing background music and sound effects in a game.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：在游戏中压缩背景音乐和音效。'
- en: '**Result**: Reduced memory footprint, faster loading times, and smoother gameplay.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：减少内存占用，加快加载时间，以及更流畅的游戏体验。'
- en: By employing advanced audio optimization techniques such as compression and
    streaming, you can significantly enhance your game’s performance while maintaining
    high-quality audio output.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用高级音频优化技术，如压缩和流式传输，你可以显著提高游戏性能，同时保持高质量的音频输出。
- en: UI
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI
- en: I covered this topic in detail in [*Chapter 5*](B22017_05.xhtml#_idTextAnchor074),
    *Designing Optimized User Interfaces with C# for Unity Games*. You can check it
    out for more details. Optimizing UI is a crucial part of performance, especially
    in mobile games, as it directly impacts user experience and device resource utilization.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[*第五章*](B22017_05.xhtml#_idTextAnchor074)，*使用C#为Unity游戏设计优化的用户界面*中详细介绍了这个主题。你可以查看它以获取更多详细信息。优化UI是性能的关键部分，尤其是在移动游戏中，因为它直接影响用户体验和设备资源利用。
- en: Networking and multiplayer
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络和多人游戏
- en: 'Optimizing networking and multiplayer functionality in Unity games is crucial
    for ensuring smooth gameplay experiences across various devices and player interactions.
    Here, we’ll explore key techniques and strategies for enhancing networking performance
    and implementing effective multiplayer mechanics in Unity games:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 优化Unity游戏中的网络和多玩家功能对于确保跨各种设备和玩家交互的流畅游戏体验至关重要。在这里，我们将探讨增强网络性能和实施Unity游戏中的有效多玩家机制的关键技术和策略：
- en: '**Latency** **compensation techniques**:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟补偿技术**：'
- en: '**Problem**: Latency can cause delays in multiplayer games, leading to synchronization
    issues and gameplay inconsistencies.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：延迟可能导致多人游戏中的延迟，导致同步问题和游戏不一致性。'
- en: '**Solution**: Implement latency compensation techniques to mitigate the effects
    of network latency on gameplay. This depends on the networking solution you have
    implemented. You can refer to their documentation for specific networking solutions,
    such as Photon.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：实施延迟补偿技术以减轻网络延迟对游戏的影响。这取决于你实施的网络解决方案。你可以参考他们的文档以获取特定网络解决方案的信息，例如Photon。'
- en: '**Example**: Use techniques such as client-side prediction, interpolation,
    and lag compensation to predict and smooth out the movement of networked objects
    based on input and network data.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：使用客户端预测、插值和延迟补偿等技术，根据输入和网络数据预测和平滑网络对象的移动。'
- en: '**Results**: Improved responsiveness and synchronization in multiplayer games,
    reducing the impact of network latency on player experience and enhancing gameplay
    smoothness.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：在多人游戏中提高了响应性和同步性，减少了网络延迟对玩家体验的影响，并增强了游戏流畅性。'
- en: '**Network** **object pooling**:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络** **对象池**：'
- en: '**Problem**: Excessive instantiation and destruction of networked objects can
    lead to network congestion and performance issues.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：过度实例化和销毁网络对象可能导致网络拥塞和性能问题。'
- en: '**Solution**: Implement network object pooling to reuse existing networked
    objects instead of creating and destroying them frequently.'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：实施网络对象池来重复使用现有的网络对象，而不是频繁地创建和销毁它们。'
- en: '**Example**: In a multiplayer game, instead of instantiating and destroying
    bullets each time they are fired, use an object pool to recycle bullets. When
    a bullet is no longer needed, it is returned to the pool and can be reused later.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：在一个多人游戏中，而不是每次开火时都实例化和销毁子弹，使用对象池来回收子弹。当子弹不再需要时，它被返回到池中，以后可以再次使用。'
- en: '**Results**: Reduced network overhead and improved performance due to fewer
    object instantiations and destructions, leading to smoother gameplay experiences.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：由于对象实例化和销毁次数减少，网络开销降低，性能提高，从而带来更平滑的游戏体验。'
- en: These techniques are instrumental in optimizing networking within Unity games
    as they effectively minimize network overhead, enhance data transmission efficiency,
    and contribute to a more satisfying multiplayer experience for players. The effectiveness
    of these optimizations, however, is contingent upon the specific networking solution
    that’s implemented within the game.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在优化Unity游戏中的网络方面至关重要，因为它们有效地最小化了网络开销，提高了数据传输效率，并为玩家提供了更令人满意的多人游戏体验。然而，这些优化的有效性取决于游戏中实施的特定网络解决方案。
- en: AI and pathfinding
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能和路径查找
- en: 'Effective AI and pathfinding techniques are pivotal for creating immersive
    and engaging gameplay experiences in Unity games. We’ll explore two key solutions:
    A* (A-star) pathfinding and hierarchical pathfinding, along with behavior trees
    and state machines, to optimize AI navigation and behaviors:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的AI和路径查找技术在创建沉浸式和引人入胜的游戏体验方面至关重要。我们将探讨两个关键解决方案：A*（A星）路径查找和分层路径查找，以及行为树和状态机，以优化AI导航和行为：
- en: '**Using** **behavior trees**:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **行为树**：'
- en: '**Problem**: Inefficient pathfinding algorithms can lead to high computational
    overhead and slow performance, especially in complex game environments with dynamic
    obstacles.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：效率低下的路径查找算法可能导致高计算开销和缓慢的性能，尤其是在具有动态障碍物的复杂游戏环境中。'
- en: '**Example**: Implementing the A* algorithm in Unity using the NavMesh system.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：在Unity中使用NavMesh系统实现A*算法。'
- en: '**How it works**: A* is a popular pathfinding algorithm that efficiently finds
    the shortest path between two points on a graph or grid. In Unity, the NavMesh
    system utilizes A* for AI navigation, allowing agents to navigate dynamic environments
    while avoiding obstacles.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**How it works**: A* 是一种流行的路径查找算法，它能够高效地在图或网格上找到两点之间的最短路径。在 Unity 中，NavMesh
    系统利用 A* 算法进行 AI 导航，使代理能够在避免障碍物的同时导航动态环境。'
- en: '**Result**: Improved AI navigation performance, reduced computational cost,
    and smoother movement of AI agents in complex game scenes.'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result**: 改善 AI 导航性能，降低计算成本，并在复杂游戏场景中使 AI 代理的运动更加平滑。'
- en: '**Using state machines for** **AI behavior**:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Using state machines for** **AI behavior**:'
- en: '**Problem**: AI behaviors lacking realism and diversity can result in predictable
    and monotonous gameplay experiences.'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Problem**: AI 行为缺乏真实性和多样性可能导致可预测和单调的游戏体验。'
- en: '**Example**: Implementing state machines for AI character behaviors.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Example**: 实现状态机以用于 AI 角色行为。'
- en: '**How it works**: State machines model AI behaviors as a set of states, transitions,
    and actions. Each state represents a specific behavior or condition, and transitions
    define how AI agents switch between states based on environmental stimuli or internal
    variables.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**How it works**: 状态机将 AI 行为建模为一组状态、转换和动作。每个状态代表特定的行为或条件，转换定义了 AI 代理根据环境刺激或内部变量在状态之间切换的方式。'
- en: 'Here’s a simplified structure of a state machine for AI behavior:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个 AI 行为状态机的简化结构：
- en: '**State interface/class**:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**State interface/class**:'
- en: '**Enter**: The method that’s called when entering the state'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Enter**: 进入状态时调用的方法'
- en: '**Update**: The method that’s called during each update cycle while in the
    state'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Update**: 在状态中每个更新周期调用的方法'
- en: '**Exit**: The method that’s called when exiting the state'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exit**: 离开状态时调用的方法'
- en: '**Concrete states**:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Concrete states**:'
- en: '**Idle State**: This represents the AI being idle, with its own **Enter**,
    **Update**, and **Exit** methods specific to idle behavior.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Idle State**: 这表示 AI 正在空闲，具有针对空闲行为的特定 **Enter**、**Update** 和 **Exit** 方法。'
- en: '**Attack State**: Represents the AI attacking, with its own **Enter**, **Update**,
    and **Exit** methods specific to attack behavior'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Attack State**: 表示 AI 正在攻击，具有针对攻击行为的特定 **Enter**、**Update** 和 **Exit** 方法'
- en: Other states as needed, each with their own behavior methods
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要添加其他状态，每个状态都有自己的行为方法
- en: '**State** **machine manager**:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**State** **machine manager**:'
- en: '**Current State**: Keeps track of the AI’s current state'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Current State**: 跟踪 AI 的当前状态'
- en: '**Change State**: This method transitions the AI from one state to another
    by updating the **Current** **State** variable'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Change State**: 通过更新 **Current** **State** 变量将 AI 从一个状态转换到另一个状态的方法'
- en: '**Update**: The method to be called in each update cycle, which, in turn, calls
    the **Update** method of the current state'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Update**: 在每个更新周期中要调用的方法，它反过来调用当前状态的 **Update** 方法'
- en: '**Usage**:'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Usage**:'
- en: Initialize the AI with an initial state (for example, **Idle State**)
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用初始状态（例如，**空闲状态**）初始化 AI
- en: During each update cycle, call the **Update** method of the state machine manager
    to execute the behavior of the current state
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个更新周期中，调用状态机管理器的 **Update** 方法来执行当前状态的行为
- en: When conditions change (for example, the AI detects an enemy), use the **Change
    State** method to switch to the appropriate state (for example, **Attack State**)
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当条件发生变化（例如，AI 检测到敌人）时，使用 **Change State** 方法切换到适当的状态（例如，**攻击状态**）
- en: This structure outlines the components and their relationships in a state machine
    for AI behavior. You can implement this structure in any programming language
    by creating classes/interfaces for states, implementing a manager to handle state
    transitions, and integrating them into your AI system.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该结构概述了状态机中组件及其关系。您可以通过创建状态类/接口、实现处理状态转换的管理器以及将它们集成到您的 AI 系统中来用任何编程语言实现此结构。
- en: '**Result**: Modular and organized AI behavior design, easier debugging and
    maintenance of AI logic, and improved adaptability to changing game conditions.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result**: 模块化和组织化的 AI 行为设计，更容易调试和维护 AI 逻辑，以及更好地适应不断变化的游戏条件。'
- en: Build size
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建大小
- en: 'Efficient build size is crucial for delivering optimized and polished Unity
    games to players. Let’s explore a technique known as build size reduction through
    asset compression to enhance build efficiency:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的构建大小对于向玩家交付优化和完善的 Unity 游戏至关重要。让我们探讨一种称为构建大小缩减的技术，通过资产压缩来提高构建效率：
- en: '**Build** **size reduction**:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Build** **size reduction**:'
- en: '**Problem**: Large build sizes can lead to longer download times and increased
    storage requirements for players.'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：大型构建大小会导致下载时间更长，并增加玩家所需的存储空间。'
- en: '**Solution**: Implement asset compression techniques such as texture compression,
    audio compression, and code stripping to reduce the overall size of the build.
    For texture compression, it’s recommended to use dimensions that are powers of
    two, such as 64x64\. This approach is beneficial for compression, resulting in
    reduced memory usage and a smaller final build size.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：实施资产压缩技术，如纹理压缩、音频压缩和代码剥离，以减少构建的整体大小。对于纹理压缩，建议使用2的幂次方尺寸，例如64x64。这种方法对压缩有益，从而减少内存使用并减小最终构建大小。'
- en: '**Example**: Use texture compression formats such as ETC2 for Android builds
    and ASTC for iOS builds to significantly reduce the size of texture assets without
    compromising quality. The size of the texture is shown in the following figures:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：使用适用于 Android 构建的 ETC2 和适用于 iOS 构建的 ASTC 纹理压缩格式，可以显著减小纹理资产的大小，同时不牺牲质量。纹理的大小在以下图中显示：'
- en: '![Figure 9.13 – Before using the compression format](img/B22017_09_13.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 使用压缩格式前](img/B22017_09_13.jpg)'
- en: Figure 9.13 – Before using the compression format
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 使用压缩格式前
- en: '![Figure 9.14 – After using a compression format](img/B22017_09_14.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 使用压缩格式后](img/B22017_09_14.jpg)'
- en: Figure 9.14 – After using a compression format
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 使用压缩格式后
- en: '**Result**: Reduced build size, faster download times, and improved performance
    on devices with limited storage.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：减小构建大小，加快下载时间，并在存储空间有限的设备上提高性能。'
- en: Rendering
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染
- en: 'Optimizing rendering is essential for delivering visually stunning games while
    maintaining optimal performance. Let’s explore two powerful techniques: a **level
    of detail** (**LOD**) system for efficient mesh rendering and Occlusion Culling
    to minimize unnecessary rendering, resulting in enhanced performance and visual
    quality:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 优化渲染对于提供视觉上令人惊叹的游戏同时保持最佳性能至关重要。让我们探讨两种强大的技术：用于高效网格渲染的**细节级别**（**LOD**）系统和遮挡剔除以最小化不必要的渲染，从而提高性能和视觉质量：
- en: '**LOD system**:'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOD 系统**：'
- en: '**Problem**: High-poly models and complex scenes can lead to performance issues,
    especially on lower-end devices.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：高多边形模型和复杂场景可能导致性能问题，尤其是在低端设备上。'
- en: '**Solution**: Implement a LOD system where objects have multiple versions with
    varying levels of detail. The system switches to lower-detail versions as objects
    move farther from the camera, reducing the rendering workload.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：实施一个 LOD 系统，其中对象具有多个版本，具有不同的细节级别。当对象远离摄像机时，系统切换到低细节版本，从而减少渲染工作量。'
- en: '**Example**: Use Unity’s **LOD Group** component to create LOD levels for meshes,
    ensuring smooth transitions between LOD levels based on camera distance. Ensure
    that you have the necessary meshes ready by either requesting them from artists,
    utilizing assets from the asset store, or creating them manually if you possess
    the skills. It’s important to create low-poly meshes from the original ones to
    optimize performance:'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：使用 Unity 的 **LOD 组** 组件为网格创建 LOD 级别，确保根据摄像机距离平滑过渡到 LOD 级别。确保你有必要的网格，可以通过从艺术家那里请求，利用资产商店中的资产，或者如果你有技能，可以手动创建。从原始网格创建低多边形网格对于优化性能很重要：'
- en: '![Figure 9.15 – The LOD Group component](img/B22017_09_15.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – LOD 组组件](img/B22017_09_15.jpg)'
- en: Figure 9.15 – The LOD Group component
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – LOD 组组件
- en: '**Result**: Improved performance by reducing the number of polygons that are
    rendered without compromising visual quality.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：通过减少渲染的多边形数量来提高性能，同时不牺牲视觉质量。'
- en: '**Occlusion culling**:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡剔除**：'
- en: '**Problem**: Rendering off-screen objects consumes resources and affects performance,
    even though they are not visible to the player.'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：渲染屏幕外对象会消耗资源并影响性能，即使它们对玩家不可见。'
- en: '**Solution**: Use Occlusion culling to prevent objects that are occluded by
    other objects or not within the player’s view frustum from being rendered.'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：使用遮挡剔除来防止被其他对象遮挡或不在玩家视锥体内的对象被渲染。'
- en: '**Example**: Configure Occlusion culling volumes in Unity to define areas where
    Occlusion culling should be applied, optimizing rendering by skipping occluded
    objects:'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：在 Unity 中配置遮挡剔除体积，以定义应应用遮挡剔除的区域，通过跳过遮挡对象来优化渲染：'
- en: '![Figure 9.16 – The camera before the starting line](img/B22017_09_16.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 起跑线前的摄像机](img/B22017_09_16.jpg)'
- en: Figure 9.16 – The camera before the starting line
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 起跑线前的摄像机
- en: '![Figure 9.17 – The camera after the starting line](img/B22017_09_17.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 起跑线后的摄像机](img/B22017_09_17.jpg)'
- en: Figure 9.17 – The camera after the starting line
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 起跑线后的摄像机
- en: '**Result**: Reduced rendering workload, improved frame rates, and enhanced
    overall performance, especially in complex scenes.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：减少了渲染工作量，提高了帧率，并增强了整体性能，尤其是在复杂场景中。'
- en: Scripting
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Efficient scripting practices are crucial for optimizing game performance and
    ensuring smooth gameplay experiences. Let’s explore two powerful techniques: object
    pooling for efficient object management and coroutine optimization to enhance
    coroutine performance, resulting in improved overall game performance and responsiveness.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的脚本编写实践对于优化游戏性能和确保流畅的游戏体验至关重要。让我们探讨两种强大的技术：用于高效对象管理的对象池和用于增强协程性能的协程优化，从而提高整体游戏性能和响应速度。
- en: Object pooling
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象池
- en: 'Let’s consider a solution for object pooling:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个对象池的解决方案：
- en: '**Problem**: Instantiating and destroying objects frequently during gameplay
    can lead to performance overhead due to memory allocation and garbage collection.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：在游戏过程中频繁地实例化和销毁对象会导致由于内存分配和垃圾回收而产生的性能开销。'
- en: '**Solution**: Implement object pooling, where a set of pre-allocated objects
    is reused instead of you having to instantiate and destroy them repeatedly.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：实现对象池，其中一组预分配的对象被重复使用，而不是您需要反复实例化和销毁它们。'
- en: '`ObjectPoolManager` and understand its functionality.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectPoolManager`及其功能。'
- en: 'In the following code block, the `ObjectPoolManager` class is responsible for
    handling all operations related to the pooled objects. To make it accessible from
    other scripts, we will implement it as a singleton:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码块中，`ObjectPoolManager`类负责处理与池化对象相关的所有操作。为了使其可以从其他脚本中访问，我们将它实现为一个单例：
- en: '[PRE0]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script uses a static `Instance` property to implement the singleton pattern
    for `ObjectPoolManager`. It also includes an `Awake` method to ensure that only
    one instance of `ObjectPoolManager` exists in the scene and persists between scene
    changes if needed.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本使用静态`Instance`属性来实现`ObjectPoolManager`的单例模式。它还包括一个`Awake`方法，以确保场景中只有一个`ObjectPoolManager`实例，并在需要时在场景变化之间持续存在。
- en: 'In the following code block, I will continue implementing the logic related
    to the object pooling by `GetPooledObject` and `ReturnToPool` functions of the
    objects:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我将继续通过`GetPooledObject`和`ReturnToPool`函数实现与对象池相关的逻辑：
- en: '[PRE1]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s an explanation for each part:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是每个部分的解释：
- en: '**private Dictionary<string, Queue<GameObject>> objectPools = new Dictionary<string,
    Queue<GameObject>>();**: This line declares a private dictionary named **objectPools**
    that stores object pools based on their names. Each name corresponds to a queue
    of GameObjects.'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private Dictionary<string, Queue<GameObject>> objectPools = new Dictionary<string,
    Queue<GameObject>>();**：这一行声明了一个名为**objectPools**的私有字典，它根据名称存储对象池。每个名称对应一个GameObject队列。'
- en: '**public GameObject GetPooledObject(string objectName)**: This method retrieves
    an object from the object pool based on its name. It checks if an object pool
    with the given name exists and if there are available objects in the pool. If
    available, it dequeues an object, activates it, and returns it. If no object is
    available, it logs a warning and returns null.'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public GameObject GetPooledObject(string objectName)**：此方法根据名称从对象池中检索一个对象。它检查是否存在具有给定名称的对象池以及池中是否有可用的对象。如果可用，它将对象出队、激活并返回它。如果没有可用对象，它记录一个警告并返回null。'
- en: '**public void ReturnToPool(string objectName, GameObject obj)**: This method
    returns an object to the object pool based on its name. It deactivates the object
    and enqueues it back into the corresponding object pool queue.'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void ReturnToPool(string objectName, GameObject obj)**：此方法根据名称将对象返回到对象池。它禁用对象并将其重新入队到相应的对象池队列中。'
- en: 'Lastly, I’ll create a function to instantiate pooled objects from other scripts,
    as demonstrated in the following code block:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我将创建一个函数，从其他脚本中实例化池化对象，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s an explanation of the `CreateObjectPool` method:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是`CreateObjectPool`方法的解释：
- en: '**public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)**:
    This method creates an object pool for a specific prefab with a given pool size
    and object name. It checks if an object pool with the same name already exists.
    If not, it creates a new queue in the dictionary and instantiates objects based
    on the prefab to populate the pool.'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)**：此方法为特定预制体创建一个具有给定池大小和对象名称的对象池。它会检查是否已存在具有相同名称的对象池。如果没有，它将在字典中创建一个新的队列，并根据预制体实例化对象以填充池。'
- en: 'Here’s an example of how to use this manager:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个如何使用此管理器的示例：
- en: '[PRE3]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Result**: Reduced memory overhead, improved performance, and smoother gameplay
    experience, especially in scenarios with frequent object creation and destruction.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：减少了内存开销，提高了性能，并改善了游戏体验的流畅性，尤其是在频繁创建和销毁对象的场景中。'
- en: Coroutine optimization
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程优化
- en: 'Now, let’s consider a solution for coroutine optimization:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个协程优化的解决方案：
- en: '**Problem**: Using coroutines extensively without optimization can lead to
    performance issues, especially when you’re dealing with long-running or frequent
    coroutines.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：过度使用协程而不进行优化可能导致性能问题，尤其是在处理长时间运行或频繁调用的协程时。'
- en: '**Solution**: Optimize coroutines by employing techniques such as using **WaitForSeconds**
    instead of **WaitForSecondsRealtime**, minimizing **WaitForSeconds** calls, and
    avoiding nested coroutines where possible. Additionally, consider defining or
    caching **WaitForSeconds** instances to avoid creating new instances each time
    the coroutine is executed, which can improve memory efficiency. The following
    code block shows an example of how to define **WaitForSeconds**:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：通过使用**WaitForSeconds**代替**WaitForSecondsRealtime**、最小化**WaitForSeconds**调用，以及在可能的情况下避免嵌套协程等技术来优化协程。此外，考虑定义或缓存**WaitForSeconds**实例，以避免每次协程执行时都创建新实例，这可以提高内存效率。以下代码块展示了如何定义**WaitForSeconds**的示例：'
- en: '[PRE4]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Example**: Refactor coroutine-heavy scripts to reduce the number of coroutine
    instances, optimize yield instructions, and use alternatives such as **InvokeRepeating**
    for repetitive tasks.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：重构协程密集型脚本，减少协程实例的数量，优化yield指令，并使用如**InvokeRepeating**等替代方案进行重复性任务。'
- en: '**Result**: Improved performance by reducing coroutine overhead, smoother gameplay,
    and better frame rates, especially in complex scenes with many coroutines running
    simultaneously.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：通过减少协程开销，使游戏体验更加流畅，以及提高帧率，尤其是在运行多个协程的复杂场景中，性能得到提升。'
- en: We now know about some common issues and their appropriate solutions. In the
    next section, we’ll move on and learn how to optimize memory.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了一些常见问题和它们相应的解决方案。在下一节中，我们将继续学习如何优化内存。
- en: Memory management and optimization
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理和优化
- en: Memory profiling in Unity involves utilizing tools such as the Memory Profiler
    module and package to analyze and optimize memory usage, allowing us to identify
    areas for improvement and enhance overall performance. You’ll learn more about
    the Memory Profiler package in this section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的内存分析涉及使用内存分析器模块和包等工具来分析和优化内存使用，使我们能够识别改进区域并提升整体性能。在本节中，你将了解更多关于内存分析器包的内容。
- en: You can analyze memory usage in your Unity application through two methods.
    First, the Memory Profiler module provides essential insights into memory usage,
    highlighting areas where your application consumes memory. Second, by integrating
    the Memory Profiler package into your project, you gain access to an enhanced
    **Memory Profiler** window within Unity Editor. This advanced tool allows for
    more detailed analysis, including storing and comparing snapshots to identify
    memory leaks and examining memory layouts to detect fragmentation issues.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方法在Unity应用程序中分析内存使用情况。首先，内存分析器模块提供了对内存使用的关键洞察，突出了应用程序消耗内存的区域。其次，通过将内存分析器包集成到项目中，你可以在Unity编辑器中获得一个增强的**内存分析器**窗口。这个高级工具允许进行更详细的分析，包括存储和比较快照以识别内存泄漏，以及检查内存布局以检测碎片化问题。
- en: The Memory Profiler
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分析器
- en: The Memory Profiler in Unity is a tool that’s used for analyzing and optimizing
    memory usage in Unity projects. It helps us understand how our game uses memory
    and identify areas where memory can be optimized.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的内存分析器是一个用于分析和优化Unity项目中内存使用的工具。它帮助我们了解我们的游戏如何使用内存，并识别可以优化的内存区域。
- en: 'You need to install this package into your project. Go to the **Package Manager**
    window and select **Memory Profiler**, as shown in *Figure 9**.18*:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将此包安装到您的项目中。转到 **包管理器** 窗口并选择 **内存分析器**，如图 *图 9*.18* 所示：
- en: '![Figure 9.18 – Installing the Memory Profiler package](img/B22017_09_18.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 安装内存分析器包](img/B22017_09_18.jpg)'
- en: Figure 9.18 – Installing the Memory Profiler package
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 安装内存分析器包
- en: 'Wait for Unity to finish installing the Memory Profiler package, then open
    it from the **Window** | **Analysis** | **Memory Profiler** menu. If this is your
    first time using it in your project, an empty window will open, as shown in *Figure
    9**.19*:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 Unity 完成内存分析器包的安装，然后从 **窗口** | **分析** | **内存分析器** 菜单打开它。如果您第一次在项目中使用它，将打开一个空窗口，如图
    *图 9*.19* 所示：
- en: '![Figure 9.19 – The Memory Profiler panel](img/B22017_09_19.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 内存分析器面板](img/B22017_09_19.jpg)'
- en: Figure 9.19 – The Memory Profiler panel
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 内存分析器面板
- en: Now that we’ve learned how to open the Memory Profiler, let’s explore how it
    works and what it does.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何打开内存分析器，让我们来探索它是如何工作的以及它做了什么。
- en: Understanding how the Memory Profiler operates
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解内存分析器的工作原理
- en: The Memory Profiler works by monitoring and recording memory allocations and
    usage in real time while your Unity project is running. It tracks various metrics,
    such as heap size, memory allocations by type, instance counts, and memory leaks.
    It provides a detailed breakdown of memory usage, allowing developers to pinpoint
    areas of high memory consumption and potential memory leaks.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器通过在 Unity 项目运行时实时监控和记录内存分配和使用情况来工作。它跟踪各种指标，如堆大小、按类型分配的内存、实例计数和内存泄漏。它提供了内存使用的详细分解，使开发者能够定位内存消耗高的区域和潜在的内存泄漏。
- en: Exploring the key functions of the Memory Profiler
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索内存分析器的关键功能
- en: 'The primary functions of the Memory Profiler are as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器的主要功能如下：
- en: '**Tracks memory allocations**: The Memory Profiler tracks memory allocations
    made by your game, including heap memory, object instances, and resource usage'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪内存分配**：内存分析器跟踪您的游戏所做的内存分配，包括堆内存、对象实例和资源使用'
- en: '**Identifies memory leaks**: It helps identify memory leaks by highlighting
    objects that are not properly disposed of or released from memory'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别内存泄漏**：它通过突出显示未正确处置或从内存中释放的对象来帮助识别内存泄漏'
- en: '**Analyzes memory usage by type**: You can see a breakdown of memory usage
    by different types of objects, scripts, textures, and other assets in your project'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按类型分析内存使用情况**：您可以看到项目中不同类型对象、脚本、纹理和其他资产的内存使用分解'
- en: '**Provides instance counts**: The Memory Profiler shows how many instances
    of each object type are currently in memory, helping you understand memory consumption
    patterns'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供实例计数**：内存分析器显示了当前内存中每种对象类型的实例数量，帮助您了解内存消耗模式'
- en: '**Offers insights into resource usage**: It provides insights into how resources
    such as textures, audio clips, and other assets contribute to memory usage'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深入了解资源使用情况**：它提供了关于纹理、音频剪辑和其他资源如何影响内存使用的见解'
- en: Now, let’s learn how to use the Memory Profiler.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用内存分析器。
- en: Using the Memory Profiler
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内存分析器
- en: Before we dive into the Memory Profiler, it’s crucial to consider and adhere
    to the memory limitations of your target devices in multiplatform development.
    Design scenes and levels within the specified memory budget for each device to
    ensure optimal performance based on hardware capabilities. Setting clear limits
    and guidelines helps maintain compatibility across platforms.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入内存分析器之前，考虑并遵守目标设备在多平台开发中的内存限制至关重要。根据硬件能力，在为每个设备指定的内存预算内设计场景和关卡，以确保基于硬件能力的最佳性能。设定明确的限制和指南有助于保持平台间的兼容性。
- en: 'The Memory Profiler package offers comprehensive memory analysis capabilities.
    Utilize it to store and compare snapshots for identifying memory leaks and optimizing
    your application’s memory layout. Unlike the Memory Profiler module, this package
    extends its functionality to include managed memory analysis, snapshot saving,
    comparison, and detailed memory content exploration with visual breakdowns:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器包提供了全面的内存分析功能。利用它来存储和比较快照，以识别内存泄漏和优化应用程序的内存布局。与内存分析器模块不同，此包扩展了其功能，包括托管内存分析、快照保存、比较以及通过可视化分解详细探索内存内容：
- en: '![Figure 9.20 – The Summary tab in the Memory Profiler](img/B22017_09_20.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 内存分析器的摘要选项卡](img/B22017_09_20.jpg)'
- en: Figure 9.20 – The Summary tab in the Memory Profiler
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 内存分析器中的摘要选项卡
- en: The **Summary** tab provides an overview of the memory status in the chosen
    snapshot(s).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**选项卡提供了所选快照（s）中内存状态的概述。'
- en: Once you click on any area of the summary, further details about it will appear
    in the right-hand panel.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击摘要中的任何区域，有关该区域的更多详细信息将出现在右侧面板中。
- en: 'Another tab we should consider is **Unity Objects**, which showcases Unity
    objects that are utilizing memory, along with their respective allocations in
    native and managed memory, and the combined total. You can utilize this data to
    spot duplicate memory entries or pinpoint objects with significant memory usage.
    You can also utilize the search bar to filter entries in the table based on your
    specified text. This can be seen in *Figure 9**.21*:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应考虑的另一个选项卡是**Unity对象**，它展示了正在使用内存的Unity对象，以及它们在本地和托管内存中的相应分配和总计。您可以使用这些数据来查找重复的内存条目或确定具有重大内存使用的对象。您还可以使用搜索栏根据指定的文本过滤表中的条目。这可以在*图9*.*21*中看到：
- en: '![Figure 9.21 – The Unity Objects tab in the Memory Profiler](img/B22017_09_21.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21 – 内存分析器中的Unity对象选项卡](img/B22017_09_21.jpg)'
- en: Figure 9.21 – The Unity Objects tab in the Memory Profiler
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 内存分析器中的Unity对象选项卡
- en: 'Lastly, The **All Of Memory** tab is exclusive to **Single Snapshot** mode,
    providing a comprehensive breakdown of all tracked memory in the snapshot. It
    visualizes memory usage, showcasing sizable portions managed either by Unity or
    the platform. This tab is instrumental in discerning non-Unity-related memory
    consumption and uncovering potential memory issues not evident in the **Unity**
    **Objects** tab:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**所有内存**选项卡仅适用于**单快照**模式，提供了快照中所有跟踪内存的详细分解。它可视化内存使用情况，展示了由Unity或平台管理的较大部分。此选项卡对于区分与Unity无关的内存消耗和揭示在**Unity**
    **对象**选项卡中不明显潜在内存问题至关重要：
- en: '![Figure 9.22 – The All Of Memory tab in the Memory Profiler](img/B22017_09_22.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22 – 内存分析器中的所有内存选项卡](img/B22017_09_22.jpg)'
- en: Figure 9.22 – The All Of Memory tab in the Memory Profiler
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – 内存分析器中的所有内存选项卡
- en: 'You can identify optimization candidates by following these steps:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤识别优化候选对象：
- en: Open a snapshot by referring to the instructions for opening snapshots.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过参考打开快照的说明来打开快照。
- en: Access the **Unity** **Objects** tab.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问**Unity** **对象**选项卡。
- en: Ensure the table is sorted in descending order, which is the default setting
    in the **Memory Profiler** window. If the sort order has been changed, select
    the **Total Size** column header to revert to descending order for this process.
    This arrangement highlights objects with the highest memory usage at the top of
    the table.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保表格按降序排序，这是内存分析器窗口中的默认设置。如果排序顺序已更改，请选择**总大小**列标题以将此过程重置为降序。这种安排将内存使用量最高的对象置于表格顶部。
- en: 'You can search through the results in one of two ways:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式之一搜索结果：
- en: Expand groups to view individual objects within each group
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开组以查看每个组内的单个对象。
- en: Consider enabling the **Flatten hierarchy** property to exclusively display
    individual objects in the table
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑启用**扁平化层次结构**属性，以仅显示表格中的单个对象。
- en: If you’re uncertain about which objects might use excessive memory, leave the
    **Flatten hierarchy** property disabled and inspect the groups to identify the
    largest objects. Enable this property if most assets are understood but there’s
    a suspicion of a few outliers consuming too much memory.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定哪些对象可能使用过多内存，请禁用**扁平化层次结构**属性，并检查组以识别最大的对象。如果大多数资产都理解但怀疑有少数异常对象消耗了过多内存，则启用此属性。
- en: Additionally, enable the **Show Potential Duplicates Only** property to identify
    objects flagged by the Memory Profiler as potential duplicates. Utilize the **References**
    component and **Selection Details** component for detailed insights into these
    objects. This information helps differentiate expected duplicates, such as multiple
    instances of a Prefab in a scene, from problematic duplicates, such as unintentionally
    created objects or instances not disposed of correctly by Unity.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，启用**仅显示潜在重复项**属性以识别内存分析器标记为潜在重复的对象。利用**引用**组件和**选择详情**组件对这些对象进行深入了解。这些信息有助于区分预期的重复项，例如场景中Prefab的多个实例，与问题重复项，例如意外创建的对象或Unity未正确处理的实例。
- en: 'Here are some considerations when it comes to memory profiling:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存分析方面，以下是一些考虑因素：
- en: Use different memory usage based on settings such as quality levels, graphics
    tiers, and AssetBundle variants, especially on more powerful devices.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据质量级别、图形层级和AssetBundle变体等设置使用不同的内存使用情况，尤其是在更强大的设备上。
- en: '**Quality Level** and **Graphics** settings can impact the size of RenderTextures
    that are used for shadow maps.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量级别**和**图形**设置可能会影响用于阴影图的RenderTextures的大小。'
- en: Resolution scaling affects screen buffers, RenderTextures, and post-processing
    effects.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分辨率缩放会影响屏幕缓冲区、RenderTextures和后期处理效果。
- en: Texture quality settings influence the size of all textures.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本质量设置影响所有纹理的大小。
- en: Maximum LOD can impact models and other elements.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大检测限（LOD）可能会影响模型和其他元素。
- en: AssetBundle variants such as HD and SD versions can result in different asset
    sizes based on the device’s specifications.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如HD和SD版本之类的AssetBundle变体可以根据设备的规格产生不同的资产大小。
- en: The target device’s screen resolution affects the dimensions of RenderTextures
    that are utilized for post-processing effects.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标设备的屏幕分辨率会影响用于后期处理效果的RenderTextures的尺寸。
- en: The supported Graphics API can affect shader sizes based on API-specific variants.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的图形API可以根据API特定的变体影响着色器的大小。
- en: Content generated dynamically during gameplay, such as procedural levels, can
    significantly impact memory usage. Monitor the memory footprint of dynamically
    generated assets to ensure efficient memory management.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏过程中动态生成的内容，如程序化关卡，可能会显著影响内存使用。监控动态生成资产的内存占用，以确保有效的内存管理。
- en: Conduct thorough testing on target devices with varying specifications, screen
    resolutions, and hardware configurations to identify and address memory issues
    specific to each platform.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有不同规格、屏幕分辨率和硬件配置的目标设备上进行全面测试，以识别和解决每个平台特有的内存问题。
- en: By considering these aspects and conducting comprehensive memory profiling,
    you can optimize memory usage across different platforms, ensuring optimal performance
    and resource utilization in your Unity projects.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑这些方面并进行全面的内存分析，您可以在不同平台上优化内存使用，确保Unity项目中的性能和资源利用达到最佳。
- en: One effective method to improve memory optimization in Unity is by optimizing
    the import settings for assets.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，通过优化资产导入设置来提高内存优化是一种有效的方法。
- en: Importing models
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入模型
- en: 'Importing models is a critical aspect of 3D game development, and optimizing
    this process can significantly enhance memory usage and overall performance. In
    this section, we’ll explore key settings, as shown in *Figure 9**.**23*, that
    can be adjusted to achieve these optimizations effectively:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模型是3D游戏开发的关键方面，优化这一过程可以显著提高内存使用率和整体性能。在本节中，我们将探讨如图*图9.23*所示的几个关键设置，这些设置可以通过调整来实现有效的优化：
- en: '![Figure 9.23 – The model’s settings](img/B22017_09_23.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23 – 模型的设置](img/B22017_09_23.jpg)'
- en: Figure 9.23 – The model’s settings
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 – 模型的设置
- en: '**Mesh Compression** is a setting that determines the level of compression
    that’s applied to imported mesh data. It affects the file size of the mesh asset
    and can impact both memory usage and rendering performance:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格压缩**是一个设置，它决定了应用于导入的网格数据的压缩级别。它影响网格资产的大小，并可能影响内存使用和渲染性能：'
- en: '**Options**: Unity provides three options for **Mesh Compression**:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：Unity为**网格压缩**提供了三个选项：'
- en: '**Off**: No compression is applied, resulting in larger file sizes but potentially
    better rendering performance.'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：不应用压缩，导致文件大小更大，但可能具有更好的渲染性能。'
- en: '**Low**: Applies a basic compression algorithm to reduce file size while still
    maintaining visual quality. This is suitable for many cases as it doesn’t have
    a significant impact on rendering performance.'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低**：应用基本的压缩算法以减小文件大小，同时仍保持视觉质量。这在许多情况下都适用，因为它对渲染性能没有显著影响。'
- en: '**Medium/High**: Utilizes more advanced compression techniques to further reduce
    file size. However, higher compression levels may lead to slightly lower rendering
    performance due to additional decompression overhead.'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中/高**：使用更高级的压缩技术进一步减小文件大小。然而，更高的压缩级别可能会由于额外的解压缩开销而导致渲染性能略有下降。'
- en: '**Best practices**: Use **Mesh Compression** judiciously based on the specific
    requirements of your game. For complex models or those with intricate details,
    consider using **Low** compression to balance file size reduction with rendering
    performance. Test different compression levels to find the optimal balance for
    your project.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：根据您游戏的具体需求，明智地使用**网格压缩**。对于复杂模型或具有复杂细节的模型，考虑使用**低**压缩以平衡文件大小减少与渲染性能。测试不同的压缩级别以找到您项目的最佳平衡。'
- en: 'The **Read/Write Enabled** setting determines whether the mesh data can be
    accessed and modified at runtime. Enabling this setting allows scripts to read
    and modify mesh properties during gameplay:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**读写启用**设置确定网格数据是否可以在运行时访问和修改。启用此设置允许脚本在游戏过程中读取和修改网格属性：'
- en: '**Impact on performance and memory**: Enabling Read/Write for a mesh increases
    memory usage because the mesh data needs to be stored in a format that allows
    runtime modifications. However, it can also provide flexibility for dynamic mesh
    operations, such as deformation or procedural mesh generation.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对性能和内存的影响**：启用网格的读写权限会增加内存使用，因为网格数据需要以允许运行时修改的格式存储。然而，它也可以为动态网格操作提供灵活性，例如变形或程序化网格生成。'
- en: '**Best practices**: Only enable Read/Write for meshes that require runtime
    modifications. For static meshes that do not change during gameplay, leave this
    setting disabled to reduce memory overhead.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：只为需要运行时修改的网格启用读写权限。对于在游戏过程中不发生变化的静态网格，保持此设置禁用以减少内存开销。'
- en: 'The **Optimize Mesh** setting determines whether Unity applies additional optimizations
    to the imported mesh data to improve rendering performance:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化网格**设置确定Unity是否对导入的网格数据应用额外的优化以提高渲染性能：'
- en: '**Effect on performance and memory**: Enabling **Optimize Mesh** allows Unity
    to perform optimizations such as vertex welding, which reduces the number of vertices
    in the mesh without significantly affecting visual quality. This can lead to improved
    rendering performance by reducing the workload on the GPU.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对性能和内存的影响**：启用**优化网格**允许Unity执行优化，如顶点焊接，这在不显著影响视觉质量的情况下减少了网格中的顶点数量。这可以通过减少GPU上的工作量来提高渲染性能。'
- en: '**Best practices**: Enable **Optimize Mesh** for meshes that can benefit from
    vertex reduction without compromising visual fidelity. This is particularly useful
    for models with redundant or overlapping vertices as it can significantly reduce
    memory usage and enhance rendering performance.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：为可以受益于顶点减少而不影响视觉保真度的网格启用**优化网格**。这对于具有冗余或重叠顶点的模型尤其有用，因为它可以显着减少内存使用并提高渲染性能。'
- en: 'Setting the **Animation Type** option to **None** for a static game object
    in the **Rig** tab can have a positive impact on both performance and memory usage.
    When you choose **None**, Unity skips any processing related to animation rigging
    and does not allocate resources for animation-related calculations during runtime.
    This can be seen in *Figure 9**.24*:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Rig**选项卡中将静态游戏对象的**动画类型**选项设置为**无**可以对性能和内存使用产生积极影响。当您选择**无**时，Unity会跳过与动画绑定相关的任何处理，并在运行时不分配与动画相关的计算资源。这可以在*图9.24*中看到：
- en: '![Figure 9.24 – The Rig tab in the model settings](img/B22017_09_24.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24 – 模型设置中的Rig选项卡](img/B22017_09_24.jpg)'
- en: Figure 9.24 – The Rig tab in the model settings
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 – 模型设置中的Rig选项卡
- en: Let’s look at how setting **Animation Type** to **None** can affect performance
    and memory.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将**动画类型**设置为**无**如何影响性能和内存。
- en: '**Performance impact**:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能影响**：'
- en: By setting **Animation Type** to **None**, Unity avoids processing animation
    data and calculations for the game object. This reduces the workload on the CPU
    and GPU, especially during the rendering and animation playback phases.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将**动画类型**设置为**无**，Unity避免了处理游戏对象的动画数据和计算。这减少了CPU和GPU的工作量，尤其是在渲染和动画播放阶段。
- en: Since there are no animation updates to perform, Unity can optimize the rendering
    pipeline by skipping unnecessary computations related to bone transformations,
    blend shapes, or animation state updates.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有动画更新要执行，Unity可以通过跳过与骨骼变换、混合形状或动画状态更新相关的计算来优化渲染管线。
- en: This optimization can lead to smoother frame rates and improved overall performance,
    particularly for static objects that do not require any animation functionality.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种优化可以导致帧率更平滑，整体性能得到提升，尤其是对于不需要任何动画功能的静态对象。
- en: '**Memory impact**:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存影响**：'
- en: Setting **Animation Type** to **None** also has a memory-saving benefit. Unity
    does not allocate memory for storing animation clips, rigging data, or animation-related
    components (for example, Animator or Animation Controller) for game objects with
    this setting applied.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**动画类型**设置为**无**也有节省内存的好处。Unity不会为应用此设置的GameObject分配内存以存储动画片段、绑定数据或与动画相关的组件（例如，Animator或Animation
    Controller）。
- en: This reduction in memory usage can be significant, especially for scenes with
    multiple static objects or large models that do not need animation features.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种内存使用量的减少可能非常显著，尤其是在包含多个静态对象或大型模型且不需要动画功能的场景中。
- en: By minimizing memory allocation for animation-related resources, you free up
    more memory for other game assets and reduce the overall memory footprint of your
    Unity project.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过最小化动画相关资源的内存分配，您可以释放更多内存用于其他游戏资产，并减少Unity项目的整体内存占用。
- en: '**Best practices**:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：'
- en: Set **Animation Type** to **None** for static game objects or models that do
    not require animation functionality. This is particularly effective for environment
    props, static scenery elements, or architectural models.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于静态游戏对象或模型，如果不需要动画功能，将**动画类型**设置为**无**。这对于环境道具、静态景观元素或建筑模型尤其有效。
- en: For dynamic objects that require animation, such as characters or interactive
    elements, choose the appropriate **Animation Type** based on their animation requirements
    (for example, **Generic**, **Humanoid**, **Legacy**, and so on).
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于需要动画的动态对象，例如角色或交互元素，根据它们的动画需求选择合适的**动画类型**（例如，**通用**、**人形**、**旧版**等）。
- en: Regularly review and optimize animation settings for each game object to ensure
    efficient use of resources and improved performance.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审查和优化每个游戏对象的动画设置，以确保资源的高效使用并提高性能。
- en: In summary, setting **Animation Type** to **None** for static game objects can
    be a beneficial optimization strategy as it reduces both CPU/GPU workload and
    memory usage in your Unity project.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，将静态游戏对象的**动画类型**设置为**无**可以是一种有益的优化策略，因为它可以减少Unity项目中的CPU/GPU工作负载和内存使用。
- en: 'Lastly, when considering the **Anim. Compression** option in the **Animation**
    tab of model settings in Unity, choosing between **Optimal Compression** or **Keyframe
    Reduction** can indeed have an impact on both performance and memory usage. This
    can be seen in *Figure 9**.25*:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当在Unity中考虑模型设置动画选项卡中的**动画压缩**选项时，选择**最佳压缩**或**关键帧减少**确实会对性能和内存使用产生影响。这可以在*图9.25*中看到：
- en: '![Figure 9.25 – The Animation tab in the model settings](img/B22017_09_25.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图9.25 – 模型设置中的动画选项卡](img/B22017_09_25.jpg)'
- en: Figure 9.25 – The Animation tab in the model settings
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – 模型设置中的动画选项卡
- en: Let’s look at how each option affects your project.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个选项如何影响您的项目。
- en: '**Optimal Compression**:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳压缩**：'
- en: '**Performance impact**: **Optimal Compression** aims to reduce the size of
    animation clips while preserving visual quality. This can result in improved performance
    during runtime, especially for devices with limited processing power or memory
    bandwidth.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：**最佳压缩**旨在在保持视觉质量的同时减少动画片段的大小。这可以在运行时提高性能，尤其是在处理能力或内存带宽有限的设备上。'
- en: '**Memory impact**: By compressing animation data efficiently, **Optimal Compression**
    reduces the memory footprint of animation clips. This can be beneficial for projects
    with many animations or large animation files, leading to lower memory usage and
    better resource management.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存影响**：通过有效地压缩动画数据，**最佳压缩**减少了动画片段的内存占用。这对于拥有许多动画或大型动画文件的项目有益，可以降低内存使用并改善资源管理。'
- en: '**Keyframe Reduction**:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键帧减少**：'
- en: '**Performance impact**: **Keyframe Reduction** focuses on minimizing the number
    of keyframes in animation clips while maintaining smooth motion. This can lead
    to improved performance by reducing the computational overhead of interpolating
    between keyframes during animation playback.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：**关键帧减少**专注于在保持平滑运动的同时最小化动画片段中的关键帧数量。这可以通过减少动画播放期间在关键帧之间插值计算的开销来提高性能。'
- en: '**Memory impact**: While **Keyframe Reduction** can help save memory by reducing
    the data needed for animation playback, it may not be as efficient in terms of
    memory optimization as **Optimal Compression**. However, it can still contribute
    to lowering the overall memory usage of animation clips.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记忆影响**：虽然**关键帧减少**可以通过减少动画播放所需的数据来帮助节省内存，但在内存优化方面可能不如**最佳压缩**高效。然而，它仍然可以有助于降低动画片段的整体内存使用。'
- en: '**Best practices**:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：'
- en: '**Optimal Compression**: Use **Optimal Compression** for animations that require
    a balance between file size reduction and visual quality. It’s suitable for a
    wide range of animations and can offer significant memory and performance benefits.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳压缩**：对于需要在文件大小减少和视觉质量之间取得平衡的动画，请使用**最佳压缩**。它适用于广泛的动画，并可以提供显著的内存和性能优势。'
- en: '**Keyframe Reduction**: Consider **Keyframe Reduction** for animations where
    reducing the number of keyframes won’t significantly impact visual fidelity. This
    option can be particularly useful for repetitive or simple animations, helping
    to streamline memory usage and improve playback performance.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键帧减少**：对于减少关键帧数量不会显著影响视觉保真度的动画，可以考虑使用**关键帧减少**。此选项对于重复或简单的动画特别有用，有助于简化内存使用并提高播放性能。'
- en: '**Choosing the** **right option**:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择正确的选项**：'
- en: Evaluate the animation requirements of your project and choose the compression
    option that best suits your needs. **Optimal Compression** is generally recommended
    for most scenarios due to its balanced approach to reducing file size and memory
    usage while maintaining visual quality.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估您项目的动画需求，并选择最适合您需求的压缩选项。**最佳压缩**通常推荐用于大多数场景，因为它在减少文件大小和内存使用的同时保持了视觉质量。
- en: Regularly test animations with different compression settings to find the optimal
    balance between performance, memory usage, and visual fidelity for your specific
    project requirements.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期测试不同压缩设置下的动画，以找到适合您特定项目需求的性能、内存使用和视觉保真度之间的最佳平衡。
- en: In conclusion, both **Optimal Compression** and **Keyframe Reduction** in the
    **Anim. Compression** option can impact performance and memory in Unity. Choose
    the compression setting that aligns with your project’s animation complexity,
    visual quality standards, and target platform capabilities to achieve the best
    results.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，**动画压缩**选项中的**最佳压缩**和**关键帧减少**都会影响Unity中的性能和内存。选择与您的项目动画复杂度、视觉质量标准和目标平台能力相匹配的压缩设置以实现最佳结果。
- en: 'To automate this process, we can create an asset `PostProcessor` script, which
    is an editor script that allows us to set default settings for importing assets.
    The following is an example code block demonstrating a `CustomMeshPostProcessor`
    class that achieves the desired default settings when importing meshes. Simply
    create this script and place it in the `Editor` folder of your project. Once implemented,
    the script will automatically apply these settings when importing new models.
    Feel free to customize it and add more settings as needed for your game:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化此过程，我们可以创建一个名为 `PostProcessor` 的资产脚本，这是一个编辑器脚本，允许我们为导入资产设置默认设置。以下是一个示例代码块，演示了一个
    `CustomMeshPostProcessor` 类，在导入网格时实现所需的默认设置。只需创建此脚本并将其放置在项目中的 `Editor` 文件夹中。一旦实施，脚本将自动在导入新模型时应用这些设置。您可以自由地对其进行自定义并根据需要添加更多设置以适应您的游戏：
- en: '[PRE5]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Overall, optimizing the import settings for models in Unity is crucial for achieving
    efficient memory usage and overall performance in your game. By carefully configuring
    these settings and following best practices, you can significantly enhance the
    user experience while maintaining optimal resource utilization.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，在Unity中对模型导入设置进行优化对于实现游戏中的高效内存使用和整体性能至关重要。通过仔细配置这些设置并遵循最佳实践，您可以在保持最佳资源利用率的同时显著提升用户体验。
- en: Importing textures
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入纹理
- en: 'The topic of importing textures is highly impactful in optimizing both game
    and memory performance, with notable effects extending to UI performance as well.
    The available settings are shown in *Figure 9**.26*:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 导入纹理的话题对优化游戏和内存性能影响极大，其显著效果还扩展到UI性能。*图 9.26* 中显示了可用的设置：
- en: '![Figure 9.26 – Texture settings](img/B22017_09_26.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 纹理设置](img/B22017_09_26.jpg)'
- en: Figure 9.26 – Texture settings
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 纹理设置
- en: When importing textures into Unity, two key settings that can impact performance
    and memory usage are **Read/Write** and **GenerateMipMaps**. Let’s delve into
    each setting and understand their effects.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当将纹理导入Unity时，有两个关键设置会影响性能和内存使用，即**读/写**和**生成MipMaps**。让我们深入了解每个设置及其影响。
- en: '**Read/Write**:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**读/写**：'
- en: '**Performance impact**: Enabling **Read/Write** allows scripts to access and
    modify texture data at runtime. While this flexibility can be beneficial for certain
    features, such as dynamic texture updates or procedural generation, it comes with
    a performance cost. Each texture marked as **Read/Write** consumes additional
    memory and may require more processing power during runtime.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：启用**读/写**允许脚本在运行时访问和修改纹理数据。虽然这种灵活性对于某些功能（如动态纹理更新或程序生成）可能有益，但它也带来了性能成本。每个标记为**读/写**的纹理都会消耗额外的内存，并且在运行时可能需要更多的处理能力。'
- en: '**Memory impact**: Textures with **Read/Write** enabled occupy more memory
    compared to those without this option. This is because Unity allocates space for
    both the texture data and an additional copy that can be modified at runtime.
    As a result, enabling **Read/Write** for multiple textures can lead to increased
    memory usage, especially on resource-constrained platforms.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存影响**：启用**读/写**的纹理与未启用此选项的纹理相比，占用的内存更多。这是因为Unity为纹理数据和可以修改的附加副本分配空间。因此，为多个纹理启用**读/写**可能导致内存使用增加，尤其是在资源受限的平台。'
- en: '**GenerateMipMaps**:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成MipMaps**：'
- en: '**Performance impact**: Generating MipMaps creates a series of pre-calculated
    texture levels (MipMaps) that improve rendering quality and performance. However,
    this process requires additional computational resources during texture import
    or runtime generation, impacting loading times and initial performance.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：生成MipMaps创建了一系列预计算的纹理级别（MipMaps），这提高了渲染质量和性能。然而，这个过程在纹理导入或运行时生成时需要额外的计算资源，影响加载时间和初始性能。'
- en: '**Memory impact**: Including MipMaps increases the memory footprint of textures
    since each MipMap level adds to the total texture size. While MipMaps enhance
    rendering performance by providing optimized texture sampling at different distances,
    they also consume more memory, especially for large textures with numerous MipMap
    levels.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存影响**：包含MipMaps会增加纹理的内存占用，因为每个MipMap级别都会增加纹理的总大小。虽然MipMaps通过在不同距离提供优化的纹理采样来提高渲染性能，但它们也消耗更多的内存，尤其是对于具有众多MipMap级别的较大纹理。'
- en: '**Best practices**:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：'
- en: '**Read/Write**: Only enable **Read/Write** for textures that require runtime
    modification or dynamic updates. For static textures used as sprites, backgrounds,
    or UI elements, disable **Read/Write** to conserve memory and improve performance.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读/写**：仅对需要运行时修改或动态更新的纹理启用**读/写**。对于用作精灵、背景或UI元素的静态纹理，禁用**读/写**以节省内存并提高性能。'
- en: '**GenerateMipMaps**: Use **GenerateMipMaps** for textures that will benefit
    from improved rendering quality and performance, such as textures used for 3D
    models or distant terrain. Consider the trade-off between enhanced visual fidelity
    and increased memory usage when deciding whether to include MipMaps.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成MipMaps**：对于将受益于改进的渲染质量和性能的纹理，例如用于3D模型或远距离地形的纹理，使用**生成MipMaps**。在决定是否包含MipMaps时，考虑提高视觉保真度和增加内存使用之间的权衡。'
- en: '**Choosing the** **right settings**:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择正确的设置**：'
- en: Evaluate the specific requirements of each texture in your project. Enable **Read/Write**
    and **GenerateMipMaps** judiciously based on whether the texture needs runtime
    modification and whether MipMaps are necessary for optimized rendering.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估你项目中每种纹理的具体需求。根据纹理是否需要运行时修改以及是否需要MipMaps进行优化渲染，明智地启用**读/写**和**生成MipMaps**。
- en: Regularly monitor the memory usage and performance impact of textures with different
    settings to optimize resource utilization and maintain efficient runtime behavior.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期监控不同设置下纹理的内存使用和性能影响，以优化资源利用并保持高效的运行时行为。
- en: In conclusion, managing **Read/Write** and **GenerateMipMaps** settings when
    you’re importing textures into Unity is crucial for balancing performance, memory
    usage, and visual quality. Selecting the appropriate settings based on the intended
    usage of each texture helps optimize resource allocation and enhances overall
    application performance.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当你在Unity中导入纹理时，管理**读取/写入**和**生成Mip贴图**设置对于平衡性能、内存使用和视觉质量至关重要。根据每个纹理的预期使用情况选择适当的设置有助于优化资源分配并提高整体应用程序性能。
- en: Another aspect to consider is compression settings, which vary based on the
    target platform, each with its unique configurations. While specific platform
    settings are extensive and platform-dependent, there are some general tips for
    optimizing compression.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的方面是压缩设置，这些设置根据目标平台而异，每个平台都有其独特的配置。虽然具体的平台设置非常广泛且依赖于平台，但有一些通用的优化压缩的建议。
- en: '**Maximum size**:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大尺寸**:'
- en: Adjusting the maximum size of textures determines their dimensions upon import.
    Higher resolutions offer better visual quality but consume more memory. Consider
    the device’s capabilities and the texture’s intended use to strike a balance between
    quality and performance.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整纹理的最大尺寸决定了导入时的纹理尺寸。较高的分辨率提供更好的视觉质量，但消耗更多的内存。考虑设备的性能和纹理的预期用途，在质量和性能之间取得平衡。
- en: '**Best practice**: Set the maximum size based on the target platform and the
    texture’s role in the game. Use lower resolutions for background elements or distant
    objects to conserve memory.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：根据目标平台和纹理在游戏中的作用设置最大尺寸。对于背景元素或远距离对象使用较低的分辨率以节省内存。'
- en: '**Resize algorithm**:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整尺寸的算法**：'
- en: The resize algorithm dictates how textures are scaled when their dimensions
    exceed the maximum size. Different algorithms may impact image quality and memory
    usage.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整尺寸的算法决定了当纹理的尺寸超过最大尺寸时如何缩放纹理。不同的算法可能影响图像质量和内存使用。
- en: '**Best practice**: Choose an algorithm that suits the texture type. Use sharper
    algorithms for detailed textures and smoother ones for gradients or patterns to
    preserve quality.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：选择适合纹理类型的算法。对于细节纹理使用更锐利的算法，对于渐变或图案使用更平滑的算法以保持质量。'
- en: '**Format**:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式**:'
- en: Texture format determines how the image data is stored, impacting compression,
    memory usage, and visual fidelity. Common formats include PNG, JPG, and TGA, each
    with its compression levels and quality trade-offs.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理格式决定了图像数据如何存储，影响压缩、内存使用和视觉保真度。常见的格式包括PNG、JPG和TGA，每种格式都有其压缩级别和质量权衡。
- en: '**Best practice**: Select a format based on the texture’s content and usage.
    Use PNG for lossless quality, JPG for photographic textures with compression,
    and TGA for high-quality images with transparency.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：根据纹理的内容和使用情况选择格式。使用PNG以获得无损质量，使用JPG以压缩照片纹理，使用TGA以获得具有透明度的高质量图像。'
- en: '**Compression**:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩**:'
- en: Compression methods reduce texture size and memory footprint. Unity offers options
    such as **Normal Quality**, **High Quality**, and **Low Quality** for compression,
    each affecting image quality and memory usage differently.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩方法可以减小纹理大小和内存占用。Unity提供了**正常质量**、**高质量**和**低质量**等压缩选项，它们以不同的方式影响图像质量和内存使用。
- en: '**Best practice**: Choose compression settings based on performance requirements
    and visual standards. Use higher-quality compression for critical textures and
    lower quality for background or non-critical elements.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：根据性能要求和视觉标准选择压缩设置。对于关键纹理使用高质量压缩，对于背景或非关键元素使用低质量压缩。'
- en: '**Crunch compression**:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**Crunch压缩**:'
- en: Crunch compression is an additional method to further reduce texture file sizes
    while maintaining acceptable quality. It’s beneficial for optimizing memory usage,
    especially on resource-constrained platforms.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Crunch压缩是一种进一步减少纹理文件大小的同时保持可接受质量的方法。它对于优化内存使用，尤其是在资源受限的平台上有益。
- en: '**Best practice**: Enable crunch compression for textures where file size reduction
    is crucial, such as UI elements or frequently used textures. Balance the compression
    level to preserve visual quality while minimizing memory impact.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**：对于文件大小减少至关重要的纹理，如UI元素或常用纹理，启用Crunch压缩。平衡压缩级别以在保持视觉质量的同时最小化内存影响。'
- en: Remember, these settings may vary in impact based on the platform, so testing
    and iteration are key. Regularly monitor memory usage and performance metrics
    to fine-tune texture settings for optimal results on each target platform.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些设置的影响可能因平台而异，因此测试和迭代是关键。定期监控内存使用情况和性能指标，以优化纹理设置，以在每个目标平台上获得最佳结果。
- en: By carefully configuring importing settings, you can reduce memory usage and
    improve overall performance in your Unity project.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细配置导入设置，你可以减少内存使用并提高 Unity 项目的整体性能。
- en: Another crucial technique for memory optimization in Unity is utilizing sprite
    atlases.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，利用精灵图集是内存优化的一项关键技术。
- en: Sprite Atlases
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精灵图集
- en: Sprite Atlases in Unity are essential tools for optimizing memory and performance,
    especially for UI elements. They allow you to combine multiple sprites into a
    single image, reducing draw calls and texture memory usage. Let’s learn how to
    use Sprite Atlases effectively while considering their best practices and impact
    on memory and performance.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的精灵图集是优化内存和性能的必要工具，尤其是对于 UI 元素。它们允许你将多个精灵组合成单个图像，减少绘制调用和纹理内存使用。让我们学习如何有效地使用精灵图集，同时考虑其最佳实践和它们对内存和性能的影响。
- en: Creating a Sprite Atlas
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建精灵图集
- en: Note
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you have the **2D Sprite** package installed in your project via **Package
    Manager**.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你通过**包管理器**在你的项目中安装了**2D Sprite**包。
- en: 'In your **Project** tab, right-click and select **Create** | **2D** | **Sprite
    Atlas**, as shown in *Figure 9**.27*:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的**项目**标签页中，右键单击并选择**创建** | **2D** | **精灵图集**，如图 9**.27**所示：
- en: '![Figure 9.27 – Sprite Atlas](img/B22017_09_27.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27 – 精灵图集](img/B22017_09_27.jpg)'
- en: Figure 9.27 – Sprite Atlas
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27 – 精灵图集
- en: Note
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you’ve enabled the **Sprite Packer** option in **Edit** | **Project
    Settings** | **Editor** so that you can start using this package.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在**编辑** | **项目设置** | **编辑器**中启用了**精灵打包器**选项，这样你就可以开始使用这个包了。
- en: 'Enable **Sprite Packer**, as shown in *Figure 9**.28*:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 启用**精灵打包器**，如图 9**.28**所示：
- en: '![Figure 9.28 – Enabling Sprite Packer in Project Settings](img/B22017_09_28.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28 – 在项目设置中启用精灵打包器](img/B22017_09_28.jpg)'
- en: Figure 9.28 – Enabling Sprite Packer in Project Settings
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28 – 在项目设置中启用精灵打包器
- en: 'After creating the sprite atlas, navigate to it to begin adding textures. Click
    on the **+** sign to select individual textures or a folder containing textures.
    Then, click on **Pack Preview** to combine them into an atlas file, as shown in
    *Figure 9**.29*:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 创建精灵图集后，导航到它以开始添加纹理。点击**+**号选择单个纹理或包含纹理的文件夹。然后，点击**打包预览**将它们组合成图集文件，如图 9**.29**所示：
- en: '![Figure 9.29 – Sprite Atlas settings](img/B22017_09_29.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.29 – 精灵图集设置](img/B22017_09_29.jpg)'
- en: Figure 9.29 – Sprite Atlas settings
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.29 – 精灵图集设置
- en: 'Here are some best practices you should consider:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你应该考虑的最佳实践：
- en: Merge frequently used sprites into a single Sprite Atlas to minimize draw calls
    and enhance performance
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将常用精灵合并到单个精灵图集中，以最小化绘制调用并提高性能
- en: Use the packing options in the **Sprite Packer** window to optimize how sprites
    are packed within the atlas, minimizing wasted space
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**精灵打包器**窗口中的打包选项来优化精灵在图集中的打包方式，以最小化浪费的空间
- en: Avoid including excessively large sprites or unnecessary sprites in the atlas
    to keep the atlas’ size manageable
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在图集中包含过大或不必要的精灵，以保持图集大小可控
- en: 'Sprite Atlases have an impact on memory and performance. Let’s take a closer
    look:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集对内存和性能有影响。让我们更深入地了解一下：
- en: '**Memory**: Sprite Atlases help conserve memory by reducing the number of individual
    textures that are loaded into memory. However, be mindful of the total size of
    the Sprite Atlas as it still occupies memory based on its dimensions and content.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：精灵图集通过减少加载到内存中的单个纹理数量来帮助节省内存。然而，请注意精灵图集的总大小，因为它仍然根据其尺寸和内容占用内存。'
- en: '**Performance**: Sprite Atlases improve performance by reducing the number
    of draw calls required to render UI elements. This is especially beneficial for
    complex UIs with numerous sprites.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：精灵图集通过减少渲染 UI 元素所需的绘制调用次数来提高性能。这对于具有许多精灵的复杂 UI 尤其有益。'
- en: Sprite Atlases primarily affect UI elements in terms of memory and performance.
    They are designed to optimize the rendering of 2D graphics, so their impact on
    other aspects of your game, such as 3D models or audio, is minimal. However, for
    UI-heavy games or applications, properly utilizing Sprite Atlases can significantly
    enhance performance and memory management.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集主要影响UI元素在内存和性能方面的表现。它们旨在优化2D图形的渲染，因此它们对游戏的其他方面，如3D模型或音频，的影响最小。然而，对于以UI为主的游戏或应用程序，正确利用精灵图集可以显著提升性能和内存管理。
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on a journey to optimize our game’s performance
    using Unity’s powerful profiling tools. Building upon the skills we’ve already
    acquired, we delved into an introduction to Unity profiling tools, reinforcing
    our ability to identify performance bottlenecks and apply optimization techniques
    to significantly enhance our game’s performance. This chapter further deepened
    our understanding of memory management and optimization, guiding us on how to
    effectively manage memory usage and optimize memory performance in our game. Through
    practical exercises and insights, we solidified our mastery of the Profiler, Frame
    Debugger, and Memory Profiler, ensuring that our game runs smoothly and efficiently.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了使用Unity强大的性能分析工具来优化游戏性能的旅程。在掌握我们已经获得的知识的基础上，我们深入了解了Unity性能分析工具的介绍，加强了识别性能瓶颈和应用优化技术以显著提升游戏性能的能力。本章进一步加深了我们对于内存管理和优化的理解，指导我们如何有效地管理内存使用并优化游戏中的内存性能。通过实际练习和洞察，我们巩固了对Profiler、帧调试器和内存分析器的掌握，确保我们的游戏运行顺畅且高效。
- en: Looking ahead to [*Chapter 10*](B22017_10.xhtml#_idTextAnchor157), we will discover
    a treasure trove of tips and tricks to enhance our Unity development skills using
    C#. The next chapter focuses on productivity-boosting shortcuts, advanced techniques
    and workflows, and troubleshooting common challenges in Unity development. We
    will learn how to utilize shortcuts for efficient development, apply advanced
    techniques to enhance our game development processes, and troubleshoot and find
    solutions to common challenges we may encounter. This chapter will equip us with
    valuable insights that we can implement to improve our workflow, overcome challenges,
    and unlock new possibilities in Unity game development using C#.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 展望[第10章](B22017_10.xhtml#_idTextAnchor157)，我们将发现一大堆使用C#增强Unity开发技能的技巧和窍门。下一章将专注于提高生产力的快捷方式、高级技术和工作流程，以及解决Unity开发中常见挑战的方法。我们将学习如何利用快捷方式提高开发效率，应用高级技术来提升我们的游戏开发流程，并解决我们可能遇到的常见挑战。本章将为我们提供宝贵的见解，我们可以将这些见解应用于改进我们的工作流程、克服挑战，并在使用C#进行Unity游戏开发时解锁新的可能性。
