- en: Advanced Concepts of Building an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter went through the implementation of the HTTP layer of the
    web service. Although the core functionalities of the service are already in place,
    there are still some refinements to cover. This chapter provides a walk-through
    of some additional implementations that will be a part of the catalog web service*,*
    such as soft deleting resources, the HATEOAS approach, adding a response-time
    middleware, and some of the best practices for asynchronous code in ASP.NET Core.
    More specifically, it will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the soft delete technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of asynchronous code in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring the response time of APIs using middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code present in this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the soft delete procedure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Deleting resources* section of [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*, the soft delete technique is a widespread
    deletion practice in real-world applications. Furthermore, it is quite uncommon
    to physically delete entities from our data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleted data may be relevant for historical purposes and for performing analysis
    and reports. The soft delete implementation involves all the projects we have
    seen in the previous three chapters. In order to proceed, let''s add a new `IsInactive`
    field to our `Item` entity inside the `Catalog.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we changed the schema of the `Item` entity, we need to perform another
    EF Core migration by executing the following commands inside the `Catalog.API`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result of the execution of the aforementioned command will generate a new
    migration file inside the `Migrations` folder and the application of the newly
    created migration in the database specified in the connection string of the `Startup`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, as we saw in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*, if we want to connect to the local Docker SQL
    Server instance, we can specify the following connection string in the `appsettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding connection string provides the connection to the local instance
    of SQL Server. In order to run the instance, it is necessary to follow the command
    we saw in Chapter 8\. The following runs the docker instance using the name sql1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can log in into the container using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and finally, we can execute the `sqlcmd` in order to log in into the SQL server
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code above creates the `Store` database with a login user called `catalog_srv`.
    Later in the book, we will see how to automate this process using the tools provided
    by Docker. Now, the database schema is updated, and we are able to continue by
    including the `IsInactive` field in the repository and the service layer of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the IItemRepository implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we added the new `IsInactive` field in our database, we can proceed by
    adapting the `IItemRepository` interface to filter our data based on the `IsInactive`
    field. Therefore, we will proceed by implementing the following changes in order
    to maintain consistency in our data source:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IItemRepository.GetAsync()` method will filter all the fields by `IsInactive
    = false`. Consequently, the resulting response will only contain active entities.
    This kind of approach guarantees that we get a lightweight response when we try
    to get multiple entities from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same way, `GetItemByArtistIdAsync` and `GetItemByGenreIdAsync` will filter
    the result by using the `IsInactive = false` flag. Also, in this case, we want
    to keep the response as light as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IItemRepository.GetAsync(Guid id)` method will retrieve the details of
    the required entity regardless of the `IsInactive` flag. Moreover, this method
    is used by the validation checks of the application, therefore, we need to avoid
    duplicate IDs when we insert new objects, whether they are active or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s proceed by implementing these specifications mentioned in the `IItemRepository`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation changes the behavior of the `GetAsync`, `GetItemByArtistIdAsync`,
    and `GetItemByGenreIdAsync` methods by filtering for `IsInactive == false` using
    the `Where` LINQ clause. On the other hand, `GetAsync(Guid id)` remains the same
    because, as mentioned in the specifications, we want the get detail operation
    to always retrieve the information, including cases where the record is not active.
    Therefore, we can test the resulting implementation by executing the following
    command in the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All tests should pass because, by default, the `IsInactive` Boolean field is
    always `false`. To test the `Where(x=>!x.IsInactive)` change, we can add a new
    record in the `Catalog.API/tests/Catalog.Fixtures/Data/item.json` file by adding
    a new inactive item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we can verify that the number of records retrieved by the get operation
    changes by creating a new test and counting the results. For example, if the `item.json`
    file contains three records and one is inactive, the get operation should retrieve
    three records. As an alternative, we can double-check by verifying that the `Item.Id`
    fields of the result do not include an inactive record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I chose to test the deletion behavior by adding a new `getitems_should_not_return_inactive_records`
    method in the `ItemRepositoryTests` class. The test verifies that when I call
    the `GetAsync` method of the repository, the result excludes the `Item` entity
    with the `Id` specified as a parameter of the test. A similar approach can be
    also taken for the `GetItemByArtistIdAsync` and the `GetItemByGenreIdAsync` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing delete operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have implemented the right filtering logic on the repository side,
    let''s proceed by implementing delete operations in the `Catalog.Domain`project
    by adding a new `DeleteItemAsync` method in the declaration of the `IItemService`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeleteItemAsync` method refers to a `DeleteItemRequest` type, which can
    be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we update the `IItemService` interface declaration, we can proceed by
    adding the implementation to the `ItemService` concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeleteItemAsync` method receives an `Id` field that is part of the `DeleteItemRequest`
    class. Besides, it uses the `GetAsync` method to get the details of the entity,
    and it continues by calling the `Update` method by passing the entity with the
    `IsInactive` flag set to `true`. The next step is to implement a new action method
    in the `ItemController` that covers the following HTTP call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we can proceed by changing the `ItemController` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Delete` action method is decorated with the `HttpDelete` attribute verb,
    which means that it is mapped with the HTTP `Delete` requests. The implementation
    sets the `IsInactive` flag through the `DeleteItemAsync` method, and it returns
    a `NoContent` result, which represents an HTTP `204 No Content` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will proceed by testing the changes made to the `ItemController` class by
    implementing the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This test code covers the following two behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: The `delete_should_returns_no_content_when_called_with_right_id` test method
    checks whether the action method correctly returns the HTTP `NoContent` response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `delete_should_returns_not_found_when_called_with_not_existing_id` method
    checks that the action method returns `HttpStatusCode.NotFound` by passing a non-existent
    GUID (`Guid.NewGuid`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both test cases, we are using the already implemented test infrastructure
    to verify the new behavior of the web service. In this section, we have seen how
    to extend our web service in order to support the soft delete operation.
  prefs: []
  type: TYPE_NORMAL
- en: The next section focuses on the implementation of the HATEOAS response approach.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already discussed the theory around the HATEOAS principle in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml),
    *REST 101 and Getting Started with ASP.NET Core.* This section explains how to
    implement the HATEOAS approach for the `ItemController` already present in the
    `Catalog.API` project. The following snippet of code shows an example of a generic
    HATEOAS response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Although this kind of response adds a heavy payload to the effective JSON response,
    it assists the client by providing the URL for each operation and resource on
    our data. The HATEOAS principle will be implemented side-by-side with `ItemController`,
    and it will give all the necessary information to the client to interact with
    the data owned by the catalog service*.*
  prefs: []
  type: TYPE_NORMAL
- en: Enriching our model with HATEOAS data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get HATEOAS working, we will rely on a third-party NuGet package called
    `RiskFirst.Hateoas`*.* This package allows us to integrate the HATEOAS principle
    in our service efficiently. First of all, let''s proceed by adding the package
    to `Catalog.API` by executing the following command in both project folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new entity called the `ItemHateoasResponse` class, which represents
    the HATEOAS response. This class refers to the already implemented `ItemResponse`
    class, and it implements the `ILinkContainer` interface exposed by the `RiskFirst.Hateoas`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Links` field is a `Dictionary<string, Link>` type and it contains the URLs
    to the resources related to the response. For example, if we get the response
    of a specific item, the `Link` attribute will provide the URLs to add, update,
    and delete the item. The `AddLink` method is used to add new fields to the `Links`
    dictionary. Therefore, we will continue by using this type of response in a controller
    in order to provide a HATEOAS-compliant reaction to our client.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HATEOAS in a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final step is to implement a controller that can handle the `ItemHateoasResponse`
    response model implemented previously. More specifically, we can proceed by creating
    a new `ItemHateoasController` class in our `Catalog.API` project. Note that we
    are building a new controller for demonstration purposes. An alternative would
    be to edit the already defined `ItemController` to return HATEOAS-compliant responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ItemHateoasController` class will use the `ILinksService` interface provided
    by the `RiskFirst.Hateoas` namespace to enrich the `Links` attribute of the `ItemHateoasResponse`
    model and return it to our client. Let''s proceed by implementing the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Get` and `GetById` action methods are quite similar to the one that is
    present in `ItemController`. The only difference is that they return a different
    response type, which is represented by the `ItemHateoasResponse` class. Furthermore,
    the action methods assign the `response` object to the `Data` field. Each action
    method also calls the `AddLinksAsync` method provided by the `ILinksService` interface
    to populate the link attribute. In the same way, we can extend the behavior of
    the other action methods present in the controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the declaration of the implementation of the create, update, and delete
    action methods. Also, in this case, we are using the `ItemHateoasResponse` model
    class to retrieve the response of the action method. We should notice that the
    action methods declare `Name` in the `[HttpVerb]` attribute decorator, such as
    `[HttpDelete("{id:guid}", Name = nameof(Delete))]`. Indeed, we will use the `Name`
    declared by the attribute in the `Startup` class to refer to each route and include
    it in the `Link` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `AddLinks` extension method provided by the `RiskFirst.Hateoas` package
    allows us to define the policies related to a response model. This is the case
    for the `config.AddPolicy<ItemHateoasResponse>` method, which calls `RequireRoutedLink`
    for each action method name declared in `ItemsHateoasController`. Note that, similar
    to the previous cases, we can extract this snippet of code in an external extension
    method to keep the `Startup` class as clean as possible. Finally, this kind of
    approach allows us to define different groups of links for different response
    models. Moreover, it is possible to establish a policy related to a specific response
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we can now run and verify the result by executing the `dotnet
    run` command in the `Catalog.API` folder. Please note, to run the Docker SQL Server,
    specify the connection string in `appsetting.json` file. After that, we can run
    the following `curl` request to verify `ItemsHateoasController`. The resulting
    JSON response will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in addition to the list of items, `ItemHateoasController` also
    retrieves an envelope that provides additional information to the client, such
    as the other routes needed for the get, add, update, and delete operations. Furthermore,
    this approach gives all the URIs needed by the client, in order to navigate through
    the information exposed by the web service.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous code in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the asynchronous code stack of ASP.NET Core.
    We have already dealt with the asynchronous pattern, and we have already seen
    that some of the implementations in the previous chapters used asynchronous code
    extensively.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the following section is mainly focused on asynchronous code in ASP.NET
    Core based on .NET Core. Bear in mind that there are some differences between
    asynchronous programming in .NET Core and .NET Framework. Some of the deadlocking
    issues that we are used to seeing in .NET Framework are not present in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start digging into the asynchronous code, let's take a look at the
    differences between synchronous and asynchronous systems in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, when a synchronous API receives a request, a thread from the thread
    pool will handle the request. The assigned thread is busy until the end of the
    request life cycle. In most cases, the API performs I/O operations on data or
    third-party APIs, which means that the thread will be blocked until the end of
    these operations. More specifically, a blocked thread cannot be used by other
    operations and requests. For asynchronous code, however, the behavior is entirely
    different.
  prefs: []
  type: TYPE_NORMAL
- en: The request will be assigned to a thread, but the thread will not be locked,
    and it can be assigned and used by other operations. If the task is awaited and
    it doesn't involve CPU-bound work, then the thread can be released to return to
    the pool to carry out other work.
  prefs: []
  type: TYPE_NORMAL
- en: Task definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Task` type represents asynchronous tasks. The `Task` class is a representation
    of a unit of work. We can find similar concepts in other languages. For example,
    in JavaScript, the concept of `Task` is represented by a `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to associate a `Task` type with a thread in our CPU, which is
    not correct: wrapping a method execution in a `Task` doesn''t guarantee that the
    operation will be executed on another thread.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async` and `await` keywords are the easiest way to deal with asynchronous
    operations in C#: the `async` keyword converts the method into a state machine
    and it enables the `await` keyword in the implementation of the method. The `await`
    keyword indicates to the compiler the operations that need to be awaited in order
    to proceed with the execution of the asynchronous method. Therefore, it is common
    to find something similar in C# codebases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is very intuitive: it calls a `url` using the `GetAsync`
    method of the `_httpClient` instance, and it uses `ReadAsStringAsync` to get the
    resulting string and store it in the `responseContent` object. It is essential
    to understand that `async` and `await` are syntactic sugar keywords, and the same
    result can be achieved in a less readable way by using the `ContinueWith` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet has the same effect as the previous one. The main difference
    is that this code is less intuitive. Furthermore, in complex operations that execute
    a lot of nested transactions, we would create a lot of nesting levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to embrace the `async`/`await` syntax as the primary way of
    working with asynchronous code. Other languages have taken a similar approach
    to keep the code more clean and readable. This is the case for ECMAScript, which
    introduced the `async`/`await` syntax in ES 2016: [https://github.com/tc39/ecma262/blob/master/README.md](https://github.com/tc39/ecma262/blob/master/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: The need for asynchronous code in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to underline is that asynchronous code is not about speed.
    As mentioned before, asynchronous programming is just about not blocking incoming
    requests. Therefore, the real benefit is about better vertical scalability*,*
    instead of increasing the speed of our code. For example, let''s suppose that
    our web services perform some I/O operations such as queries on a database: in
    case we run our code stack in a synchronous way, the thread used by an incoming
    request will be blocked and not used by any other request until the read or write
    (I/O operation) process is completed. By taking an asynchronous approach we are
    able to release the thread as soon as the read/write operation is executed. Therefore,
    once the I/O operation is finished, the application will pick up another or the
    same thread in order to continue the execution of the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asynchronous code also adds an overhead cost to our system, in fact, it
    is necessary to add additional logic to coordinate asynchronous operations. For
    example, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned example defines an action method that calls an asynchronous
    method. With the help of some external tools, such as ILSpy, it is possible to
    decompile the C# code and analyze the IL code. The **IL code** is also known as
    the **intermediate code**, which is the code that is generated by the C# compiler
    and executed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting transformation in the IL code of the previously defined `Get`
    method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the method has been transformed into a sealed class that implements
    the `IAsyncStateMachine` interface. The `MoveNext` method continuously checks
    whether the `__state` of the state machine is changed and updates the result of
    the operation. All these operations are performed for each asynchronous operation
    contained in our code.
  prefs: []
  type: TYPE_NORMAL
- en: What's new in ASP.NET Core?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its introduction in the old ASP.NET framework, the `async`/`await` code
    was previously affected by some *deadlock issues*. The old version of ASP.NET
    uses a class called `SynchronizationContext`, which essentially provides a way
    to queue a `Task` to a context when a method calls other tasks that are nested
    asynchronous methods and forces them to be executed synchronously using the `.Result`
    or `.Wait()` keywords, therefore, this causes a deadlock of the request context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that the following code is executed on the old
    version of ASP.NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This leads to a deadlock in the application because the `Get()` and `Operation1Async()`
    methods are using the same context. While the `Operation1Async()` method captures
    the context, which will be used to continue running the method, the `Get()` action
    method is blocking the context because it is waiting for a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, developers started to fill their asynchronous code with `.ConfigureAwait(false)`
    instructions, which primarily provides a way to execute the `Task` in a different
    context by avoiding the deadlock issue seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This kind of approach works, but we should consider that by calling `Result`
    or `.Wait()`, we are losing all the benefits provided by the asynchronous programming
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news about ASP.NET Core is that it doesn''t use `SynchronizationContext`.
    The *context-less* idea provides lightweight management of the asynchronous code:
    while ASP.NET queues each asynchronous unit in the request context before assigning
    it to a thread, ASP.NET Core picks up a thread from the assigned thread pool and
    attaches it to the asynchronous task.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the ASP.NET team has done an excellent job with ASP.NET Core and,
    as we saw in previous chapters, almost every component that is part of the ASP.NET
    Core pipeline has both a *synchronous* and an *asynchronous* version. This is
    the case, for example, for the action filter that we saw in [Chapter 6](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml)*,*
    *Filter Pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: While the `.ConfigureAwait(false)` method is not needed anymore with the new
    version of .NET Core, we should keep in mind that it is still useful in some codebases.
    If you are building a .NET library that compiles in .NET Core but also in older
    version of the .NET Framework, you should still use the `.ConfigureAwait(false)`
    method in order to avoid deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices in asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at some good and bad practices to do with the asynchronous
    programming model in ASP.NET Core. First of all, the central concept to keep in
    mind is to avoid mixing between synchronous and asynchronous code. As mentioned
    previously, ASP.NET Core exposes both the sync and `async` versions of the majority
    of classes and interfaces. Therefore, before blocking an asynchronous stack with
    synchronous code, you should explore and check all the alternatives provided by
    the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recommendations come from a high-level perspective of asynchronous
    programming in .NET. This book is focused on other aspects of the framework. If
    you want to get more details about how to work with asynchronous programming,
    I suggest you navigate to the following link: [https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md).
    Moreover, if you want a more general overview of concurrency in .NET, I suggest
    you read the following book: *Concurrency in C# Cookbook* by Stephen Cleary ([https://stephencleary.com/book/](https://stephencleary.com/book/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use async void methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common mistake about asynchronous programming in .NET Core and, more in general,
    in the whole .NET ecosystem, is to declare a method as `async void`. Indeed, when
    we declare a method as `async void`, we will not be able to catch exceptions thrown
    by the method. Furthermore, the `Task` type is used to capture the exceptions
    of the method and propagate them to the caller. In summary, we should always implement
    our `async` methods by returning the `Task` type when the method returns `void`,
    otherwise, we should return the `Task<T>` generic type when the method returns
    a type. Furthermore, the `Task` type is also useful when we want to notify the
    status of the operation to the caller: the `Task` type exposes the status of the
    operation through the following attributes: `Status`, `IsCanceled`, `IsCompleted,`
    and `IsFaulted`.'
  prefs: []
  type: TYPE_NORMAL
- en: Use Task.FromResult over Task.Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have previously worked with .NET Core or .NET Framework, you have probably
    dealt with both `Task.FromResult` and `Task.Run`. Both can be used to return `Task<T>`.
    The main difference between them is in their input parameters. Take a look at
    the following `Task.Run` snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Task.Run` method will queue the execution as a work item in the thread
    pool. The work item will immediately complete with the pre-computed value. As
    a result, we have wasted a thread pool. Furthermore, we should also notice that
    the initial purpose of `Task.Run` method was intended for the client-side .NET
    applications: ASP.NET Core is not optimized for the `Task.Run` operations and
    it shouldn''t ever be used to offload the execution of a portion of code. On the
    opposite side, let''s examine another case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Task.FromResult` method will wrap the pre-computed result
    without wasting a thread pool which means that we will not have the overhead provided
    by the execution of the `Task.Run` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Enable cancellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important topic is to enable the cancellation of asynchronous operations.
    If we take a look at the service layer that we implemented in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    and [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), we can see that in
    some cases we have the possibility of passing `CancellationToken` as a parameter.
    The `CancellationToken` provides a light way to notify all asynchronous operations
    that the consumer wants to cancel the current transaction. Moreover, our code
    can examine the `CancellationToken.IsCancellationRequested` property to detect
    whether the consumer has requested the cancellation of the task. This kind of
    approach is especial suitable for long-running operations because the consumer
    of our asynchronous code can request the cancellation of the current performing
    task at any point in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous code in I/O bound operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we implement code in an asynchronous way we should ask ourselves if the
    underlying process involves any kind of I/O operation. If this is the case, we
    should proceed by using an asynchronous approach for that stack. For example,
    the `Get` operation of the `ItemRepository` class involves a query to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are using the `FirstOrDefaultAsync` method to execute the
    operation in an asynchronous way. On the opposite side, if we take as an example
    another operation, such as the `Add` method of the `ItemRepository` we can see
    that the operation is not asynchronous even if the EF Core framework exposes the
    `AddAsync` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because in the case of the adding operation we are not performing any
    kind of I/O operation: the entity is added to the `context` attribute and marked
    with an added status. The proper synchronization with the database happens when
    we call the `SaveChangesAsync` method which is asynchronous because it involves
    I/O operations with the database. In conclusion, we should always keep in mind
    to understand the full context and stack of the operation that we want to execute
    in an asynchronous manner. In general, every time we have to deal with the file
    system, a database, and any other network call we should implement our code using
    an asynchronous stack, otherwise we can keep the code synchronous in order to
    avoid additional thread overheads.'
  prefs: []
  type: TYPE_NORMAL
- en: Measure response time using middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common way to measure the response time of ASP.NET Core actions is by using
    a *middleware component*. As seen in [Chapter 3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml),
    *Working with the Middleware Pipeline*, these components act at the edge of the
    ASP.NET Core request life cycle, and they are useful for performing cross-cutting
    implementations. Measuring the response time of an action method falls into this
    implementation case. Furthermore, middleware is the first component hit by a request
    and the last one that can process an outgoing response. This means that we can
    analyze and include almost the whole life cycle of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an implementation of `ResponseTimeMiddlewareAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous class defines an `async` middleware to detect the response time
    of the requests. It follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It declares a `Stopwatch` instance in the `InvokeAsync` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes the `Start()` method of the `Stopwatch` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines a new response delegate using the `OnStarting` method. The `OnStarting`
    method, which allows us to declare a delegate action to be invoked just before
    the response headers, will be sent to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls the `Stop()` method and sets the `ElapsedMilliseconds` property as
    a custom header using the `X-Response-Time-ms` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is possible to include the `ResponseTimeMiddlewareAsync` class in the middleware
    pipeline by adding the following line in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, it is also possible to test the middleware by following the same
    approach we took for testing the controllers by implementing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `ResponseTimeMiddlewareTests` class allows us to make an HTTP call by extending
    the `InMemoryApplicationFactory` class. We can check whether the `X-Response-Time-ms`
    header exists in the response object. It is important to note that the other measurement
    doesn't include the startup time of the web server or the application pool. Furthermore,
    it takes some additional time when the webserver is not initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered some different topics about building an API: from
    the soft deletion of our resources to how to measure the performance of responses.
    We also had an overview of the asynchronous programming stack of ASP.NET Core
    and some recommendations as to how to use it. The topics covered in this chapter
    will be helpful to you at an advanced development stage in order to improve the
    readability of the returned data and the performance of the web service. In the
    next chapter, we will see how to run our catalog solution using containerization
    technologies. The chapter provides an overview of Docker and on the related Docker
    compose tools.'
  prefs: []
  type: TYPE_NORMAL
