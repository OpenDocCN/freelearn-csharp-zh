- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Effects with Particle Systems and Visual Effect Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue learning about visual effects for our game.
    We will be discussing particle systems, a way to simulate fire, waterfalls, smoke,
    and all kinds of fluids. Also, we will see the two Unity **particle systems**
    to create these kinds of effects, **Shuriken**, and **Visual Effect Graph**, the
    latter being more powerful than the first but requiring more hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following particle system topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Shuriken particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating fluid simulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating complex simulations with Visual Effect Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Shuriken particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All graphics and effects we have created so far use static meshes—3D models
    that can’t be skewed, bent, or deformed in any way. **Fluids** such as fire and
    smoke clearly can’t be represented using this kind of mesh, but actually, we can
    simulate these effects with a combination of static meshes, and this is where
    particle systems are useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Particle systems** are objects that emit and animate lots of **particles**
    or **billboards**, which are simple quad meshes that face the camera. Each particle
    is a static mesh, but rendering, animating, and combining lots of them can generate
    the illusion of a fluid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11.1* you can see a smoke effect using particle systems on the left,
    and on the right, the **Wireframe** view of the same particles. There you can
    see the quads that create the illusion of smoke, which is done by applying a smoke
    texture to each of the particles and animating them, so they spawn at the bottom
    and move up in random directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: On the left side, a smoke particle system; on the right side,
    the wireframe of the same system'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following topics related to particles:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic particle system with Shuriken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing how to create our very first particle system using
    Shuriken.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic particle system with Shuriken
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the creation of a particle system, let’s create an explosion
    effect. The idea is to spawn lots of particles at once and spread them in all
    directions. Let’s start with creating the Shuriken particle system and configuring
    the basic settings it provides to change its default behavior. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **GameObject | Effects | Particle System** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Particle System button'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the effect in the following screenshot. The default behavior
    is a column of particles going up, like the smoke effect shown previously. Let’s
    change that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Default particle system appearance'
  prefs: []
  type: TYPE_NORMAL
- en: Click the created object in the scene and look at the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Shape** section by clicking on the title. Here you will be able to
    specify the particle emitter shape from where the particles are going to be spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the **Shape** property to **Sphere**. Now the particles should move
    in all possible directions instead of following the default cone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Shape properties'
  prefs: []
  type: TYPE_NORMAL
- en: In the particle system **module** (usually known as **Main**) set **Start Speed**
    to `10`. This will make the particles move faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same module, set **Start Lifetime** to `0.5`. This specifies how long
    a particle will live. In this case, we have given a lifetime of half a second.
    In combination with the speed (10 meters per second), this makes the particles
    disappear after moving 5 meters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Main Particle System module'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Emission** module and set **Rate over Time** to `0`. This property
    specifies how many particles will be emitted per second, but for an explosion,
    we actually need a burst of particles, so we won’t emit particles constantly over
    time in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Bursts** list, click the **+** button at the bottom, and in the created
    item in the list, set the count column to `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Emission module'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Main** module (the one titled **Particle System**) set **Duration**
    to `1` and uncheck **Looping**. In our case, the explosion won’t repeat constantly;
    we just need one explosion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Looping checkbox'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the particle isn’t looping, you need to manually hit the **Play** button
    that is shown in the **Particle Effect** window in the bottom-right part of the
    Scene view to see the system. If you don’t see that window, remember to first
    select the GameObject with the Particle System in the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Particle system playback controls'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set **Stop Action** to **Destroy**. This will destroy the object when the **Duration**
    time has passed. This will just work when you are running the game, so you can
    safely use this configuration while editing your scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Stop Action set to Destroy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the **Start Size** of the **Main** module to `3`. This will make the particles
    bigger so they seem denser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Particle system Start Size'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the down-pointing arrow at the right of the **Start Rotation** property
    of the **Main** module and select **Random Between Two Constants**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Start Rotation** to `0` and `360` in the two input values that appeared
    after *step 14*. This allows us to give the particles a random rotation when they
    spawn to make them look slightly different from each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Random Start Rotation'
  prefs: []
  type: TYPE_NORMAL
- en: Now the particles behave as expected, but they don’t look as expected. Let’s
    change that. Create a new material by clicking on the **+** icon in the Project
    view and selecting **Material**. Call it `Explosion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its shader to **Universal Render Pipeline/Particles/Unlit**. This is a
    special shader that is used to apply a texture to the Shuriken particle system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Particle system material shader'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download a smoke particle texture from the internet or the **Asset Store**.
    In this case, it is important to download one with a black background; ignore
    the others:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Smoke particle texture'
  prefs: []
  type: TYPE_NORMAL
- en: Set this texture as the **Base Map** of the material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Surface Type** to **Transparent** and the **Blending Mode** to **Additive**.
    Doing this will make the particles blend with each other, instead of being drawn
    on each other, to simulate a big mass of smoke instead of individual smoke puffs.
    We use **Additive** mode because our texture has a black background and because
    we want to create a lighting effect (the explosion will brighten the scene):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Surface options for particles'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag your material to the **Material** property of the **Renderer** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: Particle material settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now your system should look like the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: Result of the previous settings'
  prefs: []
  type: TYPE_NORMAL
- en: With those steps, we have changed how the particles or billboards will spawn
    (using the **Emission** module), in which direction they will move (using the
    **Shape** module), how fast they will move, how long they will last, how big they
    will be (using the **Main** module), and what they will look like (using the **Renderer**
    module). Creating particle systems is a simple case of properly configuring their
    different settings. Of course, doing it properly is an art on its own; it requires
    creativity and knowledge of how to use all the settings and configurations they
    provide. So, to increase our skillset, let’s discuss some advanced modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our system looks nice, but we can improve it a lot, so let’s enable some new
    modules to increase its quality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the checkbox on the left of **Color over Lifetime** to enable it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: Enabling the Color over Lifetime module'
  prefs: []
  type: TYPE_NORMAL
- en: Open the module by clicking on the title, and click the white bar on the right
    of the **Color** property. This will open the gradient editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click slightly to the right of the top-left white marker in the bar to create
    a new marker. Also, click slightly to the left of the top-right white marker to
    create the fourth marker. These markers will allow us to specify the transparency
    of the particles during their life:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: Color over Lifetime gradient editor'
  prefs: []
  type: TYPE_NORMAL
- en: If you created unwanted markers, just drag them outside the window to remove
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the top-left marker (not the one we created, the one that was already
    there) and set the **Alpha** slider at the bottom to `0`. Do the same with the
    top-right marker, as shown in the following screenshot. Now you should see the
    particles fading away instead of popping out of existence when the explosion is
    finishing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Fade-in and fade-out gradient'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the **Limit Velocity over Lifetime** module by clicking on its checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Dampen** setting to `0.1`. This will make the particles slowly stop
    instead of continuing to move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: Dampen the velocity to make the particles stop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable **Rotation over Lifetime** and set the **Angular Velocity** between
    `-90` and `90`. Remember that you should set the value in **Random Between Two
    Constants** by clicking on the down-pointing arrow to the right of the property.
    Now the particles should rotate during their lives to simulate more motion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.21: Random rotation velocity'
  prefs: []
  type: TYPE_NORMAL
- en: Some of these effects will be very subtle given the short **Lifetime** we set
    in the **Main Module** when we just created the particle. Feel free to increase
    the **Lifetime** value to see those effects in more detail, but consider that
    this could lead to an excessive number of particles if you spawn them frequently,
    reducing performance. Just be wary about how they impact your performance when
    tweaking those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are lots of extra modules that can be enabled and disabled
    to add layers of behavior on top of the existing ones, so again, use them creatively
    to create all kinds of effects. Remember that you can create Prefabs of these
    systems to replicate them all over your scene. I also recommend searching for
    and downloading particle effects from the Asset Store to see how other people
    have used the same system to create amazing effects. Seeing a variety of different
    systems is the best way to learn how to create them, and that is what we are going
    to do in the next section: create more systems!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating fluid simulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said, the best way to learn how to create particle systems is to keep
    looking for already-created particle systems and explore how people have used
    the various system settings to create completely different simulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to create the following effects using particle
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: A waterfall effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bonfire effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the simplest one, the waterfall effect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a waterfall effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new particle system (**GameObject** | **Effects** | **Particle System**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Shape** to **Edge** and its **Radius** to `5` in the **Shape** module.
    This will make the particles spawn along a line of emission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.22: Edge shape'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **Rate over Lifetime** of the **Emission** module to `50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Start Size** of the **Main** module to `3` and the **Start Lifetime**
    to `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.23: Main module settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the **Gravity Modifier** of the Main module to `0.5`. This will make the
    particles fall down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.24: Gravity Modifier in the Main module'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the same `Explosion` material we created previously for this system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.25: Explosion particle material'
  prefs: []
  type: TYPE_NORMAL
- en: Enable **Color Over Lifetime** and open the **Gradient** editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the bottom-right marker, and this time you should see a color picker
    instead of an alpha slider. The top markers allow you to change the transparency
    over time, while the bottom ones change the color of the particles over time.
    Set a light blue color in this marker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.26: White to light blue gradient'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a challenge, I suggest you add a little particle system where this one ends
    to create some water splashes, simulating the water colliding with a lake at the
    bottom. Now we can add this particle system to one of the hills of our scene to
    decorate it, like in the following screenshot. I have adjusted the system a little
    bit to look better in this scenario. I challenge you to tweak it by yourself to
    make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.27: The waterfall particle system being applied to our current scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create another effect: a bonfire.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bonfire effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a bonfire, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a particle system like we did in the section *Creating a basic particle
    system with Shuriken*, in **GameObject | Effects | Particle System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for a **Fire Particle Texture Sheet** texture on the internet or the Asset
    Store. This kind of texture should look like a grid of different flame textures.
    The idea is to apply a flame animation to our particles swapping all those mini
    textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.28: Particles texture sprite sheet'
  prefs: []
  type: TYPE_NORMAL
- en: Create a particle **material** that uses the **Universal Render Pipeline/Particles/Unlit**
    shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the flames sprite sheet texture as the **Base Map**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the color at the right of the **Base Map** to white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set this material as the particle material. Remember to set **Surface Type**
    to **Transparent** and **Blending Mode** to **Additive**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.29: A material with a particle sprite sheet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the **Texture Sheet Animation** module and set the **Tiles** property
    according to your fire sheet. In my case, I have a grid of 4x4 sprites, so I put
    `4` in **X** and `4` in **Y**. After this, you should see the particles swapping
    textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.30: Enabling Texture Sheet Animation'
  prefs: []
  type: TYPE_NORMAL
- en: Set **Start Speed** to `0` and **Start Size** to `1.5` in the Main module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Radius** to `0.5` in **Shape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a second particle system and make it a child of the fire system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.31: Parenting particle systems'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the **Explosion** material from the explosion example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Angle** to `0` and **Radius** to `0.5` in the **Shape** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The system should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.32: Result of combining fire and smoke particle systems'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can combine several particle systems to create a single
    effect. Take care when doing this because it’s easy to emit too many particles
    and affect the game’s performance. Particles are not cheap and may cause a reduction
    in the game’s **FPS (Frames Per Second)** if you are not cautious with them.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored one of the Unity systems that you can use to create
    these kinds of effects, and while this system is enough for most situations, Unity
    recently released a new one that can generate more complex effects, called **Visual
    Effect Graph**. Let’s see how to use it and see how it differs from Shuriken.
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex simulations with Visual Effect Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The particle system we have used so far is called Shuriken, and it handles
    all calculations in the CPU. This has both pros and cons. A pro is that it can
    run on all possible devices that Unity supports, regardless of their capabilities
    (all of them have CPUs), but a con is that we can exceed CPU capabilities easily
    if we are not cautious with the number of particles we emit. Modern games require
    more complex particle systems to generate believable effects, and this kind of
    CPU-based particle system solution has started to reach its limit. This is where
    the Visual Effect Graph comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.33: On the left, a massive particle system, and on the right, an
    example of a Visual Effect Graph'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Effect Graph** is a GPU-based particle system solution, meaning that
    the system is executed in the video card instead of the CPU. That’s because video
    cards are far more efficient at executing lots and lots of little simulations,
    like the ones each particle of a system needs, so we can reach far higher orders
    of magnitude in the number of particles with the GPU than we can with the CPU.
    The con here is that we need a fairly modern GPU that has **compute shader** capabilities
    to support this system, so we will exclude certain target platforms using this
    system (forget about most mobile phones), so use it if your target platform supports
    it (mid- to high-end PCs, consoles, and some high-end phones).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the following topics of Visual Effect Graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Effect Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and analyzing a Visual Effect Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rain effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by seeing how we can add support for Visual Effect Graph in our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Effect Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have used lots of Unity features that were already installed in our
    project, but Unity can be extended with a myriad of plugins, both official and
    third-party. Visual Effect Graph is one of those features that needs to be independently
    installed if you are using **Universal Render Pipeline** **(URP)**. We can do
    that using the Package Manager, a Unity window dedicated to managing official
    Unity plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Something to think about when you are installing those packages is that each
    package or plugin has its own version, independent of the Unity version. That
    means that you can have Unity 2022.1 installed, but Visual Effect Graph 13.1.8
    or whatever version you want, and you can actually update the package to a newer
    version without upgrading Unity. This is important because some versions of these
    packages require a minimum version of Unity—for example, Visual Effect Graph 13.1.8
    requires Unity 2022.1 as a minimum. Moreover, some packages depend on other packages
    and specific versions of those packages, so we need to ensure we have the correct
    versions of every package to ensure compatibility. To be clear, the dependencies
    of a package are installed automatically, but sometimes we can have them installed
    separately, so in that scenario, we need to check the required version. It sounds
    complicated, but it is simpler than it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, in order to get Visual Effect Graph working
    properly we need version 13.1.8, and also we need the same version of **Universal
    RP**. Yes, Universal RP is another feature you can install using the Package Manager,
    but as we created the project using the Universal RP template, it was already
    installed for us with the proper version. With that in mind, let’s install the
    Visual Effect Graph as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top menu of Unity, go to **Window | Package Manager**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.34: Package Manager location'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to be sure the **Packages** dropdown is in **Unity Registry** mode,
    to see the Unity official packages list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.35: Package Manager Unity Registry mode'
  prefs: []
  type: TYPE_NORMAL
- en: In the left column, locate **Universal RP** and check whether it says 13.1.8
    or higher to the right. If it does, jump to *step 6*. Remember, though, that a
    higher version may look different or have different steps for use than the ones
    displayed in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don’t have version 13.1.8 or higher, click on the right-pointing arrow
    at the left to display a list of all possible versions to install. Locate 13.1.8
    and click it. In my case it says **Currently installed** as I have that version
    already installed in the project, and there’s no other one available for Unity
    2022:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.36: Package version selector'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Update to 13.1.8** button in the bottom-right part of the window
    and wait for the package to update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for the **Visual Effect Graph** package on the left side of the window.
    As you did with Universal RP, make sure you select version 11.0.0 or the closest
    higher available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.37: Visual Effect Graph package'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Install** button at the bottom-right of the window and wait for
    the package to install. Sometimes it is recommended to restart Unity after installing
    packages, so save your changes and restart Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have installed Visual Effect Graph, let’s create our first particle
    system using it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and analyzing a Visual Effect Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method to create a particle system using Visual Effect Graph is similar
    to a regular Particle System. We will chain and configure modules as parts of
    the behavior of the particles, each module adding some specific behavior, but
    the way we do it is very different than with Shuriken. First, we need to create
    a **Visual Effect Graph**, an asset that will contain all the modules and configurations,
    and then make a GameObject that will execute the Graph asset to spawn particles.
    Let’s do that with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project window, click on the **+** button and look for **Visual Effects
    | Visual Effect Graph**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.38: Visual Effect Graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **Empty** GameObject using the **GameObject** | **Create Empty**
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.39: Empty GameObject creation'
  prefs: []
  type: TYPE_NORMAL
- en: Select the created object and look at the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the **Add Component** search bar, look for the **Visual Effect** component
    and click on it to add it to the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.40: Adding a component to the Visual Effect Graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the **Visual Effect** asset we created to the **Asset Template** property
    of the **Visual Effect** component in our GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.41: Visual Effect using the previously created Visual Effect asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see clock particles being emitted from our object, which is the
    default behavior included in a new Visual Effect asset, meaning it’s being executed
    correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.42: Default Visual Effect asset results'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a base effect, let’s create something that requires a lot
    of particles, such as dense rain. Before doing so, we will explore some core concepts
    of Visual Effect Graph. If you double-click the Visual Effect asset, you will
    see the following editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.43: Visual Effect Graph editor window'
  prefs: []
  type: TYPE_NORMAL
- en: This window is composed of several interconnected nodes, generating a flow of
    actions to be executed. As with the Shader Graph, you can navigate this window
    by keeping the *Alt* key (*Option* on Mac) pressed and dragging with the mouse
    the empty areas of the graph. At first, it seems similar to the Shader Graph,
    but it works a little bit differently, so let’s study each section of the default
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first area to explore is the dotted one that contains three nodes. This
    is what Unity calls a **System**. A System is a set of nodes that defines how
    a particle will behave, and you can have as many as you want, which is the equivalent
    of having several particle system objects. Each System is composed of **Contexts**,
    the nodes inside the dotted area, and in this case, we have **Initialize Particle**,
    **Update Particle**, and **Output Particle Quad**. Each Context represents a different
    stage of the particle system logic flow, so let’s define what each Context in
    our graph does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialize Particle**: This defines the initial data of each emitted particle,
    such as position, color, speed, and size. It is similar to the **Start** properties
    in the Main module of the particle system we saw at the beginning of this chapter.
    The logic in this node will only execute when a new particle is emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update Particle**: Here, we can apply modifications to the data of the living
    particles. We can change particle data such as the current velocity or particle
    size of all the frames. This is similar to the **Overtime** nodes of the Shuriken
    particle systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output Particle Quad**: This Context will be executed when the particle needs
    to be rendered. It will read the particle data to see where to render, how to
    render, which texture and color to use, and the different visual settings. This
    is similar to the renderer module of the previous particle system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside each Context, apart from some base configurations, we can add **Blocks**.
    Each Block is an action that will be executed in the Context. We have actions
    that can be executed in any Context and then some specific Context actions. As
    an example, we can use an **Add Position Block** in the Initialize Particle Context
    to move the initial particle position, but if we use the same Block in the Update
    Particle Context, it will move the particle constantly. So basically, Contexts
    are different situations that happen in the life of the particle, and Blocks are
    actions that are executed in those situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.44: A Set Velocity Random Block inside the Initialize Particle Context.
    This sets the initial velocity of a particle'
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can have **Standalone Contexts**, Contexts outside Systems, such as
    **Spawn**. This Context is responsible for telling the System that a new particle
    needs to be created. We can add Blocks to specify when the context will tell the
    system to create the particle, such as at a fixed rate over time, bursts, and
    so on. The idea is that Spawn will create particles according to its Blocks, while
    a System is responsible for initializing, updating, and rendering each of them,
    again, according to the blocks we set up inside each one of those Contexts.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can see that there are lots of similarities with Shuriken, but the way
    to create a system here is quite different. Let’s reinforce this by creating a
    rain effect, which will require lots of particles—a nice use case for Visual Effect
    Graph.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rain effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create this effect, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the **Capacity** property of the **Initialize Particle** Context to `10000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.45: Initialize Particle Context'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the **Rate** of the **Constant Spawn Rate** of the **Spawn** context to
    `10000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.46: Constant Spawn Rate Block'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the **A** and **B** properties to `0`, `-50`, and `0` and `0`, `-75`, and
    `0` respectively in the **Set Velocity Random** block in the **Initialize Particle**
    Context. This will set a random velocity pointing downward for our particles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.47: Set Velocity Random Block'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the **Initialize Particle** title, and select **Create Block**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for the **Set Position Random** block and click on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.48: Adding blocks'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **A** and **B** properties of the **Set Position Random** Block to `-50`,
    `0`, and `-50` and `50`, `0`, and `50` respectively. This will define an initial
    area in which to randomly spawn the particle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the arrow at the left of the **Bounds** property of the **Initialize Particle**
    Block to display its properties, and set **Center** and **Size** to `0`, `-12.5`,
    and `0` and `100`, `25`, and `100` respectively. This will define the area where
    the particles should be visible. Particles can actually move outside this area,
    but it is important to render the particles only in the areas we are interested
    in them being visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search `Frustum culling` on the internet for more information about bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.49: Configuring blocks'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the GameObject that is executing the system, and in the bottom-right
    window in the Scene view check the **Show Bounds** checkbox to see the previously
    defined bounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.50: Visual Effect playback controls'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t see the window at the bottom right, click the **VE** (Visual Effect)
    button at the top-left side of the screen to display it. This button will be shown
    only if you have selected the **Rain** visual effect GameObject in the **Hierarchy**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.51: Another way to display the Visual Effect playback controls'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t see the changes being applied, click the **Compile** button in
    the top left of the window, the one that looks like a paper bin beneath a downward-pointing
    arrow. Also, you can save your changes using *Ctrl* + *S* (*Command* + *S* on
    Mac):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.52: VFX asset saving controls'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the object position to cover the whole base area. In my case, the position
    is `100`, `37`, and `100`. Remember that you need to change the **Position** of
    the **Transform** component for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.53: Setting a Transform position'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the **A** and **B** properties of the **Set Lifetime Random** Block in
    the **Initialize Particle** to `0.5`. This will make the particles have a shorter
    life, ensuring that they are always inside the bounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.54: Set Lifetime Random Block'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the **Main Texture** property of the **Output Particle Quad** Context
    to another texture. In this case, the previously downloaded smoke texture can
    work here, even though it’s not water, because we will modify its appearance in
    a moment. Also, you can try to download a water droplet texture if you want to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.55: VFX Graph Main Texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set **Blend Mode** of the **Output Particle Quad** Context to **Additive**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.56: Additive mode of VFX Graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to stretch our particles a little bit to look like actual raindrops
    instead of falling balls. Before accomplishing that, first we need to change the
    orientation of our particles, so they don’t point at the camera all the time.
    In order to do this, right-click on the **Orient Block** in the **Output Particle
    Quad** Context and select **Delete** (or press *Delete* on PC or *Command* + *Backspace*
    on Mac):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.57: Deleting a block'
  prefs: []
  type: TYPE_NORMAL
- en: We want to stretch our particles according to their velocity direction. Another
    preparation step before actually doing that is to select the title of the **Output
    Particle Quad** context and hit the space bar to look for a block to add. In this
    case, we need to search and add the **Orient Along Velocity** block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Set Scale** Block to the **Initialize Particle** Context and set the
    **Scale** property to `0.25`, `1.5`, and `0.25`. This will stretch the particles
    to look like falling drops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.58: Set Scale Block'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Compile** button in the top-left window again to see the changes.
    Your system should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.59: Rain results'
  prefs: []
  type: TYPE_NORMAL
- en: We have just modified lots of different properties of the Visual Effect Graph,
    but if you want to have two instances of the same Visual Effect Graph, but with
    slight differences, I recommend you look at the Blackboard feature, which will
    allow you to expose properties in the Inspector. For example, you can make less
    dense rain on another scene, making the spawn rate lower, or change the particle
    color to make acid rain, all using the same graph, but let’s keep things simple
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: The Blackboard feature is also present in Shader Graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can experiment by adding and removing Blocks from the Contexts
    as you wish, and again, I recommend you look for already-created Visual Effect
    Graphs to find ideas for other systems. Actually, you can get ideas for Visual
    Effect Graph by looking at effects made in Shuriken and using the analogous blocks.
    Also, I recommend you search for the Visual Effect Graph documentation online
    or at: [https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@13.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@13.1/manual/index.html)
    to learn more about this system. You can also access the documentation of any
    Unity Package by clicking the **View Documentation** button in the Package Manager
    while the package is selected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.60: Package Manager documentation link'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learnt how to create different visual effects, let’s see how
    to use them via scripting to achieve effects that react to what’s happening in
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting Visual Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual feedback is the concept of using different VFX, such as particles and
    a VFX graph, to reinforce what is happening. For example, say right now we are
    shooting our weapon, and we know that this is happening because we can see the
    bullets. However, it doesn’t feel like a real shooting effect, because a proper
    shooting effect should have a muzzle effect on the tip of our gun. Another example
    would be the enemy dying—it just disappears with no animation! That doesn’t feel
    as satisfying as it could be. We can instead add a little explosion (considering
    they are robots).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start making our enemies spawn an explosion when they die by doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an explosion effect or download one from the Asset Store. It shouldn’t
    loop and it needs to be destroyed automatically when the explosion is over (ensure
    **Looping** is unchecked and **Stop Action** is set to `Destroy` in the main module).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some explosions in the Asset Store might use non-URP-compatible shaders. You
    can fix them by using **Window | Rendering | Render Pipeline Converter**, as we
    saw in *Chapter 4*, *Importing and Integrating Assets*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manually upgrade the materials that didn’t upgrade automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a script to the `Enemy` prefab called `ExplosionOnDeath`. This will be responsible
    for spawning the particles Prefab when the enemy dies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a field of the `GameObject` type called `particlePrefab` and drag the explosion
    Prefab to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be expecting to add the explosion spawning to the `Life` component.
    In that case, you are assuming that anything to do with life will spawn a particle
    when dying, but consider scenarios where characters die with a falling animation
    instead, or maybe an object that just despawns with no effect whatsoever. If a
    certain behavior is not used in most scenarios, it is better to code it in a separate
    optional script to allow us to mix and match different components and get the
    exact behavior we want.
  prefs: []
  type: TYPE_NORMAL
- en: Make the script access the `Life` component and subscribe to its `onDeath` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `listener` function, spawn the particle system in the same location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_11_61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.61: The explosion spawner script'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visual Scripting version would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_11_62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.62: The explosion spawner visual script'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are just using the same concepts we learned about in previous
    chapters but combining them in new ways. This is what programming is all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the muzzle effect, which will also be a particle system,
    but we will take another approach this time:'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have one already, download a weapon model from the Asset Store.
    The character in the package we used in the book already comes with one, so we
    will use that one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it’s not already in your character, instantiate the weapon so that it is
    the parent of the hand of the player. Remember that our character is rigged and
    has a hand bone, so you should put the weapon there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The weapon that comes with the character we downloaded in this book is a special
    scenario where the weapon has a **SkinnedMeshRenderer**. This component uses the
    *Skinning Animation* system that we will learn to use in *Chapter 17*, *Create
    Animations with Animator, Cinemachine, and Timeline*. In this case, the movement
    of the weapon will be affected by the animations we will use in that chapter,
    so for now let’s keep the weapon where it is located now, even if it looks odd.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or get a muzzle particle system. In this case, my muzzle particle system
    was created as a short particle system that has a burst of particles and then
    automatically stops. Try to get one with that behavior because there are others
    out there that will loop instead, and the script to handle that scenario would
    be different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an instance of the particle system prefab in the editor and parent it
    inside the weapon, locating it in front of the weapon, aligned with the cannon
    of the gun. Make sure the **Play On Awake** property of the main module of the
    particle system is unchecked; we don’t want the muzzle to fire until we press
    the fire key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.63: The muzzle parented to the weapon'
  prefs: []
  type: TYPE_NORMAL
- en: Create a field of the `ParticleSystem` type called `muzzleEffect` in `PlayerShooting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the muzzle effect GameObject that is parented in the gun to it in the Inspector.
    Now, we have a reference to the `ParticleSystem` component of the muzzle to manage
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `if` statement that checks whether we are shooting, execute `muzzleEffect.Play();`
    to play the particle system. It will automatically stop and is short enough to
    finish between key presses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_11_64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.64: The muzzle parented to the weapon'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visual Scripting version’s additional nodes and variables would be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_11_65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.65: The muzzle playing visual script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to play the muzzle effect also on the AI while shooting by
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: As we did with `PlayerShooting`, create a field of the `ParticleSystem` type
    called `muzzleEffect` in `EnemyFSM`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Shoot` method, add the line `muzzleEffect.Play();` at the end of
    the method to play the particle system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_11_66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.66: The muzzle playing C# script'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visual Scripting version’s additional nodes for the `Attack State` and
    `Attack Base` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_11_67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.67: The muzzle playing script for the Attack State'
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add those nodes to both attack states and to add the `muzzleEffect`
    variable to the AI Variables component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed two different ways to create particle systems:
    using Shuriken and VFX Graph. We used them to simulate different fluid phenomena,
    such as fire, a waterfall, smoke, and rain. The idea is to combine particle systems
    with meshes to generate all the possible props needed for your scene. Also, as
    you can imagine, creating these kinds of effects professionally requires you to
    go deeper. If you want to dedicate yourself to this (another part of the job of
    a technical artist), you will need to learn how to create your own particle textures
    to get the exact look and feel you want, code scripts that control certain aspects
    of the systems, and several other aspects of particle creation. However, that
    is outside the scope of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some rain in our scene, we can see that the sky and the lighting
    in the scene don’t really reflect a rainy day, so let’s fix that in the next chapter!
  prefs: []
  type: TYPE_NORMAL
