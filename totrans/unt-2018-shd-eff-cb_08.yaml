- en: Mobile Shader Adjustment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动设备着色器调整
- en: 'In the next two chapters, we are going to take a look at making the shaders
    that we write in a performance-friendly manner for different platforms. We won''t
    be talking about any one platform specifically, but we are going to break down
    the elements of shaders we can adjust in order to make them more optimized for
    mobiles and efficient on any platform in general. These techniques range from
    understanding what Unity offers in terms of built-in variables that reduce the
    overhead of the shaders memory to learning about ways in which we can make our
    own shader code more efficient. This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个章节中，我们将探讨如何使我们在不同平台上编写的着色器以性能友好的方式运行。我们不会具体讨论任何单一平台，但我们将分解我们可以调整的着色器元素，以便使它们更适合移动设备，并在任何平台上更高效。这些技术包括了解Unity提供的内置变量，这些变量可以减少着色器内存的负担，以及了解我们可以如何使自己的着色器代码更高效。本章将涵盖以下配方：
- en: Techniques to make shaders more efficient
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高着色器效率的技术
- en: Profiling your shaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析你的着色器
- en: Modifying our shaders for mobile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们的着色器以适应移动设备
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Learning the art of optimizing your shaders will come up in just about any game
    project that you work on. There will always come a point in any production where
    a shader needs to be optimized, or maybe it needs to use fewer textures but produces
    the same effect. As a technical artist or shader programmer, you have to understand
    these core fundamentals to optimize your shaders so that you can increase the
    performance of your game while still achieving the same visual fidelity. Having
    this knowledge can also help in setting the way in which you write your shader
    from the start. For instance, by knowing that the game built using your shader
    will be played on a mobile device, we can automatically set all our `Lighting`
    functions to use a half-vector as the view direction or set all of our float variable
    types to fixed or half so as to reduce the amountof memory used. These, and many
    other techniques, all contribute to your shaders running efficiently on your target
    hardware. Let's begin our journey and start learning how to optimize our shaders.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 学习优化你的着色器的艺术几乎会在你参与的任何游戏项目中出现。在任何制作过程中，总会有一个时刻需要优化着色器，或者可能需要使用更少的纹理但产生相同的效果。作为一个技术艺术家或着色器程序员，你必须理解这些核心基础，以便优化你的着色器，从而在保持相同视觉保真度的同时提高你游戏的表现。拥有这些知识还可以帮助你从开始就设定你编写着色器的方式。例如，通过知道使用你的着色器构建的游戏将在移动设备上运行，我们可以自动将所有的`Lighting`函数设置为使用半向量作为视图方向，或者将所有浮点变量类型设置为固定或半型，以减少使用的内存量。这些以及其他许多技术，都对你的着色器在目标硬件上高效运行做出了贡献。让我们开始我们的旅程，开始学习如何优化我们的着色器。
- en: Techniques to make shaders more efficient
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高着色器效率的技术
- en: What is a cheap shader? When first asked the question, it might be a little
    tough to answer, as there are many elements that go into making a more efficient
    shader. It could be the amount of memory used up by your variables. It could be
    the amount of textures the shader is using. It could also be that our shader is
    working fine, but we can actually produce the same visual effect with half the
    amount of data by reducing the amount of code we are using or data we are creating.
    We are going to explore a few of these techniques in this recipe and show how
    they can be combined to make your shader fast and efficient but still produce
    the high-quality visuals everyone expects from games today, whether on a mobile
    or PC.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是廉价的着色器？当第一次被问到这个问题时，可能有点难以回答，因为有很多元素会影响着色器的效率。这可能包括你的变量使用的内存量。这可能还包括着色器使用的纹理数量。也可能是因为我们的着色器运行良好，但实际上我们可以通过减少我们使用的代码量或创建的数据量，用一半的数据量产生相同的视觉效果。在这个配方中，我们将探索一些这些技术，并展示如何将它们结合起来，使你的着色器快速高效，同时仍然产生今天游戏玩家所期望的高质量视觉效果，无论是在移动设备还是PC上。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to get this recipe started, we need to gather a few resources together.
    So, let''s perform the following tasks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动这个配方，我们需要收集一些资源。所以，让我们执行以下任务：
- en: Create a new scene and fill it with a simple sphere object and single directional
    light.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并在其中添加一个简单的球体对象和单一方向性光源。
- en: Create a new shader (`OptimizedShader01`) and material (`OptimizedShader01Mat`) and
    assign the shader to the material.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器（`OptimizedShader01`）和材质（`OptimizedShader01Mat`），并将着色器分配给材质。
- en: We then need to assign the material we just created to our sphere object in
    our
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要将我们刚刚创建的材质分配到我们的球体对象中
- en: 'new scene:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新场景：
- en: '![](img/00167.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00167.jpeg)'
- en: Finally, modify the shader so that it uses a diffuse texture and normal map
    and includes your own custom `Lighting` function.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改着色器，使其使用漫反射纹理和法线贴图，并包含您自己的自定义`Lighting`函数。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lastly, assign a base and normal map to your material (I used the `MudRockey`
    texture included in the assets for [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08),
    *Post Processing Stack*). You should now have a setup similar to the following
    screenshot.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将基础和法线贴图分配给您的材质（我在[第1章](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08)，*后处理堆栈*）中包含的`MudRockey`纹理）。现在您应该有一个类似于以下截图的设置。
- en: 'This setup will allow us to take a look at some of the basic concepts that
    go into optimizing shaders using Surface Shaders in Unity:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种设置将使我们能够查看一些基本概念，这些概念在Unity中使用表面着色器优化着色器时是必不可少的：
- en: '![](img/00168.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00168.jpeg)'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are going to build a simple `DiffuseShader` to take a look at a few ways
    in which you can optimize your shaders in general.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个简单的`DiffuseShader`，以便查看您在一般情况下可以优化着色器的几种方法。
- en: First, we'll optimize our variable types so that they use less memory when they
    are
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将优化我们的变量类型，以便它们在占用更少内存的情况下工作。
- en: 'processing data:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据：
- en: Let's begin with the `struct Input` in our shader. Currently, our UVs are being
    stored in a variable of the `float2` type.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从着色器中的`struct Input`开始。目前，我们的UVs被存储在一个`float2`类型的变量中。
- en: 'Remember that floats provide the highest form of precision at a full 32 bits
    of memory. This is needed for complex trigonometry or exponents, but if you can
    handle less precision, it''s much better to use either a half or a fixed instead.
    The half type provides up to 3 digits of precision using half the size, or 16
    bits of memory. That means we can have a `half2` with the same amount of memory
    of a single float. We need to change this to use `half2` instead:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，浮点数提供了最高形式的精度，占用完整的32位内存。这对于复杂的三角函数或指数运算来说是必需的，但如果您能处理更低的精度，使用半精度或固定精度会更好。半精度类型使用一半的大小，即16位内存，提供高达3位的精度。这意味着我们可以有一个`half2`，其内存量与单个浮点数相同。我们需要将其更改为使用`half2`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then move to our `Lighting` function and reduce the variables'' memory
    footprint by changing their types to the following:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以转到我们的`Lighting`函数，通过将变量的类型更改为以下内容来减少它们的内存占用：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we are using the lowest precision type of `fixed`, which is only
    11  bits as compared to the `float` type's 32\. This is useful for simple calculations
    such as color or texture data, which is perfect for this particular case.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用的是`fixed`类型的最低精度，它只有11位，而`float`类型有32位。这对于简单的计算，如颜色或纹理数据，非常适用，这正是这个特定案例的情况。
- en: In case you'd like a refresher on the fixed type as well as all of the other
    types we are using, please check out [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader*, or look at [https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html](https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想复习固定类型以及我们正在使用的所有其他类型，请查看[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)，*创建您的第一个着色器*，或者查看[https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html](https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html)。
- en: 'Finally, we can complete this optimization pass by updating the variables in
    our `surf()` function. Since we''re using texture data, it''s fine for us to use
    a `fixed4` here instead:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过更新我们的`surf()`函数中的变量来完成这次优化过程。由于我们正在使用纹理数据，因此在这里使用`fixed4`是完全可以的：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have our variables optimized, we are going to take advantage of
    a built-in `Lighting` function variable so that we can control how lights are
    processed by this shader. By doing this, we can greatly reduce the number of lights
    the shader processes. Modify the `#pragma` statement in your shader with the following
    code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经优化了变量，我们将利用内置的`Lighting`函数变量，以便我们可以控制这个着色器如何处理光线。通过这样做，我们可以大大减少着色器处理的灯光数量。使用以下代码修改您的着色器中的`#pragma`语句：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can optimize this further by sharing UVs between the normal map and diffuse
    texture. To do this, we simply change the UV lookup in our `UnpackNormal()` function
    to use `_MainTex` UVs instead of the UVs of `_NormalMap`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在法线贴图和漫反射纹理之间共享UV来进一步优化。为此，我们只需将我们的`UnpackNormal()`函数中的UV查找更改为使用`_MainTex`
    UVs而不是`_NormalMap`的UVs：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we have removed the need for the normal map UVs, we need to make sure that
    we remove the normal map UV code from the `Input` `struct`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经消除了对法线图UV的需求，我们需要确保从`Input` `struct`中删除法线图UV代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we can further optimize this shader by telling the shader that it
    only works with certain renderers:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过告诉着色器它只与某些渲染器一起工作来进一步优化这个着色器：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result of our optimization passes show us that we really don''t notice
    a difference in the visual quality, but we have reduced the amount of time it
    takes for this shader to be drawn to the screen. You will learn about finding
    out how much time it takes for a shader to render in the next recipe, but the
    idea to focus on here is that we achieve the same result with fewer data. So keep
    this in mind when creating your shaders. The following screenshot shows us the
    final result of our shader:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们优化过程的结果显示，我们在视觉质量上并没有真正注意到差异，但我们已经减少了这个着色器绘制到屏幕上所需的时间。你将在下一道菜谱中了解到如何找出着色器渲染所需的时间，但这里要关注的思想是，我们用更少的数据实现了相同的结果。所以当你创建着色器时要记住这一点。以下截图显示了我们的着色器的最终结果：
- en: '![](img/00169.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00169.jpeg)'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now that we have seen the ways in which we can optimize our shaders, let's dive
    in a bit deeper and really understand how all of these techniques work, why we
    should use them, and look at a couple of other techniques that you can try for
    yourself in your own shaders.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们可以如何优化我们的着色器，让我们更深入地研究一下，真正理解所有这些技术是如何工作的，为什么我们应该使用它们，并看看一些你可以在自己的着色器中尝试的其他技术。
- en: 'Let''s first focus our attention on the size of the data each of our variables
    is storing when we declare them. If you are familiar with programming, then you
    will understand that you can declare values or variables with different sizes
    of types. This means that a float actually has a maximum size in memory. The following
    description will describe these variable types in much more detail:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们关注一下当我们声明变量时，每个变量所存储的数据大小。如果你熟悉编程，那么你会明白你可以用不同大小的类型来声明值或变量。这意味着浮点数实际上在内存中有一个最大大小。以下描述将更详细地描述这些变量类型：
- en: '**Float**: A float is a full 32-bit precision value and is the slowest of the
    three'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float**：float是一个完整的32位精度值，是三种类型中最慢的。'
- en: different types we see here. It also has its corresponding values of `float2`,
    `float3`, and `float4`, which allow us to store multiple floats in one variable.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里看到的不同类型。它也有其对应的`float2`、`float3`和`float4`的值，这些值允许我们在一个变量中存储多个浮点数。
- en: '**Half**: The half variable type is a reduced 16-bit floating point value and
    is suitable for store UV values and color values and much faster than using a
    float value. As with the float type, it has its corresponding values, which are
    `half2`, `half3`, and `half4`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Half**：half变量类型是一个减少的16位浮点值，适合存储UV值和颜色值，比使用float值快得多。与float类型一样，它也有其对应的值，即`half2`、`half3`和`half4`。'
- en: '**Fixed**: A fixed value is the smallest in size of the three types, but can
    be used for lighting calculations and colors and has the corresponding values
    of `fixed2`, `fixed3`, and `fixed4`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fixed**：fixed值是三种类型中最小的，但可以用于光照计算和颜色，并且有对应的`fixed2`、`fixed3`和`fixed4`值。'
- en: For more information on working with array types for shaders, check out the
    *Using packed arrays* recipe from [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08),
    *Surface Shaders and Texture Mapping*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在着色器中使用数组类型的更多信息，请参阅第3章的*使用打包数组*菜谱，*表面着色器和纹理映射*。
- en: Our second phase of optimizing our simple shader was to declare the `noforwardadd`
    value to our `#pragma` statement. This is basically a switch that automatically
    tells Unity that any object with this particular shader receives only per-pixel
    light from a single directional light. Any other lights that are calculated by
    this shader will be forced to be processed as per-vertex lights using *spherical
    harmonic* values produced internally by Unity. This is especially obvious when
    we place another light in the scene to light our sphere object because our shader
    is doing a per-pixel operation using the normal map.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们优化简单着色器的第二阶段是向我们的`#pragma`语句中声明`noforwardadd`值。这基本上是一个自动告诉Unity任何具有这种特定着色器的对象只从单个方向光接收每像素光的开关。任何其他由这个着色器计算的光都将被迫以Unity内部产生的球谐函数值作为每顶点光进行处理。当我们放置另一个灯光照亮场景中的球体对象时，这一点尤其明显，因为我们的着色器正在使用法线图进行每像素操作。
- en: 'This is great, but what if you wanted to have a bunch of directional lights
    in the scene and control over which of these lights is used for the main per-pixel
    light? Well, if you notice, each light has a Render Mode drop-down. If you click
    on this drop-down, you will see a couple of flags that can be set. These are Auto,
    Important, and Not Important. By selecting a light, you can tell Unity that a
    light should be considered more as a per-pixel light than a per-vertex light,
    by setting its render mode to Important and vice versa. If you leave a light set
    to Auto, then you will let Unity decide the best course of action:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但如果你想在场景中有一堆方向光，并控制这些光中哪一盏用作主每像素光呢？注意，每个灯光都有一个渲染模式下拉菜单。如果你点击这个下拉菜单，你会看到可以设置的一些标志。这些是自动、重要和不重要。通过选择一个灯光，你可以告诉Unity，通过将其渲染模式设置为重要，一个灯光应该被视为比顶点光更接近每像素光，反之亦然。如果你将灯光设置为自动，那么你将让Unity决定最佳行动方案：
- en: '![](img/00170.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00170.jpeg)'
- en: 'Place another light in your scene and remove the texture that is currently
    in the main texture for our shader. You will notice that the second point light
    does not react with the normal map, only the directional light that we created
    first. The concept here is that you save on per-pixel operations by just calculating
    all extra lights as vertex lights, and save performance by just calculating the
    main directional light as a per-pixel light. The following diagram visually demonstrates
    this concept as the point light is not reacting with the normal map:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中放置另一盏灯，并移除当前用于我们着色器的主纹理中的纹理。你会注意到第二个点光源不会与法线图反应，只有我们最初创建的方向光会反应。这里的理念是通过仅计算所有额外的灯光作为顶点灯光来节省每像素操作，并通过仅计算主方向光作为每像素光来节省性能。以下图表直观地展示了这一概念，因为点光源不会与法线图反应：
- en: '![](img/00171.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00171.jpeg)'
- en: Finally, we did a bit of cleaning up and simply told the normal map texture
    to use the main texture's UV values, and we got rid of the line of code that pulled
    in a separate set of UV values specifically for the normal map. This is always
    a nice way to simplify your code and clean up any unwanted data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行了一些清理工作，简单地将法线贴图纹理的UV值设置为使用主纹理的UV值，并去掉了专门为法线图提取一组UV值的代码行。这是一种简化代码和清理任何不需要数据的不错方法。
- en: 'We also declared `exclude_pass: prepass` in our `#pragma` statement so that
    this'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还在`#pragma`语句中声明了`exclude_pass: prepass`，这样'
- en: shader wouldn't accept any custom lighting from the deferred renderer. This
    means that we can really use this shader effectively in the forward renderer only,
    which is set in the main camera's settings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器不接受来自延迟渲染器的任何自定义光照。这意味着我们只能在正向渲染器中有效地使用这个着色器，这是在主相机的设置中设置的。
- en: By taking a bit of time, you will be amazed at how much a shader can be optimized.
    You have seen how we can pack grayscale textures into a single RGBA texture as
    well as use lookup textures to fake lighting. There are many ways in which a shader
    can be optimized, which is why it is always an ambiguous question to ask in the
    first place, but knowing these different optimization techniques, you can cater
    your shaders to your game and target platform, ultimately resulting in very streamlined
    shaders and a nice steady frame rate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过花点时间，你会对着色器可以优化到什么程度感到惊讶。你已经看到了我们如何将灰度纹理打包到单个RGBA纹理中，以及如何使用查找纹理来模拟光照。着色器可以通过多种方式优化，这也是为什么一开始就问这个问题总是模糊不清的原因，但了解这些不同的优化技术，你可以根据你的游戏和目标平台定制着色器，最终得到非常流畅的着色器和稳定的帧率。
- en: Profiling your shaders
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器性能分析
- en: Now that we know how we can reduce the overhead that our shaders might take,
    let's take a look at how to find problematic shaders in a scene where you might
    have a lot of shaders or a ton of objects, shaders, and scripts, all running at
    the same time. To find a single object or shader among a whole game can be quite
    daunting, but Unity provides us with its built-in Profiler. This allows us to
    actually see, on a frame-by-frame basis, what is happening in the game, and each
    item that is being used by the GPU and CPU.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何减少我们的着色器可能带来的开销，让我们看看如何在有大量着色器或大量对象、着色器和脚本同时运行的场景中找到有问题的着色器。在整款游戏中找到一个单独的对象或着色器可能相当困难，但Unity为我们提供了其内置的Profiler。这允许我们实际上在每一帧的基础上看到游戏中发生了什么，以及GPU和CPU正在使用的每个项目。
- en: Using the Profiler, we can isolate items such as shaders, geometry, and general
    rendering items using its interface to create blocks of profiling jobs. We can
    filter out items until we are looking at the performance of just a single object.
    This then lets us see the effects on the CPU and GPU that the object has while
    it is performing its functions at runtime.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Profiler，我们可以通过其界面创建分析作业的块来隔离如着色器、几何体和一般渲染项。我们可以过滤出项目，直到我们只看到单个对象的表现。这样，我们就可以看到对象在运行时执行其功能时对CPU和GPU产生的影响。
- en: Let's take a look through the different sections of the Profiler and learn how
    to debug our scenes and, most importantly, our shaders.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览Profiler的不同部分，并学习如何调试我们的场景，最重要的是，我们的着色器。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s use our Profiler by getting a few assets ready and launching the Profiler
    window:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过准备一些资产并启动Profiler窗口来使用我们的Profiler：
- en: Let's use the scene from the last recipe and launch the Unity Profiler from
    Window | Profiler or *Ctrl* + *7*. Feel free to drag and drop or move it so you
    can see it well. I personally put it at the same spot as the Inspector tab.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用上一道菜中的场景，并从窗口 | Profiler或*Ctrl* + *7*启动Unity Profiler。请随意拖放或移动它，以便您可以清楚地看到。我个人把它放在Inspector标签页的同一位置。
- en: Let's also duplicate our sphere a couple more times to see how that affects
    our rendering.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再复制我们的球体几次，看看这对我们的渲染有什么影响。
- en: From the Profiler tab, click on the Deep Profile option to get additional information
    about the project and then play your game!
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Profiler标签页，点击Deep Profile选项以获取有关项目的更多信息，然后玩游戏！
- en: 'You should see something similar to the following image:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下类似图像：
- en: '![](img/00172.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00172.jpeg)'
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To use the Profiler, we will take a look at some of the UI elements of this
    window. Before we hit Play, let''s take a look at how to get the information we
    need from the Profiler:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Profiler，我们将查看这个窗口的一些UI元素。在我们按Play之前，让我们看看如何从Profiler中获取所需的信息：
- en: 'First, click on the larger blocks in the Profiler window called GPU Usage,
    CPU Usage, and Rendering. You will find these blocks on the left-hand side of
    the upper window:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击Profiler窗口中称为GPU Usage、CPU Usage和Rendering的较大块。您可以在窗口的左侧找到这些块：
- en: '![](img/00173.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: Using these blocks, we can see different data specific to those major functions
    of our game. The CPU Usage is showing us what most of our scripts are doing, as
    well as physics and overall rendering. The GPU Usage block is giving us detailed
    information about the elements that are specific to our lighting, shadows, and
    render queues. Finally, the Rendering block is giving us information about the
    drawcalls and amount of geometry we have in our scene at any one frame.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些块，我们可以看到针对我们游戏的主要功能的不同数据。CPU Usage显示了我们大多数脚本正在做什么，以及物理和整体渲染。GPU Usage块提供了关于我们照明、阴影和渲染队列的特定元素的确切信息。最后，Rendering块提供了关于drawcalls和在任何一帧中我们场景中的几何体数量的信息。
- en: If you do not see the GPU Usage option, click on Add Profiler | GPU. It is possible
    that it may not show up if your graphics card drivers are not up to date.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到GPU Usage选项，请点击Add Profiler | GPU。如果您的显卡驱动程序未更新，它可能不会显示。
- en: By clicking on each of these blocks, we can isolate the type of data we see
    during our profiling session.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击这些块中的每一个，我们可以在分析会话期间隔离我们看到的数据类型。
- en: Now, click on the tiny colored blocks in one of these Profile blocks and hit
    Play, or *Ctrl* + *P*, to run the scene.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击这些Profile块中的一个彩色小方块，然后按Play键，或*Ctrl* + *P*，以运行场景。
- en: 'This lets us dive down even deeper into our profiling session so that we can
    filter out what is being reported back to us. While the scene is running, uncheck
    all of the boxes, except for Opaque in the GPU Usage block. Notice that we can
    now see just how much time is being used to render the objects that are set to
    the Render Queue of Opaque:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使我们能够进一步深入我们的分析会话，以便我们可以过滤出返回给我们的信息。当场景运行时，除了GPU Usage块中的Opaque之外，取消选中所有复选框。注意，我们现在可以看到渲染到不透明渲染队列的对象所花费的时间：
- en: '![](img/00174.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00174.jpeg)'
- en: Another great function of the Profiler window is the action of clicking and
    dragging in the graph view.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Profiler窗口的另一个出色功能是在图表视图中点击和拖动。
- en: 'This will automatically pause your game so that you can further analyze a certain
    spike in the graph to find out exactly which item is causing the performance problem.
    Click and drag around in the graph view to pause the game and see the effect of
    using this functionality:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将自动暂停你的游戏，以便你可以进一步分析图表中的某个峰值，以找出确切是哪个项目导致了性能问题。在图表视图中点击并拖动以暂停游戏并查看使用此功能的效果：
- en: '![](img/00175.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00175.jpeg)'
- en: 'Turning our attention now towards the lower half of the Profiler window, you
    will notice that there is a dropdown item available when we have the GPU Block
    selected. We can expand this to get even more detailed information about the current
    active profiling session and, in this case, more information about what the camera
    is currently rendering and how much time it is taking up:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的注意力转向Profiler窗口的下半部分，你会注意到当我们选择了GPU Block时，会出现一个下拉菜单项。我们可以展开这个菜单以获取关于当前活动分析会话的更详细信息，在这个例子中，是关于相机当前渲染的内容及其占用时间的更多信息：
- en: '![](img/00176.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00176.jpeg)'
- en: If you click on the button that says No Details and changes the option to Show
    Related Objects, you can see what objects are being used in the functions being
    called.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击显示为“无详细信息”的按钮，并将选项更改为“显示相关对象”，你可以看到在调用的函数中使用哪些对象。
- en: This gives us a complete look at the inner workings of what Unity is processing
    in this particular frame. In this case, we can see that our three spheres with
    our optimized shader are taking roughly 0.066 milliseconds to draw to the screen,
    they are taking up fifteen drawcalls, and this process is taking 8.4% of the GPU's
    time in every frame (the numbers will likely be different depending on what hardware
    you have for your computer). It's this type of information we can use to diagnose
    and solve performance issues with regard to shaders. Let's conduct a test to see
    the effects of adding one more texture to our shader and blending two diffuse
    textures together using a `lerp` function. You will see the effects in the Profiler
    pretty clearly.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这为我们提供了Unity在此特定帧中处理内部工作的完整视图。在这种情况下，我们可以看到我们的三个带有优化着色器的球体绘制到屏幕上大约需要0.066毫秒，它们占用了十五次绘制调用，并且这个过程在每个帧中占用了GPU的8.4%时间（这些数字可能因你的电脑硬件而异）。我们可以使用这类信息来诊断和解决与着色器相关的性能问题。让我们进行一个测试，看看向我们的着色器添加一个纹理并使用`lerp`函数混合两个漫反射纹理的效果。你将在Profiler中清楚地看到这些效果。
- en: 'Modify the `Properties` block of your shader with the following code to give
    us another texture to use:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码修改你的着色器的`Properties`块，以给我们另一个纹理使用：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then let''s feed our texture to `CGPROGRAM`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们将我们的纹理传递给`CGPROGRAM`：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it''s time to update our `surf()` function accordingly so that we blend
    our diffuse textures together:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候更新我们的`surf()`函数，以便我们将漫反射纹理混合在一起：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once you save your modifications in your shader and return to Unity's editor,
    we can run our game and see the increase in milliseconds of our new shader.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的着色器修改并返回Unity编辑器后，我们可以运行我们的游戏并查看新着色器带来的毫秒级增加。
- en: 'Attach a new texture inside of your `Blend Texture`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Blend Texture`中附加一个新的纹理：
- en: '![](img/00177.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00177.jpeg)'
- en: 'Press Play to start the game again with the Profiler turned on. Press Play
    once you have returned to Unity and let''s take a look at the results in our Profiler:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放按钮以再次启动游戏并开启Profiler。返回Unity后按下播放按钮，让我们看看Profiler中的结果：
- en: '![](img/00178.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00178.jpeg)'
- en: You can see now that the amount of time to render our Opaque Shaders in this
    scene is taking 0.069 milliseconds, up from 0.066 milliseconds. By adding another
    texture and using the `lerp()` function, we increased the render time for our
    spheres. While it's a small change, imagine having 20 shaders all working in different
    ways on different objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到在这个场景中渲染我们的不透明着色器所需的时间为0.069毫秒，比0.066毫秒有所增加。通过添加另一个纹理并使用`lerp()`函数，我们增加了我们的球体的渲染时间。虽然这是一个小的变化，但想象一下有20个着色器以不同的方式在不同的对象上工作。
- en: Using the information given here, you can pinpoint areas that are causing performance
    decreases more quickly and solve these issues using the techniques from the previous
    recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这里提供的信息，你可以更快地定位导致性能下降的区域，并使用前一个菜谱中的技术来解决这些问题。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While it's completely out of the scope of this book to describe how this tool
    actually works internally, we can surmise that Unity has given us a way to view
    the computer's performance while our game is running. Basically, this window is
    tied very tightly to the CPU and GPU to give us real-time feedback of how much
    time is being taken for each of our scripts, objects, and render queues. Using
    this information, we have seen that we can track the efficiency of our shader
    writing to eliminate problem areas and code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书完全不涉及描述这个工具内部如何工作的细节，但我们可以推测Unity为我们提供了一种在游戏运行时查看计算机性能的方法。基本上，这个窗口与CPU和GPU紧密相连，以便为我们提供每个脚本、对象和渲染队列所花费时间的实时反馈。利用这些信息，我们发现我们可以追踪我们的着色器编写的效率，以消除问题区域和代码。
- en: It's important to note that games running with the Profiler open, as well as
    from within the editor in general, will make the game slightly slower than it
    would be when compiled and running in a normal situation. You might even see the
    Editor in the Profilers list of CPU expenses.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用Profiler打开的游戏，以及通常在编辑器中运行的游戏，会比在正常情况下编译和运行时慢一些。你甚至可能会在CPU开销列表中看到Editor。
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is also possible to profile specifically for mobile platforms. Unity provides
    us with a couple of extra features when the Android or iOS build target is set
    in the Build Settings. We can actually get real-time information from our mobile
    devices while the game is running. This becomes very useful because you are able
    to profile directly on the device itself instead of profiling directly in your
    editor. To find out more about this process, refer to Unity''s documentation at
    the following link:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以专门针对移动平台进行性能分析。当在构建设置中将Android或iOS设置为构建目标时，Unity为我们提供了一些额外的功能。我们实际上可以在游戏运行时从我们的移动设备获取实时信息。这非常有用，因为你可以直接在设备上而不是在编辑器中直接进行性能分析。要了解更多关于这个过程的详细信息，请参考以下链接的Unity文档：
- en: '[http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html](http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html).
    [](http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html](http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html)'
- en: Modifying our shaders for mobile
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动设备修改我们的着色器
- en: Now that we have seen quite a broad set of techniques for making really optimized
    shaders, let's take a look at writing a nice, high-quality shader targeted for
    a mobile device. It is actually quite easy to make a few adjustments to the shaders
    we have written so that they run faster on a mobile device. This includes elements
    such as using the `approxview` or `halfasview Lighting` function variables. We
    can also reduce the amount of textures we need and even apply better compression
    for the textures we are using. By the end of this recipe, we will have a nicely
    optimized normal-mapped, Specular Shader for use in our mobile games.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一系列针对真正优化着色器的技术，让我们来看看如何编写一个针对移动设备的优质、高质量着色器。实际上，对已编写的着色器进行一些调整以使其在移动设备上运行得更快是非常容易的。这包括使用`approxview`或`halfasview
    Lighting`函数变量等元素。我们还可以减少所需的纹理数量，甚至为使用的纹理应用更好的压缩。到这个配方结束时，我们将有一个优化良好的正常贴图、高光着色器，适用于我们的移动游戏。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, let''s get a fresh new scene and fill it with some objects
    to apply our `MobileShader`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们创建一个全新的场景，并填充一些对象以应用我们的`MobileShader`：
- en: Create a new scene and fill it with a default sphere and single directional
    light.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并填充一个默认的球体和一个单方向光源。
- en: Create a new material (`MobileMat`) and shader (`MobileShader`), and assign
    the shader to the material.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质（`MobileMat`）和一个着色器（`MobileShader`），并将着色器分配给材质。
- en: Finally, assign the material to our sphere object in our scene.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将材质分配到场景中的球体对象上。
- en: 'When completed, you should have a scene similar to the one in the following
    screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该有一个类似于以下截图的场景：
- en: '![](img/00179.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00179.jpeg)'
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this recipe, we will write a mobile-friendly shader from scratch and discuss
    the elements that make it more mobile friendly:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将从头开始编写一个适合移动设备的着色器，并讨论使其更适合移动设备的元素：
- en: 'Let''s first populate our `Properties` block with the textures required. In
    this case, we are going to use a single `_Diffuse` texture with the gloss map
    in its alpha channel, `Normal map`, and a slider for specular intensity:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在我们的`Properties`块中填充所需的纹理。在这种情况下，我们将使用一个带有光泽图在其alpha通道中的单个`_Diffuse`纹理，`Normal
    map`和一个用于光泽强度滑块的滑块：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our next task is to set up our `#pragma` declarations. This will simply turn
    certain features of the Surface Shader on and off, ultimately making the shader
    cheaper or more expensive:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一个任务是设置我们的`#pragma`声明。这将简单地打开或关闭表面着色器的某些功能，最终使着色器更便宜或更昂贵：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The highlighted line should be on one line.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行应该放在一行上。
- en: Next, remove the `#pragma target 3.0` line, as we are not using any of the features
    of it.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除`#pragma target 3.0`行，因为我们没有使用它的任何特性。
- en: 'We then need to make the connection between our `Properties` block and `CGPROGRAM`.
    This time, we are going to use the fixed variable type for our specular intensity
    slider in order to reduce its memory usage:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在我们的`Properties`块和`CGPROGRAM`之间建立连接。这次，我们将使用固定变量类型来减少光泽强度滑块的内存使用：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order for us to map our textures to the surface of our object, we need to
    get some UVs. In this case, we are going to get only one set of UVs to keep the
    amount of data in our shader down to a minimum:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将我们的纹理映射到我们对象的表面，我们需要获取一些UV坐标。在这种情况下，我们将只获取一组UV坐标，以将我们的着色器中的数据量降到最低：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to fill in our `Lighting` function using a few of the new
    input variables that are available to us when using the new `#pragma` declarations:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用新`#pragma`声明中可用的几个新输入变量来填写我们的`Lighting`函数：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we complete the shader by creating the `surf()` function and processing
    the final color of our surface:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过创建`surf()`函数并处理我们表面的最终颜色来完成着色器：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When finished with the code portion of this recipe, save your shader and return
    to the Unity editor to let the shader compile. If no errors occurred, assign some
    properties for the Base and Normal Map properties:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当完成这个菜谱的代码部分后，保存你的着色器并返回Unity编辑器，让着色器进行编译。如果没有发生错误，为基色和法线贴图属性分配一些属性：
- en: '![](img/00180.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00180.jpeg)'
- en: 'Add a few point lights and some copies of the new object and you should see
    a result similar to the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加几个点光源和一些新对象的副本，你应该会看到以下截图类似的结果：
- en: '![](img/00181.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00181.jpeg)'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So, let's begin the description of this shader by explaining what it does and
    doesn't do. First, it excludes the deferred lighting pass. This means that if
    you created a `Lighting` function that was connected to the deferred renderer's
    `prepass`, it wouldn't use that particular `Lighting` function and would look
    for the default `Lighting` function like the ones that we have been creating thus
    far in this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过解释这个着色器做什么和不做什么来开始对这个着色器的描述。首先，它排除了延迟光照通道。这意味着如果你创建了一个连接到延迟渲染器的`prepass`的`Lighting`函数，它将不会使用那个特定的`Lighting`函数，而是会寻找默认的`Lighting`函数，就像我们在本书中迄今为止创建的那样。
- en: This particular shader does not support *lightmapping* by Unity's internal light-mapping
    system. This just keeps the shader from trying to find light maps for the object
    that the shader is attached to, making the shader more performance-friendly because
    it is not having to perform the lightmapping check.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的着色器不支持Unity内部的光照贴图系统。这仅仅阻止着色器尝试为着色器附加的对象查找光照贴图，这使得着色器更易于性能优化，因为它不需要执行光照贴图检查。
- en: We included the `noforwardadd` declaration so that we process only per-pixel
    textures with a single directional light. All other lights are forced to become
    per-vertex lights and will not be included in any per-pixel operations you might
    do in the `surf()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了`noforwardadd`声明，这样我们只处理具有单一方向光的单像素纹理。所有其他灯光都将被强制转换为顶点灯光，并且不会包含在`surf()`函数中你可能进行的任何单像素操作中。
- en: Finally, we are using the `halfasview` declaration to tell Unity that we aren't
    going to use the main `viewDir` parameter found in a normal `Lighting` function.
    Instead, we are going to use the half vector as the view direction and process
    our specular with this. This becomes much faster for the shader to process as
    it will be done on a per-vertex basis. It isn't completely accurate when it comes
    to simulating specular in the real world, but visually, on a mobile device, it
    looks just fine and the shader is more optimized.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`halfasview`声明来告诉Unity我们不会使用在常规`Lighting`函数中找到的`viewDir`主参数。相反，我们将使用半向量作为视图方向，并以此处理我们的镜面反射。这样做使得着色器处理速度更快，因为它将在每个顶点上完成。虽然在模拟现实世界中的镜面反射时并不完全准确，但在移动设备上视觉上看起来相当不错，且着色器更加优化。
- en: It's techniques like these that make a shader more efficient and cleaner, codewise.
    Always make sure that you are using only the data you need while weighing this
    against your target hardware and the visual quality that the game requires. In
    the end, a cocktail of these techniques is what ultimately makes up your shaders
    for your games.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这类技术使得着色器在代码上更加高效和简洁。始终确保你只使用所需的数据，同时权衡你的目标硬件和游戏所需的视觉质量。最终，这些技术的混合使用构成了你游戏中着色器的核心。
