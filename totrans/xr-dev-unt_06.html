<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor020"/>6</h1>
<h1 id="_idParaDest-115">Building Interactive AR Experiences</h1>
<p>Having mastered the basics of crafting and implementing an AR experience in Unity for Android and iOS platforms in <a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a>, we’ll now embark on the engaging journey of enhancing your AR scenes with intriguing interactions. This chapter will open a whole new world of user experiences for you as we strive to augment reality with utility-based overlays.</p>
<p>Harnessing the robust capabilities of C#, our adventure will take a turn toward creating an innovative AR application tailored to the food industry. This application will revolutionize the way customers make their selections, offering an unprecedented method for placing orders.</p>
<p>As we unravel the creation process of this AR app, you’ll discover how to anchor and scale 3D models in the real world, facilitate user interactions with the elements of your AR app, and comprehend the broad principles to contemplate when architecting your own AR application. This immersive journey will equip you with a rich set of skills, offering a deeper understanding of the boundless possibilities of AR.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Understanding the design patterns and core components of an interactive AR application</li>
<li>Building the foundation of our AR menu application</li>
<li>Adding interactivity to our AR menu application</li>
</ul>
<h1 id="_idParaDest-116">Technical requirements</h1>
<p>To fully participate in and benefit from the AR application development process detailed in this chapter, there are several technical requirements your hardware must meet. If you followed along with the project we built in <a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a>, you can skip these requirements, so long as your Unity setup hasn’t changed.</p>
<p>To ensure you can follow along with the content and examples in this book, confirm that your computer system can handle <em class="italic">Unity 2021.3</em> LTS or a more recent edition, including Android or iOS Build Support.</p>
<p>Additionally, as we delve into the fascinating world of AR, it is helpful to have either an Android or iOS device that can support <em class="italic">ARKit</em> or <em class="italic">ARCore</em>. You can check the compatibility of your device at <a href="https://developers.google.com/ar/devices">https://developers.google.com/ar/devices</a>.</p>
<p>However, if you don’t have a device that fits these requirements, you can still participate in these tutorials and test your application on your PC. The <em class="italic">Deploying AR experiences onto mobile devices</em> section of <a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a> detailed how to do this.</p>
<h1 id="_idParaDest-117">Understanding the design patterns and core components of an interactive AR application</h1>
<p>In this section, we <a id="_idIndexMarker468"/>will delve into the commonly used design patterns and applications of AR, equipping you with the knowledge to choose the appropriate use case for your AR application. This includes familiarizing yourself with the core concepts and integral components of the AR menu application that we will construct in this chapter.</p>
<p>Understanding the right <a id="_idIndexMarker469"/>applications for interactive AR apps is essential before embarking on your journey to develop your first full-fledged AR application. Let’s take a look at the various types of AR apps that currently exist, highlighting the different ways they enhance the user experience. Not only will this give you a clearer picture of the current state of AR applications, but it will also shed light on what types of AR experiences resonate most with users.</p>
<p>Let’s look at these different kinds of applications:</p>
<ul>
<li><strong class="bold">AR gaming apps</strong>: Games <a id="_idIndexMarker470"/>such as Pokémon Go and Minecraft Earth are popular examples of AR apps. They place virtual objects such as creatures or blocks into the user’s real-world surroundings. Interaction is usually done through touchscreen commands, with the game responding to physical location data from the device’s GPS.</li>
<li><strong class="bold">AR navigation apps</strong>: Apps<a id="_idIndexMarker471"/> such as Google Maps Live View and CityViewAR overlay directional cues and points of interest onto real-world images. These apps use GPS data and device orientation to decide which AR elements to show and where. These elements <a id="_idIndexMarker472"/>can include arrows, labels, and even 3D models of buildings. Users primarily interact by moving and looking around. Some apps also allow users to touch screen elements for more information.</li>
<li><strong class="bold">AR shopping apps</strong>: IKEA Place <a id="_idIndexMarker473"/>and Amazon AR View let users visualize products in their own homes before buying. These apps access the users’ camera feeds so that they can place 3D models of products in their rooms. Advanced apps use environmental understanding to place objects on surfaces and scale them correctly. Users move around to view the product from different angles and use touch commands to select different items, change colors or features, and make a purchase.</li>
<li><strong class="bold">AR education apps</strong>: Apps<a id="_idIndexMarker474"/> such as Star Walk 2 and AR Anatomy Learning are designed to provide immersive, interactive learning experiences. These apps often use image recognition to anchor 3D models such as a star system or a human organ to specific locations in the real world. Users can interact with the 3D models through touch commands, for example, to rotate the model or activate animations. Users may also move around to view the model from different angles.</li>
</ul>
<p>These different AR applications may cater to different user groups and industries, but they share a core pattern: projecting 3D models into real-world contexts using AR. These apps use the camera feed, device orientation, and GPS data to position and scale the 3D models. User interaction is achieved through touch commands or physical movement, with the interaction often centered on manipulating specific features of the 3D models. This pattern, which emphasizes simplicity and focus, is the current standard in AR app development and will serve as our blueprint for the interactive AR app we’ll discuss in this chapter. It’s also a pattern we recommend for our own AR projects.</p>
<p class="callout-heading">Note</p>
<p class="callout">Remember that the goal is not to force AR functionality into an app but to use it where it enhances user experience. For instance, using AR to display a restaurant menu on a table might seem novel, but it doesn’t necessarily add value for the user. A traditional 2D app or physical menu would serve the same purpose. However, if you create an AR experience where users can visualize each dish on the table, scaled to the actual serving size, the user gets a clear sense of what to expect. This enhances the dining experience and overall satisfaction, showing how AR can create meaningful and beneficial interactions when applied appropriately. And this is exactly what we are going to create in the subsequent sections.</p>
<p>With this understanding, let’s proceed and build the foundation of our AR menu application.</p>
<h1 id="_idParaDest-118">Building the foundation of our AR menu application</h1>
<p>As we<a id="_idIndexMarker475"/> start crafting this AR menu application, you’ll set the groundwork for your AR project by assembling the essential components. The following sections will guide you through the process of sourcing and importing a variety of dishes from the Unity Asset Store and adding UI buttons and text elements to your scene, providing the basis for your interactive AR menu application.</p>
<h2 id="_idParaDest-119">Defining the key components of our AR application</h2>
<p>Throughout this<a id="_idIndexMarker476"/> chapter, we will be building an AR application that allows users to place 3D models of food items that have been detected by their mobile device’s camera onto real-world surfaces. Before we get into the project, it is always good to visualize the functionality of the app we are going to create. Our AR application will consist of several key components:</p>
<ul>
<li><strong class="bold">AR Session and AR Session Origin</strong>: These are the primary components for any <a id="_idIndexMarker477"/>AR Foundation application. These form the stage for our performance. For an in-depth understanding of AR Session Origin and AR Session, you’re invited to revisit the <em class="italic">Exploring the AR Session Origin GameObject</em> and <em class="italic">Understanding the AR Session GameObject</em> sections of <a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a>.</li>
<li><strong class="bold">AR Raycast Manager and AR Plane Manager</strong>: These components come by default<a id="_idIndexMarker478"/> with AR Session Origin. AR Raycast Manager performs raycasts against tracked AR features and geometry, such as <a id="_idIndexMarker479"/>detected planes. We’ll use it to find where we can place our 3D models in the real world. AR Plane Manager, on the other hand, allows you to detect and track horizontal and vertical surfaces in the real world.</li>
<li><strong class="bold">Food prefabs</strong>: These<a id="_idIndexMarker480"/> are 3D models of food items that users can place in the real world. They are the tangible objects that the user will in<a id="_idTextAnchor021"/>teract with.</li>
<li><strong class="bold">UI buttons and text elements</strong>: These <a id="_idIndexMarker481"/>UI elements are needed to guide the user on how the app works, to swap the current food prefab to the next or previous one in line, and to display nutritional information for each dish. Consider these UI elements as the interactive elements of our application where the users can participate.</li>
<li><strong class="bold">The ARPlacePrefab script</strong>: This is <a id="_idIndexMarker482"/>our main script, and it’s responsible for managing the placement of the 3D models and a UI button in the AR space. It also handles the user interactions for placing objects and updates the placement indicator based on AR raycast results.</li>
<li><strong class="bold">The SwapPrefab script</strong>: This<a id="_idIndexMarker483"/> script works in conjunction with the <strong class="bold">ARPlacePrefab</strong> script to switch between different food prefabs when the UI button is clicked.</li>
<li><code>Food</code>, which enables us to create <code>Food</code> objects with certain characteristics or properties, such as a name, ingredients, calories, and diet type.</li>
</ul>
<p>By implementing<a id="_idIndexMarker485"/> these components, we will have a working AR application that lets users place, view, and swap different 3D models of food in their real-world environment using their smartphone in place of a traditional printed menu. To ensure that the users understand what they are supposed to do in this application, dedicated UI elements will be added to the start scene of the application. By using visual cues such as grids, the process of finding the optimal <a id="_idIndexMarker486"/>position to place a dish will be facilitated for the user. By adding a scaling functionality, the user will be able to adjust the size of the displayed dish for an enhanced user experience.</p>
<p>In the following section, we will set up our AR application so that we’re one step closer to building an interactive AR app.</p>
<h2 id="_idParaDest-120">Setting up the environment</h2>
<p>To initiate <a id="_idIndexMarker487"/>our journey, let’s start by creating a new project, as explained in the <em class="italic">Creating an AR project with Unity’s AR template</em> section in <a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a>. If you’ve already completed these steps, you can simply open the existing project for this chapter. After your project loads, follow this step-by-step guide to set up your environment:</p>
<ol>
<li>Let’s kick-start the process by crafting a new empty scene. This can be achieved by going to <code>ARFoodMenu</code>.</li>
<li>A quick double-click will transport you into your newly minted scene, which currently only houses <strong class="bold">Main Camera</strong> and <strong class="bold">Directional Light</strong>. <strong class="bold">Main Camera</strong> can be removed as it won’t be needed.</li>
<li>Before diving into the AR setup, it’s important to lay the groundwork for our AR app. In our situation, this means incorporating <strong class="bold">AR Session Origin</strong> and <strong class="bold">AR Session</strong>. You can accomplish this by right-clicking in the <strong class="bold">Scene Hierarchy</strong> window, choosing <strong class="bold">XR</strong> | <strong class="bold">AR Session Origin</strong>, and repeating the same step for <strong class="bold">AR Session</strong>.</li>
<li>Once <code>AR Plane Manager</code> script, and select it. Repeat this process for the <strong class="bold">AR Raycast </strong><strong class="bold">Manager</strong> script.</li>
<li>In the <code>ARPlane</code> and drag the prefab into the <strong class="bold">Plane Prefab</strong> cell of the <strong class="bold">AR Plane Manager</strong> script component in the <strong class="bold">Inspector</strong> window. As we just want to detect horizontal planes for our AR menu application, select <strong class="bold">Horizontal</strong> for <strong class="bold">Detection Mode</strong>. We don’t need to assign any prefabs for <strong class="bold">AR Raycast Manager</strong> as we just need the functionality to calculate when the ray encounters the surface.</li>
</ol>
<p>And there you<a id="_idIndexMarker488"/> have it! With a few clicks, we’ve added <strong class="bold">AR Session</strong>, <strong class="bold">AR Session Origin</strong>, <strong class="bold">AR Raycast Manager</strong>, and <strong class="bold">AR Plane Manager</strong> to our scene. Our next move is to import food models from the Asset Store, which will showcase the meals we aim to present to the user.</p>
<h2 id="_idParaDest-121">Designing 3D food models</h2>
<p>As <a id="_idIndexMarker489"/>a restaurant proprietor, you need to produce 3D models of your meals at this stage. The following are a few strategies you could employ to design 3D models of food or dishes:</p>
<ul>
<li><strong class="bold">3D modeling software</strong>: There<a id="_idIndexMarker490"/> are many 3D modeling software tools you can use to create 3D models. These include <em class="italic">Blender</em>, <em class="italic">3ds Max</em>, <em class="italic">Autodesk Maya</em>, and <em class="italic">SketchUp</em>. Among these, <em class="italic">Blender</em> is a popular choice because it’s free and open source. There are many online tutorials available to help beginners get started with <em class="italic">Blender</em>, such as <em class="italic">CGFastTrack</em>’s YouTube channel (<a href="https://www.youtube.com/@CGFastTrack/featured">https://www.youtube.com/@CGFastTrack/featured</a>).</li>
<li><strong class="bold">Photogrammetry</strong>: Photogrammetry is a<a id="_idIndexMarker491"/> technique where you take multiple photographs of an object from different angles and then use software to stitch them together into a 3D model. Tools such as <em class="italic">Luma Labs</em>, <em class="italic">Reality Capture</em>, <em class="italic">Meshroom</em>, and <em class="italic">Agisoft Metashape</em> can help with this. For food models, this can give a very realistic result, but it may also be more complex to get right, particularly with foods that are uniform in color or texture.</li>
<li><strong class="bold">Download pre-made 3D models</strong>: If creating models is too time-consuming or outside your current skill set, you can download pre-made models from sites such as <em class="italic">Sketchfab</em>, <em class="italic">TurboSquid</em>, or the <em class="italic">Unity Asset Store</em>, which is what we will do for this project. Just make sure you check the licensing terms to see if they fit your needs.</li>
<li><strong class="bold">Hire a 3D artist</strong>: If you have a budget for your project, you might consider hiring a 3D artist to create custom food models for you. This can give you exactly what you want, tailored to your specifications.</li>
</ul>
<p>As we pointed <a id="_idIndexMarker492"/>out previously, we are going to import our models through the Unity Asset Store for the sake of this AR menu application. Follow these instructions to do this:</p>
<ol>
<li>Go to the Unity Asset Store (<a href="https://assetstore.unity.com/">https://assetstore.unity.com/</a>) and search for the <code>French Fries – Free</code> package. Alternatively, you can access the <strong class="bold">French Fries</strong> package page via this link: <a href="https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017">https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017</a>.</li>
<li>After adding the package to your assets, click the <strong class="bold">Open in Unity</strong> button that now appears on the Asset Store’s website.</li>
<li>Your Unity project should open, and you should be prompted with the option to import the package. Click the <strong class="bold">Import</strong> button to proceed.</li>
<li>Once the package has been successfully imported into your project, repeat the previous three steps for the <strong class="bold">Japanese Food Tofu – FREE</strong> package (<a href="https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533">https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533</a>) and the <strong class="bold">Japanese Food Kashipan – FREE</strong> package (<a href="https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938">https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938</a>).</li>
</ol>
<p>Now that we’ve imported the appropriate food meals into our scene, we fulfilled the food prefabs requisite. In the next section, we will add the UI button and text components that will guide the user through the AR menu application.</p>
<h2 id="_idParaDest-122">Adding UI buttons and text elements to our AR menu application</h2>
<p>In this<a id="_idIndexMarker493"/> section, we’ll focus on integrating three buttons and two text elements into our scene. These buttons are divided into one for initiating the<a id="_idIndexMarker494"/> app and two for transitioning between the dishes. The first text element serves to guide the user through the AR menu application, while the second acts as a placeholder to contain information about the displayed dish, such as its name, ingredients, caloric content, and dietary type.</p>
<p>Excluding the second text element, these UI elements should remain within the user’s field of view, regardless of how the device is rotated. This can be accomplished by assigning them as child objects to the AR camera.</p>
<p>Let’s start with the two dish-swapping buttons. Follow these steps to achieve this:</p>
<ol>
<li>Navigate to the <strong class="bold">Scene Hierarchy</strong> window, right-click on the <strong class="bold">AR Camera</strong> component, and select <strong class="bold">UI</strong> | <strong class="bold">Canvas</strong>. This action will add <strong class="bold">Canvas</strong> as a child object of <strong class="bold">AR Camera</strong>. The <strong class="bold">Canvas</strong> component is necessary for all UI elements.</li>
<li>Alter the Canvas’s <code>0.01</code>, <code>0.01</code>, <code>0.01</code>) with <code>480</code> and <code>90</code>. Position the <code>0</code>,<code>0</code>,<code>1</code>).</li>
<li>Create the buttons by right-clicking on the <code>ButtonNext</code> and <code>ButtonPrevious</code>. Rescale both buttons to (<code>0.07</code>, <code>0.32</code>, <code>1</code>) with <code>160</code> and <code>30</code>. Position <code>10</code>,<code>40</code>,<code>0</code>) and <code>-10</code>, <code>40</code>, <code>0</code>).</li>
<li>For the child objects of both buttons, enter arrows such as <code>-&gt;</code> and <code>&lt;-</code> as the text input in the <strong class="bold">Inspector</strong> window. These arrows tell the user which button switches to the next or previous dish.</li>
</ol>
<p>At this point, the two buttons have been fully initialized. Next, we need to create an instructional piece of text to guide users on how to use the AR menu application. To achieve this, follow these step-by-step instructions:</p>
<ol>
<li>Right-click on <code>0.17</code>, <code>0.17</code>, <code>0.17</code>). Adjust the panel top to <code>-46.5</code> and the panel bottom to <code>-3.4</code>. This panel will act as a backdrop for our text. You’re free to choose its color; in our case, we chose red. Rename this panel <code>InfoPanel</code>.</li>
<li>For the instructional text, right-click <code>InstructionText</code>. Adjust its scale to (<code>0.7</code>, <code>0.7</code>, <code>0.7</code>) with <code>600</code> and <code>150</code>; then, position it at (<code>0</code>, <code>0</code>, <code>0</code>).</li>
<li>Input the following text: <code>Wait until the blue surface is visible. This shows the area where the food is placed</code>. This instruction will be critical for the user as we’ll implement a blue grid area that indicates where the food prefabs will be placed.</li>
<li>To<a id="_idIndexMarker495"/> prevent the user seeing a meal directly<a id="_idIndexMarker496"/> when the application starts, create another button below the instruction text. This button is responsible for spawning the first dish. To do this, right-click <code>PlaceFirstMealButton</code>, scale it to (<code>2.2</code>, <code>2.2</code>, <code>2.2</code>), and position it at (<code>0</code>, <code>-292</code>, <code>0</code>) with <code>160</code> and <code>30</code>.</li>
<li>Open the child text component of <code>Place First Meal</code> as the text input in the <strong class="bold">Inspector</strong> window. Activate the <strong class="bold">Active auto size</strong> checkbox to make sure that the text is adjusted with the button. Both <strong class="bold">InstructionText</strong> and <strong class="bold">PlaceFirstMealButton</strong> are child objects of <strong class="bold">InfoPanel</strong>. They are designed to disappear after the first meal is placed. This means we only need to target <strong class="bold">InfoPanel</strong> in our code instead of all three objects individually.</li>
</ol>
<p>Lastly, we require another text element, but this time, it should not be a child object of <strong class="bold">AR camera</strong>. This text needs to spawn above the dishes and remain there consistently.</p>
<p>To accomplish this, let’s perform the following steps:</p>
<ol>
<li>Create another <code>0.1</code>, <code>0.1</code>, <code>0.1</code>) and position it at (<code>0.3</code>, <code>0.3</code>, <code>1</code>) with <code>480</code> and <code>90</code>. Rename this <code>FoodInfoCanvas</code>.</li>
<li>Right-click <code>FoodInfoText</code>, scale it to (<code>0.005</code>, <code>0.005</code>, <code>0.005</code>), and position it at (<code>-3.4</code>, <code>0</code>,<code>31</code>, <code>0</code>) with <code>200</code> and <code>50</code>. <strong class="bold">FoodInfoText</strong> does not need<a id="_idIndexMarker498"/> text input as this will be assigned programmatically in correspondence with the displayed dish.</li>
</ol>
<p>At this point, your <strong class="bold">Scene Hierarchy</strong> window should look like what is shown in <em class="italic">Figure 6</em><em class="italic">.1</em>.</p>
<div><div><img alt="Figure 6.1 – ﻿Our project’s Scene Hierarchy window, showcasing all components in our scene" src="img/B20869_06_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Our project’s Scene Hierarchy window, showcasing all components in our scene</p>
<p>Similarly, all your UI elements should be aligned in your Game view, as shown in <em class="italic">Figure 6</em><em class="italic">.2</em>.</p>
<div><div><img alt="Figure 6.2 – ﻿Our project’s Game view, showcasing the alignment of the different UI elements in the scene" src="img/B20869_06_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Our project’s Game view, showcasing the alignment of the different UI elements in the scene</p>
<p>Please note <a id="_idIndexMarker499"/>that all UI elements are positioned and <a id="_idIndexMarker500"/>scaled concerning the <strong class="bold">Canvas</strong> component. If your UI elements have a different alignment to the one shown in <em class="italic">Figure 6</em><em class="italic">.2</em>, you can manually adjust the position and scale of your <strong class="bold">Canvas</strong> component.</p>
<p>With that, we have successfully added all the necessary UI elements to our scene and therefore finished adding UI buttons and text elements to create an interactive AR application. Next, we’ll add scripts to our scene to introduce some interactivity and life to it.</p>
<h1 id="_idParaDest-123">Adding interactivity to our AR menu application</h1>
<p>To <a id="_idIndexMarker501"/>infuse life into <a id="_idIndexMarker502"/>our currently modest AR scene, we must incorporate some C# scripts into our project. This key step will empower the users of our AR app, allowing them to <a id="_idIndexMarker503"/>interact with our imported food pr<a id="_idTextAnchor022"/>efabs dynamically and engagingly.</p>
<p>In the next section, you will get an overview of the short but decisive <strong class="bold">Food</strong> script.</p>
<h2 id="_idParaDest-124">Adding the Food script to the scene</h2>
<p>Before we dive<a id="_idIndexMarker504"/> into scripting, let’s first organize our project workspace so that we can work more efficiently by finding the needed components quickly.</p>
<p>Start by adding a new folder to the <code>Assets</code> directory in the <code>Scripts</code> and enter it. Right-click in this empty folder and select <code>Food</code>. After double-clicking on this script, it should be opened in your preferred <strong class="bold">integrated development </strong><strong class="bold">environment</strong> (<strong class="bold">IDE</strong>).</p>
<p>The <code>Food</code> objects that are created will have certain characteristics or properties, just like how every car has a make, model, and color.</p>
<p>Here’s a simple breakdown of this script:</p>
<pre class="source-code">
[System.Serializable]
public class Food
{
    public string name;
    public string ingredients;
    public string calories;
    public string dietType;
    public GameObject prefab;
}</pre>
<p><code>[System.Serializable]</code> is a directive that tells Unity to make this class serializable. This means that Unity will be able to save and load <code>Food</code> objects and that you’ll be able to edit <code>Food</code> objects directly in the Unity editor.</p>
<p>After <a id="_idIndexMarker505"/>defining a new, public class called <code>Food</code>, a public property called <code>name</code> is declared. This property represents the name of the food, such as <code>French Fries</code>. Next, we declare additional properties such as <code>ingredients</code>, <code>calories</code>, and <code>dietType</code>. The latter property stores the type of diet the food fits into, such as <code>Vegetarian</code>, <code>Vegan</code>, or <code>Paleo</code>.</p>
<p>Lastly, a public property that will hold a <code>GameObject</code> is declared that represents the 3D model of the food that will be displayed in the AR environment.</p>
<p>As we venture into the next section, we’ll continue our journey by incorporating the most pivotal C# script in our scene – the <strong class="bold">ARPlacePrefab</strong> script. It is this crucial component that will truly open the doors of interactivity within our AR menu application.</p>
<h2 id="_idParaDest-125">Adding the ARPlacePrefab script to the scene</h2>
<p>Similar to the <a id="_idIndexMarker506"/>previous scripts we created in this chapter, navigate to the <code>Assets</code> folder in the <code>ARPlacePrefab</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">We highly recommend that you clone the <a href="B20869_06.xhtml#_idTextAnchor020"><em class="italic">Chapter 6</em></a> project, which can be found in the GitHub repository of this book, and open it in parallel, enabling you to revisit and mimic the steps described in this project tutorial more easily.</p>
<p>We can open the just-created <code>ARPlacePrefab</code> script by double-clicking on it.</p>
<p class="callout-heading">Tip</p>
<p class="callout">The script will launch in the default IDE that you usually utilize. If you wish to switch to a different IDE, simply go to <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> in the Unity editor. In the newly opened <strong class="bold">Preferences</strong> window, navigate to the <strong class="bold">External Tools</strong> tab and alter <strong class="bold">External Script Editor</strong> to the IDE of your preference.</p>
<p>The <code>ARPlacePrefab</code> script, as <a id="_idIndexMarker507"/>previously highlighted, will serve as our primary script. It carries out the crucial role of handling the placement of the 3D models and UI buttons within the AR space. Moreover, it manages user interactions so that it can position objects and dynamically update the placement indicator based on AR raycast outcomes.</p>
<p>Next, let’s take a look at the various methods and functions in the <code>ARPlacePrefab</code> script.</p>
<h3>Understanding the ARPlacePrefab script</h3>
<p>As the <code>ARPlacePrefab</code> script <a id="_idIndexMarker508"/>is the core of our AR menu application, we must understand every method of it to truly grasp the mechanisms of interactive AR experiences and successfully replicate the script’s functionality in a wide range of projects and contexts.</p>
<p>In the following code snippets, you’ll notice some lines that have been commented out. This is because they reference the <strong class="bold">SwabPrefab</strong> script, which hasn’t been created yet, and would result in compile errors if left uncommented.</p>
<p>At the top of the <code>ARPlacePrefab</code> script, various public and private variables are declared:</p>
<pre class="source-code">
public class ARPlacePrefab : MonoBehaviour
{
    public GameObject ObjectToPlace;
    //public SwapPrefab SwapPrefabScript;
    public GameObject NextPrefabButton;
    public GameObject PreviousPrefabButton;
    public TextMeshProUGUI InfoText;
    public Button PlaceFirstMealButton;
    public GameObject InfoPanel;
    private ARRaycastManager _arRaycastManager;
    private Pose _placementPose;
    private bool _placementPoseIsValid = false;
    private GameObject _placedObject;
    private GameObject _nextButton;
    private GameObject _previousButton;
    private Vector2 _oldTouchDistance;
    private GameObject _placementIndicator;
    private GameObject _placementGrid;</pre>
<p>The public variables of the <code>ARPlacePrefab</code> script allow users to interact with the AR space, such as positioning <code>ObjectToPlace</code> or cycling between 3D models using <code>NextPrefabButton</code> and <code>PreviousPrefabButton</code>. They also enable users to view details via <code>InfoText</code> and <code>InfoPanel</code>, as well as activate specific AR placements with <code>PlaceFirstMealButton</code>. Additionally, they provide a space for extended details or options.</p>
<p>On the<a id="_idIndexMarker509"/> other hand, the private variables govern the internal mechanics of the AR experience. <code>_arRaycastManager</code> handles surface detection in the real-world environment, while <code>_placementPose</code> denotes the desired position for the AR object. Its validity is tracked by <code>_placementPoseIsValid</code>. Once an object is placed in the AR space, it’s referred to as <code>_placedObject</code>. Touch gestures utilize <code>_oldTouchDistance</code>. Lastly, <code>_placementIndicator</code> and <code>_placementGrid</code> offer visual cues to users, indicating where an AR object will be positioned.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Some lines, related to the yet-to-be-introduced <strong class="bold">SwapPrefab</strong> script, have been commented out to prevent any compilation issues. We will uncomment them toward the end of our scripting process.</p>
<p>The first method of the <code>ARPlacePrefab</code> script is the <code>Start()</code> method:</p>
<pre class="source-code">
void Start()
    {
        _arRaycastManager =
            FindObjectOfType&lt;ARRaycastManager&gt;();
        //_nextButton = InstantiateButton(NextPrefabButton,
        //SwapPrefabScript.SwapFoodPrefab);
        //_previousButton =
        //InstantiateButton(PreviousPrefabButton,
        //SwapPrefabScript.SwapToPreviousFoodPrefab);
        _placementGrid = CreatePlacementGrid();
        PlaceFirstMealButton.onClick
            .AddListener(PlaceObjectIfNeeded);
    }</pre>
<p>This function <a id="_idIndexMarker510"/>is called when the program first starts. It’s where the initial setup for the script is done, such as finding the <code>_nextButton</code> and <code>_previousButton</code> have been commented out because they reference the yet-to-be-created <strong class="bold">SwapPrefab</strong> script. This script is associated with the two buttons that enable users to cycle through various food choices.</p>
<p>The next method that is called in the <code>ARPlacePrefab</code> class is the <code>Update()</code> method:</p>
<pre class="source-code">
void Update()
    {
        if (Input.touchCount == 2)
        {
            PinchToScale();
        }
        UpdatePlacementPose();
        UpdatePlacementIndicator();
        if (_placementPoseIsValid &amp;&amp; Input.touchCount &gt; 0
            &amp;&amp; Input.GetTouch(0).phase == TouchPhase.Began)
        {
            PlaceObject();
        }
    }</pre>
<p>The <code>Update()</code> method is<a id="_idIndexMarker511"/> like the heartbeat of the script, constantly checking on things every moment the game is running. If a two-finger touch input is detected, it adjusts the scale of the placed object based on how much the distance between the fingers changes, similar to a pinch or stretch movement. It also updates the placement pose and indicator, which determines where the object will be placed, and listens for a single touch input. If a single touch input is detected, it places the object.</p>
<p>The <code>PlaceObject()</code> method follows after the <code>Update()</code> method and looks like this:</p>
<pre class="source-code">
public void PlaceObject()
    {
        if (_placedObject != null)
        {
            Destroy(_placedObject);
        }
        _placedObject = Instantiate(ObjectToPlace,
            _placementPose.position,
            _placementPose.rotation);
        _placedObject.transform.localScale = new
            Vector3(0.5f, 0.5f, 0.5f);
        PositionButton(_nextButton, new Vector3(0.5f, 0f,
            0f));
        PositionButton(_previousButton, new Vector3(-0.5f,
            0f, 0f));
        UpdateFoodInfoText();
        _placementGrid.SetActive(false);
    }</pre>
<p>This function <a id="_idIndexMarker512"/>is called when a single touch input is detected in the <code>Update()</code> function. It places the selected object in the real world at the location determined by the placement pose. It also positions and activates the next and previous buttons. Then, it fetches some information about the currently selected food item and updates the <code>InfoText</code> UI with this information.</p>
<p>The next method in the <code>ARPlacePrefab</code> class is the <code>UpdatePlacementPose()</code> method:</p>
<pre class="source-code">
private void UpdatePlacementPose()
    {
        var screenCenter =
            Camera.current.ViewportToScreenPoint(
            new Vector3(0.5f, 0.5f));
        var hits = new List&lt;ARRaycastHit&gt;();
        _arRaycastManager.Raycast(screenCenter, hits,
            TrackableType.Planes);
        _placementPoseIsValid = hits.Count &gt; 0;
        if (_placementPoseIsValid)
        {
            _placementPose = hits[0].pose;
            PositionGrid(hits[0].pose.position,
                hits[0].pose.rotation);
        }
        else
        {
            _placementGrid.SetActive(false);
        }
    }</pre>
<p>This <a id="_idIndexMarker513"/>method is called in the <code>Update()</code> function. It acts like the script’s eyes in the sense that it’s always looking at the middle of your screen and figuring out where in the real world that corresponds to in the virtual world. This method updates the placement pose, which is the position and orientation where the new object will be placed. It does this by casting a ray from the center of the screen and checking if it hits a plane in the AR environment.</p>
<p>The <code>UpdatePlacementIndicator()</code> method works similarly to the <code>UpdatePlacementPose()</code> method and looks like this:</p>
<pre class="source-code">
private void UpdatePlacementIndicator()
    {
        if (_placementPoseIsValid)
        {
            _placementIndicator.SetActive(true);
            _placementIndicator.transform
                .SetPositionAndRotation(
                _placementPose.position,
                _placementPose.rotation);
        }
        else
        {
            _placementIndicator.SetActive(false);
        }
    }</pre>
<p>This function is also called in the <code>Update()</code> function. It simply moves and rotates the placement<a id="_idIndexMarker514"/> indicator to match the placement pose, showing the user where the object will be placed. It also turns <code>LineRenderer</code> on or off, depending on whether a suitable location for placing the object was found.</p>
<p>The next method is called <code>InstantiateButton()</code> and looks like this:</p>
<pre class="source-code">
private GameObject InstantiateButton(GameObject
buttonPrefab, UnityEngine.Events.UnityAction onClickAction)
    {
        var button = Instantiate(buttonPrefab);
        button.SetActive(false);
        button.GetComponent&lt;Button&gt;().onClick
            .AddListener(onClickAction);
        return button;
    }</pre>
<p>The <code>InstantiateButton</code> method serves as a vital cog in the <code>ARPlacePrefab</code> class. Its primary role is to create and set up the buttons that users interact with to navigate between food choices. When invoked, the method takes in two parameters: a button prefab and an action to be executed upon clicking the button.</p>
<p>The method <a id="_idIndexMarker515"/>begins by creating a new instance of the button using the provided prefab. Once instantiated, the button is initially set to be inactive, ensuring it doesn’t immediately appear or interfere with the user interface. Then, the method fetches the button’s built-in <strong class="bold">On Click</strong> event and attaches the specified action to it, ensuring the desired function is executed when the button is pressed. Finally, the newly created and configured button is returned by the method, ready for use in the AR interface.</p>
<p>The next two methods in the script act as helper functions. They are called <code>CreatePlacementGrid()</code> and <code>PlaceObjectIfNeeded()</code>:</p>
<pre class="source-code">
private GameObject CreatePlacementGrid()
    {
        var grid =
           GameObject.CreatePrimitive(PrimitiveType.Plane);
        grid.transform.localScale = new Vector3(0.01f,
            0.01f, 0.01f);
        grid.GetComponent&lt;Renderer&gt;().material =
            Resources.Load&lt;Material&gt;("GridMaterial");
        grid.SetActive(false);
        return grid;
    }
    private void PlaceObjectIfNeeded()
    {
        if (_placementPoseIsValid)
        {
            PlaceObject();
            InfoPanel.SetActive(false);
        }
    }</pre>
<p>The <code>CreatePlacementGrid()</code> method creates a little grid in the virtual world to help you <a id="_idIndexMarker516"/>see where your dish will be placed before you place it. If everything has been set up correctly, the <code>PlaceObjectIfNeeded()</code> method places the food prefab in the virtual world and then hides <code>InfoPanel</code>, cleaning up your screen. Pay attention to the following line in the <code>CreatePlacementGrid()</code> method:</p>
<pre class="source-code">
grid.GetComponent&lt;Renderer&gt;().material =
Resources.Load&lt;Material&gt;("GridMaterial");</pre>
<p>Here, we assign a <code>grid</code> so that the user sees a visual cue of where the food prefab will be placed. Besides using the Unity editor’s interface, C# scripting provides us with another way to assign materials to <code>GameObject</code> – that is, by defining the precise path and name of the material that we want to use. In this case, a material named <code>GridMaterial</code> is expected to be in the <code>Resources</code> folder of our project.</p>
<p>Before continuing with the next few methods, let’s quickly create a material called <code>GridMaterial</code> in the <code>Resources</code> folder of our project. Simply head to the <code>Assets</code> folder, and select <code>Resources</code> and enter it. Right-click inside this folder and select <code>GridMaterial</code> and select a blue albedo color of your choice.</p>
<p>Now, back in the <code>ARPlacePrefab</code> class, let’s have a look at the <code>PinchToScale()</code> and <code>ScalePlacedObject()</code> methods, which look like this:</p>
<pre class="source-code">
private void PinchToScale()
    {
        Touch touchZero = Input.GetTouch(0);
        Touch touchOne = Input.GetTouch(1);
        if (touchZero.phase ==
        TouchPhase.Moved || touchOne.phase ==
        TouchPhase.Moved)
        {
            Vector2 touchDistance =
                touchOne.position - touchZero.position;
            float pinchDistanceChange =
                touchDistance.magnitude –
                _oldTouchDistance.magnitude;
            float pinchToScaleSensitivity = 0.001f;
            if (_placedObject != null)
            {
                ScalePlacedObject(pinchDistanceChange,
                    pinchToScaleSensitivity);
            }
            _oldTouchDistance = touchDistance;
        }
    }
private void ScalePlacedObject(float pinchDistanceChange, float pinchToScaleSensitivity)
    {
        Vector3 newScale =
            _placedObject.transform.localScale + new
            Vector3(pinchDistanceChange,
            pinchDistanceChange, pinchDistanceChange) *
            pinchToScaleSensitivity;
        newScale = Vector3.Max(newScale, new Vector3(0.1f,
            0.1f, 0.1f));
        newScale = Vector3.Min(newScale, new Vector3(10f,
            10f, 10f));
        _placedObject.transform.localScale = newScale;
    }</pre>
<p>As the names <a id="_idIndexMarker517"/>of these two methods already suggest, they enable the zoom feature of the food prefabs. The <code>PinchToScale()</code> method checks whether you’re using two fingers to pinch the screen, and if you are, it changes the size of your placed object by calling the <code>ScalePlacedObject()</code> method. This functionality is very useful in the context of our AR menu application as it enables the user to scale the displayed food prefab to the desired size.</p>
<p>The <code>PositionButton()</code> method provides another useful functionality for application users. It consists of these components:</p>
<pre class="source-code">
private void PositionButton(GameObject button,
Vector3 offset)
    {
        button.transform.position =
            _placedObject.transform.position + offset;
        button.SetActive(true);
    }</pre>
<p>The <code>PositionButton()</code> method ensures the next and previous buttons are always near your placed object so that you can easily press them. Hence, this method is fundamental to ensure<a id="_idIndexMarker518"/> a satisfying user experience of the A<a id="_idTextAnchor023"/>R menu application across different devices.</p>
<p>The <code>UpdateFoodInfoText()</code> method is another integral part of the<code>ARPlacePrefab</code> class. Let’s see what the method looks like:</p>
<pre class="source-code">
private void UpdateFoodInfoText()
    {
        /*Food currentFood =
            SwapPrefabScript.GetCurrentFood();
        InfoText.text = $"&lt;b&gt;Name:&lt;/b&gt;
        {currentFood.name}\n&lt;b&gt;Ingredients:&lt;/b&gt;
        {currentFood.ingredients}\n
        &lt;b&gt;&lt;color=red&gt;Calories:&lt;/color&gt;&lt;/b&gt;
        {currentFood.calories}\n&lt;b&gt;Diet Type:&lt;/b&gt;
        {currentFood.dietType}";*/
        InfoText.transform.position =
            _placedObject.transform.position + new
            Vector3(-0.2f, 0.3f, 0f);
        InfoText.transform.rotation =
            _placedObject.transform.rotation;
    }</pre>
<p>Once you’ve placed a food prefab in the environment, the <code>UpdateFoodInfoText()</code> method tells you more about this specific dish, such as its name, ingredients, how many calories it has, and which diet it aligns with. As before, the initial lines have been commented out due to their reference to the yet-to-be-created <strong class="bold">SwapPrefab</strong> script.</p>
<p>Finally, there is only one small script left for you to understand in the <code>ARPlacePrefab</code> class. It’s the <code>PositionGrid()</code> method and it looks like this:</p>
<pre class="source-code">
private void PositionGrid(Vector3 position,
Quaternion rotation)
    {
        _placementGrid.transform.SetPositionAndRotation(
            position, rotation);
        _placementGrid.SetActive(true);
    }</pre>
<p>This method <a id="_idIndexMarker519"/>simply moves the placement grid to the right spot in the virtual world so that it matches where your indicator is pointing in the real world.</p>
<p>With that, you have successfully understood the <code>ARPlacePrefab</code> script, which is the primary script that’s used in our AR menu application. In the next section, you will learn how to attach this script to <strong class="bold">AR Session Origin</strong> as a component.</p>
<h3>Assigning the ARPlacePrefab script as a component</h3>
<p>By attaching the<a id="_idIndexMarker520"/> main script of any AR application to <code>ARPlacePrefab</code> script as a component of <strong class="bold">AR Session Origin</strong> in the <strong class="bold">Inspector</strong> window in the Unity editor before progressing to the next step. To do this, simply follow these steps:</p>
<ol>
<li>Select <code>ARPlacePrefab</code> script. By selecting it, the script’s public fields are shown in the <strong class="bold">Inspector</strong> window.</li>
<li>For the <strong class="bold">Object to Place</strong> field, you can assign one of the food prefabs, such as <strong class="bold">Tofu</strong>, by dragging and dropping it from the <strong class="bold">Project</strong> window into the corresponding cell.</li>
<li>Following the same principle, you can drag and drop <strong class="bold">ButtonNext</strong> into the <strong class="bold">Next Prefab Button</strong> cell, <strong class="bold">ButtonPrevious</strong> into the <strong class="bold">Previous Prefab Button</strong> cell, <strong class="bold">FoodInfoText</strong> into the <strong class="bold">InfoText</strong> cell, <strong class="bold">PlaceFirstMealButton</strong> into the <strong class="bold">Place First Meal Button</strong> cell, and <strong class="bold">InfoPanel</strong> into the <strong class="bold">Info </strong><strong class="bold">Panel</strong> cell.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">The <strong class="bold">SwapPrefab</strong> cell expects the <strong class="bold">SwapPrefab</strong> script, which we are going to create and assign in the upcoming sections.</p>
<p>Congratulations – you<a id="_idIndexMarker521"/> have successfully fulfilled the <code>ARPlacePrefab</code> script requirement on our roadmap to create an interactive AR menu application! In the next section, you will come even closer to the final application by delving into the script that swaps our food prefabs: the <strong class="bold">SwapPrefab</strong> script.</p>
<h2 id="_idParaDest-126">Adding the SwapPrefab script to the scene</h2>
<p>To add the <code>Assets</code> folder in the <code>SwapPrefab</code>. Double-click on the script to open it in your preferred IDE.</p>
<p>The <code>SwapPrefab</code> script is tied to the two buttons that allow the user to cycle through different food options. It starts like this:</p>
<pre class="source-code">
public class SwapPrefab : MonoBehaviour
{
    public Food[] AvailableFoods;
    private int CurrentFoodIndex = 0;
    private ARPlacePrefab ARPrefabPlacement;</pre>
<p>In the preceding code snippet, you can see the declaration of a list of <code>Food</code> objects called <code>AvailableFoods</code>, a variable to keep track of the current food called <code>currentFoodIndex</code>, and a reference to the <code>ARPlacePrefab</code> script called <code>ARPlacePrefab</code>.</p>
<p>Next, let’s have a look at the methods of the <code>SwapPrefab</code> class to understand how the user can cycle through the different dishes.</p>
<p>The first method that is relevant for this is the <code>Start()</code> method. It looks like this:</p>
<pre class="source-code">
void Start()
    {
        ARPrefabPlacement =
            FindObjectOfType&lt;ARPlacePrefab&gt;();
        if (AvailableFoods.Length &gt; 0)
        {
            ARPrefabPlacement.ObjectToPlace =
                AvailableFoods[0].prefab;
        }
    }</pre>
<p>This method <a id="_idIndexMarker523"/>is called when the scene starts. It grabs a reference to the <code>ARPlacePrefab</code> script and sets the first food object in the list as the one to be placed in the AR environment.</p>
<p>Next, there is the <code>SwapFoodPrefab()</code> method, which looks like this:</p>
<pre class="source-code">
public void SwapFoodPrefab()
    {
        CurrentFoodIndex = (CurrentFoodIndex + 1) %
            AvailableFoods.Length;
        ARPrefabPlacement.ObjectToPlace =
            AvailableFoods[CurrentFoodIndex].prefab;
        ARPrefabPlacement.PlaceObject();
        // Update the InfoText
        ARPrefabPlacement.InfoText.text = $"&lt;b&gt;Name:&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].name}\n
        &lt;b&gt;Ingredients:&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].ingredients}\n
        &lt;b&gt;&lt;color=red&gt;Calories:&lt;/color&gt;&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].calories}\n
        &lt;b&gt;Diet Type:&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].dietType}";
    }</pre>
<p>This method <a id="_idIndexMarker524"/>is linked to a button. When the button is clicked, it advances <code>currentFoodIndex</code> to the next food in the list or back to the start if it’s at the end and updates <code>objectToPlace</code> in the <code>ARPlacePrefab</code> script to the new food. Then, it immediately places the new food object in the AR environment and updates the displayed information about the food.</p>
<p>The <code>SwapToPreviousFoodPrefab()</code> method in the <code>SwapPrefab</code> class consists of the following lines of code:</p>
<pre class="source-code">
public void SwapToPreviousFoodPrefab()
    {
        CurrentFoodIndex--;
        if (CurrentFoodIndex &lt; 0)
        {
            CurrentFoodIndex = AvailableFoods.Length - 1;
        }
        ARPrefabPlacement.ObjectToPlace =
            AvailableFoods[CurrentFoodIndex].prefab;
        ARPrefabPlacement.PlaceObject();
        // Update the InfoText
        ARPrefabPlacement.InfoText.text = $"&lt;b&gt;Name:&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].name}\n
        &lt;b&gt;Ingredients:&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].ingredients}\n
        &lt;b&gt;&lt;color=red&gt;Calories:&lt;/color&gt;&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].calories}\n
        &lt;b&gt;Diet Type:&lt;/b&gt;
        {AvailableFoods[CurrentFoodIndex].dietType}";
    }</pre>
<p>This<a id="_idIndexMarker525"/> method works similarly to <code>SwapFoodPrefab()</code>, but it goes back to the previous food in the list instead of moving forward. If it’s already at the start of the list, it loops back to the end. Like <code>SwapFoodPrefab()</code>, it then immediately places the new food object and updates the displayed information.</p>
<p>Lastly, there is the short <code>GetCurrentFood()</code> method:</p>
<pre class="source-code">
public Food GetCurrentFood()
    {
        return AvailableFoods[CurrentFoodIndex];
    }</pre>
<p>This is a simple helper method that other parts of the program can call to find out what the current food is.</p>
<p>Remember those lines we commented out in the <code>ARPlacePrefab</code> script because they referenced the <code>SwapPrefab</code> script? Now is the time to go back to the <code>ARPlacePrefab</code> script and uncomment those lines. Once you’ve done this, we can dive into the last missing snippets of our AR menu application.</p>
<h2 id="_idParaDest-127">Setting up On Click events for the buttons</h2>
<p>Now, we<a id="_idIndexMarker526"/> need to link <code>SwapPrefab</code> script by adding <strong class="bold">On Click</strong> events to both. Follow these steps to do this:</p>
<ol>
<li>We need to attach the <code>SwapPrefab</code> script to a <code>GameObject</code> object in our scene. We can do this by creating an empty <code>GameObject</code> object in the <code>GameObject</code> to <code>PrefabManager</code> and attach the <code>SwapPrefab</code> script to it.</li>
<li>Now, we must link <code>SwapPrefab</code> script. Let’s start with <code>PrefabManager</code> <code>GameObject</code> into the object cell. In the drop-down menu, select the <code>SwapPrefab</code> | <code>SwapFoodPrefab()</code> function. This calls the <code>SwapFoodPrefab()</code> function of the <code>SwapPrefab</code> script, whenever <strong class="bold">ButtonNext</strong> is pressed. <em class="italic">Figure 6</em><em class="italic">.3</em> shows what the <strong class="bold">On Click</strong> event of <strong class="bold">ButtonNext</strong> should look like.</li>
</ol>
<div><div><img alt="Figure 6.3 – ﻿ButtonNext’s On Click event" src="img/B20869_06_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – ButtonNext’s On Click event</p>
<ol>
<li value="3">Repeat this process for <code>SwapPrefab</code> | <code>SwapToPreviousFoodPrefab()</code> function from the dropdown.</li>
</ol>
<p>Do you remember the takeaway from the <em class="italic">Assigning the ARPlacePrefab script as a component</em> section in that the <code>SwapPrefab</code> script is the last missing cell input of the <code>ARPlacePrefab</code> script that is attached to <code>SwapPrefab</code> script to this cell. You can do this in a few, simple steps:</p>
<ol>
<li>Select <strong class="bold">AR Session Origin</strong> in the <strong class="bold">Scene </strong><strong class="bold">Hierarchy</strong> window.</li>
<li>Search for <code>SwapPrefab</code> via the search bar of the <strong class="bold">Project</strong> window.</li>
<li>Now, drag and drop the script into the respective cell of the AR Session Origin’s <code>ARPlacePrefab</code> script component in the <code>ARPlacePrefab</code> script component should look like now.</li>
</ol>
<div><div><img alt="Figure 6.4 – ﻿The ARPlacePrefab script component of AR Session Origin once all of its cells have been correctly assigned" src="img/B20869_06_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The ARPlacePrefab script component of AR Session Origin once all of its cells have been correctly assigned</p>
<p>Before <a id="_idIndexMarker527"/>testing the scene on your PC or deploying it to your phone, there is one last step you have to take: add some nutritional information to our food prefabs. This can be done very easily:</p>
<ol>
<li>Select <strong class="bold">PrefabManager</strong> in the <strong class="bold">Scene Hierarchy</strong> window and navigate to the <strong class="bold">Inspector</strong> window.</li>
<li>In the <code>SwapPrefab</code> script component, click the <strong class="bold">+</strong> button three times to add three dishes to our AR menu application.</li>
<li>Insert the names, nutritional information, diet type, and prefabs of our three dishes, namely <strong class="bold">French Fries</strong>, <strong class="bold">Tofu</strong>, and <strong class="bold">Kashipan</strong>, into the respective cells, as shown in <em class="italic">Figure 6</em><em class="italic">.5</em>.</li>
</ol>
<div><div><img alt="Figure 6.5 – ﻿The inserted names, nutritional information, diet type, and prefabs of our three dishes in the PrefabManager’s SwapPrefab script component" src="img/B20869_06_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The inserted names, nutritional information, diet type, and prefabs of our three dishes in the PrefabManager’s SwapPrefab script component</p>
<p>With that, you <a id="_idIndexMarker528"/>have completed the final step in our roadmap to create an interactive AR menu application. To celebrate this milestone, the next section explains how you can explore the different features of your newly developed AR application on your mobile device.</p>
<h2 id="_idParaDest-128">Exploring the completed, interactive AR menu application on a mobile device</h2>
<p>To test<a id="_idIndexMarker529"/> your interactive <a id="_idIndexMarker530"/>AR menu application on your PC or deploy it onto your mobile device, please refer to the step-by-step instructions provided in the <em class="italic">Deploying AR experiences onto mobile devices</em> section of <a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a>. <em class="italic">Figure 6</em><em class="italic">.6</em> shows you what should be displayed on your screen once you have successfully deployed the AR menu application onto your mobile device and opened it.</p>
<div><div><img alt="Figure 6.6 – ﻿The initial screen of the newly deployed AR menu application on a mobile device" src="img/B20869_06_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The initial screen of the newly deployed AR menu application on a mobile device</p>
<p>Notice<a id="_idIndexMarker531"/> how <a id="_idIndexMarker532"/>we can see the instruction text, which familiarizes the user with the nature of the application, and the button at the bottom of the application, which the user has to press to place the first dish on the detected plane. You can also see the two buttons that the user can press to see the next or previous prefab. If there is a horizontal plane in your scene, you will see the blue placement grid element in the center of your screen.</p>
<p><em class="italic">Figure 6</em><em class="italic">.7</em> shows what the screen of your device should look like once you have pressed the <strong class="bold">Place First </strong><strong class="bold">Meal</strong> button.</p>
<div><div><img alt="Figure 6.7 – ﻿The screen of the AR menu application on a mobile device once the “Place First Meal” button has been pressed" src="img/B20869_06_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – The screen of the AR menu application on a mobile device once the “Place First Meal” button has been pressed</p>
<p>By<a id="_idIndexMarker533"/> touching the screen <a id="_idIndexMarker534"/>with two of your fingers and moving them closer together or further apart, you can scale the <strong class="bold">French Fries</strong> to become bigger or smaller. By changing the rotation of your mobile device after the first food prefab has been placed and clicking on the <strong class="bold">-&gt;</strong> button, the next food prefab should be placed at the new position, as indicated by the blue placement grid element.</p>
<p>The upcoming section offers a summary of the valuable skills you’ve acquired in your journey to create XR applications in Unity. Specifically, you’ve harnessed the power of C# scripting to craft interactive AR applications. This newfound expertise marks a significant enhancement to your repertoire, expanding your capacity to develop sophisticated XR experiences.</p>
<h1 id="_idParaDest-129">Summary</h1>
<p>Throughout this chapter, you’ve embarked on the exciting journey of building your very first interactive AR application, testing it meticulously on your mobile device. This experience should have empowered you to evaluate prospective AR app ideas critically in terms of their utility.</p>
<p>Leveraging intuitive design patterns, you should now feel equipped to create engaging AR applications that allow users to interact seamlessly with virtual objects within a real-world context. From establishing the core components of the AR app, such as user interface and text elements, to invoking their interactivity through C# scripting, you’re now well-equipped to create a diverse array of interactive AR applications.</p>
<p>These applications will breathe life into virtual objects placed within real-world environments, inviting users to interact with them in significant and captivating ways. Congratulations on reaching this milestone in your AR development journey. You are now more than capable of bringing your creative AR ideas to life.</p>
<p>Looking forward, the next chapter promises to elevate your VR development skills to a new level. It’s all about adding magic to your VR scenes through audio and visual effects. The upcoming chapter will delve into the theory of audio in Unity, guide you through the process of incorporating audio sources and mixers, and unveil the secrets of adding particle effects and animations to your VR experiences. The road ahead is set to be an exciting journey of discovery and application.</p>
</div>
</body></html>