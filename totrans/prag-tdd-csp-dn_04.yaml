- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real Unit Testing with Test Doubles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test differentiates itself from other test categories by using **test
    doubles**; actually, you would rarely see a unit test without a test double.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of confusion on the web about what that means. My aim in this
    chapter is to clarify this term so that you can use it in the right context and
    give you as many explained examples of the topic so you feel confident in selecting
    the right test double for the test at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the concepts and usage of test doubles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss more testing categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will understand what is special about unit testing
    and will be able to use test doubles to start writing realistic unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using test doubles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You would rarely write a unit test without using a **test double**. Think of
    the term *double* in the same sense as a Hollywood stunt, where a stunt takes
    the place of a real actor in some situations. *Test double* is an umbrella term
    for an object that is used to replace a dependency with a test equivalent (double)
    for the sake of testing a SUT. They are meant to satisfy one or more of the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement 1**: Enable the test code to compile.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement 2**: Eliminate side effects according to the unit test requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement 3**: Embed a canned (predetermined) behavior that relates somehow
    to the real behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement 4**: Take a note of and verify the activities that were exerted
    on a dependency within a unit test (we will name this requirement later as *spying*).'
  prefs: []
  type: TYPE_NORMAL
- en: We will be referring to these four conditions when we discuss individual test
    double types, so you may want to bookmark this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you want your method to call the payment gateway and execute a transaction
    while being unit tested? Do you want to call a third-party API that costs money
    while you are unit testing? Do you even want to go over the HTTP while you are
    testing? *Hint*: You don’t want, and you shouldn’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the different types of test doubles that can satisfy the four
    conditions mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Types of test doubles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are five major types of test doubles—each one is meant to satisfy one
    or more of the four requirements mentioned earlier. When unit testing, you may
    use zero or more types of test doubles to satisfy your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss dummies, stubs, mocks, and fakes. These four types of
    test doubles are commonly used with TDD. The fifth type is isolation, which is
    not used with TDD and is only mentioned here for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Dummies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ConvertCToF` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `ConvertCToF`, we have to instantiate a `WeatherForecastController`
    class. The constructor expects multiple objects to be passed in to instantiate
    the controller class: `logger`, `client`, `nowWrapper`, and `randomWrapper`. But
    the `ConvertCToF` is only using `_logger`. Also, we did not want to test the side
    effect of `_logger` as we are testing another behavior. For this reason, we decided
    to use a `NullLogger<>`. We can pass all dummies to our controller, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When `logger` is used, it does nothing, and the other `null` values are just
    passed to make the code compile. In this case, `logger` and the `null` values
    are acting as dummy test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating *intelligent* test doubles when dummies can be used can complicate
    and blur the intention of your unit test, so use dummies when you can.
  prefs: []
  type: TYPE_NORMAL
- en: Dummies satisfy the first and the second test double requirements that we’ve
    mentioned previously. They allow the code to compile and also create objects that
    do nothing when called.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GetReal()` method of the WFA controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are using `_client`, a dependency service, and calling `OneCallAsync` to
    retrieve the weather data from *OpenWeather*. This saves the results in the `res`
    object. `OneCallResponse` is not what we want to return to the `GetReal()` API
    consumer. Instead, we want to present the consumer with a simple output collection
    of the type `WeatherForecast[]`. For this reason, we have a mapping process that
    takes the data coming from `_client.OneCallAsync` and maps it to `WeatherForecast[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, the point that links the mapping process to *OpenWeather*
    is the `OneCallAsync` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The unit we need to test ](img/Figure_4.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The unit we need to test
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to swap the implementation of `OneCallAsync` with our own stubbed implementation
    to avoid calling the real RESTful API because the unit that we are testing is
    the mapping business logic. Luckily, we can swap the implementation using *polymorphism*.
    This can be done through implementing `IClient` ourselves by creating a concrete
    class called `ClientStub` and writing our own `OneCallAsync` method. Our final
    design looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Client and ClientStub implementing IClient ](img/Figure_4.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Client and ClientStub implementing IClient
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build our stub class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the following in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClientStub` implements `IClient`, and it should provide an implementation
    for `OneCallAsync` to satisfy the contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor allows the user of the class to provide the `DateTime` and the
    seven days temperature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OneCallAsync` method has a made-up, stubbed implementation that generates
    a `OneCallResponse` return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have written the class, we can put it into practice. There are
    several test criteria that we want to test. Here is the first test with the first
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are deciding what day it is. This is our way of freezing the
    day so that the test can execute anytime. We are also deciding what the weather
    is going to be for the next 7 days, starting from our made-up day. We need to
    do this to be able to instantiate `ClientStub` so that it can respond according
    to these values.
  prefs: []
  type: TYPE_NORMAL
- en: From the name of the test, which should be structured as `Method_Condition_Expectation`,
    we can figure out what we are trying to do in this test. The weather that we get
    in reality contains 7 days starting from today, but what we return in `WeatherForecast[]`
    is the forecast from the next day onward for the next 5 days. Therefore, we ignore
    today’s weather and use it nowhere.
  prefs: []
  type: TYPE_NORMAL
- en: The stub has shielded us from reaching to the real weather service and provided
    the canned values that we included in the `Arrange` section. If we were to call
    the real service, we would get unpredictable weather, from a test point of view,
    for unpredictable days (depending on when we run the test), which wouldn’t make
    us able to write our `Assert` criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test is not enough to have good coverage of all the criteria that should
    be tested. You can find more tests for the `GetReal` method using the `ClientStub`
    class in the source code for this chapter in the `WeatherForecastControllerTests`
    class. The tests are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to have a look at the companion code to familiarize yourself
    with other examples.
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Spies** are extra functionality added to a stub class to reveal what happened
    inside the stub. For example, consider this business requirement where we need
    to ensure that we are only passing metric temperature (degrees Celsius) requests
    to *OpenWeather*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to modify our stub to reveal what has been passed to `OneCallAsync`.
    The new code in the stub will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a property called `LastUnitSpy` to store the last requested unit
    and ended it with the `Spy` suffix as a convention. Our unit test will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in this test, we did not populate the forecast temperature with
    meaningful values and used default `DateTime`. This emphasized to future test
    readers (other developers reading the code) that we don’t care in this test for
    the variation of these parameters. We just wanted dummy objects to instantiate
    the `clientStub` object.
  prefs: []
  type: TYPE_NORMAL
- en: The last assert has validated receiving `Units.Metric`, which satisfies our
    business requirement.
  prefs: []
  type: TYPE_NORMAL
- en: You can add spies on-demand according to your tests and you can organize them
    in the way you like and hopefully, by now, the idea behind calling it *spy* makes
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of using stubs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using stubs is simple and leads to readable code. Not needing to learn any special
    stubbing framework is also an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with stubbing is that the more sophisticated your scenarios are,
    the more stub classes you need (`ClientStub2` and `ClientStub3`) or the cleverer
    your stub implementation needs to be. Your stub should contain minimal *cleverness*
    and business logic. In real-life scenarios, your stubs will be chunky and harder
    to maintain if you and your team are not careful about maintaining them.
  prefs: []
  type: TYPE_NORMAL
- en: Recap of the previous scenario
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have followed these steps to unit test the `GetReal()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: We realized that `_client` is a dependency used by our SUT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to isolate our `GetReal` method from calling the real OpenWeather, so
    we need to provide an alternative behavior for `_client`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_client` is an object of a class that implements the `IClient` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime, the SUT is instantiated by the start up class. `Client`, which is
    provided by a third-party library, is passed to SUT. This `Client`, which implements
    `IClient`, provides a means for retrieving the real weather data from *OpenWeather*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing should not extend the test to a third party and should restrict
    the test to the SUT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To bypass calling the real service, we stubbed a class and called it `ClientStub`,
    and implemented `IClient`. `ClientStub` contains an implementation to generate
    made-up weather data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We wrote our unit test following the unit test name convention and the AAA structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our SUT constructor requires an instance of `IClient`, so we passed `ClientStub`
    to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now test our SUT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubs satisfy the first three test double requirements of those we stated previously.
    Also, with the help of spies, they satisfy the fourth requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The same stubbing process is used for the rest of the unit tests for the GetReal
    method. Some teams use stubs as the main type of test doubles and other teams
    prefer to use mocks, which naturally leads us to our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Mocks** have great similarities with stubs, but rather than having the implementation
    of stubs done in regular coding, they use a *trick* to generate a behavior without
    having to implement a complete class. Mocks use third-party libraries to reduce
    the amount of coding involved to create a test double.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With mocks, you have to use a third-party library or build your own—heaven forbid.
    Two popular libraries for .NET are **Moq** (pronounced *mock you*) and **NSubstitute**.
  prefs: []
  type: TYPE_NORMAL
- en: Moq started gaining popularity in 2010\. It relies heavily on lambda expressions,
    which made it less verbose compared to its peers at that time. If you like lambda
    expressions, then Moq is for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSubstitute was also released near Moq time. Its focus is to provide a readable
    syntax for mocking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both libraries are mature in features and have a great online community. This
    book will use *NSubstitute*, but will also give you a quick introduction to Moq
    in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install NSubstitute, you can go to the unit test project directory and execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second line is optional. It adds the C# NSubstitute analyzers, which uses
    Roslyn to add code analysis during compilation to detect possible errors. Also,
    it adds the capability for VS to give you hints to improve your mocks code.
  prefs: []
  type: TYPE_NORMAL
- en: You now have the NSubstitute library installed and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Example using mocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Mocks and stubs can be used interchangeably, so a good way of understanding
    them is to start from our previous stub implementation. Let’s take the same example
    that we used in the stubs, which is testing `GetReal`. In that example, we used
    stubbing as our test double. Now, we use mocking, so we take the same test above
    and replace the `Arrange` part with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When using stubs, we coded an entire class so that we can instantiate it, as
    you can see in the commented line. In mocking the magical method from NSubstitute,
    `Substitute.For` created a concrete class from `IClient` and instantiated it all
    in one simple line.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the created object, `clientMock`, does not have any implementation
    for the `OneCallAsync`, so we have used NSubstitute methods to say: whichever
    parameter (`Is.Any<>`), that is passed to the `OneCallAsync` method, `Return`
    what is described in the provided lambda. The lambda content is the same content
    that was used in the `ClientStub` before.'
  prefs: []
  type: TYPE_NORMAL
- en: We have dynamically attached a method implementation to an object that we just
    created with a couple of lines of code. This is pretty impressive and has less
    code than its previous stub counterpart. Mocking libraries have the ability to
    create a concrete implementation of an abstraction and, in advanced scenarios,
    they can mock concrete classes and substitute part of their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you are using mocking, the `ClientStub` stubbing class that we
    used in the stubbing example is not needed. You only pick one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: I have created a test class called `WeatherForecastControllerTestsWithMocking`
    to differentiate from the one that uses a stub. In a real-life project, you wouldn’t
    do that as you will be typically using stubbing or mocking. This chapter and *Part
    2*, *Building an Application with TDD*, will have dozens of examples that use
    mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When it comes to mocking, we rarely use the term *spy* because the spy functionality
    is always embedded in the mocking framework. Spying in stubs is something you
    need to code, while for mocks, spying is built in. To illustrate this, it’s best
    to take the spying-with-a-stub example that we presented earlier and make it spying
    with mock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Arrange` and `Act` sections have not changed; we are only ignoring the
    output of the act stage. What has changed is our assertion. NSubstitute provides
    a method to spy on the passed parameters called `Received` and combines it with
    `Arg.Is` to verify what was passed.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first example where the `Assert` section does not use xUnit’s `Assert`
    class. This is perfectly legal, as the `Received()` method is an assertion method
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of using mocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mocks produce succinct code. They are slightly harder to read than plain code
    (code without a mocking library) if we compare them to stubs.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of mocks is that you depend on a library such as NSubstitute, and
    there is a learning curve associated with that. Also, some practitioners don’t
    like the magic that mock libraries employ to attach behavior dynamically and prefer
    to keep things more obvious by using plain code (stubs).
  prefs: []
  type: TYPE_NORMAL
- en: Next, I summarize the differences between mocks and stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks versus stubs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The difference between mocks and stubs is important, as you need to be armed
    with logic to choose the best technique to suit you. Here is a quick list of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Both mocks and stubs are categorized as test doubles, and you can use one or
    the other in your project based on the project requirements or the team preference,
    although in the industry, mocks are used more often than stubs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks are implemented with the help of a third-party library such as Moq or
    NSubstitute, while stubs do not rely on a library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks are less verbose than stubs, but their syntax is slightly harder to read
    than plain code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks are claimed to do some magic, which some practitioners believe corrupts
    the unit test, while stubs are plain code with no magic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The difference between mocks and stubs is a popular interview question. It is
    also important to expand on the answer and mention that both are test double types
    and are mainly used with unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Recap of the previous scenario
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To recap, we had the same scenario as of the stub, but when stubbing, we have
    added a class to contain our stub and used it in the unit test. In mocking, we
    have used a mocking framework that facilitated including our implementation within
    the body of the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks satisfy all test double requirements that we stated above. I hope the
    previous examples have given you a flavor of mocking. Next, we will explore another
    test double type.
  prefs: []
  type: TYPE_NORMAL
- en: Fakes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Fakes** are libraries that mimic part or all of a real-life equivalent, and
    they exist in order to facilitate testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *fake* has multiple definitions in the industry. This chapter is using
    the definition by Martin Fowler ([https://martinfowler.com/bliki/TestDouble.xhtml](https://martinfowler.com/bliki/TestDouble.xhtml)),
    as follows: “*Fake objects actually have working implementations, but usually
    take some shortcut which makes them not suitable for production (an InMemoryTestDatabase
    is a good example).*”'
  prefs: []
  type: TYPE_NORMAL
- en: One confusing name is a .NETframework called Microsoft Fakes that does isolation!
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular examples library called **FakeItEasy** that does mocks.
    Also, Microsoft has a framework called Microsoft Fakes that does isolation!
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most popular examples of a fake within the .NET library is *Entity
    Framework Core In-Memory Database Provider*. This is a quote from the Microsoft
    documentation ([https://docs.microsoft.com/en-us/ef/core/providers/in-memory](https://docs.microsoft.com/en-us/ef/core/providers/in-memory)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*This database provider allows Entity Framework Core to be used with an in-memory
    database. The in-memory database can be useful for testing, […]. The in-memory
    database is designed for testing only*.'
  prefs: []
  type: TYPE_NORMAL
- en: When storing in memory, it is easy to wipe and recreate the storage while executing
    every individual unit test. That helps in repeating the tests without worrying
    about the changed state of the data. Although, if the storage was persisted on
    disk, say with a real database (SQL Server, Cosmos, Mongo or others), then resetting
    the data before every test is not a simple task. The volatile nature of an in-memory
    database is suitable for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: If *Test A* changed a username from `JohnDoe` to `JohnSmith` and *Test B* tried
    to change `JohnDoe` to `JaneSmith`, *Test B* will definitely fail if the changes
    that *Test A* had done were permanent (persisted to a physical disk database).
    Using a volatile in-memory database can make resetting the data easier in between
    every test. This is an important unit test principle known as **No Interdependency**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fakes are meant to help provide an implementation of a complex system to try
    to make your unit tests more realistic. If you have a system that uses a relational
    database and relies on EF Core, then the previous provider might help when unit
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – In-memory storage versus production storage ](img/Figure_4.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – In-memory storage versus production storage
  prefs: []
  type: TYPE_NORMAL
- en: Fakes satisfy the first three test double requirements of those we stated earlier.
    If fakes were to embed spying behavior, they would satisfy the fourth requirement.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 2*, *Building an Application with TDD*, we will be using this provider
    and we will show the usage of fakes.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Isolation** is not something you do with TDD, but I have added a limited
    introduction here for completeness. Isolation bypasses traditional DI all together
    and uses a different technique for DI known as **shim**. Shim involves modifying
    compiled code behavior at runtime for injection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Owing to the complexity of the functionality of isolation frameworks, there
    aren’t many of them in .NET. Here are possibly the only two frameworks available
    for .NET **Core**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Fakes**: Available with the Enterprise version of Visual Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telerik JustMock**: A third-party commercial tool. It also has an open source
    restricted implementation called **JustMock Lite**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am unaware of a fully-featured isolation library that has a permissive, or
    free, license for .NET 5 and above.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation frameworks are primarily used to unit test legacy systems, where you
    cannot change the production code to support DI. Therefore, the isolation framework
    injects the dependencies into the SUT at runtime. The reason they are not used
    with TDD is that TDD is about adding tests while gradually *modifying* production
    code, but isolation is not meant to modify the production code. Despite the fact
    you can use isolation frameworks to unit test greenfield projects, they are not
    the best tools for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Although isolation frameworks exist to target legacy code, I don’t believe that
    applying unit tests to code that cannot change is the best use of a team’s time.
    I cover this in more detail in [*Chapter 12*](B18370_12.xhtml#_idTextAnchor279),
    *Dealing with Brownfield Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: What should I use for TDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the process of elimination. Isolation and isolation frameworks
    may not be used in the context of TDD as they are incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: Dummies can coexist with all types of test doubles. Using a `NullLogger<>` service
    where the logger is not used or passing null arguments is going to happen in most
    of your unit tests. So, use a dummy when you can; in fact, using dummies should
    take precedence over other types if this is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Teams usually use mocks or stubs, but not both unless the project is in a transitional
    state from one to the other. The debate of which one is better cannot be resolved
    in this book, it is all over the internet. However, given that stubs are harder
    to maintain and they need to be built up manually, mocks can do better as a start.
    Begin with mocks, get experienced, and then you can decide whether stubs can serve
    you better.
  prefs: []
  type: TYPE_NORMAL
- en: Finding appropriate fakes is a hit and miss. Sometimes, you can find a well-implemented
    fake such as the EF Core In-Memory Database Provider, and sometimes you might
    find an open source fake for some popular system. Sometimes, you may be unfortunate
    and have to create one yourself. But fakes are used in conjunction with mocks
    or stubs; as we will see in *Part 2* of the book, they are not one or the other.
    They add value to your tests, and you need to decide when to use them on a case-by-case
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: '*In summary, for any object that should not be part of the SUT or for an unused
    dependency, use a dummy. To build and test dependencies, use mocks. Add fakes
    where it makes sense.*'
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of stubs, mocks, and fakes will vary, and the definitions are muddled.
    I have tried to use the most common terminology in the industry. What is important
    is understanding all the test double options that we can use and using them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Test doubles are what make unit testing different from other categories. This
    can be clarified further when we discuss other testing categories to better understand
    the uniqueness of unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: More testing categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve probably heard about plenty of testing categories other than unit testing.
    There is **integration testing**, **regression testing**, **automation testing**,
    **load testing**, **pen testing**, **component testing**—and the list goes on.
    Well, we won’t cover all these test categories, as explaining them all will not
    fit in this book. What we will do instead is discuss the two categories that have
    commonalities with unit testing. The first one is **integration testing** and
    the second one is what I call **Sintegration testing**. We will also have an honorable
    mention of **acceptance testing** due to its importance in building a full test
    categories suite.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing, integration testing, and Sintegration testing have one major difference
    that sets them apart. It is how they deal with dependencies. Understanding the
    differences will help clarify how unit testing fits into the test ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration testing is, fortunately, easy to understand. It is exactly like
    a unit test, but with real dependencies, not with test doubles. An integration
    test executes an endpoint, such as a method or an API, which will trigger all
    the real dependencies, including external systems such as a DB and tests the outcome
    against a criterion.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The xUnit framework can also execute integration and Sintegration tests, so
    to show an example, we can create an integration test project in the same way
    we created a unit test project. From your console, go to your solution directory
    and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just created an integration test project using the *xUnit framework*
    and added it to our solution. Our integration test will be going over HTTP and
    will be deserializing the JSON values, so we will need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will add the .NET JSON NuGet package to your Integration test.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the integration test project is not referencing `Uqs.Weather`. This
    is because the integration test project will trigger the RESTful API through HTTP
    and does not need to use any type from `Uqs.Weather`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we want to test getting 5 days, starting from the next day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: On the class level, we add these fields. They specify the address of the service,
    which is pointing to my local machine, and also specify the URI of the SUT. By
    looking at the `WeatherForecast` class from `Uqs.Weather`, I know that I am getting
    back an array of `WeatherForecast` of five fields. So, I have constructed a similar
    record to the expected data that will come from the RESTful API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'My integration test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We don’t know on which day the test is going to execute, so we are fetching
    today’s date and then calculating the dates of the next 5 days. We are creating
    and setting up an `HttpClient` to issue an HTTP call.
  prefs: []
  type: TYPE_NORMAL
- en: In `Act`, we are calling the RESTful API’s endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In `Assert`, we are converting the returned value from JSON to the `record`
    class that we created earlier and checking that we are getting the next 5 days.
  prefs: []
  type: TYPE_NORMAL
- en: This test requires a different setup to run than the way we were running unit
    tests before. This is an out-of-process test, which means that the API is running
    on one process and the test is running on another process. The two processes are
    communicating with each other via HTTP. So, to run this test, we first need to
    initiate the REST API process. Right-click on **Uqs.Weather** | **Debug** | **Start
    Without Debugging**. Then this will launch Kestrel web server in a console window
    and make our API ready for an HTTP call.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can go ahead and execute the integration test in a similar fashion
    to executing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Activities triggered by this test
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The API call that we have just executed in our integration test triggered multiple
    dependencies to generate the output. These are a few of the triggered dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: The network, including the HTTPS connection, between the integration test and
    the ASP.NET Web API host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ASP.NET Web API host, which spun a process and displayed in a console window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routing code that analyzed the request and spun the right action method
    in the controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DI container that decided which object to create and inject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTPS connection between `Uqs.Weather` and the *OpenWeather* API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We know that each of these dependencies works on its own. By executing this
    test, we made sure that all our components are integrated and work well together.
    The following diagram shows a hint of what happened when we executed the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Request/response going through the dependencies ](img/Figure_4.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Request/response going through the dependencies
  prefs: []
  type: TYPE_NORMAL
- en: These are not all the components, as I have missed some, but hopefully, you’ve
    got the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Points to note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is our first integration test in this book (and the last one), and I would
    like to point out the differences between this test and its unit test equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not know the day in advance—we have to determine the date dynamically,
    while in our unit test, we had a pre-configured day in the `Assert` section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no test doubles, and everything is executing the real objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We had two processes running; one is the web server that hosts the API, and
    the other is our integration test. Unit tests were calling directly, in-process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a probability of failure that is not related to the test. The test
    could fail due to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall issues
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *OpenWeather* service is down
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceeding the number of calls permitted by our *OpenWeather* license
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Web server has not started
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The routing module is not configured properly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other environmental issues
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This test, while not measured, will take a longer time as it is communicating
    between two processes, hitting multiple components, and then going over HTTPS,
    which includes serialization/deserialization and encryption/decryption. Although
    the execution time is unnoticeable, having 10 seconds of integration tests will
    add up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing versus integration testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration tests and unit tests are great tools, and comparing them might imply
    using one over the other. This is not the case as both complement each other.
    Integration testing is good at testing a full cycle call, while unit testing is
    good at testing various scenarios of business logic. They have separate roles
    in quality assurance; the problem arises if they step on each other’s toes.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The difference between unit and integration testing is a common interview question
    that allows the interviewer to assess whether the candidate understands dependency
    management, test doubles, unit testing, and integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of integration tests over unit tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are the advantages that might lead us to use integration tests over unit
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests check the real behavior that mimics what the end client might
    do, while unit tests check what the developer thinks the system should do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests are easier to write and understand as they are regular code
    that doesn’t use test doubles and doesn’t care about DI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests can cover scenarios that unit tests cannot cover efficiently,
    such as the integration between the components of the whole system and DI container
    registration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests can be applied to legacy systems or greenfield systems. In
    fact, integration tests are one of the recommended ways to test legacy systems,
    while unit tests require code refactoring to be introduced into brownfield projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some integration tests, like the example above, can be written in a language-agnostic
    way. So, the previous test could have been written in F#, Java, or Python, or
    by a tool such as Postman, while unit tests use the same language as the production
    code (C#, in our case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of unit tests over integration tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some advantages that might lead us to use unit over integration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are much faster to execute, and this is very important when running
    hundreds of tests and looking for a short feedback loop, especially before integrating
    the code or releasing to an environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests have predictable results and are not affected by time, third-party
    service availability, or environmental intermittent issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are repeatable as they do not persist any data, while integration
    tests might change the data permanently, which may make subsequent tests unreliable.
    This happens when writing and editing. Our example above was reading (Getting),
    so it did not suffer from this problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are easier to deploy to CI/CD pipelines (we will demonstrate this
    in [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous
    Integration with GitHub Actions*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spotting bugs in unit tests is done sooner and can be pinpointed faster than
    finding the same bug in integration tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests can run during feature development, while an integration test can
    only be added when a feature is fully ready.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confusing unit and integration tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Frameworks such as xUnit or NUnit are used in various integration test implementations.
    The term *Unit* in the framework names might mislead some developers to think
    what is written in these projects is unit tests. Add to that using the *AAA convention*
    and the method name convention, and this might mislead as well. In fact, I used
    these conventions in the previous integration test, but using the same convention
    of a unit test does not make a test a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the infrastructure and building the CI pipeline will vary based on
    the type of test being implemented. Although they look the same, it is important
    to differentiate between them to understand the level of tasks and maintenance
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Given that they look the same, how do you spot one or the other? There is a
    telltale, if they are not relying on the real dependency, they are most likely
    to be unit tests. If they are using real objects that would trigger real external
    dependencies, chances are they are not unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Sintegration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Sintegration** test is a midway between integration testing and unit testing.
    Integration testing relies on real components, while unit testing relies on test
    doubles. Sintegration testing tries to solve the shortcomings of integration testing
    by mixing elements of unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Unit, Sintegration, and integration testing ](img/Figure_4.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Unit, Sintegration, and integration testing
  prefs: []
  type: TYPE_NORMAL
- en: 'I have found some developers referring to this type of test as a **component
    test**. But a component test, in software engineering, means something different,
    and I feel the developers were—rightly—more concerned about what it does than
    naming it correctly. This test category has these distinctive features, as outlined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Substitutes (swaps) some dependencies with their real counterpart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulates some real dependencies by building fakes (the fakes of test doubles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the *S* at the beginning of *s*ubstitute, *s*wap, and *s*imulate, and for
    its resemblance to integration tests, I gave it the name *Sintegration testing*.
    As always, let me clarify Sintegration tests with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s assume that we have a web project that uses logging, service bus queues,
    and Cosmos DB. The logging logs to the cloud, so it needs cloud connectivity.
    The queue is also a cloud component, and Cosmos DB is a cloud component as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also assume that we have a series of APIs to deal with the user profile,
    such as the `UpdateName` API and the `ChangePassword` API. A Sintegration test
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Kestrel web server and have the same features as per production, as
    Kestrel is flexible enough to run on-demand on local machines, test, and production
    environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing logs will require access to the cloud, so we inject a `NullLogger<>`
    service that will ignore logging but will let the system work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues are only available on the cloud, so we replaced this with a fake in-memory
    queue that can be easily wiped between tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cosmos DB does not have an in-memory implementation, but the cloud version can
    be easily wiped between test runs. So, we use the same .NET Cosmos DB client library,
    but we point to a different database—the Sintegration Tests Cosmos DB, at test
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a project component diagram of what the system would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Executing Sintegration tests ](img/Figure_4.6_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Executing Sintegration tests
  prefs: []
  type: TYPE_NORMAL
- en: The Sintegration tests in this scenario use fakes, dummies, and real components.
    They cover part of the integration in the system, on the other hand, the queues
    and DB can be easily wiped between individual tests to make sure no Sintegration
    test is affecting other tests.
  prefs: []
  type: TYPE_NORMAL
- en: Sintegration testing started gaining traction in recent years; perhaps the movement
    from the classical .NET Framework to .NET has surfaced this type of testing as
    .NET Core libraries are no longer dependent on specific Windows components, such
    as the IIS web server. Also, ASP.NET Core has specific implementations that allowed
    this type of testing, whereas, in the past, these implementations were not part
    of the framework. One of these implementations is having a Kestrel web server
    as part of .NET and being able to spin it easily without relying on a special
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This was a quick overview of Sintegration tests. While Sintegration tests are
    not part of TDD, they are important to understand as they are related to unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Acceptance testing** is the testing of a complete functionality or a feature
    end-to-end. One popular tool for acceptance tests that is used for websites is
    **Selenium**. You might find this category of testing under different names, such
    as **functional testing**, **system testing**, and **automated testing**.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A test that simulates a user’s action of updating their name, then pressing
    the **Update** button, and then checking whether the name is updated. This example
    tests a full workflow of different actions, probably in the same order that the
    user would trigger them.
  prefs: []
  type: TYPE_NORMAL
- en: Think of acceptance tests as multiple integration tests executing successively.
    These tests are fragile and slow, so they are better kept at a minimum. On the
    other hand, they are a necessity in a system as they cover areas not covered by
    unit tests and Sintegration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing test categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After reading about the three test types—namely, unit, Sintegration, and integration—and
    the additional acceptance tests, what tests should you write? The answer, surprisingly,
    is all four (if possible). However, integration tests can be omitted if both Sintegration
    and acceptance tests are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The testing triangle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is an industry concept known as the **testing triangle** that states
    the essential test categories to be implemented and the number of tests in each
    category. However, as with all software engineering concepts, the categories of
    the essential tests vary per triangle. Let’s look at the testing triangle for
    a greenfield project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Testing triangle ](img/Figure_4.7_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Testing triangle
  prefs: []
  type: TYPE_NORMAL
- en: The triangle in the preceding image advocates more unit tests than the other
    two testing categories. Assume you are experienced with the three mentioned tests.
    You will find that implementing unit tests takes the least amount of time compared
    to the other two and takes a few seconds to execute hundreds of them (after compiling
    and loading the code).
  prefs: []
  type: TYPE_NORMAL
- en: Discussing this triangle with respect to brownfield projects will be covered
    in [*Chapter 12*](B18370_12.xhtml#_idTextAnchor279), *Dealing with Brownfield
    Projects*. Hopefully, debating integration test and Sintegration test have helped
    you to better understand what a unit test is.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we compared unit tests with its siblings: *integration* and
    *Sintegration* *tests*. We listed test doubles and gave an example of each, and
    we have also seen xUnit and NSubstitute in action.'
  prefs: []
  type: TYPE_NORMAL
- en: Our journey with understanding unit testing and test doubles will not stop here,
    but we will cover more examples of the two topics across the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you can consider the experience from this chapter to take you to TDD
    level 3 out of 5! And now, you should be able to write a basic unit test that
    uses test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: We have not covered the advantages and disadvantages of unit testing—yes, it
    has disadvantages! We have also not covered how TDD relates to unit testing and
    the best practices of unit testing because this is the role of the next chapter,
    *Test-Driven Development Explained*.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Martin Fowler’s definition of test doubles*: [https://martinfowler.com/bliki/TestDouble.xhtml](https://martinfowler.com/bliki/TestDouble.xhtml%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NSubstitute*: [https://nsubstitute.github.io](https://nsubstitute.github.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
