- en: Chapter 1. New Features in C# 6.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 C# 6.0的新功能
- en: 'In this chapter, we will cover the following recipes with regard to the new
    features of C# 6.0:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下关于C# 6.0新功能的食谱：
- en: Creating your Visual Studio project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的Visual Studio项目
- en: String interpolation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串插值
- en: Null-conditional operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空条件运算符
- en: Initializers for auto-implemented properties and getter-only auto properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动实现属性和只读自动属性的初始化器
- en: Index initializers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引初始化器
- en: The `nameof` expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameof`表达式'
- en: Expression-bodied functions and properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式体函数和属性
- en: Using `static`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`static`
- en: Exception filters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: Using `await` operator in `catch` and `finally` blocks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`catch`和`finally`块中使用`await`运算符
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: C# as a programming language first appeared in 2000\. Its development team is
    led by the prominent Danish software engineer Anders Hejlsberg. He is the lead
    architect of C# and core developer of TypeScript. The C# programming language
    is simple to use, and this book will deal with C# 6.0, which was released on 20
    July, 2015.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C#作为一种编程语言首次出现在2000年。其开发团队由杰出的丹麦软件工程师Anders Hejlsberg领导。他是C#的首席架构师和TypeScript的核心开发者。C#编程语言易于使用，本书将涉及于2015年7月20日发布的C#
    6.0。
- en: Knowing what new language features are available in C# 6.0 will not only make
    you a more effective developer, but will also allow you to implement the latest
    and best practices in the software that you create. A little-known fact is that
    C# was actually called **C-like Object Oriented Language** (**Cool**) before its
    release at Microsoft's *Professional Developers Conference* in July 2000, but
    was changed to C# at the time of its release.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解C# 6.0中可用的新语言功能不仅会使您成为一个更有效的开发者，还允许您在您创建的软件中实施最新的最佳实践。一个鲜为人知的事实是，在2000年7月微软的**专业开发者大会**上发布之前，C#实际上被称为**C-like
    Object Oriented Language**（**酷**），但在发布时改名为C#。
- en: The name might have changed, but C# remains a very cool language to learn and
    use. This chapter will take you through the new features of C# 6.0 and illustrate
    how to effectively use these features in you daily programming tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 名称可能已经更改，但C#仍然是一种学习和使用起来非常酷的语言。本章将向您介绍C# 6.0的新功能，并说明如何有效地在日常编程任务中使用这些功能。
- en: Creating your Visual Studio project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的Visual Studio项目
- en: The Visual Studio project that you will create will be used to add the classes
    that contain the code samples in each recipe of this book. The project will be
    a simple console application that will call into static classes that do the work
    of illustrating the recipe code and outputting the results (if any) to the console
    window.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建的Visual Studio项目将用于添加包含每个食谱中代码示例的类。该项目将是一个简单的控制台应用程序，它将调用静态类来完成食谱代码的展示，并将结果（如果有）输出到控制台窗口。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through the recipes in this book, you will need a copy of Visual Studio
    2015\. If you do not have a copy of Visual Studio 2015, you can download a free
    copy of Visual Studio 2015 Community from [https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行本书中的食谱，您需要一个Visual Studio 2015的副本。如果您没有Visual Studio 2015的副本，您可以从[https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx)下载免费的Visual
    Studio 2015 Community版本。
- en: You can also compare editions of Visual Studio 2015 by navigating to [https://www.visualstudio.com/en-us/products/compare-visual-studio-2015-products-vs.aspx](https://www.visualstudio.com/en-us/products/compare-visual-studio-2015-products-vs.aspx).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过导航到[https://www.visualstudio.com/en-us/products/compare-visual-studio-2015-products-vs.aspx](https://www.visualstudio.com/en-us/products/compare-visual-studio-2015-products-vs.aspx)来比较Visual
    Studio 2015的版本。
- en: After you have downloaded and installed Visual Studio 2015, create a new console
    application that will contain the recipes illustrated in this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在您下载并安装Visual Studio 2015之后，创建一个新的控制台应用程序，该应用程序将包含本书中展示的食谱。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Start Visual Studio 2015 and click on the **File** menu. Then, click on **New**
    and then select **Project**. You can also use the *Ctrl* + *Shift* + *N* keyboard
    shortcut:![How to do it…](img/B05391_01_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015并点击**文件**菜单。然后，点击**新建**然后选择**项目**。您也可以使用*Ctrl* + *Shift*
    + *N*键盘快捷键：![如何做…](img/B05391_01_01.jpg)
- en: From the **New** **Project** dialog screen, select **Console Application**,
    which can be found by going to **Installed** | **Templates** | **Visual C#** |
    **Windows** | **Classic Desktop** in the tree view to the left. You can call your
    console application `CodeSamples`:![How to do it…](img/B05391_01_02.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建项目**对话框屏幕上，选择**控制台应用程序**，您可以通过在左侧的树视图中导航到**已安装** | **模板** | **Visual C#**
    | **Windows** | **经典桌面**来找到它。您可以将您的控制台应用程序命名为`CodeSamples`：![如何操作…](img/B05391_01_02.jpg)
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that the selected framework is **.NET Framework 4.6.1**, which
    is selected by default. Leave this framework selected when creating your project.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到选定的框架是 **.NET Framework 4.6.1**，这是默认选择的。在创建项目时，请保留此框架的选择。
- en: Visual Studio now creates your console application, which we will use to create
    all the code samples needed for this book.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 现在将创建您的控制台应用程序，我们将使用它来创建本书所需的所有代码示例。
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This console application will form the base of the recipes in this book. Each
    recipe can be individually added to this console application. A recipe, therefore,
    can function on its own without the need to create a previous recipe. You can
    also easily separate any custom code you might want to add and experiment with.
    It is also recommended that you play around with the code by adding classes of
    your own.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制台应用程序将构成本书中食谱的基础。每个食谱都可以单独添加到这个控制台应用程序中。因此，一个食谱可以独立运行，无需创建先前的食谱。您还可以轻松地分离您可能想要添加和实验的任何自定义代码。还建议您通过添加自己的类来与代码进行交互。
- en: String interpolation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值
- en: String interpolation is a very easy and precise way to inject variable values
    into a string. An interpolated string expression looks at contained expressions.
    It then replaces those expressions with the `ToString` representations of the
    expressions' results.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值是一种非常简单且精确的方法，可以将变量值注入到字符串中。一个插值字符串表达式会查看包含的表达式。然后，它将这些表达式替换为表达式的结果的 `ToString`
    表示形式。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new class to test your code. We will use the example of reading the
    current exchange rate for a specific currency to illustrate how string interpolation
    can be used to output strings to the user interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类来测试您的代码。我们将使用读取特定货币当前汇率的示例来说明如何使用字符串插值将字符串输出到用户界面。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a new class by right-clicking on your solution, selecting **Add,** and
    then selecting **New Project** from the context menu:![How to do it…](img/B05391_01_03.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在解决方案上右键单击，选择**添加**，然后从上下文菜单中选择**新建项目**来创建一个新的类：![如何操作…](img/B05391_01_03.jpg)
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter1`:![How to do it…](img/B05391_01_04.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**添加新项目**对话框屏幕中选择**类库**从已安装模板，并将您的类命名为 `Chapter1`：![如何操作…](img/B05391_01_04.jpg)
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which I renamed to `Recipes.cs` in order to distinguish the code
    properly. You can, however, rename your class to whatever you like if that makes
    more sense to you.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的新类库将以默认名称 `Class1.cs` 添加到您的解决方案中，我将它重命名为 `Recipes.cs` 以便正确区分代码。但是，如果您觉得这样更有意义，您可以将类重命名为您喜欢的任何名称。
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_01_05.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名您的类，只需在**解决方案资源管理器**中单击类名，然后从上下文菜单中选择**重命名**：![如何操作…](img/B05391_01_05.jpg)
- en: Visual Studio will ask you to confirm a rename of all references to the **Class1**
    code element in the project. Just click on **Yes**:![How to do it…](img/B05391_01_06.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将要求您确认重命名项目中所有对 **Class1** 代码元素的引用。只需单击**是**：![如何操作…](img/B05391_01_06.jpg)
- en: 'The class that is created now needs to be made static using the `static` keyword.
    Also, rename the class name in code to `Recipe1StringInterpolation`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建的类需要使用 `static` 关键字使其成为静态的。同时，将代码中的类名重命名为 `Recipe1StringInterpolation`：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that static classes, therefore, do not need to be instantiated and will
    be sealed classes by default. This means that they cannot be inherited further.
    In practice, you would normally define helper or utility classes as static. These
    are classes that will be used often by your application to, for example, parse
    dates or perform calculations. The use of the `static` keyword here is simply
    to illustrate the specific new features of C# 6.0 within a class that can easily
    and quickly be called from the console application. The static class in reality
    would most likely not be a good fit for all the examples illustrated.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，因此静态类不需要实例化，并且默认情况下将是密封类。这意味着它们不能进一步继承。在实践中，你通常会定义辅助或实用类为静态。这些类将经常被你的应用程序使用，例如解析日期或执行计算。这里使用
    `static` 关键字只是为了在一个可以轻松快速从控制台应用程序中调用的类中说明 C# 6.0 的特定新功能。实际上，静态类可能不适合所有示例。
- en: 'Inside your class, add a property to contain the base currency:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的类中，添加一个属性来包含基础货币：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, include a dummy method to return the exchange rate:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包括一个返回汇率的方法：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last method to add is the method that will return the interpolated string
    expression:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要添加的方法是返回插值字符串表达式的那个方法：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You now need to hook up the class you created to your console application. You
    therefore need to add a reference to the class from the console application. Right-click
    on **References** in your `CodeSamples` project and select **Add Reference…**:![How
    to do it…](img/B05391_01_07.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要将你创建的类连接到你的控制台应用程序。因此，你需要从控制台应用程序中添加对类的引用。在你的 `CodeSamples` 项目中，右键单击 **引用**
    并选择 **添加引用…**：![如何操作…](img/B05391_01_07.jpg)
- en: From the **Reference** **Manager** dialog that pops up, select the `Chapter1`
    solution to add it as a reference. Then, click on the **OK** button:![How to do
    it…](img/B05391_01_08.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的 **参考** **管理器** 对话框中选择 `Chapter1` 解决方案以将其添加为参考。然后，点击 **确定** 按钮：![如何操作…](img/B05391_01_08.jpg)
- en: 'In your `CodeSamples` project, double-click on the `Program.cs` file and add
    the following code to the `Main` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `CodeSamples` 项目中，双击 `Program.cs` 文件，并将以下代码添加到 `Main` 方法中：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To see the result, run your application and see the output in the console application:![How
    to do it…](img/B05391_01_09.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看结果，运行你的应用程序并查看控制台应用程序的输出：![如何操作…](img/B05391_01_09.jpg)
- en: The interpolated string expression is output as `1 USD = 16,3040 ZAR`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插值字符串表达式输出为 `1 USD = 16,3040 ZAR`。
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The console application passes the currency codes for South African Rand and
    US Dollar to the static class by calling the following line of code: `Chapter1.Recipe1StringInterpolation.ReadExchangeRate("ZAR",
    "USD");`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序通过调用以下代码行将南非兰特和美元的货币代码传递给静态类：`Chapter1.Recipe1StringInterpolation.ReadExchangeRate("ZAR",
    "USD");`
- en: This class is static and, as mentioned previously, does not need to be instantiated.
    The `ReadExchangeRate` method then reads the exchange rate and formats it into
    a suitable string using string interpolation. You will notice that the interpolated
    string expression is written as `$"1 {toCurrencyCode} = {conversion} {fromCurrencyCode}
    ";`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是静态的，正如之前提到的，不需要实例化。然后 `ReadExchangeRate` 方法读取汇率并将其格式化为合适的字符串，使用字符串插值。你会注意到插值字符串表达式被写成
    `$"1 {toCurrencyCode} = {conversion} {fromCurrencyCode} ";`。
- en: The `toCurrencyCode`, `conversion`, and `fromCurrencyCode` variables are expressed
    directly inside the string expression. This is a much easier way of formatting
    strings because you can do away with `String.Format`, used in the previous versions
    of C#. Previously, the same expression would have been written as `String.Format("1
    {0} = {1} {2} ", toCurrencyCode, conversion, fromCurrencyCode);`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`toCurrencyCode`、`conversion` 和 `fromCurrencyCode` 变量直接在字符串表达式中表示。这是一个格式化字符串的更简单方法，因为你可以不用
    `String.Format`（在 C# 的早期版本中使用），同样的表达式将被写成 `String.Format("1 {0} = {1} {2} ", toCurrencyCode,
    conversion, fromCurrencyCode);`。'
- en: As you can see, the interpolated string expression is much easier to read and
    write. In reality though, string interpolation is merely syntactical sugar because
    the compiler treats the expression like `String.Format` anyway. You might be wondering
    how you would express a curly bracket when using string interpolation. To do this,
    you can simply use a double curly bracket in your expression. If you need to express
    the exchange rate as `{16,3040}`, you would need to express it as `$"{{{conversion}}}";`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，插值字符串表达式更容易阅读和编写。然而，实际上，字符串插值仅仅是语法糖，因为编译器仍然将表达式视为 `String.Format`。你可能想知道在使用字符串插值时如何表示花括号。为此，你可以在表达式中简单地使用双花括号。如果你需要将汇率表示为
    `{16,3040}`，你需要将其表示为 `$"{{{conversion}}}";`。
- en: 'You can also format your string right there inside the interpolated string
    expression. If you returned the `$"The date is {DateTime.Now}";` expression, the
    output would be `The date is 2016/01/10 3:04:48 PM`. You can go ahead and modify
    the expression to format the date using a colon, followed by the format to use.
    Change the code to `$"The date is {DateTime.Now : MMMM dd, yyyy}";`. The output
    will be formatted and result in `The date is January 5, 2016`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以在插值字符串表达式中直接格式化字符串。如果你返回 `$"The date is {DateTime.Now}";` 表达式，输出将是 `The
    date is 2016/01/10 3:04:48 PM`。你可以继续修改表达式，使用冒号后跟的格式来格式化日期。将代码更改为 `$"The date is
    {DateTime.Now : MMMM dd, yyyy}";`。输出将被格式化，并产生 `The date is January 5, 2016`。'
- en: 'Another great tip is that you can express a condition in the string expression.
    Consider the following line of code that determines whether a year is a leap year
    or not:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的技巧是，你可以在字符串表达式中表达一个条件。考虑以下代码行，它确定一个年份是否是闰年：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use the ternary `?` operator one step further. Consider the following
    line of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将三元 `?` 操作符进一步使用。考虑以下代码行：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the colon is used to denote formatting, we have to wrap the conditional part
    of the expression in parenthesis. String interpolation is a very nice way to express
    strings in code that is easy to read and understand.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于冒号用于表示格式化，我们必须将表达式的条件部分用括号括起来。字符串插值是表达代码中易于阅读和理解的字符串的一种非常好的方式。
- en: Null-conditional operator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空条件操作符
- en: The worst thing that a developer can do is not check for null in code. This
    means that there is no reference to an object, in other words, there is a null.
    Reference-type variables have a default value of null. Value types, on the other
    hand, cannot be null. In C# 2, developers were introduced to the nullable type.
    To effectively make sure that objects are not null, developers usually write sometimes
    elaborate `if` statements to check whether objects are null or not. C# 6.0 made
    this process very easy with the introduction of the null-conditional operator.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者能做的最糟糕的事情就是在代码中不检查 null。这意味着没有对象的引用，换句话说，存在一个 null。引用类型变量有一个默认值 null。另一方面，值类型不能为
    null。在 C# 2 中，开发者被引入了可空类型。为了确保对象不是 null，开发者通常编写一些复杂的 `if` 语句来检查对象是否为 null。C# 6.0
    通过引入空条件操作符使这个过程变得非常简单。
- en: It is expressed by writing `?.` and is called the question-dot operator. The
    question is written after the instance, right before calling the property via
    the dot. An easy way to think of the null-conditional operator is to remember
    that if the left-hand side of the operator is null, the whole expression is null.
    If the left-hand side is not null, the property is invoked and becomes the result
    of the operation. To really see the power of the null-conditional operator is
    to see it in action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过写入 `?.` 来表示，被称为问号点操作符。问号紧跟在实例之后，在通过点调用属性之前书写。可以这样理解空条件操作符：如果操作符的左侧是 null，整个表达式就是
    null。如果左侧不是 null，则调用属性并成为操作的结果。真正看到空条件操作符的强大之处，就是看到它在实际中的应用。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create another class that will illustrate the use of the null-conditional
    operator. The method will call a `Student` class to return a count of students
    in the resulting list. We will check to see whether the `Student` class is valid
    before returning the student count.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个类来展示空条件操作符的使用。该方法将调用 `Student` 类来返回结果列表中的学生数量。在返回学生数量之前，我们将检查 `Student`
    类是否有效。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create another class called `Recipe2NullConditionalOperator` beneath the last
    class you wrote in the *Creating your Visual Studio project* recipe:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *创建你的 Visual Studio 项目* 菜单中，在最后一个你编写的类下面创建另一个名为 `Recipe2NullConditionalOperator`
    的类：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a method called `GetStudents` to the class and add the following code to
    it:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`GetStudents`的方法添加到类中，并向其中添加以下代码：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add a third class to your code called `Student` with the following properties:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向你的代码中添加一个名为`Student`的第三个类，具有以下属性：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `Student` class will be the object we will call from our `GetStudents`
    method. In the `Program.cs` file, add the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Student`类将是我们在`GetStudents`方法中调用的对象。在`Program.cs`文件中，添加以下代码：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the console application will result in the application telling us that
    there are two students contained in the list. This is expected, because we added
    two `Student` objects to our `List<Student>` class:![How to do it…](img/B05391_01_10.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会导致应用程序告诉我们列表中有两个学生。这是预期的，因为我们向我们的`List<Student>`类中添加了两个`Student`对象：![如何做到这一点…](img/B05391_01_10.jpg)
- en: 'To see the null-conditional operator in action, modify the code in your `GetStudents`
    method to set the `students` variable to null. Your code should look like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看空条件运算符的实际应用，修改你的`GetStudents`方法中的代码，将`students`变量设置为空。你的代码应该看起来像这样：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the console application again, and see how the output has changed:![How
    to do it…](img/B05391_01_11.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序，看看输出是如何变化的：![如何做到这一点…](img/B05391_01_11.jpg)
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Consider the code we used in the `return` statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在`return`语句中使用的代码：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We told the compiler to check whether the `List<Student>` class' variable `students`
    is null. We did this by adding `?` after the `students` object. If the `students`
    object is not null, we use the dot operator, and the `Count()` property becomes
    the result of the statement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉编译器检查`List<Student>`类的变量`students`是否为空。我们通过在`students`对象后添加`?`来实现这一点。如果`students`对象不为空，我们使用点运算符，`Count()`属性成为语句的结果。
- en: If the `students` object however is null, then we return zero. This way of checking
    for null makes all that `if(students != null)` code unnecessary. The null check
    sort of fades into the background and makes it much easier to express and read
    null checks (not to mention less code).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`students`对象为空，则返回零。这种方式检查空值使得所有`if(students != null)`代码都变得不必要。空值检查似乎淡入背景，使得表达和阅读空值检查变得更容易（更不用说代码更少了）。
- en: 'If we had to change the `return` statement to a regular `Count()` method without
    the null-conditional operator, we would see an `ArgumentNullException was unhandled`
    error:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须将`return`语句更改为没有空条件运算符的常规`Count()`方法，我们会看到一个`ArgumentNullException was
    unhandled`错误：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calling `Count()` on the `students` object without using the null-conditional
    operator breaks the code. The null-conditional operator is an exciting addition
    to the C# language because it makes writing code to check for null a lot easier.
    Less code is better code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`students`对象上调用`Count()`而不使用空条件运算符会破坏代码。空条件运算符是C#语言的激动人心的补充，因为它使得编写检查空值的代码变得更加容易。代码越少，代码质量越好。
- en: Initializers for auto-implemented properties and getter-only auto properties
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动实现的属性和只读自动属性的初始化器
- en: The release of C# 6.0 saw two enhancements made to auto-implemented properties.
    You can now initialize auto-implemented properties inline, and you can also define
    them without a setter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0的发布为自动实现的属性带来了两项增强。你现在可以内联初始化自动实现的属性，也可以定义它们而不需要设置器。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To illustrate how to implement these two new enhancements to auto-implemented
    properties, we will create another class that calculates the sales price after
    discount for a given barcode and discount type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何实现这两个新的自动实现属性增强，我们将创建另一个类，该类计算给定条形码和折扣类型的折扣后的销售价格。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Start off by creating a static class called `Recipe3AutoImplementedProperties`
    and add the `DiscountType` enumerator to the class, along with the auto-implemented
    properties. You will then initialize those auto-implemented properties with default
    values:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Recipe3AutoImplementedProperties`的静态类，并将`DiscountType`枚举器添加到该类中，以及自动实现的属性。然后，将这些自动实现的属性初始化为默认值：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to add the method to calculate the sales price of an item
    linked to the barcode supplied to the method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一个方法来计算与提供给方法的条形码相关联的商品的销售价格：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to simulate a database lookup to find the selling price of a barcode,
    create another method to return a price for a given barcode:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟数据库查找以找到条形码的销售价格，创建另一个方法来返回给定条形码的价格：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we will create an extension method class to calculate the sale price
    after the discount has been applied:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个扩展方法类来计算折扣后适用的销售价格：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Extension methods are static methods by default and allow you to extend your
    code's functionality (extend existing types) without having to modify the original
    type. You can now have an extension methods class in your solution where you add
    helpful code. A nice example of using an extension method is to calculate the
    financial year for a given date. Extension methods are differentiated from other
    static methods using the `this` keyword in the method signature. In the preceding
    example, the compiler knows that this is an extension method for the decimal class
    by looking at the type it extends.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展方法默认是静态方法，允许你扩展你代码的功能（扩展现有类型）而无需修改原始类型。你现在可以在你的解决方案中有一个扩展方法类，在那里你可以添加有用的代码。使用扩展方法的一个好例子是计算给定日期的财政年度。扩展方法与其他静态方法的不同之处在于方法签名中使用
    `this` 关键字。在前面的例子中，编译器通过查看它扩展的类型知道这是一个为 decimal 类提供的扩展方法。
- en: 'Replace the code of your `Progam.cs` file and run the program:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换你的 `Program.cs` 文件中的代码并运行程序：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The sales price is calculated after applying the sale discount and returned
    to the console application:![How to do it…](img/B05391_01_12.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用折扣后，销售价格被计算并返回到控制台应用程序：![如何操作…](img/B05391_01_12.jpg)
- en: How it works…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: If you look at the auto-implemented properties again, you would notice that
    we have two getter-only auto-implemented properties. All four auto-implemented
    properties have been initialized with default values. The `SaleDiscountPercent`
    and `ClearoutDiscountPercent` properties are read-only. This ensures that the
    discount values can't be modified in any way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看自动实现的属性，你会注意到我们有两个只读自动实现的属性。所有四个自动实现的属性都已使用默认值初始化。`SaleDiscountPercent`
    和 `ClearoutDiscountPercent` 属性是只读的。这确保了折扣值不能以任何方式修改。
- en: You will also notice that if the shelf price returned from the `GetPriceFromBarcode`
    method is zero, then the default `ShelfPrice` property value is used in determining
    the discount price. If no discount is applied, the `CalculateSalePrice` method
    simply returns the barcode price. If no price is determined from the barcode,
    the default `ShelfPrice` property value is returned.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，如果从 `GetPriceFromBarcode` 方法返回的货架价格是零，那么在确定折扣价格时将使用默认的 `ShelfPrice` 属性值。如果没有应用折扣，`CalculateSalePrice`
    方法将直接返回条形码价格。如果没有从条形码中确定价格，则返回默认的 `ShelfPrice` 属性值。
- en: Auto-implemented property initializers and getter-only auto-implemented properties
    are great to cut down on unnecessary `if` `else` statements. It also makes the
    code implementing the properties more readable because the intent can be contained
    in the property itself by initializing it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自动实现的属性初始化器和只读自动实现的属性可以大大减少不必要的 `if` `else` 语句。它还使实现属性的代码更易于阅读，因为意图可以通过初始化属性本身来包含。
- en: 'Look at what happens if we try to set the `SaleDiscountPercent` or `ClearoutDiscountPercent`
    property to a different value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如果我们尝试将 `SaleDiscountPercent` 或 `ClearoutDiscountPercent` 属性设置为不同的值会发生什么：
- en: '![How it works…](img/B05391_01_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_13.jpg)'
- en: Visual Studio will emit an error for the getter-only properties because using
    the `get` keyword, we can only read from this property, not assign a value to
    it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 将为只读属性发出错误，因为我们只能使用 `get` 关键字从这个属性中读取，而不能为其赋值。
- en: Index initializers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引初始化器
- en: You need to remember that C# 6.0 does not introduce big new concepts, but small
    features designed to make your code cleaner and easier to read and understand.
    With index initializers, this is not an exception. You can now initialize the
    indices of newly created objects. This means you do not have to use separate statements
    to initialize the indexes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住，C# 6.0 并没有引入大的新概念，而是引入了一些旨在使你的代码更简洁、更易于阅读和理解的小特性。使用索引初始化器，这也不例外。你现在可以初始化新创建对象的索引。这意味着你不需要使用单独的语句来初始化索引。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The change here is subtle. We will create a method to return the day of the
    week based on an integer. We will also create a method to return the start of
    the financial year and salary increase month, and then set the salary increase
    month to a different value than the default. Finally we will use properties to
    return a specific type of species to the console window.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化很微妙。我们将创建一个方法来根据整数返回星期几。我们还将创建一个方法来返回财务年度的开始月份和薪资增长月份，然后设置薪资增长月份为一个不同于默认值的值。最后，我们将使用属性将特定类型的物种返回到控制台窗口。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Start off by creating a new class called `Recipe4IndexInitializers` and add
    a second class called `Month` to your code. The `Month` class simply contains
    two auto-implemented properties that have been initialized. `StartFinancialYearMonth`
    has been set to month two (February), and `SalaryIncreaseMonth` has been set to
    month three (March):'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `Recipe4IndexInitializers` 的新类，并将第二个名为 `Month` 的类添加到您的代码中。`Month`
    类仅包含两个已初始化的自动实现属性。`StartFinancialYearMonth` 已设置为二月（2月），而 `SalaryIncreaseMonth`
    已设置为三月（3月）：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Go ahead and add a method called `ReturnWeekDay` that takes an integer for
    the day number as a parameter, to the `Recipe4IndexInitializers` class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续添加一个名为 `ReturnWeekDay` 的方法，该方法接受一个整数作为参数，用于表示天数，到 `Recipe4IndexInitializers`
    类中：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the second example, add a method called `ReturnFinancialAndBonusMonth`
    to the `Recipe4IndexInitializers` class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个示例，将一个名为 `ReturnFinancialAndBonusMonth` 的方法添加到 `Recipe4IndexInitializers`
    类中：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, add several auto-implemented properties to the class to contain species
    and a method called `DetermineSpecies` to the `Recipe4IndexInitializers` class.
    Your code should look like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向类中添加几个自动实现的属性以包含物种，并在 `Recipe4IndexInitializers` 类中添加一个名为 `DetermineSpecies`
    的方法。您的代码应如下所示：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In your console application, add the following code to call the code in the
    `Recipe4IndexInitializers` class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的控制台应用程序中，添加以下代码以调用 `Recipe4IndexInitializers` 类中的代码：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you have added all your code, run your application. The output will look
    like this:![How to do it…](img/B05391_01_14.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了所有代码，运行你的应用程序。输出将如下所示：![如何操作…](img/B05391_01_14.jpg)
- en: How it works…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first method `ReturnWeekDay` created a `Dictionary<int, string>` object.
    You can see how the indices are initialized with the day names. If we now pass
    the day integer to the method, we can return the day name by referencing the index.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法 `ReturnWeekDay` 创建了一个 `Dictionary<int, string>` 对象。您可以看到索引是如何用星期名称初始化的。如果我们现在将天数整数传递给该方法，我们可以通过引用索引来返回星期名称。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason for not using a zero-based index in `ReturnWeekDay` is because the
    first day of the week is associated to the numerical value 1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReturnWeekDay` 中不使用零基索引的原因是因为一周的第一天与数值 1 相关联。
- en: 'In the second example, we called a method called `ReturnFinancialAndBonusMonth`
    that creates an array to hold the financial year start month and the salary increase
    month. Both properties of the `Month` class are initialized to `2` and `3`, respectively.
    You can see that we are overriding the value of the `SalaryIncreaseMonth` property
    and setting it to `2`. It is done in the following line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们调用了一个名为 `ReturnFinancialAndBonusMonth` 的方法，该方法创建一个数组来存储财务年度开始月份和薪资增长月份。`Month`
    类的两个属性分别初始化为 `2` 和 `3`。您可以看到，我们正在覆盖 `SalaryIncreaseMonth` 属性的值并将其设置为 `2`。这是在以下代码行中完成的：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last example uses the `Human`, `Rabbit`, `Sloth`, `Mouse`, `Hedgehog`, `Dolphin`,
    and `Dog` properties to return the correct index value of the `Species` object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例使用 `Human`、`Rabbit`、`Sloth`、`Mouse`、`Hedgehog`、`Dolphin` 和 `Dog` 属性来返回
    `Species` 对象的正确索引值。
- en: The nameof expressions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`nameof` 表达式'
- en: The `nameof` expressions are particularly nice. You can now provide a string
    that names an object in code. This is especially handy if you are throwing exceptions.
    You can now see which variable caused the exception. In the past, developers had
    to rely on messy string literals in their code. This was particularly error prone
    and vulnerable to spelling errors. Another problem was that any code refactoring
    might miss a string literal, and then that code becomes obsolete and broken.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof` 表达式特别有用。现在您可以为代码中命名的对象提供一个字符串。如果您正在抛出异常，这尤其方便。现在您可以看到哪个变量引发了异常。在过去，开发者必须依赖于代码中的混乱字符串字面量。这特别容易出错，并且容易受到拼写错误的影响。另一个问题是，任何代码重构都可能错过一个字符串字面量，然后该代码就变得过时并损坏。'
- en: The `nameof` expressions have come to save the day. The compiler will see that
    you are referencing the name of a specific variable and correctly convert it to
    a string. `nameof` expressions, therefore, also stay in sync with any refactoring
    you may do.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof` 表达式已经拯救了我们的困境。编译器会看到你正在引用特定变量的名称，并将其正确地转换为字符串。因此，`nameof` 表达式也与任何你可能进行的重构保持同步。'
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the same code example that we wrote in the *String interpolation*
    recipe from this chapter, with a few small changes. We will create a `Student`
    object and add students to it. We will then return that object to the console
    and output the student count.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章中 *字符串插值* 菜单中编写的相同代码示例，并进行一些小的修改。我们将创建一个 `Student` 对象并向其中添加学生。然后，我们将该对象返回到控制台并输出学生数量。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a class called `Recipe5NameofExpression`. Add an auto-implemented property
    to this class called `StudentCount`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Recipe5NameofExpression` 的类。向该类添加一个名为 `StudentCount` 的自动实现属性：
- en: '[PRE25]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we need to add the `GetStudents` method, which returns a `List<Student>`
    object. The method contains a `try`/`catch` statement and will throw `ArgumentNullException()`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个名为 `GetStudents` 的方法，该方法返回一个 `List<Student>` 对象。该方法包含一个 `try`/`catch`
    语句，并将抛出 `ArgumentNullException()`：
- en: '[PRE26]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, we would not simply return `ArgumentNullException` off the bat like
    that. This is simply being used to illustrate the concept of the `nameof` expression
    as used in `ArgumentNullException`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，我们不会立即简单地返回 `ArgumentNullException`。这只是为了说明在 `ArgumentNullException` 中使用
    `nameof` 表达式的概念。
- en: 'In the console application, we will add code that returns the `List<Student>`
    object and reports how many students were contained in the list by outputting
    the `StudentCount` property value to the console window:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，我们将添加代码以返回 `List<Student>` 对象，并通过将 `StudentCount` 属性值输出到控制台窗口来报告列表中包含的学生数量：
- en: '[PRE27]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Running the console application with the code as is will call the `GetStudents()`
    method. This will then create the `List<Student>` object and add two `Student`
    objects to it. The `StudentCount` property is set equal to the count of the `List<Student>`
    object. The `GetStudents()` method then returns the result to the console application,
    which then reads the `StudentCount` property and displays it in the console output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以当前代码运行控制台应用程序将调用 `GetStudents()` 方法。这将创建一个 `List<Student>` 对象，并向其中添加两个 `Student`
    对象。`StudentCount` 属性设置为 `List<Student>` 对象的计数。然后 `GetStudents()` 方法将结果返回到控制台应用程序，该应用程序读取
    `StudentCount` 属性并在控制台输出中显示它：
- en: '![How it works…](img/B05391_01_15.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B05391_01_15.jpg)'
- en: 'If we now went ahead and modified the code in the `GetStudents()` method to
    set the `students` variable to `null` right before we called `students.Count()`,
    an exception would be thrown. The exception is caught in `catch`, and this is
    where we use the `nameof` expression to display a string literal of the `students`
    variable:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在修改 `GetStudents()` 方法中的代码，在调用 `students.Count()` 之前将 `students` 变量设置为
    `null`，将会抛出异常。异常在 `catch` 中被捕获，这就是我们使用 `nameof` 表达式来显示 `students` 变量的字符串字面量的地方：
- en: '![How it works…](img/B05391_01_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B05391_01_16.jpg)'
- en: 'Using the `nameof` expression, we can ensure that the expression stays in sync
    with refactoring actions such as renaming the `students` variable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `nameof` 表达式，我们可以确保表达式与重构操作（如重命名 `students` 变量）保持同步：
- en: '![How it works…](img/B05391_01_17.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B05391_01_17.jpg)'
- en: If we had written the code in the `catch` statement using a string literal,
    we would not have had the code updated automatically when we renamed the `students`
    variable. The `nameof` expression effectively allowed developers to stop writing
    `throw new ArgumentNullException("students");`, which will not be affected by
    refactoring actions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `catch` 语句中使用字符串字面量编写代码，那么当我们重命名 `students` 变量时，代码不会自动更新。`nameof` 表达式有效地允许开发者停止编写
    `throw new ArgumentNullException("students");`，这将不会受到重构操作的影响。
- en: Another benefit of using a `nameof` expression in your code is that it involves
    no runtime cost, because the code containing the string literal is generated at
    compile time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用 `nameof` 表达式的好处之一是它不涉及任何运行时成本，因为包含字符串字面量的代码是在编译时生成的。
- en: 'Modify the code in the console application slightly to make it look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微修改控制台应用程序中的代码，使其看起来像这样：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you run your console application now, you can see that the `nameof` expression
    has been used to create the string literal of the `StudentCount` property:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行你的控制台应用程序时，你可以看到已经使用了 `nameof` 表达式来创建 `StudentCount` 属性的字符串字面量：
- en: '![How it works…](img/B05391_01_18.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_18.jpg)'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ensure that you have commented out the `students = null`; line of code in the
    `GetStudents()` method; otherwise, you will still receive the null exception.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在 `GetStudents()` 方法中注释掉了 `students = null;` 这行代码；否则，你仍然会收到空异常。
- en: 'You can also use the `nameof` expression with enumerators. Add the following
    code to your class. We are basically creating an enumerator called `Course`. In
    the `SetCourse()` method, we set a course based on a course ID:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `nameof` 表达式与枚举一起使用。将以下代码添加到你的类中。我们基本上创建了一个名为 `Course` 的枚举。在 `SetCourse()`
    方法中，我们根据课程 ID 设置一个课程：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then use a `switch` statement to select the course defined by the course
    ID parameter and set the `SelectedCourse` property equal to the `nameof` expression
    of the enumerator. Add the following code to your console application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `switch` 语句根据课程 ID 参数选择定义的课程，并将 `SelectedCourse` 属性设置为枚举的 `nameof` 表达式。将以下代码添加到你的控制台应用程序中：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the console application will result in the string representation of
    the selected enumerator value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序将导致所选枚举值的字符串表示形式：
- en: '![How it works…](img/B05391_01_19.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_19.jpg)'
- en: The `nameof` expression is a very good way of keeping your code in sync when
    dealing with the string literals of objects in C# 6.0.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof` 表达式是处理 C# 6.0 中对象的字符串字面量时保持代码同步的一种非常好的方法。'
- en: Expression-bodied functions and properties
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式主体函数和属性
- en: As the name suggests, expression-bodied functions and properties allow methods
    and properties to have a body that is an expression instead of a statement. You
    will notice that expression-bodied members look a lot like lambda expressions,
    because they are inspired by lambda expressions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，表达式主体函数和属性允许方法和属性拥有一个表达式主体而不是语句主体。你会注意到表达式主体成员看起来很像 lambda 表达式，因为它们受到了
    lambda 表达式的启发。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To truly appreciate expression-bodied functions and properties, we need to look
    at the way code had to be written previously. We will create a class to calculate
    the sale price of an item, and the class will contain two public methods. One
    will set a shelf price, and the other will return a message displaying the calculated
    sale price.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正欣赏表达式主体函数和属性，我们需要看看之前代码是如何编写的。我们将创建一个类来计算商品的销售价格，该类将包含两个公共方法。一个用于设置货架价格，另一个用于返回显示计算出的销售价格的消息。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Create a class called `Recipe6ExpressionBodiedFunctionMembers` and add two
    private auto-implemented properties to hold the sale discount percent and the
    shelf price:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Recipe6ExpressionBodiedFunctionMembers` 的类，并添加两个私有自动实现的属性来存储销售折扣百分比和货架价格：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you haven''t done so in an earlier recipe, add the extension method class
    to calculate the sale price of an item:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有在之前的菜谱中这样做，请添加一个扩展方法类来计算商品的销售价格：
- en: '[PRE32]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will now add a calculated property to the class. This calculated property
    uses the extension method on the `ShelfPrice` property to get the sale price:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向类中添加一个计算属性。这个计算属性使用 `ShelfPrice` 属性上的扩展方法来获取销售价格：
- en: '[PRE33]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, add two methods to your class to set the shelf price and another to
    return a message with the sale price:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向你的类中添加两个方法来设置货架价格，另一个方法用于返回带有销售价格的消息：
- en: '[PRE34]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To see the result of the code, add the following code to your console application:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看代码的结果，请将以下代码添加到你的控制台应用程序中：
- en: '[PRE35]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Running your application produces the message displaying the calculated sale
    price:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序将显示计算出的销售价格的消息：
- en: '![How it works…](img/B05391_01_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_20.jpg)'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we are just supplying the bar code in the output message. However, in
    a live system, the shelf price would be looked up from a data store for the specific
    bar code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在输出消息中提供了条形码。然而，在实际系统中，货架价格将根据特定的条形码从数据存储中查找。
- en: 'Looking back at our class, we can see that it is somewhat bulky. We have a
    calculated property that returns a sale price and two methods with a single `return`
    statement. One sets the shelf price, while the other gets a message containing
    the sale price. This is where expression-bodied function members come into play.
    Modify your code in the `Recipe6ExpressionBodiedFunctionMembers` class to make
    it look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的类，我们可以看到它有些庞大。我们有一个返回销售价格的计算属性，以及两个只有一个 `return` 语句的方法。一个用于设置货架价格，另一个获取包含销售价格的消息。这就是表达式主体函数成员发挥作用的地方。将
    `Recipe6ExpressionBodiedFunctionMembers` 类中的代码修改如下：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What we are left with is a terse class that does exactly the same as the code
    we wrote before. There is less code, it is easier to read, and it looks much cleaner.
    You will notice the use of the lambda `=>` operator. For the `GetCalculatedSalePrice`
    computed property, the `get` keyword is missing. This became implied when we changed
    the computed property body to an expression.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的是一个简洁的类，它与我们之前编写的代码完全一样。代码更少，更容易阅读，看起来也更干净。您会注意到使用了 lambda `=>` 操作符。对于
    `GetCalculatedSalePrice` 计算属性，`get` 关键字是缺失的。当我们将计算属性体更改为表达式时，它就隐含了。
- en: One point to remember though is that expression-bodied function members do not
    work with constructors.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一点需要注意，表达式主体函数成员不支持构造函数。
- en: Using static
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态
- en: C# 6.0 introduces a new kind of `using` statement that now refers to types instead
    of namespaces. This means that the static members of the type are then directly
    put into scope. What this means for your code is evident in the condensed result
    of this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0 引入了一种新的 `using` 语句，现在它引用的是类型而不是命名空间。这意味着类型的静态成员将直接放入作用域。这对于您的代码意味着什么，可以从这个菜谱的简化结果中明显看出。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a class called `Recipe7UsingStatic` that will determine the sale
    price of an item depending on the day of the week. If it is Friday, we want to
    apply the sale discount to the item. On any other day, we will sell the item at
    the shelf price.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `Recipe7UsingStatic` 的类，该类将根据星期几确定商品的销售价格。如果是星期五，我们将对商品应用销售折扣。在其他任何一天，我们将以货架价格出售商品。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Start by creating a `Recipe7UsingStatic` class that contains two auto-implemented
    properties and an enumerator for the day of the week:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为 `Recipe7UsingStatic` 的类，该类包含两个自动实现的属性和一个表示星期的枚举：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will now add a computed property and two methods to our `Recipe7UsingStatic`
    class. One method will set the shelf price and the other will get the sale price:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将向 `Recipe7UsingStatic` 类中添加一个计算属性和两个方法。一个方法用于设置货架价格，另一个方法用于获取销售价格：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the console application, we will add the code to define the day of the week,
    set the shelf price, and then get the sale price. The sale price is then written
    out to the console application:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，我们将添加代码来定义星期几，设置货架价格，然后获取销售价格。然后，将销售价格写入控制台应用程序：
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Run your console application and see that the sale price is calculated correctly
    and output to the console application:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序，并查看销售价格是否正确计算并输出到控制台应用程序：
- en: '![How it works…](img/B05391_01_21.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B05391_01_21.jpg)'
- en: 'Now, let''s have a closer look at the code. In particular, look at the `GetCalculatedSalePrice`
    computed property. It uses the `Math.Round` function to round the sale price to
    two decimals:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看代码。特别是，看看 `GetCalculatedSalePrice` 计算属性。它使用 `Math.Round` 函数将销售价格四舍五入到两位小数：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Math` class is in reality a static class that contains a collection of
    functions that you can use throughout your code to perform different mathematical
    calculations. So, go ahead and add the following `using` statement at the top
    of your `Recipes.cs` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Math` 类是一个静态类，其中包含了一组函数，您可以在代码的任何地方使用这些函数来执行不同的数学计算。因此，请在上面的 `Recipes.cs`
    文件顶部添加以下 `using` 语句：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now change our computed `GetCalculatedSalePrice` property to omit the
    `Math` class name:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将计算属性 `GetCalculatedSalePrice` 修改为省略 `Math` 类名：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is really a fantastic enhancement. Look at the following lines of code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个非常棒的增强功能。看看以下代码行：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because of this enhancement, the preceding lines of code can simply be written
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个增强功能，前面的代码可以简单地写成以下这样：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There is, however, more to using the `static` keyword''s functionality. We
    are using static classes for all the recipes in this chapter. We can, therefore,
    also implement the `using static` statement for our own custom static classes.
    Add the following `using` statements to the top of the console application''s
    `Program` class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `static` 关键字的功能还有更多。我们在这个章节的所有食谱中都使用了静态类。因此，我们也可以为我们的自定义静态类实现 `using static`
    语句。将以下 `using` 语句添加到控制台应用程序的 `Program` 类顶部：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will notice that we have included the enumerator in the `using static`
    statements. This is equally fantastic, because Friday is clearly a day of the
    week, and the enumerator doesn''t need to be called fully, as in the old console
    application code. By adding the `using static` statements, the code in our console
    application can be changed as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在 `using static` 语句中包含了枚举器。这同样很棒，因为周五显然是一周中的某一天，枚举器不需要完全调用，就像旧的控制台应用程序代码中那样。通过添加
    `using static` 语句，我们控制台应用程序中的代码可以按如下方式更改：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is where the real benefit of the `using static` statements become evident.
    It means less code and makes your code more readable. To recap the idea behind
    C# 6.0, it didn't introduce big new concepts but many small features to make your
    code cleaner and your intent easier to understand. The `using static` feature
    does exactly this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `using static` 语句真正好处显现的地方。这意味着代码更少，使代码更易于阅读。回顾一下 C# 6.0 的理念，它并没有引入大的新概念，而是引入了许多小功能，使代码更干净，意图更容易理解。`using
    static` 功能正是如此。
- en: Exception filters
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: Exception filters have been around for some time. **Visual Basic.NET** (**VB.NET**)
    and F# devs have had this functionality for a while. Luckily for us, it has now
    been introduced in C# 6.0\. Exception filters do more than what meets the eye.
    At first glance, it looks as if exception filters merely specify a condition when
    an exception needs to be caught. This is, after all, what the name "exception
    filter" implies. Upon closer inspection, however, we see that exception filters
    act as more than just syntactical sugar.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤器已经存在一段时间了。**Visual Basic.NET（VB.NET**）和 F# 开发者已经有一段时间拥有这项功能了。幸运的是，它现在已经被引入到
    C# 6.0 中。异常过滤器不仅仅如表面所见。乍一看，异常过滤器似乎只是指定了当需要捕获异常时的条件。毕竟，“异常过滤器”这个名字就是这样暗示的。然而，仔细观察后，我们发现异常过滤器不仅仅是语法糖。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new class called `Recipe8ExceptionFilters` and call a method
    that reads an XML file. The file read logic is determined by a Boolean flag being
    set to `true`. Imagine here that there is some other database flag that when set,
    also sets our Boolean flag to `true`, and thus, our application knows to read
    the given XML file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类 `Recipe8ExceptionFilters` 并调用一个读取 XML 文件的方法。文件读取逻辑由一个布尔标志设置为 `true`
    决定。想象一下，这里有一个其他数据库标志，当它被设置时，也会将我们的布尔标志设置为 `true`，因此，我们的应用程序知道要读取给定的 XML 文件。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a class called `Recipe8ExceptionFilters` that contains two methods.
    One method reads the XML file, and the second method logs any exception errors:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Recipe8ExceptionFilters` 的类，该类包含两个方法。一个方法读取 XML 文件，另一个方法记录任何异常错误：
- en: '[PRE47]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the console application, add the following code to call the `ReadXMLFile`
    method, passing it the file name to read:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，添加以下代码以调用 `ReadXMLFile` 方法，并传递要读取的文件名：
- en: '[PRE48]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'If we had to run our application now, we would obviously receive an error (this
    is assuming that you actually don''t have a file called `XMLFile.xml` in your
    `temp` folder). Visual Studio will break on the `throw` statement:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，显然会收到错误（这里假设你实际上在 `temp` 文件夹中没有名为 `XMLFile.xml` 的文件）。Visual Studio
    将在 `throw` 语句处中断：
- en: '![How it works…](img/B05391_01_22.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_22.jpg)'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You need to add the correct namespace using `System.IO` at the top of your code
    file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在代码文件顶部添加正确的命名空间 `System.IO`。
- en: 'The `Log(ex)` method has logged the exception, but have a look at the **Watch1**
    window. We have no idea what the value of `blnReadFileFlag` is. When an exception
    is caught, the stack is unwound (adding overhead to your code) to whatever the
    actual catch block is. Therefore, the state of the stack before the exception
    happened is lost. Modify your `ReadXMLFile` and `Log` methods as follows to include
    an exception filter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log(ex)` 方法已记录异常，但看看 **Watch1** 窗口。我们不知道 `blnReadFileFlag` 的值是什么。当捕获到异常时，堆栈会回溯（给代码添加开销）到实际的捕获块。因此，异常发生前的堆栈状态丢失。按照以下方式修改你的
    `ReadXMLFile` 和 `Log` 方法，以包含异常过滤器：'
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When you run your console application again, Visual Studio will break on the
    actual line of code that caused the exception:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行你的控制台应用程序时，Visual Studio 将在导致异常的实际代码行上中断：
- en: '![How it works…](img/B05391_01_23.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_23.jpg)'
- en: 'More importantly, the value of `blnReadFileFlag` is still in scope. This is
    because exception filters can see the state of the stack at the point where the
    exception occurred instead of where the exception was handled. Looking at the
    **Locals** window in Visual Studio, you will see that the variables are still
    in scope at the point where the exception occurred:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，`blnReadFileFlag` 的值仍然在作用域内。这是因为异常过滤器可以看到异常发生时的堆栈状态，而不是异常被处理时的状态。查看 Visual
    Studio 中的 **Locals** 窗口，你会看到变量在异常发生时仍然在作用域内：
- en: '![How it works…](img/B05391_01_24.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_24.jpg)'
- en: 'Imagine being able to view the exception information in a log file with all
    the local variable values available. Another interesting point to note is the
    `return false` statement in the `Log(ex)` method. Using this method to log the
    error and return `false` will allow the application to continue and have the exception
    handled elsewhere. As you know, catching `Exception ex` will catch everything.
    By returning `false`, the exception filter doesn''t run into the `catch` statement,
    and more specific `catch` exceptions (for example, `catch (FileNotFoundException
    ex)` after our `catch (Exception ex)` statement) can be used to handle specific
    errors. Normally, when catching exceptions, `FileNotFoundException` will never
    be caught in the following code example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下能够在日志文件中查看异常信息，同时所有局部变量值都可用。另一个值得注意的有趣点是 `Log(ex)` 方法中的 `return false` 语句。使用此方法记录错误并返回
    `false` 将允许应用程序继续运行，并在其他地方处理异常。正如你所知，捕获 `Exception ex` 将捕获一切。通过返回 `false`，异常过滤器不会遇到
    `catch` 语句，并且可以使用更具体的 `catch` 异常（例如，在我们的 `catch (Exception ex)` 语句之后的 `catch (FileNotFoundException
    ex)`）来处理特定错误。通常，在捕获异常时，在以下代码示例中 `FileNotFoundException` 永远不会被捕获：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is because the order of the exceptions being caught is wrong. Traditionally,
    developers must catch exceptions in their order of specificity, which means that
    `FileNotFoundException` is more specific than `Exception` and must therefore be
    placed before `catch (Exception ex)`. With exception filters that call a false
    returning method, we can inspect and log an exception accurately:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为捕获异常的顺序是错误的。传统上，开发者必须按照特定性顺序捕获异常，这意味着 `FileNotFoundException` 比较具体，因此必须放在
    `catch (Exception ex)` 之前。使用返回 `false` 的方法调用的异常过滤器，我们可以准确地检查和记录异常：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code will catch all exceptions, and in doing so log the exception
    accurately but not step into the exception handler because the `Log(ex)` method
    returns `false`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将捕获所有异常，并在捕获异常的过程中准确记录异常，但不会进入异常处理程序，因为 `Log(ex)` 方法返回 `false`。
- en: 'Another implementation of exception filters is that they can allow developers
    to retry code in the event of a failure. You might not specifically want to catch
    the first exception, but implement a type of timeout element to your method. When
    the error counter has reached the maximum iterations, you can catch and handle
    the exception. You can see an example of catching an exception based on a `try`
    clauses'' count here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤器的另一种实现是允许开发者在失败的情况下重试代码。你可能不希望专门捕获第一个异常，但可以在你的方法中实现一种超时元素。当错误计数器达到最大迭代次数时，你可以捕获并处理异常。你可以在这里看到基于
    `try` 子句计数的异常捕获示例：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Exception filtering is a very useful and extremely powerful way to handle exceptions
    in your code. The behind-the-scenes workings of exception filters are not as immediately
    obvious as one might imagine, but here lies the actual power of exception filters.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤是处理代码中异常的一种非常有用且极其强大的方式。异常过滤器背后的工作原理并不像人们想象的那样立即明显，但这里正是异常过滤器的实际力量所在。
- en: Using await operator in catch and finally blocks
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 catch 和 finally 块中使用 await 操作符
- en: Finally, in C# 6.0, you can now use the `await` keyword in the `catch` and `finally`
    blocks. Previously, developers had to resort to all sorts of strange workarounds
    to achieve what is now easily achievable in C# 6.0\. There really is not much
    more to it than the following.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 C# 6.0 中，你现在可以在 `catch` 和 `finally` 块中使用 `await` 关键字。以前，开发者不得不求助于各种奇怪的解决方案来实现现在在
    C# 6.0 中可以轻松实现的功能。实际上，这并没有比以下内容更多。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create another class that will simulate the deletion of a file. An exception
    is thrown, and the `catch` block is then executed along with the `finally` statement.
    In both the `catch` and `finally` clauses, we will delay and await a task for
    3 seconds. Then, we will output this delay to the console application window.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个类来模拟文件的删除。将抛出一个异常，然后执行 `catch` 块以及 `finally` 语句。在 `catch` 和 `finally`
    子句中，我们将延迟并等待一个任务 3 秒。然后，我们将此延迟输出到控制台应用程序窗口。
- en: How to do it…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Create a class called `Recipe9AwaitInCatchFinally` and add a method called
    `FileRunAsync()` to the class with the following code. Make sure that the file
    does not exist in the path given to the `filePath` variable:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Recipe9AwaitInCatchFinally` 的类，并向该类添加一个名为 `FileRunAsync()` 的方法，其代码如下。确保
    `filePath` 变量给出的路径中不存在文件：
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, add another method called `RemoveFileAcync()` to the class that takes
    a file path as a parameter. Include `try` `catch` in this method and add the code
    that will attempt to read the file at the path supplied:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向类中添加另一个名为 `RemoveFileAcync()` 的方法，该方法接受一个文件路径作为参数。在这个方法中包含 `try` `catch`，并添加尝试读取指定路径文件的代码：
- en: '[PRE54]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the `catch` clause, add the following code to simulate a process that takes
    a few seconds to complete:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `catch` 子句中，添加以下代码来模拟一个需要几秒钟才能完成的过程：
- en: '[PRE55]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `finally` clause, add another delay that simulates a task which also
    takes a few seconds to complete:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `finally` 子句中，添加另一个延迟来模拟一个也需要几秒钟才能完成的任务：
- en: '[PRE56]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the console application, simply add a call to the `FileRunAsync()` method
    in the `Recipe9AwaitInCatchFinally` class:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，只需在 `Recipe9AwaitInCatchFinally` 类中调用 `FileRunAsync()` 方法：
- en: '[PRE57]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'After adding the code, run the console application and have a look at the output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代码后，运行控制台应用程序并查看输出：
- en: '![How it works…](img/B05391_01_25.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_01_25.jpg)'
- en: You will notice that the exception thrown was a "file not found" exception.
    In `catch`, the code stopped for 3 seconds while the task was delayed. The same
    is evident for the code in the `finally` clause. It too was delayed for 3 seconds
    while the task was delayed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到抛出的异常是“文件未找到”异常。在 `catch` 中，代码在任务延迟时停止了 3 秒。对于 `finally` 子句中的代码也是如此。它也在任务延迟时延迟了
    3 秒。
- en: This means that now, in your C# 6.0 applications, you can, for example, await
    in the `catch` clause while an exception log message is written to the log. You
    can do the same thing in the `finally` clause while closing database connections
    to dispose of other objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在，在你的 C# 6.0 应用程序中，例如，你可以在异常日志消息写入日志时在 `catch` 子句中等待。你可以在关闭数据库连接以释放其他对象时在
    `finally` 子句中做同样的事情。
- en: The process of how the compiler does this is rather complicated. You, however,
    don't need to worry about how this functionality is achieved. All you need to
    do is know that the `await` keyword is now available to you as a developer for
    use in the `catch` and `finally` blocks.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器如何实现这个过程相当复杂。然而，你不需要担心这个功能是如何实现的。你所需要做的就是知道，`await` 关键字现在作为开发人员可用，可以在 `catch`
    和 `finally` 块中使用。
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look. The code bundle for the book is also hosted on GitHub
    at [https://github.com/PacktPublishing/CSharp-Programming-Cookbook](https://github.com/PacktPublishing/CSharp-Programming-Cookbook).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有关下载代码包的详细步骤，请参阅本书的序言。请查看。本书的代码包也托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/CSharp-Programming-Cookbook](https://github.com/PacktPublishing/CSharp-Programming-Cookbook)。我们还有其他来自我们丰富的图书和视频目录的代码包，可在
    [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/) 找到。查看它们！
