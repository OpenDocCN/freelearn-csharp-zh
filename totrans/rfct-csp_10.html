<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-210"><a id="_idTextAnchor209"/>10</h1>
<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/>Defensive Coding Techniques</h1>
<p>Code is almost organic and evolves over its lifetime as new features are added, fixes are implemented, and refactorings occur at regular intervals. As code changes and developers enter and leave the project, there’s a chance that some of these changes may introduce bugs.</p>
<p>In <em class="italic">Part 2</em> of this book, we discussed testing strategies for detecting these bugs before they reach production. In this chapter, we’ll talk about a few additional techniques that help developers catch and resolve bugs during development. Along the way, we’ll also explore a few newer features in C# and their roles in keeping your code stable and healthy.</p>
<p>We’ll cover the following topics in this chapter:</p>
<ul>
<li>Validating inputs</li>
<li>Protecting against null</li>
<li>Moving beyond classes</li>
<li>Advanced type usage</li>
</ul>
<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter10/Ch10BeginningCode</code> folder.</p>
<p>The code in this chapter talks to a REST API, which will require an active internet connection.</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor212"/>Introducing the Cloudy Skies API</h1>
<p>Our fictitious sample organization, Cloudy <a id="_idIndexMarker587"/>Skies, has a pre-existing set of web services in the form of a public <strong class="bold">REST API</strong>. This API intends to allow interested organizations to pull information about Cloudy Skies flights through the API. However, a steady amount of support tickets has proven that organizations are having a hard time adopting the API and using it in approved ways.</p>
<p>In response, Cloudy Skies has built a .NET library to help others more easily use the API.</p>
<p>Early testing of this library is promising, but some developers are still encountering confusing errors that ultimately appear to be related to the data they’re passing the library.</p>
<p>The development team <a id="_idIndexMarker588"/>decided that validating parameters to public methods would help improve the adoption of their library by finding issues sooner. We’ll explore this change in the next section.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/>Validating inputs</h1>
<p><strong class="bold">Input validation</strong> is the act of <a id="_idIndexMarker589"/>verifying that any inputs to your code, such as parameters or current property values, are correct before performing the requested work. We validate inputs to public methods to detect potential issues early on.</p>
<p>To illustrate the importance of this, let’s look at a method that doesn’t validate its inputs:</p>
<pre class="source-code">
public FlightInfo? GetFlight<strong class="bold">(string id, string apiKey)</strong> {
  RestRequest request = new($"/flights/<strong class="bold">{id.ToLower()}</strong>");
  request.AddHeader("x-api-key", <strong class="bold">apiKey</strong>);
  LogApiCall(request.Resource);
  return _client.Get&lt;FlightInfo?&gt;(request);
}</pre>
<p>The <code>GetFlight</code> method takes in an <code>id</code> parameter indicating a flight number, such as “CSA1234,” whereas the <code>apiKey</code> parameter represents a token that must be supplied to interact with the API and get a response. Think of the token as something like a digital keycard that Cloudy Skies issues to interested organizations that want to interact with its APIs. Every request that goes to the Cloudy Skies API must include a token to authenticate and get a result.</p>
<p>The <code>id</code> parameter is important because it is used to identify the flight that we’re interested in. This parameter gets added to the URL that the code makes an HTTP GET request to using the RestSharp <a id="_idIndexMarker590"/>library, which is one of many ways of interacting with web services in modern .NET.</p>
<p class="callout-heading">Don’t panic!</p>
<p class="callout">If any of the web services code or handling of authentication tokens is beyond your comfort zone, don’t worry. While these are concepts you should learn as you grow, the actual mechanics of the web API are not important for this chapter. Instead, we’re focusing on parameter validation.</p>
<p>Now that we’ve established what this method is doing, let’s talk about how it could be better.</p>
<p>First of all, any value for a string is valid here for both <code>id</code> and <code>apiKey</code>. This includes values such as null and empty or whitespace strings. While you might not think that a developer might try those values for those parameters, I can think of compelling reasons someone might try either one:</p>
<ul>
<li>Someone might try to pass null for the <code>id</code> parameter, thinking that it would get the next flight, all flights, or possibly even a random flight</li>
<li>A developer without an API key may think that API keys are only required for requests that modify data on the server or that you can interact with the API in low volumes without an API key</li>
</ul>
<p>While both assumptions are incorrect for this API, I could see someone without knowledge of the system trying either one. In the case of Cloudy Skies, not providing a valid API key will result in a 401 unauthorized error coming back from the server.</p>
<p>On the other hand, not providing an <code>id</code> parameter results in a <code>NullReferenceException</code> error when the code tries to convert <code>id</code> into lowercase, as shown in <em class="italic">Figure 10</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 10.1 – A NullReferenceException error due to id being null when ToLower was called" src="img/B21324_10_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – A NullReferenceException error due to id being null when ToLower was called</p>
<p>Both of these errors are <a id="_idIndexMarker591"/>things that a developer trying to interact with this code could encounter, and neither one of these errors adequately tells the developer that they made a mistake in the parameters they passed in. Let’s fix this with validation.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>Performing basic validation</h2>
<p>The goal of validation is to <a id="_idIndexMarker592"/>detect bad inputs early on and explicitly point out these issues before bad data gets deeper into our system. In building a library, this means that we want to validate parameters sent to our code as early as possible, preferably in the public methods other developers will interact with.</p>
<p>Here’s a version of <code>GetFlight</code> that performs some additional validation steps:</p>
<pre class="source-code">
public FlightInfo? GetFlight(string id, string apiKey) {
<strong class="bold">  if (string.IsNullOrEmpty(apiKey)) {</strong>
<strong class="bold">    throw new ArgumentNullException("apiKey");</strong>
<strong class="bold">  }</strong>
<strong class="bold">  if (string.IsNullOrEmpty(id)) {</strong>
<strong class="bold">    throw new ArgumentNullException("id");</strong>
<strong class="bold">  }</strong>
<strong class="bold">  if (!id.StartsWith("CSA",</strong>
<strong class="bold">                     StringComparison.OrdinalIgnoreCase)) {</strong>
<strong class="bold">    throw new ArgumentOutOfRangeException("id", "Cannot</strong>
<strong class="bold">        lookup non-CSA flights");</strong>
<strong class="bold">  }</strong>
  RestRequest request = new($"/flights/{id.ToLower()}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
  return _client.Get&lt;FlightInfo?&gt;(request);
}</pre>
<p>Here, we check if <code>apiKey</code> or <code>id</code> are either null or empty strings. If that’s true, we throw an <code>ArgumentNullException</code> error to tell whoever called this method that they are not providing a valid value for a specific parameter.</p>
<p>We also perform a check on <code>id</code> to determine whether it refers to a flight with a Cloudy Skies Airline prefix. If it <a id="_idIndexMarker593"/>doesn’t, this flight will never be found since it isn’t tracked by the system. In this case, it makes sense to alert the caller with an <code>ArgumentOutOfRangeException</code> error. This exception type is also commonly used with numbers or dates that are outside of acceptable ranges for a method.</p>
<p class="callout-heading">Should we really throw exceptions here?</p>
<p class="callout">Many new developers think that exceptions are bad. Most developers hate encountering exceptions, and throwing exceptions can indeed be relatively slow. Keeping these things <a id="_idIndexMarker594"/>in mind, when you get invalid values, sometimes, the best option is to throw a specific exception that highlights the issue. This helps catch mistakes quickly and prevents errors that can occur from letting invalid values deeper into a system.</p>
<p>You may have noticed that the revised code has a lot of validation relative to the other logic in the method. There are a few ways of improving this, as we’ll see in the upcoming sections, but let’s work toward that goal incrementally. We’ll start by looking at a better way of referring to bad parameter values.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Using the nameof keyword</h2>
<p>Right now, the code validates parameters and throws exceptions with code like this:</p>
<pre class="source-code">
throw new ArgumentNullException("apiKey");</pre>
<p>In this example, <code>"apiKey"</code> refers to<a id="_idIndexMarker595"/> the name of the parameter, which helps developers identify which parameter the exception is complaining about.</p>
<p>Now, what happens if<a id="_idIndexMarker596"/> someone renames that parameter later to <code>apiToken</code>? This change wouldn’t cause any compiler errors and the exception could still be thrown. Unfortunately, the exception would reference the old <code>apiKey</code> parameter name that was no longer present, which would confuse the developer encountering the error.</p>
<p>To help with this, C# gives us the <code>nameof</code> keyword, which looks like this:</p>
<pre class="source-code">
public FlightInfo? GetFlight(string id, string apiKey) {
  if (string.IsNullOrEmpty(apiKey)) {
    throw new ArgumentNullException(<strong class="bold">nameof(apiKey)</strong>);
  }</pre>
<p>When your code is compiled, the <code>nameof</code> keyword evaluates the name of the parameter, method, or class it is used on. A string with the result of that <code>nameof</code> evaluation is then included in the compiled code. In other words, it’s identical to the code we had before – except that if the parameter is ever renamed, our code no longer compiles until the <code>nameof</code> keyword is updated to refer to the renamed parameter.</p>
<p>This allows us to rely on the compiler to help ensure our parameter validation uses the correct parameter names, even if those parameters are renamed in the future.</p>
<p>Let’s introduce a more concise way of throwing exceptions.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>Validation with guard clauses</h2>
<p>Right now, our validation logic <a id="_idIndexMarker597"/>consists of an <code>if</code> statement followed by <a id="_idIndexMarker598"/>a conditional <code>throw</code> statement. This validation is so common and can take up many lines of code when validation is complex that .NET now gives us a more concise way of interacting with it in the form of <strong class="bold">guard clauses</strong>.</p>
<p>We can take our validation down to a single line of code by calling <code>ArgumentException.ThrowIfNullOrEmpty</code>, as shown here:</p>
<pre class="source-code">
public FlightInfo? GetFlight(string id, string apiKey) {
<strong class="bold">  ArgumentException.ThrowIfNullOrEmpty(id, nameof(id));</strong></pre>
<p>This method will check the value of the <a id="_idIndexMarker599"/>parameter it is passed in and will throw either an <code>ArgumentNullException</code> error if the value is null or an <code>ArgumentException</code> error if the value is an empty string.</p>
<p>There aren’t a lot of these validations built into .NET right now, but if you like the idea and want validations<a id="_idIndexMarker600"/> for things such as negative values or numeric or date ranges, you’ll love Steve Smith’s excellent <strong class="bold">GuardClauses library</strong>.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>Guard clauses with the GuardClauses library</h2>
<p>To help augment the built-in guard <a id="_idIndexMarker601"/>clauses, Steve Smith created the <strong class="bold">Ardalis.GuardClauses</strong> library.</p>
<p>To use the GuardClauses library, install the<a id="_idIndexMarker602"/> latest version of Ardallis.GuardClauses via NuGet Package Manager, as we’ve done in prior chapters.</p>
<p>Next, add <code>using Ardalis.GuardClauses;</code> to the top of your <code>.</code><code>cs</code> file.</p>
<p>Once that’s been installed and referenced, you’ll be able to use guard syntax, as shown in the following code:</p>
<pre class="source-code">
public Flights GetFlightsByMiles(int maxMiles,
  string apiKey) {
<strong class="bold">  Guard.Against.NegativeOrZero(maxMiles);</strong>
<strong class="bold">  Guard.Against.NullOrWhiteSpace(apiKey);</strong>
  // Other logic omitted…
}</pre>
<p>Here, the GuardClauses library provides various static methods inside <code>Guard.Against</code> syntax that allow you to validate a great many things.</p>
<p>If a validation condition is met – for example, if <code>maxMiles</code> is <code>4</code> when <code>NegativeOrZero</code> is called – the program continues as normal. However, if the condition is not met, an <code>ArgumentException</code> error will be thrown containing the name of the parameter that <a id="_idIndexMarker603"/>violated the condition.</p>
<p>I’ve found this library to be intuitive to write and read, and it also leads to efficient and effective guard clauses that require a minimal amount of effort.</p>
<p>The full extent of the GuardClauses<a id="_idIndexMarker604"/> library is well beyond the scope of this book, but you can install it and see the methods available or check out the documentation referenced in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<p class="callout-heading">But wait – there’s more!</p>
<p class="callout">This book’s wonderful technical reviewers rightly pointed out the popular <strong class="bold">FluentValidation library</strong>, which offers a rich set of validation rules that can be applied to your classes. You can learn more about this library in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<p>Before we move on, I want to point out one aspect of the <code>Ardalis.GuardClauses</code> library that you might not have noticed.</p>
<p>Let’s say you call a guard clause with <code>Guard.Against.Null(apiKey);</code>.</p>
<p>If this validation rule fails it will throw an <code>ArgumentException</code> error. This exception will have a <code>ParamName</code> property with a value of <code>apiKey</code>. Additionally, the resulting message will mention the <code>apiKey</code> parameter by name, <em class="italic">even though you didn’t provide the name when you called the </em><em class="italic">guard clause</em>.</p>
<p>This works due to the library’s use of the <code>CallerArgumentExpression</code> attribute, which we’ll explore next.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/>Using CallerMemberInformation attributes</h2>
<p>The <code>nameof</code> keyword proved so successful in eliminating strings referring to things that were later renamed that C# grew to accompany four separate attributes that can tell you things about any given method.</p>
<p>Each of these attributes is <a id="_idIndexMarker605"/>applied to a method <a id="_idIndexMarker606"/>parameter. Like the <code>nameof</code> keyword, these attributes are evaluated at compile time and result in a <code>string</code> or <code>int</code> type being used in the final compiled code in their place.</p>
<p>The four available caller member attributes are as follows:</p>
<ul>
<li><strong class="bold">CallerFilePath</strong> contains a string with the name and path of the file of the code calling to the method on the machine compiling the code</li>
<li><code>int</code> type with the line number for the method call</li>
<li><strong class="bold">CallerMemberName</strong> contains the name of the method or property where the method call occurred</li>
<li><strong class="bold">CallerArgumentExpression</strong> converts the expression passed into the method into a string, before evaluating the expression</li>
</ul>
<p>Let’s look at <code>LogApiCall</code> for an example of this:</p>
<pre class="source-code">
public static void LogApiCall(string url,
<strong class="bold">  [CallerFilePath] string file = "",</strong>
<strong class="bold">  [CallerLineNumber] int line = 0,</strong>
<strong class="bold">  [CallerMemberName] string name = "",</strong>
<strong class="bold">  [CallerArgumentExpression(nameof(url))] string expr = "")</strong>
{
  Console.WriteLine($"Making API Call to {url}");
  Console.WriteLine("Called in:");
  Console.WriteLine($"{<strong class="bold">file</strong>}:{<strong class="bold">line</strong>} at {<strong class="bold">name</strong>}");
  Console.WriteLine($"Url expression: {<strong class="bold">expr</strong>}");
}</pre>
<p>This method takes in five parameters, where the first is a standard string parameter and the other four use the various caller member information attributes. Notice how these attributes all have a default value specified. When values are not specified for these parameters, the compiler<a id="_idIndexMarker607"/> will replace each parameter with values it detected during compilation.</p>
<p>Let’s look at an example<a id="_idIndexMarker608"/> call:</p>
<pre class="source-code">
public IEnumerable&lt;FlightInfo&gt; GetFlightsByMiles(
  int maxMiles, string apiKey) {
  // Validation omitted...
  string url = $"/flights/uptodistance/{maxMiles}";
  RestRequest request = new(url);
  request.AddHeader("x-api-key", apiKey);
<strong class="bold">  LogApiCall(request.Resource);</strong>
  IEnumerable&lt;FlightInfo&gt;? response =
    _client.Get&lt;IEnumerable&lt;FlightInfo&gt;&gt;(request);
  return response ?? Enumerable.Empty&lt;FlightInfo&gt;();
}</pre>
<p>Notice how when <code>LogApiCall</code> is invoked, only the string parameter is specified. The remaining parameters are provided values during compilation due to the attributes on each parameter.</p>
<p>Also, note that the expression that was used to get that string is <code>request.Resource</code>. This expression is what <code>CallerArgumentExpression</code> uses to generate its string because the <code>CallerArgumentExpression</code> attribute requires the name of another parameter. In this case, we specified <code>[CallerArgumentExpression(nameof(url))]</code> to have it look at the expression that was passed into the <code>url</code> parameter – the first parameter the method takes in.</p>
<p>When this code runs, we will see the following message logged in the console:</p>
<pre class="console">
Making API Call to /flights/uptodistance/500
Called in:
C:\RefactorBook\Chapter10\CloudySkiesFlightProvider.cs:51
  at GetFlightsByMiles
Url expression: request.Resource</pre>
<p>As you can see, it logged the full path to the file on my hard drive, as well as the line number of the <code>LogApiCall</code> method call.</p>
<p>The expression of <code>request.Resource</code> is the exact <a id="_idIndexMarker609"/>string of code that’s used to call that method, as shown here:</p>
<pre class="source-code">
LogApiCall(<strong class="bold">request.Resource</strong>);</pre>
<p>Caller member information<a id="_idIndexMarker610"/> attributes are very handy for certain types of things, such as logging and validation, or certain <a id="_idIndexMarker611"/>specialized scenarios such as raising <code>INotifyProperty</code> changed in <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>) applications.</p>
<p>Now that we’ve sufficiently explored working with parameters for our methods, let’s look at how modern C# lets us work safely with null values.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Protecting against null</h1>
<p>British computer scientist, Tony Hoare, is <a id="_idIndexMarker612"/>generally credited as the inventor of the null reference in programming. In 2008, he famously apologized for it, calling it his “billion-dollar mistake.” This was due to the countless bugs and crashes that have occurred in various programming languages when code attempted to interact with variables currently holding null values. While I can’t fault Tony Hoare, nulls can certainly be dangerous.</p>
<p>In .NET, this comes in the form of a <code>NullReferenceException</code> error, as we saw earlier in this chapter. You get a <code>NullReferenceException</code> error any time you attempt to invoke a method or evaluate a property on a variable that currently holds a null value.</p>
<p>Before C# 8, developers needed to be explicitly aware that any reference type could hold a null value and write conditional logic, such as the following code:</p>
<pre class="source-code">
if (<strong class="bold">flight != null</strong>) {
 Console.WriteLine($"Flight {<strong class="bold">flight.Id</strong>}: {<strong class="bold">flight.Status</strong>}");
}</pre>
<p>This pattern of checking for nullability and then conditionally acting became prevalent in C# because when it didn’t, developers encountered <code>NullReferenceException</code> errors. Unfortunately, this led to null checks occurring throughout the code, including in many places where nulls would never be encountered.</p>
<p>In C# 8, nullable reference<a id="_idIndexMarker613"/> types were introduced, which helped developers understand when and where they were likely to encounter null values so that they would have active reminders to guard against null values in those places. Additionally, these improvements made it easier to remove unnecessary null checks in places where nulls were not expected.</p>
<p>In C# 8 and beyond, when nullability analysis is enabled, you can indicate that any reference type may be null by adding <code>?</code> after the type indicator, as shown here for <code>FlightInfo</code>:</p>
<pre class="source-code">
public <strong class="bold">FlightInfo?</strong> GetFlight(string id, string apiKey) {
  ArgumentException.ThrowIfNullOrEmpty(id);
  ArgumentException.ThrowIfNullOrEmpty(apiKey);
  RestRequest request = new($"/flights/{id.ToLower()}");
  request.AddHeader("x-Api-key", apiKey);
  LogApiCall(request.Resource);
  return client.Get&lt;<strong class="bold">FlightInfo?</strong>&gt;(request);
}</pre>
<p>In this case, this indicates that the <code>GetFlight</code> method will return either a <code>FlightInfo</code> instance or a null value. Additionally, this indicates that the <code>id</code> and <code>apiKey</code> parameters will always have a string that is not null. If these accepted null values, they would be declared as <code>string? Id, string? </code><code>apiKey</code> instead.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Nullability analysis in C# does not prevent you from passing null to things that say they do not accept null values, nor does it prevent you from returning null values from methods that claim to return a non-null return type. Instead, nullability analysis flags these cases as warnings, which will help you address these issues. We’ll talk more about code analysis warnings in <a href="B21324_12.xhtml#_idTextAnchor259"><em class="italic">Chapter 12</em></a>.</p>
<p>If we wanted to say that <code>GetFlight</code> could <a id="_idIndexMarker614"/>never return null, we would remove <code>?</code> from the <code>FlightInfo</code> return type and validate that the result from the API was not null:</p>
<pre class="source-code">
public <strong class="bold">FlightInfo</strong> GetFlight(string id, string apiKey) {
  ArgumentException.ThrowIfNullOrEmpty(id);
  ArgumentException.ThrowIfNullOrEmpty(apiKey);
  RestRequest request = new($"/flights/{id.ToLower()}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
<strong class="bold">  FlightInfo? flightInfo=_client.Get&lt;FlightInfo?&gt;(request);</strong>
<strong class="bold">  if (flightInfo == null) {</strong>
<strong class="bold">    </strong><strong class="bold">string message = $"Could not find flight {id}";</strong>
<strong class="bold">    throw new InvalidOperationException(message);</strong>
<strong class="bold">  }</strong>
<strong class="bold">  return flightInfo;</strong>
}</pre>
<p>The request to the API via <code>_client.Get</code> still might return a nullable value, so the code must now check for null and conditionally throw an exception if a null value is encountered. However, this guarantees that the code returns only a non-null value, which is what the return type of <code>FlightInfo</code> indicates with nullability analysis active.</p>
<p>Let’s look at how to enable and disable nullability analysis in Visual Studio.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>Enabling nullability analysis in C#</h2>
<p>Since .NET 6, nullable <a id="_idIndexMarker615"/>reference types are enabled by default in new projects going forward.</p>
<p>However, you can enable<a id="_idIndexMarker616"/> nullable reference types in any project using C# 8 or above by adding a <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> node to your project’s <code>.</code><code>csproj</code> file:</p>
<pre class="source-code">
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    <strong class="bold">&lt;Nullable&gt;enable&lt;/Nullable&gt;</strong>
    &lt;RootNamespace&gt;Packt.CloudySkiesAir&lt;/RootNamespace&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre>
<p>You can edit this file either in a text editor such as Notepad, or you can double-click on the project node in <strong class="bold">Solution Explorer</strong> to edit the file inside Visual Studio.</p>
<p>If you don’t want nullability analysis enabled for your entire project, you can enable and disable nullability analysis with preprocessor statements such as <code>#nullable enable</code> and <code>#nullable disable</code>. For example, the following code temporarily disables nullability analysis for a class definition:</p>
<pre class="source-code">
<strong class="bold">#nullable disable</strong>
public class FlightInfo {
    public string Id { get; set; }
    public FlightStatus Status { get; set; }
    public string Origin { get; set; }
    public string Destination { get; set; }
    public DateTime DepartureTime { get; set; }
    public DateTime ArrivalTime { get; set; }
    public int Miles { get; set; }
    public override string ToString() =&gt;
      $"{Id} from {Origin} to {Destination} " +
      $"on {DepartureTime}. Status: {Status}";
}
<strong class="bold">#nullable restore</strong></pre>
<p>I’d encourage you to use project-level nullability analysis and avoid using <code>#nullable</code> when possible. I’ve known <a id="_idIndexMarker617"/>many developers who get nauseated every time they see a preprocessor<a id="_idIndexMarker618"/> statement. My opinion is that <code>#nullable</code> should be reserved for when you are moving a larger project to use nullability analysis but are not yet ready to enable it for the entire project.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Using nullability operators</h2>
<p>Earlier, we talked about how <code>?</code> indicates that a type may contain a null value, but there are several other operators<a id="_idIndexMarker619"/> related to nullability you should be aware of in C#.</p>
<p>First of all, the non-null assertion operator of <code>!</code> tells C# that something is not going to be null and to ignore nullability warnings on that value.</p>
<p>One common place I use this is when working with <code>Console.ReadLine()</code>. This method indicates it may return a null value, but in practice, it never does in normal operation. This can be suppressed using <code>!</code>, as shown here:</p>
<pre class="source-code">
Console.WriteLine("Enter a flight #: ");
<strong class="bold">string</strong> id = Console.ReadLine()<strong class="bold">!</strong>;</pre>
<p>Here, we are taking <code>ReadLine</code>, which is defined as having a <code>string?</code> result and storing it in <code>string</code>. The <code>!</code> operator says that the <code>string?</code> result should be treated as if it was <code>string</code>.</p>
<p>Other nullability operators include the following:</p>
<ul>
<li>The <code>?</code>), which conditionally calls methods only if the object they’re being invoked on is<a id="_idIndexMarker620"/> not null. For<a id="_idIndexMarker621"/> example, <code>_conn?.Dispose()</code> calls the <code>Dispose</code> method only if <code>_conn</code> is not null.</li>
<li>The <code>??</code>), which uses a backup value in case something is null. For <a id="_idIndexMarker622"/>example, <code>int miles = flight?.Miles ?? 0;</code> uses null-conditional and <a id="_idIndexMarker623"/>null coalescing operators to safely get <code>Miles</code> out of a flight or use <code>0</code> when no flight is present.</li>
<li>The <code>??=</code>) assigns a value to a variable only if the<a id="_idIndexMarker624"/> variable is null already. For<a id="_idIndexMarker625"/> example, <code>message ??= "An unexpected error has occurred";</code> will only set the new error message in <code>message</code> if <code>message</code> is null. This allows us to effectively replace null values with backup values.</li>
</ul>
<p>The combination of nullability analysis and nullability operators helps us make intelligent decisions around null values in concise ways. This keeps our code efficient and focused while guiding us toward having a cohesive strategy around handling null values in code.</p>
<p>Let’s take a broader look at changes we can make at the class level to help design more robust applications.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor222"/>Moving beyond classes</h1>
<p>In C# 9 and beyond, Microsoft<a id="_idIndexMarker626"/> has made concerted efforts to give developers new options for working with classes through things such as record types, init-only properties, primary constructors, and more.</p>
<p>In this section, we’ll explore how these newer C# constructs can improve the design of your classes.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Preferring immutable classes</h2>
<p>In recent years, immutable <a id="_idIndexMarker627"/>classes have become more and more popular. This immutability refers to the inability to change an object after it has been created.</p>
<p>What this means is that once an object exists, you cannot modify its state and instead are limited to creating new objects that are like the original. If you’re familiar with working with string and DateTime objects in .NET, you’ve seen this concept with methods such as <code>ToLower</code> on string and <code>AddDays</code> on DateTime returning a new object instead of modifying the original object.</p>
<p>Let’s look at a small class representing a boarding pass that is currently mutable (changeable) and then convert it into an immutable class:</p>
<pre class="source-code">
public class BoardingPass {
  public FlightInfo Flight { get; set; }
  public string Passenger { get; set; }
  public int Group { get; set; }
  public string Seat { get; set; }
}</pre>
<p>This is a “plain old C# object” with properties with getters and setters. Thinking about the class logically, there are several problems:</p>
<ul>
<li>There’s nothing preventing <code>Flight</code>, <code>Passenger</code>, or <code>Seat</code> from having a null value.</li>
<li>Once a pass is created, properties such as <code>passenger</code>, <code>boarding group</code>, <code>seat</code>, and even <code>flight</code> can be changed. This doesn’t make sense in the context of an airline business where a new boarding pass would need to be issued to change these.</li>
</ul>
<p>We can change this object so that it’s immutable and requires valid values for these parameters by removing their setters and adding a constructor with validation:</p>
<pre class="source-code">
public BoardingPass(FlightInfo flight, string passenger,
  string seat, int group) {
  ArgumentNullException.ThrowIfNull(flight);
  ArgumentException.ThrowIfNullOrEmpty(passenger);
  ArgumentException.ThrowIfNullOrEmpty(seat);
  if (group &lt; 1 || group &gt; 8) {
    throw new ArgumentOutOfRangeException(nameof(group));
  }
  Flight = flight;
  Passenger = passenger;
  Seat = seat;
  Group = group;
}</pre>
<p>This constructor now requires that valid values are present for all properties on the object in object creation. Meanwhile, the removal of setters for the properties ensures that the class stays<a id="_idIndexMarker628"/> valid and cannot be changed.</p>
<p>If we needed to, we could add new methods to the <code>BoardingPass</code> class that create and return a new <code>BoardingPass</code> object with similar characteristics to the original in a similar manner to how various string and DateTime methods work. However, <code>with expressions</code> give us a more interesting way of doing this, as we’ll see later in this chapter.</p>
<p>While using immutability may seem more inconvenient than beneficial at first, there are a few key advantages of using immutable classes:</p>
<ul>
<li>Immutable classes can be validated during creation and ensured that they are in a valid state. Once<a id="_idIndexMarker629"/> created, this valid state cannot change.</li>
<li>When objects can be modified anywhere in your code, this makes it harder to track down what changed an object when multiple other classes may have a reference to it. Immutable objects prevent this from occurring.</li>
<li>Some concepts just make more sense as immutable objects, such as a prior version of a document or a boarding pass for a passenger at an airport.</li>
<li>Since immutable objects don’t change, they can be reliably worked with in multi-threaded applications. Without<a id="_idIndexMarker630"/> immutability, you’d need to rely on using <code>Interlocked</code>, the <code>lock</code> keyword, or thread-safe collections to avoid bugs.</li>
</ul>
<p>Of course, having to specify all the properties of an object in its constructor can be cumbersome for classes with many properties. Additionally, not every class in your project needs to be immutable. For those classes that would benefit from immutability, C#’s required keyword and init-only properties help alleviate this burden.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Using required and init-only properties</h2>
<p>The downside of adding every property as a parameter to class constructors is that your constructors can start to <a id="_idIndexMarker631"/>become larger than you’d like. Additionally, creating objects that require many constructor parameters is tedious and error-prone and the <a id="_idIndexMarker632"/>creation of individual objects can be tedious and confusing, particularly when many constructor parameters are needed.</p>
<p>On the other hand, object initializers can be more readable, but until recently, they lacked a way of ensuring properties are present.</p>
<p>Look at the two ways of creating a <code>BoardingPass</code> object and see which appears more readable to you:</p>
<pre class="source-code">
BoardingPass p1 = new(myFlight, "Amleth Hamlet", "2B", 1);
BoardingPass p2 = {
  Flight = myFlight,
  Passenger = "Amleth Hamlet",
  Seat = "2B",
  Group = 1
};</pre>
<p>The object initializer version used in <code>p2</code> is more readable and maintainable, particularly as the number of properties you might want to set in the class grows over time.</p>
<p>The traditional downside of this <a id="_idIndexMarker633"/>approach was that a developer using the object initializer might forget to <a id="_idIndexMarker634"/>set important required properties. C# 11 introduced the <code>required</code> keyword, which will fail to compile if a required property is not explicitly initialized during object initialization or in the constructor when the <code>Passenger</code> property is omitted, as shown in <em class="italic">Figure 10</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 10.2 – A compiler error due to Passenger not being set" src="img/B21324_10_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – A compiler error due to Passenger not being set</p>
<p>To achieve this, we can add <code>required</code> to any property definitions on the class that we want to make sure they are explicitly set by the time the object-initializer completes. The following version of <code>BoardingPass</code> features required properties:</p>
<pre class="source-code">
public class BoardingPass {
  public <strong class="bold">required</strong> FlightInfo Flight { get; <strong class="bold">init</strong>; }
  public <strong class="bold">required</strong> string Passenger { get; <strong class="bold">init</strong>; }
  public <strong class="bold">required</strong> int Group { get; <strong class="bold">init</strong>; }
  public <strong class="bold">required</strong> string Seat { get; <strong class="bold">init</strong>; }
}</pre>
<p>You may have also noticed that this class definition defines these properties as <code>{get; init;}</code> instead of <code>{get;}</code> or <code>{get; set;}</code>. While the traditional <code>get; set;</code> combination allows a property to be changed at any time, this violates immutability. The <code>get;</code> version removes the ability to set the property anywhere but the constructor, which means properties defined as <code>get;</code> cannot be set in object initializers.</p>
<p>The newer <code>get; init;</code> combination that was added in C# 9 allows the property to be set in the constructor or initializer, but no longer allows setting after the object is initialized. This helps us support our immutable class design while not restricting the user to using constructors.</p>
<p>I believe that object initializers are the future of .NET and nowadays tend to favor required properties <a id="_idIndexMarker635"/>with <code>get; init;</code> when designing classes for immutability.</p>
<p>Speaking of the <a id="_idIndexMarker636"/>future, let’s look at a brand-new feature in C# 12: primary constructors for reference types.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/>Primary constructors</h2>
<p><strong class="bold">Primary constructors</strong> are constructors that must be called to initialize the class and provide a way of automatically creating fields in your class. We’ll talk more about what that “must be called” phrase<a id="_idIndexMarker637"/> entails in a moment, but let’s start by looking at a simple example:</p>
<pre class="source-code">
<strong class="bold">public class BoardingPass(string Passenger)</strong> {
  public required FlightInfo Flight { get; init; }
  public required int Group { get; init; }
  public required string Seat { get; init; }
  public override string ToString() =&gt;
    $"{<strong class="bold">Passenger</strong>} in group {Group} " +
    $"for seat {Seat} of {Flight.Id}";
}</pre>
<p>This version of <code>BoardingPass</code> has parentheses and a parameter list immediately following the class declaration. This is the primary constructor for the class.</p>
<p>Any parameters declared in the primary constructor are available as if they were init-only properties. This makes a primary constructor roughly equivalent to the following C# code:</p>
<pre class="source-code">
public class BoardingPass {
<strong class="bold">  public BoardingPass(string passenger) {</strong>
<strong class="bold">    this.Passenger = passenger;</strong>
<strong class="bold">  }</strong>
<strong class="bold">  public string Passenger {get; init; }</strong>
  // Other members omitted for brevity...
}</pre>
<p>The advantage of primary constructors is that they are very concise and do not require you to define a constructor or field definitions.</p>
<p>Primary constructors <a id="_idIndexMarker638"/>can work with other constructors, though any other constructor you declare must call the primary constructor using the <code>this</code> keyword, as shown here:</p>
<pre class="source-code">
public class BoardingPass(string Passenger) {
<strong class="bold">  public BoardingPass(FlightInfo flight, string passenger)</strong>
<strong class="bold">  </strong><strong class="bold">: this(passenger) {</strong>
<strong class="bold">    Flight = flight;</strong>
<strong class="bold">  }</strong>
  // other members omitted for brevity...
}</pre>
<p>Essentially, your primary constructor must always be called – either on its own or from another constructor via the <code>this</code> keyword.</p>
<p>Primary constructors are not unique to classes and exist for records starting in C# 9.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>Converting classes into record classes</h2>
<p>Throughout this book, I’ve <a id="_idIndexMarker639"/>alluded to <strong class="bold">record classes</strong> several times<a id="_idIndexMarker640"/> without defining them or going into detail on why you’d want to use one.</p>
<p>To understand record classes, let’s talk briefly about equality in classes. By default, two objects are considered equal if they both live in the same memory address in the heap.</p>
<p>This means that, by default, two separate objects with identical properties are not equal. For example, the <a id="_idIndexMarker641"/>following code would evaluate these two boarding passes as different from each other:</p>
<pre class="source-code">
BoardingPass pass1 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
BoardingPass pass2 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
Console.WriteLine(<strong class="bold">pass1 == pass2</strong>); // false</pre>
<p>You can change this behavior <a id="_idIndexMarker642"/>by overriding <code>Equals</code> and <code>GetHashCode</code> on the <code>BoardingPass</code> class, as we did in <a href="B21324_05.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a>. However, record types give us an easier way of managing this.</p>
<p>Record classes are like normal C# classes except equality works by comparing all properties to each other. In other words, record classes are like normal C# classes that have overridden <code>Equals</code> and <code>GetHashCode</code>.</p>
<p>Let’s redeclare our boarding pass as a record class:</p>
<pre class="source-code">
public <strong class="bold">record class</strong> BoardingPass(string Passenger) {
  public required FlightInfo Flight { get; init; }
  public required int Group { get; init; }
  public required string Seat { get; init; }
  public override string ToString() =&gt;
    $"{Passenger} in group {Group} " +
    $"for seat {Seat} of {Flight.Id}";
}</pre>
<p>Now, we can<a id="_idIndexMarker643"/> successfully compare two boarding passes using just their values:</p>
<pre class="source-code">
BoardingPass pass1 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
BoardingPass pass2 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
Console.WriteLine(pass1 == pass2); // true</pre>
<p>These two classes are <a id="_idIndexMarker644"/>considered equal because they carry the same values. Note that the <code>Flight</code> property refers to a <code>FlightInfo</code> object, which is still a standard C# class and uses traditional reference equality. This means that boarding passes must point to the same <code>FlightInfo</code> object in memory; otherwise, they will not be considered equal. This can be changed by making <code>FlightInfo</code> a record class as well.</p>
<p>I recommend using record classes for small objects that you might want to compare to each other. They also might be helpful for classes that might be frequently instantiated, such as objects coming from the database or an external API call.</p>
<p>Let’s move on to talk about my favorite new way of creating objects: <code>with</code> expressions.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>Cloning objects using with expressions</h2>
<p><code>with</code> expressions work very well with immutable records by allowing you to clone<a id="_idIndexMarker645"/> and slightly tweak the source record without making any modifications to the original record.</p>
<p>Let’s say that Hamlet’s boarding pass for seat 2B on the flight needed to be changed. The system could instantiate a new boarding pass that was just like the original one except for seat 2C using the following code:</p>
<pre class="source-code">
BoardingPass pass = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
BoardingPass newPass = <strong class="bold">pass with { Seat = "3B" }</strong>;</pre>
<p>This creates a new boarding pass based on the original one but with one property slightly different.</p>
<p>If we wanted to move Hamlet to have a new seat but an earlier boarding group, we could do that as well by listing an additional property, as shown here:</p>
<pre class="source-code">
BoardingPass newPass2 = <strong class="bold">pass with {Seat = "3B", Group = 1}</strong>;</pre>
<p>I find <code>with</code> expressions to be one of the most exciting things about working with record classes in C# and I love the direction the language is going in to streamline the creation of objects.</p>
<p>This style of referring to property values is not unique to the <code>with</code> expression, as we’ll see in the next section with pattern matching.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/>Advanced type usage</h1>
<p>In this final section of this chapter, we’ll see how new and old language features help you build better types.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>Exploring pattern matching</h2>
<p>It turns out that we can use the same style of syntax we used with expressions earlier to conditionally match <a id="_idIndexMarker646"/>different objects through <strong class="bold">pattern matching</strong>.</p>
<p>To explain what I mean, let’s start with an example that loops over different boarding passes:</p>
<pre class="source-code">
List&lt;BoardingPass&gt; passes = PassGenerator.Generate();
foreach (BoardingPass pass in passes) {
  if (<strong class="bold">pass is { Group: 1 or 2 or 3,</strong>
<strong class="bold">                Flight.Status: FlightStatus.Pending</strong>
<strong class="bold">              }) </strong>{
    Console.WriteLine($"{pass.Passenger} board now");
  } else if (<strong class="bold">pass is { Flight.Status: FlightStatus.Active</strong>
<strong class="bold">                       or FlightStatus.Completed</strong>
<strong class="bold">                     }</strong>) {
    Console.WriteLine($"{pass.Passenger} flight missed");
  } else {
    Console.WriteLine($"{pass.Passenger} please wait");
  }
}</pre>
<p>This code loops over a collection of boarding passes and does one of three things:</p>
<ul>
<li>If the flight is <code>Pending</code> and the passenger is in group 1, 2, or 3, we tell them to board</li>
</ul>
<p>If the flight is <code>Active</code> or <code>Completed</code>, we tell the passenger they missed their flight</p>
<p>If neither of these cases is true, the flight must be <code>Pending</code>, but the passenger’s group is not boarding, so we tell them to wait</p>
<p>The code is a little arbitrary, particularly in how it deals with the boarding group, but it illustrates some of the capabilities of pattern matching.</p>
<p>Using pattern matching, you can evaluate one or more properties on an object in an <code>if</code> statement to concisely check multiple things at once.</p>
<p>While you can use pattern matching in <code>if</code> statements, they are also commonly used in switch expressions, as we saw in <a href="B21324_03.xhtml#_idTextAnchor045"><em class="italic">Chapter 3</em></a>. We could rewrite our code from earlier into a switch <a id="_idIndexMarker647"/>expression, as follows:</p>
<pre class="source-code">
List&lt;BoardingPass&gt; passes = PassGenerator.Generate();
foreach (BoardingPass pass in passes) {
<strong class="bold">  </strong><strong class="bold">string message = pass switch {</strong>
<strong class="bold">    { Flight.Status: FlightStatus.Pending,</strong>
<strong class="bold">      Group: 1 or 2 or 3 }</strong>
<strong class="bold">      =&gt; $"{pass.passenger} board now",</strong>
<strong class="bold">    { Flight.Status: not FlightStatus.Pending }</strong>
<strong class="bold">      =&gt; $"{pass.passenger} flight missed",</strong>
<strong class="bold">      _ =&gt; $"{pass.passenger} please wait",</strong>
<strong class="bold">  };</strong>
  Console.WriteLine(message);
}</pre>
<p>Here, we can see the switch expressions concept combined with the power of pattern matching to set a string in the <code>message</code> variable. Note that the code uses <code>not FlightStatus.Pending</code> instead of <code>FlightStatus.Active or FlightStatus.Completed</code> for brevity and to illustrate the usage of the <code>not</code> keyword in negating or inverting pattern matching expressions.</p>
<p>While this code takes some adjustment to learn to read, there’s also very little “waste” in this syntax. Almost the entirety of every line of code is centered around either the conditions that must be true or the value to use when they are true. Additionally, this syntax can handle more complex scenarios such as or and not statements more easily than normal C# logic can.</p>
<p>Of course, as with any new C# language feature, if the readability cost is too high for you and your team, you are free to avoid switch expressions and pattern matching entirely.</p>
<p>Now that we’ve seen<a id="_idIndexMarker648"/> how pattern matching and switch expressions work together in the latest versions of C#, let’s look at one of C#’s earliest enhancements: generics.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/>Using generics to reduce duplication</h2>
<p><strong class="bold">Generics</strong> are a concept that every .NET developer encounters and works with daily.</p>
<p>When you work with <code>List&lt;string&gt;</code> (pronounced “list of strings”), you are working with a generic <code>List</code> object that can hold something of a specific type – in this case, strings.</p>
<p>Generics work by specifying at least one type parameter that goes into either a class or a method and allows the class or method to be structured around that type.</p>
<p>To illustrate the advantage of generics, let’s look at a very simple <code>FlightDictionary</code> class that stores <code>FlightInfo</code> objects by their identifiers using a dictionary and incorporates some light console logging:</p>
<pre class="source-code">
public class FlightDictionary {
  private readonly Dictionary&lt;string, FlightInfo&gt; _items =
    new();
  public bool Contains(string identifier)
    =&gt; _items.ContainsKey(identifier);
  public void AddItem(string id, FlightInfo item) {
    Console.WriteLine($"Adding {id}");
    _items[id] = item;
  }
  public FlightInfo? GetItem(string id) {
    if (Contains(id)) {
      Console.WriteLine($"Found {id}");
      return _items[id];
    }
    Console.WriteLine($"Could not find {id}");
    return null;
  }
}</pre>
<p>This class is the beginning of a new collection class, like the <code>Dictionary</code> class provided by .NET. It allows external callers to add, retrieve, and check for <code>FlightInfo</code> by a string identifier.</p>
<p>While this code is very simple and missing several features I’d expect from a real collection class, it should serve to illustrate the need for generics by asking the following question: What happens if <a id="_idIndexMarker649"/>we like this class so much for <code>FlightInfo</code> objects that we want to use something like it for <code>BoardingPass</code> objects?</p>
<p>Often, this would result in someone copying and pasting the <code>FlightDictionary</code> class to create a new <code>BoardingPassDictionary</code>, as shown here:</p>
<pre class="source-code">
public class BoardingPassDictionary {
  private readonly Dictionary&lt;string, BoardingPass&gt; _items
    = new();
  public bool Contains(string identifier)
    =&gt; _items.ContainsKey(identifier);
  public void AddItem(string id, BoardingPass item) {
    Console.WriteLine($"Adding {id}");
    _items[id] = item;
  }
  public BoardingPass? GetItem(string id) {
    if (Contains(id)) {
      Console.WriteLine($"Found {id}");
      return _items[id];
    }
    Console.WriteLine($"Could not find {id}");
    return null;
  }
}</pre>
<p>The only difference between these two classes is the type of item being stored.</p>
<p>What generics let us do is declare a class that takes in parameters of the types it should use for different operations.</p>
<p>Now, let’s look at a more reusable version of this class that accepts generic type parameters for the type<a id="_idIndexMarker650"/> used as a key for each item, as well as the type used as a value:</p>
<pre class="source-code">
public class LoggingDictionary<strong class="bold">&lt;TKey, TValue&gt;</strong> {
  private readonly Dictionary&lt;<strong class="bold">TKey, TValue</strong>&gt; _items
    = new();
  public bool Contains(<strong class="bold">TKey</strong> identifier)
    =&gt; _items.ContainsKey(identifier);
  public void AddItem(<strong class="bold">TKey</strong> id, <strong class="bold">TValue</strong> item) {
    Console.WriteLine($"Adding {id}");
    _items[id] = item;
  }
  public <strong class="bold">TValue?</strong> GetItem(<strong class="bold">TKey</strong> id) {
    if (Contains(id)) {
      Console.WriteLine($"Found {id}");
      return _items[id];
    }
    Console.WriteLine($"Could not find {id}");
    return <strong class="bold">default(TValue);</strong>
  }
}</pre>
<p>This implementation of the class depends on two generic type arguments: <code>TKey</code> and <code>TValue</code>. These parameters can<a id="_idIndexMarker651"/> be whatever names you want them to be, but the<a id="_idIndexMarker652"/> convention is to use <code>T</code>.</p>
<p>With this class, a new <code>LoggingDictionary</code> can be created for any types you might want to support using the following syntax:</p>
<pre class="source-code">
LoggingDictionary&lt;string, BoardingPass&gt; passDict = new();
LoggingDictionary&lt;string, FlightInfo&gt; flightDict = new();</pre>
<p>Generics are something that has been around since .NET Framework 2.0 but still offers value today in adding reusability to classes.</p>
<p>Let’s close this chapter out with a brief look into a new C# 12 feature: <strong class="bold">type aliases</strong>.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>Introducing type aliases with the using directive</h2>
<p>Let’s say you’re<a id="_idIndexMarker653"/> developing a system and you need to work with a set of data<a id="_idIndexMarker654"/> types you’re not certain about and may need to change in the future. Alternatively, you might have a routine need for some hideous-looking types, such as needing to deal with <code>List&lt;string, Dictionary&lt;Passenger, List&lt;FlightInfo&gt;&gt;&gt; </code>throughout a class.</p>
<p>While one approach for the latter problem might be to introduce your class to hide away some of this complexity, a new option in C# 12 is to use <code>using</code> statement.</p>
<p>Let’s look at simplifying some of the code in <code>CloudySkiesFlightProvider.cs</code> to reduce the places where <code>IEnumerable&lt;FlightInfo&gt;</code> appears. We’ll use the <code>GetFlightsByMiles</code> method as<a id="_idIndexMarker655"/> an example:</p>
<pre class="source-code">
public <strong class="bold">IEnumerable&lt;FlightInfo&gt;</strong> GetFlightsByMiles(
  int maxMiles, string apiKey) {
  RestRequest request =
    new($"/flights/uptodistance/{maxMiles}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
  <strong class="bold">IEnumerable&lt;FlightInfo&gt;?</strong> response =
    _client.Get&lt;<strong class="bold">IEnumerable&lt;FlightInfo&gt;</strong>&gt;(request);
  return response ?? Enumerable.Empty&lt;FlightInfo&gt;();
}</pre>
<p>This code isn’t bad, but imagine that you felt very strongly that you didn’t like looking at <code>IEnumerable&lt;FlightInfo&gt;</code> everywhere and you’d rather have a custom type defined for this.</p>
<p>Using C# 12, you could add the <a id="_idIndexMarker656"/>following line to the <code>using</code> statements in the file:</p>
<pre class="source-code">
using Flights = System.Collections.Generic.IEnumerable&lt;
Packt.CloudySkiesAir.Chapter10.FlightInfo&gt;;</pre>
<p>With this one change, you can now change your method to use your new type alias:</p>
<pre class="source-code">
public <strong class="bold">Flights</strong> GetFlightsByMiles(int maxMiles,
  string apiKey) {
  RestRequest request =
    new($"/flights/uptodistance/{maxMiles}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
  <strong class="bold">Flights?</strong> response = _client.Get&lt;<strong class="bold">Flights</strong>&gt;(request);
  return response ?? Enumerable.Empty&lt;FlightInfo&gt;();
}</pre>
<p>This code doesn’t change that you’re dealing with <code>IEnumerable&lt;FlightInfo&gt;</code> in this method, but it does reduce<a id="_idIndexMarker657"/> the amount of code you have to type and simplifies the code for reading.</p>
<p>Additionally, if you ever <a id="_idIndexMarker658"/>wanted to change to a different type in these places, you now just need to modify the <code>using</code> statement to use a different type instead.</p>
<p>I’m not sure if obscuring the underlying type offers more benefit than potential confusion, but I could see some places where it might be helpful, particularly in dealing with complex generic types or working with tuples (collections of multiple values).</p>
<p>Time will tell on the effectiveness of type aliases and the best places to use them, but I’m glad we now have the option.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/>Summary</h1>
<p>In this chapter, we looked at a variety of ways of ensuring your classes are safe and reusable through means such as argument validation, caller member information, nullability analysis, and using modern C# features such as record classes, primary constructors, pattern matching, and enhanced properties with the <code>required</code> and <code>init</code> keywords.</p>
<p>These language features help you detect issues earlier in development, work with objects more effectively, and write fewer lines of code overall.</p>
<p>This concludes <em class="italic">Part 2</em> of this book. In <em class="italic">Part 3</em>, we’ll look at how AI and code analysis tools can help you and your team sustainably build better software.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/>Questions</h1>
<p>Answers the following questions to test your knowledge of this chapter:</p>
<ol>
<li>How can throwing exceptions be beneficial to your code?</li>
<li>What are the various ways you can declare a property in C#?</li>
<li>What are the various ways you can instantiate an object in C#?</li>
<li>What are the differences between classes and record classes?</li>
</ol>
<h1 id="_idParaDest-235"><a id="_idTextAnchor234"/>Further reading</h1>
<p>You can find more information about features discussed in this chapter at these URLs:</p>
<ul>
<li><em class="italic">Guard Clauses </em><em class="italic">library</em>: <a href="https://github.com/ardalis/GuardClauses">https://github.com/ardalis/GuardClauses</a></li>
<li><em class="italic">Fluent Validation </em><em class="italic">library</em>: <a href="https://github.com/FluentValidation/FluentValidation">https://github.com/FluentValidation/FluentValidation</a></li>
<li><em class="italic">Caller Member </em><em class="italic">Information</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information</a></li>
<li><em class="italic">Primary constructors and using </em><em class="italic">aliases</em>: <a href="https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/">https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/</a></li>
<li><em class="italic">Safer Nullability in Modern </em><em class="italic">C#</em>: <a href="https://newdevsguide.com/2023/02/25/csharp-nullability/">https://newdevsguide.com/2023/02/25/csharp-nullability/</a></li>
<li><em class="italic">Classes, structs, and records in </em><em class="italic">C#</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/</a></li>
<li><em class="italic">Choosing Between Exceptions or </em><em class="italic">Validation: </em><a href="https://ardalis.com/guard-clauses-and-exceptions-or-validation/">https://ardalis.com/guard-clauses-and-exceptions-or-validation/</a></li>
</ul>
</div>


<div><h1 id="_idParaDest-236" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor235"/>Part 3: Advanced Refactoring with AI and Code Analysis</h1>
<p>The third part of this book focuses on advanced refactoring techniques using artificial intelligence and modern code analysis capabilities built into Visual Studio.</p>
<p>This chapter introduces GitHub Copilot Chat as a way to refactor, generate, inspect, document, and test code.</p>
<p>We then extensively cover the code analysis capabilities of Visual Studio by introducing the code analysis tooling and rulesets as well as some third-party tools that can help catch additional issues. Finally, we explore how Visual Studio’s code analysis is based on Roslyn Analyzers by building and deploying our own Roslyn Analyzer as both a Visual Studio extension and as a NuGet package.</p>
<p>This chapter will give you a deep understanding of code analysis issues as well as new productivity tools to help detect and resolve issues in their code.</p>
<p>This part contains the following chapters:</p>
<ul>
<li><a href="B21324_11.xhtml#_idTextAnchor236"><em class="italic">Chapter 11</em></a><em class="italic">, AI-Assisted Refactoring with GitHub Copilot</em></li>
<li><a href="B21324_12.xhtml#_idTextAnchor259"><em class="italic">Chapter 12</em></a><em class="italic">, Code Analysis in Visual Studio</em></li>
<li><a href="B21324_13.xhtml#_idTextAnchor275"><em class="italic">Chapter 13</em></a><em class="italic">, Creating a Roslyn Analyzer</em></li>
<li><a href="B21324_14.xhtml#_idTextAnchor297"><em class="italic">Chapter 14</em></a><em class="italic">, Refactoring Code with Roslyn Analyzers</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>