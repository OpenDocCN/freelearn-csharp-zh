<html><head></head><body>
        

                            
                    <h1 class="header-title">Aggregate Persistence</h1>
                
            
            
                
<p>We have spent enough time discussing how to ensure domain model consistency with explicitly defined business rules. In this chapter, we will go further with persisting our aggregates to the database. Since our model is not being designed around any database, we might encounter issues when trying to get a complex object graph to be stored by using a database engine. That's because the database does not work with objects. Instead, relational databases are optimized to store data in tables that might have relations that use primary and foreign keys. Document databases store objects in machine-readable formats, like JSON, and are, by definition, able to persist complex object graphs as-is; however, we shouldn't fool ourselves, since there are still serious constraints about how these objects need to be organized so that the database client library can convert our objects to JSON and back. All these differences between having a domain object to persist on one side and a database engine with all its quirks and tweaks on the other side, will create challenges for developers.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The repository pattern</li>
<li>Impedance mismatch</li>
<li>Using a document database for persistence</li>
<li>Using a relational database for persistence</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The code for this chapter can be found in the <kbd>Chapter08</kbd> folder of the book repository on GitHub. There are three subfolders there. One is called <kbd>before</kbd>, and the code there can be used to follow the course of this chapter as it goes further with the persistence implementation. Two other folders, <kbd>ravendb</kbd> and <kbd>ef-core</kbd>, contain the final code that implements the aggregate persistence using the RavenDB document database and the Entity Framework Core and PostgreSQL.</p>
<p class="mce-root"/>
<p>You will need to use <kbd>docker-compose</kbd> to run the infrastructure. This implies that you need to have Docker installed, as well. Follow the Docker CE installation guidelines at <a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a> and the Docker Compose installation guidelines at <a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a>.</p>
<p>If you have not run Docker on your machine before, or if you did it a while ago, you might need to log in using the <kbd>docker login</kbd> command. For that command, you need to have an account on Docker Hub, which you can create for free at <a href="https://hub.docker.com">https://hub.docker.com</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aggregate persistence</h1>
                
            
            
                
<p>Now that we have discussed in detail how complex object graphs with complex business rules can be implemented using the <strong>a</strong><strong>ggregate</strong> pattern, we need to look at how to enable persistence for the aggregates that we use in our system. In the previous chapter, we briefly looked at the <strong>repository</strong> pattern that allows us to abstract persistence from the domain. We also started implementing an implementation of the persistence layer by using the RavenDB document database, since it's easier to save complex objects as documents. However, we also learned that we will most likely face impedance mismatch when trying to comply with the requirements that a chosen persistence method might have for our objects, so that we can both save them to the database and retrieve them back.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Repository and units of work</h1>
                
            
            
                
<p>Let's go back to the point where we used the repository pattern to persist our aggregates. As you will remember, the purpose of the repository pattern is to abstract aggregate persistence. That is exactly what we are going to do now. We still have the repository interface, and it looks like this:</p>
<pre class="language-csharp">public interface IClassifiedAdRepository  
{  
    Task&lt;ClassifiedAd&gt; Load(ClassifiedAdId id);  
    Task Save(ClassifiedAd entity);
}</pre>
<p>The repository pattern is one of the most debated patterns that exists, and to understand why that is, we need to get back to the definition. For example, this is how this pattern is defined in the <em>Patterns of Enterprise Application Architecture</em> book by Martin Fowler (extract taken from <a href="https://martinfowler.com/eaaCatalog/repository.html">https://martinfowler.com/eaaCatalog/repository.html</a>).  It's recommended that you have a look at the definition given on that page.</p>
<p class="mce-root"/>
<p>The diagram that you can find on the web page that we mentioned earlier shows that a client can ask a repository to retrieve a set of objects that satisfy certain criteria. The client can also add and remove objects from the repository.</p>
<p>The debate about repositories generally involves the fact that in many cases, developers also implement a repository as a unit of work. In addition, it is quite common to see <em>generic repositories</em>, like this:</p>
<pre class="language-csharp">public interface IRepository&lt;T&gt;
{
    void GetById(int id); void Save(T);
    IEnumerable&lt;T&gt; Query(Func&lt;T, bool&gt; filter);
}</pre>
<p>The <kbd>Query</kbd> method allows for sending a lambda expression to a typed repository, and the generic repository implementation will then send the query to the underlying ORM framework or document database API, without much thinking.</p>
<p>This approach makes people think that repositories are just unnecessary abstractions on top of ORM frameworks. Many argue that when developers send a free-form query and leave it to the ORM framework to translate this query to an SQL statement, it creates a sense of ignorance of the database technology for developers, and it rarely ends well. We cannot just ignore the database and send any query to it, because it can lead to performance issues, due to a lack of query optimization. For some document databases, this approach might not even work, because the database requires having a predefined index to execute queries. RavenDB can create automatic indexes based on any query, but it is not recommended, for performance reasons. For relational databases, using LINQ query translators via ORMs can lead to suboptimal queries that can severely impact not only the application performance, but the performance of the database server itself.</p>
<p>At the same time, if we decide not to have repositories, we might end up dealing with persistence when designing our domain model, and that should not be the case. A domain model exists on its own, and it is designed to deal with business rules and invariants, and not to deal with the database.</p>
<p>Eric Evans insists that querying repositories must happen by using predefined specifications and not by sending any queries. These specifications need to use the Ubiquitous Language to express the intent of a client to retrieve a set of objects from the repository.</p>
<p class="mce-root"/>
<p>For example, we must prefer using <kbd>IEnumerable&lt;ClassifiedAd&gt; GetAdsPendingReview()</kbd> or <kbd>IEnumerable&lt;ClassifiedAd&gt; Query(Specifications.GetAdsPendingReview)</kbd> over a generic call, like <kbd>IEnumerable&lt;ClassifiedAd&gt; Query(x =&gt; x.State == ClassifiedAdState.PendingReview)</kbd>. One reason for it is to make queries more expressive and use the domain language. Another reason is to let the repository decide how to execute that particular query, since we have control over all queries that can be used by the client. The last reason is that we put the query conditions inside the specification, or inside the repository method, so we are free to change those rules if needed, and those rules are only defined in one place.</p>
<p>So, if we spend less time arguing about repositories and more time understanding the original definitions, we'll see that executing queries using a specification is not equal to shoving queries to ORMs, but involves executing specific queries that are named following the Ubiquitous Language and are optimized to work with the database that our application intends to use.</p>
<p>Let's see how we can change our repository to be closer to the original definition. First, we need to get rid of the <kbd>Save</kbd> method, since it is the repository client (our application service) that will control the unit of work and will have a final say on whether changes need to be committed to the database. Then, we add at least one query that we will need in the application service when we check if an object already exists in the database:</p>
<pre class="language-csharp">using System.Threading.Tasks;

namespace Marketplace.Domain
{
    public interface IClassifiedAdRepository
    {
        Task&lt;ClassifiedAd&gt; Load(ClassifiedAdId id);

        Task Add(ClassifiedAd entity);
        
        Task&lt;bool&gt; Exists(ClassifiedAdId id);
    }
}</pre>
<p>With this interface, we have no ability for the repository implementation to control transactions, and that will become the responsibility of our application layer. We don't still want our application service to be directly coupled to the persistence layer, following the ports and adapters architecture.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation for RavenDB</h1>
                
            
            
                
<p>Now, let's start doing stuff with a real database; our first exercise will be using the RavenDB document database. This database was created with the NHibernate API in mind, but without the burden of object-relational mapping. It stores objects as JSON documents, supports transactions, and can handle queries on stored documents using quite complex filters. RavenDB is a commercial product, but it has a free license option, which is perfectly suitable to build a small application and put it into production.</p>
<p>The choice of RavenDB for this book may not be obvious for some readers. Apparently, MongoDB would be a better choice in terms of popularity. Also, Azure Cosmos DB has the Mongo API and it makes the MongoDB driver more attractive to use in the sample app. At the same time, RavenDB has quite a lot of traction in the .NET community, and it also has a best-in-class web user interface that will be really helpful for seeing what is going on in the database as we move along with this chapter.</p>
<p>The choice of a document database is based on the fact that a document database has much less impedance mismatch as compared with relational databases, since document databases manipulate with objects, unlike relational databases, which deal with tables and relations.</p>
<p>We will start by implementing the repository interface with RavenDB persistence, in order to save and load individual aggregates.</p>
<p>To make things a bit more explicit, we can move the infrastructural parts, like database-specific classes, to a new folder in the <kbd>Marketplace</kbd> project, called <kbd>Infrastructure</kbd>.</p>
<p>Since we have already implemented our repository for RavenDB, we can start there. But now, we want to remove the <kbd>Save</kbd> method, because we want to remove the commit responsibility to the unit of work. Also, we can now move this file to the new <kbd>Infrastructure</kbd> folder. To implement the new repository interface, we need to make minor changes, so our code will look like this:</p>
<pre class="language-csharp">using System;
using System.Threading.Tasks;
using Marketplace.Domain;
using Raven.Client.Documents.Session;

namespace Marketplace.Infrastructure
{
    public class ClassifiedAdRepository : IClassifiedAdRepository
    {
        private readonly IAsyncDocumentSession _session;

        public ClassifiedAdRepository(IAsyncDocumentSession session) 
            =&gt; _session = session;

        public Task Add(ClassifiedAd entity) 
            =&gt; _session.StoreAsync(entity, EntityId(entity.Id));

        public Task&lt;bool&gt; Exists(ClassifiedAdId id) 
            =&gt; _session.Advanced.ExistsAsync(EntityId(id));

        public Task&lt;ClassifiedAd&gt; Load(ClassifiedAdId id)
            =&gt; _session.LoadAsync&lt;ClassifiedAd&gt;(EntityId(id));

        private static string EntityId(ClassifiedAdId id)
            =&gt; $"ClassifiedAd/{id.ToString()}";
    }
}</pre>
<p>Here, we removed the <kbd>Save</kbd> method, and we now have the <kbd>Add</kbd> method that will only be used when we add new aggregates to the database. RavenDB uses the <em>session</em> not only to control the connection to the database, but also to track changes for objects that were added to the session by either calling the <kbd>Store</kbd> or <kbd>StoreAsync</kbd> methods for new objects or by loading existing objects from the database using the session. So, as soon as we use the <kbd>Load</kbd> or <kbd>Add</kbd> methods of our repository, the underlying session will track all changes that happen in these objects. In fact, the session itself represents the unit of work, since all changes that happened for all objects that are attached to the session will be committed to the database when we tell the session to commit changes as one transaction.</p>
<p>The ability to track and commit changes as a transaction is not an exclusive property of the RavenDB client library. For relational databases, <strong>Entity Framework</strong> (<strong>EF</strong>) and NHibernate allow for using the same technique. In particular, NHibernate also has an <kbd>ISession</kbd> interface with exactly the same abilities, since the RavenDB API was originally designed to resemble the NHibernate API quite closely. Also, the Marten (<a href="http://jasperfx.github.io/marten/">http://jasperfx.github.io/marten/</a>) open source library that uses the native ability of PostgreSQL to work with document-like structures in JSONB fields has an implementation of a session that tracks changes in connected objects.</p>
<p>To complete the abstraction, we need to have an interface for the unit of work. We can start with something like this:</p>
<pre class="language-csharp">using System.Threading.Tasks;

namespace Marketplace.Framework
{
    public interface IUnitOfWork
    {
        Task Commit();
    }
}</pre>
<p>The implementation of this interface will be quite trivial, since we are using the power of the RavenDB session to track changes in objects:</p>
<pre class="language-csharp">using System.Threading.Tasks;
using Marketplace.Framework;
using Raven.Client.Documents.Session;

namespace Marketplace.Infrastructure
{
    public class RavenDbUnitOfWork : IUnitOfWork
    {
        private readonly IAsyncDocumentSession _session;

        public RavenDbUnitOfWork(IAsyncDocumentSession session) 
            =&gt; _session = session;

        public Task Commit() =&gt; _session.SaveChangesAsync();
    }
}</pre>
<p>In order to make it work with our application service, we need to make sure that the service gets both the repository and the unit of work interfaces in its constructor as parameters. The new code for <kbd>ClassifiedAdAplicationService</kbd> looks like this:</p>
<pre class="language-csharp">using System;<br/>using System.Threading.Tasks;<br/>using Marketplace.Domain;<br/>using Marketplace.Framework;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    public class ClassifiedAdsApplicationService : IApplicationService<br/>    {<br/>        private readonly IClassifiedAdRepository _repository;<br/>        private readonly IUnitOfWork _unitOfWork;<br/>        private readonly ICurrencyLookup _currencyLookup;<br/><br/>        public ClassifiedAdsApplicationService(<br/>            IClassifiedAdRepository repository, IUnitOfWork unitOfWork,<br/>            ICurrencyLookup currencyLookup<br/>        )<br/>        {<br/>            _repository = repository;<br/>            _unitOfWork = unitOfWork;<br/>            _currencyLookup = currencyLookup;<br/>        }<br/><br/>        public Task Handle(object command) =&gt; <br/>            command switch<br/>            {<br/>                V1.Create cmd =&gt; HandleCreate(cmd),<br/>                V1.SetTitle cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.SetTitle(<br/>                            ClassifiedAdTitle.FromString(cmd.Title)<br/>                        )<br/>                    ),<br/>                V1.UpdateText cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.UpdateText(<br/>                            ClassifiedAdText.FromString(cmd.Text)<br/>                        )<br/>                    ),<br/>                V1.UpdatePrice cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.UpdatePrice(<br/>                            Price.FromDecimal(<br/>                                cmd.Price, cmd.Currency, <br/>                                _currencyLookup<br/>                            )<br/>                        )<br/>                    ),<br/>                V1.RequestToPublish cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.RequestToPublish()<br/>                    )<br/>            };<br/><br/>        private async Task HandleCreate(V1.Create cmd)<br/>        {<br/>            if (await _repository.Exists(cmd.Id.ToString()))<br/>                throw new InvalidOperationException(<br/>                    $"Entity with id {cmd.Id} already exists");<br/><br/>            var classifiedAd = new ClassifiedAd(<br/>                new ClassifiedAdId(cmd.Id),<br/>                new UserId(cmd.OwnerId)<br/>            );<br/><br/>            await _repository.Add(classifiedAd);<br/>            await _unitOfWork.Commit();<br/>        }<br/><br/>        private async Task HandleUpdate(<br/>            Guid classifiedAdId, Action&lt;ClassifiedAd&gt; operation)<br/>        {<br/>            var classifiedAd = await <br/>            _repository.Load(classifiedAdId.ToString());<br/>            if (classifiedAd == null)<br/>                throw new InvalidOperationException(<br/>                    $"Entity with id {classifiedAdId} cannot be <br/>                    found");<br/><br/>            operation(classifiedAd);<br/><br/>            await _unitOfWork.Commit();<br/>        }<br/>    }<br/>}</pre>
<p>You can see that our application service gets three dependencies, instead of the two that it had before. We added the unit of work interface so that the service can decide when to commit changes to the database. It creates the challenge of rewriting our application startup code, so we add the missing dependency. One more issue awaits us there, because our unit of work commits using the document session that it gets as a dependency to itself. The repository also depends on the document session. You might remember that the document session tracks all changes in objects that are loaded or explicitly added to the session; that is what the repository does. But we do the commit in our unit of work, and it means that the repository and the unit of work that is used in the same instance of the application service must have <em>the same</em> document session.</p>
<p>That part is quite tricky if we decide to instantiate the dependency graph ourselves. For our application, we will use the ASP.NET (<a href="https://www.asp.net/">https://www.asp.net/</a>) Core service collection to define dependencies. The service collection also works as a <strong>dependency injection</strong> container, so if we configure it properly, we get the dependencies right. The following startup code serves the purpose:</p>
<pre class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    var store = new DocumentStore
    {
        Urls = new[] {"http://localhost:8080"},
        Database = "Marketplace_Chapter8",
        Conventions =
        {
            FindIdentityProperty = m =&gt; m.Name == "_databaseId"
        }
    };
    store.Initialize();

    services.AddSingleton&lt;ICurrencyLookup, FixedCurrencyLookup&gt;();
    services.AddScoped(c =&gt; store.OpenAsyncSession());
    services.AddScoped&lt;IUnitOfWork, RavenDbUnitOfWork&gt;();
    services.AddScoped&lt;IClassifiedAdRepository, ClassifiedAdRepository&gt;();
    services.AddScoped&lt;ClassifiedAdsApplicationService&gt;();

    services.AddMvc();
    services.AddSwaggerGen(c =&gt;
    {
        c.SwaggerDoc(<br/>            "v1",
            new Info
            {
                Title = "ClassifiedAds",
                Version = "v1"
            });
    });
}</pre>
<p>This code is for the <kbd>Startup.cs</kbd> file in the <kbd>Marketplace</kbd> project. There, we register the document session using a factory delegate, <kbd>RavenDbUnitOfWork</kbd>, and <kbd>ClassifiedAdRepository</kbd> as scoped dependencies. Our application service is also registered as a scoped service. When we register any dependency as <em>scoped</em>, its lifetime will be limited by the lifetime of a single HTTP request. For our code, it means that only one document session will be instantiated for the request, and it will be used as a dependency for all other objects that are instantiated to handle the request. As a result, we will get one application service instance, one repository, and one unit of work. The last two will also get the same instance of the document session, and this is exactly what we want.</p>
<p>As a side note, I have to make it clear that the moment we encounter a strong need to have a dependency injection container to manage our dependencies and we cannot configure our dependencies manually, we need to notice that something is not going well with our code. In such a case, we need to reconsider the dependencies graph and try to simplify it so that we have less of a need, or no need, to use a container. In this particular case, we have no control over how ASP.NET Core instantiates the controller that it calls to handle HTTP requests. Therefore, we are forced to use the container. However, we will try to make the list of dependencies smaller to avoid injection hell and take back control of the request handling scope.</p>
<p>In the code for this chapter, you can also see that we have one helper method in the <kbd>ClassifiedAdCommandsApi</kbd> class, to handle HTTP requests by sending them to the application service and wrapping any exceptions that it might throw. We could have just used the developer error page provided by the web API; however, it contains a lot of HTML, and we are using Swagger, which won't render it and show the HTML source instead. It makes diagnostics harder, because we'd need to dig into a bunch of HTML tags to find the exception information and the stack trace. The method that is added is as follows:</p>
<pre class="language-csharp">private async Task&lt;IActionResult&gt; HandleRequest&lt;T&gt;(T request, Func&lt;T, Task&gt; handler)
{
    try
    {
        Log.Debug("Handling HTTP request of type {type}", <br/>        typeof(T).Name);
        await handler(request);
        return Ok();
    }
    catch (Exception e)
    {
        Log.Error("Error handling the request", e);
        return new BadRequestObjectResult(new {error = e.Message, <br/>        stackTrace = e.StackTrace});
    }
}</pre>
<p>Since we use the generic type argument here, we can send any request to this method, along with the application service <kbd>Handle</kbd> method as a delegate to handle the request. For example, the <kbd>Post</kbd> method in our controller now looks like this:</p>
<pre class="language-csharp">public ClassifiedAdsCommandsApi(
    ClassifiedAdsApplicationService applicationService)
    =&gt; _applicationService = applicationService;</pre>
<p>You probably noticed that the <kbd>HandleRequest</kbd> method uses logging, as well. In this book, we use the <kbd>Serilog</kbd> open source logging library, which was the first library that provided structured logging to the .NET space and quickly became the most popular logging library for the .NET space.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Our initial stage of preparing to save our aggregate to RavenDB is complete. For the next step, we need to get RavenDB running, and the easiest way to do it is to use Docker Compose with the configuration file that is provided in the book repository for this chapter. The <kbd>docker-compose.yml</kbd> file contains instructions for Docker Compose to start two containers—one is RavenDB, and another one is PostgreSQL, which we will use later in this chapter, when we explore using relational databases to persist aggregates.</p>
<p>You should be able to run the <kbd>docker-compose up</kbd> command from the chapter folder in the Terminal window, and you will see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3f931305-f508-4a91-aa7e-761481004004.png" style="width:58.25em;height:31.67em;"/></p>
<p>The Terminal output of the docker-compose command</p>
<p>If you have any issues when executing the command, please check the <em>Technical requirements</em> section for this chapter.</p>
<p>Remember that you can stop your <kbd>docker-compose</kbd> session by pressing <em>Ctrl </em>+ <em>C</em> in the Terminal window where it runs, and in that case, the containers will be stopped. All data inside the containers will be kept, so when you use <kbd>docker-compose up</kbd> next time, you will see your databases again. If you use <kbd>docker-compose down</kbd>, the containers will be removed, and when you start them again, you will need to create the databases again. If you want to keep the data no matter what, consider specifying volumes in the <kbd>docker-compose.yml</kbd> file.</p>
<p>When you have RavenDB up and running for the first time, or any time the container gets recreated, you need to visit the database web UI by going to <kbd>http://localhost:8080</kbd> and accepting the license agreement. RavenDB is free to use for development and in small-scale production systems. When you accept the agreement, you will be redirected to the RavenDB Studio page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7fa93254-2121-4311-93dc-1fe340c7aa65.png" style="width:53.33em;height:35.08em;"/></p>
<p>RavenDB user interface</p>
<p>Before we can save anything to RavenDB, we need to create a database. For this chapter, the database name in the sample application code is hardcoded to <kbd>Marketplace_Chapter8</kbd>. To create a new database, you can use the CREATE DATABASE button on the RavenDB Studio home page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/09e6b198-25aa-426d-b387-5f9f57275f9c.png" style="width:36.17em;height:10.58em;"/></p>
<p>This button lets you create a new database</p>
<p>When you click on this button, you will get a popup where you can enter the database name and click on Create:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4b2af2ef-cc81-4973-b99a-249c8314fe00.png" style="width:44.75em;height:21.00em;"/></p>
<p>New database creation screen</p>
<p>Now, we can start our sample application. After the application starts, it produces output similar to this:</p>
<pre class="language-">Hosting environment: Development
Content root path: ~/github/ddd-book/chapter8/Marketplace/bin/Debug/netcoreapp2.2
Now listening on: http://localhost:5000
Application started. Press Ctrl+C to shut down.</pre>
<p>By default, any ASP.NET Core application would start listening on <kbd>http://localhost:5000</kbd>. There is no user interface in our app, but we have the Swagger UI to send requests to the API added to the application configuration. Therefore, if you visit the <kbd>http://localhost:5000/swagger/index.html</kbd> page, you will see all the API endpoints that we have created so far:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/61c9dd34-d8d8-402a-bbf4-e7a7b28b7a8d.png" style="width:44.83em;height:35.17em;"/></p>
<p>Command API of the Swagger UI</p>
<p>Finally, we get very close to send commands to our application and see how it will work. First things first; before doing any updates, we need to create our first aggregate. So, we can click on the POST and then the Try it out button. We will get two fields to fill out with new GUIDs, which can easily be generated by an online GUID generator, or a similar tool that is available in JetBrains Rider or Visual Studio.</p>
<p>After entering two newly generated GUIDs into the parameter fields for a new <kbd>POST</kbd> request, you can press the Execute button, and after a short while, you will get a response:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f38ffdbd-921f-49d7-9147-ce1310d63733.png" style="width:61.42em;height:64.83em;"/></p>
<p>An exception is thrown when we try executing the command</p>
<p>But wait; we have an error! Let's look at what the error message tells us about what happened:</p>
<pre class="language-">Cannot set identity value 'ClassifiedAd/302790d5-735e-445e-a042-b5891ad3cf1f' on property 'Id' for type 'Marketplace.Domain.ClassifiedAd' because property type is not a string.</pre>
<p>Here, we have our first example of impedance mismatch. We have been modeling our domain classes without considering persistence and we have based all decisions on the structure of our classes only on the requirements for the domain. As soon as we started working with a database, although this database is document-based, and in theory, should persist any object we give it, the reality is a bit different. Now, we are forced to start adapting our domain classes in a way that they can be persisted. That is quite unfortunate, because ideally, we should keep our domain model implementation clean of any persistence concerns.</p>
<p>But, let's look at what we can do now. RavenDB requires any document that is being saved there to have an identity property or field of the type string. We are using the <kbd>ClassifiedAdId</kbd> value object type for the identity property. We explicitly tell RavenDB the object identity in our repository <kbd>Add</kbd> method, so it doesn't use the <kbd>Id</kbd> property for that. However, it failed to write the string value back to the <kbd>Id</kbd> field, because it is not the string. This can only be fixed by adding a new property or field with the type string to our aggregate class. RavenDB uses the name <kbd>Id</kbd> for the identity property, but we can configure conventions so that the database client API will use something else, instead.</p>
<p>We can start fixing the issue by adding a new <kbd>private</kbd> field to the <kbd>ClassifiedAd</kbd> class:</p>
<pre class="language-csharp">public class ClassifiedAd : AggregateRoot&lt;ClassifiedAdId&gt;
{
    // Properties to handle the persistence
    private string DbId
    {
        get =&gt; $"ClassifiedAd/{Id.Value}";
        set {}
    }
    
    // Aggregate state properties</pre>
<p>It might seem weird that we don't use the property setter, but the database will read the <kbd>Id</kbd> property as an object, and we will get the value back. So, we can safely use the <kbd>Id</kbd> property for the <kbd>get</kbd> part, and <kbd>set</kbd> will only be used to keep the database happy.</p>
<p>We also need to explain to the database API that it needs to use this new property as the document identity. It is done by using conventions when we create the <kbd>DocumentStore</kbd> instance in <kbd>Startup.cs</kbd>:</p>
<pre class="language-csharp">var store = new DocumentStore
    {
        Urls = new[] {"http://localhost:8080"},
        Database = "Marketplace_Chapter8",
        Conventions =
        {
            FindIdentityProperty = x =&gt; x.Name == "DbId"
        }
    };
store.Initialize();</pre>
<p>Now, let's start the application again and repeat the call from Swagger. We can use the same values, so if you kept the browser window open while changing the code, you can just execute the same request that previously generated an error. Now, the response is different:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/84c0bd6e-2209-4960-ace7-a7fa5e9e2ae8.png" style="width:48.75em;height:14.75em;"/></p>
<p>Getting 200 OK means everything worked</p>
<p>To confirm that our persistence code worked, we need to turn to the RavenDB Studio again, and if we open the database there, we will have one document that represents the state of the new aggregate:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d1b43618-6612-4e89-8da7-eafdf4ae3aac.png" style="width:58.50em;height:30.83em;"/></p>
<p>The document is successfully stored</p>
<p>For the next step, we can execute one of the commands that perform state changes on an existing aggregate. To start, we can set the ad title by calling the <kbd>/ad/name/</kbd> API endpoint with <kbd>PUT</kbd>. We need to use the same aggregate ID that we used for the <kbd>POST</kbd> call, since that's the only object we currently have in the system. In the following screenshot, you can see when the action has already been executed and the API has returned a <kbd>200 OK</kbd> status:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/79986107-368e-4676-9272-d11f3fe32de0.png" style="width:55.00em;height:34.42em;"/></p>
<p>Successful execution of the update command</p>
<p>Let's check what happened with the document in RavenDB. If the document was still open in the Studio, you will see a small popup saying, This document has been modified outside of the studio. Click here to refresh. You can go on and click on the link so that the document gets refreshed and the new version shows up. Now, we can see that the document content has changed and the <kbd>Title</kbd> property has a proper value (further, I will only use the document content as JSON):</p>
<pre class="language-json">{
    "OwnerId": {
        "Value": "83508629-d2ee-4798-9ac5-b5bbc3e57731"
    },
    "Title": {
        "Value": "Green sofa"
    },
    "Text": null,
    "Price": null,
    "State": "Inactive",
    "ApprovedBy": null,
    "Pictures": [],
    "FirstPicture": null,
    "Id": {
        "Value": "302790d5-735e-445e-a042-b5891ad3cf1f"
    },
    "@metadata": {
        "@collection": "ClassifiedAds",
        "Raven-Clr-Type": "Marketplace.Domain.ClassifiedAd, <br/>        Marketplace.Domain"
    }
}</pre>
<p>Now, let's try to call other endpoints. You can even try calling the same endpoint again, so that it tries to set the title to some other value. Surprisingly, this won't work. We can see the following error message:</p>
<pre class="language-">Could not convert document ClassifiedAd/7b0a443f-af9b-4f0d-8876-7896c9921cbc to entity of type Marketplace.Domain.ClassifiedAd.ClassifiedAd</pre>
<p>This message is not very informative, but what RavenDB is trying to tell us is that we have a serialization issue. Let's look at what the inner exception could tell us. The message here is as follows:</p>
<pre class="language-">Unable to find a constructor to use for type Marketplace.Domain.ClassifiedAd.ClassifiedAdTitle. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute. Path 'Title.Value'.</pre>
<p>The issue here is that since we are only allowing our value objects to be created using factory methods in order to prevent the creation of value objects with invalid content. When we bypass the validation the serializer will not use it unless we put an <kbd>[JsonConstructor]</kbd> attribute on it. We definitely don't want to do that, because by doing so, our domain model will take a dependency on the <kbd>Newtonsoft.Json</kbd> library, which is a purely infrastructural concern. The only way to avoid this without compromising the purity of our domain project is to create a parameterless private constructor. It will allow us to keep the encapsulation and satisfy the serializer at the same time. This is yet another issue with a mismatch between the persistence layer and the domain layer.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's solve the issue by adding this line of code to the <kbd>ClassifiedAdTitle</kbd> class:</p>
<pre class="language-csharp">// Satisfy the serialization requirements
protected ClassifiedAdTitle() { }</pre>
<p>Similar lines need to be added to all value object types, except for the identity types, because they already have public constructors with one parameter of <kbd>Guid</kbd>, and the serializer is happy to use it. After all these changes are done, all of the HTTP endpoints will start to work.</p>
<p>So, we can now conclude that the small changes that we made to overcome the impedance mismatch worked fine. You may have already noticed that all properties that have value object types are stored as a JSON object. This is a nice feature of any document database that can store and retrieve complex object graphs as one document.</p>
<p>It is possible to take a similar approach to implementing the persistence by using other types of document storage that support sessions and change tracking within a session. I already mentioned Marten earlier in this chapter. However, for other document databases, like MongoDB or Cosmos DB, you would need to step away from collection-style repositories and start committing updates from inside the repository, instead of using the unit of work. Such an approach might look as <em>not-by-the-book</em>, and because of that, developers sometimes feel guilty when implementing it. However, if we remember that an aggregate must be seen as a transactional boundary, there is no chance that you would need to update multiple objects within one transaction. If this rule is violated, then you might have a bigger issue than just having a <kbd>Save</kbd> method in your repository interface. But, when we only operate on one aggregate in the application service, the whole story with a separate unit of work starts to feel redundant. When our application services conform to the pattern of <em>load-act-save</em>, there might not be a practical reason to separate repositories from the unit of work. The application service will still be in charge of committing changes, but it can do it by calling the <kbd>_repository.Save()</kbd>, just as it calls <kbd>_unitOfWork.Commit()</kbd> in our code. We will look more closely at the repository pattern and its usefulness when we start discussing event-based persistence, in <a href="75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml" target="_blank">Chapter 10</a>, <em>Event Sourcing</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation of Entity Framework Core</h1>
                
            
            
                
<p>Although nowadays, developers have a wide choice of databases, in many cases, a relational database is still preferred. The reasons for this can be different, but the most popular ones include that some RDBMS databases, like Oracle or Microsoft SQL Server, are already used in the organization, and there are people available who can maintain it, or the development team itself has vast experience in working with relational databases. Of course, it often creates issues, due to the risk for domain models to quickly become data models, and the whole application would be built around the persistence.</p>
<p>Relational databases are also notorious for having a significant impedance mismatch. Although developers often tend to think that classes can be perfectly stored in tables, and relations between classes can be represented as foreign keys, that's not the whole picture. We will see this very soon, after the first iteration of the persistence implementation for our single aggregate is complete.</p>
<p>To overcome the impedance mismatch and make the persistence for relational databases more transparent for developers that work with objects, our industry invented a solution. Most of us are familiar with the <strong>object-relational mappers</strong> (<strong>ORM</strong>) that promise to transparently put objects into the database and retrieve them back. In the .NET space, in particular, we have two major ORM frameworks that are widely used. These frameworks are NHibernate and Entity Framework. NHibernate has a long history, and it was started as a clone of a popular Java ORM framework (Hibernate). For several years, NHibernate was the only ORM tool for the .NET space. Then, after a failed attempt from Microsoft to enter the ORM space with LINQ2SQL, the Entity Framework was born. Criticized by many for being slow, rigid, and not well designed, it nevertheless quickly became the tool of choice for many .NET developers, for the single reason that it was backed by Microsoft. Entity Framework also delivered the first visual designer tool that allowed for creating  class models mapped to the persistence layer by drag and drop. After a few years of continuous improvement of the framework, Entity Framework gained a lot of adoption, and at some point, many considered NHibernate as dead. However, during the last couple of years, the NHibernate community has released version 4 with async/await support, and then version 5, with .NET Core support. The Entity Framework team has decided to step back and rethink the design, coming back with Entity Framework Core. This version is now being actively developed, and it is also included in the umbrella <kbd>Microsoft.AspNet.Core</kbd> NuGet package group, so it is directly available for all .NET Core applications.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Thanks to many members of the community that have an influence at Microsoft, like Julie Lerman, who dove deeply into DDD and its principles, and then provides a lot of valuable input for the Entity Framework team to improve their product in terms of mitigating the impedance mismatch, and support concepts like immutable value objects, out of the box. Therefore, I decided to include an example of how this framework can be used as a domain model persistence for relational databases, although this book is more oriented toward Event Sourcing.</p>
<p>The code for this part is available in the book's GitHub repository, in the folder <kbd>Chapter08/ef-core</kbd>.</p>
<p>We will be using the PostgreSQL database for this example, but the code can easily be converted for Microsoft SQL Server, since we won't be using any features that are specific to PostgreSQL. The <kbd>docker-compose.yml</kbd> file in the <kbd>ef-core</kbd> folder for this chapter will help you to start the database inside a container, just like we did with RavenDB. The initialization script will automatically be executed when the container is created. The script takes care of creating a database user and a new database called <kbd>Marketplace_Chapter8</kbd>, so you don't need to do anything before starting the application.</p>
<p>Now, let's see what we need to do to use a relational database to persist our aggregate. Since we already have the reference to the <kbd>Microsoft.AspNetCore.App</kbd> set of packages in our project, the Entity Framework Core itself is available to use straight away. We need to add a PostgreSQL driver package, called <kbd>Npgsql.EntityFrameworkCore.PostgreSQL</kbd>, to our project.</p>
<p>We need to tell the framework that it needs to map our <kbd>ClassifiedAd</kbd> class to the database. To do that, we need to create a new class, <kbd>ClassifiedAdDbContext</kbd>, in the <kbd>Infrastructure</kbd> folder of our <kbd>Marketplace</kbd> project. We will use the code-first approach and let the framework decide how the table will look and how to map the class <kbd>ClassifiedAd</kbd> properties to the table columns. Here is the first version of the class:</p>
<pre class="language-csharp">using Marketplace.Domain;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace Marketplace.Infrastructure
{
    public class ClassifiedAdDbContext : DbContext
    {
        private readonly ILoggerFactory _loggerFactory;

        public ClassifiedAdDbContext(
            DbContextOptions&lt;ClassifiedAdDbContext&gt; options,
            ILoggerFactory loggerFactory)
            : base(options) =&gt; _loggerFactory = loggerFactory;

        public DbSet&lt;ClassifiedAd&gt; ClassifiedAds { get; set; }

        protected override void OnConfiguring(<br/>            DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseLoggerFactory(_loggerFactory);
            optionsBuilder.EnableSensitiveDataLogging();
        }

        protected override void OnModelCreating(ModelBuilder <br/>        modelBuilder)
            =&gt; modelBuilder.ApplyConfiguration(<br/>                new ClassifiedAdEntityTypeConfiguration());
    }

    public class ClassifiedAdEntityTypeConfiguration <br/>        : IEntityTypeConfiguration&lt;ClassifiedAd&gt;
    {
        public void Configure(EntityTypeBuilder&lt;ClassifiedAd&gt; builder)
            =&gt; builder.HasKey(x =&gt; x.ClassifiedAdId);
    }

    public static class AppBuilderDatabaseExtensions
    {
        public static void EnsureDatabase(this IApplicationBuilder app)
        {
            var context = app.ApplicationServices<br/>                .GetService&lt;ClassifiedAdDbContext&gt;();

            if (!context.Database.EnsureCreated())
                context.Database.Migrate();
        }
    }
}</pre>
<p>We don't do a lot here. By adding a property with the type <kbd>DbSet&lt;ClassifiedAd&gt;</kbd>, we tell the framework that it needs to map that class. Then, we also explain that the property <kbd>ClassifiedAd.ClassifiedAdId</kbd> should be used as the primary key. We didn't have this property before, but we already used something similar in the previous section for RavenDB, since the database needs to know what value is used as the entity identity, and it cannot be a value object.</p>
<p>Therefore, we also need to add this property to our aggregate. We want to encapsulate as much as we can, but since we need to have access to the property from the infrastructure configuration, we are forced to make it public, at least for getting its value. Unlike with RavenDB, we cannot specify the property by its name.</p>
<p>One more thing that we do in our <kbd>DbContext</kbd> implementation is tell Entity Framework Core to do logging, and also, to log sensitive data. It will be useful for debugging purposes, as it allows us to see what Entity Framework Core does behind the scenes, including all SQL statements and parameters. Remember that you should not use <kbd>EnableSensitiveDataLogging</kbd> in production, since it exposes all data, and it might result in some sensitive data becoming exposed via log files or the logging server.</p>
<p>There is one more class in the preceding code that implements an extension for the <kbd>IApplicationBuilder</kbd>. We will use this extension to create or migrate the necessary tables. This approach also isn't good for production, since you will probably want to do the migration separately.</p>
<p>So, we need to make the following changes in our aggregate class:</p>
<pre class="language-csharp">public class ClassifiedAd : AggregateRoot&lt;ClassifiedAdId&gt;
{
    // Properties to handle the persistence
    public Guid ClassifiedAdId { get; private set; }
    
    protected ClassifiedAd() { }

    ... more code here...

    protected override void When(object @event)
    {
        Picture picture;
        
        switch (@event)
        {
            case Events.ClassifiedAdCreated e:
                Id = new ClassifiedAdId(e.Id);
                OwnerId = new UserId(e.OwnerId);
                State = ClassifiedAdState.Inactive;
                
                // required for persistence
                ClassifiedAdId = e.Id;
                break;

    ... rest of the code ...</pre>
<p>This would count as our first chance to address the impedance mismatch and to add one property, just to satisfy the persistence. For RavenDB, that was all we needed to do to get things rolling. Let's see if that's enough for EF Core.</p>
<p>As the next step, we need to have a new implementation of the unit of work. We will add a new class <kbd>EfUnitOfWork</kbd> to the <kbd>Infrastructure</kbd> namespace:</p>
<pre class="language-csharp">using System.Threading.Tasks;
using Marketplace.Framework;

namespace Marketplace.Infrastructure
{
    public class EfCoreUnitOfWork : IUnitOfWork
    {
        private readonly ClassifiedAdDbContext _dbContext;

        public EfCoreUnitOfWork(ClassifiedAdDbContext dbContext)
            =&gt; _dbContext = dbContext;

        public Task Commit() =&gt; _dbContext.SaveChangesAsync();
    }
}</pre>
<p>Then, we will make the necessary changes in the repository class, <kbd>ClassifiedAdRepository</kbd>:</p>
<pre class="language-csharp">using System;
using System.Threading.Tasks;
using Marketplace.Domain;

namespace Marketplace.Infrastructure
{
    public class ClassifiedAdRepository : IClassifiedAdRepository
    {
        private readonly ClassifiedAdDbContext _dbContext;

        public ClassifiedAdRepository(ClassifiedAdDbContext dbContext) 
            =&gt; _dbContext = dbContext;

        public Task Add(ClassifiedAd entity) 
            =&gt; _dbContext.ClassifiedAds.AddAsync(entity);

        public async Task&lt;bool&gt; Exists(ClassifiedAdId id) 
            =&gt; await _dbContext.ClassifiedAds.FindAsync(id.Value) != <br/>            null;

        public Task&lt;ClassifiedAd&gt; Load(ClassifiedAdId id)
            =&gt; _dbContext.ClassifiedAds.FindAsync(id.Value);
    }
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, we are relying on <kbd>DbContext</kbd> to be instantiated per scope. In fact, <kbd>DbContext</kbd> is the Entity Framework implementation of the unit of work pattern, because it tracks all changes in objects that are attached to it during its lifetime and creates all necessary SQL statements to commit those changes to the database when we call <kbd>_dbContext.SaveChangesAsync()</kbd>.</p>
<p>The last part is the wiring. We need to change the <kbd>Startup.cs</kbd> file to tell the ASP.NET Core to use our context and register the database context in its IoC container. Certainly, we also need to register the new implementation of the unit of work. We do all of this in the <kbd>ConfigureServices</kbd> method, as follows:</p>
<pre class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    const string connectionString = 
        "Host=localhost;Database=Marketplace_Chapter8;<br/>        Username=ddd;Password=book";
    services
        .AddEntityFrameworkNpgsql()
        .AddDbContext&lt;ClassifiedAdDbContext&gt;(
            options =&gt; options.UseNpgsql(connectionString));

    services.AddSingleton&lt;ICurrencyLookup, FixedCurrencyLookup&gt;();
    services.AddScoped&lt;IUnitOfWork, EfCoreUnitOfWork&gt;();
    services.AddScoped&lt;IClassifiedAdRepository, ClassifiedAdRepository&gt;<br/>    ();
    services.AddScoped&lt;ClassifiedAdsApplicationService&gt;();

    services.AddMvc();
    services.AddSwaggerGen(c =&gt;
    {
        c.SwaggerDoc("v1",
            new Info
            {
                Title = "ClassifiedAds",
                Version = "v1"
            });
    });
}</pre>
<p>Here, we also instructed Entity Framework Core to use PostgreSQL as the database and to use the hardcoded connection string. Remember that you should avoid hardcoding connection strings, as they must be part of the configuration. We use the simplified approach to have the connection string visible.</p>
<p>The last thing we need to do before starting the app is call our extension method to create or migrate the database objects. We do it in the <kbd>Configure</kbd> method of the <kbd>Startup</kbd> class:</p>
<pre class="language-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.EnsureDatabase();
    app.UseMvcWithDefaultRoute();
    app.UseSwagger();
    app.UseSwaggerUI(c =&gt;
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "ClassifiedAds <br/>        v1"));
}</pre>
<p>The changes that we have made more or less represent all the changes that we needed to do to use RavenDB for persistence. Ideally, everything should work now. Let's start the application and see what happens.</p>
<p>After pressing <em>F5</em>, we will see that the application doesn't start. Instead, it throws an exception immediately:<br/>
The entity type <kbd>ClassifiedAdId</kbd> requires a primary key to be defined.</p>
<p>That sounds weird, because <kbd>ClassifiedAdId</kbd> is not an entity. Here comes trouble. Entity Framework Core considers all object-to-object relations to be relationships between different entities. It wants to create a separate table to store the <kbd>ClassifiedAdId</kbd> object in it, but as an entity, it must have an identifier. Just about a couple of years ago, we'd be stuck right here, and the only way to overcome this limitation would be to use the <strong>memento</strong> pattern. The essence of this pattern is to be able to persist the object state and to be able to restore it later. Sometimes, it is referred to as <strong>undo rollback</strong>, but that is just a narrow use case for this pattern. Essentially, every object persistence method uses some implementation of the memento pattern.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In order to implement memento, we need to have a way to convert our complex object to something that can be persisted, like a text file, relational table, or JSON object. Upon any save operation, we'd need to manually convert the state of our aggregate to the memento, and when we retrieved the state back, a reverse operation would be required. However, today, we can solve this issue by telling Entity Framework Core that we are, in fact, dealing with value objects, and not work entities. In fact, the EF Core has implemented all of the pieces of the pattern for us. To use this feature, we need to add more code to the <kbd>ClassifiedAdEntityTypeConfiguration</kbd> class:</p>
<pre class="language-csharp">public class ClassifiedAdEntityTypeConfiguration : IEntityTypeConfiguration&lt;ClassifiedAd&gt;
{
    public void Configure(EntityTypeBuilder&lt;ClassifiedAd&gt; builder)
    {
        builder.HasKey(x =&gt; x.ClassifiedAdId);
        builder.OwnsOne(x =&gt; x.Id);
        builder.OwnsOne(x =&gt; x.Price, p =&gt; p.OwnsOne(c =&gt; c.Currency));
        builder.OwnsOne(x =&gt; x.Text);
        builder.OwnsOne(x =&gt; x.Title);
        builder.OwnsOne(x =&gt; x.ApprovedBy);
        builder.OwnsOne(x =&gt; x.OwnerId);
    }
}</pre>
<p>The <kbd>OwnsOne</kbd> method tells EF Core that it needs to persist the given property not as a separate entity in a separate table, but as a part of the same table. Since EF Core would only save the content of public properties, we need to expose the properties of our value objects for the <kbd>get</kbd> part. We still want encapsulation, so the setter remains private. This is what we need to add to the <kbd>PictureSize</kbd> value object code:</p>
<pre class="language-csharp">public class PictureSize : Value&lt;PictureSize&gt;
{
    public int Width { get; internal set; }
    public int Height { get; internal set; }

    internal PictureSize() { }

    ... rest of the code ...</pre>
<p>EF Core also requires all objects that it persists to have either a constructor that accepts values for all properties, or a parameterless constructor. We use the second option, but we make the constructor internal, so no one can use it from outside of the <kbd>Domain</kbd> project.</p>
<p>Now, we also know that EF Core wants to know more about how to map objects to tables; it has also become clear that we need to map the <kbd>Picture</kbd> entity, as well. There, we want to keep objects persisted in a separate table. To do that, we need to add a new class <kbd>PictureEntityTypeConfiguration</kbd>. It can be added to the same <kbd>ClassifiedAdDbContext.cs</kbd> file:</p>
<pre class="language-csharp">public class PictureEntityTypeConfiguration : IEntityTypeConfiguration&lt;Picture&gt;
{
    public void Configure(EntityTypeBuilder&lt;Picture&gt; builder)
    {
        builder.HasKey(x =&gt; x.PictureId);
        builder.OwnsOne(x =&gt; x.Id);
        builder.OwnsOne(x =&gt; x.ParentId);
        builder.OwnsOne(x =&gt; x.Size);
    }
}</pre>
<p>Notice that we need to do the same trick with the picture ID that we did with the classified ad ID. I am not putting the code changes in the text for the sake of brevity, since all of the code can be found in the book repository for this chapter.</p>
<p>The <kbd>ClassifiedAdDbContext.OnModelCreating</kbd> now needs to include this additional mapping configuration, as well:</p>
<pre class="language-csharp">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.ApplyConfiguration(new <br/>    ClassifiedAdEntityTypeConfiguration());
    modelBuilder.ApplyConfiguration(new <br/>    PictureEntityTypeConfiguration());
}</pre>
<p>Now let's run the application again. This time, it start just fine; at first glance, all mappings seem to be correct. If we also look at the database (use the tool of your choice, like Database Explorer in Visual Studio or the Database tool window in Rider) we will see that two tables were created:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9c00a144-0f67-4acf-8171-5f6a990e8daa.png" style="width:46.67em;height:41.33em;"/></p>
<p>The database structure in the Visual Studio database explorer</p>
<p class="mce-root"/>
<p>As you can see, there are two tables for each entity type. Since the <kbd>Picture</kbd> entity is a part of the <kbd>ClassifiedAd</kbd> aggregate, we use the object-to-object relationship, and it was mapped as a foreign key in the database. For each value object, EF Core has created a set of columns to store all properties of each value object in the same table as the parent entity. So far, so good; now, we can try calling our API. You'd need two GUIDs to be filled out in Swagger, and after clicking on Execute, we will have quite a long wait. That's because EF Core initialization is implicit, and it is being called when we try to do anything with <kbd>DbContext</kbd> for the first time. Subsequent calls are processed faster, since the initialized model will be cached.</p>
<p>Let's look at what we got back from the HTTP call. This is not really surprising, it is an exception again. We are getting all the issues associated with the impedance mismatch, one by one! The new error message is as follows:</p>
<pre>The entity of type 'ClassifiedAd' is sharing the table 'ClassifiedAds' with entities of type 'ClassifiedAdText', but there is no entity of this type with the same key value '{ClassifiedAdId: 302790d5-735e-445e-a042-b5891ad3cf1f}' that has been marked as 'Added'.</pre>
<p>This time, the error message is not really clear. In reality, what EF Core is telling us now is that it cannot handle value object properties of the <kbd>ClassifiedAd</kbd> object that are null. When we apply the <kbd>ClassifiedAdCreated</kbd> event in the <kbd>When</kbd> method, we only assign values to the properties that we have—the ID, and the owner ID.</p>
<p>There are a few ways to work around this limitation, and the most prominent one is to use instances of value objects that represent <em>no value</em>. In fact, this method also allows us to mitigate the risk of getting the null reference exception. We already touched upon the issue of null earlier in this book. Having specific <em>no value</em> instances for all our value objects would be similar to using the optional types that are commonly used in functional languages. In the following, you can see the code to implement such a value for the <kbd>ClassifiedAdTitle</kbd> class by adding a static property to it:</p>
<pre class="language-csharp">public static ClassifiedAdTitle NoTitle =
    new ClassifiedAdTitle();</pre>
<p>When we have such properties in all value object types that can be empty (for example, <kbd>PictureSize</kbd> or <kbd>ClassifiedAdId</kbd> are always assigned, so we can skip these types), we need to assign empty values in the <kbd>When</kbd> method of the <kbd>ClassifiedAd</kbd> class for the <kbd>ClassifiedAdCreated</kbd> event handler:</p>
<pre class="language-csharp">protected override void When(object @event)
{
    Picture picture;
    
    switch (@event)
    {
        case Events.ClassifiedAdCreated e:
            Id = new ClassifiedAdId(e.Id);
            OwnerId = new UserId(e.OwnerId);
            State = ClassifiedAdState.Inactive;
            
            Title = ClassifiedAdTitle.NoTitle;
            Text = ClassifiedAdText.NoText;
            Price = Price.NoPrice;
            ApprovedBy = UserId.NoUser;

            ClassifiedAdId = e.Id;
            break;

    ... rest of the code ...</pre>
<p>With these changes complete, we can do the API call again, and now, it should work. On the console, we can see the following debug output:</p>
<pre><strong>[17:44:32 INF] Executed DbCommand (13ms) [Parameters=[@p0='302790d5-735e-445e-a042-b5891ad3cf1f', @p1='2', @p2='302790d5-735e-445e-a042-b5891ad3cf1f', @p3='', @p4='', @p5='', @p6='0', @p7='False', @p8='-1', @p9='00000000-0000-0000-0000-000000000000', @p10='83508629-d2ee-4798-9ac5-b5bbc3e57731'], CommandType='Text', CommandTimeout='30']</strong><br/><strong> INSERT INTO "ClassifiedAds" ("ClassifiedAdId", "State", "Id_Value", "Text_Value", "Title_Value", "Price_Currency_CurrencyCode", "Price_Currency_DecimalPlaces", "Price_Currency_InUse", "Price_Amount", "ApprovedBy_Value", "OwnerId_Value")</strong><br/><strong> VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6, @p7, @p8, @p9, @p10);</strong></pre>
<p>We can also call the <kbd>PUT</kbd> method for <kbd>/ad/title</kbd> and get this debug output:</p>
<pre><strong>[17:46:48 INF] Executed DbCommand (5ms) [Parameters=[@p1='302790d5-735e-445e-a042-b5891ad3cf1f', @p0='Green sofa'], CommandType='Text', CommandTimeout='30']</strong><br/><strong> UPDATE "ClassifiedAds" SET "Title_Value" = @p0</strong><br/><strong> WHERE "ClassifiedAdId" = @p1;</strong></pre>
<p>We can also look at the content of the <kbd>ClassifiedAd</kbd> table and see that the values are indeed being assigned:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a57984ff-6c46-4662-b559-dac02120e979.png" style="width:56.25em;height:5.17em;"/></p>
<p>Updated data in the ClassifiedAd table</p>
<p>By now, we have managed to handle all the challenges that come from the mismatch between our domain model and the data model. This is not the only way to handle aggregate persistence using relational databases. Many developers prefer having the domain model and the data model completely separate. By doing that, they obtain more flexibility for changing the domain model without looking at persistence concerns all the time. However, such flexibility comes with the associated costs of overly increasing the complexity for the persistence layer, since the mappings between domain objects and data objects need to be handled manually. For larger applications, this approach might be preferred, because it also allows for tuning the data model to satisfy the performance needs of the underlying database. When we use the ORM framework to deal with our domain objects and persist them directly, we put a lot of trust in the framework capabilities to handle the data aspect properly. At the same time, EF Core is constantly improving to make database calls more optimal and to mitigate the impedance mismatch more transparently for developers. So far, we have been able to fix most of the issues by applying a more advanced configuration in the infrastructure configuration classes, and the changes in the domain model itself have not been that significant.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we dove deeply into the topic of aggregate persistence. You have seen many challenges that are associated with what is known as <strong>impedance mismatch</strong>, when we can clearly see that databases aren't exactly happy to persist complex object graphs as is due to specific requirements that different types of databases have. Also, you learned about using the repository pattern to abstract the persistence and keep both our domain model and the application service away from the database-related concerns.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You learned how to use RavenDB to persist our aggregate as a document, and what challenges we might encounter on this road. It became clear that document databases are, in general, more suitable for persisting complex objects, but some concerns still need to be addressed, like handling identities and exposing properties.</p>
<p>This chapter also covered the topic of persisting aggregates in a relational database. We used the Entity Framework Core with a PostgreSQL database to represent our aggregate as a set of tables with relations between them. Despite the significant improvements that the EF Core team has made during the last couple of years, persisting value objects is a particularly challenging subject, and we had to do quite a lot of configuration changes to make it work. However, the changes that we had to make in the domain model were not that dramatic, and we were still able to use value objects as-is, including the important characteristic of their immutability.</p>
<p>However, we haven't touched the topic of retrieving data from the database. Our API still only has endpoints to create new domain objects and perform state transitions in the existing object. In fact, we can only handle commands. You might wonder why we don't start adding more methods to our repository to fetch collections of aggregates based on some criteria or specification. That is one of the fallacies of persistence implementations that we see in many systems when trying to apply the principles of DDD. That's why I have dedicated the next chapter exclusively to queries. As you will see, it is not as straightforward, and there are some interesting things to discover ahead.</p>


            

            
        
    </body></html>