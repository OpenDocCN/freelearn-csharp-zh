- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Working with IMGUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IMGUI
- en: The last UI system I will cover is **IMGUI** or **Immediate Mode Graphical User
    Interface**. The primary usage for IMGUI is to create tools that assist developers
    during development and debugging. While IMGUI can technically make runtime UI,
    it is strongly discouraged by Unity. So, for example, you can use it to make Editor
    extensions or debug menus that will run in your game’s view, and can be accessed
    when you play your game outside of the Editor. However, keep in mind these debug
    in-game menus are meant to be developer-facing, not player-facing. IMGUI is most
    commonly used for developing Editor UI extensions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要介绍的最后一个 UI 系统是 **IMGUI** 或 **即时模式图形用户界面**。IMGUI 的主要用途是创建在开发过程中和调试期间帮助开发者的工具。虽然
    IMGUI 在技术上可以创建运行时 UI，但 Unity 强烈不建议这样做。例如，您可以使用它来创建 Editor 扩展或调试菜单，这些菜单将在您的游戏视图中运行，并且可以在您在编辑器外玩游戏时访问。然而，请注意，这些游戏内的调试菜单是面向开发者的，而不是面向玩家的。IMGUI
    最常用于开发 Editor UI 扩展。
- en: Since this book’s primary focus is on runtime, player-facing UI, I won’t delve
    too deep into this system; however, I’ll cover the very basics of making developer-facing
    with IMGUI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的主要重点是运行时、面向玩家的 UI，因此我不会深入探讨这个系统；然而，我会介绍使用 IMGUI 制作面向开发者内容的基础知识。
- en: 'In this chapter, I will discuss the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论以下内容：
- en: A general overview of how to use IMGUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IMGUI 的一般使用概述
- en: The most commonly used IMGUI Controls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的 IMGUI 控件
- en: How to use IMGUI for Inspector UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 IMGUI 进行 Inspector UI
- en: How to show debug frame rate text UI in your game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的游戏中显示调试帧率文本 UI
- en: How to put a button on an Inspector component and import data to a ScriptableObject
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Inspector 组件上放置按钮并将数据导入到 ScriptableObject
- en: It is important to note that IMGUI is not a recommended system by Unity. When
    it comes to runtime UI, they recommend uGUI (which is what the majority of this
    book is about), and when it comes to Editor UI, they recommend UI Toolkit (which
    was covered in [*Chapter 18*](B18327_18.xhtml#_idTextAnchor481)). So, learning
    IMGUI is not necessarily a required skill for anyone developing in Unity. It is
    especially not a required skill for non-programmers. However, it does give programmers
    a very quick way to build out UI to assist them in development, so the skills
    are not useless.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Unity 并不推荐使用 IMGUI 系统。当涉及到运行时 UI 时，他们推荐使用 uGUI（本书的大部分内容都是关于这个的），而当涉及到编辑器
    UI 时，他们推荐使用 UI Toolkit（在第 18 章中介绍过。[*第 18 章*](B18327_18.xhtml#_idTextAnchor481)）。因此，学习
    IMGUI 并非 Unity 开发者必须掌握的技能，尤其是对于非程序员来说。然而，它确实为程序员提供了一种非常快速构建 UI 的方法，以帮助他们进行开发，所以这些技能并非无用。
- en: Let’s review some basic information about IMGUI.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于 IMGUI 的一些基本信息。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2019](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2019)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2019](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2019)
- en: IMGUI overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IMGUI 概述
- en: As I stated earlier, IMGUI gives programmers a quick way to build out UI that
    can assist them in their development. This is because IMGUI is built exclusively
    via code. It is not connected to GameObjects, and all objects are rendered via
    calls to an `OnGUI()` or `OnInspectorGUI()` method. The `OnGUI()` method is called
    every frame, similar to the `Update()` method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，IMGUI 为程序员提供了一种快速构建 UI 的方法，这可以帮助他们在开发过程中。这是因为 IMGUI 完全通过代码构建。它与 GameObjects
    无关，所有对象都是通过调用 `OnGUI()` 或 `OnInspectorGUI()` 方法来渲染的。`OnGUI()` 方法每帧都会被调用，类似于 `Update()`
    方法。
- en: If you want your IMGUI to appear within your scene, you write all your UI building
    code in an `OnGUI()` method within a `MonoBehaviour` inheriting script. Because
    IMGUI items are created via code, any UI you create with it on a `MonoBehaviour`
    script will not render until the game is run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让 IMGUI 在您的场景中显示，您需要在继承自 `MonoBehaviour` 的脚本中的 `OnGUI()` 方法中编写所有 UI 构建代码。因为
    IMGUI 项目是通过代码创建的，所以您在 `MonoBehaviour` 脚本上使用它创建的任何 UI 都不会渲染，直到游戏运行。
- en: If you want your UI to appear in an Editor window, you will write all your UI
    building code in an `OnGUI()` method within an `EditorWindow` inheriting script.
    If you want your UI to appear in the Inspector, you write all your UI building
    code in an `OnInspectorGUI()` method within an `Editor` inheriting script.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的UI出现在编辑器窗口中，你将在继承自`EditorWindow`的脚本中的`OnGUI()`方法中编写所有UI构建代码。如果你希望你的UI出现在检查器中，你将在继承自`Editor`的脚本中的`OnInspectorGUI()`方法中编写所有UI构建代码。
- en: 'All IMGUI items are created by calling their unique method within an `OnGUI()`
    or `OnInspectorGUI()` method. Each of their unique methods can be positioned and
    sized using rectangular position. When positioning an object with rectangular
    position, you first create a new Rectangle using the `Rect()` method. The `Rect()`
    method takes four parameters: `x` position, `y` position, `width`, and `height`.
    So, for example, you can create a new rectangle with the following line of code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有IMGUI项目都是通过在`OnGUI()`或`OnInspectorGUI()`方法中调用它们的独特方法来创建的。每个独特的方法都可以使用矩形位置来定位和调整大小。当使用矩形位置定位对象时，你首先使用`Rect()`方法创建一个新的矩形。`Rect()`方法接受四个参数：`x`位置，`y`位置，宽度，和高度。所以，例如，你可以使用以下代码行创建一个新的矩形：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This would create a rectangle at screen coordinate `(10, 10)` with a width and
    height of `50`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕坐标`(10, 10)`处创建一个宽度为`50`，高度为`50`的矩形。
- en: Remember, screen coordinates put position `(0,0)` in the top-left corner of
    the screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，屏幕坐标将位置`(0,0)`放在屏幕的左上角。
- en: 'You can also use `Vector2`s to specify the parameters. For example, you could
    do something like this to achieve the same results:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Vector2`s来指定参数。例如，你可以这样做以实现相同的结果：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we know how to create IMGUI items, let’s review the types of items
    that you can draw using `OnGUI()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建IMGUI项目，让我们回顾一下可以使用`OnGUI()`绘制的项目类型。
- en: IMGUI Controls
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IMGUI控件
- en: 'The items drawn using IMGUI are called **Controls**. While the term “Controls”
    may imply the item is interactable, not all Controls are interactable. There are
    multiple Controls available with the IMGUI system, but you can accomplish most
    of your IMGUI goals with the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IMGUI绘制的项目被称为**控件**。虽然“控件”一词可能意味着项目是可交互的，但并非所有控件都是可交互的。IMGUI系统中有多种控件可用，但你可以用以下几种控件实现大多数IMGUI目标：
- en: '`Label`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`'
- en: '`Button`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`'
- en: '`RepeatButton`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重复按钮`'
- en: '`TextField`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本字段`'
- en: '`TextArea`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本区域`'
- en: '`Toggle`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`切换`'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a comprehensive list of all IMGUI controls here: [https://docs.unity3d.com/2023.3/Documentation/Manual/gui-Controls.xhtml](https://docs.unity3d.com/2023.3/Documentation/Manual/gui-Controls.xhtml).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到所有IMGUI控件的完整列表：[https://docs.unity3d.com/2023.3/Documentation/Manual/gui-Controls.xhtml](https://docs.unity3d.com/2023.3/Documentation/Manual/gui-Controls.xhtml)。
- en: 'A `Label`, you call the `GUI.Label()`method. The `GUI.Label()` method has multiple
    overloads, but the primary ones you will use are the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`标签`，你调用`GUI.Label()`方法。`GUI.Label()`方法有多个重载，但你将主要使用以下几种：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Where the first is used to define a text label, and the second is used to define
    an image label.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于定义文本标签，第二个用于定义图像标签。
- en: 'For example, the following code will display a text label and an image label
    in a scene, when it is attached to a GameObject and the `labelTexture` variable
    is assigned in the Inspector:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将在附加到GameObject并分配`labelTexture`变量到检查器的情况下，在场景中显示文本标签和图像标签：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The labels will look as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 标签将看起来如下：
- en: '![Figure 19.1: Using IMGUI Labels](img/B18327_19_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图19.1：使用IMGUI标签](img/B18327_19_01.jpg)'
- en: 'Figure 19.1: Using IMGUI Labels'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1：使用IMGUI标签
- en: 'A `Button`, you call the `GUI.Button()` method. The `GUI.Button()` method has
    multiple overloads, but the primary ones you will use are the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`按钮`，你调用`GUI.Button()`方法。`GUI.Button()`方法有多个重载，但你将主要使用以下几种：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Where the first will be used to define a text button, and the second will be
    used to define an image button.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将用于定义文本按钮，第二个将用于定义图像按钮。
- en: To execute code when a button is clicked, you create the button within an `if`
    statement within the `OnGUI()` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时执行代码，你可以在`OnGUI()`方法中的`if`语句内创建按钮。
- en: 'For example, the following code will display a text button and an image button
    in a scene:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将在附加到GameObject并在检查器中分配的情况下，在场景中显示文本按钮和图像按钮：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both buttons will write a message in the console each time they are clicked.
    The code must be attached to a GameObject and the `buttonTexture` variable must
    be assigned in the Inspector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 两个按钮每次点击都会在控制台写入一条消息。代码必须附加到一个GameObject上，并且必须在检查器中分配`buttonTexture`变量。
- en: 'The buttons created by the preceding code will look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码创建的按钮将看起来如下：
- en: '![Figure 19.2: Using IMGUI Buttons](img/B18327_19_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图19.2：使用IMGUI按钮](img/B18327_19_02.jpg)'
- en: 'Figure 19.2: Using IMGUI Buttons'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2：使用IMGUI按钮
- en: If you want to create a button that calls a method as it is clicked and held,
    you can use a `Button`. You can replace all instances of `GUI.Button` in the preceding
    code with `GUI.RepeatButton` and achieve a similar result, except the button will
    execute the method as long as the button is held.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个在点击并按住时调用方法的按钮，你可以使用`Button`。你可以将前面代码中的所有`GUI.Button`实例替换为`GUI.RepeatButton`，以实现类似的结果，但按钮将一直执行方法，直到按钮被按住。
- en: 'The `TextField` is used when you want only a single line of editable text,
    whereas `TextArea` is used when you want multiple lines. To create a `TextField`
    or `TextArea`, you call the `GUI.TextField()` and `GUI.TextArea()` methods, respectively.
    The `GUI.TextField()` method has multiple overloads, but the primary ones you
    will use are the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想有一行可编辑文本时，使用`TextField`，而当你想有多个行时，使用`TextArea`。要创建一个`TextField`或`TextArea`，你分别调用`GUI.TextField()`和`GUI.TextArea()`方法。`GUI.TextField()`方法有多个重载，但你将主要使用以下几种：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first method creates a `TextField`, and the second creates a `TextArea`.
    In both cases, the `string` parameter is the text that will be displayed before
    the user begins editing the text. Note that the method returns a `string` type.
    You can get the value of what is entered by the user by assigning the constructed
    object to a `string` variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法创建一个`TextField`，第二个创建一个`TextArea`。在两种情况下，`string`参数是在用户开始编辑文本之前将显示的文本。请注意，该方法返回一个`string`类型。你可以通过将构造的对象分配给一个`string`变量来获取用户输入的值。
- en: 'For example, the following code will display a `TextField` and `TextArea` you
    can interact with in your scene when it is attached to a GameObject:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将在场景中附加到一个GameObject上时显示一个可以与之交互的`TextField`和`TextArea`：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The items rendered in the scene appear as follows before the user starts editing
    the text:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户开始编辑文本之前，场景中渲染的项目如下所示：
- en: '![Figure 19.3: Using the IMGUI TextField and TextArea Controls](img/B18327_19_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图19.3：使用IMGUI文本字段和文本区域控制](img/B18327_19_03.jpg)'
- en: 'Figure 19.3: Using the IMGUI TextField and TextArea Controls'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3：使用IMGUI文本字段和文本区域控制
- en: '`Toggle`, you call the `GUI.Toggle()` method. The `GUI.Toggle()` method has
    multiple overloads, but the primary ones you will use are the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toggle`，你调用`GUI.Toggle()`方法。`GUI.Toggle()`方法有多个重载，但你将主要使用以下几种：'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the method returns a `bool` type. You can get the value of the toggle
    by assigning the created object to a `bool` variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该方法返回一个`bool`类型。你可以通过将创建的对象分配给一个`bool`变量来获取切换的值。
- en: 'For example, the following code will create a toggle whose value is assigned
    to a Boolean variable whenever the toggle is clicked. This example, like the other
    examples, would need to be attached to a GameObject in your scene to render:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将创建一个切换，其值在切换被点击时分配给一个布尔变量。这个例子，就像其他例子一样，需要附加到场景中的GameObject上以进行渲染：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The toggle will initially render in the scene as follows until the user interacts
    with it, in which case the toggle will turn on and off with each click.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 切换最初将在场景中按如下方式渲染，直到用户与之交互，此时切换将随着每次点击而打开和关闭。
- en: '![Figure 19.4: Using the IMGUI Toggle Control](img/B18327_19_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图19.4：使用IMGUI切换控制](img/B18327_19_04.jpg)'
- en: 'Figure 19.4: Using the IMGUI Toggle Control'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4：使用IMGUI切换控制
- en: All the examples I have shown were in the scene. However, if you want to display
    your UI in an Editor window, your code will work similarly. You simply put your
    code in an `EditorWindow` inheriting script. (See the example covered in [*Chapter
    18*](B18327_18.xhtml#_idTextAnchor481).) However, it is slightly different if
    you want to create IMGUI in your Inspector. Let’s look at that now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我所展示的所有示例都是在场景中。然而，如果你想在你编辑器窗口中显示你的UI，你的代码将类似地工作。你只需将你的代码放入一个继承自`EditorWindow`的脚本中。（参见[*第18章*](B18327_18.xhtml#_idTextAnchor481)中的示例。）但是，如果你想在检查器中创建IMGUI，情况就略有不同。现在让我们来看看。
- en: IMGUI in the Inspector
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查器中的IMGUI
- en: 'Using IMGUI to enhance your components works very similarly to the way it does
    with in-game IMGUI and `EditorWindow` IMGUI. However, there are some small changes.
    First, you write scripts that inherit from `Editor`. Second, you use the `OnInspectorGUI()`
    method, not the `OnGUI()` method. Third, if you want the Inspector to also contain
    all its usual data, you need to call the `DrawDefaultInspector()` method within
    your `OnInspectorGUI()` method. Lastly, if you want the IMGUI button to appear
    in line with the various default Inspector elements, you use the `GUILayout` base
    class, rather than the `GUI` base class. So, for example, you wouldn’t create
    a button with the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IMGUI 增强你的组件的工作方式与在游戏内 IMGUI 和 `EditorWindow` IMGUI 中非常相似。然而，有一些小的变化。首先，你编写从
    `Editor` 继承的脚本。其次，你使用 `OnInspectorGUI()` 方法，而不是 `OnGUI()` 方法。第三，如果你想检查器也包含所有其通常的数据，你需要在你的
    `OnInspectorGUI()` 方法中调用 `DrawDefaultInspector()` 方法。最后，如果你想使 IMGUI 按钮与各种默认检查器元素对齐，你使用
    `GUILayout` 基类，而不是 `GUI` 基类。所以，例如，你不会用以下代码创建一个按钮：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead, you’d create it with this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你会用以下方式创建它：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Buttons created with `GUILayout` do not require a rectangular position and will
    automatically be positioned within the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GUILayout` 创建的按钮不需要矩形位置，它们将自动在 UI 中定位。
- en: I will cover an example of this in the *Examples* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 *示例* 部分介绍这个示例。
- en: Now, you have enough basic background information to begin developing developer-facing
    UI with IMGUI. Let’s look at some basic examples to get you started on using the
    system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了足够的基本背景信息，可以开始使用 IMGUI 开发面向开发者的 UI。让我们看看一些基本示例，以帮助你开始使用该系统。
- en: Examples
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'For the examples in this chapter, I will cover two types of IMGUI usages: one
    for an in-game debug menu and another for an Inspector UI. All the examples covered
    up to this point have all been in-game debug menu UI.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，我将介绍两种 IMGUI 的使用类型：一种用于游戏内的调试菜单，另一种用于检查器 UI。到目前为止，所有涵盖的示例都已经在游戏内的调试菜单
    UI 中。
- en: Using IMGUI to show framerate in-game
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IMGUI 在游戏中显示帧率
- en: Let’s create a very simple script that will show the frame rate of our game
    in the scene. It will change color if the framerate drops below a certain value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的脚本，它将在场景中显示我们游戏的帧率。如果帧率低于某个值，它将改变颜色。
- en: 'To display the framerate in your game, complete the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏中显示帧率，请完成以下步骤：
- en: Create a new scene called `Chapter19-Examples.unity`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter19-Examples.unity` 的新场景。
- en: Within the new scene, create a new GameObject called `DebugMenu`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新场景中，创建一个名为 `DebugMenu` 的新 GameObject。
- en: Create a new script called `DebugFrameRate.cs`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DebugFrameRate.cs` 的新脚本。
- en: Attach the `DebugFrameRate.cs` script to your `DebugMenu` GameObject as a component.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DebugFrameRate.cs` 脚本附加到你的 `DebugMenu` GameObject 作为组件。
- en: 'Open the new script and add the following variable declarations:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新脚本并添加以下变量声明：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `fps` variable is used to get an estimate of our game’s frame rate, while
    the `fpsThreshold` variable is assigned in the Inspector and used to determine
    the threshold for when our fps will display as red in the scene.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fps` 变量用于获取我们游戏帧率的估计值，而 `fpsThreshold` 变量在检查器中分配，并用于确定当我们的 fps 在场景中显示为红色时的阈值。'
- en: 'Create an IMGUI `Label` that will display the fps with the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个 IMGUI `Label`，用于显示 fps：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s calculate the fps. We can get an estimate of the fps with the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们计算 fps。我们可以使用以下方法来估计 fps：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Play your game, and you should see the fps displayed in the scene. If you open
    the **Stats** window, you should see that the values are relatively close.![Figure
    19.5: The frame rate displaying in-game](img/B18327_19_05.jpg)'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩你的游戏，你应该在场景中看到 fps 的显示。如果你打开 **Stats** 窗口，你应该看到这些值相对接近。![图 19.5：显示在游戏中的帧率](img/B18327_19_05.jpg)
- en: 'Figure 19.5: The frame rate displaying in-game'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 19.5：显示在游戏中的帧率
- en: It’s slightly difficult to see what the value is without pausing the game. So,
    let’s make it change color when it drops below a certain value. This will make
    it easier to see when there is a framerate we find worrisome. We’ll use the `fpsThreshold`
    value for this. Your game running in your Editor may run at a different framerate
    than mine, so please use a value that makes sense for your system to be able to
    see the code execute. I’m going to use `1000`. Enter the value for your `fpsThreshould`
    in the Inspector.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有暂停游戏很难看到值。所以，让我们让它低于某个值时改变颜色。这将使得在帧率低于我们担忧的水平时更容易看到。我们将使用`fpsThreshold`值来实现这一点。你的游戏在编辑器中运行的帧率可能不同于我的，所以请使用一个对你系统有意义的值，以便能够看到代码执行。我将使用`1000`。在检查器中输入你的`fpsThreshould`值。
- en: 'Now, let’s make it change color when it goes below that threshold. Add the
    following `if`/`else` statement to the top of your `OnGUI()` method, before the
    label is created:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们让它低于那个阈值时改变颜色。将以下`if`/`else`语句添加到你的`OnGUI()`方法顶部，在创建标签之前：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that’s all you need to have a framerate estimate display in your game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就在游戏中有了帧率估计显示。
- en: Displaying a framerate for your game is a great example of something you might
    want to make with an in-game debug UI. This will let you easily see the general
    performance of your game, even when you run it outside of the Editor. You could
    extend this to only appear when you perform specific tasks or only update every
    second. The possibilities are endless.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中显示帧率是使用游戏内调试UI制作你可能想要的东西的一个很好的例子。这将让你在运行游戏时，即使是在编辑器之外，也能轻松地看到游戏的整体性能。你可以扩展它，使其仅在执行特定任务时出现，或者每秒只更新一次。可能性是无限的。
- en: There are lots of other reasons you may want to use an in-game debug menu. For
    example, you might want buttons that call functions that help you skip to sections
    of your game. Or maybe you want a button that clears your saved data. The important
    thing to remember about making in-game UI with IMGUI is this should all be to
    help you, the developer, but should not be used to display information to your
    player.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有其他很多原因想要使用游戏内的调试菜单。例如，你可能想要一些按钮，它们可以调用帮助你跳转到游戏特定部分的函数。或者你可能想要一个清除你保存数据的按钮。制作使用IMGUI的游戏内UI时，重要的是记住，这应该都是为了帮助你，开发者，而不应该用来向玩家显示信息。
- en: Now, let’s look at an example of something you can do in your Editor to assist
    your development.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你可以在你的编辑器中做的一些事情来帮助你进行开发。
- en: Using IMGUI to make an Inspector button that imports data
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IMGUI制作一个用于导入数据的检查器按钮
- en: Often in game development, you will have data stored in some external source
    and need to import it into a usable format within your game’s code. For example,
    you may have a writer on your team who creates all dialogue in an Excel sheet,
    which you then need to figure out how to import into your game. This example will
    show a basic example that uses an Inspector button to read text from a file and
    distribute it to the appropriate place within your game, specifically a ScriptableObject.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，你通常会在外部存储一些数据，并需要在游戏代码中将这些数据导入为可用的格式。例如，你可能有一个团队成员负责在Excel表中创建所有对话，然后你需要找出如何将其导入到你的游戏中。这个例子将展示一个使用检查器按钮从文件中读取文本并将其分配到游戏中的适当位置的基本示例，特别是ScriptableObject。
- en: '![Figure 19.6: A custom Inspector with an import button](img/B18327_19_06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图19.6：带有导入按钮的自定义检查器](img/B18327_19_06.jpg)'
- en: 'Figure 19.6: A custom Inspector with an import button'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6：带有导入按钮的自定义检查器
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We haven’t really discussed ScriptableObjects in this text. A ScriptableObject
    is essentially a data container within Unity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们还没有真正讨论过ScriptableObjects。ScriptableObject在Unity中本质上是一个数据容器。
- en: 'To create a button that imports data into your ScriptableObject, complete the
    following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个将数据导入到你的ScriptableObject中的按钮，请完成以下步骤：
- en: Create a new C# script called `DialogueData.cs`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，名为`DialogueData.cs`。
- en: Create a new folder in your `Assets` folder called `Data`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Assets`文件夹中创建一个名为`Data`的新文件夹。
- en: From the code files, find the text file called `SampleDialogue.txt`. Import
    it into your `Data` folder. Alternatively, you can create a text file with at
    least three lines of text and place it into this folder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码文件中找到名为`SampleDialogue.txt`的文本文件。将其导入到你的`Data`文件夹中。或者，你也可以创建一个至少有三行文本的文本文件，并将其放入这个文件夹中。
- en: 'Open your `DialogueData.cs` script and change it so that it inherits from `Monobehavior`
    to `ScriptableObject`, like so:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`DialogueData.cs`脚本，将其修改为从`Monobehavior`继承到`ScriptableObject`，如下所示：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following two lines of code to the class:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下两行代码：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ll use the `textPath` variable to define where the text file being imported
    is within our project and the `importedDialogue` variable to hold all the imported
    dialogue.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`textPath`变量来定义导入的文本文件在我们项目中的位置，并使用`importedDialogue`变量来保存所有导入的对话。
- en: 'Add the following line above the class definition, to create a menu that makes
    `DialogueData` ScriptableObjects:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义上方添加以下行，以创建一个菜单，使得`DialogueData` ScriptableObjects：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, return to your Editor and create a new ScriptableObject by right-clicking
    within your `Data` folder and selecting **Create** | **DialogueData**.![Figure
    19.7: Creating the DialogueData ScriptableObject](img/B18327_19_07.jpg)'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到你的编辑器，通过在`Data`文件夹内右键点击并选择**创建** | **DialogueData**来创建一个新的ScriptableObject。![图19.7：创建DialogueData
    ScriptableObject](img/B18327_19_07.jpg)
- en: 'Figure 19.7: Creating the DialogueData ScriptableObject'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.7：创建DialogueData ScriptableObject
- en: 'This will create a new ScriptableObject called `New SO` with the following
    Inspector:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的名为`New SO`的ScriptableObject，其检查器如下所示：
- en: '![Figure 19.8: The ScriptableObject’s Inspector](img/B18327_19_08.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图19.8：ScriptableObject的检查器](img/B18327_19_08.jpg)'
- en: 'Figure 19.8: The ScriptableObject’s Inspector'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.8：ScriptableObject的检查器
- en: Now, let’s customize the Inspector with an import button. Create a new script
    called `DialogueDataCustomEditor.cs` and save it in your `Editor` folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用导入按钮自定义检查器。创建一个新的脚本`DialogueDataCustomEditor.cs`并将其保存在你的`Editor`文件夹中。
- en: 'Open the script and make it inherit from `Editor` instead of `Monobehavior`,
    like so:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本，将其继承自`Editor`而不是`Monobehavior`，如下所示：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Make sure to add the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保添加以下内容：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, to let the script know that it is a custom Inspector for the `DialogueData`
    class, add the following above the class definition:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了让脚本知道它是一个`DialogueData`类的自定义检查器，在类定义上方添加以下内容：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code to your script to display a button in the Inspector:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的脚本中，以在检查器中显示按钮：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you return to your `New SO`, you’ll see that the Inspector only contains
    a button now.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你返回到你的`New SO`，你会看到检查器现在只包含一个按钮。
- en: '![Figure 19.9: The button in the Inspector](img/B18327_19_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图19.9：检查器中的按钮](img/B18327_19_09.jpg)'
- en: 'Figure 19.9: The button in the Inspector'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.9：检查器中的按钮
- en: 'It no longer displays all of the data that we want to show in the Inspector.
    So, add the following, above your button code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不再显示我们想在检查器中显示的所有数据。因此，在按钮代码上方添加以下内容：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It should now draw the button on top of the default Inspector information,
    which is not what we want.![Figure 19.10: The button in the Inspector over the
    default information](img/B18327_19_10.jpg)'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它现在应该在默认检查器信息上方绘制按钮，这并不是我们想要的。![图19.10：检查器上方的按钮](img/B18327_19_10.jpg)
- en: 'Figure 19.10: The button in the Inspector over the default information'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.10：检查器上方的按钮
- en: 'Edit the button code to the following:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将按钮代码编辑为以下内容：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will cause the button to display at the bottom of the component, utilizing
    the layout of the Unity GUI instead of being explicitly positioned.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致按钮显示在组件的底部，利用Unity GUI的布局而不是显式定位。
- en: '![Figure 19.11: The button using the GUILayout base class](img/B18327_19_11.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图19.11：使用GUILayout基类的按钮](img/B18327_19_11.jpg)'
- en: 'Figure 19.11: The button using the GUILayout base class'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.11：使用GUILayout基类的按钮
- en: 'Now, we just need to import the dialogue. Add the following variable declaration
    to your code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要导入对话。将以下变量声明添加到你的代码中：
- en: '[PRE25]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will use this variable to correctly parse the data in the text file, making
    sure each new line is a new line of dialogue.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用这个变量来正确解析文本文件中的数据，确保每一行都是一个新的对话行。
- en: 'Now, we need to add code that will first get the data from the file and then
    send it to the ScriptableObject:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加代码，首先从文件获取数据，然后将其发送到ScriptableObject：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, update your `OnInspectorGUI()` method to call the `ReadString()` method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新你的`OnInspectorGUI()`方法以调用`ReadString()`方法：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We need to add the location of the `SampleDialogue.txt` file to our ScriptableObject.
    Right-click on `SampleDialogue.txt` and select **Copy Path**. Paste it into the
    **Text** **Path** slot.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`SampleDialogue.txt`文件的位置添加到我们的ScriptableObject中。右键点击`SampleDialogue.txt`并选择**复制路径**。将其粘贴到**文本**
    **路径**槽中。
- en: '![Figure 19.12: The textPath variable assigned in the Inspector](img/B18327_19_12.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图19.12：在检查器中分配的textPath变量](img/B18327_19_12.jpg)'
- en: 'Figure 19.12: The textPath variable assigned in the Inspector'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.12：在检查器中分配的textPath变量
- en: We should be good to go. Click on the **Import Dialogue** button and the dialogue
    will now import. Your Inspector should appear like *Figure 19**.6*.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该可以开始了。点击**导入对话框**按钮，对话框现在将开始导入。你的检查器应该看起来像*图 19*。6*。
- en: And that’s it for using IMGUI to create a button within the Editor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IMGUI 在编辑器内创建按钮的操作就到这里了。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed how to use the IMGUI system to build UI for both
    developers, in-game debug displays as well as Editor extensions. While IMGUI is
    not necessarily a recommended UI system, it is extremely helpful for creating
    super-quick tools to assist developers during the development process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用 IMGUI 系统为开发者构建 UI，包括游戏内的调试显示以及编辑器扩展。虽然 IMGUI 并非一个推荐的 UI 系统，但它对于在开发过程中快速创建辅助开发者的工具来说极为有用。
- en: 'In the next chapter, we will look at the other input system provided by Unity:
    the New Input System.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Unity 提供的另一个输入系统：新输入系统。
