- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Demystifying Microservices Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘微服务应用
- en: Over the last decade, microservices architecture has taken a central role in
    modern software development. In this chapter, we will define what microservices
    architecture is. You will learn the reasons behind the success of microservices,
    their pros and cons, and when it is worth adopting them. Starting with the problems
    that led to their conception, we will discuss typical scenarios of when to use
    them, the impact of their adoption on overall project costs, and the returns you
    might expect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，微服务架构在现代软件开发中占据了核心地位。在本章中，我们将定义微服务架构是什么。你将了解微服务成功的原因，它们的优缺点，以及何时值得采用它们。从导致它们产生的难题开始，我们将讨论典型的使用场景，采用它们对整体项目成本的影响，以及你可能期望的回报。
- en: You will get insights into the organization of microservices, discovering how
    it differs from the usual monolithic application by resembling more of an assembly
    line than user-requests-driven processing. This newly conceived organization brings
    with it new challenges that require ad hoc techniques to enforce coherence, coordination,
    and reliability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将深入了解微服务的组织结构，发现它如何与通常的单体应用不同，更像是装配线而不是由用户请求驱动的处理。这种新构思的组织带来了新的挑战，需要特定的技术来确保一致性、协调性和可靠性。
- en: Moreover, new patterns and best practices have been created to tackle challenges
    with microservices and optimize their advantages. We will introduce and summarize
    some fundamental patterns here, while their practical implementation, together
    with more specific patterns, will be detailed throughout the remainder of the
    book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还创建了新的模式和最佳实践来应对微服务带来的挑战并优化其优势。在这里，我们将介绍并总结一些基本模式，而它们的实际实施以及更具体的模式将在本书的剩余部分详细阐述。
- en: 'More specifically, this chapter covers the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章涵盖了以下内容：
- en: The rise of **Service-Oriented Architectures** (**SOAs**) and microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务导向架构**（**SOAs**）和微服务的兴起'
- en: The definition and organization of microservices architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的定义和组织
- en: When is it worth adopting microservices architectures?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时采用微服务架构是值得的？
- en: Microservices common patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的常见模式
- en: The rise of Service-Oriented Architectures (SOAs) and microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务导向架构（SOAs）和微服务的兴起
- en: Briefly defined, microservices are chunks of software deployed on computer networks
    that communicate through network protocols. However, this is not all; they must
    also obey a set of further constraints.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，微服务是在计算机网络中部署的软件块，它们通过网络协议进行通信。然而，这还不是全部；它们还必须遵守一系列进一步的约束。
- en: Before giving a more detailed definition of what a microservices architecture
    is, we must understand how the idea of microservices evolved and what kind of
    problems it was called to solve. We will describe the two main steps of this evolution
    across two separate subsections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在给出微服务架构的更详细定义之前，我们必须了解微服务理念是如何演变的，以及它被用来解决什么类型的问题。我们将通过两个独立的子节来描述这一演变的两个主要步骤。
- en: The rise of SOA
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOA的兴起
- en: The first step in the direction of microservices was taken by the so-called
    **service-oriented architectures**, or **SOAs**, that is, architectures based
    on networks of communicating processes. Initially, SOAs were implemented as web
    services similar to the ones you might have already experienced in ASP.NET Core.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方向的第一步是由所谓的**服务导向架构**（SOAs）所采取的，即基于通信进程网络的架构。最初，SOAs被实现为类似于你在ASP.NET Core中可能已经体验过的Web服务。
- en: In an SOA, different macro-modules that implement different features or roles
    in software applications are exposed as separate processes that communicate with
    each other through standard protocols. The first SOA implementation was web services
    communicating through the XML-based SOAP protocol. Then, most web services architectures
    moved toward JSON-based web APIs, which you might already know about since REST
    web services are available as standard ASP.NET project templates. The *Further
    reading* section contains useful links that provide more details on REST web services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在SOA中，实现软件应用中不同功能或角色的不同宏模块被暴露为相互通信的独立进程，它们通过标准协议进行通信。第一个SOA实现是通过基于XML的SOAP协议进行通信的Web服务。然后，大多数Web服务架构转向基于JSON的Web
    API，你可能已经了解，因为RESTful Web服务可以作为标准ASP.NET项目模板使用。*进一步阅读*部分包含了一些有用的链接，提供了更多关于RESTful
    Web服务的详细信息。
- en: 'SOAs were conceived during the boom in the creation of software for business
    applications as one of the ways to integrate the various preexisting applications
    used by different branches and divisions into a unique company information system.
    Since the preexisting applications were implemented with different technologies,
    and the software expertise available in the various branches and divisions was
    heterogeneous, SOA was the answer to the following compelling needs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SOA是在商业应用程序软件开发热潮期间被构想出来的，作为将不同分支和部门使用的各种现有应用程序集成到一个单一公司信息系统中的多种方法之一。由于现有应用程序是用不同的技术实现的，而且各个分支和部门可用的软件专业知识是异质的，因此SOA是以下迫切需求的答案：
- en: Enabling software communication between modules implemented with different technologies
    and running on different platforms (Linux + Apache, Linux + NGINX, or Windows
    + IIS). In fact, software based on different technologies is not binary compatible,
    but it can still cooperate with others if each of them is implemented as a web
    service that communicates with the others through a technology-independent standard
    protocol. Among them, it is worth mentioning the text-based HTTP REST protocol
    and the binary gRPC protocol. Worth mentioning also is that the HTTP REST protocol
    is an actual standard while at the moment, gRPC is just a de facto standard proposed
    by Google. The *Further reading* section contains useful links for getting more
    details about these protocols.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许使用不同技术实现的模块之间进行软件通信，并且运行在不同的平台上（Linux + Apache、Linux + NGINX或Windows + IIS）。实际上，基于不同技术的软件不是二进制兼容的，但只要每个都作为通过技术无关的标准协议与其他软件通信的Web服务实现，它们仍然可以相互合作。其中，值得提及的是基于文本的HTTP
    REST协议和二进制的gRPC协议。同样值得提及的是，HTTP REST协议是一个实际的标准，而gRPC目前只是一个由谷歌提出的实际标准。*进一步阅读*部分包含了一些有用的链接，可以获取更多关于这些协议的详细信息。
- en: Enabling the versioning of each macro-module to evolve independently from the
    others. For instance, you might decide to move some web service toward the new
    .NET 9 version to take advantage of new .NET features or new, available libraries,
    while leaving other web services that don’t need modifications with a previous
    version, say, .NET 8.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许每个宏模块的版本独立于其他模块进行演进。例如，你可能会决定将某些网络服务迁移到新的.NET 9版本，以利用新的.NET功能或新的可用库，同时保留其他不需要修改的网络服务，例如.NET
    8。
- en: Promoting public web services that offer services to other applications. As
    an example, think of the various public services offered by Google, such as Google
    Maps, or the artificial intelligence services offered by Microsoft, such as language
    translation services.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推广为其他应用程序提供服务的公共网络服务。例如，想想谷歌提供的各种公共服务，如谷歌地图，或者微软提供的各种人工智能服务，如语言翻译服务。
- en: Below is a diagram that summarizes classical SOA.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是一个总结经典SOA的图表。
- en: '![](img/B31916_02_1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B31916_02_1.png)'
- en: 'Figure 2.1: SOA'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：SOA
- en: Over time, the company information system and other complex SOA applications
    conquered more markets and users, so new needs and constraints appeared. We will
    discuss them in the next subsection.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着公司信息系统和其他复杂SOA应用的不断发展，占领了更多市场和用户，因此出现了新的需求和约束。我们将在下一小节中讨论它们。
- en: Toward microservices architectures
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向微服务架构迈进
- en: 'As application users and traffic increased up to a different order of magnitude,
    the optimization of performance and the optimal balancing of hardware resources
    among the various software modules became a *must*. This led to a new requirement:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用用户和流量的增加达到不同的数量级，性能优化以及在各个软件模块之间最佳平衡硬件资源成为了一个*必须*。这导致了一个新的需求：
- en: Each software module must be scalable independently from the others so that
    we can allocate to each module the optimal quantity of resources it needs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件模块必须能够独立于其他模块进行扩展，这样我们才能为每个模块分配其所需的最佳资源量。
- en: 'As the company information system gained a central role, its continuous operation,
    that is, almost zero downtime, became a *must*, leading to another important constraint:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着公司信息系统在组织中扮演核心角色，其持续运行，即几乎零停机时间，成为了一个*必须*，这导致另一个重要约束：
- en: Microservices architecture must be redundant. Each software module must have
    several replicas running on different hardware nodes to resist software crashes
    and hardware failures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构必须是冗余的。每个软件模块必须在不同的硬件节点上运行多个副本，以抵抗软件崩溃和硬件故障。
- en: Moreover, to adapt each application to a rapidly evolving market, the requirements
    on the development times became more compelling. Accordingly, more developers
    were needed to develop and maintain each application with the given strict milestones.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了适应快速变化的市场，对开发时间的要求变得更加紧迫。因此，需要更多的开发者来开发和维护每个应用程序，并按照给定的严格里程碑进行。
- en: 'Unfortunately, handling software projects involving more than around four people
    to the required quality proved to be substantially impossible. So, a new constraint
    was added to SOAs:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，处理涉及四个人以上软件项目的质量要求证明是实质上不可能的。因此，SOA中增加了一个新的约束：
- en: The services composing an application must be completely independent of each
    other so that they can be implemented by loosely interacting separate teams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 构成应用程序的服务必须完全独立于彼此，以便它们可以由松散交互的独立团队实现。
- en: 'However, the maintenance effort also needed to be optimized, yielding another
    important constraint:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，维护工作也需要优化，从而产生了另一个重要的约束：
- en: Modifications to a service must not propagate to other services. Accordingly,
    each service must have a well-defined interface that doesn’t change with software
    maintenance (or that, at least, rarely changes). For the same reason, design choices
    adopted in the implementation of a service must not constrain any other application
    service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的修改不应传播到其他服务。因此，每个服务都必须有一个定义良好的接口，该接口不会随着软件维护（或者至少很少改变）而改变。出于同样的原因，在服务实现中采用的设计选择不应限制任何其他应用程序服务。
- en: The first and second requirements can be satisfied by implementing each software
    module as a separate service so that we might allocate more hardware resources
    to it by simply replicating it in N different instances as needed to optimize
    the overall performance and ensure redundancy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将每个软件模块作为独立的服务实现，我们可以通过简单地将其复制到N个不同实例来分配更多硬件资源，从而满足第一和第二个要求，这样我们就可以优化整体性能并确保冗余。
- en: We also need a new actor, something that decides how many copies of each service
    to use and on what hardware to place them. There are similar entities called **orchestrators**.
    It is worth pointing out that we might also have several orchestrators, each taking
    care of a subset of the services, or no orchestrator at all!
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个新的参与者，它决定使用每个服务的副本数量以及将它们放置在什么硬件上。存在类似的实体，称为**编排器**。值得注意的是，我们可能也有几个编排器，每个编排器负责一组服务，或者根本没有任何编排器！
- en: Summing up, we moved from applications made of coarse-grained coupled web services
    to fine-grained and loosely coupled microservices, each implemented by a different
    developer team, as shown in the following figure.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结来说，我们从由粗粒度耦合的Web服务组成的应用程序转变为细粒度和松散耦合的微服务，每个微服务由不同的开发团队实现，如下所示。
- en: '![Figure 2.2: Microservices architecture](img/B31916_02_2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：微服务架构](img/B31916_02_2.png)'
- en: 'Figure 2.2: Microservices architecture'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：微服务架构
- en: The diagram shows fine-grained microservices assigned to different loosely coupled
    teams. It is worth pointing out that while loose coupling was also an initial
    target for the primordial web services architectures, it took time to improve
    to a good level, till reaching its peak with the advent of microservices techniques.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图表显示了分配给不同松散耦合团队的不同粒度微服务。值得注意的是，虽然松散耦合也是原始Web服务架构的初始目标之一，但需要时间才能提升到良好水平，直到微服务技术的出现使其达到顶峰。
- en: The preceding diagram and requirements do not define exactly what microservices
    are; they just explain the start of the microservices era. In the next section,
    we will give a more formal definition of microservices that reflects their current
    stage of evolution.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的图表和需求并没有精确地定义微服务是什么；它们只是解释了微服务时代的开始。在下一节中，我们将给出一个更正式的微服务定义，该定义反映了它们当前的进化阶段。
- en: The definition and organization of microservices architectures
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的定义和组织
- en: In this section, we will give a definition of microservices and detail their
    immediate consequences on an organization, distinguishing between the *microservices
    definition*, which is expected to change gradually over time, and *microservices
    practical organization*, which might evolve at a faster rate as new technologies
    appear.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将给出微服务的定义，并详细说明它们对组织立即产生的影响，区分*微服务定义*，它预计会随着时间的推移逐渐变化，以及*微服务实际组织*，它可能随着新技术的出现而更快地发展。
- en: In the first subsection, we will focus on the definition and its immediate consequences.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一小节中，我们将关注定义及其直接后果。
- en: A definition of microservices architectures
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的定义
- en: Let’s first list all the microservices requirements. Then, we will discuss each
    of them in a separate subsection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先列出所有微服务需求。然后，我们将分别讨论每个需求。
- en: 'A microservices architecture is an architecture based on SOA that satisfies
    all the constraints below:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是基于SOA的架构，满足以下所有约束：
- en: Module boundaries are defined according to the domain of expertise they require.
    As we will discuss in the subsections below, this should ensure they are loosely
    coupled.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块边界是根据它们所需的专业领域定义的。正如我们将在以下小节中讨论的，这应该确保它们是松散耦合的。
- en: Each module is implemented as a replicable service, called a **microservice**,
    where replicable means one can create several instances of each service to enforce
    scalability and redundancy.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都实现为一个可复制的服务，称为**微服务**，其中可复制的意思是可以创建每个服务的多个实例，以实现可扩展性和冗余。
- en: Each service can be implemented and maintained by a different team, where all
    teams are loosely coupled.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务可以由不同的团队实现和维护，其中所有团队都是松散耦合的。
- en: Each service has a well-defined interface known to all teams involved in the
    development project.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都有一个所有参与开发项目的团队都了解的明确接口。
- en: Communication protocols are decided at the project start and are known by all
    teams.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议在项目开始时决定，并且所有团队都知道。
- en: Each service must depend just on the interface exposed by the others and on
    the communication protocols adopted. In particular, no design choice adopted for
    a service can impose constraints on the implementation of the others.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务必须仅依赖于其他服务公开的接口和采用的通信协议。特别是，为某个服务采用的设计选择不能对其他服务的实现施加约束。
- en: You are encouraged to compare each of the above constraints with the requirements
    that led to the conception of microservices architecture discussed in the previous
    section. In fact, each of these constraints is the immediate result of one or
    more of the previous requirements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您将上述约束与上一节中讨论的导致微服务架构构思的需求进行比较。实际上，这些约束中的每一个都是前一个或多个需求直接的结果。
- en: Let’s discuss each constraint in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每个约束。
- en: Domain of expertise and microservices
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专业领域和微服务
- en: 'This constraint has the purpose of providing a practical rule for defining
    the boundary of each microservice so that microservices are kept loosely coupled
    and can be handled by loosely coupled teams. It is based on the theory of **domain-driven
    design** developed by Eric Evans (see *Domain-Driven Design*: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)).
    Here, we will go over just a few essential concepts of this theory, but if you’re
    interested in reading more, refer to the *Further reading* section for more details.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束的目的是提供一个实际规则来定义每个微服务的边界，以便微服务保持松散耦合，并且可以被松散耦合的团队处理。它基于由Eric Evans（参见*领域驱动设计*：[https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)）开发的**领域驱动设计**理论。在这里，我们将简要介绍这个理论的一些基本概念，但如果你有兴趣了解更多，请参阅*进一步阅读*部分以获取更多详细信息。
- en: Basically, each domain of expertise uses a typical language. Therefore, during
    the analysis, it is enough to detect changes in the language used by the experts
    you speak with to understand what is included in and excluded from each microservice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每个专业领域都使用一种典型的语言。因此，在分析过程中，只需检测你与之交谈的专家使用的语言的变化，就可以理解每个微服务包含的内容和排除的内容。
- en: The rationale behind this technique is that toughly interacting people always
    develop a specific language recognized by others who share the same domain of
    expertise, while the absence of such a common language is a signal of loose interaction.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的合理性在于，紧密互动的人们总是发展出一种被同一领域专家共享的特定语言，而缺乏这种共同语言则是松散互动的信号。
- en: This way, the application **domain** or an application **subdomain** is split
    into so-called **bounded contexts**, each characterized by the usage of a common
    language. It is worth pointing out that **domain**, **subdomain**, and **bounded
    context** are all core concepts of DDD. For more details on them and DDD, you
    may refer to the *Further reading* section, but our simple description should
    suffice for getting started with microservices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，应用**域**或应用**子域**被分割成所谓的**边界上下文**，每个上下文都由使用通用语言的特点所表征。值得注意的是，**域**、**子域**和**边界上下文**都是DDD的核心概念。有关它们和DDD的更多详细信息，您可以参考*进一步阅读*部分，但我们的简单描述应该足以开始使用微服务。
- en: Thus, we get the first division of the application into **bounded contexts**.
    Each is assigned to a team and a formal interface for each of them is defined.
    This interface becomes the specification of a microservice, and it is also everything
    the other teams must know about the microservice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了应用的第一种划分，即**边界上下文**。每个上下文都分配给一个团队，并为每个上下文定义一个正式的接口。这个接口成为微服务的规范，也是其他团队必须了解的关于微服务的所有信息。
- en: Then, each team that has been assigned a microservice can split it further into
    smaller microservices to scale each of them independently from the others, checking
    that each resulting microservice exchanges an acceptable quantity of messages
    with the others (loose coupling).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个被分配微服务的团队可以将它进一步分割成更小的微服务，以便独立于其他微服务对其进行扩展，同时检查每个结果微服务与其他微服务交换的消息量是否可接受（松散耦合）。
- en: The first division is used to split the work among the teams, while the second
    division is designed to optimize performance in various ways, which we will detail
    in the *Microservices organization* subsection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次划分用于在团队之间分配工作，而第二次划分旨在以各种方式优化性能，我们将在*微服务组织*子节中详细说明。
- en: Replicable microservices
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可复制的微服务
- en: 'There should be a way to create several instances of the same microservice
    and place them on the available hardware to allocate more hardware resources to
    the most critical microservices. For some applications or single microservices,
    this can be done manually; but, more often, dedicated software tools called **orchestrators**
    are adopted. In this book, we will describe two orchestrators: **Kubernetes**,
    in [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization
    with Kubernetes*, and **Azure Container Apps**, in [*Chapter 9*](Chapter_9.xhtml#_idTextAnchor261),
    *Simplifying Containers and Kubernetes: Azure Container Apps* *and other Tools*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一种方法来创建同一微服务的多个实例，并将它们放置在可用的硬件上，以便将更多的硬件资源分配给最关键的微服务。对于某些应用程序或单个微服务，这可以手动完成；但更常见的是，采用称为**编排器**的专用软件工具。在这本书中，我们将描述两个编排器：**Kubernetes**，在[*第8章*](Chapter_8.xhtml#_idTextAnchor205)，*使用Kubernetes进行实用微服务组织*，以及**Azure
    Container Apps**，在[*第9章*](Chapter_9.xhtml#_idTextAnchor261)，*简化容器和Kubernetes：Azure
    Container Apps* *和其他工具*。
- en: Splitting microservices development among different teams
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不同团队之间分割微服务开发
- en: The way microservices are defined, so that they can be assigned to different
    loosely coupled teams, has already been explained in the *Domain of expertise
    and microservices* subsection. Here, it is worth pointing out that the microservices
    defined at this stage are called **logical microservices**, and then each team
    can decide to split each logical microservice into one or more **physical microservices**
    for various practical reasons.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*领域专业知识和微服务*子节中已经解释了微服务的定义方式，以便它们可以被分配给不同松散耦合的团队。在这里，值得指出的是，在这个阶段定义的微服务被称为**逻辑微服务**，然后每个团队可以决定根据各种实际原因将每个逻辑微服务分割成一个或多个**物理微服务**。
- en: Microservices, interfaces, and communication protocols
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务、接口和通信协议
- en: Once microservices are assigned to different teams, it is time to define their
    interfaces and the communication protocol used for each kind of message. This
    information is shared among all teams so that each team knows how to communicate
    with the microservices handled by the other teams.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦微服务被分配给不同的团队，就是时候定义它们的接口和用于每种消息的通信协议了。这些信息在所有团队之间共享，以便每个团队都知道如何与其他团队处理的微服务进行通信。
- en: Only the interfaces of all logical microservices and the associated communication
    protocols must be shared among all teams, while the division of each logical microservice
    into physical microservices is just shared within each team.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在所有逻辑微服务的接口和相关的通信协议之间共享，而每个逻辑微服务如何划分为物理微服务的划分只是在每个团队内部共享。
- en: 'The coordination of the various teams, and the documentation and monitoring
    of all services, is achieved with various tools. Below are the main tools used:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 各个团队的协调以及所有服务的文档和监控是通过各种工具实现的。以下是主要使用的工具：
- en: '**Context maps** are a graphical representation of the organizational relationships
    among the various teams working on all application-bounded contexts.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文映射**是表示所有应用程序上下文团队之间组织关系的图形表示。'
- en: '**Service catalogs** collect information about all microservice requirements,
    teams, costs, and other properties. Tools like **Datadog** ([https://docs.datadoghq.com/service_catalog/](https://docs.datadoghq.com/service_catalog/))
    and **Backstage** ([https://backstage.io/docs/features/software-catalog/](https://backstage.io/docs/features/software-catalog/))
    perform various types of monitoring, while tools like **Postman** ([https://www.postman.com/](https://www.postman.com/))
    and **Swagger** ([https://swagger.io/](https://swagger.io/)) are mainly focused
    on formal requirements, such as the testing and automatic generation of clients
    for interacting with the services.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务目录**收集有关所有微服务需求、团队、成本和其他属性的信息。像**Datadog**([https://docs.datadoghq.com/service_catalog/](https://docs.datadoghq.com/service_catalog/))和**Backstage**([https://backstage.io/docs/features/software-catalog/](https://backstage.io/docs/features/software-catalog/))这样的工具执行各种类型的监控，而像**Postman**([https://www.postman.com/](https://www.postman.com/))和**Swagger**([https://swagger.io/](https://swagger.io/))这样的工具主要关注正式要求，例如测试和自动生成与服务交互的客户端。'
- en: Just the interfaces of the logical microservices are public
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只有逻辑微服务的接口是公开的
- en: The code of each microservice can’t make any assumptions about how the public
    interface of all other logical microservices is implemented. Nothing can be assumed
    about the technologies used (.NET, Python, Java, and so on) and their versions,
    and nothing can be assumed about the algorithms and data architectures used by
    other microservices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务的代码不能对其他所有逻辑微服务的公共接口的实现方式做出任何假设。关于所使用的科技（.NET、Python、Java等）及其版本，以及其他微服务使用的算法和数据架构，都不能做出任何假设。
- en: Having analyzed the definition of microservices architecture, and its immediate
    consequences, we can move to the current most practical way to organize them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分析了微服务架构的定义及其直接后果后，我们可以转向目前最实用的组织方式。
- en: Microservices organization
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务组织
- en: The first consequence of the independence of microservices design choices is
    that each microservice must have private storage because a shared database would
    cause dependencies among the microservices sharing it. Suppose microservices A
    and B both access the same database table, T. Now, we’re modifying microservice
    A to meet a new user’s requirements. As part of this update, the solution for
    A will require us to replace table T with two new tables, T1 and T2.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计选择独立性的第一个后果是，每个微服务都必须拥有私有存储，因为共享数据库会导致使用该数据库的微服务之间产生依赖。假设微服务A和B都访问同一个数据库表T。现在，我们正在修改微服务A以满足新用户的需求。作为这次更新的部分，A的解决方案将需要我们用两个新表T1和T2来替换表T。
- en: 'In a similar situation, we would be forced to also change the code of B to
    adapt it to the replacement of T with T1 and T2\. Clearly, the same limitation
    doesn’t apply to different instances of the same microservice, so they can both
    share the same database. To summarize, we can state the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，我们也必须修改B的代码以适应用T1和T2替换T。显然，同样的限制不适用于同一微服务的不同实例，因此它们可以共享同一个数据库。为了总结，我们可以陈述以下：
- en: Instances of different microservices can’t share a common database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不同微服务的实例不能共享一个公共数据库。
- en: Unfortunately, moving away from a single-application database inevitably leads
    to data duplication and coordination challenges. More specifically, the same chunk
    of data must be duplicated in several microservices, so when it changes, the change
    must be communicated to all microservices that are using a duplicated copy of
    it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，远离单一应用程序数据库不可避免地会导致数据重复和协调挑战。更具体地说，相同的数据块必须在几个微服务中重复，因此当它发生变化时，必须将变化通知所有使用其复制副本的微服务。
- en: 'Thus, we may state another organizational constraint:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以提出另一个组织约束：
- en: Microservices must be designed in a way that minimizes the duplication of data,
    or stated differently, duplications should involve as few microservices as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务必须以最小化数据重复的方式设计，或者换句话说，重复应尽可能涉及最少的微服务。
- en: As has been said in the previous section, if we define microservices according
    to the domain of expertise, the last constraint should be ensured automatically
    because different domains of expertise usually share just a little data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们根据专业领域定义微服务，最后一个约束应该自动得到保证，因为不同的专业领域通常共享的数据很少。
- en: No other constraints descend immediately from the definition of microservices,
    but it is enough to add a trivial performance constraint on the response time
    to force the organization of microservices in a way that it more closely resembles
    an assembly line than a usual user-request-driven software. Let’s see why.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他约束直接从微服务的定义中产生，但只需要在响应时间上添加一个微不足道的性能约束，就可以迫使微服务的组织方式更接近于装配线而不是通常的用户请求驱动的软件。让我们看看原因。
- en: 'A user request coming to microservice A might cause, in turn, a long chain
    of requests issued to other microservices, as shown in the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户请求到达微服务 **A** 可能会引发一系列对其他微服务的请求，如下面的图所示：
- en: '![Figure 2.3: Chain of synchronous request-responses](img/B31916_02_3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：同步请求-响应链](img/B31916_02_3.png)'
- en: 'Figure 2.3: Chain of synchronous request-responses'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：同步请求-响应链
- en: Messages 1-6 are triggered by a request to microservice *A* and are sent in
    sequence, so their processing times sum up to the response time. Moreover, microservice
    *A*, after having sent message *1*, remains blocked, waiting for a response, until
    it receives the last message (*6*); that is, it remains blocked for the whole
    lifetime of the overall chained communication process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 消息 1-6 是由对微服务 *A* 的请求触发的，并且按顺序发送，因此它们的处理时间总和等于响应时间。此外，微服务 *A* 在发送消息 *1* 后保持阻塞，等待响应，直到它收到最后一条消息
    (*6*)；也就是说，它在整个链式通信过程的整个生命周期内保持阻塞。
- en: Microservice **B** remains blocked twice, waiting for an answer to a request
    it issued. The first time is during the *2*-*3* communication and then the second
    is during the *4*-*5* communication. To sum up, a naive request-response pattern
    to microservices communication implies high response times and a waste of microservices
    computation time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务 **B** 两次被阻塞，等待它发出的请求的响应。第一次是在 *2*-*3* 通信期间，第二次是在 *4*-*5* 通信期间。总的来说，一个简单的请求-响应模式对微服务通信意味着高响应时间和微服务计算时间的浪费。
- en: The only ways to overcome the above problems are either avoiding complete dependencies
    among microservices or caching all information needed to satisfy any user request
    into the first microservice, *A*. Since reaching total independence is basically
    impossible, the usual solution is caching in *A* whatever data it needs to answer
    requests without asking for further information about other microservices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 克服上述问题的唯一方法要么是避免微服务之间的完全依赖，要么是将满足任何用户请求所需的所有信息缓存到第一个微服务，*A* 中。由于达到完全独立基本上是不可能的，通常的解决方案是在
    *A* 中缓存它需要回答请求而不需要进一步了解其他微服务的任何数据。
- en: To achieve this goal, microservices are proactive and adopt the so-called **asynchronous
    data-sharing** approach. Whenever they update data, they send the updated information
    to all other microservices that need it for their responses. Put simply, in the
    example above, tree nodes, instead of waiting for requests from their parent nodes,
    send pre-processed data to all their possible callers each time their private
    data changes, as shown in the figure below.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，微服务是主动的，并采用所谓的 **异步数据共享** 方法。每当它们更新数据时，它们会将更新的信息发送给所有需要这些信息的其他微服务。简单来说，在上面的例子中，树节点，而不是等待来自父节点的请求，每次它们的私有数据发生变化时，都会将预处理的发送给所有可能的调用者，如图下面的图所示。
- en: '![Figure 2.4: Data-driven communication](img/B31916_02_4.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：数据驱动通信](img/B31916_02_4.png)'
- en: 'Figure 2.4: Data-driven communication'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：数据驱动通信
- en: Both communications labeled *1* are triggered when the data of the *C*/*D* microservices
    changes, and they may occur in parallel. Moreover, once communication is sent,
    each microservice can return to its job without waiting for a response. Finally,
    when a request arrives at microservice *A*, it already has all the data it needs
    to build the response with no need to interact with other microservices. In general,
    microservices based on **asynchronous data sharing** pre-process data and send
    it to whichever other service might need it as soon as their data changes. This
    way, each microservice already contains precomputed data that it can use to respond
    immediately to user requests with no need for further request-specific communications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为*1*的两种通信都是在**C**/*D*微服务的数据发生变化时触发的，并且它们可能并行发生。此外，一旦通信被发送，每个微服务就可以返回其工作，而无需等待响应。最后，当请求到达微服务**A**时，它已经拥有了构建响应所需的所有数据，无需与其他微服务交互。一般来说，基于**异步数据共享**的微服务会在数据变化后立即预处理数据并将其发送给可能需要它的其他服务。这样，每个微服务已经包含了可以用来立即响应用户请求的预计算数据，无需进行进一步针对特定请求的通信。
- en: This time, we can’t speak of requests and responses but simply of messages exchanged.
    People working with classical web applications will be accustomed to request/response
    communications where a client issues a request and a server processes that request
    and sends back a response.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们无法谈论请求和响应，而只能简单地说成是交换的消息。与古典Web应用打交道的人会习惯于请求/响应通信，其中客户端发起请求，服务器处理该请求并发送响应。
- en: In general, in a request/response communication, one of the involved actors,
    say, **A**, sends a message containing a **request** to perform some specific
    processing to another actor, say, **B**, then **B** performs the required processing
    and returns a result (the **response**), which may also be an error notification.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在请求/响应通信中，涉及的参与者之一，比如**A**，会发送一个包含**请求**的消息，要求对另一个参与者，比如**B**，执行一些特定的处理，然后**B**执行所需的处理并返回一个结果（**响应**），这也可以是一个错误通知。
- en: However, we may also have communications that are not request/response-based.
    In this case, we simply speak of messages. In this case, there are not responses
    but just acknowledgments that the messages have been correctly received by either
    the final target or an intermediate actor. Differently from responses, acknowledgments
    are sent before completing the processing of the messages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能也有非请求/响应的通信。在这种情况下，我们只需说成是消息。在这种情况下，没有响应，只有确认消息已被最终目标或中间参与者正确接收。与响应不同，确认是在完成消息处理之前发送的。
- en: Returning to **asynchronous data sharing**, as new data becomes available, each
    microservice does its job and then sends the results to all interested microservices,
    and then it continues performing its job without waiting for a response from its
    recipients.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**异步数据共享**，当新数据可用时，每个微服务完成其工作后，将结果发送给所有感兴趣的微服务，然后继续执行其工作，而无需等待接收者的响应。
- en: Each sender just waits for an acknowledgment from its immediate recipient, so
    wait times do not add up like in the initial chained request/response example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个发送者只需等待其直接接收者的确认，因此等待时间不会像在最初的链式请求/响应示例中那样累加。
- en: What about message acknowledgments? They also cause small delays. Is it possible
    to also remove this smaller inefficiency? Of course, with the help of asynchronous
    communication!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，消息确认呢？它们也会引起小的延迟。是否有可能也消除这种较小的低效？当然，借助异步通信可以做到！
- en: In synchronous communication, the sender waits for the message acknowledgment
    before continuing its processing. This way, if the acknowledgment times out or
    is replaced by an error notification, the sender can perform corrective actions,
    such as resending the message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步通信中，发送者在继续其处理之前等待消息确认。这样，如果确认超时或被错误通知取代，发送者可以执行纠正操作，例如重新发送消息。
- en: In asynchronous communication, the sender doesn’t wait for either an acknowledgment
    or an error notification but continues its processing, immediately after the message
    is sent, while acknowledgments or error notifications are sent to a callback.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步通信中，发送者不会等待确认或错误通知，而是在消息发送后立即继续其处理，同时确认或错误通知被发送到回调。
- en: Asynchronous communication is more effective in microservices because it completely
    avoids wait times. However, the necessity to perform corrective actions in case
    of possible errors complicates the overall message-sending action. More specifically,
    all sent messages must be added to a queue, and each time an acknowledgment arrives,
    the message is marked as correctly sent and removed from this queue. Otherwise,
    if no acknowledgment arrives within a configurable `timeout` time, or if an error
    is raised, the message is marked to be re-sent according to some retry policies.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，异步通信更有效，因为它完全避免了等待时间。然而，在可能出错的情况下执行纠正措施的需要使得整体的消息发送动作变得复杂。更具体地说，所有发送的消息都必须添加到队列中，每次收到确认时，消息被标记为正确发送并从队列中移除。否则，如果在可配置的`timeout`时间内没有收到确认，或者发生错误，则根据某些重试策略将消息标记为需要重发。
- en: 'The microservices **asynchronous data-sharing** approach is often accompanied
    by the so-called **Command Query Responsibility Segregation** (**CQRS**) pattern.
    According to CQRS, microservices are split into *updates microservices*, which
    perform the usual CRUD operations, and *query microservices*, which are specialized
    in answering queries that aggregate data from several other microservices, as
    shown in the following figure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务异步数据共享方法通常伴随着所谓的**命令查询责任分离**（**CQRS**）模式。根据CQRS，微服务被分为*更新微服务*，执行常规的CRUD操作，以及*查询微服务*，专门回答从多个其他微服务聚合数据的查询，如下图所示：
- en: '![Figure 2.5: Updates and query microservices](img/B31916_02_5.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：更新和查询微服务](img/B31916_02_5.png)'
- en: 'Figure 2.5: Updates and query microservices'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：更新和查询微服务
- en: According to the **asynchronous data-sharing** approach, each update microservice
    sends all its modifications to the query services that need them, while query
    microservices precompute all queries to ensure short response times. It is worth
    pointing out that data-driven updates resemble a factory assembly line that builds
    all possible query results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据异步数据共享方法，每个更新微服务将其所有修改发送到需要它们的查询服务，而查询微服务预先计算所有查询以确保快速响应时间。值得注意的是，数据驱动更新类似于一个工厂装配线，构建所有可能的查询结果。
- en: Both updates and query microservices are called **frontend** microservices because
    they are involved in the usual request-response pattern with the user. However,
    data updates in their path may also encounter microservices that do not interact
    at all with a user. They are called **worker** microservices. The following figure
    shows the relationship between worker and frontend microservices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 更新和查询微服务都被称为**前端**微服务，因为它们参与了与用户的常规请求-响应模式。然而，它们路径中的数据更新也可能遇到完全不与用户交互的微服务。它们被称为**工作**微服务。以下图显示了工作微服务和前端微服务之间的关系。
- en: '![Figure 2.6: Frontend and worker microservices](img/B31916_02_6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：前端和工作微服务](img/B31916_02_6.png)'
- en: 'Figure 2.6: Frontend and worker microservices'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：前端和工作微服务
- en: While frontend microservices usually respond to several user requests in parallel
    by creating a thread for each request, worker microservices are involved only
    in data updates, so they don’t need to parallelize requests to ensure low response
    times to the user.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前端微服务通常通过为每个请求创建一个线程来并行响应多个用户请求，但工作微服务仅涉及数据更新，因此它们不需要并行化请求以确保对用户的低响应时间。
- en: Accordingly, their operation is completely analogous to the one of the stations
    that compose an assembly line. They extract their input messages from an input
    queue and process them one after the other. Output data is sent to all interested
    microservices as soon as they are available. This kind of processing is called
    **data-driven**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们的操作与组成装配线的各个站点的操作完全类似。它们从输入队列中提取输入消息，并依次处理它们。一旦可用，输出数据就会发送到所有感兴趣的微服务。这种处理方式被称为**数据驱动**。
- en: One might object that worker microservices are not necessary since their job
    might be taken care of by the frontend services that consume their outputs. This
    is not the case! For instance, let’s imagine accounting data that needs to be
    consolidated over a period of time before being used as fields of complex queries.
    Of course, each query microservice that needs the consolidated data might take
    care of consolidating it. However, this would result in the duplication of the
    processing effort and the storage needed to hold the partial sums.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会反对，认为工作微服务是不必要的，因为他们的工作可能已经被消费他们输出的前端服务处理了。这并不是事实！例如，让我们想象一下需要在一个时间段内合并的会计数据，然后才能用作复杂查询的字段。当然，每个需要合并数据的查询微服务都可能负责合并它。然而，这会导致处理努力和存储部分总和的重复。
- en: Moreover, embedding the consolidation processing in other microservices would
    enable its independent scaling, with better optimization of the overall performance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将合并处理嵌入到其他微服务中，将使其能够独立扩展，从而更好地优化整体性能。
- en: The next subsection shows an example that exemplifies all the concepts learned
    so far.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示一个示例，该示例展示了迄今为止学到的所有概念。
- en: Car-sharing example
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汽车共享示例
- en: The following figure shows a communication diagram of the routes-handling part
    of a car-sharing application. Dashed lines surround all physical microservices
    belonging to the same logical microservice. Query microservices are at the top
    of the image, updates microservices are at the bottom, and worker microservices
    are in the middle (with gray shading).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了汽车共享应用路线处理部分的通信图。虚线包围属于同一逻辑微服务的所有物理微服务。查询微服务位于图像的顶部，更新微服务位于底部，工作微服务位于中间（带有灰色阴影）。
- en: '![Figure 2.7: Route-handling subsystem of a car-sharing application](img/B31916_02_7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：汽车共享应用的路线处理子系统](img/B31916_02_7.png)'
- en: 'Figure 2.7: Route-handling subsystem of a car-sharing application'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：汽车共享应用的路线处理子系统
- en: The language analysis detected two logical microservices. The first one speaks
    the language of the car sharer and is made of six physical microservices. The
    second one is focused on topology since it finds the best routes between a source
    and a destination and matches intermediate source-destination pairs with existing
    routes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 语言分析检测到两个逻辑微服务。第一个说的是汽车共享者的语言，由六个物理微服务组成。第二个专注于拓扑，因为它在源点和目的地之间找到最佳路线，并将中间源-目的地对与现有路线相匹配。
- en: Car holders handle their requests with CRUD operations on the `Car-Holding-Requests`
    updates microservice, while users looking for a car interact with the `Car-Seeking-Requests`
    updates microservice in a similar way. The `Routes-Listing` microservice lists
    all available trips with empty slots for new passengers to help car seekers choose
    the date of their trip. Once the date is chosen, the request is submitted through
    the `Car-Seeking-Requests` microservice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车持有者通过在`Car-Holding-Requests`更新微服务上执行CRUD操作来处理他们的请求，而寻找汽车的用户则以类似的方式与`Car-Seeking-Requests`更新微服务进行交互。`Routes-Listing`微服务列出所有有空位的新乘客可用行程，以帮助汽车寻求者选择他们的旅行日期。一旦选择了日期，请求将通过`Car-Seeking-Requests`微服务提交。
- en: Both car holders and car seekers interact with the `Route-Choosing` updates
    microservice. Car seekers choose one of several available routes for both the
    source and destination, while car holders accept car seekers by selecting the
    routes that fit their sources and destinations. Once a route is selected by a
    car seeker and accepted by the car holder, all other incompatible options are
    deleted from the best matches of both the car holder and the car seeker.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车持有者和汽车寻求者都与`Route-Choosing`更新微服务进行交互。汽车寻求者会从几个可用的路线中选择源点和目的地的路线，而汽车持有者则通过选择适合其源点和目的地的路线来接受汽车寻求者。一旦汽车寻求者选择了一条路线并被汽车持有者接受，所有其他不兼容的选项都将从汽车持有者和汽车寻求者的最佳匹配中删除。
- en: All available routes for both car seekers and car holders are listed by the
    `My-Best-Matches` microservice. The `Routes-Planner` worker microservice computes
    the best routes that fit for the source and destination of a car holder that contains
    also sources and destinations for some car seekers. It stores unmatched car-seeker
    requests until a route passing at an acceptable distance from them is added. When
    this happens, the `Routes-Planner` microservice creates a new alternative route
    for the same trip that contains the new source-destination pair. All routes’ changes
    are sent to both the `My-Best-Matches` and `Route-Choosing` microservices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`My-Best-Matches` 微服务列出了汽车寻求者和车主的所有可用路线。`Routes-Planner` 工作微服务计算适合车主出发地和目的地的最佳路线，这些路线也包含了一些汽车寻求者的出发地和目的地。它存储未匹配的汽车寻求者请求，直到添加了一个距离它们可接受的路线。当这种情况发生时，`Routes-Planner`
    微服务为相同的行程创建了一条新的替代路线，包含新的出发地-目的地对。所有路线的变化都会发送到`My-Best-Matches`和`Route-Choosing`微服务。'
- en: The `Locations-Listing` microservice handles a database of known locations,
    and it is used in various kinds of user suggestions, such as autocomplete of user
    sources and destinations and suggestions for interesting trips based on user preferences
    statistics. It takes its input from all car-holder and car-seeker requests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Locations-Listing` 微服务处理已知位置的数据库，并用于各种用户建议，例如用户来源和目的地的自动完成以及基于用户偏好统计的建议有趣行程。它从所有汽车车主和汽车寻求者的请求中获取输入。'
- en: We have seen what kind of problems microservices were conceived to solve and
    how their adoption adds complexity to the application design. Moreover, it is
    not difficult to imagine that testing and maintaining an application that runs
    on several different machines and relies on complex data-driven communication
    patterns should be a complex and time-consuming task.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了微服务旨在解决的问题以及它们的采用如何增加了应用程序设计的复杂性。此外，不难想象，测试和维护运行在多个不同机器上并依赖于复杂数据驱动通信模式的应用程序应该是一项复杂且耗时的任务。
- en: Therefore, it is important to assess the impact of using microservices architecture
    in our application to verify that the cost is affordable and that the advantages
    of the adoption outweigh the disadvantages and extra costs. In the next section,
    we will cover some criteria for facing this kind of assessment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，评估在我们应用程序中使用微服务架构的影响非常重要，以验证成本是否可承受，以及采用微服务的优势是否超过其劣势和额外成本。在下一节中，我们将介绍一些评估此类评估的标准。
- en: When is it worth adopting microservices architectures?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时采用微服务架构才是值得的？
- en: An application that requires more than five developers is certainly a good target
    for a microservices architecture since logical microservices help split the workforce
    into small, loosely coupled teams.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要超过五个开发者的应用程序无疑是微服务架构的良好目标，因为逻辑微服务有助于将劳动力分成小型、松散耦合的团队。
- en: A high-traffic application with several time-consuming modules is also a good
    target for microservices architecture since it needs module-level performance
    optimizations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个耗时模块的高流量应用程序也是微服务架构的良好目标，因为它需要模块级性能优化。
- en: Low-traffic applications that require just a small team of less than five people
    for their implementation are not a good target for a microservices architecture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只需要不到五人的小团队实现的应用程序，流量较低，不是微服务架构的良好目标。
- en: Deciding when to adopt microservices in all other situations that fall between
    the above extreme cases is not easy. In general, it requires a detailed analysis
    of costs and returns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两种极端情况之间决定何时采用微服务并不容易。一般来说，这需要详细分析成本和回报。
- en: Considering costs, using a microservices architecture requires a development
    effort of about five times that of a usual monolithic application. We got this
    scale as an average on 7 total rewrites of monolithic applications with a Microservices
    architecture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到成本，采用微服务架构的开发工作量大约是传统单体应用的五倍。我们通过将单体应用转换为微服务架构，平均进行了7次重写，得到了这个规模。
- en: This is in part due to the extra effort needed to handle reliable communications,
    coordination, and detailed resource management. However, most of the costs come
    from the difficulties of testing, debugging, and monitoring a distributed application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分原因是处理可靠通信、协调和详细资源管理所需的额外工作量。然而，大部分成本来自测试、调试和监控分布式应用程序的困难。
- en: Later in the book, we will describe tools and methodologies for efficaciously
    handling all of the above problems, but the extra cost brought on by microservices
    remains.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将描述处理上述所有问题的工具和方法，但微服务带来的额外成本仍然存在。
- en: Considering expected returns, the most significant advantage is the capability
    of focusing maintenance on just the critical modules, since if the interface of
    a microservice doesn’t change also the more drastic changes in its implementation,
    such as moving to a different operating system, or to a different development
    stack, or simply to a newer version of the same stack, will not require any change
    to all other Microservices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到预期回报，最显著的优势是能够将维护集中在关键模块上，因为如果微服务的接口没有变化，那么其实现中的更剧烈的变化，例如迁移到不同的操作系统，或迁移到不同的开发堆栈，或者简单地迁移到同一堆栈的新版本，也不需要对所有其他微服务进行任何更改。
- en: We may decide to reduce the maintenance of modules that do not require several
    market-critique changes to a minimum while focusing on just the market-critique
    modules that either increase the perceived value of the application or require
    changes to adapt them to a quickly evolving market. To summarize, we may focus
    on just the important changes required by the users, leaving all modules that
    are not involved in these changes unchanged.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会决定将不需要进行多次市场审查更改的模块的维护减少到最低限度，同时专注于仅增加应用程序感知价值或需要更改以适应快速发展的市场的市场审查模块。总之，我们可能会专注于用户所需的重要更改，而将所有不涉及这些更改的模块保持不变。
- en: Focusing on just a few modules ensures a low time to market, so we can satisfy
    market opportunities as soon as they appear without the risk of releasing a new
    version too late.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于仅几个模块可以确保快速上市时间，因此我们可以尽快满足市场机会，而不会存在发布新版本过晚的风险。
- en: We are also able to fine-tune performance quickly when the traffic on some specific
    functionalities increases by scaling just the involved microservices. It is worth
    pointing out that the capability of fine-tuning each specific building block of
    our application allows for better usage of the available hardware, thus reducing
    the overall hardware costs. Moreover, the ability to fine-tune and monitor specific
    microservices simplifies achieving better response times and, in general, performance
    goals.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些特定功能的流量增加时，我们也可以通过仅扩展相关的微服务来快速调整性能。值得注意的是，调整每个特定构建块的能力允许更好地利用可用硬件，从而降低整体硬件成本。此外，调整和监控特定微服务的能力简化了实现更好的响应时间和总体性能目标。
- en: Having analyzed the evolution that led to the microservices architecture, as
    well as its very nature and basic organization, we can move on to patterns that,
    while not specific to microservices, are common in microservices architectures.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了导致微服务架构演变的演变过程，以及其本质和基本组织之后，我们可以继续探讨虽然不是特定于微服务，但在微服务架构中常见的模式。
- en: Microservices common patterns
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务常见模式
- en: In this section, we will analyze the fundamental patterns used in all microservices
    architectures whose description is not tied to a specific programming language
    or tool. Most of them concern microservice communication. Let’s start with common
    retry strategies.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析所有微服务架构中使用的根本模式，这些模式与特定的编程语言或工具无关。其中大部分与微服务通信有关。让我们从常见的重试策略开始。
- en: Resilient task execution
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性任务执行
- en: Microservices can be moved from one machine to another to achieve better load
    balancing. They can also be restarted to reset some possible memory leaks or to
    solve other performance issues. During these operations, they may miss some messages
    sent to them, or they may abort some ongoing computation. Moreover, failure due
    to software bugs or hardware faults may occur, too.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以从一台机器移动到另一台机器，以实现更好的负载均衡。它们也可以被重新启动，以重置一些可能的内存泄漏或解决其他性能问题。在这些操作过程中，它们可能会错过发送给它们的某些消息，或者可能会中断某些正在进行的计算。此外，由于软件错误或硬件故障也可能发生。
- en: Since microservices architectures are required to be reliable (almost zero downtime),
    they are usually redundant, and particular care is needed to detect faults and
    apply corrective actions. Therefore, all microservices architectures must provide
    mechanisms to both detect failures, such as simple timeouts, and correct failed
    operations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务架构需要具有可靠性（几乎零停机时间），它们通常是冗余的，并且需要特别注意检测故障和采取纠正措施。因此，所有微服务架构都必须提供机制来检测失败，例如简单的超时，以及纠正失败的操作。
- en: Failures are detected through the detection of either unexpected exceptions
    or timeouts. Since the code can always be arranged in a way to turn timeouts into
    exceptions, failure detection can always be reduced to adequate exception handling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 失败是通过检测意外异常或超时来发现的。由于代码总是可以安排成将超时转换为异常，因此失败检测总能被简化为适当的异常处理。
- en: To resolve this problem, the community of microservices developers defined useful
    **retry policies** one can attach to specific exceptions. They are usually implemented
    through specific libraries together with other reliability patterns, but sometimes
    they are offered out of the box by cloud providers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，微服务开发者的社区定义了一些有用的**重试策略**，可以将它们附加到特定的异常上。它们通常通过特定的库以及其他的可靠性模式来实现，但有时云提供商会直接提供这些功能。
- en: 'Below are the standard reliability patterns used in microservices architectures:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是微服务架构中使用的标准可靠性模式：
- en: '**Exponentials retry**: It has been designed to overcome temporary faults,
    such as a failure due to a microservice instance restart. After each failure,
    the operation is retried with a delay that increases exponentially with the number
    of attempts, until a maximum number of attempts is reached. For instance, first,
    we would retry after 10 milliseconds, and if this retry operation results in a
    new failure, a new attempt is made after 20 milliseconds, then after 40 milliseconds,
    and so on. If the maximum number of attempts is reached, an exception is thrown,
    where it can find another retry policy or some other exception-handling strategy.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指数重试**：它被设计用来克服暂时性故障，例如由于微服务实例重启导致的失败。在每次失败后，操作会以指数级增加的延迟重新尝试，直到达到最大尝试次数。例如，首先，我们会在10毫秒后重试，如果这次重试操作导致新的失败，那么会在20毫秒后进行新的尝试，然后是40毫秒，以此类推。如果达到最大尝试次数，则会抛出异常，此时可以找到另一个重试策略或某种其他异常处理策略。'
- en: '**Circuit break**: It has been designed to handle long-term failures and it
    is usually triggered after an exponential retry reaches its maximum number of
    retries. When a long-term failure is assumed, access to the resource is interdicted
    for a fixed amount of time by returning an immediate exception without attempting
    all the required operations. The interdiction time must be sufficient to allow
    human intervention or any other kind of manual fix.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：它被设计用来处理长期故障，通常在指数重试达到最大重试次数后触发。当假设存在长期故障时，通过立即抛出异常而不尝试所有必要的操作来禁止对资源的访问。禁止时间必须足够长，以便允许人工干预或任何其他类型的手动修复。'
- en: '**Bulkhead isolation**: Bulkhead isolation has been designed to prevent failure
    and congestion propagation. The basic idea is to organize services and/or resources
    into isolated partitions so that failures or congestions originating in a partition
    remain confined to that partition, and the remainder of the system continues working
    properly.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离舱隔离**：隔离舱隔离被设计用来防止故障和拥塞的传播。基本思想是将服务和/或资源组织成隔离的部分，使得来自某个部分的故障或拥塞仅限于该部分，而系统的其余部分继续正常工作。'
- en: Suppose, for instance, that several microservice replicas use the same database
    (as is common). Due to a failure, a replica might start opening too many database
    connections, thus also congesting all other replicas that need to access the same
    database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，几个微服务副本使用相同的数据库（这是常见的）。由于一个故障，一个副本可能会开始打开过多的数据库连接，从而也会使需要访问相同数据库的所有其他副本发生拥塞。
- en: In this case, we recognize that database connections are critical resources
    that need bulkhead isolation. Thus, we compute the maximum number of connections
    the database can properly handle and partition them among all replicas, assigning,
    for instance, a maximum of five simultaneous connections to each microservice
    replica.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们认识到数据库连接是关键资源，需要隔离舱隔离。因此，我们计算数据库可以正确处理的连接的最大数量，并将它们分配给所有副本，例如，为每个微服务副本分配最多五个并发连接。
- en: 'This way, a failure in a replica doesn’t affect the proper access of other
    replicas to the database. Moreover, if the application is properly organized,
    requests that fail to be served because of the failed replica will eventually
    be retried on a properly working replica so that the overall application can continue
    working properly. In general, if we would like to partition all requests to a
    shared resource, we can proceed as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，副本的故障不会影响其他副本对数据库的正确访问。此外，如果应用程序组织得当，由于失败的副本而未能得到服务的请求最终将在正常工作的副本上重试，从而使整个应用程序能够继续正常运行。一般来说，如果我们想对共享资源的所有请求进行分区，我们可以按以下步骤进行：
- en: Only a maximum number of similar pending simultaneous outbound requests to the
    shared resource is allowed; let’s say 5, as in the previous database example.
    This is like putting an upper bound on thread creation.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许对共享资源的最大类似待处理同时出站请求数量；比如说5，就像之前的数据库示例中那样。这就像对线程创建设置一个上限。
- en: Requests exceeding the previous bound are queued.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超过之前上限的请求将被排队。
- en: If a maximum queue length is reached, any further requests result in exceptions
    being thrown to abort them.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果达到最大队列长度，任何进一步的请求将引发异常以终止它们。
- en: It is worth pointing out that the requests partitioning and throttling pattern
    previously shown is a common way of applying bulkhead isolation, but it is not
    the only way. Any partition plus isolation strategy can be classified as bulkhead
    isolation. For instance, one might split the replicas of two interacting microservices
    into two isolated partitions such that only replicas belonging to the same partition
    might interact. This way, a failure in a partition can’t affect the other partition.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，之前展示的请求分区和节流模式是应用隔离舱隔离的常见方式，但并非唯一方式。任何分区加隔离策略都可以归类为隔离舱隔离。例如，可以将两个交互式微服务的副本分成两个隔离分区，这样只有属于同一分区的副本才能交互。这样，分区中的故障不会影响另一个分区。
- en: Together with the actions and strategies for handling failures exposed above,
    microservices architectures also offer failure prevention strategies. Failure
    prevention is achieved by monitoring anomalous consumptions of hardware resources
    and performing periodic hardware and software health checks. For this purpose,
    orchestrators monitor the usage of memory and CPU resources and restart a microservice
    instance or add a new instance when they fall out of a developer-defined range.
    Moreover, they offer the possibility of declaring periodic software checks that
    the orchestrator can perform to verify if the microservice is working properly.
    The most common of such health checks is a call to a **health REST endpoint**
    exposed by the microservice. Again, if the microservice fails a health check,
    it is restarted.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面提到的处理故障的动作和策略，微服务架构还提供了故障预防策略。通过监控硬件资源的异常消耗和定期进行硬件和软件健康检查来实现故障预防。为此，编排器监控内存和CPU资源的使用情况，并在它们超出开发者定义的范围时重启微服务实例或添加新的实例。此外，它们还提供了声明周期性软件检查的可能性，编排器可以执行这些检查以验证微服务是否正常运行。最常见的此类健康检查是调用微服务公开的**健康REST端点**。再次强调，如果微服务未能通过健康检查，它将被重启。
- en: When a hardware node fails a health check, all of its microservices are moved
    to a different hardware node.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个硬件节点未能通过健康检查时，其所有微服务将被转移到不同的硬件节点。
- en: Efficacious handling of asynchronous communication
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效处理异步通信
- en: 'Asynchronous communication with associated asynchronous acknowledgment causes
    three important problems:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与相关的异步确认一起的异步通信导致三个重要问题：
- en: Since after the communication the sending microservice moves to serving other
    requests without waiting for the acknowledgment, it must keep a copy of all messages
    it sent until an acknowledgment or a communication failure, such as a timeout,
    is detected, so that it can retry the operation (with an exponential retry, for
    instance), or it can take another kind of corrective action.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在通信后，发送微服务会转向处理其他请求而无需等待确认，因此它必须保留所有已发送消息的副本，直到检测到确认或通信故障（如超时），以便它可以重试操作（例如，使用指数重试），或者它可以采取其他类型的纠正措施。
- en: Since in case of a timeout a message may be re-sent, the intended recipient
    can receive several copies of the same message.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在超时的情况下，消息可能会被重新发送，因此预期的接收者可能会收到相同消息的多个副本。
- en: Messages can reach a recipient in an order that is different from the one they
    were sent. For instance, if two messages that instruct the recipient to modify
    the name of a product are sent in the order M1, M2, we expect the final name to
    be the one contained in M2\. However, if the recipient receives the two messages
    in the wrong order, M2, M1, the final product name will be the one contained in
    M1, thus causing an error.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息可以以与发送时不同的顺序到达接收者。例如，如果两个指示接收者修改产品名称的消息按顺序M1, M2发送，我们期望最终名称是M2中包含的名称。然而，如果接收者以错误的顺序接收这两条消息，M2,
    M1，最终的产品名称将是M1中包含的名称，从而造成错误。
- en: 'The first problem is handled by keeping all messages in a queue, as shown in
    the following figure:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题通过将所有消息保存在队列中解决，如图所示：
- en: '![Figure 2.8: Output message queue](img/B31916_02_8.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：输出消息队列](img/B31916_02_8.png)'
- en: 'Figure 2.8: Output message queue'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：输出消息队列
- en: When an acknowledgment is received, the involved message is removed from the
    queue. If, on the contrary, a failure or timeout is detected, the message is added
    to the end of the queue to be retried. If a retry must be handled with an exponential
    retry, each queue entry must contain both the number of the current attempt and
    the minimum time when the message can be re-sent.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到确认时，相关的消息将从队列中移除。相反，如果检测到失败或超时，消息将被添加到队列末尾以重新尝试。如果必须使用指数重试来处理重试，则每个队列条目都必须包含当前尝试的次数和消息可以重新发送的最小时间。
- en: The second and third problems require that each received message has a unique
    identifier and a sequence number. The unique identifier helps recognize and discard
    duplicates, while the sequence number helps the recipient to reconstruct the right
    message order. The following figure shows a possible implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个问题要求每个接收到的消息都有一个唯一的标识符和序列号。唯一的标识符有助于识别和丢弃重复项，而序列号有助于接收者重建正确的消息顺序。以下图示展示了一种可能的实现。
- en: '![Figure 2.9: Input message queue](img/B31916_02_9.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：输入消息队列](img/B31916_02_9.png)'
- en: 'Figure 2.9: Input message queue'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：输入消息队列
- en: Messages can be read from the input queue only after all sequence holes before
    them have been filled and read, while duplicates are easily recognized and discarded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在它们前面的所有序列空缺都被填补并读取之后，才能从输入队列中读取消息，而重复的消息则容易识别并丢弃。
- en: Event-based communications
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于事件的通信
- en: Suppose we add a new microservice to the car-sharing application in *Figure
    2.7*, say, a worker microservice that computes statistics about user trips. We
    would be forced to modify all microservices it needs input from, because all these
    microservices must also send some messages to the newly added microservice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在图2.7中的拼车应用中添加一个新的微服务，比如一个计算用户行程统计的工人微服务。我们将被迫修改所有需要从它那里获取输入的微服务，因为这些微服务也必须向新添加的微服务发送一些消息。
- en: The main constraint of microservices architectures is that modifications to
    a microservice must not propagate to other microservices, but by simply adding
    a new microservice, we have already violated this basic principle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的主要约束是，对微服务的修改不能传播到其他微服务，但我们通过简单地添加一个新的微服务，已经违反了这个基本原则。
- en: To overcome this problem, messages that might also interest newly added microservices
    are handled with the **publisher-subscriber** pattern. That is, the sender sends
    the message to a publisher endpoint instead of sending it directly to the final
    recipients. Then, each microservice that is interested in that message simply
    subscribes to this endpoint, so that the subscription endpoint will automatically
    send to it all messages it receives. The following figure shows how the publisher-subscriber
    pattern works.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，可能会引起新添加的微服务兴趣的消息，使用**发布-订阅**模式进行处理。也就是说，发送者将消息发送到发布者端点，而不是直接发送给最终接收者。然后，每个对这条消息感兴趣的微服务只需订阅这个端点，这样订阅端点就会自动发送它接收到的所有消息。以下图示展示了发布-订阅模式的工作原理。
- en: '![Figure 2.10: Publisher-subscriber pattern](img/B31916_02_10.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：发布-订阅模式](img/B31916_02_10.png)'
- en: 'Figure 2.10: Publisher-subscriber pattern'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：发布-订阅模式
- en: Once a publish endpoint receives a message, it resends it to all subscribers
    that added themselves to its subscriptions queue. This way, if we add a new microservice,
    no modification is required for all message senders since they need just to continue
    sending their messages to the adequate publish endpoints. It is up to the newly
    added microservice to register itself to the proper publish endpoints.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布端点收到一条消息，它就会将其重新发送到所有添加到其订阅队列的订阅者。这样，如果我们添加一个新的微服务，就不需要对所有消息发送者进行任何修改，因为他们只需要继续将他们的消息发送到适当的发布端点。新添加的微服务需要将自己注册到正确的发布端点。
- en: Publish endpoints are handled by applications called message brokers that offer
    this service together with other message-delivering services. Message brokers
    can be deployed themselves as replicable microservices, but they are typically
    offered as standard services by all main cloud providers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 发布端点由称为消息代理的应用程序处理，这些代理提供此服务以及其他消息传递服务。消息代理本身可以作为可复制的微服务部署，但它们通常由所有主要云提供商作为标准服务提供。
- en: Among them, it is worth mentioning **RabbitMQ**, which must be installed as
    a microservice, and **Azure Service Bus**, which is available as a cloud service
    in Azure. We will say more about them throughout the rest of the book, but interested
    readers may find links with more details in the *Further reading* section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，值得提及的是**RabbitMQ**，它必须作为微服务安装，以及**Azure Service Bus**，它在 Azure 中作为云服务提供。我们将在本书的其余部分详细介绍它们，但感兴趣的读者可以在*进一步阅读*部分找到更多详细信息。
- en: Interfacing the external world
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与外部世界的接口
- en: Microservices applications are usually confined to a private network and expose
    their services through public or private IP addresses by means of gateways, load
    balancers, and web servers. These components may route external addresses to internal
    microservices. However, it is hard to leave to the user client-application the
    choice of the microservice to send each of their requests to.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用程序通常局限于私有网络，并通过网关、负载均衡器和 Web 服务器通过公共或私有 IP 地址公开其服务。这些组件可以将外部地址路由到内部微服务。然而，很难让用户客户端应用程序选择将每个请求发送到哪个微服务。
- en: Typically, input requests are all handled by a unique endpoint called an **API
    gateway** that analyzes them and translates the request to an appropriate request
    for internal microservices. This way, the user client application doesn’t need
    any knowledge of how the microservices application is organized internally. Therefore,
    we are free to change the application organization during its maintenance without
    affecting the clients that use it, since the needed translations are performed
    by the application API gateway. This process is known as **web API interface translation**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，输入请求都由一个独特的端点处理，称为**API 网关**，它分析这些请求并将请求转换为适合内部微服务的请求。这样，用户客户端应用程序不需要了解微服务应用程序的内部组织方式。因此，在维护期间，我们可以自由地更改应用程序的组织，而不会影响使用它的客户端，因为所需的转换是由应用程序
    API 网关执行的。这个过程被称为**Web API 接口转换**。
- en: 'The following figure summarizes the API gateway operation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下图总结了 API 网关的操作：
- en: '![Figure 2.11: API gateway](img/B31916_02_11.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11：API 网关](img/B31916_02_11.png)'
- en: 'Figure 2.11: API gateway'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：API 网关
- en: API gateways can also handle application versioning by sending all requests
    to the microservices that belong to the version required by the client application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关还可以通过将所有请求发送到属于客户端应用程序所需版本的微服务来处理应用程序版本。
- en: Moreover, they typically also handle authentication tokens; that is, they have
    the keys to decode them and to verify all user information they contain, such
    as user ID and its access privileges.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们通常还处理身份验证令牌；也就是说，它们有解码它们的密钥，并验证它们包含的所有用户信息，例如用户 ID 和其访问权限。
- en: Please do not confuse authentication with login. Login is performed once per
    session when the user starts interacting with the application, and it is performed
    by a dedicated microservice. The result of a successful login is an authentication
    token that encodes information about the user and that must be included in all
    subsequent requests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要将身份验证与登录混淆。登录是在用户开始与应用程序交互时每次会话中执行一次，并且由一个专门的微服务执行。成功登录的结果是一个身份验证令牌，它编码了有关用户的信息，并且必须在所有后续请求中包含。
- en: 'Summing up, API gateways offer the following services:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，API 网关提供以下服务：
- en: Web API interface translation
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API 接口转换
- en: Versioning
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本
- en: Authentication
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'However, they often also offer other services, such as:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们通常还提供其他服务，例如：
- en: API documentation endpoints, that is, endpoints that offer a formal description
    of the services offered by the application and how to request them. In the case
    of REST communication, API documentation is based on the **OpenAPI** standard
    (see *Further reading*).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 文档端点，即提供应用提供的服务正式描述以及如何请求它们的端点。在 REST 通信的情况下，API 文档基于 **OpenAPI** 标准（参见
    *进一步阅读*）。
- en: Caching, that is, adding the right HTTP headers to handle appropriate caching
    of all responses in both the user client and the web intermediate nodes.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存，即向用户客户端和 Web 中间节点添加适当的 HTTP 头来处理所有响应的缓存。
- en: It is worth pointing out that the above services are just common examples of
    the services available in commercial or open-source API gateways that usually
    offer a wide range of services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，上述服务只是商业或开源 API 网关中可用的服务的一般示例，这些网关通常提供广泛的服务。
- en: API gateways can be implemented as ad hoc microservices using libraries like
    YARP ([https://microsoft.github.io/reverse-proxy/index.html](https://microsoft.github.io/reverse-proxy/index.html)),
    or they can use preexisting configurable applications, for instance, the open-source
    Ocelot ([https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)).
    All main providers offer powerful configurable API gateways, called **API management
    systems** (for Azure, see [https://azure.microsoft.com/en-us/products/api-management](https://azure.microsoft.com/en-us/products/api-management)).
    However, there are also independent cloud-native offers, like Kong ([https://docs.konghq.com/gateway/latest/](https://docs.konghq.com/gateway/latest/)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关可以作为使用 YARP（[https://microsoft.github.io/reverse-proxy/index.html](https://microsoft.github.io/reverse-proxy/index.html)）等库的临时微服务实现，或者它们可以使用现有的可配置应用程序，例如开源的
    Ocelot（[https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)）。所有主要提供商都提供强大的可配置
    API 网关，称为 **API 管理系统**（对于 Azure，请参阅 [https://azure.microsoft.com/en-us/products/api-management](https://azure.microsoft.com/en-us/products/api-management)）。然而，也存在独立的云原生提供者，如
    Kong（[https://docs.konghq.com/gateway/latest/](https://docs.konghq.com/gateway/latest/)）。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the basics of microservices, starting from their
    evolution and continuing on to their definition, organization, and main patterns.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了微服务的基础知识，从它们的演变开始，继续到它们的定义、组织以及主要模式。
- en: We described the main features and requirements of a microservices-based application,
    how its organization resembles more of an assembly line than a user-requests-driven
    application, how to make microservices reliable, and how to handle efficaciously
    both failures and all problems caused by efficient asynchronous communication.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了基于微服务应用的主要特性和要求，如何其组织结构更类似于装配线而非用户请求驱动的应用，如何使微服务可靠，以及如何有效地处理故障和由高效异步通信引起的所有问题。
- en: Finally, we described how to make all microservices more independent from each
    other with publisher-subscriber-based communication and how to interface a microservices
    application with the external word.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述了如何通过基于发布者-订阅者的通信使所有微服务彼此更加独立，以及如何将微服务应用与外部世界接口。
- en: 'The next chapter describes two important building blocks for building enterprise-level
    microservices: Docker and Onion architectures.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章描述了构建企业级微服务的两个重要构建块：Docker 和洋葱架构。
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main difference between a hold-style SOA and a modern microservices
    architecture?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持有式 SOA 和现代微服务架构之间的主要区别是什么？
- en: In Microservices architectures are fine-grained. Moreover, each Microservices
    must not depend on the design choices of other Microservices. Furthermore, microservices
    must be redundant, replicable, and resilient.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，架构是细粒度的。此外，每个微服务不得依赖于其他微服务的架构选择。此外，微服务必须是冗余的、可复制的和有弹性的。
- en: Why are loosely coupled teams so important?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么松散耦合的团队如此重要？
- en: Because it is quite easy to coordinate loosely coupled teams.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因为协调松散耦合的团队相当容易。
- en: Why must each logical microservice have dedicated storage?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么每个逻辑微服务必须有专用的存储？
- en: This is an immediate consequence of the independence of the design choices of
    a Microservice from the design choices adopted in all other Microservices. In
    fact, sharing a common database would force common design choices on the database
    structure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务的设计选择与其他所有微服务采用的设计选择独立性的直接后果。事实上，共享一个公共数据库将迫使数据库结构采用共同的设计选择。
- en: Why is data-driven communication needed?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要数据驱动的通信？
- en: This is the only way to avoid long chains of recursive request and answers that
    would cause unacceptable overall response times.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是避免造成不可接受的总体响应时间的长链递归请求和响应的唯一方法。
- en: Why is event-driven communication so important?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么事件驱动的通信如此重要？
- en: Because event-driven communication completely decouples Microservices, so that
    developers can add a new Microservice without modifying any of the preexisting
    Microservices.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件驱动的通信完全解耦了微服务，这样开发者就可以在不修改任何现有微服务的情况下添加新的微服务。
- en: Do API gateways usually offer login services?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 网关通常会提供登录服务吗？
- en: No login services are offered by specific Microservices called Authentication
    Servers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由称为身份验证服务器的特定微服务提供的登录服务。
- en: What is exponential retry?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是指数重试？
- en: A retry policy that exponentially increases the delay between failures and retries
    after each failure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一种在每次失败后指数级增加失败和重试之间延迟的重试策略。
- en: Further reading
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Eric Evans, Domain-Driven Design: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20
    )'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 埃里克·埃文斯，《领域驱动设计》：[https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20
    )
- en: 'More resources on DDD can be found here: [https://www.domainlanguage.com/ddd/](https://www.domainlanguage.com/ddd/)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于领域驱动设计的资源可以在这里找到：[https://www.domainlanguage.com/ddd/](https://www.domainlanguage.com/ddd/)
- en: 'A detailed discussion of CQRS design principles can be found here: [https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在这里找到关于 CQRS 设计原则的详细讨论：[https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)
- en: 'ASP.NET Core REST API: [https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core REST API：[https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/)
- en: 'Datadog: [https://docs.datadoghq.com/service_catalog/](https://docs.datadoghq.com/service_catalog/)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Datadog: [https://docs.datadoghq.com/service_catalog/](https://docs.datadoghq.com/service_catalog/)'
- en: 'Backstage: [https://backstage.io/docs/features/software-catalog/](https://backstage.io/docs/features/software-catalog/)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backstage：[https://backstage.io/docs/features/software-catalog/](https://backstage.io/docs/features/software-catalog/)
- en: 'OpenAPI (REST API specifications): [https://swagger.io/docs/specification/v3_0/about/](https://swagger.io/docs/specification/v3_0/about/)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI（REST API 规范）：[https://swagger.io/docs/specification/v3_0/about/](https://swagger.io/docs/specification/v3_0/about/)
- en: 'Postman: [https://www.postman.com/](https://www.postman.com/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Postman: [https://www.postman.com/](https://www.postman.com/)'
- en: 'gRPC: [https://grpc.io/](https://grpc.io/ )'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC：[https://grpc.io/](https://grpc.io/ )
- en: 'RabbitMQ: [https://www.rabbitmq.com/](https://www.rabbitmq.com/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ：[https://www.rabbitmq.com/](https://www.rabbitmq.com/)
- en: 'Azure Service Bus: [https://azure.microsoft.com/en-us/products/service-bus/](https://azure.microsoft.com/en-us/products/service-bus/)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 服务总线：[https://azure.microsoft.com/en-us/products/service-bus/](https://azure.microsoft.com/en-us/products/service-bus/)
- en: 'Ocelot: [https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ocelot：[https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)
- en: 'YARP: [https://microsoft.github.io/reverse-proxy/index.html](https://microsoft.github.io/reverse-proxy/index.html)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YARP：[https://microsoft.github.io/reverse-proxy/index.html](https://microsoft.github.io/reverse-proxy/index.html)
- en: 'Kong: [https://docs.konghq.com/gateway/latest/](https://docs.konghq.com/gateway/latest/)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kong: [https://docs.konghq.com/gateway/latest/](https://docs.konghq.com/gateway/latest/)'
- en: 'Azure API Management: [https://azure.microsoft.com/en-us/products/api-management](https://azure.microsoft.com/en-us/products/api-management)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure API 管理：[https://azure.microsoft.com/en-us/products/api-management](https://azure.microsoft.com/en-us/products/api-management)
- en: Join our community on Discord
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/PSMCSharp](Chapter_2.xhtml)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/PSMCSharp](Chapter_2.xhtml)'
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI 生成的内容可能不正确。](img/B31916_Discord-QR-Code.png)'
