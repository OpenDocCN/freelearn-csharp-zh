- en: Command-Line Tools Based on Roslyn API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing an application based on the Compiler Syntax API to parse and transform
    source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an application based on the Compiler Semantic API to display diagnostics
    and overload resolution results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an application based on the Compiler Analyzer API to execute diagnostic
    analyzers and display analyzer diagnostics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an application based on the Workspaces API to format and simplify all
    source files in the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an application based on the Workspaces API to edit projects in a solution
    and display project properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter enables developers to write command-line tools using the Roslyn
    compiler and workspaces API to analyze and/or edit C# code. The article at ([https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview](https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview))
    provides a very good introduction to the Roslyn APIs at each of these layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will provide you a gist from the article:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34e6b225-9b74-4f36-a4e0-a1fc49c5acd0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Compiler API**: The compiler layer contains the object models that correspond
    with information exposed at each phase of the compiler pipeline, both syntactic
    and semantic. The compiler layer also contains an immutable snapshot of a single
    invocation of a compiler, including assembly references, compiler options, and
    source code files. There are two distinct APIs that represent the C# language
    and the Visual Basic language. These two APIs are similar in shape but tailored
    for high fidelity to each individual language. This layer has no dependencies
    on Visual Studio components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workspaces API**: The Workspaces layer contains the Workspaces API, which
    is the starting point for doing code analysis and refactoring over entire solutions.
    It assists you in organizing all the information about the projects in a solution
    into a single object model, offering you direct access to the compiler layer object
    models without needing to parse files, configure options, or manage project to
    project dependencies. This layer has no dependencies on Visual Studio components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an application based on the Compiler Syntax API to parse and transform
    source files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a C# console application based on Roslyn Compiler
    APIs to parse a given source file into a syntax tree, and then perform the following
    syntax transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit all the class declarations with no explicit accessibility modifier to add
    an internal modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add documentation comment syntax trivia to all public class declarations with
    no documentation comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove empty class declarations with no members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from: [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp` NuGet package (as of this writing,
    the latest stable version is *2.1.0*). For guidance on how to search and install
    the NuGet package to a project, refer to the recipe *Searching and installing
    analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory, and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%file_path%>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a text file, say `test.cs`, with the following code at the project root
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the application with `test.cs` as the argument: `bin\Debug\ConsoleApp.exe
    test.cs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the expected transformed source is displayed in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d778001-bcef-4845-85fd-db54050e822e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we wrote a C# console application based on Roslyn Compiler
    API to parse and transform source text. As mentioned earlier, our application
    demonstrates three core syntax operations on the parsed tree: edit, add, and remove.
    Let''s walk through the code and understand how we implemented these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main` method invokes individual methods to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseArguments` to scan for the input file to parse and transform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the text from this source file and `Parse` it into a syntax tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the compilation unit root of the parsed tree and perform the following
    transformations on the root:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditClassDeclarations` : To add internal modifier to class with no accessibility
    modifier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddDocCommentsToClassDeclarations` : To add stub documentation comments to
    public class with no documentation comments.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveEmptyClassDeclarations` : To remove class declarations with no members.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the transformed text on the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ParseArguments` method expects a single argument, which must be a full
    path to an existing file on the disk. Otherwise, it displays an error and bails
    out returning null.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Parse` method reads the file contents from the input file and parses it
    using the parsing API `CSharpSyntaxTree.ParseText`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `EditClassDeclarations` method walks the descendant nodes of the root to
    find all class declaration nodes whose modifier list has no accessibility modifier
    (public, private, internal, or protected).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it invokes the `ReplaceNodes` API on the root syntax node to replace each
    such class declaration with an updated node returned by the `AddModifier` helper.
    This helper adds a new internal modifier at the start of the current modifier
    list of the class declaration. It also takes care of moving any existing leading
    trivia of the class declaration to the new modifier and adds a whitespace trivia
    after the new modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `AddDocCommentsToClassDeclarations` method walks the descendant nodes of
    the root to find all class declaration nodes whose modifier list has a public
    accessibility modifier and its first token has no leading documentation comment
    trivia.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, it invokes the `ReplaceNode`*s* API on the root syntax node to replace
    each such class declaration with an updated node returned by the `AddDocumentationComment`
    helper. This helper creates an XML summary element with a `TODO` comment and creates
    a single line documentation comment with this stub summary element and adds this
    at end of the current leading trivia for the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `RemoveEmptyClassDeclarations` method walks the descendant nodes of the
    root to find all class declaration nodes which have no members declarations (methods,
    fields, nested types, and so on) and then invokes the `ReplaceNodes` API on the
    root syntax node to remove all such declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing an application based on the Compiler Semantic API to display diagnostics
    and overload resolution results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a C# console application based on Roslyn Compiler
    APIs to create a compilation from the given source file and then perform the following
    semantic analyses:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute and display the compilation diagnostics that would be produced by the
    C# compiler if the file were to be compiled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compute the symbol info for each invocation (method call) in the source file
    and display the following semantic information for each call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Overload resolution result ([https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx](https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx)):
    Success or failure reason.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If overload resolution succeeded, the method symbol bound to the invocation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, if overload resolution failed and we have one or more candidate symbols,
    then display each candidate symbol.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp` NuGet package (as of this writing,
    the latest stable version is *2.1.0*). For guidance on how to search and install
    NuGet package to a project, refer to the recipe *Searching and installing analyzers
    through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory, and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%file_path%>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a text file, say `test.cs`, with the following code at the project root
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the application with `test.cs` as the argument: `bin\Debug\ConsoleApp.exe
    test.cs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the expected diagnostics and invocation semantics with overload resolution
    results are displayed in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b7728e2d-18de-47de-885a-3ea256bb3819.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we wrote a C# console application based on the Roslyn Compiler
    API to create a compilation and analyze and display the diagnostics and overload
    resolution semantics for invocation expressions. These operations are very similar
    to what a C# compiler would do when compiling the source code. Let''s walk through
    the code and understand how we implemented these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Main method invokes individual methods to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseArguments` to scan for the input file to parse and transform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCompilation` to create a C# compilation from a parsed syntax tree created
    with the text from this source file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisplayDiagnostics` to compute the compiler diagnostics and then display them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisplayInvocations` to analyze each invocation (method call) in a syntax tree
    and display the overload resolution result and bound symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of `ParseArguments` is identical to the one in the previous recipe,
    *Writing an application based on Compiler Syntax API to parse and transform source
    files.* Refer to the *How it works...*, section of that recipe for further explanation
    on this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateCompilation` method first reads the file contents from the input
    file and parses it using the parsing API `CSharpSyntaxTree.ParseText`. Then, it
    creates a metadata reference for the system assembly (corlib) using the location
    of the assembly containing the object type. It creates compilation options with
    output kind `DynamicallyLinkedLibrary` (`.dll`) and uses these inputs to create
    a C# compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `DisplayDiagnostics` method computes the compilation diagnostics using the
    `Compilation.GetDiagnostics` API and then displays the diagnostic count and string
    representation of each diagnostic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DisplayInvocations` method first gets the semantic model for the syntax
    tree in the compilation. Then, it iterates over the descendant nodes of the root
    to get all `InvocationExpressionSyntax` nodes. For each such invocation, it queries
    the symbol info of the expression from the semantic model. The symbol info contains
    information about the semantics of the invocation. We display the overload resolution
    success/fail result based on whether or not the candidate reason is `CandidateReason.None`.
    Then, we display the bound symbol or candidate symbols for the success and failure
    cases, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Writing an application based on the Compiler Analyzer API to execute diagnostic
    analyzers and display analyzer diagnostics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write a C# console application based on Roslyn Compiler
    APIs that loads the given analyzer assembly, executes all diagnostic analyzers
    defined in this assembly on a given source file, and outputs all the reported
    analyzer diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp` NuGet package (as of this writing,
    the latest stable version is *2.1.0*). For guidance on how to search and install
    the NuGet package to a project, refer to the recipe *Searching and installing
    analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a C# class library project targeting .NET Framework 4.6 or higher to the
    solution, say *Analyzer.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis` NuGet package to this project (as of this
    writing, the latest stable version is *2.1.0*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Class1.cs` with the diagnostic analyzer source code
    from the attached code sample `\Analyzer\Class1.cs`. This file contains the code
    for the default symbol analyzer that reports a diagnostic for type names containing
    any lowercase characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory of `ConsoleApp`, and execute `bin\Debug\ConsoleApp.exe` with no
    arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%analyzer_file_path%>
    <%source_file_path%>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a text file, say `test.cs`, at the project root directory of `ConsoleApp`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the application with a relative path to analyzer assembly and
    `test.cs` as the arguments: `bin\Debug\ConsoleApp.exe ..\..\..\Analyzer\bin\Debug\Analyzer.dll
    test.cs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the expected analyzer diagnostics are displayed in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we wrote a C# console application based on the Roslyn Compiler
    API to load and execute diagnostic analyzers from an analyzer assembly and report
    the diagnostics reported by the analyzers. These operations are very similar to
    what the C# compiler would do when you compile source files with `/analyzer:<%analyzer_file_path%>`
    command line switch. Let''s walk through the code and understand how we implemented
    these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Main method invokes individual methods to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseArguments` to scan for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzer assembly file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Input source file on which the analyzers will be executed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCompilation` to create a C# compilation from parsed syntax tree created
    with the text from the input source file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCompilationWithAnalyzers` to create a compilation instance with diagnostic
    analyzers from the given analyzer assembly file attached to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisplayAnalyzerDiagnostics` to execute the analyzers to compute the analyzer
    diagnostics and then display them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of `ParseArguments` and `CreateCompilation` is identical to the
    one in the previous recipe, *Writing an application based on Compiler Syntax API
    to parse and transform source files.* Refer to the *How it works...*, section
    of that recipe for further explanation on these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateCompilationWithAnalyzers` method takes the compilation and the analyzer
    assembly as the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, it creates `AnalyzerFileReference` ([http://source.roslyn.io/#q=AnalyzerFileReference](http://source.roslyn.io/#q=AnalyzerFileReference))
    with the analyzer file path and an instance of the analyzer assembly loader (`IAnalyzerAssemblyLoader`
    - details later in the section ([http://source.roslyn.io/#q=IAnalyzerAssemblyLoader](http://source.roslyn.io/#q=IAnalyzerAssemblyLoader))).
    It invokes the `AnalyzerReference.GetAnalyzers` API ([http://source.roslyn.io/#q=AnalyzerReference.GetAnalyzers](http://source.roslyn.io/#q=AnalyzerReference.GetAnalyzers))
    on this analyzer file reference to load the analyzer assembly with the given analyzer
    assembly loader, and then create instances of the diagnostic analyzers defined
    in this assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It creates a default set of `CompilationWithAnalyzersOptions` ([http://source.roslyn.io/#q=CompilationWithAnalyzersOptions](http://source.roslyn.io/#q=CompilationWithAnalyzersOptions))
    for configuring the analyzer execution. The possible options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnalyzerOptions`: Analyzer options contain the set of additional non-source
    text files that are passed to the analyzers. In this recipe, we use an empty set.
    You can read more about additional files at [https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAnalyzerException` delegate: Delegate to be invoked when an analyzer throws
    an exception. In this recipe, we just re-throw this exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concurrentAnalysis`: Flag to control whether the analyzers should be run concurrently
    or not. In this recipe, we default this to false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logAnalyzerExecutionTime`: Flag to control whether the relative execution
    times for each analyzer should be tracked. If set to true, then this data can
    be requested for each analyzer using the public API `CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync`
    ([http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync)).
    This returns an `AnalyzerTelemetryInfo`, which has a property named `ExecutionTime`
    (`http://source.roslyn.io/#q=AnalyzerTelemetryInfo.ExecutionTime`). In this recipe,
    we default this to false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the method creates and returns a `CompilationWithAnalyzers` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a))
    instance with the given compilation, analyzer file reference, and options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We briefly mentioned our custom `AnalyzerAssemblyLoader` passed into the `AnalyzerFileReference`
    constructor above. It is implemented in our code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This analyzer assembly loader handles loading the analyzer assembly using the
    .NET APIs for assembly loading on the executing platform. In this recipe, we use
    .NET Framework API `Assembly.LoadFrom` ([https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx))
    to load the assembly from the given path.
  prefs: []
  type: TYPE_NORMAL
- en: We ignore the callbacks to add analyzer dependency locations in our custom `AnalyzerAssemblyLoader`,
    as our test analyzer assembly has no dependencies. We can enhance this assembly
    loader to track these locations and handle assembly loading for dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '`DisplayAnalyzerDiagnostics` takes the `CompilationWithAnalyzers` instance
    created earlier and executes the analyzers on the underlying compilation using
    `GetAnalyzerDiagnosticsAsync` API. It then walks through all the analyzer diagnostics
    and outputs the message for each diagnostic, with the line and column information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can invoke the `CompilationWithAnalyzers.GetAnalysisResultAsync` ([http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalysisResultAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalysisResultAsync))
    public API to get a more fine-grained view of the analysis results. The returned
    `AnalysisResult` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalysisResult.cs,86a401660972cfb8](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalysisResult.cs,86a401660972cfb8))
    allows you to get separate syntax, semantic, and compilations diagnostics reported
    by each diagnostic analyzer and also allows you to get the analyzer telemetry
    info for each analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an application based on the Workspaces API to format and simplify all
    source files in the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a C# console application based on Roslyn Workspaces
    APIs to load a C# solution into a workspace and then perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Format the solution to change tabs to white spaces with a custom indentation
    size. This is a syntactic code refactoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplify the solution to change local declarations to have an explicit type
    specification instead of var. This is a semantic code refactoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can read the XML documentation comments and implementation details for
    the Formatter and Simplifier for additional information on these operations at:
    [http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Formatting/Formatter.cs,f445ffe3c814c002](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Formatting/Formatter.cs,f445ffe3c814c002)
    and [http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Simplification/Simplifier.cs,1d256ae3815b1cac](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Simplification/Simplifier.cs,1d256ae3815b1cac),
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp.Workspaces` NuGet package (as of
    this writing, the latest stable version is *2.1.0*). For guidance on how to search
    and install NuGet package to a project, refer to the recipe *Searching and installing
    analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%solution_file_path%>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# console application, say `TestSolution`, and add one implicitly
    typed and one explicitly typed local declaration to the `Main` method (note the
    indent size of 4):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b8bc391-7f99-4ca0-b91a-82bcc557c9c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, execute the application with full path to `TestSolution.sln` as the argument:
    `bin\Debug\ConsoleApp.exe <%test_solution_path%>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the console output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the new contents of the source file in *TestSolution now* has an indent
    size of 2 and no explicitly typed local declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e2b2aff-adf2-42a0-ab4d-e40859a988b9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we wrote a C# console application based on Roslyn Workspaces
    API to format and simplify all the source files in a solution. These operations
    are very similar to what a Visual Studio IDE would do when you apply formatting
    and simplification quick fixes after setting the corresponding tools options.
    Let''s walk through the code and understand how we implemented these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main` method invokes individual methods to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseArguments`: To scan for the input file to parse and transform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSBuildWorkspace.Create`: To create a workspace and `Workspace.OpenSolutionAsync`
    to load the given solution in the workspace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormatSolution`: To format all the documents in the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimplifySolution`: To simplify all the documents in the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplyChanges`: To apply the formatting and simplification changes to the workspace
    and persist these to the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of `ParseArguments` is identical to the one in the recipe, *Writing
    an application based on Compiler Syntax API to parse and transform source files.*
    Refer to the *How it works...*, section of that recipe for further explanation
    on this method.
  prefs: []
  type: TYPE_NORMAL
- en: '`MSBuildWorkspace` ([http://source.roslyn.io/#q=MSBuildWorkspace](http://source.roslyn.io/#q=MSBuildWorkspace))
    is a custom implementation of the core Roslyn Workspace, which uses the MSBuild
    ([https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild))
    project model for loading the solution/project files and allows reading and writing
    individual documents in the projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormatSolution` method formats all documents in the solution. First, it
    modifies the options to prefer whitespace over tabs, with an indentation size
    of 2 (default is 4):'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormattingOptions.UseTabs`: Value set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormattingOptions.IndentationSize`: Value set to `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It keeps track of the current solution snapshot in `newSolution`*,* which is
    initialized to `originalSolution`. It then iterates over all the documents in
    the solution and does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Format the document by invoking `Formatter.FormatAsync` public API ([http://source.roslyn.io/#q=Formatter.FormatAsync](http://source.roslyn.io/#q=Formatter.FormatAsync))
    with the current document and options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `newSolution` to point to the solution of the formatted `newDocument`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note how we can't simply iterate over `originalSolution.Projects` or `project.Documents`
    because it will return objects from the unmodified `originalSolution`, not from
    the `newSolution`. We need to use the `ProjectId`/`DocumentIds` (that don't change)
    to look up the corresponding snapshots in the `newSolution`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it returns the `newSolution` after all documents have been formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SimplifySolution` method simplifies all documents in the solution. First,
    it modifies the options to prefer implicitly type local declaration, that is,
    user `var` over explicit type specification, by setting `SimplificationOptions.PreferImplicitTypeInLocalDeclaration`
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`SimplifySolution` has very identical implementation to the `FormatSolution`
    method for iterating the documents, simplifying them by invoking `Simplifier.ReduceAsync`
    public API ([http://source.roslyn.io/#q=Simplifier.ReduceAsync](http://source.roslyn.io/#q=Simplifier.ReduceAsync)),
    storing the latest snapshot in `newSolution` after processing each document, and
    finally returning the new solution snapshot at the end. It has one important difference
    though. `Simplifier.ReduceAsync` only processes nodes with a special syntax annotation:
    `Simplifier.Annotation` ([http://source.roslyn.io/#q=Simplifier.Annotation](http://source.roslyn.io/#q=Simplifier.Annotation)).
    Hence, before invoking this API, we add this syntax annotation to the root of
    the document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApplyChanges` method invokes the `Workspace.TryApplyChanges` public API
    ([http://source.roslyn.io/#q=Workspace.TryApplyChanges](http://source.roslyn.io/#q=Workspace.TryApplyChanges))
    with the new solution snapshot to apply the changes in the solution snapshot to
    the workspace. This also causes the `MSBuildWorkspace` to persist these changes
    onto the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Writing an application based on the Workspaces API to edit projects in a solution
    and display project properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a C# console application based on Roslyn Workspaces
    APIs to load a C# solution into a workspace and then perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Display project properties such as project file path, output file path, project
    language, assembly name, reference count, document count, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new project to the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an existing project from the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit project to add a project reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting the .NET
    Framework 4.6 or higher, say `ConsoleApp`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp.Workspaces` NuGet package (as of
    this writing, the latest stable version is *2.1.0*). For guidance on how to search
    and install the NuGet package to a project, refer to the recipe *Searching and
    installing analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory, and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%solution_file_path%>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# class library solution, say `TestSolution`, and add one more
    class library project, say `ClassLibrary`*,* to the solution. Now, execute the
    application with full path to `TestSolution.sln` as the argument: `bin\Debug\ConsoleApp.exe
    <%test_solution_path%>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the console output shows the project properties for the initial solution
    with two projects, `TestSolution` and `ClassLibrary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eaea8ea5-56ce-4166-98b9-d7d6e5c28e46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Press any key to continue and note the following operations were performed:
    add project to solution, remove project from solution, and edit existing project
    (add project reference).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbd48de2-5839-486a-8b70-5e7f7a908c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Press any key to continue and verify the solution now contains two projects
    `TestSolution` and `AddedClassLibrary`, and there is a project reference from
    `AddedClassLibrary` to `TestSolution`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab01e219-8de4-4753-9aae-897a207e462d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we wrote a C# console application based on Roslyn Workspaces
    API to perform various operations on a projects in a solution: add, remove, edit,
    and display project properties. The rich Workspaces APIs provide you with a powerful
    object model for analyzing and editing projects and documents in a solution. Let''s
    walk through the code and understand how we implemented these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Main method invokes individual methods to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseArguments`: To scan for the input file to parse and transform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSBuildWorkspace.Create`: To create a workspace and `Workspace.OpenSolutionAsync`
    to load the given solution in the workspace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisplayProjectProperties`: To display common properties for all projects in
    a solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddProject`: To add a new project to the solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveProject`: To remove an existing project from a solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddProjectReference`: To add a project reference to an existing project in
    a solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of `ParseArguments` is identical to the one in the recipe, *Writing
    an application based on Compiler Syntax API to parse and transform source files.*
    Please refer to the *How it works...*, section of that recipe for further explanation
    on this method.
  prefs: []
  type: TYPE_NORMAL
- en: '`MSBuildWorkspace` ([http://source.roslyn.io/#q=MSBuildWorkspace](http://source.roslyn.io/#q=MSBuildWorkspace))
    is a custom implementation of the core Roslyn Workspace, which uses the MSBuild
    project model for loading the solution/project files, and allows reading and writing
    individual documents in the projects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DisplayProjectProperties` displays common project properties such as project
    name, language, assembly name, references, documents, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddProject` method creates a barebones `ProjectInfo` ([http://source.roslyn.io/#q=ProjectInfo](http://source.roslyn.io/#q=ProjectInfo))
    with the given `projectName`, a unique Project ID, version stamp, assembly name,
    and C# language name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It then invokes the `Solution.AddProject` API ([http://source.roslyn.io/#q=Solution.AddProject](http://source.roslyn.io/#q=Solution.AddProject))
    to add a new project with the created project info to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RemoveProject` method removes an existing project with the given `projectName`
    from the solution. It uses the `Solution.RemoveProject` API ([http://source.roslyn.io/#q=Solution.RemoveProject](http://source.roslyn.io/#q=Solution.RemoveProject))
    to remove the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `AddProjectReference` method adds a project reference from the given `referenceFrom`
    project to the given `referenceTo` project. It searches for existing projects
    in the solution with the given names, creates a `ProjectReference` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4))
    with project ID for the `referenceFrom` project, and uses the `Solution.AddProjectReference`
    ([http://source.roslyn.io/#q=Solution.AddProjectReference](http://source.roslyn.io/#q=Solution.AddProjectReference))
    to add the required reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
