<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer400" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-192"><a id="_idTextAnchor292" class="pcalibre pcalibre1 calibre6"/>11</h1>
<h1 id="_idParaDest-193" class="calibre5"><a id="_idTextAnchor293" class="pcalibre pcalibre1 calibre6"/>UI Images and Effects</h1>
<p class="calibre3">We’ve worked with UI Images in the previous chapters, but now we’ll learn more about the component’s specific properties, as well as how to access the component via code. We’ll also look at some of the UI effect components that we can apply to our UI objects for visual appeal. While we will look at the components thoroughly, the majority of this chapter focuses on specific worked-out examples of UI functionality that you will find in video games, particularly mobile <span>video games.</span></p>
<p class="calibre3">In this chapter, we will discuss the <span>following topics:</span></p>
<ul class="calibre16">
<li class="calibre14">Creating UI Images and setting <span>their properties</span></li>
<li class="calibre14">Using the various UI effects components to further customize our <span>graphical UI</span></li>
<li class="calibre14">Implementing horizontal and circular <span>progress bars</span></li>
<li class="calibre14">How to create Buttons that swap sprites without using the built-in transitions, like a <span>mute/unmute Button</span></li>
<li class="calibre14">Adding a <span>press-and-hold/long-press functionality</span></li>
<li class="calibre14">Creating an onscreen four-directional <span>virtual D-Pad</span></li>
<li class="calibre14">Creating a floating eight-directional virtual <span>analog stick</span></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">All the examples shown in the sections before the <em class="italic">Examples</em> section can be found within the Unity project provided in the code bundle. They can be found within the scene <span>labeled </span><span><strong class="source-inline1">Chapter11</strong></span><span>.</span></p>
<p class="callout">Each example figure has a caption stating the example name within <span>the scene.</span></p>
<p class="callout">In the scene, each example is on its own Canvas, and some of the Canvases are deactivated. To view an example on a deactivated Canvas, simply select the checkbox next to the Canvas’ name in the Inspector. Each Canvas is also given its own Event System. This will cause errors if you have more than one Canvas activated at <span>a time.</span></p>
<h1 id="_idParaDest-194" class="calibre5"><a id="_idTextAnchor294" class="pcalibre pcalibre1 calibre6"/>Technical requirements</h1>
<p class="calibre3">You can find the relevant codes and asset files of this chapter <span>here: </span><a href="https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011" class="pcalibre pcalibre1 calibre6"><span>https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011</span></a></p>
<h1 id="_idParaDest-195" class="calibre5"><a id="_idTextAnchor295" class="pcalibre pcalibre1 calibre6"/>UI Image component properties</h1>
<p class="calibre3">We’ve created a UI Image before, but<a id="_idIndexMarker629" class="pcalibre pcalibre1 calibre6"/> let’s look at its properties <span>and components.</span></p>
<p class="calibre3">You can create a new UI Image object using <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <span><strong class="bold">Image</strong></span><span>.</span></p>
<p class="calibre3">The UI <strong class="source-inline">Image</strong> object contains the <strong class="bold">Rect Transform</strong> and <strong class="bold">Canvas Renderer</strong> components as well as the <strong class="bold">Image</strong> component. We’ve looked at the <strong class="bold">Rect Transform</strong> and <strong class="bold">Canvas Renderer</strong> components extensively; now, let’s look at the <span><strong class="bold">Image</strong></span><span> component.</span></p>
<p class="calibre3">The first setting on the <strong class="bold">Image</strong> component is the <strong class="bold">Source Image</strong> property, which represents the sprite that will be rendered. The <strong class="bold">Color</strong> property represents the base color of the sprite being rendered. Leaving the color at white will make the Image appear exactly as the sprite, but changing the color will add a tinted color overlay to the Image. You can also change the transparency of the Image by reducing the alpha value. The <strong class="bold">Material</strong> property allows you to add a material to <span>the Image.</span></p>
<p class="calibre3">The <strong class="bold">Raycast Target</strong> and <strong class="bold">Raycast Padding</strong> properties work the same way they do on the <strong class="bold">Text</strong> component, by specifying whether the Image will block clicks on UI objects behind it or not and if there is any padding to the block. The <strong class="bold">Maskable</strong> property determines if the Image can be affected by masks <span>or not.</span></p>
<p class="calibre3">When a sprite is assigned to the <strong class="bold">Source Image</strong> slot, new options appear in the <strong class="bold">Image</strong> component under <strong class="bold">Image Type</strong>, as shown in the <span>following figure:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer356">
<img alt="Figure 11.1: The UI Image component and all its properties" src="image/B18327_11_01.jpg" class="calibre351"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.1: The UI Image component and all its properties</p>
<p class="calibre3">Let’s look at the various <a id="_idIndexMarker630" class="pcalibre pcalibre1 calibre6"/>options for <strong class="bold">Image Type</strong> and how they affect <span>a sprite.</span><a id="_idTextAnchor296" class="pcalibre pcalibre1 calibre6"/></p>
<h2 id="_idParaDest-196" class="calibre7"><a id="_idTextAnchor297" class="pcalibre pcalibre1 calibre6"/>Image Type</h2>
<p class="calibre3">The <strong class="bold">Image Type</strong> property determines<a id="_idIndexMarker631" class="pcalibre pcalibre1 calibre6"/> how the sprite specified by <strong class="bold">Source Image</strong> will appear. There are four options: <strong class="bold">Simple</strong>, <strong class="bold">Sliced</strong>, <strong class="bold">Tiled</strong>, and <strong class="bold">Filled</strong>. Let’s take a look <span>at them.</span><a id="_idTextAnchor298" class="pcalibre pcalibre1 calibre6"/></p>
<h3 class="calibre9">Simple</h3>
<p class="calibre3">An Image with its <strong class="bold">Image Type</strong> property set to <strong class="bold">Simple</strong> scales evenly across the sprite. This is the default type. When <strong class="bold">Simple</strong> is selected <a id="_idIndexMarker632" class="pcalibre pcalibre1 calibre6"/>as the <strong class="bold">Image Type</strong>, a toggle labeled <strong class="bold">Use Sprite Mesh</strong>, a toggle labeled <strong class="bold">Preserve Aspect</strong>, and a button labeled <strong class="bold">Set Native Size</strong> <span>become available.</span></p>
<p class="calibre3">Selecting the <strong class="bold">Use Sprite Mesh</strong> toggle will have the Image use the sprite mesh created by the <strong class="bold">TextureImporter</strong>. By default, this property is deselected, and the sprite’s mesh is a quad. You will select this property if you don’t want the Image represented by a rectangle, but instead want it to have a mesh that fits tightly around the visible area of <span>the Image.</span></p>
<p class="calibre3">When the <strong class="bold">Preserve Aspect</strong> property is checked, the sprite will display with its portions preserved and may not appear to fill the entire area of the Rect Transform. Selecting this property ensures that your sprites look as originally intended and are not <span>stretched out.</span></p>
<p class="calibre3">Selecting the <strong class="bold">Set Native Size</strong> button <a id="_idIndexMarker633" class="pcalibre pcalibre1 calibre6"/>sets the dimensions of the Image to the pixel dimensions of <span>the spri<a id="_idTextAnchor299" class="pcalibre pcalibre1 calibre6"/>te.</span></p>
<h3 class="calibre9">Sliced</h3>
<p class="calibre3"><strong class="bold">Sliced</strong> Images are split into nine areas. When a <strong class="bold">Sliced</strong> Image is scaled, all areas of the Image are scaled, except the corners. This <a id="_idIndexMarker634" class="pcalibre pcalibre1 calibre6"/>allows you to scale an Image without distorting its corners. This works particularly well with sprites that have rounded corners that you want to be able to stretch into <span>rounded rectangles.</span></p>
<p class="calibre3">When an image is set to <strong class="bold">Sliced</strong>, the <strong class="bold">Fill Center</strong> and <strong class="bold">Pixels Per Unit Multiplier</strong> properties appear. The following figure shows a rounded rectangle with five alternate versions of it being stretched. You can see how selecting <strong class="bold">Sliced</strong> allows the rounded rectangle to stretch in a way that maintains the rounded rectangle shape while leaving the <strong class="bold">Image Type</strong> at <strong class="bold">Simple</strong> causes a distortion in the edges of the Image when it <span>is scaled.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer357">
<img alt="Figure 11.2: Sliced Image Type Example in the Chapter11 scene" src="image/B18327_11_02.jpg" class="calibre352"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11<a id="_idTextAnchor300" class="pcalibre pcalibre1 calibre6"/>.2: Sliced Image Type Example in the Chapter11 scene</p>
<p class="calibre3">You must specify where the nine areas will be, within the <strong class="bold">Sprite Editor</strong> of the sprite or sprite sheet. If you have not specified the regions, a message will appear within the <span><strong class="bold">Image</strong></span><span> component.</span></p>
<p class="calibre3">To specify the area in the <strong class="bold">Sprite Editor</strong>, you need to drag the green boxes on the edges of the sprite to the desired position. As you can see from the following screenshot, you want to drag the <a id="_idIndexMarker635" class="pcalibre pcalibre1 calibre6"/>green lines so that they stop surrounding the curves of <span>the edges:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer358">
<img alt="Figure 11.3: Specifying the nine areas of a sprite in the Sprite Editor" src="image/B18327_11_03.jpg" class="calibre353"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.3: Specifying the nine areas of a sprite in the Sprite Edi<a id="_idTextAnchor301" class="pcalibre pcalibre1 calibre6"/>tor</p>
<p class="calibre3">Next, let’s talk about the <strong class="bold">Tiled</strong> option under the <span><strong class="bold">Image Type</strong></span><span>.</span></p>
<h3 class="calibre9">Tiled</h3>
<p class="calibre3">Selecting <strong class="bold">Tiled</strong> for <strong class="bold">Image Type</strong> will cause <a id="_idIndexMarker636" class="pcalibre pcalibre1 calibre6"/>the Image to repeat to fill the stretched area. The following figure demonstrates how selecting <strong class="bold">Simple</strong> and <strong class="bold">Tiled</strong> for <strong class="bold">Image Type</strong> affects the <span>scaled Images:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer359">
<img alt="Figure 11.4: Tiled Image Type Example in the Chapter11 scene" src="image/B18327_11_04.jpg" class="calibre354"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.4: Tiled Image Type Example in the Chapter11 scene</p>
<p class="calibre3">Next, let’s talk about the <strong class="bold">Filled</strong> option <a id="_idIndexMarker637" class="pcalibre pcalibre1 calibre6"/>under the <span><strong class="bold">Image T<a id="_idTextAnchor302" class="pcalibre pcalibre1 calibre6"/>ype</strong></span><span>.</span></p>
<h3 class="calibre9">Filled</h3>
<p class="calibre3">Images with <strong class="bold">Filled</strong> selected for their <strong class="bold">Image Type</strong> will fill in <a id="_idIndexMarker638" class="pcalibre pcalibre1 calibre6"/>a percentage of the sprite, starting at an origin in a specified direction. Any part of the sprite past the designated percentage will not be rendered. When <strong class="bold">Filled</strong> is selected, new properties <span>are displayed:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer360">
<img alt="Figure 11.5: Properties for a Filled Image" src="image/B18327_11_05.jpg" class="calibre355"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.5: Properties for a Filled Image</p>
<p class="calibre3">The <strong class="bold">Fill Method</strong> property determines whether the sprite will be filled horizontally, vertically, or radially. There are five options: <strong class="bold">Horizontal</strong>, <strong class="bold">Vertical</strong>, <strong class="bold">Radial 90</strong>, <strong class="bold">Radial 180</strong>, and <strong class="bold">Radial 360</strong>. Each of these <strong class="bold">Fill Method</strong> options will begin drawing the sprite at the <strong class="bold">Fill Origin</strong> up to the <strong class="bold">Fill Amount</strong>. When one of the radial methods is selected, you can also select the option to have the fill progress <strong class="bold">Clockwise</strong>; if you choose not to select this option, the<a id="_idIndexMarker639" class="pcalibre pcalibre1 calibre6"/> Image will fill counterclockwise. The following figure demonstrates the three <strong class="bold">Fill Method</strong> options, all with <strong class="bold">Fill Amount</strong> values of <strong class="source-inline">0.75</strong> or <span>75 percent:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer361">
<img alt="Figure 11.6: Filled Image Type Example in the Chapter11 scene" src="image/B18327_11_06.jpg" class="calibre356"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.6: Filled Image Type Example in the Chapter11 scene</p>
<p class="calibre3">The <strong class="bold">Horizontal</strong> and <strong class="bold">Vertical</strong> <strong class="bold">Fill Method</strong> options are somewhat self-explanatory when you see them in action, but it’s a little more difficult to determine exactly how the three radial methods work just from looking at them. <strong class="bold">Radial 90</strong> places the center of the radial at one of the corners, <strong class="bold">Radial 180</strong> places the center of the radial at one of the edges, and <strong class="bold">Radial 360</strong> places the center of the radial in the center of <span>the sprite.</span></p>
<p class="calibre3">The <strong class="bold">Filled</strong> <strong class="bold">Image Type</strong> option also has the <strong class="bold">Set Native </strong><span><strong class="bold">Size</strong></span><span> property.</span></p>
<p class="calibre3">Now that we’ve explored the UI Image <a id="_idIndexMarker640" class="pcalibre pcalibre1 calibre6"/>component, we can look at some UI <span>effect compon<a id="_idTextAnchor303" class="pcalibre pcalibre1 calibre6"/>ents.</span></p>
<h1 id="_idParaDest-197" class="calibre5"><a id="_idTextAnchor304" class="pcalibre pcalibre1 calibre6"/>UI effect components</h1>
<p class="calibre3">Three effects components allow you to add special <a id="_idIndexMarker641" class="pcalibre pcalibre1 calibre6"/>effects to your Text and Image objects: <strong class="bold">Shadow</strong>, <strong class="bold">Outline</strong>, and <strong class="bold">Position as UV1</strong>. They can all be found under <strong class="bold">Add Component</strong> | <strong class="bold">UI</strong> | <strong class="bold">Effects</strong>. Let’s look at each one individually, starting with the <span>Shadow comp<a id="_idTextAnchor305" class="pcalibre pcalibre1 calibre6"/>onent.</span></p>
<h2 id="_idParaDest-198" class="calibre7"><a id="_idTextAnchor306" class="pcalibre pcalibre1 calibre6"/>Shadow</h2>
<p class="calibre3">The <strong class="bold">Shadow</strong> component adds a <a id="_idIndexMarker642" class="pcalibre pcalibre1 calibre6"/>simple shadow to your Text or <span>Image object.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer362">
<img alt="Figure 11.7: The Shadow component" src="image/B18327_11_07.jpg" class="calibre357"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.7: The Shadow component</p>
<p class="calibre3">You can change the color and transparency of the shadow with the <strong class="bold">Effect Color</strong> property. The <strong class="bold">Effect Distance</strong> property determines its position relative to the graphic to which it is attached. The <strong class="bold">Use Graphic Alpha</strong> property will multiply the color of the shadow with the color of the graphic on which the shadow is attached. So, if this property is checked and the alpha (opacity) of the original graphic is reduced, the alpha of the shadow will reduce as well, with the resulting shadow being a product of the two alpha values. However, if the <strong class="bold">Use Graphic Alpha</strong> property is unchecked, the shadow will maintain its alpha value regardless of the alpha of the original graphic. So, if you turned the alpha of the original graphics all the way down to <strong class="source-inline">0</strong>, rendering it invisible, the shadow would remain visible based on the alpha specified on the <strong class="bold">Effect </strong><span><strong class="bold">Color</strong></span><span> property.</span></p>
<p class="calibre3">The following figure shows a few examples of the <strong class="bold">Shadow</strong> component <span>in action:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer363">
<img alt="Figure 11.8: Shadow Component Example in the Chapter11 scene" src="image/B18327_11_08.jpg" class="calibre358"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.8: Shadow Component Example in the Chapter11 scene</p>
<p class="calibre3">All four bananas have the same alpha value set on their <strong class="bold">Shadow</strong> component’s <strong class="bold">Effect Color</strong> property. The <strong class="bold">Image</strong> component’s <strong class="bold">Color</strong> property of the first banana has the alpha set to full opacity. The second, third, and fourth bananas have the opacity of their <strong class="bold">Image</strong> component reduced. The second and third bananas have identical properties, except that the second banana <a id="_idIndexMarker643" class="pcalibre pcalibre1 calibre6"/>uses the <strong class="bold">Use Graphic Alpha</strong> property and the third does not. So, you can see that the shadow of the third banana has not been dimmed by the dimming of the banana’s <strong class="bold">Image</strong> component. The fourth and final banana has its <strong class="bold">Image</strong> component’s opacity set to <strong class="source-inline">0</strong>, but since <strong class="bold">Use Graphic Alpha</strong> is not selected on the <strong class="bold">Shadow</strong> component, the shadow did not dim with the banana and remains at its designated <span>alpha <a id="_idTextAnchor307" class="pcalibre pcalibre1 calibre6"/>value.</span></p>
<h2 id="_idParaDest-199" class="calibre7"><a id="_idTextAnchor308" class="pcalibre pcalibre1 calibre6"/>Outline</h2>
<p class="calibre3">The <strong class="bold">Outline</strong> component simulates an<a id="_idIndexMarker644" class="pcalibre pcalibre1 calibre6"/> outline around the graphic by creating four shadows around it at <span>specified distances.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer364">
<img alt="Figure 11.9: The Outline component" src="image/B18327_11_09.jpg" class="calibre359"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.9: The Outline component</p>
<p class="calibre3">The <strong class="bold">Outline</strong> component will create two shadows to the left and right of the original graphic based on <strong class="bold">Effect Distance X</strong> and two shadows to the top and bottom of the original graphic based on <strong class="bold">Effect Distance Y</strong>. Unlike the <strong class="bold">Shadow</strong> component, there is no difference in a negative or positive value for these two distances because the two shadows created for each axis <span>are mirrored.</span></p>
<p class="calibre3">Setting the <strong class="bold">Effect Distance X</strong> value to <strong class="source-inline">-3</strong> essentially just switches the positions of the two horizontal shadows, but the<a id="_idIndexMarker645" class="pcalibre pcalibre1 calibre6"/> effect looks the same, as shown in the <span>following figure:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer365">
<img alt="Figure 11.10: Outline Component Example 1 in the Chapter11 scene" src="image/B18327_11_10.jpg" class="calibre360"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.10: Outline Component Example 1 in the Chapter11 scene</p>
<p class="calibre3">The <strong class="bold">Use Graphic Alpha</strong> property works identically on this component as it does on the <strong class="bold">Shadow</strong> component, <span>as shown:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer366">
<img alt="Figure 11.11: Outline Component Example 2 in the Chapter11 scene" src="image/B18327_11_11.jpg" class="calibre361"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.11: Outline Component Example 2 in the Chapter11 scene</p>
<p class="calibre3">Next, let’s look at the <strong class="bold">Position As </strong><span><strong class="bold">UV1</strong></span><span> compo<a id="_idTextAnchor309" class="pcalibre pcalibre1 calibre6"/>nent.</span></p>
<h2 id="_idParaDest-200" class="calibre7"><a id="_idTextAnchor310" class="pcalibre pcalibre1 calibre6"/>Position As UV1</h2>
<p class="calibre3">The <strong class="bold">Position As UV1</strong> component<a id="_idIndexMarker646" class="pcalibre pcalibre1 calibre6"/> allows you to change the UV channel that the Canvas renders on. This is used if you want to create custom shaders that utilize baked <span>light maps.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer367">
<img alt="Figure 11.12: The Position As UV1 component" src="image/B18327_11_12.jpg" class="calibre362"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.12: The Position As UV1 component</p>
<p class="calibre3">Sadly, custom shaders are a pretty heavy topic and go past the scope of this text, so I won’t go any further into the usage of <span>this component.</span></p>
<p class="calibre3">Now that we’ve reviewed the UI Image component and some UI effect components, let’s look at some examples of ways we can use <span>these compon<a id="_idTextAnchor311" class="pcalibre pcalibre1 calibre6"/>ents.</span></p>
<h1 id="_idParaDest-201" class="calibre5"><a id="_idTextAnchor312" class="pcalibre pcalibre1 calibre6"/>Examples</h1>
<p class="calibre3">In this chapter, we’ll expand on the scene we’ve been building further by adding some new UI elements. We’ll also look at some mobile/touchscreen UI <span>and interactions.</span></p>
<p class="calibre3">Some of these examples may seem better suited for the chapter on Buttons, but since they include access to the Image component’s properties, I placed <span>them here.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">We have created two scenes that load into the scene we’ve been building upon: a start screen and an intro scene. Since I’ve been duplicating our main scene to make progress from each chapter easy to track, our intro sScene will not navigate to the updates we make in this and future chapters unless we keep updating the <strong class="bold">Next Scene</strong> variable on our <strong class="bold">Dialogue Boxes</strong> component in the intro sScene and including the new scene in our <span><strong class="bold">Build Settings</strong></span><span>.</span></p>
<p class="callout">I will not be including this update in the steps since scene navigation is no longer a focus of these examples. However, it will be included in the packages I include in each chapter’s <span>completed sc<a id="_idTextAnchor313" class="pcalibre pcalibre1 calibre6"/>enes.</span></p>
<h2 id="_idParaDest-202" class="calibre7"><a id="_idTextAnchor314" class="pcalibre pcalibre1 calibre6"/>Horizontal and circular health/progress meters</h2>
<p class="calibre3">Let’s get back to our main scene. Duplicate the <strong class="source-inline">Chapter10-Examples</strong> scene to create a <span><strong class="source-inline">Chapter11-Examples</strong></span><span> scene.</span></p>
<p class="calibre3">In this section, we’ll cover how to create two types of progress meters, a horizontal one and a circular one, as shown in the <span>following screenshot:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer368">
<img alt="Figure 11.13: Example of horizontal and vertical progress bars" src="image/B18327_11_13.jpg" class="calibre363"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.13: Example of horizontal and vertical progress bars</p>
<p class="calibre3">We’ll hook up the circular and horizontal progress meters so that they both display the progress of the same variable, and we can watch them both change at the <span>same time.</span></p>
<p class="calibre3">The circular progress meter doesn’t really fit in the main scene that we’ve been building, and we’ll hide it after this chapter, but circular progress bars are common game elements, so I thought it was important to include an example of how to do them in <span>this chap<a id="_idTextAnchor315" class="pcalibre pcalibre1 calibre6"/>ter.</span></p>
<h3 class="calibre9">Horizontal health bar</h3>
<p class="calibre3">There are a few different ways that a <a id="_idIndexMarker647" class="pcalibre pcalibre1 calibre6"/>horizontal health bar can be created, but the quickest and easiest way is to scale a single axis based on percentage. When setting up a horizontal health bar in this way, it is important to ensure that the anchor is set at a position that represents a completely <span>depleted bar.</span></p>
<p class="calibre3">Remember that back in <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 6</em></span></a>, we set the anchor of the health bar to the left, so we have already set the anchor correctly. We also scaled the health bar in the <em class="italic">x</em> direction to show what the bar would look like as <span>it depleted.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer369">
<img alt="" role="presentation" src="image/B18327_11_14.jpg" class="calibre364"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.14: The Health Bar’s Rect Transform component</p>
<p class="calibre3">Now, all we need to do is tie the percentage to the <strong class="bold">X Scale</strong> value of the <span>health bar.</span></p>
<p class="calibre3">To tie the fill of the health <a id="_idIndexMarker648" class="pcalibre pcalibre1 calibre6"/>bar to an actual value, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Create a new C# script in your <strong class="source-inline">Scripts</strong> folder and name <span>it </span><span><strong class="source-inline">ProgressMeters.cs</strong></span><span>.</span></li>
<li class="calibre14">In the <strong class="source-inline">ProgressMeters</strong> script, initialize the following <span>four variables:</span><pre class="source-code">
public uint health;
[SerializeField] uint totalHealth;
[SerializeField] float percentHealth;
[SerializeField] RectTransform healthBar;</pre><p class="calibre3">The <strong class="source-inline">health</strong> variable represents the current health of the player, and the <strong class="source-inline">totalHealth</strong> variable represents the total health the player can obtain. As it doesn’t make sense for these values to be negative, they have been initialized at the <strong class="source-inline">uint</strong> type or a positive integer. I have made the <strong class="source-inline">health</strong> variable <strong class="source-inline">public</strong> so that it can be accessed via other scripts and seen within the Inspector. I made <strong class="source-inline">totalHealth</strong> a private <strong class="source-inline">SerializeField</strong> so that it cannot be accessed via other scripts but still be seen and assigned via <span>the Inspector.</span></p><p class="calibre3">The <strong class="source-inline">percentHealth</strong> variable will be calculated based on the quotient of the <strong class="source-inline">health</strong> and <strong class="source-inline">totalHealth</strong> variables. I made this value private and serialized, not so that we can edit it in the Inspector but so that we can easily see its value change in <span>the Inspector.</span></p><p class="calibre3">The <strong class="source-inline">healthBar</strong> variable stores the <strong class="source-inline">RectTransform</strong> component of the <strong class="source-inline">Health Bar</strong> UI Image<a id="_idIndexMarker649" class="pcalibre pcalibre1 calibre6"/> within <span>our scene.</span></p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">Since <strong class="source-inline1">RectTransform</strong> inherits from <strong class="source-inline1">Transform</strong>, we could have declared <strong class="source-inline1">healthBar</strong> as a <strong class="source-inline1">Transform</strong> and the following code would <span>still work.</span></p>
<ol class="calibre13">
<li value="3" class="calibre14">Return to the Unity Editor and drag the <strong class="source-inline">ProgessMeters</strong> script onto <strong class="source-inline">HUD Canvas</strong> &gt; <strong class="source-inline">Top Left Panel</strong>. Assign the value <strong class="source-inline">500</strong> to both the <strong class="bold">Health</strong> and <strong class="bold">Total Health</strong> slots. Drag the <strong class="source-inline">Health Bar</strong> UI Image into the <strong class="bold">Health Bar</strong> slot. Any value you try to type into the <strong class="bold">Percent Health</strong> slot will be overridden by the code we write in the next step. Your component should look <span>as follows:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer370">
<img alt="Figure 11.15: The Progress Meters component" src="image/B18327_11_15.jpg" class="calibre365"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.15: The Progress Meters component</p>
<ol class="calibre13">
<li value="4" class="calibre14">We want any changes made to our <strong class="source-inline">health</strong> value to automatically update the <strong class="source-inline">percentHealth</strong> value and the scale of our <strong class="source-inline">healthBar</strong>. To do that, we can put the following code in the <span><strong class="source-inline">Update()</strong></span><span> function:</span><pre class="source-code">
void Update()
{
    // Cap health
    if (health &gt; totalHealth)
    {
        health = totalHealth;
    }
    // Calculate health percentage
    percentHealth = (float)health / totalHealth;
    // Update horizontal health bar
    healthBar.localScale = new Vector2(percentHealth, 1f);
}</pre><p class="calibre3">Declaring our <strong class="source-inline">health</strong> and <strong class="source-inline">totalHealth</strong> variables with the <strong class="source-inline">uint</strong> type stopped them from becoming negative, but we still need to put an upper cap on our <strong class="source-inline">health</strong> variable. It doesn’t make sense for it to exceed the <span><strong class="source-inline">totalHealth</strong></span><span> variable.</span></p><p class="calibre3">While <strong class="source-inline">percentHealth</strong> is a <strong class="source-inline">float</strong> variable, performing a division between two <strong class="source-inline">uint</strong> variables will result in a <strong class="source-inline">uint</strong> type, so adding <strong class="source-inline">(float)</strong> at the beginning of the integer division provides a <strong class="source-inline">float</strong> result from <span>the division.</span></p><p class="calibre3">The last part of the code sets the <strong class="source-inline">localScale</strong> value of the <strong class="source-inline">healthBar</strong>. When you scale a UI object, you have to use <strong class="source-inline">localScale</strong>. This scales the object locally, meaning relative to<a id="_idIndexMarker650" class="pcalibre pcalibre1 calibre6"/> its <span>parent object.</span></p></li> <li class="calibre14">Now, we can test the code easily in the Editor. Play the game and hover your mouse over the word <strong class="bold">Health</strong> in the <strong class="bold">Progress Meters</strong> component until the mouse displays two arrows around it, as shown in the <span>following figure:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer371">
<img alt="Figure 11.16: The Progress Meters component’s effect on the meter" src="image/B18327_11_16.jpg" class="calibre366"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.16: The Progress Meters component’s effect on the meter</p>
<p class="calibre3">When these arrows appear, clicking and dragging will manipulate the values of the variable based on your mouse position. You’ll see, as you do this, that as the <strong class="bold">Health</strong> value decreases, the <strong class="bold">Percent Health</strong> value decreases, and the <strong class="source-inline">Health Bar</strong> in the scene changes size. You’ll note that you cannot set the value of <strong class="bold">Health</strong> below <strong class="source-inline">0</strong> or <span>above </span><span><strong class="source-inline">500</strong></span><span>.</span></p>
<p class="calibre3">As you can see, setting up a horizontal health bar isn’t terribly difficult. Duplicating this process in a game where the health reduces by Events won’t require a lot of steps to achieve. Just ensure that you set the anchor of the health bar correctly. This process will work similarly for a vertical<a id="_idIndexMarker651" class="pcalibre pcalibre1 calibre6"/> <span>healt<a id="_idTextAnchor316" class="pcalibre pcalibre1 calibre6"/>h bar.</span></p>
<h3 class="calibre9">Circular progress meter</h3>
<p class="calibre3">Horizontal health bars didn’t take a lot of work to set up. The work to make a circular progress meter is just about as easy and can be completed with only two more lines of code. Since we don’t already have a circular progress bar in our scene, we will have to start with a bit of <span>setup first.</span></p>
<p class="calibre3">To create a circular progress bar, complete the <a id="_idIndexMarker652" class="pcalibre pcalibre1 calibre6"/><span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">From the code bundle, drag the <strong class="source-inline">circularMeter.png</strong> sprite into the <strong class="source-inline">Sprites</strong> folder of <span>your project.</span></li>
<li class="calibre14">Set the <strong class="bold">Sprite Mode</strong> of the <strong class="source-inline">circularMeter.png</strong> sprite to <strong class="bold">Multiple</strong> and automatically slice it in the <span><strong class="bold">Sprite Editor</strong></span><span>.</span></li>
<li class="calibre14">Select the <strong class="source-inline">Top Left Panel</strong> within the Hierarchy and give it a new UI Image child. Name the Image <span><strong class="source-inline">Progress Holder</strong></span><span>.</span></li>
<li class="calibre14">Similar to how we set up the health bar, there will be a holder and a fill. Drag the <strong class="source-inline">circularMeter_0</strong> sub-sprite into the <strong class="bold">Source Image</strong> slot of the <strong class="bold">Image</strong> component of <span><strong class="source-inline">Progress Holder</strong></span><span>.</span></li>
<li class="calibre14">It’s important that we get the right proportions for our holder and fill Images. So, to ensure that the Image is correctly proportioned, hit the <strong class="bold">Set Native Size</strong> button on the <span><strong class="bold">Image</strong></span><span> component.</span></li>
<li class="calibre14">Now, add a child UI Image to <strong class="source-inline">Progress Holder</strong> called <span><strong class="source-inline">Progress Meter</strong></span><span>.</span></li>
<li class="calibre14">Set the anchor preset of <strong class="source-inline">Progress Meter</strong> to middle center. Do not <span>stretch it.</span></li>
<li class="calibre14">Add <strong class="source-inline">circularMeter_1</strong> to the <strong class="bold">Source Image</strong> slot of the <strong class="bold">Image</strong> component on the <span><strong class="source-inline">Progress Meter</strong></span><span>.</span></li>
<li class="calibre14">Hit the <strong class="bold">Set Native Size</strong> button for the <strong class="source-inline">Progress Meter</strong> <strong class="bold">Image</strong> component as well. After completing this step, you should see <span>the following:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer372">
<img alt="Figure 11.17: The progress on the Progress Meter" src="image/B18327_11_17.jpg" class="calibre367"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.17: The progress on the Progress Meter</p>
<p class="calibre3">If the pink fill is not perfectly <a id="_idIndexMarker653" class="pcalibre pcalibre1 calibre6"/>nestled inside the blue holder, you may have forgotten to hit the <strong class="bold">Set Native Size</strong> button on one of the Images or the <strong class="source-inline">Progress Meter</strong> does not have its anchor preset set to <span>middle center.</span></p></li>
</ol>
<ol class="calibre13">
<li value="10" class="calibre14">Let’s move this meter and scale it a bit. Select <strong class="source-inline">Progress Holder</strong> and move it so that it is positioned in the scene below <strong class="source-inline">Character Holder</strong>. Set the <strong class="bold">Scale X</strong> and <strong class="bold">Scale Y</strong> values of <strong class="source-inline">Progress Holder</strong> to <strong class="source-inline">0.8</strong> to make it a <span>little smaller.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer373">
<img alt="Figure 11.18: Repositioning the circular progress meter" src="image/B18327_11_18.jpg" class="calibre368"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.18: Repositioning the circular progress meter</p>
<ol class="calibre13">
<li value="11" class="calibre14">The last thing to do to the code is to change the <strong class="bold">Image Type</strong> of the <strong class="source-inline">Progress Meter</strong>. Change <a id="_idIndexMarker654" class="pcalibre pcalibre1 calibre6"/>the <strong class="bold">Image Type</strong> to <strong class="bold">Filled</strong> with a <strong class="bold">Radial 360 Fill Method</strong>. Change the <strong class="bold">Fill Origin</strong> to <strong class="bold">Top</strong>. Adjust the scroll bar on the <strong class="bold">Fill Amount</strong> to preview the <span>meter filling:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer374">
<img alt="Figure 11.19: Adjusting the fill amount on the circular progress meter" src="image/B18327_11_19.jpg" class="calibre369"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.19: Adjusting the fill amount on the circular progress meter</p>
<ol class="calibre13">
<li value="12" class="calibre14">Now, we’re ready to write some code. As you have probably guessed from adjusting the <strong class="bold">Fill Amount</strong> value in the Inspector, we’ll want to tie the <strong class="source-inline">fillAmount</strong> value to the <strong class="source-inline">percentHealth</strong> variable in our code. First, we need to create a variable with which we can access the Image component of our <strong class="source-inline">Progress Meter</strong>. Declare the following variable at the top of <span>your code:</span><pre class="source-code">
[SerializeField] Image progressMeter;</pre></li> <li class="calibre14">Now, add the following at the end of the <span><strong class="source-inline">Update()</strong></span><span> function:</span><pre class="source-code">
// Circular progress meter
progressMeter.fillAmount = percentHealth;</pre></li> <li class="calibre14">The last thing we need <a id="_idIndexMarker655" class="pcalibre pcalibre1 calibre6"/>to do is hook the <strong class="source-inline">Progress Meter</strong> UI Image to the <strong class="source-inline">progressMeter</strong> variable. Drag the <strong class="source-inline">Progress Meter</strong> into the <strong class="bold">Progress </strong><span><strong class="bold">Meter</strong></span><span> slot.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer375">
<img alt="Figure 11.20: The Progress Meter component’s updates" src="image/B18327_11_20.jpg" class="calibre370"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.20: The Progress Meter component’s updates</p>
<ol class="calibre13">
<li value="15" class="calibre14">Play the game and adjust the <strong class="bold">Health</strong> value in the Inspector as you did earlier, and watch the two meters move <span>in unison.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer376">
<img alt="Figure 11.21: Result of the Progress Meter" src="image/B18327_11_21.jpg" class="calibre371"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.21: Result of the Progress Meter</p>
<p class="calibre3">As you can see, making a circular progress meter is really not more difficult than making a <span>horizontal one!</span></p>
<p class="callout-heading">Note</p>
<p class="callout">In the same way we used the fill amount for the circular progress bar, we could have used the fill amount for the horizontal health bar. Setting the <strong class="bold">Image Type</strong> property to <strong class="bold">Filled</strong> and <strong class="bold">Horizontal</strong> and then affecting the <strong class="bold">Fill Amount</strong> value rather than the scale would have had a <span>similar effect.</span></p>
<p class="calibre3">Because this circular progress meter <a id="_idIndexMarker656" class="pcalibre pcalibre1 calibre6"/>wasn’t part of the original UI plan and was only placed in the scene for demonstration purposes, I am going to disable it in all future figures <span>and screen<a id="_idTextAnchor317" class="pcalibre pcalibre1 calibre6"/><a id="_idTextAnchor318" class="pcalibre pcalibre1 calibre6"/>shots.</span></p>
<h2 id="_idParaDest-203" class="calibre7"><a id="_idTextAnchor319" class="pcalibre pcalibre1 calibre6"/>Mute Buttons with sprite swap</h2>
<p class="calibre3">Now, let’s look at an example where we swap the <a id="_idIndexMarker657" class="pcalibre pcalibre1 calibre6"/>sprite of a Button based on a pre-defined state. This is different than a sprite swap transition, which we discussed in <a href="B18327_09.xhtml#_idTextAnchor213" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 9</em></span></a>, because it won’t use the states of highlighted, pressed, selected, or disabled. It’s included in this chapter rather than the Buttons chapter since it involves affecting the Image component, not the <span>Button component.</span></p>
<p class="calibre3">In the scene, we have a <strong class="source-inline">Pause Panel</strong> that pops up when the <em class="italic">P</em> key is hit on the keyboard. On this Panel, we will place two mute Buttons, one for music and one for sound, which will toggle between muted and unmuted states. The Panel will appear as shown in the <span>following screenshot:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer377">
<img alt="Figure 11.22: The Pause Panel with new mute Buttons" src="image/B18327_11_22.jpg" class="calibre372"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.22: The Pause Panel with new mute Buttons</p>
<p class="calibre3">To add the music and sound Buttons<a id="_idIndexMarker658" class="pcalibre pcalibre1 calibre6"/> shown in the preceding screenshot, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">First, we need to bring in a new art asset. The Button sprites on the sprite sheet we imported previously are a bit too small and don’t contain a muted version. So, I edited them a bit and provided a new sprite for you. In the book’s source files, you should find an <strong class="source-inline">.png</strong> file <span>named </span><span><strong class="source-inline">muteUnmute.png</strong></span><span>:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer378">
<img alt="Figure 11.23: The muteUnmute.png sprite" src="image/B18327_11_23.jpg" class="calibre373"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.23: The muteUnmute.png sprite</p>
<p class="calibre3">Import this <strong class="source-inline">.png</strong> file into your project’s <span><strong class="source-inline">Assets/Sprites</strong></span><span> folder.</span></p></li>
</ol>
<ol class="calibre13">
<li value="2" class="calibre14">Slice the sprite into mu<a id="_idTextAnchor320" class="pcalibre pcalibre1 calibre6"/>ltiple sub-sprites by changing its <strong class="bold">Sprite Mode</strong> to <strong class="bold">Multiple</strong>, opening its <strong class="bold">Sprite Editor</strong>, and applying the automatic slice type. Multiple sprites should<a id="_idIndexMarker659" class="pcalibre pcalibre1 calibre6"/> appear <span>as follows:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer379">
<img alt="Figure 11.24: The muteUnmute.png sprite sliced" src="image/B18327_11_24.jpg" class="calibre374"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.24: The muteUnmute.png sprite sliced</p>
<ol class="calibre13">
<li value="3" class="calibre14">Create two new Buttons as children of the <strong class="source-inline">Pause Panel</strong> and name them <strong class="source-inline">Music Button</strong> and <strong class="source-inline">Sound Button</strong>. Delete their text children because we do not <span>need them.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer380">
<img alt="Figure 11.25: The current view of the Hierarchy" src="image/B18327_11_25.jpg" class="calibre375"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.25: The current view of the Hierarchy</p>
<ol class="calibre13">
<li value="4" class="calibre14">Give the two new Buttons<a id="_idIndexMarker660" class="pcalibre pcalibre1 calibre6"/> the following <strong class="bold">Rect Transform</strong> and <span><strong class="bold">Image</strong></span><span> properties:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer381">
<img alt="Figure 11.26: The Rect Transform of the two Buttons" src="image/B18327_11_26.jpg" class="calibre376"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.26: The Rect Transform of the two Buttons</p>
<p class="calibre3">Your Panel should now look just like the one at the beginning of <span>this example:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer382">
<img alt="Figure 11.27: The Pause Panel" src="image/B18327_11_27.jpg" class="calibre377"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.27: The Pause Panel</p></li>
</ol>
<ol class="calibre13">
<li value="5" class="calibre14">Now, let’s write some code to make these Buttons swap sprites that will represent the sound and <a id="_idIndexMarker661" class="pcalibre pcalibre1 calibre6"/>music toggling on and off. Create a new script called <strong class="source-inline">MuteUnmute.cs</strong> in your <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder.</span><p class="calibre3">Replace the code of <strong class="source-inline">MuteUnmute</strong> with <span>the following:</span></p><pre class="source-code">
public class MuteUnmute : MonoBehaviour
{
    [SerializeField] Button musicButton;
    private Image musicImage;
    [SerializeField] private Sprite[] musicSprites = new Sprite[2];
    private bool musicOn = true;
    [SerializeField] Button soundButton;
    private Image soundImage;
    [SerializeField] private Sprite[] soundSprites = new Sprite[2];
    private bool soundOn = true;
    void Awake()
    {
        musicImage = musicButton.GetComponent&lt;Image&gt;();
        soundImage = soundButton.GetComponent&lt;Image&gt;();
    }
    public void ToggleMusic()
    {
        musicOn = !musicOn;
        musicImage.sprite = musicSprites[Convert.ToInt32(musicOn)];
    }
    public void ToggleSound()
    {
        soundOn = !soundOn;
        soundImage.sprite = soundSprites[Convert.ToInt32(soundOn)];
    }
}</pre></li> </ol>
<p class="calibre3">As you can see, this code contains two main functions: <strong class="source-inline">ToggleMusic()</strong> and <strong class="source-inline">ToggleSound()</strong>. These two function identically by simply swapping the sprite on the specified Button based on the <strong class="source-inline">musicOn</strong> and <strong class="source-inline">soundOn</strong> <span>Boolean values.</span></p>
<p class="calibre3">To swap the sprite, the script first finds the Image component on the two Buttons specified as <strong class="source-inline">musicButton</strong> and <strong class="source-inline">soundButton</strong>, within the <strong class="source-inline">Awake()</strong> function. These Buttons will be assigned in the Inspector. It then swaps the sprite of the Image component to the correct sprite<a id="_idIndexMarker662" class="pcalibre pcalibre1 calibre6"/> from an array of sprites. The sprites for the mute and unmute states will be assigned in the Inspector in a <span>future step.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Sadly, this book does not cover adding sound and music to a Unity project. The code provided here doesn’t actually mute and unmute audio; it simply swaps sprites. You will simply need to include two audio sources: one for playing music and one for playing sounds that have the <strong class="bold">Music</strong> and <strong class="bold">Sound</strong> <span>tags, respectively.</span></p>
<ol class="calibre13">
<li class="calibre14">Go back to the Unity Editor and attach the <strong class="source-inline">MuteUnmute.cs</strong> script to the <strong class="source-inline">Pause Panel</strong> by dragging it into <span>its </span><span><strong class="bold">Inspector</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer383">
<img alt="Figure 11.28: The Mute Unmute component" src="image/B18327_11_28.jpg" class="calibre378"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.28: The Mute Unmute component</p>
<ol class="calibre13">
<li value="2" class="calibre14">Now, we want to assign the appropriate Buttons and sprites to the slots. Drag the <strong class="source-inline">Music Button</strong> and <strong class="source-inline">Sound Button</strong> into their designated slots from the Hierarchy. Drag and drop<a id="_idIndexMarker663" class="pcalibre pcalibre1 calibre6"/> the audio Button sprites from the project view to their appropriate slots, making sure to put the muted sprite in the 0 element of <span>the array.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer384">
<img alt="Figure 11.29: The updated Mute Unmute component" src="image/B18327_11_29.jpg" class="calibre379"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.29: The updated Mute Unmute component</p>
<ol class="calibre13">
<li value="3" class="calibre14">Now, we just need to hook up the Buttons to call the appropriate functions. Select the <strong class="source-inline">Music Button</strong>. Select the <strong class="bold">+</strong> sign at the bottom of the <strong class="source-inline">OnClick()</strong> Event list of the <strong class="bold">Button</strong> component to add a new Event. The script we want to access, <strong class="source-inline">MuteUnmute.cs</strong>, is on the <strong class="source-inline">Pause Panel</strong>, so drag the <strong class="source-inline">Pause Panel</strong> into the object slot. Now, from the function dropdown menu, select <strong class="bold">MuteUnmute</strong> | <span><strong class="bold">ToggleMusic</strong></span><span>.</span></li>
<li class="calibre14">Perform the same actions <a id="_idIndexMarker664" class="pcalibre pcalibre1 calibre6"/>as you did in the previous step for the <strong class="source-inline">Sound Button</strong>, but this time select <strong class="bold">MuteUnmute</strong> | <strong class="bold">ToggleSound</strong> from the function <span>dropdown list.</span></li>
</ol>
<p class="calibre3">Now, play the game, press <em class="italic">P</em> to bring up the <strong class="source-inline">Pause Panel</strong>, and you will see the Buttons toggle back and forth between their two <span>different s<a id="_idTextAnchor321" class="pcalibre pcalibre1 calibre6"/>prites.</span></p>
<p class="calibre3">Now that we’ve looked at how to implement progress meters and sprite swap Buttons, let’s look at how to implement a few different <span>mobile-specific interactions.</span></p>
<h2 id="_idParaDest-204" class="calibre7"><a id="_idTextAnchor322" class="pcalibre pcalibre1 calibre6"/>Adding press-and-hold/long-press functionality</h2>
<p class="calibre3">Press-and-hold is utilized frequently in mobile games. Many games that use right-click on a PC or the web use press-and-hold when they are converted to the <span>mobile platform.</span></p>
<p class="calibre3">To demonstrate how to<a id="_idIndexMarker665" class="pcalibre pcalibre1 calibre6"/> implement press-and-hold functionality, we will create a Button that has a growing ring that represents hold time. Once a specified amount of time has passed, a function <span>will fire:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer385">
<img alt="Figure 11.30: Press-and-hold Button example" src="image/B18327_11_30.jpg" class="calibre380"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.30: Press-and-hold Button example</p>
<p class="calibre3">When working on this example, it is important to remember that even though the code is referencing a pointer, this functionality does not work exclusively with a mouse. Placing a finger on a touchscreen functions in the same way as a pointer down, and picking up the finger works the same as a <span>pointer up.</span></p>
<p class="calibre3">To create a Button with a growing ring that represents hold time, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Create a new scene named <strong class="source-inline">Chapter11-Examples-Buttons1</strong> in the <strong class="source-inline">Assets/Scenes</strong> folder and open the <span>new scene.</span></li>
<li class="calibre14">Select <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Button</strong> to create a new Button in <span>the scene.</span></li>
<li class="calibre14">Set the Button’s <strong class="bold">Transition</strong> type on the <strong class="bold">Button</strong> component <span>to </span><span><strong class="bold">None</strong></span><span>.</span></li>
<li class="calibre14">Change the text on the Button to say <strong class="source-inline">Press </strong><span><strong class="source-inline">and Hold</strong></span><span>.</span></li>
<li class="calibre14">Right-click the <strong class="source-inline">Button</strong> in the Hierarchy and select <strong class="bold">UI</strong> | <strong class="bold">Image</strong> to add an <strong class="source-inline">Image</strong> child to <span>the </span><span><strong class="source-inline">Button</strong></span><span>.</span></li>
<li class="calibre14">Change the <strong class="bold">Width</strong> and <strong class="bold">Height</strong> on the <strong class="source-inline">Image</strong>’s <strong class="bold">Rect Transform</strong> component <span>to </span><span><strong class="source-inline">50</strong></span><span>.</span></li>
<li class="calibre14">Assign the <strong class="source-inline">circularMeter_1</strong> sprite to the <strong class="bold">Source Image</strong> property of the <span><strong class="bold">Image</strong></span><span> component.</span></li>
<li class="calibre14">Change the <strong class="bold">Image Type</strong> to <strong class="bold">Filled</strong> and change the <strong class="bold">Fill Amount</strong> <span>to </span><span><strong class="source-inline">0</strong></span><span>.</span></li>
<li class="calibre14">To create press-and-hold functionality on the <strong class="source-inline">Button</strong>, we will utilize the <strong class="bold">Pointer Down</strong> and <strong class="bold">Pointer Up</strong> Events. Add the <strong class="bold">Event Trigger</strong> component to the <span><strong class="source-inline">Button</strong></span><span> object.</span></li>
<li class="calibre14">Select <strong class="bold">Add New Event Type</strong> and <span>select </span><span><strong class="bold">PointerDown</strong></span><span>.</span></li>
<li class="calibre14">Select <strong class="bold">Add New Event Type</strong> and <span>select </span><span><strong class="bold">PointerUp</strong></span><span>.</span></li>
<li class="calibre14">Now, we need to actually write the functions that will be called by the Event Triggers we set up in the previous <a id="_idIndexMarker666" class="pcalibre pcalibre1 calibre6"/>steps. Create a new script in the <strong class="source-inline">Assets/Scripts</strong> folder <span>called </span><span><strong class="source-inline">LongPressButton</strong></span><span>.</span></li>
<li class="calibre14">Before opening the script, go ahead and attach it as a component <span>to </span><span><strong class="source-inline">Button</strong></span><span>.</span></li>
<li class="calibre14">Add the <strong class="source-inline">UnityEngine.UI</strong> namespace to the top of the script with <span>the following:</span><pre class="source-code">
using UnityEngine.UI;</pre></li> <li class="calibre14">To check how long the Button is being pressed, we will use a Boolean variable that checks to see if the Button is being held and a few different variables related to time. Add the following variable declaration to <span>your script:</span><pre class="source-code">
private bool buttonPressed = false;
private float startTime = 0f;
private float holdTime = 0f;
[SerializeField] private float longHoldTime = 1f;</pre><p class="calibre3">The <strong class="source-inline">buttonPressed</strong> variable will be set to <strong class="source-inline">true</strong> with the <strong class="bold">Pointer Down</strong> Event and false with the <strong class="bold">Pointer Up</strong> Event. The <strong class="source-inline">startTime</strong> variable will be set to the current time when the <strong class="bold">Pointer Down</strong> Event is triggered. The <strong class="source-inline">holdTime</strong> variable will determine how much time has passed since <strong class="source-inline">startTime</strong>. The <strong class="source-inline">longHoldTime</strong> variable is the amount of time the Button must be held down before the long press is complete. It is serialized so that it can be <span>easily customized.</span></p></li> <li class="calibre14">The last variable we need will represent the radial filling Image. Add the following variable <a id="_idIndexMarker667" class="pcalibre pcalibre1 calibre6"/>declaration to <span>your code:</span><pre class="source-code">
[SerializeField] private Image radialFillImage;</pre></li> <li class="calibre14">Now, we need to write a function that will be called by both the <strong class="bold">Pointer Down</strong> and <strong class="bold">Pointer </strong><span><strong class="bold">Up</strong></span><span> Events:</span><pre class="source-code">
public void PressAndRelease(bool pressStatus)
{
    buttonPressed = pressStatus;
    if (!buttonPressed)
    {
        holdTime = 0;
        radialFillImage.fillAmount = 0;
    }
    else
    {
        startTime = Time.time;
    }
}</pre><p class="calibre3">This function accepts a Boolean variable from the Event Trigger. It then sets the value of <strong class="source-inline">buttonPressed</strong> to the <span>passed value.</span></p><p class="calibre3">When the Button is released, a value of <strong class="source-inline">false</strong> will be passed to the function. If the value passed is <strong class="source-inline">false</strong>, the amount of time that has passed, <strong class="source-inline">holdTime</strong>, is reset to <strong class="source-inline">0</strong>, and the <strong class="source-inline">radialFillImage</strong> Image is reset to have a <strong class="source-inline">fillAmount</strong> value <span>of </span><span><strong class="source-inline">0</strong></span><span>.</span></p><p class="calibre3">When the Button is pressed, the <strong class="source-inline">startTime</strong> value will be set to the <span>current time.</span></p></li> <li class="calibre14">Create a function that will be called once the full amount of time needed for the long press, specified by <strong class="source-inline">longHoldTime</strong>, <span>has completed:</span><pre class="source-code">
public void LongPressCompleted()
{
    radialFillImage.fillAmount = 0;
    Debug.Log("Do something after long press");
}</pre><p class="calibre3">This function doesn’t really do anything but reset the filling Image and print out a <strong class="source-inline">Debug.Log</strong>. However, you can later reuse this code and replace the <strong class="source-inline">Debug.Log</strong> line with more interesting and <span>meaningful actions.</span></p></li> <li class="calibre14">The <strong class="source-inline">Update()</strong> function can be used to make the timer count upward. Adjust the <strong class="source-inline">Update()</strong> function <a id="_idIndexMarker668" class="pcalibre pcalibre1 calibre6"/><span>as follows:</span><pre class="source-code">
void Update()
{
    if (buttonPressed)
    {
        holdTime = Time.time - startTime;
        if (holdTime &gt;= longHoldTime)
        {
            buttonPressed = false;
            LongPressCompleted();
        }
        else
        {
            radialFillImage.fillAmount = holdTime / longHoldTime;
        }
    }
}</pre><p class="calibre3">This code makes the value of <strong class="source-inline">holdTime</strong> tick upward if the <strong class="source-inline">buttonPressed</strong> value is set to <strong class="source-inline">true</strong>. Remember—<strong class="source-inline">buttonPressed</strong> will be set to <strong class="source-inline">true</strong> with a <strong class="bold">Pointer Down</strong> Event and <strong class="source-inline">false</strong> with a <strong class="bold">Pointer Up</strong> Event. So, it will only be true if the player has pressed the Button and not yet <span>released it.</span></p><p class="calibre3">Once the <strong class="source-inline">holdTime</strong> value reaches the value specified by <strong class="source-inline">longHoldTime</strong>, the timer will stop ticking up, because <strong class="source-inline">buttonPressed</strong> will be reset to <strong class="source-inline">false</strong>. Additionally, the <strong class="source-inline">LongPressCompleted()</strong> function is called. If <strong class="source-inline">longHoldTime</strong> has not yet been reached, the Image’s radial fill will update to represent the percentage of total required time that <span>has transpired.</span></p></li> <li class="calibre14">Now that the script is completed, we can hook up the <strong class="source-inline">PressAndRelease()</strong> function with the Event Triggers on the Button. Add the <strong class="source-inline">PressAndRelease</strong> function from the static list to both the <strong class="bold">Pointer Down</strong> and <strong class="bold">Pointer Up</strong> Event Triggers. Since the <strong class="source-inline">PressAndRelease()</strong> function accepts a Boolean variable, there is a checkbox representing the Boolean value that should be passed. Select the checkbox for the <strong class="bold">Pointer Down</strong> Event (sending <strong class="source-inline">true</strong>) but not for the <strong class="bold">Pointer Up</strong> Event (<span>sending </span><span><strong class="source-inline">false</strong></span><span>).</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer386">
<img alt="Figure 11.31: The Event Trigger component" src="image/B18327_11_31.jpg" class="calibre381"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.31: The Event Trigger component</p>
<ol class="calibre13">
<li value="21" class="calibre14">Now, we need to assign the <strong class="source-inline">Image</strong> to the <strong class="bold">Radial Fill Image</strong> slot on the <strong class="bold">Long </strong><span><strong class="bold">Press</strong></span><span> component.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer387">
<img alt="Figure 11.32: The Long Press component" src="image/B18327_11_32.jpg" class="calibre382"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.32: The Long Press component</p>
<p class="calibre3">Playing the game now will <a id="_idIndexMarker669" class="pcalibre pcalibre1 calibre6"/>demonstrate the Image radially filling when you hold the Button and printing <strong class="source-inline">Do something after long press</strong> in the console. If you release the Button before the fill has completed, it will go away and reset for when you start <span>clicking again.</span></p>
<p class="calibre3">Press-and-hold is a pretty common functionality, and while it isn’t a pre-installed Event in the Unity Event library, luckily it isn’t too difficult to hook up. I recommend holding on to that script so that you can reuse it in <span>the<a id="_idTextAnchor323" class="pcalibre pcalibre1 calibre6"/> future.</span></p>
<p class="calibre3">Creating a static four-directional <span>virtual D-Pad</span></p>
<p class="calibre3">A D-Pad is simply four Buttons on a directional pad. To create a D-Pad for a mobile game, you just need to create a<a id="_idIndexMarker670" class="pcalibre pcalibre1 calibre6"/> graphic that contains four Buttons on <span>the directions.</span></p>
<p class="calibre3">The art used in this example was obtained <span>from </span><a href="https://opengameart.org/content/onscreen-controls-8-styles" class="pcalibre pcalibre1 calibre6"><span>https://opengameart.org/content/onscreen-controls-8-styles</span></a><span>.</span></p>
<p class="calibre3">To create a virtual D-Pad, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Create a new scene named <strong class="source-inline">Chapter11-Examples-Buttons2</strong> in the <strong class="source-inline">Assets/Scenes</strong> folder and open the <span>new scene.</span></li>
<li class="calibre14">Import the <strong class="source-inline">dPadButtons.png</strong> sprite sheet into the <span><strong class="source-inline">Assets/Sprites</strong></span><span> folder.</span></li>
<li class="calibre14">Change the newly imported sprite’s <strong class="bold">Sprite Mode</strong> to <strong class="bold">Multiple</strong> and automatically <span>slice it.</span></li>
<li class="calibre14">Create a new Canvas with <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Canvas</strong>. Name the new Canvas <span><strong class="source-inline">D-Pad Canvas</strong></span><span>.</span></li>
<li class="calibre14">The size of a D-Pad is incredibly important on mobile devices. Even if the screen gets smaller, you’ll probably want the D-Pad to be about the same size. If it gets too small, the game can be unplayable or uncomfortable. Therefore, set the <strong class="bold">Canvas Scaler</strong> component’s <strong class="bold">UI Scale Mode</strong> value to <strong class="bold">Constant </strong><span><strong class="bold">Physical Size</strong></span><span>.</span></li>
<li class="calibre14">Add a new Image as a child of <strong class="source-inline">D-Pad Canvas</strong> with <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Image</strong> and rename it <span><strong class="source-inline">D-Pad Background</strong></span><span>.</span></li>
<li class="calibre14">Set the <strong class="bold">Source Image</strong> <span>to </span><span><strong class="source-inline">dPadButtons_4</strong></span><span>.</span></li>
<li class="calibre14">Set its anchor and pivot to the lower-left corner of the screen, and set its <strong class="bold">Pos X</strong> and <strong class="bold">Pos Y</strong> values <span>to </span><span><strong class="source-inline">30</strong></span><span>.</span></li>
<li class="calibre14">Set its <strong class="bold">Width</strong> and <strong class="bold">Height</strong> <span>to </span><span><strong class="source-inline">200</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer388">
<img alt="Figure 11.33: The D-Pad positioned correctly" src="image/B18327_11_33.jpg" class="calibre383"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.33: The D-Pad positioned correctly</p>
<ol class="calibre13">
<li value="10" class="calibre14">Right-click on <strong class="source-inline">D-Pad Background</strong> and add a new Button as a child with <strong class="bold">UI</strong> | <strong class="bold">Button</strong>. Rename the new <span>Button </span><span><strong class="source-inline">Up</strong></span><span>.</span></li>
<li class="calibre14">Remove its child <span><strong class="source-inline">Text</strong></span><span> object.</span></li>
<li class="calibre14">Set the <strong class="bold">Pos X</strong>, <strong class="bold">Pos Y</strong>, <strong class="bold">Width</strong>, and <strong class="bold">Height</strong> values of the <strong class="source-inline">Up</strong> Button to <strong class="source-inline">0</strong>, <strong class="source-inline">65</strong>, <strong class="source-inline">60</strong>, and <strong class="source-inline">60</strong>, respectively. This will <a id="_idIndexMarker671" class="pcalibre pcalibre1 calibre6"/>create a square over just the up position of the <span>D-Pad Image.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer389">
<img alt="Figure 11.34: The D-Pad with an Up Button" src="image/B18327_11_34.jpg" class="calibre384"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.34: The D-Pad with an Up Button</p>
<ol class="calibre13">
<li value="13" class="calibre14">Duplicate the <strong class="source-inline">Up</strong> Button three times and rename the duplicates <strong class="source-inline">Right</strong>, <strong class="source-inline">Left</strong>, <span>and </span><span><strong class="source-inline">Down</strong></span><span>.</span></li>
<li class="calibre14">Set the <strong class="source-inline">Right</strong> Button’s <strong class="bold">Pos X</strong> and <strong class="bold">Pos Y</strong> values to <strong class="source-inline">65</strong> and <span><strong class="source-inline">0</strong></span><span>, respectively.</span></li>
<li class="calibre14">Set the <strong class="source-inline">Left</strong> Button’s <strong class="bold">Pos X</strong> and <strong class="bold">Pos Y</strong> values to <strong class="source-inline">-65</strong> and <span><strong class="source-inline">0</strong></span><span>, respectively.</span></li>
<li class="calibre14">Set the <strong class="source-inline">Down</strong> Button’s <strong class="bold">Pos X</strong> and <strong class="bold">Pos Y</strong> values to <strong class="source-inline">0</strong> and <strong class="source-inline">-65</strong>, respectively. You should now have <a id="_idIndexMarker672" class="pcalibre pcalibre1 calibre6"/>four Buttons positioned <span>as follows:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer390">
<img alt="Figure 11.35: The D-Pad with all of its Buttons" src="image/B18327_11_35.jpg" class="calibre385"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.35: The D-Pad with all of its Buttons</p>
<p class="calibre3">These four Buttons cover the entire area of the arms of the directional pad. They will act as the hit area for <span>the directions.</span></p></li>
</ol>
<ol class="calibre13">
<li value="17" class="calibre14">We only really want these four Buttons for their hit area and don’t want to actually have them visible in the UI. Select all four of the Buttons in the Hierarchy and set the alpha value on the <strong class="bold">Color</strong> property of their <strong class="bold">Image</strong> component <span>to </span><span><strong class="source-inline">0</strong></span><span>.</span></li>
<li class="calibre14">Since the directional pad Image is static and not split into four separate Buttons, any transitions applied to it would cover the whole Image. However, we can make the individual directions look as if they are being pressed and have some sort of color transition by adding sub-Images for the arrows on the directions. Right-click the <strong class="source-inline">Up</strong> Button and add an Image as a child with <strong class="bold">UI</strong> | <strong class="bold">Image</strong>. Rename the new <span>Image </span><span><strong class="source-inline">Arrow</strong></span><span>.</span></li>
<li class="calibre14">Assign the <strong class="source-inline">dPadButtons_5</strong> sprite to the <strong class="bold">Source Image</strong> on its <strong class="bold">Image</strong> component and select <span><strong class="bold">Preserve Aspect</strong></span><span>.</span></li>
<li class="calibre14">Scale and move the Image so that it is appropriately lined up with the arrow displayed on the D-Pad <span>background Image:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer391">
<img alt="Figure 11.36: The Up Arrow of the D-Pad" src="image/B18327_11_36.jpg" class="calibre386"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.36: The Up Arrow of the D-Pad</p>
<ol class="calibre13">
<li value="21" class="calibre14">Select the <strong class="bold">Color</strong> slot on the <strong class="source-inline">Arrow</strong> Image component and use the eye dropper tool to grab the color of the arrows from the <strong class="source-inline">D-Pad Background</strong> Image. This will make it a light gray instead <span>of white.</span></li>
<li class="calibre14">Create <strong class="source-inline">Arrow</strong> children<a id="_idIndexMarker673" class="pcalibre pcalibre1 calibre6"/> for each of the other three Buttons, and size, position, and color them appropriately. Make sure to also use the correct sub-Image of the <strong class="source-inline">dPadButtons</strong> sprite sheet. Once completed, your D-Pad and Hierarchy should appear <span>as follows:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer392">
<img alt="Figure 11.37: All Arrows on the D-Pad" src="image/B18327_11_37.jpg" class="calibre387"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.37: All Arrows on the D-Pad</p>
<ol class="calibre13">
<li value="23" class="calibre14">Now, so that the D-Pad will react visually when the four directions are pressed, we will set the four <strong class="source-inline">Arrow</strong> children to have color tint Button <strong class="bold">Transitions</strong> when the four Buttons are pressed. For each Button, drag its <strong class="source-inline">Arrow</strong> child into the <strong class="bold">Target Graphic</strong> slot on its <strong class="bold">Button</strong> component. Now, when you press the individual Buttons, you will see a slight change in the color of the arrows, indicating which direction is<a id="_idIndexMarker674" class="pcalibre pcalibre1 calibre6"/> pressed. You may wish to change the pressed color to something a bit more drastic than the default gray if you are having difficulty telling that a change <span>is occurring.</span></li>
<li class="calibre14">Add the script named <strong class="source-inline">DPad.cs</strong> from the book’s code bundle to the <strong class="source-inline">Assets/Scripts</strong> folder. This is an incredibly simple script that contains four functions that only write to the console. Hooking up these four functions to the individual directional Buttons won’t do anything fun, but it will allow us to see logs in the console that let us know the Buttons are performing as <span>they should.</span></li>
<li class="calibre14">Attach the script to the <strong class="source-inline">D-Pad </strong><span><strong class="source-inline">Background</strong></span><span> object.</span></li>
<li class="calibre14">Select each of the four directional Buttons and, with all of them selected, add an <strong class="bold">On Click ()</strong> Event to the <span><strong class="bold">Button</strong></span><span> component.</span></li>
<li class="calibre14">Now, drag the <strong class="source-inline">D-Pad Background</strong> object into the object slot of the <strong class="bold">On Click ()</strong> <span>Event.</span></li>
<li class="calibre14">Select each Button individually and assign the appropriate functions, <strong class="source-inline">PressUp</strong>, <strong class="source-inline">PressDown</strong>, <strong class="source-inline">PressLeft</strong>, and <strong class="source-inline">PressRight</strong>, to their <strong class="bold">On Click ()</strong> <span>Events.</span></li>
</ol>
<p class="calibre3">Playing the game and selecting the four directional Buttons should result in the appropriate message being displayed <a id="_idIndexMarker675" class="pcalibre pcalibre1 calibre6"/>on <span>the console.</span></p>
<p class="calibre3">Many D-Pads actually accept nine inputs: the four directs, the four diagonals (corners), and the center. If you want to accept diagonal inputs as well as a center-click for your D-Pad, I’d suggest using a grid layout group to evenly space your <span>nine Buttons.</span></p>
<p class="calibre3">Since D-Pads tend to allow press-and-hold, you may want to combine the process used in this example with actions similar to those described in the previous example. Instead of using the <strong class="bold">On Click ()</strong> Event, you could set up an Event Trigger for using the <strong class="source-inline">OnPointerDown</strong> and <strong class="source-inline">OnPointerUp</strong> Events. These Events could then set a Boolean variable to <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>. For example, on the <strong class="source-inline">Right</strong> Button, you could have the <strong class="source-inline">OnPointerDown</strong> Event set a variable called <strong class="source-inline">moveRight</strong> to <strong class="source-inline">true</strong> and the <strong class="source-inline">OnPointerUp</strong> Event set <strong class="source-inline">moveRight</strong> <span>to </span><span><strong class="source-inline">false</strong></span><span>.</span></p>
<h2 id="_idParaDest-205" class="calibre7"><a id="_idTextAnchor324" class="pcalibre pcalibre1 calibre6"/>Creating a floating eight-directional virtual analog stick</h2>
<p class="calibre3">In this example, we will create a floating eight-directional <a id="_idIndexMarker676" class="pcalibre pcalibre1 calibre6"/>virtual analog stick. First, we will create an eight-directional D-Pad that simulates a control stick that moves in the direction the <span>player drags:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer393">
<img alt="Figure 11.38: The positions of the floating analog stick" src="image/B18327_11_38.jpg" class="calibre388"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.38: The positions of the floating analog stick</p>
<p class="calibre3">Then, we will expand the eight-directional D-Pad so that it is floating, which means it will not be visible in the scene until the player presses somewhere in the screen. Then, it will appear where the player’s<a id="_idIndexMarker677" class="pcalibre pcalibre1 calibre6"/> thumb is located and perform the eight-direction movement based on the player’s <span>thumb<a id="_idTextAnchor325" class="pcalibre pcalibre1 calibre6"/> dragging.</span></p>
<p class="calibre3">Setting up the eight-directional virtual <span>analog stick</span></p>
<p class="calibre3">To create an analog stick that moves in eight<a id="_idIndexMarker678" class="pcalibre pcalibre1 calibre6"/> directions, as shown in the previous figure, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Create a new scene named <strong class="source-inline">Chapter11-Examples-Buttons3</strong> in the <strong class="source-inline">Assets/Scenes</strong> folder and open the <span>new scene.</span></li>
<li class="calibre14">Create a new Image with <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Image</strong>. Name the new Image <span><strong class="source-inline">Stick Base</strong></span><span>.</span></li>
<li class="calibre14">Add the <strong class="source-inline">dPadButtons_15</strong> sprite to the <strong class="bold">Source Image</strong> slot of its <span><strong class="bold">Image</strong></span><span> component.</span></li>
<li class="calibre14">Resize it so that it has a <strong class="bold">Width</strong> and <strong class="bold">Height</strong> of <strong class="source-inline">200</strong> and give it a <strong class="bold">Pos X</strong> and <strong class="bold">Pos Y</strong> <span>of </span><span><strong class="source-inline">0</strong></span><span>.</span></li>
<li class="calibre14">Right-click <strong class="source-inline">Stick Base</strong> in the Hierarchy and select <strong class="bold">UI</strong> | <strong class="bold">Image</strong> to add an <strong class="source-inline">Image</strong> child to the <strong class="source-inline">Stick Base</strong>. Name the <span>child </span><span><strong class="source-inline">Stick</strong></span><span>.</span></li>
<li class="calibre14">Resize the <strong class="source-inline">Stick</strong> Image to match the <strong class="source-inline">Stick Base</strong> by setting its <strong class="bold">Rect Transform</strong> stretch and anchor to stretch fully across <span>both directions.</span></li>
<li class="calibre14">Add the <strong class="source-inline">dPadButtons_0</strong> sprite to the <strong class="bold">Source Image</strong> slot of the <strong class="source-inline">Stick</strong> <span>Image component.</span></li>
<li class="calibre14">Set the <strong class="bold">Left</strong>, <strong class="bold">Top</strong>, <strong class="bold">Right</strong>, and <strong class="bold">Bottom</strong> properties of the <strong class="bold">Rect Transform</strong> component all to <strong class="source-inline">10</strong> to give some padding around the edges of <span>the </span><span><strong class="source-inline">Stick</strong></span><span>.</span></li>
<li class="calibre14">Now, set the pivot and <a id="_idIndexMarker679" class="pcalibre pcalibre1 calibre6"/>position to <strong class="bold">middle center</strong>. This is an important step! Without doing this, the <strong class="source-inline">Stick</strong> will not move around appropriately on the <span><strong class="source-inline">Stick Base</strong></span><span>.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer394">
<img alt="Figure 11.39: The Rect Transform component of the Stick" src="image/B18327_11_39.jpg" class="calibre389"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.39: The Rect Transform component of the Stick</p>
<ol class="calibre13">
<li value="10" class="calibre14">That’s all there is for the setup to get our virtual analog stick working. We’ll just leave it in the center of the screen for now. Now, we need to write some code. Create a new script in the <strong class="source-inline">Assets/Script</strong> folder and name <span>it </span><span><strong class="source-inline">FloatingAnalogStick</strong></span><span>.</span></li>
<li class="calibre14">Add the <strong class="source-inline">UnityEngine.UI</strong> namespace to the top of the script with <span>the following:</span><pre class="source-code">
using UnityEngine.UI;</pre></li> <li class="calibre14">To make the stick wiggle<a id="_idIndexMarker680" class="pcalibre pcalibre1 calibre6"/> around on top of the base, we need the <span>following variables:</span><pre class="source-code">
[SerializeField] private RectTransform theStick;
private Vector2 mouseStartPosition;
private Vector2 mouseCurrentPosition;
[SerializeField] private int dragPadding = 30;</pre><p class="calibre3">The first three variables should be pretty self-explanatory. The <strong class="source-inline">dragPadding</strong> variable will be used to determine how far the player has to drag the stick before it actually registers as <span>being moved.</span></p></li> <li class="calibre14">Before we write the code that checks how far the player has dragged their finger, let’s add a few dummy functions that would allow this analog stick to actually control something in the future. Add the following functions to <span>your script:</span><pre class="source-code">
public void MovingLeft()
{
    Debug.Log("move left");
}
public void MovingRight()
{
    Debug.Log("move right");
}
public void MovingUp()
{
    Debug.Log("move up");
}
public void MovingDown()
{
    Debug.Log("move down");
}</pre></li> <li class="calibre14">The <strong class="source-inline">Stick</strong> will move outward when the player moves their finger from their starting finger-down position. So, let’s create a function that will find the starting position when the player begins dragging their finger. Add the following function to <span>your script:</span><pre class="source-code">
public void StartDrag()
{
    mouseStartPosition = Input.mousePosition;
}</pre><p class="calibre3">Remember—when working with a touchscreen, <strong class="source-inline">Input.mousePosition </strong>will give the value of the <span>touch position.</span></p></li> <li class="calibre14">Now, let’s create a function that checks how far the player has dragged their finger and moves the <strong class="source-inline">Stick</strong> based on that information. Add the following function to <span>your script:</span><pre class="source-code">
public void Dragging()
{
    float xPos;
    float yPos;
    mouseCurrentPosition = Input.mousePosition;
    if (mouseCurrentPosition.x &lt; mouseStartPosition.x - dragPadding)
    {
        MovingLeft();
        xPos = -10;
    }
    else if (mouseCurrentPosition.x &gt; mouseStartPosition.x + dragPadding)
    {
        MovingRight();
        xPos = 10;
    }
    else
    {
        xPos = 0;
    }
    if (mouseCurrentPosition.y &gt; mouseStartPosition.y + dragPadding)
    {
        MovingUp();
        yPos = 10;
    }
    else if (mouseCurrentPosition.y &lt; mouseStartPosition.y - dragPadding)
    {
        MovingDown();
        yPos = -10;
    }
    else
    {
        yPos = 0;
    }
    theStick.anchoredPosition = new Vector2(xPos, yPos);
}</pre></li> <li class="calibre14">The last piece we need to add is something that will reset the stick to its original position once the player <a id="_idIndexMarker681" class="pcalibre pcalibre1 calibre6"/>stops dragging or lifts up their finger. Add the following function to your script to <span>do so:</span><pre class="source-code">
public void StoppedDrag()
{
    theStick.anchoredPosition = Vector2.zero;
}</pre></li> <li class="calibre14">Now, we need to hook this script and these functions to the items within the scene. Add the <strong class="source-inline">FloatingAnalogStick</strong> script to the <strong class="source-inline">Stick </strong><span><strong class="source-inline">Base</strong></span><span> Image.</span></li>
<li class="calibre14">Add the <strong class="source-inline">Stick</strong> Image to the <strong class="bold">Stick</strong> property in the <strong class="bold">Floating Analog </strong><span><strong class="bold">Stick</strong></span><span> component.</span></li>
<li class="calibre14">Add an <strong class="bold">Event Trigger</strong> component to the <strong class="source-inline">Stick Base</strong> object with <strong class="bold">Add Component</strong> | <strong class="bold">Events</strong> | <strong class="bold">Event Trigger</strong>. This will allow the user to use Event Types other than <span><strong class="bold">On Click()</strong></span><span>.</span></li>
<li class="calibre14">Add the <strong class="bold">Begin Drag</strong>, <strong class="bold">Drag</strong>, and <strong class="bold">End Drag</strong> Event Types with the <strong class="bold">Add New Event </strong><span><strong class="bold">Type</strong></span><span> button.</span></li>
<li class="calibre14">Add the appropriate functions on the <strong class="source-inline">FloatingAnalogStick</strong> script attached to the <strong class="source-inline">Stick Base</strong> to <span>the Events:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer395">
<img alt="Figure 11.40: The Event Trigger component" src="image/B18327_11_40.jpg" class="calibre390"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.40: The Event Trigger component</p>
<p class="calibre3">If you play the game now, you should see the eight-directional analog stick responding appropriately. Clicking on it and<a id="_idIndexMarker682" class="pcalibre pcalibre1 calibre6"/> dragging in any direction will cause the stick to move in the direction<a id="_idTextAnchor326" class="pcalibre pcalibre1 calibre6"/> of <span>the drag.</span></p>
<h3 class="calibre9">Making the eight-directional virtual analog stick float</h3>
<p class="calibre3">If all you want is an eight-directional analog stick, you’re good to go! But if you want the analog stick to float—appear where the players press on the screen and disappear when they lift their finger—you have to do a little bit <span>more work.</span></p>
<p class="calibre3">To make the analog stick appear <a id="_idIndexMarker683" class="pcalibre pcalibre1 calibre6"/>where the player clicks, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">First, we need to create an area where the player will click to bring up the analog stick. Right-click <strong class="source-inline">Canvas</strong> in the Hierarchy and select <strong class="bold">UI</strong> | <strong class="bold">Button</strong> to add a <strong class="source-inline">Button</strong> child to the <strong class="source-inline">Canvas</strong>. Rename the <strong class="source-inline">Button</strong> child <span><strong class="source-inline">Click Area</strong></span><span>.</span></li>
<li class="calibre14">Remove the <strong class="source-inline">Text</strong> child object from the <span><strong class="source-inline">Click Area</strong></span><span>.</span></li>
<li class="calibre14">Stretch the <strong class="source-inline">Click Area</strong> to fill the <span>whole </span><span><strong class="source-inline">Canvas</strong></span><span>.</span></li>
<li class="calibre14">Add some padding to the sides of <strong class="source-inline">Click Area</strong> by changing the <strong class="bold">Left</strong>, <strong class="bold">Top</strong>, <strong class="bold">Right</strong>, and <strong class="bold">Bottom</strong> properties on the <strong class="bold">Rect Transform</strong> component to <strong class="source-inline">50</strong>. I have added this padding so that the player cannot click on the very edge of the screen and have the analog stick appear <span>mostly off-screen.</span></li>
<li class="calibre14">In the Hierarchy, move <strong class="source-inline">Click Area</strong> so that it is above <strong class="source-inline">Stick Base</strong>. Now, <strong class="source-inline">Click Area</strong> will render<a id="_idIndexMarker684" class="pcalibre pcalibre1 calibre6"/> behind the <span>analog stick:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer396">
<img alt="Figure 11.41: The Hierarchy showing Click Area and Stick Base" src="image/B18327_11_41.jpg" class="calibre391"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.41: The Hierarchy showing Click Area and Stick Base</p>
<ol class="calibre13">
<li value="6" class="calibre14">Open up your <strong class="source-inline">FloatingAnalogStick</strong> code so that we can add some functionality <span>to it.</span></li>
<li class="calibre14">To make the position of our analog stick more easily hook to the position of the mouse on the screen, we should move our stick base so that it is centered at the lower-left corner of the <strong class="source-inline">Canvas</strong>. Set the anchor and position to the <strong class="bold">bottom left</strong> <span>anchor preset.</span></li>
<li class="calibre14">Now, set the <strong class="bold">X</strong> and <strong class="bold">Y</strong> <strong class="bold">Pivot</strong> properties <span>to </span><span><strong class="source-inline">0.5</strong></span><span>.</span></li>
<li class="calibre14">Set the <strong class="bold">Pos X</strong> and <strong class="bold">Pos Y</strong> properties to <strong class="source-inline">0</strong>. This should place the analog stick at the lower-left corner of the Canvas (or screen) with its pivot point set to <span>its center:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer397">
<img alt="Figure 11.42: The Hierarchy showing Click Area and Stick Base" src="image/B18327_11_42.jpg" class="calibre392"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.42: The Hierarchy showing Click Area and Stick Base</p>
<ol class="calibre13">
<li value="10" class="calibre14">We need two more variables now to get the analog stick to appear where we want it to in the scene. Add <a id="_idIndexMarker685" class="pcalibre pcalibre1 calibre6"/>the following variable to your script to assign the stick and track if it has <span>been added:</span><pre class="source-code">
[SerializeField] private RectTransform theBase;
[SerializeField] private bool stickAdded = false;</pre></li> <li class="calibre14">Now, create the following function to add the stick to <span>the scene:</span><pre class="source-code">
public void AddTheStick()
{
    theBase.anchoredPosition = Input.mousePosition;
    theStick.anchoredPosition = Vector2.zero;
    mouseStartPosition = Input.mousePosition;
    stickAdded = true;
}</pre></li> <li class="calibre14">Add the following <strong class="source-inline">Update()</strong> function to determine when the stick <span>will appear:</span><pre class="source-code">
void Update()
{
    if (stickAdded == true)
    {
        Dragging();
        if (Input.GetMouseButtonUp(0))
        {
            // ToggleBaseCanvasGroup(false);  // This line is commented out as ToggleBaseCanvasGroup is not defined in the provided code
            stickAdded = false;
            StoppedDrag();
        }
    }
}</pre></li> <li class="calibre14">Add <strong class="source-inline">Stick Base</strong> to the <strong class="bold">The </strong><span><strong class="bold">Base</strong></span><span> slot:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer398">
<img alt="Figure 11.43: The Floating Analog Stick component" src="image/B18327_11_43.jpg" class="calibre393"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.43: The Floating Analog Stick component</p>
<ol class="calibre13">
<li value="14" class="calibre14">Add the <strong class="bold">Event Trigger</strong> component <a id="_idIndexMarker686" class="pcalibre pcalibre1 calibre6"/>to the <span><strong class="source-inline">Click Area</strong></span><span>.</span></li>
<li class="calibre14">Add the following <strong class="bold">Pointer Down</strong> Event to the <span><strong class="source-inline">Click Area</strong></span><span>:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer399">
<img alt="Figure 11.44: The Event Trigger component" src="image/B18327_11_44.jpg" class="calibre394"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.44: The Event Trigger component</p>
<p class="calibre3">Playing the game now will have the analog stick appear where you click and move around with <span>your dragging.</span></p></li>
</ol>
<ol class="calibre13">
<li value="16" class="calibre14">Now, let’s make it so that the analog stick is only visible when the player is touching the screen. Add a <strong class="bold">Canvas Group</strong> component to <span><strong class="source-inline">Stick Base</strong></span><span>.</span></li>
<li class="calibre14">Set <strong class="bold">Alpha</strong> to <strong class="source-inline">0</strong>, <strong class="bold">Interactable</strong> to <strong class="source-inline">false</strong>, and <strong class="bold">Blocks Raycast</strong> <span>to </span><span><strong class="source-inline">false</strong></span><span>.</span></li>
<li class="calibre14">Add the following variable to your <strong class="source-inline">FloatingAnalogStick</strong> script to keep track of <span>the </span><span><strong class="source-inline">CanvasGroup</strong></span><span>:</span><pre class="source-code">
private CanvasGroup theBaseVisibility;</pre></li> <li class="calibre14">Add the following <strong class="source-inline">Awake()</strong> function to initialize the <span><strong class="source-inline">theBaseVisibility</strong></span><span> variable:</span><pre class="source-code">
void Awake()
{
    theBaseVisibility = theBase.GetComponent&lt;CanvasGroup&gt;();
}</pre></li> <li class="calibre14">Create a new function called <strong class="source-inline">ToggleBaseCanvasGroup()</strong> to toggle the <strong class="source-inline">CanvasGroup</strong>’s properties on <span>and off:</span><pre class="source-code">
public void ToggleBaseCanvasGroup(bool visible)
{
    theBaseVisibility.alpha = Convert.ToInt32(visible);
    theBaseVisibility.interactable = visible;
    theBaseVisibility.blocksRaycasts = visible;
}</pre></li> <li class="calibre14">Add the following<a id="_idIndexMarker687" class="pcalibre pcalibre1 calibre6"/> to the <strong class="source-inline">AddTheStick()</strong> function to turn on <span>the </span><span><strong class="source-inline">CanvasGroup</strong></span><span>:</span><pre class="source-code">
ToggleBaseCanvasGroup(true);</pre></li> <li class="calibre14">Add the following to the innermost <strong class="source-inline">if</strong> statement within the <strong class="source-inline">Update()</strong> function to turn off <span>the </span><span><strong class="source-inline">CanvasGroup</strong></span><span>:</span><pre class="source-code">
ToggleBaseCanvasGroup(false);</pre></li> </ol>
<p class="calibre3">Now, the analog stick will appear when the player presses down, move in the direction of their finger, and disappear when the player lifts <span>their finger.</span></p>
<h1 id="_idParaDest-206" class="calibre5"><a id="_idTextAnchor327" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
<p class="calibre3">UI Images are one of the core components of the Unity UI system and manipulating them is essential to creating visually interactive user interfaces. This chapter culminated all the skills we have learned in the preceding chapters by letting us create interesting interfaces that utilized Events, Buttons, <span>and Images.</span></p>
<p class="calibre3">In the next chapter, we’ll look at how to create masks and scroll views so that we can hold even more child objects within our <span>Panel containers.</span></p>
</div>
</div></body></html>