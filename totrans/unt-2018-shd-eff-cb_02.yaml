- en: Creating Your First Shader
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个着色器
- en: 'In this chapter, you will learn about the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下配方：
- en: Creating a basic Standard Shader
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的标准着色器
- en: Adding properties to a shader
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向着色器添加属性
- en: Using properties in a Surface Shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表面着色器中使用属性
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will cover some of the more common diffuse techniques found in
    today's game development shading pipelines. Let's imagine a cube that has been
    painted white uniformly in a 3D environment with a directional light. Even if
    the color used is the same on each face, they will all have different shades of
    white on them depending on the direction that the light is coming from and the
    angle that we are looking at it from. This extra level of realism is achieved
    in 3D graphics through the use of shaders, special programs that are mostly used
    to simulate how light works. A wooden cube and a metal one may share the same
    3D model, but what makes them look different is the shader that they use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍当今游戏开发着色器管道中的一些更常见的漫反射技术。让我们想象一个在3D环境中被均匀涂成白色的立方体。即使使用的颜色在每个面上都相同，但由于光线来的方向和观察的角度不同，它们都会呈现出不同的白色阴影。通过使用着色器，这种额外的真实感在3D图形中得以实现，着色器是主要用于模拟光线工作的特殊程序。一个木制立方体和一个金属立方体可能共享相同的3D模型，但使它们看起来不同的正是它们使用的着色器。
- en: This first chapter will introduce you to shader coding in Unity. If you have
    little to no previous experience with shaders, this chapter is what you need in
    order to understand what shaders are, how they work, and how to customize them.
    By the end of this chapter, you will have learned how to build basic shaders that
    perform basic operations. Armed with this knowledge, you will be able to create
    just about any Surface Shader.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍Unity中的着色器编程。如果你对着色器几乎没有或没有先前的经验，那么这一章就是你需要的，以便了解着色器是什么，它们是如何工作的，以及如何自定义它们。到本章结束时，你将学会如何构建执行基本操作的基本着色器。掌握了这些知识，你将能够创建几乎任何表面着色器。
- en: Creating a basic Standard Shader
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的标准着色器
- en: In Unity, when we create a game object, we then attach additional functionality
    through the use of **components**. In fact, every game object is required to have
    a Transform component; there are a number of components included in Unity already,
    and we create components of our own when we write scripts that extend from `MonoBehaviour`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，当我们创建一个游戏对象时，我们通过使用**组件**来附加额外的功能。实际上，每个游戏对象都需要有一个变换组件；Unity已经包含了一些组件，当我们编写扩展自`MonoBehaviour`的脚本时，我们创建自己的组件。
- en: 'All the objects that are part of a game contain a number of components that
    affect their look and behavior. While scripts determine how objects should behave,
    renderers decide how they should appear on the screen. Unity comes with several
    renderers, depending on the type of object that we are trying to visualize; every
    3D model typically has a `MeshRenderer` component attached to it. An object should
    have only one renderer, but the renderer itself can contain several materials.
    Each material is a wrapper for a single shader, the final ring in the food chain
    of 3D graphics. The relationships between these components can be seen in the
    following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于游戏的对象都包含一些影响其外观和行为的组件。虽然脚本决定了对象应该如何行为，但渲染器决定了它们应该在屏幕上如何显示。Unity提供了多种渲染器，具体取决于我们试图可视化的对象类型；每个3D模型通常都附有一个`MeshRenderer`组件。一个对象应该只有一个渲染器，但渲染器本身可以包含多个材质。每个材质都是一个单一着色器的包装，是3D图形链中的最后一环。这些组件之间的关系可以在以下图中看到：
- en: '![](img/00028.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Understanding the difference between these components is essential for understanding
    how shaders work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些组件之间的区别对于理解着色器的工作方式至关重要。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, you will need to have Unity running and must
    have a project opened. As mentioned before, there will also be a Unity project
    included with this cookbook, so you can use that one as well and simply add your
    own custom shaders to it as you step through each recipe. With this completed,
    you are now ready to step into the wonderful world of real-time shading!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个配方，你需要运行Unity并打开一个项目。如前所述，这个食谱中还将包含一个Unity项目，因此你也可以使用那个项目，并且只需在逐步执行每个配方时添加你自己的自定义着色器即可。完成这些后，你现在就可以进入实时着色的奇妙世界了！
- en: 'Before getting into our first shader, let''s create a small scene for us to
    work with:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始第一个着色器之前，让我们创建一个小的场景供我们使用：
- en: Let's create a scene by navigating to File | New Scene.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you create the scene, create a plane to act as the ground by going to GameObject | 3D
    Objects | Plane in the Unity editor. Next, select the object in the Hierarchy tab
    and then go into the Inspector tab. From there, right-click on the Transform component
    and select the Reset Position option:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'This will reset the position property of the object to be at `0`, `0`, `0`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to see what our shaders will look like when applied, let''s
    add some shapes to visualize what each of our shaders will do. Create a sphere
    by going to GameObject | 3D Objects | Sphere. Once created, select it and go to
    the Inspector tab. Next, change the Position to `0`, `1`, `0` so it is above the
    origin of the world (which is at `0`, `0`, `0`) and our previously created plane:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Once this sphere is created, create two more spheres, placing them to the left
    and right of the spheres at positions `-2`, `1`, `0` and `2`, `1`, `0` respectively:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Lastly, confirm that you have a directional light (it should be seen in the
    Hierarchy tab). If not, you can add one by selecting GameObject | Light | Directional
    Light to make it easier to see the effect of your changes and how your shaders
    react to light.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using the Unity project that came with the cookbook, you can open
    up the `Chapter 2` | `Starting Point` scene instead as it has been set up already.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our scene generated, we can move on to the shader writing steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: In the Project tab in your Unity editor, right-click on the `Chapter 2` folder
    and select Create | Folder.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the folder that you created as `Shaders` by right-clicking on it and
    selecting Rename from the drop-down list, or by selecting the folder and hitting
    *F2* on the keyboard.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another folder and rename it as `Materials`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Shaders` folder and select Create | Shader | Standard Surface
    Shader. Then, right-click on the `Materials` folder and select Create | Material.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename both the shader and material as `StandardDiffuse`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the `StandardDiffuse` shader by double-clicking on the file. This will
    automatically launch a scripting editor for you and display the shader's code.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that Unity has already populated our shader with some basic code.
    This, by default, will get you a basic shader that accepts one texture in the
    Albedo (RGB) property. We will be modifying this base code so that you can learn
    how to quickly start developing your own custom shaders.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s give our shader a custom folder from which it''s selected. The very
    first line of code in the shader is the custom description that we have to give
    the shader so that Unity can make it available in the shader drop-down list when
    assigning to materials. We have renamed our path as `Shader "CookbookShaders/StandardDiffuse"`,
    but you can name it whatever you want and rename it at any time so don''t worry
    about any dependencies at this point. Save the shader in your script editor and
    return to the Unity editor. Unity will automatically compile the shader when it
    recognizes that the file has been updated. This is what your shader should look
    like at this point:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的着色器创建一个自定义文件夹，以便从中选择。着色器中的第一行代码是我们必须提供给着色器的自定义描述，这样Unity才能在将着色器分配给材质时在着色器下拉列表中使其可用。我们已经将路径重命名为`Shader
    "CookbookShaders/StandardDiffuse"`，但您可以将其命名为任何您想要的名称，并且可以在任何时候重命名，所以请放心，目前不需要担心任何依赖关系。在脚本编辑器中保存着色器，并返回到Unity编辑器。当Unity识别到文件已更新时，它将自动编译着色器。此时您的着色器应该看起来是这样的：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Technically speaking, this is a Surface Shader based on **physically-based rendering** (**PBR**).
    As the name suggests, this type of shader achieves realism by simulating how light
    physically behaves when hitting objects.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从技术角度讲，这是一个基于**基于物理的渲染**（**PBR**）的表面着色器。正如其名所示，这种类型的着色器通过模拟光线击中物体时的物理行为来实现逼真效果。
- en: After your shader is created, we need to connect it to a material. Select the
    material called `StandardDiffuse` that we created in *step 4* and look at the
    Inspector tab. From the Shader drop-down list, select CookbookShaders | StandardDiffuse.
    (Your shader path might be different if you chose to use a different path name.)
    This will assign your shader to your material and make it ready for you to assign
    to an object.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的着色器创建后，我们需要将其连接到材质。选择我们在*步骤4*中创建的名为`StandardDiffuse`的材质，并查看“检查器”标签页。从“着色器”下拉列表中选择CookbookShaders
    | StandardDiffuse。（如果选择了不同的路径名称，您的着色器路径可能不同。）这将把您的着色器分配给您的材质，并使其准备好分配给对象。
- en: To assign material to an object, you can simply click and drag your material
    from the Project tab to the object in your scene. You can also drag material to
    the Inspector tab of an object in the Unity editor in order to assign it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将材质分配给对象，您只需简单地从“项目”标签页点击并拖动您的材质到场景中的对象即可。您还可以将材质拖动到Unity编辑器中对象的“检查器”标签页，以便分配它。
- en: 'The screenshot of an example is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例截图：
- en: '![](img/00032.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: Not much to look at at this point, but our shader development environment is
    set up and we can now start to modify the shader to suit our needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前看起来没有什么可看的，但我们的着色器开发环境已经设置好了，我们现在可以开始修改着色器以满足我们的需求。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unity has made the task of getting your shader environment up and running very
    easy for you. It is simply a matter of a few clicks and you are good to go. There
    are a lot of elements working in the background with regard to the Surface Shader
    itself. Unity has taken the Cg shader language and made it more efficient to write
    by doing a lot of the heavy Cg code lifting for you. The Surface Shader language
    is a more component-based way of writing shaders. Tasks such as processing your
    own texture coordinates and transformation matrices have already been done for
    you, so you don't have to start from scratch any more. In the past, we would have
    to start a new shader and rewrite a lot of code over and over again. As you gain
    more experience with Surface Shaders, you will naturally want to explore more
    of the underlying functions of the Cg language and how Unity is processing all
    of the low-level **graphics** **processing unit** (**GPU**) tasks for you.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unity已经使您设置着色器环境的工作变得非常简单。这只是一个点击几个按钮的问题，然后您就可以开始了。在表面着色器本身方面，有很多元素在后台工作。Unity已经对Cg着色器语言进行了优化，以便您更高效地编写，通过为您执行大量的重Cg代码。表面着色器语言是一种更基于组件的编写着色器的方法。处理自己的纹理坐标和变换矩阵等任务已经为您完成，因此您不必从头开始。在过去，我们不得不创建一个新的着色器并反复重写大量代码。随着您在表面着色器方面经验的增加，您自然会想要探索Cg语言的更多底层功能以及Unity是如何为您处理所有底层**图形**
    **处理单元**（**GPU**）任务的。
- en: All the files in a Unity project are referenced independently from the folder
    that they are in. We can move shaders and materials from within the editor without
    the risk of breaking any connection. Files, however, should never be moved from
    outside the editor as Unity will not be able to update their references.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Unity项目中的所有文件都是独立于它们所在的文件夹进行引用的。我们可以在编辑器内部移动着色器和材质，而不用担心破坏任何连接。然而，文件永远不应该从编辑器外部移动，因为Unity将无法更新它们的引用。
- en: So, by simply changing the shader's path name to a name of our choice, we have
    got our basic diffuse shader working in the Unity environment, with lights and
    shadows and all that, just by changing one line of code!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需将着色器的路径名称更改为我们选择的名称，我们就在Unity环境中实现了基本漫反射着色器，包括灯光和阴影等，只需更改一行代码即可！
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The source code of the built-in shaders is typically hidden in Unity. You cannot
    open this from the editor as you do with your own shaders. For more information
    on where to find a large portion of the built-in Cg functions for Unity, go to
    your Unity install directory and navigate to the `Editor` | `Data` | `CGIncludes` folder:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内置着色器的源代码通常在Unity中是隐藏的。你不能像处理自己的着色器那样从编辑器中打开它。有关查找大量内置Cg函数的信息，请转到你的Unity安装目录，并导航到`Editor`
    | `Data` | `CGIncludes`文件夹：
- en: '![](img/00033.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: 'In this folder, you can find the source code of the shaders shipped with Unity.
    Over time, they have changed a lot; you can visit the** Unity download archive**
    ([https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive))
    if you need to access the source codes of a shader used in a different version
    of Unity. After choosing the right version, select Built in shaders from the drop-down
    list, as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，你可以找到Unity附带着色器的源代码。随着时间的推移，它们已经发生了很大变化；如果你需要访问不同版本的Unity中使用的着色器的源代码，请访问**Unity下载存档**([https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive))。选择正确的版本后，从下拉列表中选择内置着色器，如图下所示：
- en: '![](img/00034.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: There are three files that are of note at this point: `UnityCG.cginc`,  `Lighting.cginc`,
    and `UnityShaderVariables.cginc`. Our current shader is making use of all these
    files at the moment. In [Chapter 11](part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08),
    *Advanced Shading Techniques*, we will explore in depth how to use CGInclude for
    a modular approach to shader coding.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有三个文件值得关注：`UnityCG.cginc`、`Lighting.cginc` 和 `UnityShaderVariables.cginc`。我们当前的着色器正在使用所有这些文件。在[第11章](part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08)，“高级着色技术”中，我们将深入探讨如何使用
    CGInclude 以模块化方式编写着色器代码。
- en: Adding properties to a shader
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向着色器添加属性
- en: Properties of a shader are very important for the shader pipeline as they are
    the method that you use to let the artist or user of the shader assign textures
    and tweak your shader values. Properties allow you to expose GUI elements in a
    material's Inspector tab without you having to use a separate editor, which provides
    visual ways to tweak a shader. With your shader opened in your IDE of choice,
    look at the block of lines two through seven. This is called the `Properties`
    block of the script. Currently, it will have one texture property in it called
    `_MainTex`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的属性对于着色器管道非常重要，因为它们是艺术家或着色器用户用来分配纹理和调整着色器值的方法。属性允许你在材质的检查器标签页中暴露GUI元素，而无需使用单独的编辑器，这提供了调整着色器的视觉方式。在你的IDE中打开着色器，查看第二行到第七行的代码块。这被称为脚本的`Properties`块。目前，它将包含一个名为`_MainTex`的纹理属性。
- en: If you look at your material that has this shader applied to it, you will notice
    that there is one **texture** GUI element in the Inspector tab. These lines of
    code in our shader are creating this GUI element for us. Again, Unity has made
    this process very efficient in terms of coding and the amount of time it takes
    to iterate through changing your properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看应用了此着色器的材质，你会在检查器标签页中注意到有一个**纹理**GUI元素。我们着色器中的这些代码行正在为我们创建这个GUI元素。再次强调，Unity
    在编码效率和迭代更改属性所需的时间方面使这个过程非常高效。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's see how this works in our current shader called `StandardDiffuse` by creating
    our own properties and learning more about the syntax involved. For this example,
    we will refit the shader previously created. Instead of using a texture, it will
    only use its color and some other properties that we will be able to change directly
    from the Inspector tab. Start by duplicating the `StandardDiffuse` shader. You
    can do this by selecting it in the Inspector tab and pressing *Ctrl *+ *D*. This
    will create a copy called `StandardDiffuse 1`. Go ahead and rename it as `StandardColor`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: You can give a friendlier name to your shader in its first line. For instance,
    `Shader "CookbookShaders/StandardDiffuse"` tells Unity to call this shader `StandardDiffuse` and
    move it to a group called `CookbookShaders`. If you duplicate a shader using *Ctrl *+ *D*,
    your new file will share the same name. To avoid confusion, make sure to change
    the first line of each new shader so that it uses a unique alias in this and future
    recipes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the `StandardColor` shader is ready, we can start changing its properties:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line of the script, update the name to the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Downloading the example code
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com/). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support) and
    register to have the files emailed directly to you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Properties` block of our shader, remove the current property by deleting
    the following code from our current shader:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we have removed an essential property, this shader will not compile until
    the other references to `_MainTex` are removed. Let''s remove this other line
    inside of the `SubShader` section:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The original shader used `_MainTex` to color the model. Let''s change this
    by replacing the first line of code of the `surf()` function with this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just as you may be used to the `float` type being used for floating point values
    when writing code in C# and other programming languages, `fixed` is used for fixed-point
    values and is the type used when writing shaders. You may also see the `half`
    type used as well, which is like the `float` type but takes up half the space.
    This is useful for saving memory but is less precise in how it is presented. We
    will be discussing this in much greater detail in the *Techniques to make shaders
    more efficient* recipe in [Chapter 8](part0212.html#6A5N80-e8c76c858d514bc3b1668fda96f8fa08),
    *Mobile Shader Adjustment*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: For more information on fixed-point values, check out [https://en.wikipedia.org/wiki/Fixed-point_arithmetic](https://en.wikipedia.org/wiki/Fixed-point_arithmetic).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The `4`  in `fixed4` stands for the fact that the color is a single variable
    that contains four `fixed` values: red, green, blue, and alpha. You will learn
    more about how this works and how to modify these values in more detail in the
    next chapter, [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed4`中的`4`表示颜色是一个包含四个`fixed`值的单个变量：红色、绿色、蓝色和alpha。你将在下一章中了解更多关于它是如何工作的以及如何更详细地修改这些值的信息，[第3章](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08)，*表面着色器和纹理映射*。'
- en: 'When you save and return to Unity, the shader will compile, and you will see
    that now our material''s Inspector tab doesn''t have a texture swatch any more.
    To complete the refit of this shader, let''s add one more property to the `Properties`
    block and see what happens. Enter the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你保存并返回Unity时，着色器将进行编译，你会看到现在我们的材质的“检查器”标签中不再有纹理样本。为了完成这个着色器的重新配置，让我们在`属性`块中添加一个额外的属性并看看会发生什么。输入以下代码：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have added another color swatch to the material''s Inspector tab. Now let''s
    add one more in order to get a feel for other kinds of properties that we can
    create. Add the following code to the `Properties` block:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在材质的“检查器”标签中添加了另一个颜色样本。现在让我们再添加一个，以便感受我们可以创建的其他类型的属性。将以下代码添加到`属性`块中：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have now created another GUI element that allows us to visually interact
    with our shader. This time, we created a slider with the name This is a Slider,
    as shown in the following screenshot:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在创建了一个另一个GUI元素，允许我们以视觉方式与我们的着色器交互。这次，我们创建了一个名为This is a Slider的滑块，如下面的截图所示：
- en: '![](img/00035.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: Properties allow you to create a visual way to tweak shaders without having
    to change values in the shader code itself. The next recipe will show you how
    these properties can actually be used to create a more interesting shader.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性允许你创建一种视觉方式来调整着色器，而无需更改着色器代码中的值。下一道菜谱将向你展示这些属性实际上是如何被用来创建一个更有趣的着色器的。
- en: While properties belong to shaders, the values associated with them are stored
    in materials. The same shader can be safely shared between many different materials.
    On the other hand, changing the property of a material will affect the look of
    all the objects that are currently using it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性属于着色器，但与它们关联的值存储在材质中。相同的着色器可以在许多不同的材质之间安全共享。另一方面，更改材质的属性将影响当前使用它的所有对象的外观。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Every Unity shader has a built-in structure that it is looking for in its code.
    The Properties block is one of those functions that are expected by Unity. The
    reason behind this is to give you, the shader programmer, a means of quickly creating
    GUI elements that tie directly into your shader code. These properties (variables)
    that you declare in the Properties block can then be used in your shader code
    to change values, colors, and textures. The syntax to define a property is as
    follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Unity着色器都在其代码中寻找一个内置的结构。`属性`块是Unity期望的函数之一。背后的原因是为了给你，着色器程序员，提供一种快速创建与着色器代码直接关联的GUI元素的方法。你可以在`属性`块中声明的这些属性（变量）然后可以在你的着色器代码中使用它们来更改值、颜色和纹理。定义属性的语法如下：
- en: '![](img/00036.gif)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.gif)'
- en: 'Let''s take a look at what is going on under the hood here. When you first
    start writing a new property, you will need to give it a **Variable Name**. The
    **Variable Name** is going to be the name that your shader code is going to use
    in order to get the value from the GUI element. This saves us a lot of time because
    we don''t have to set up this system ourselves. The next elements of a property
    are the **Inspector GUI Name** and **Type** of the property, which is contained
    within parentheses. The **Inspector GUI Name** is the name that is going to appear
    in the material''s Inspector tab when the user is interacting with and tweaking
    the shader. The **Type** is the type of data that this property is going to control.
    There are many types that we can define for properties inside of Unity shaders.
    The following table describes the types of variables that we can have in our shaders:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| **Surface Shader property types** | **Description** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `Range` (min, max) | This creates a `float` property as a slider from the
    minimum value to the maximum value |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `Color` | This creates a color swatch in the Inspector tab that opens up
    a `color picker = (float,float,float,float)` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `2D` | This creates a texture swatch that allows a user to drag a texture into
    the shader |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `Rect` | This creates a non-power of two texture swatch and functions the
    same as the `2D` GUI element |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| Cube | This creates a cube map swatch in the Inspector tab and allows a user
    to drag and drop a cube map into the shader |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| `float` | This creates a float value in the Inspector tab but without a slider
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| Vector | This creates a four-float property that allows you to create directions
    or colors |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: Finally, there is the **Default Value**. This simply sets the value of this
    property to the value that you place in the code. So, in the previous example
    diagram, the default value for the property named `_AmbientColor`, which is of
    the `Color` type, is set to a value of `1, 1, 1, 1`. As this is a `Color` property
    expecting a color that is `RGBA` or `float4` or `r, g, b, a = x, y, z, w`, this
    `Color` property, when first created, is set to white.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The properties are documented in the Unity manual at [http://docs.unity3d.com/Documentation/Components/SL-Properties.html](http://docs.unity3d.com/Documentation/Components/SL-Properties.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Using properties in a Surface Shader
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created some properties, let's actually hook them up to the
    shader so that we can use them as tweaks to our shader and make the material process
    much more interactive. We can use the Properties values from the material's Inspector
    tab because we have attached a variable name to the property itself, but in the
    shader code, you have to set up a couple of things before you can start calling
    the value by its variable name.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps show you how to use the properties in a Surface Shader:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from the previous example, let''s create another shader with the
    name `ParameterExample`. Just like before, remove the `_MainTex` property in the
    same manner as was done in the *Adding properties to a shader* recipe of this
    chapter:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个示例的基础上继续，让我们创建另一个名为 `ParameterExample` 的着色器。就像之前一样，以与本章中“向着色器添加属性”配方相同的方式移除
    `_MainTex` 属性：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Afterward, update the `Properties` section to the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将 `Properties` 部分更新为以下代码：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add the following lines of code to the shader, below the `CGPROGRAM`
    line:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `CGPROGRAM` 行下面添加以下代码行到着色器中：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With *step 3* complete, we can now use the values from the properties in our
    shader. Let''s do this by adding the value from the `_Color` property to the `_AmbientColor`
    property and giving the result of this to the `o.Albedo` line of code. So, let''s
    add the following code to the shader in the `surf()` function:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过完成**步骤 3**，我们现在可以使用着色器中的属性值了。让我们通过将 `_Color` 属性的值添加到 `_AmbientColor` 属性中，并将这个结果赋给
    `o.Albedo` 代码行来实现这一点。所以，让我们在 `surf()` 函数的着色器中添加以下代码：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, your shader should look like the following shader code. If you save
    your shader and re-enter Unity, your shader will compile. If there were no errors,
    you will now have the ability to change the ambient and emissive colors of the
    material as well as increase the saturation of the final color using the slider
    value. Pretty neat:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你的着色器应该看起来像以下着色器代码。如果你保存你的着色器并重新进入 Unity，你的着色器将会编译。如果没有错误，你现在将能够通过滑动条值来改变材质的环境光和自发光颜色，以及增加最终颜色的饱和度。非常方便：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `pow(arg1, arg2)` function is a built-in function that will perform the
    equivalent `math` function of power. So, argument `1` is the value that we want
    to raise to a power and argument `2` is the power that we want to raise it to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow(arg1, arg2)` 函数是一个内置函数，它将执行等价的 `math` 函数的幂运算。所以，参数 `1` 是我们想要提升到幂的值，而参数
    `2` 是我们想要提升到的幂。'
- en: To find out more about the `pow()` function, look at the Cg tutorial. It is
    a great free resource that you can use to learn more about shading and there is
    a glossary of all the functions available to you in the Cg shading language at [http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `pow()` 函数的信息，请查看 Cg 教程。这是一个非常好的免费资源，你可以用它来学习更多关于着色器的知识，并且有一个所有 Cg 着色语言中可用的函数的词汇表，可以在[http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html)找到。
- en: 'The following screenshot demonstrates the result obtained using our properties
    to control our material''s colors and saturation from within the material''s Inspector
    tab:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了使用我们的属性从材质的“检查器”标签中控制材质颜色和饱和度的结果：
- en: '![](img/00037.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you declare a new property in the `Properties` block, you are providing
    a way for the shader to retrieve the tweaked value from the material's Inspector
    tab. This value is stored in the variable name portion of the property. In this
    case, `_AmbientColor`, `_Color`, and `_MySliderValue` are the variables in which
    we are storing the tweaked values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `Properties` 块中声明一个新的属性时，你为着色器提供了一种从材质的“检查器”标签中检索调整值的方法。这个值存储在属性的变量名部分。在这种情况下，`_AmbientColor`、`_Color`
    和 `_MySliderValue` 是我们存储调整值的变量。
- en: In order for you to be able to use the value in the `SubShader` block, you need
    to create three new variables with the same names as the property's variable name.
    This automatically sets up a link between these two so that they know they have
    to work with the same data. Additionally, it declares the type of data that we
    want to store in our `SubShader` variables, which will come in handy when we look
    at optimizing shaders in a later chapter. Once you have created the `SubShader`
    variables, you can then use the values in the `surf()` function. In this case,
    we want to add the `_Color` and `_AmbientColor` variables together and take it
    to a power of whatever the `_MySliderValue` variable is equal to in the material's
    Inspector tab. The vast majority of shaders start out as Standard Shaders and
    get modified until they match the desired look. We have now created the foundation
    for any Surface Shader you will create that requires a diffuse component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Materials are assets. This means that any change made to them while your game
    is running in the editor are permanent. If you have changed the value of a property
    by mistake, you can undo it using *Ctrl *+ *Z*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any other programming language, Cg does not allow mistakes. As such, your
    shader will not work if you have a typo in your code. When this happens, your
    materials are rendered in unshaded magenta:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.gif)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'When a script does not compile, Unity prevents your game from being exported
    or even executed. Conversely, errors in shaders do not stop your game from being
    executed. If one of your shaders appears as magenta, it is time to investigate
    where the problem is. If you select the incriminated shader, you will see a list
    of errors displayed in its Inspector tab:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Despite showing the line that raised the error, it rarely means that this is
    the line that has to be fixed. The error message shown in the previous screenshot
    is generated by deleting the `sampler2D _MainTex` variable from the `SubShader{}`
    block. However, the error is raised by the first line that tries to access such
    a variable. Finding and fixing what''s wrong with code is a process called **debugging**.
    The most common mistakes that you should check for are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: A missing bracket. If you forgot to add a curly bracket to close a section,
    the compiler is likely to raise errors at the end of the document, at the beginning,
    or in a new section.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A missing semicolon. One of the most common mistakes, but luckily one of the
    easiest to spot and fix. When looking at the Error definition, first check if
    the line above it has a semicolon or not.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property that has been defined in the `Properties` section but has not been
    coupled with a variable in the `SubShader{}` block.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared to what you might be used to in C# scripts, the floating point values
    in Cg do not need to be followed by an `f`. It's `1.0`, not `1.0f`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error messages raised by shaders can be very misleading, especially due
    to their strict syntactic constraints. If you are in doubt about their meaning,
    it's best to search the internet. The Unity forums are filled with other developers
    who are likely to have encountered (and fixed) your problem before.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器抛出的错误信息可能会非常误导，尤其是由于它们严格的语法约束。如果你对它们的含义有疑问，最好是上网搜索。Unity 论坛上充满了其他开发者，他们很可能在之前遇到过（并解决了）你的问题。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on how to master Surface Shaders and their properties can be
    found in [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何掌握表面着色器和它们的属性，更多信息可以在第3章[《表面着色器和纹理映射》](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08)中找到。
- en: If you are curious to see what shaders can actually do when used at their full
    potential, have a look at [Chapter 11](part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08),
    *Advanced Shading Techniques*, for some of the most advanced techniques covered
    in this book.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你好奇想看看当着色器发挥其全部潜力时能做什么，可以查看第11章[《高级着色技术》](part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08)，书中涵盖的一些最先进的技术。
