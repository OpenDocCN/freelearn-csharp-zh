- en: 7 Strategy, Abstract Factory, and Singleton Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file32.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explores object creation using a few classic, simple, and yet powerful
    design patterns from the **Gang of Four** (**GoF**). These patterns allow developers
    to encapsulate and reuse behaviors, centralize object creation, add flexibility
    to our designs, or control object lifetime. Moreover, you will most likely use
    some of them in all software you build directly or indirectly in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**GoF**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are the authors
    of *Design Patterns: Elements of Reusable Object-Oriented Software* (1994), known
    as the **Gang of Four** (**GoF**). In that book, they introduce 23 design patterns,
    some of which we revisit in this book.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Why are they that important? Because they are the building blocks of robust
    object composition and help create flexibility and reliability. Moreover, in *Chapter
    8*, *Dependency Injection*, we make those patterns even more powerful!But first
    things first. In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract Factory design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Strategy design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strategy pattern is a behavioral design pattern that allows us to change
    object behaviors at runtime. We can also use this pattern to compose complex object
    trees and rely on it to follow the **Open/Closed Principle** (**OCP**) without
    much effort. Moreover, it plays a significant role in the *composition over inheritance*
    way of thinking. In this chapter, we focus on the behavioral part of the Strategy
    pattern. The next chapter covers how to use the Strategy pattern to compose systems
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Strategy pattern aims to extract an algorithm (a strategy) from the host
    class needing it (the context or consumer). That allows the consumer to decide
    on the strategy (algorithm) to use at runtime.For example, we could design a system
    that fetches data from two different types of databases. Then we could apply the
    same logic to that data and use the same user interface to display it. To achieve
    this, we could use the Strategy pattern to create two strategies, one named `FetchDataFromSql`
    and the other `FetchDataFromCosmosDb`. Then we could plug the strategy we need
    at runtime in the `context` class. That way, when the consumer calls the `context`,
    the `context` does not need to know where the data comes from, how it is fetched,
    or what strategy is in use; it only gets what it needs to work, delegating the
    fetching responsibility to an abstracted strategy (an interface).
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before any further explanation, let’s take a look at the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Strategy pattern class diagram](img/file33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Strategy pattern class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding diagram, the building blocks of the Strategy pattern
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context` is a class that depends on the `IStrategy` interface and leverages
    an implementation of the `IStrategy` interface to execute the `ExecuteAlgo` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IStrategy` is an interface defining the strategy API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteStrategy1` and `ConcreteStrategy2` represent one or more different
    concrete implementations of the `IStrategy` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following diagram, we explore what happens at runtime. The actor represents
    any code consuming the `Context` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Strategy pattern sequence diagram](img/file34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Strategy pattern sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the consumer calls the `Context.SomeOperation()` method, it does not know
    which implementation is executed, which is an essential part of this pattern.
    The `Context` class should not be aware of the strategy it uses either. It should
    run the strategy through the interface, unaware of the implementation. That is
    the strength of the Strategy pattern: it abstracts the implementation away from
    both the `Context` class and its consumers. Because of that, we can change the
    strategy during either the object creation or at runtime without the object knowing,
    changing its behavior on the fly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We could even generalize that last sentence and extend it to any interface.
    Depending on an interface breaks the ties between the consumer and the implementation
    by relying on that abstraction instead.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Project – Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We want to sort a collection differently, eventually even using
    different sort algorithms (out of the scope of the example but possible). Initially,
    we want to support sorting the elements of any collection in ascending or descending
    order.To achieve this, we need to implement the following building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` is the `SortableCollection` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IStrategy` is the `ISortStrategy` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The concrete strategies are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortAscendingStrategy`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SortDescendingStrategy`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The consumer is a small REST API that allows the user to change the strategy,
    sort the collection, and display the items. Let’s start with the `ISortStrategy`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That interface contains only one method that expects a string collection as
    input and returns an ordered string collection. Now let’s inspect the two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both implementations are super simple, using **Language Integrated Query** (**LINQ**)
    to sort the input and return the result directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When using expression-bodied methods, please ensure you do not make the method
    harder to read for your colleagues (or future you) by creating very complex one-liners.
    Writing multiple lines often makes the code easier to read.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The next building block to inspect is the `SortableCollection` class. It is
    composed of multiple string items (the `Items` property) and can sort them using
    an `ISortStrategy`. On top of that, it implements the `IEnumerable<string>` interface
    through its `Items` property, making it iterable. Here’s the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SortableCollection` class is the most complex one so far, so let’s take
    a more in-depth look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_sortStrategy` field references the algorithm: an `ISortStrategy` implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_items` field references the strings themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Items` property exposes the strings to the consumers of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor initializes the `Items` property using the `items` parameter
    and sets the default sorting strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SetSortStrategy` method allows consumers to change the strategy at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Sort` method uses the `_sortStrategy` field to sort the items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two `GetEnumerator` methods represent the implementation of the `IEnumerable<string>`
    interface and make the class enumerable through the `Items` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that code, we can see the Strategy pattern in action. The `_sortStrategy`
    field represents the current algorithm, respecting an `ISortStrategy` contract,
    which is updatable at runtime using the `SetSortStrategy` method. The `Sort` method
    delegates the work to the `ISortStrategy` implementation (the concrete strategy).
    Therefore, changing the value of the `_sortStrategy` field leads to a change of
    behavior of the `Sort` method, making this pattern very powerful yet simple. The
    highlighted code represents this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `_items` field is an `ImmutableArray<string>`, which makes changing the
    list impossible from the outside. For example, a consumer cannot pass a `List<string>`
    to the constructor, then change it later. Immutability has many advantages.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s experiment with this by looking at the `Consumer.API` project a REST
    API application that uses the previous code. Next is a breakdown of the `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` member is the context, our sortable collection of items. Next, we
    look at some boilerplate code to create the application and serialize `enum` values
    as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last part represents the consumer of the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declared the following endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: The first endpoint returns the `data` object when a client sends a `GET` request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second endpoint allows changing the sort strategy based on the `SortOrder`
    enum when a client sends a **PUT** request. Once the strategy is modified, it
    sorts the collection and returns the sorted data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The highlighted code represents the consumption of this implementation of the
    strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReplaceSortStrategy` class is an input DTO. Combined with the `SortOrder`
    enum, they represent the data contract of the second endpoint.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When we run the API and request the first endpoint, it responds with the following
    JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the items are in the order we set them because the code never
    called the `Sort` method. Next, let’s send the following HTTP request to the API
    to change the sort strategy to “descending”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the execution, the endpoint responds with the following JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the content, the sorting algorithm worked. Afterward, the
    list will remain in the same order if we query the GET endpoint. Next, let’s look
    at this use case using a sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Sequence diagram sorting the items using the “sort descending
    strategy”](img/file35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Sequence diagram sorting the items using the “sort descending strategy”'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the `Program` creating a strategy and assigning
    it to `SortableCollection` using its `SetSortStrategy` method. Then, when the
    `Program` calls the `Sort()` method, the `SortableCollection` instance delegates
    the sorting computation to the underlying implementation of the `ISortStrategy`
    interface. That implementation is the `SortDescendingStrategy` class (the **strategy**)
    which was set by the `Program` at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Sending another `PUT` request but specifying the `Ascending` sort order end
    up in a similar result, but the items would be sorted alphabetically.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The HTTP requests are available in the `Consumer.API.http` file.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: From a strategy pattern perspective, the `SortableCollection` class (the **context**)
    is responsible for referencing and using the current strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Strategy design pattern is very effective at delegating responsibilities
    to other objects, allowing you to hand over the responsibility of an algorithm
    to other objects while keeping its usage trivial. It also allows having a rich
    interface (context) with behaviors that can change at runtime.As we can see, the
    Strategy pattern is excellent at helping us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: It helps extract responsibilities from external classes and use them
    interchangeably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: It allows extending classes without updating its code by changing the
    current strategy at runtime, which is pretty much the actual definition of the
    OCP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: It does not rely on inheritance. Moreover, it plays a large role in
    the *composition over inheritance principle*, helping us avoid inheritance altogether
    and the LSP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: By creating smaller strategies based on lean and focused interfaces,
    the Strategy pattern is an excellent enabler of the ISP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The creation of dependencies is moved from the class using the strategy
    (the context) to the class’s consumer. That makes the context depend on abstraction
    instead of implementation, inverting the flow of control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C# Features**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you noticed C# features you are less familiar with, *Appendix A* explains
    many of them briefly.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s explore the Abstract Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Abstract Factory design pattern is a creational design pattern from the
    GoF. We use creational patterns to create other objects, and factories are a very
    popular way of doing that.The Strategy pattern is the backbone of dependency injection,
    enabling the composition of complex object trees, while factories are used to
    create some of those complex objects that can’t be assembled automatically by
    a dependency injection library. More on that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Abstract Factory pattern is used to abstract the creation of a family of
    objects. It usually implies the creation of multiple object types within that
    family. A family is a group of related or dependent objects (classes).Let’s think
    about creating automotive vehicles. There are multiple vehicle types, and there
    are multiple models and makes for each type. We can use the Abstract Factory pattern
    to model this sort of scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The *Factory Method* pattern also focuses on creating a single type of object
    instead of a family. We only cover Abstract Factory here, but we use other types
    of factories later in the book.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Abstract Factory, the consumer asks for an abstract object and gets one.
    The factory is an abstraction, and the resulting objects are also abstractions,
    decoupling the creation of an object from its consumers.That allows adding or
    removing families of objects produced together without impacting the consumers
    (all actors communicate through abstractions).In our case, the family (the set
    of objects the factory can produce) is composed of a car and a bike, and each
    factory (family) must produce both objects.If we think about vehicles, we could
    have the ability to create low- and high-end models of each vehicle type. Here
    is a diagram representing how to achieve that using the Abstract Factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Abstract Factory class diagram](img/file36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Abstract Factory class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diagram, we have the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IVehicleFactory` interface represents the Abstract Factory. It defines
    two methods: one that creates cars of type `ICar` and another that creates bikes
    of type `IBike`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HighEndVehicleFactory` class is a concrete factory implementing the `IVehicleFactory`
    interface. It handles high-end vehicle model creation, and its methods return
    `HighEndCar` or `HighEndBike` instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LowEndVehicleFactory` is a second concrete factory implementing the `IVehicleFactory`
    interface. It handles low-end vehicle model creation, and its methods return `LowEndCar`
    or `LowEndBike` instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LowEndCar` and `HighEndCar` are two implementations of `ICar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LowEndBike` and `HighEndBike` are two implementations of `IBike`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on that diagram, consumers use the concrete factories through the `IVehicleFactory`
    interface and should not be aware of the implementation used underneath. Applying
    this pattern abstracts away the vehicle creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Abstract Factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We need to support the creation of multiple models of vehicles.
    We also need to be able to add new models as they become available without impacting
    the system. To begin with, we only support high-end and low-end models, but we
    know this will change sooner rather than later. The program must only support
    the creation of cars and bikes.For the sake of our demo, the vehicles are just
    empty classes and interfaces because learning how to model vehicles is not necessary
    to understand the pattern; that would be noise. The following code represents
    those entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look at the part that we want to study—the factories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The factories are simple implementations that describe the pattern well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LowEndVehicleFactory` creates low-end models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HighEndVehicleFactory` creates high-end models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The consumer of this code is an xUnit test project. Unit tests are often your
    first consumers, especially if you are doing **test-driven development** (**TDD**).To
    make the tests easier, I created the following base test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The key to that class is the following generic parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TConcreteFactory` parameter represents the type of concrete factory we
    want to test. Its generic constraint specifies that it must implement the `IVehicleFactory`
    interface and have a parameterless constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TExpectedCar` parameter represents the type of `ICar` we expect from the
    `CreateCar` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TExpectedBike` parameter represents the type of `IBike` we expect from
    the `CreateBike` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first test method contained by that class is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test method creates a vehicle factory using the TConcreteFactory
    generic parameter, then creates a car using that factory. Finally, it asserts
    ICar instance is of the expected type.The second test method contains by that
    class is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test method is very similar and creates a vehicle factory using
    the `TConcreteFactory` generic parameter but then creates a bike instead of a
    car using that factory. Finally, it asserts `IBike` instance is of the expected
    type.
  prefs: []
  type: TYPE_NORMAL
- en: I used the `ICar` and `IBike` interfaces to type the variables instead of `var`,
    to clarify the `result` variable type. In another context, I would have used `var`
    instead. The same applies to the `IVehicleFactory` interface.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, to test the low-end factory, we declare the following test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That class solely depends on the `BaseAbstractFactoryTest` class and specifies
    the types to test for (highlighted).Next, to test the high-end factory, we declare
    the following test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Like the low-end factory, that class depends on the `BaseAbstractFactoryTest`
    class and specifies the types to test for (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: In a more complex scenario where we can’t use the `new()` generic constraint,
    we can leverage an IoC container to create the instance of `TConcreteFactory`
    and optionally mock its dependencies.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With that test code, we created the following two sets of two tests:'
  prefs: []
  type: TYPE_NORMAL
- en: A `LowEndVehicleFactory` class that should create a `LowEndCar` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LowEndVehicleFactory` class that should create a `LowEndBike` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `HighEndVehicleFactory` class that should create a `HighEndCar` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `HighEndVehicleFactory` class that should create a `HighEndBike` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have four tests: two for bikes and two for cars.If we review the tests’
    execution, both test methods are unaware of types. They use the Abstract Factory
    (`IVehicleFactory`) and test the `result` against the expected type without knowing
    what they are testing but the abstraction. That shows how loosely coupled the
    consumers (tests) and the factories are.'
  prefs: []
  type: TYPE_NORMAL
- en: We would use the `ICar` or the `IBike` instances in a real-world program to
    do something relevant based on the specifications. That could be a racing game
    or a rich person’s garage management system; who knows!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The important part of this project is **the abstraction of the object creation
    process**. The test code (consumer) is not aware of the implementations.Next,
    we extend our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Project – The mid-range vehicle factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To prove the flexibility of our design based on the Abstract Factory pattern,
    let’s add a new concrete factory named `MidRangeVehicleFactory`. That factory
    should return a `MidRangeCar` or a `MidRangeBike` instance. Once again, the car
    and bike are just empty classes (of course, in your programs, they will do something):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `MidRangeVehicleFactory` looks pretty much the same as the other two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to test the mid-range factory, we declare the following test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the low-end and high-end factories, the mid-range test class depends on
    the `BaseAbstractFactoryTest` class and specifies the types to test for (highlighted).If
    we run the tests, we now have the following six passing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Visual Studio Test Explorer showcasing the six passing tests.](img/file37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Visual Studio Test Explorer showcasing the six passing tests.'
  prefs: []
  type: TYPE_NORMAL
- en: So, without updating the consumer (the `AbstractFactoryTest` class), we added
    a new family of vehicles, the middle-end cars and bikes; kudos to the Abstract
    Factory pattern for that wonderfulness!
  prefs: []
  type: TYPE_NORMAL
- en: Impacts of the Abstract Factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before concluding, what would happen if we packed everything in a large interface
    instead of using an Abstract Factory (breaking the ISP along the way)? We could
    have created something like the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the preceding interface contains four specific methods and seems
    docile. However, the consumers of that code would be tightly coupled with those
    specific methods. For example, to change a consumer''s behavior, we’d need to
    update its code, like changing the call from `CreateHighEndBike` to `CreateLowEndBike`,
    which breaks the OCP. On the other hand, with the factory method, we can set a
    different factory for the consumers to spit out different results, which moves
    the flexibility out of the object itself and becomes a matter of composing the
    object graph instead (more on that in the next chapter).Moreover, when we want
    to add mid-range vehicles, we must update the `ILargeVehicleFactory` interface,
    which becomes a breaking change (the implementation(s) of the `ILargeVehicleFactory`
    must be updated). Here’s an example of the two new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From there, once the implementation(s) are updated, if we want to consume the
    new mid-range vehicles, we need to open each consumer class and apply the changes
    there, which once again breaks the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: The most crucial part is understanding and seeing the coupling and its impacts.
    Sometimes, it's okay to tightly couple one or more classes together as we don’t
    always need the added flexibility the SOLID principles and some design patterns
    can bring.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now let’s conclude before exploring the last design pattern of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Abstract Factory pattern is excellent for abstracting away the creation
    of object families, isolating each family and its concrete implementation, leaving
    the consumers unaware of the family created at runtime by the factory.We talk
    more about factories in the next chapter; meanwhile, let’s see how the Abstract
    Factory pattern can help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Each concrete factory is solely responsible for creating a family of
    objects. You could combine Abstract Factory with other creational patterns, such
    as the **Prototype** and **Builder** patterns for more complex creational needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: We can create new families of objects, like the mid-range vehicles,
    without breaking existing client code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: We aim at composition, so there’s no need for any inheritance, implicitly
    discarding the need for the LSP. If you use abstract classes in your design, you
    must ensure you don’t break the LSP when creating new abstract factories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Extracting a small abstraction with many implementations where each
    concrete factory focuses on one family makes that interface very focused on one
    task instead of having a large interface that exposes all types of products (like
    the `ILargeVehicleFactory` interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: By depending only on interfaces, the consumer is unaware of the concrete
    types it uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we explore the last design pattern of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Singleton design pattern allows creating and reusing a single instance
    of a class. We could use a static class to achieve almost the same goal, but not
    everything is doable using static classes. For example, a static class can’t implement
    an interface. We can’t pass an instance of a static class as an argument because
    there is no instance. We can only use static classes directly, which leads to
    tight coupling every time.The Singleton pattern in C# is an anti-pattern, and
    we should rarely use it, if ever, and use dependency injection instead. That said,
    it is a classic design pattern worth learning to at least avoid implementing it.
    We explore a better alternative in the next chapter.Here are a few reasons why
    we are covering this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: It translates into a singleton scope in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without knowing about it, you cannot locate it, try to remove it, or avoid its
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a simple pattern to explore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leads to other patterns, such as the **Ambient Context** pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Singleton pattern limits the number of instances of a class to one. Then,
    the idea is to reuse the same instance subsequently. A singleton encapsulates
    both the object logic itself and its creational logic. For example, the Singleton
    pattern could lower the cost of instantiating an object with a large memory footprint
    since the program instantiates it only once.Can you think of a SOLID principle
    that gets broken right there?The Singleton pattern promotes that one object must
    have two responsibilities, breaking the **Single Responsibility Principle** (**SRP**).
    A singleton is the object itself and its own factory.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This design pattern is straightforward and is limited to a single class. Let’s
    start with a class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Singleton pattern class diagram](img/file38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Singleton pattern class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Singleton` class is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A private static field that holds its unique instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public static `Create()` method that creates or returns the unique instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private constructor, so external code cannot instantiate it without passing
    by the `Create` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can name the `Create()` method anything or even get rid of it, as we see
    in the next example. We could name it `GetInstance()`, or it could be a static
    property named `Instance` or bear any other relevant name.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can translate the preceding diagram to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The null-coalescing assignment operator `??=` assigns the new instance of `MySingleton`
    only if the `_instance` member is `null`. That line is equivalent to writing the
    following if statement:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before discussing the code more, let’s explore our new class''s behavior. We
    can see in the following unit test that `MySingleton.Create()` always returns
    the same instance as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And voilà! We have a working Singleton pattern, which is extremely simple—probably
    the most simple design pattern that I can think of.Here is what is happening under
    the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: The first time that a consumer calls `MySingleton.Create()`, it creates the
    first instance of `MySingleton`. Since the constructor is `private`, it can only
    be created from the inside.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Create` method then persists that first instance to the `_instance` field
    for future use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a consumer calls `MySingleton.Create()` a second time, it returns the `_instance`
    field, reusing the class's previous (and only) instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we understand the logic, there is a potential issue with that design:
    it is not thread-safe. If we want our singleton to be thread-safe, we can `lock`
    the instance creation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we ensure two threads are not attempting to access the
    `Create` method simultaneously to ensure they are not getting different instances.
    Next, we improve our thread-safe example by making it shorter.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate (better) way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we used the “long way” of implementing the Singleton pattern and
    had to implement a thread-safe mechanism. Now that classic is behind us. We can
    shorten that code and even get rid of the `Create()` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code relies on the static initializer to ensure that only one
    instance of the `MySimpleSingleton` class is created and assigned to the `Instance`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: This simple technique should do the trick unless the singleton's constructor
    executes some heavy processing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With the property instead of a method, we can use the singleton class like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can prove the correctness of that claim by executing the following test
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is usually best to delegate responsibilities to the language or the framework
    whenever possible like we did here with the property initializer. Using a static
    constructor would also be a valid, thread-safe alternative, once again delegating
    the job to language features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beware of the arrow operator.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It may be tempting to use the arrow operator `=>` to initialize the `Instance`
    property like this: `public static MySimpleSingleton Instance => new MySimpleSingleton();`,
    but doing so would return a new instance every time. This would defeat the purpose
    of what we want to achieve. On the other hand, the property initializer runs only
    once.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The arrow operator makes the `Instance` property an expression-bodied member,
    equivalent to creating the following getter: `get { return new MySimpleSingleton();
    }`. You can consult *Appendix A* for more information about expression-bodies
    statements.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before we conclude the chapter, the Singleton (anti-)pattern also leads to a
    code smell.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell – Ambient Context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That last implementation of the **Singleton** pattern led us to the **Ambient
    Context** pattern. We could even call the Ambient Context an anti-pattern, but
    let’s just state that it is a consequential code smell.I do not recommend using
    ambient contexts for multiple reasons. First, I do my best to avoid anything global;
    an ambient context is a global state. Globals, like static members in C#, can
    look very convenient because they are easy to access and use. They are always
    there and accessible whenever needed: easy. However, they bring many drawbacks
    in terms of flexibility and testability.When using an ambient context, the following
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight coupling**: global states lead to less flexible systems; consumers
    are tightly coupled with the ambient context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing difficulty**: global objects are harder to replace, and we cannot
    easily swap them for other objects, like a mock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unforseen impacts**: if some part of your system messes up your global state,
    that may have unexpected consequences on other parts of your system, and you may
    have difficulty finding out the root cause of those errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential misuse**: developers could be tempted to add non-global concerns
    to the ambient context, leading to a bloated component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fun fact**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many years ago, before the JavaScript frameworks era, I fixed a bug in a system
    where some function was overriding the value of `undefined` due to a subtle error.
    This is an excellent example of how global variables could impact your whole system
    and make it more brittle. The same applies to the Ambient Context and Singleton
    patterns in C#; globals can be dangerous and annoying.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rest assured that, nowadays, browsers won’t let developers update the value
    of `undefined`, but it was possible back then.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we’ve discussed global objects, an ambient context is a global instance,
    usually available through a static property. The Ambient Context pattern can bring
    good things, but it is a code smell that smells bad.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few examples in .NET Framework, such as `System.Threading.Thread.CurrentPrincipal`
    and `System.Threading.Thread.CurrentThread`, that are scoped to a thread instead
    of being purely global like most static members. An ambient context does not have
    to be a singleton, but that is what they are most of the time. Creating a non-global
    (scoped) ambient context is harder and requires more work.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Is the Ambient Context pattern good or bad? I’d go with both! It is useful
    primarily because of its convenience and ease of use. Most of the time, it could
    and should be designed differently to reduce its drawbacks.There are many ways
    of implementing an ambient context, but to keep it brief and straightforward,
    we are focusing only on the singleton version of the ambient context. The following
    code is a good example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That code is an exact copy of the `MySimpleSingleton` class, with a few subtle
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Instance` is named `Current`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WriteSomething` method is new but has nothing to do with the Ambient Context
    pattern itself; it is just to make the class do something.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we take a look at the test method that follows, we can see that we use the
    ambient context by calling `MyAmbientContext.Current`, just like we did with the
    last singleton implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The property could include a public setter or support more complex logic. Building
    the right classes and exposing the right behaviors is up to you and your specifications.To
    conclude this interlude, avoid ambient contexts and use instantiable classes instead.
    We see how to replace a singleton with a single instance of a class using dependency
    injection in the next chapter. That gives us a more flexible alternative to the
    Singleton pattern. We can also create a single instance per HTTP request, which
    saves us the trouble of coding it while eliminating the disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Singleton pattern allows the creation of a single instance of a class for
    the whole lifetime of the program. It leverages a `private static` field and a
    `private` constructor to achieve its goal, exposing the instantiation through
    a `public static` method or property. We can use a field initializer, the `Create`
    method itself, a static constructor, or any other valid C# options to encapsulate
    the initialization logic.Now let’s see how the Singleton pattern can help us (not)
    follow the SOLID principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The singleton violates this principle because it has two clear responsibilities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the responsibility for which it has been created (not illustrated here),
    like any other class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the responsibility of creating and managing itself (lifetime management).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: The Singleton pattern also violates this principle. It enforces a single
    static instance, locked in place by itself, which limits extensibility. It is
    impossible to extend the class without changing its code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: There is no inheritance directly involved, which is the only good point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: No C# interface is involved, which violates this principle. However,
    we can look at the class interface instead, so building a small targeted singleton
    instance would satisfy this principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The singleton class has a rock-solid hold on itself. It also suggests
    using its static property (or method) directly without using an abstraction, breaking
    the DIP with a sledgehammer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, the Singleton pattern violates all the SOLID principles but
    the LSP and should be used cautiously. Having only a single instance of a class
    and always using that same instance is a common concept. However, we explore more
    proper ways to do this in the next chapter, leading me to the following advice:
    do not use the Singleton pattern, and if you see it used somewhere, try refactoring
    it out.'
  prefs: []
  type: TYPE_NORMAL
- en: I suggest avoiding static members that create global states as a general good
    practice. They can make your system less flexible and more brittle. There are
    occasions where `static` members are worth using, but try keeping their number
    as low as possible. Ask yourself if you can replace that `static` member or class
    with something else before coding one.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some may argue that the Singleton design pattern is a legitimate way of doing
    things. However, in ASP.NET Core, I am afraid I have to disagree: we have a powerful
    mechanism to do it differently, called dependency injection. When using other
    technologies, maybe, but not with modern .NET.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we explored our first GoF design patterns. These patterns
    expose some of the essential basics of software engineering, not necessarily the
    patterns themselves, but the concepts behind them:'
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern is a behavioral pattern that we use to compose most of
    our future classes. It allows swapping behavior at runtime by composing an object
    with small pieces and coding against interfaces, following the SOLID principles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract Factory pattern brings the idea of abstracting away object creation,
    leading to a better separation of concerns. More specifically, it aims to abstract
    the creation of object families and follow the SOLID principles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if we defined it as an anti-pattern, the Singleton pattern brings the application-level
    objects to the table. It allows the creation of a single instance of an object
    that lives for the whole lifetime of a program. The pattern violates most SOLID
    principles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also peeked at the Ambient Context code smell, which is used to create an
    omnipresent entity accessible from everywhere. It is often implemented as a singleton
    and brings a global state object to the program.The next chapter explores how
    dependency injection helps us compose complex yet maintainable systems. We also
    revisit the Strategy, the Factory, and the Singleton patterns to see how to use
    them in a dependency-injection-oriented context and how powerful they really are.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the Strategy pattern a behavioral pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could we define the goal of the creational patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I write the code `public MyType MyProp => new MyType();`, and I call the
    property twice (`var v1 = MyProp; var v2 = MyProp;`), are `v1` and `v2` the same
    instance or two different instances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that the Abstract Factory pattern allows us to add new families of
    elements without modifying the existing consuming code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the Singleton pattern an anti-pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It helps manage behaviors at runtime, such as changing an algorithm in the middle
    of a running program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The creational patterns are responsible for creating objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`v1` and `v2` are two different instances. The code on the right-hand side
    of the arrow operator is executed every time you call the property’s getter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, it is true. That’s the primary goal of the pattern, as we demonstrated
    in the `MidRangeVehicleFactory` code sample.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Singleton pattern violates the SOLID principles and encourages using global
    (static) state objects. We can avoid this pattern most of the time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
