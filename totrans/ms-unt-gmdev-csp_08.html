<html><head></head><body>
<div id="_idContainer066" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-73" class="calibre5"><a id="_idTextAnchor075" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Designing Optimized User Interfaces with C# for Unity Games</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Welcome to </span><a href="B22017_05.xhtml#_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapter 5</span></em></span></a><span class="kobospan" id="kobo.5.1">, where we will learn how to optimize </span><strong class="bold"><span class="kobospan" id="kobo.6.1">user interfaces</span></strong><span class="kobospan" id="kobo.7.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.8.1">UIs</span></strong><span class="kobospan" id="kobo.9.1">) for our Unity games using the versatile capabilities of C#. </span><span class="kobospan" id="kobo.9.2">This chapter equips you with practical skills to enhance the performance of your UI and ensure a smooth user experience. </span><span class="kobospan" id="kobo.9.3">The first skill focuses on utilizing C# for efficient UI optimization, maximizing the performance of your UI elements. </span><span class="kobospan" id="kobo.9.4">Following this, we delve into strategies for creating an optimized UI system in C#, providing insights into structuring and managing views effectively. </span><span class="kobospan" id="kobo.9.5">Throughout this chapter, the presented system acts as a flexible framework, allowing you to customize and optimize UI elements based on your game’s unique requirements. </span><span class="kobospan" id="kobo.9.6">Let’s dive into the world of optimized UIs, leveraging the power of C# to refine the performance and functionality of your Unity </span><span><span class="kobospan" id="kobo.10.1">game interfaces.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.12.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Introducing UI design </span><span><span class="kobospan" id="kobo.14.1">in gaming</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Best practices and optimizing techniques </span><span><span class="kobospan" id="kobo.16.1">for UI</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">UI system </span><span><span class="kobospan" id="kobo.18.1">using C#</span></span><a id="_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"/></li>
</ul>
<h1 id="_idParaDest-74" class="calibre5"><a id="_idTextAnchor077" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.19.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.20.1">All the code files of this chapter can be found </span><span><span class="kobospan" id="kobo.21.1">at: </span></span><a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.22.1">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005</span></span></a><span><span class="kobospan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-75" class="calibre5"><a id="_idTextAnchor078" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.24.1">Introducing UI design in gaming</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.25.1">In the exciting</span><a id="_idIndexMarker311" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.26.1"> world of making games, the UI is like the link between the player and the cool virtual world made by game creators. </span><span class="kobospan" id="kobo.26.2">UI design isn’t just about making things look good; it’s super important in shaping how players experience the game. </span><span class="kobospan" id="kobo.26.3">This section talks about why UI design is a big deal in games and how it really affects how much players get into the game and how much they </span><span><span class="kobospan" id="kobo.27.1">like it:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.28.1">The </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.29.1">first impression</span></strong></span><span><span class="kobospan" id="kobo.30.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.31.1">Think of the UI as the </span><a id="_idIndexMarker312" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.32.1">first hello between the game and the player. </span><span class="kobospan" id="kobo.32.2">A well-made UI grabs attention, sets the vibe, and makes the game look and feel unique. </span><span class="kobospan" id="kobo.32.3">Whether you’re on the main menu or playing the game, every part adds up to the first feeling you get when you </span><span><span class="kobospan" id="kobo.33.1">start playing.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.34.1">Enhancing </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.35.1">player immersion:</span></strong></span><p class="calibre3"><span class="kobospan" id="kobo.36.1">Playing a game should feel like you’re right there in the action. </span><span class="kobospan" id="kobo.36.2">A well-thought-out UI blends smoothly with the game, so you stay focused on playing without getting distracted. </span><span class="kobospan" id="kobo.36.3">Whether it’s cool movements, matching themes, or easy controls, the UI becomes a big part of the </span><span><span class="kobospan" id="kobo.37.1">game’s story.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.38.1">Guiding </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.39.1">user interaction:</span></strong></span><p class="calibre3"><span class="kobospan" id="kobo.40.1">The UI is like a helpful guide showing players what to do in the game. </span><span class="kobospan" id="kobo.40.2">From health bars to markers for quests, each thing gives important information without confusing players. </span><span class="kobospan" id="kobo.40.3">Making the UI clear and simple is super important so that players can think about their moves and the tricky parts of the game, not figuring out </span><span><span class="kobospan" id="kobo.41.1">the buttons.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.42.1">Impact on </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.43.1">player engagement:</span></strong></span><p class="calibre3"><span class="kobospan" id="kobo.44.1">A UI that’s easy to understand and looks good really keeps players interested. </span><span class="kobospan" id="kobo.44.2">If moving around menus is smooth and the game responds well, players want to spend more time playing. </span><span class="kobospan" id="kobo.44.3">On the flip side, a badly made UI can make players frustrated, not want to play, and ruin </span><span><span class="kobospan" id="kobo.45.1">the fun.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.46.1">Adapting to </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.47.1">diverse platforms:</span></strong></span><p class="calibre3"><span class="kobospan" id="kobo.48.1">Since we play games on all kinds of devices now, the UI has to work well on everything. </span><span class="kobospan" id="kobo.48.2">It’s like speaking different languages for each device, making sure the game feels right no matter whether you’re using a computer, console, </span><span><span class="kobospan" id="kobo.49.1">or phone.</span></span></p></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">Making the UI in games </span><a id="_idIndexMarker313" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.51.1">is like finding the right mix of making things look good and work well. </span><span class="kobospan" id="kobo.51.2">It’s about picking colors and fonts, how things are spaced out, and also making sure everything runs smoothly. </span><span class="kobospan" id="kobo.51.3">Using C# in Unity lets game makers use these cool design ideas and make interfaces that not only look awesome but also do their </span><span><span class="kobospan" id="kobo.52.1">job well.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.53.1">As we go through this chapter, we’ll check out the basic ideas behind UI design and see how C# can help make really great UIs that make playing games even </span><span><span class="kobospan" id="kobo.54.1">more awesome.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.55.1">Transitioning to best practices and optimization techniques for UIs, we’ll explore strategies to enhance UI performance and </span><span><span class="kobospan" id="kobo.56.1">responsiveness nex</span><a id="_idTextAnchor079" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.57.1">t.</span></span></p>
<h1 id="_idParaDest-76" class="calibre5"><a id="_idTextAnchor080" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.58.1">Best practices and optimization techniques for UIs</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">In this section, we are going to talk about some optimization techniques for UIs along with some best practices to have a better performance. </span><span class="kobospan" id="kobo.59.2">Let’s </span><span><span class="kobospan" id="kobo.60.1">get started.</span></span></p>
<h2 id="_idParaDest-77" class="calibre7"><a id="_idTextAnchor081" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.61.1">Splitting up Canvases</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.62.1">Issue</span></strong><span class="kobospan" id="kobo.63.1">: </span><em class="italic"><span class="kobospan" id="kobo.64.1">Modifying a single element on the UI Canvas triggers a complete Canvas refresh, </span></em><span><em class="italic"><span class="kobospan" id="kobo.65.1">impacting performance.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.66.1">The</span><a id="_idIndexMarker314" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.67.1"> Unity UI relies on the Canvas as its fundamental component. </span><span class="kobospan" id="kobo.67.2">It creates meshes representing UI elements, refreshes these meshes when there are changes, and sends draw calls to the GPU for actual </span><span><span class="kobospan" id="kobo.68.1">UI display.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.69.1">Mesh generation is resource-intensive, requiring UI Elements to be grouped into batches for efficiency in draw calls. </span><span class="kobospan" id="kobo.69.2">Due to the cost of batch regeneration, it’s essential to minimize unnecessary refreshes. </span><span class="kobospan" id="kobo.69.3">The challenge arises when even a single element changes on a Canvas, prompting a full Canvas re-evaluation to determine the optimal way to redraw </span><span><span class="kobospan" id="kobo.70.1">its elements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.71.1">Many users construct their entire game’s UI on a single Canvas with numerous elements. </span><span class="kobospan" id="kobo.71.2">Altering just one element can lead to a significant CPU spike, consuming </span><span><span class="kobospan" id="kobo.72.1">multiple milliseconds.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.73.1">Solution</span></strong><span class="kobospan" id="kobo.74.1">: Divide </span><span><span class="kobospan" id="kobo.75.1">your Canvases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.76.1">Each Canvas functions as an independent entity, segregating its elements from those on other Canvases. </span><span class="kobospan" id="kobo.76.2">Leverage the Unity GUI’s support for multiple Canvases by segmenting your Canvases, addressing the batching challenges within </span><span><span class="kobospan" id="kobo.77.1">Unity UI.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.78.1">Nested Canvases </span><a id="_idIndexMarker315" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.79.1">offer another solution, enabling the creation of complex hierarchical UIs without the need to consider the spatial arrangement of elements across Canvases. </span><span class="kobospan" id="kobo.79.2">Child Canvases additionally insulate content from both their parent and sibling Canvases. </span><span class="kobospan" id="kobo.79.3">They maintain individual geometry and conduct independent batching. </span><span class="kobospan" id="kobo.79.4">An effective strategy for segmentation is based on the refresh frequency of elements. </span><span class="kobospan" id="kobo.79.5">Place static UI Elements on a distinct Canvas, reserving smaller sub-Canvases for dynamic elements that update simultaneously. </span><span class="kobospan" id="kobo.79.6">Additionally, ensure uniformity in Z values, materials, and textures for all UI Elements on </span><span><span class="kobospan" id="kobo.80.1">each Canvas.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.81.1">In our game, let me illustrate with an example. </span><span class="kobospan" id="kobo.81.2">We’ll set up a Canvas for the overall scene and, within this main canvas, each panel will function as an individual Canvas. </span><span class="kobospan" id="kobo.81.3">This means that when we make updates, such as to the HUD canvas during gameplay, we won’t be affecting the </span><strong class="bold"><span class="kobospan" id="kobo.82.1">Pause</span></strong><span class="kobospan" id="kobo.83.1"> panel or any other panels. </span><span class="kobospan" id="kobo.83.2">It’s crucial to ensure that every panel or view has its dedicated canvas component, preventing performance issues when updates </span><span><span class="kobospan" id="kobo.84.1">are applied.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">The following figure shows the division of the gameplay scene canvases into </span><span><span class="kobospan" id="kobo.86.1">smaller sub-canvases.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer056">
<span class="kobospan" id="kobo.87.1"><img alt="Figure 5.1 – GamePlayCanvas hierarchy" src="image/B22017_05_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.88.1">Figure 5.1 – GamePlayCanvas hierarchy</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.89.1">The following </span><a id="_idIndexMarker316" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.90.1">figure shows the </span><strong class="bold"><span class="kobospan" id="kobo.91.1">GamePlayCanvas</span></strong><span class="kobospan" id="kobo.92.1"> which contains </span><span><span class="kobospan" id="kobo.93.1">all canvases:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer057">
<span class="kobospan" id="kobo.94.1"><img alt="Figure 5.2 – GamePlayCanvas GameObject" src="image/B22017_05_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.95.1">Figure 5.2 – GamePlayCanvas GameObject</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.96.1">The following </span><a id="_idIndexMarker317" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.97.1">figure shows the </span><strong class="bold"><span class="kobospan" id="kobo.98.1">PauseCanvas</span></strong><span class="kobospan" id="kobo.99.1"> which is a child </span><span><span class="kobospan" id="kobo.100.1">of </span></span><span><strong class="bold"><span class="kobospan" id="kobo.101.1">GamePlayCanvas</span></strong></span><span><span class="kobospan" id="kobo.102.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer058">
<span class="kobospan" id="kobo.103.1"><img alt="Figure 5.3 – PauseCanvas GameObject" src="image/B22017_05_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.104.1">Figure 5.3 – PauseCanvas GameObject</span></p>
<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor082" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.105.1">Avoiding too many Graphic Raycasters and turning off Raycast Target</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.106.1">Issue #1</span></strong><span class="kobospan" id="kobo.107.1">: </span><em class="italic"><span class="kobospan" id="kobo.108.1">Not using Graphic </span></em><span><em class="italic"><span class="kobospan" id="kobo.109.1">Raycaster well</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">The </span><strong class="bold"><span class="kobospan" id="kobo.111.1">Graphic Raycaster</span></strong><span class="kobospan" id="kobo.112.1"> helps</span><a id="_idIndexMarker318" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.113.1"> with turning your clicks or taps on the screen into things the game understands. </span><span class="kobospan" id="kobo.113.2">It’s like a translator between your actions and the game’s UI, figuring out what you’re touching and sending that information to the right parts of the game. </span><span class="kobospan" id="kobo.113.3">You need this thing on every screen that needs your touch, even on smaller screens inside the big one. </span><span class="kobospan" id="kobo.113.4">But it goes through all the places you touch on the screen and checks whether they’re inside a UI’s area, which can be a </span><span><span class="kobospan" id="kobo.114.1">bit much.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.115.1">Even though it’s called a Graphic Raycaster, it doesn’t exactly cast rays. </span><span class="kobospan" id="kobo.115.2">By default, it only cares about UI graphics. </span><span class="kobospan" id="kobo.115.3">It looks at all the UI parts that want to know when you touch them and checks whether the spot where you touch matches up with the UI parts that are set up </span><span><span class="kobospan" id="kobo.116.1">to respond.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">The problem is that not all UI parts want to be bothered when you </span><span><span class="kobospan" id="kobo.118.1">touch them.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.119.1">Solution</span></strong><span class="kobospan" id="kobo.120.1">: Get rid of </span><a id="_idIndexMarker319" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.121.1">Graphic Raycasters from screens or UI elements where you don’t need them, especially if there are things that don’t really care if you touch them. </span><span class="kobospan" id="kobo.121.2">Also, switch off the part that checks whether some things on the screen can be touched for elements that don’t change or don’t need your touch. </span><span class="kobospan" id="kobo.121.3">In the following figure, notice the </span><strong class="bold"><span class="kobospan" id="kobo.122.1">Raycast Target</span></strong><span class="kobospan" id="kobo.123.1"> setting in the </span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">Image</span></strong><span class="kobospan" id="kobo.125.1"> component – we only turn it off for images that you can’t </span><span><span class="kobospan" id="kobo.126.1">interact with:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer059">
<span class="kobospan" id="kobo.127.1"><img alt="Figure 5.4 – RayCast Target variable" src="image/B22017_05_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.128.1">Figure 5.4 – RayCast Target variable</span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.129.1">Issue #2</span></strong><span class="kobospan" id="kobo.130.1">: </span><em class="italic"><span class="kobospan" id="kobo.131.1">Sometimes the Graphic Raycaster does more than just </span></em><span><em class="italic"><span class="kobospan" id="kobo.132.1">translate touches.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.133.1">When you set </span><strong class="bold"><span class="kobospan" id="kobo.134.1">Render Mode</span></strong><span class="kobospan" id="kobo.135.1"> on your Canvas to </span><strong class="bold"><span class="kobospan" id="kobo.136.1">Worldspace Camera</span></strong><span class="kobospan" id="kobo.137.1"> or </span><strong class="bold"><span class="kobospan" id="kobo.138.1">Screen Space Camera</span></strong><span class="kobospan" id="kobo.139.1">, a blocking mask can be added. </span><span class="kobospan" id="kobo.139.2">This mask determines whether the Raycaster will cast rays using 2D or 3D physics, determining whether any physics object obstructs the user’s ability to interact with </span><span><span class="kobospan" id="kobo.140.1">the UI.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.141.1">Solution</span></strong><span class="kobospan" id="kobo.142.1">: Casting</span><a id="_idIndexMarker320" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.143.1"> rays via 2D or 3D physics can be resource-intensive, so use this feature judiciously. </span><span class="kobospan" id="kobo.143.2">To minimize the number of Graphic Raycasters, exclude them from non-interactive UI Canvases since, in such cases, there is no need to check for </span><span><span class="kobospan" id="kobo.144.1">interaction events.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.145.1">In the following figure, you can see the </span><strong class="bold"><span class="kobospan" id="kobo.146.1">Graphic </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.147.1">Raycaster</span></strong></span><span><span class="kobospan" id="kobo.148.1"> component:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer060">
<span class="kobospan" id="kobo.149.1"><img alt="Figure 5.5 – Graphic Raycaster component" src="image/B22017_05_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.150.1">Figure 5.5 – Graphic Raycaster component</span></p>
<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor083" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.151.1">Efficiently managing UI object pools</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.152.1">Issue</span></strong><span class="kobospan" id="kobo.153.1">: </span><em class="italic"><span class="kobospan" id="kobo.154.1">Inefficient practices in UI </span></em><span><em class="italic"><span class="kobospan" id="kobo.155.1">object pooling</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.156.1">Frequently, individuals</span><a id="_idIndexMarker321" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.157.1"> engage in pooling UI objects by first changing their parent and then disabling them, resulting in </span><span><span class="kobospan" id="kobo.158.1">unnecessary complications.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.159.1">Solution</span></strong><span class="kobospan" id="kobo.160.1">: Optimize for deactivating the object first before reassigning its parent within </span><span><span class="kobospan" id="kobo.161.1">the pool.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.162.1">This strategy ensures that the original hierarchy is dirtied only once. </span><span class="kobospan" id="kobo.162.2">Once the object is reparented, there’s no need for an additional round of hierarchy changes, and the new hierarchy remains unaffected. </span><span class="kobospan" id="kobo.162.3">When extracting an object from the pool, follow the sequence of reparenting it first, updating your data, and then activating it to </span><span><span class="kobospan" id="kobo.163.1">maintain efficiency.</span></span></p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor084" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.164.1">Hiding a Canvas the right way</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.165.1">Issue</span></strong><span class="kobospan" id="kobo.166.1">: </span><em class="italic"><span class="kobospan" id="kobo.167.1">Uncertain about efficiently hiding </span></em><span><em class="italic"><span class="kobospan" id="kobo.168.1">a Canvas</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.169.1">There are</span><a id="_idIndexMarker322" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.170.1"> times when you want to keep UI Elements and Canvases out of sight. </span><span class="kobospan" id="kobo.170.2">But how can you achieve this in an </span><span><span class="kobospan" id="kobo.171.1">effective manner?</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.172.1">Solution</span></strong><span class="kobospan" id="kobo.173.1">: Deactivate the </span><strong class="source-inline"><span class="kobospan" id="kobo.174.1">Canvas</span></strong> <span><span class="kobospan" id="kobo.175.1">component itself.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.176.1">By disabling the </span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">Canvas</span></strong><span class="kobospan" id="kobo.178.1"> component, you stop the generation of draw calls to the GPU, rendering the Canvas invisible. </span><span class="kobospan" id="kobo.178.2">Importantly, the Canvas retains its vertex buffer, preserving all meshes and vertices. </span><span class="kobospan" id="kobo.178.3">Consequently, re-enabling it doesn’t trigger a rebuild; it simply </span><span><span class="kobospan" id="kobo.179.1">resumes drawing.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.180.1">Furthermore, deactivating the </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">Canvas</span></strong><span class="kobospan" id="kobo.182.1"> component avoids initiating the resource-intensive </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">OnDisable</span></strong><span class="kobospan" id="kobo.184.1">/</span><strong class="source-inline"><span class="kobospan" id="kobo.185.1">OnEnable</span></strong><span class="kobospan" id="kobo.186.1"> callbacks within the Canvas hierarchy. </span><span class="kobospan" id="kobo.186.2">Just exercise caution when disabling child components that execute computationally demanding </span><span><span class="kobospan" id="kobo.187.1">per-frame code.</span></span></p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor085" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.188.1">Efficient implementation of animations for UI Elements</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.189.1">Issue</span></strong><span class="kobospan" id="kobo.190.1">: </span><em class="italic"><span class="kobospan" id="kobo.191.1">Implementing animators on </span></em><span><em class="italic"><span class="kobospan" id="kobo.192.1">the UI</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.193.1">When</span><a id="_idIndexMarker323" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.194.1"> animators are applied to the UI, they consistently affect UI Elements in every frame, even when the animation value </span><span><span class="kobospan" id="kobo.195.1">remains constant.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.196.1">Solution</span></strong><span class="kobospan" id="kobo.197.1">: Employ code for </span><span><span class="kobospan" id="kobo.198.1">UI animation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.199.1">Restrict the use of animators to dynamic UI Elements that undergo constant changes. </span><span class="kobospan" id="kobo.199.2">For elements that infrequently change or experience temporary alterations triggered by events, opt for coding your animations or utilizing a tweening system, a system you can make through code or you can use third-party assets for that. </span><span class="kobospan" id="kobo.199.3">Various effective solutions for this purpose can be found on the Unity Asset Store. </span><span class="kobospan" id="kobo.199.4">For our game, we will use the free </span><strong class="source-inline"><span class="kobospan" id="kobo.200.1">DoTween</span></strong><span class="kobospan" id="kobo.201.1"> package </span><span><span class="kobospan" id="kobo.202.1">for this.</span></span></p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor086" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.203.1">Effective handling of fullscreen UIs</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.204.1">Issue</span></strong><span class="kobospan" id="kobo.205.1">: </span><em class="italic"><span class="kobospan" id="kobo.206.1">Performance issues with </span></em><span><em class="italic"><span class="kobospan" id="kobo.207.1">fullscreen UIs</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">When a </span><a id="_idIndexMarker324" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.209.1">pause or start screen occupies the entire display, the remaining elements of the game continue rendering in the background, potentially leading to </span><span><span class="kobospan" id="kobo.210.1">performance problems.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.211.1">Solution</span></strong><span class="kobospan" id="kobo.212.1">: Hide </span><span><span class="kobospan" id="kobo.213.1">everything else.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.214.1">If you present a screen that overlays the entire scene, deactivate the camera responsible for rendering the 3D scene. </span><span class="kobospan" id="kobo.214.2">Likewise, disable Canvas elements positioned beneath the </span><span><span class="kobospan" id="kobo.215.1">top Canvas.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.216.1">Contemplate reducing </span><strong class="source-inline"><span class="kobospan" id="kobo.217.1">Application.targetFrameRate</span></strong><span class="kobospan" id="kobo.218.1"> when engaging a fullscreen UI, as there is no necessity for updates at a </span><strong class="bold"><span class="kobospan" id="kobo.219.1">60 </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.220.1">fps</span></strong></span><span><span class="kobospan" id="kobo.221.1"> rate.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.222.1">Now that we have understood the best practices and optimization techniques for the UI, let’s move on to the next section where we will explore some </span><span><span class="kobospan" id="kobo.223.1">architectural patterns.</span></span></p>
<h1 id="_idParaDest-83" class="calibre5"><a id="_idTextAnchor087" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.224.1">Introducing architecture patterns (MVC and MVVM)</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">In the world of game development, organizing and managing the UI is crucial for creating</span><a id="_idIndexMarker325" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.226.1"> engaging and efficient experiences. </span><span class="kobospan" id="kobo.226.2">Two widely used architectural patterns – namely, </span><strong class="bold"><span class="kobospan" id="kobo.227.1">Model-View-Controller</span></strong><span class="kobospan" id="kobo.228.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.229.1">MVC</span></strong><span class="kobospan" id="kobo.230.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.231.1">Model-View-ViewModel</span></strong><span class="kobospan" id="kobo.232.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.233.1">MVVM</span></strong><span class="kobospan" id="kobo.234.1">) – provide frameworks for structuring UI elements in a way that </span><a id="_idIndexMarker326" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.235.1">enhances clarity and maintainability. </span><span class="kobospan" id="kobo.235.2">MVC separates the application into three interconnected components — the </span><strong class="bold"><span class="kobospan" id="kobo.236.1">model</span></strong><span class="kobospan" id="kobo.237.1"> for data and logic, the </span><strong class="bold"><span class="kobospan" id="kobo.238.1">view</span></strong><span class="kobospan" id="kobo.239.1"> for the user interface, and the </span><strong class="bold"><span class="kobospan" id="kobo.240.1">controller</span></strong><span class="kobospan" id="kobo.241.1"> for managing user input. </span><span class="kobospan" id="kobo.241.2">On the other hand, MVVM introduces </span><strong class="bold"><span class="kobospan" id="kobo.242.1">ViewModel</span></strong><span class="kobospan" id="kobo.243.1"> as a mediator between the model and the view, simplifying presentation logic and data binding, which is the automatic synchronization of data between the UI and the underlying data model in software applications. </span><span class="kobospan" id="kobo.243.2">In this section, we will explore the practical application of these patterns in Unity game development, offering insights and guidance to help you make informed decisions about structuring your </span><span><span class="kobospan" id="kobo.244.1">game’s UI.</span></span></p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor088" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.245.1">Understanding MVC – a teamwork of three roles</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.246.1">In the following figure, you can see the arrangement of the MVC pattern and how its </span><span><span class="kobospan" id="kobo.247.1">components interact.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer061">
<span class="kobospan" id="kobo.248.1"><img alt="Figure 5.6 – MVC structure" src="image/B22017_05_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.249.1">Figure 5.6 – MVC structure</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.250.1">Let’s understand a</span><a id="_idIndexMarker327" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.251.1"> little bit more about the </span><span><span class="kobospan" id="kobo.252.1">MVC structure:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.253.1">Model</span></strong></span><span><span class="kobospan" id="kobo.254.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.255.1">Essence</span></em><span class="kobospan" id="kobo.256.1">: Represents the data and business logic of </span><span><span class="kobospan" id="kobo.257.1">the application</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.258.1">Unity implementation</span></em><span class="kobospan" id="kobo.259.1">: Often implemented as </span><strong class="source-inline1"><span class="kobospan" id="kobo.260.1">ScriptableObject</span></strong><span class="kobospan" id="kobo.261.1"> or regular C# </span><span><span class="kobospan" id="kobo.262.1">class instances</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.263.1">Role</span></em><span class="kobospan" id="kobo.264.1">: Manages data, enforces business rules, and communicates changes to </span><span><span class="kobospan" id="kobo.265.1">the view</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.266.1">View</span></strong></span><span><span class="kobospan" id="kobo.267.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.268.1">Essence</span></em><span class="kobospan" id="kobo.269.1">: Represents the UI elements, responsible for displaying data to </span><span><span class="kobospan" id="kobo.270.1">the user</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.271.1">Unity implementation</span></em><span class="kobospan" id="kobo.272.1">: Comprises Unity UI components, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">Canvas</span></strong><span class="kobospan" id="kobo.274.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">Text</span></strong><span class="kobospan" id="kobo.276.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">Image</span></strong><span class="kobospan" id="kobo.278.1">, and </span><span><span class="kobospan" id="kobo.279.1">so on</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.280.1">Role</span></em><span class="kobospan" id="kobo.281.1">: Renders the data from the model and handles user input interactions, forwarding them to </span><span><span class="kobospan" id="kobo.282.1">the controller</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.283.1">Controller</span></strong></span><span><span class="kobospan" id="kobo.284.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.285.1">Essence</span></em><span class="kobospan" id="kobo.286.1">: Acts as an intermediary between the model and the view, handling user input and updating the model and </span><span><span class="kobospan" id="kobo.287.1">view accordingly</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.288.1">Unity implementation</span></em><span class="kobospan" id="kobo.289.1">: A </span><strong class="source-inline1"><span class="kobospan" id="kobo.290.1">MonoBehaviour</span></strong><span class="kobospan" id="kobo.291.1"> script attached to Unity UI elements or </span><span><span class="kobospan" id="kobo.292.1">game objects.</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.293.1">Role</span></em><span class="kobospan" id="kobo.294.1">: Listens for</span><a id="_idIndexMarker328" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.295.1"> user input, updates the model, and instructs the view to </span><span><span class="kobospan" id="kobo.296.1">reflect changes</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.297.1">Interaction flow</span></strong></span><span><span class="kobospan" id="kobo.298.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.299.1">User input</span></em><span class="kobospan" id="kobo.300.1">: Captured by </span><span><span class="kobospan" id="kobo.301.1">the controller</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.302.1">Model update</span></em><span class="kobospan" id="kobo.303.1">: The controller updates the model based on </span><span><span class="kobospan" id="kobo.304.1">user input</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.305.1">View update</span></em><span class="kobospan" id="kobo.306.1">: The view receives notifications from the model and updates the </span><span><span class="kobospan" id="kobo.307.1">UI accordingly</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.308.1">Pros </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.309.1">in Unity</span></strong></span><span><span class="kobospan" id="kobo.310.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.311.1">Simplicity</span></em><span class="kobospan" id="kobo.312.1">: Well suited for smaller projects and straightforward </span><span><span class="kobospan" id="kobo.313.1">UI structures</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.314.1">Unity compatibility</span></em><span class="kobospan" id="kobo.315.1">: Aligns seamlessly with Unity’s built-in </span><span><span class="kobospan" id="kobo.316.1">UI system</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.317.1">Cons </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.318.1">in Unity</span></strong></span><span><span class="kobospan" id="kobo.319.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.320.1">Potential complexity</span></em><span class="kobospan" id="kobo.321.1">: May lead to increased complexity as the </span><span><span class="kobospan" id="kobo.322.1">project grows</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.323.1">Data binding challenges</span></em><span class="kobospan" id="kobo.324.1">: Achieving efficient data binding might require </span><span><span class="kobospan" id="kobo.325.1">additional effort</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.326.1">Let’s move on to understanding the next architectural </span><span><span class="kobospan" id="kobo.327.1">pattern, MVVM.</span></span></p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.328.1">Understanding MVVM – a mix of views and models</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.329.1">In the following </span><a id="_idIndexMarker329" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.330.1">figure, you can see the arrangement of the MVVM pattern and how its </span><span><span class="kobospan" id="kobo.331.1">components interact:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer062">
<span class="kobospan" id="kobo.332.1"><img alt="Figure 5.7 – MVVM structure" src="image/B22017_05_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.333.1">Figure 5.7 – MVVM structure</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.334.1">Let’s understand a </span><a id="_idIndexMarker330" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.335.1">little bit more about the </span><span><span class="kobospan" id="kobo.336.1">MVVM structure:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.337.1">Model</span></strong></span><span><span class="kobospan" id="kobo.338.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.339.1">Essence</span></em><span class="kobospan" id="kobo.340.1">: Represents the data and business logic, similar </span><span><span class="kobospan" id="kobo.341.1">to MVC</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.342.1">Unity implementation</span></em><span class="kobospan" id="kobo.343.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.344.1">ScriptableObject</span></strong><span class="kobospan" id="kobo.345.1"> or regular C# class instances, much like </span><span><span class="kobospan" id="kobo.346.1">in MVC</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.347.1">Role</span></em><span class="kobospan" id="kobo.348.1">: Manages data, enforces business rules, and communicates changes to </span><span><span class="kobospan" id="kobo.349.1">the view</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.350.1">View</span></strong></span><span><span class="kobospan" id="kobo.351.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.352.1">Essence</span></em><span class="kobospan" id="kobo.353.1">: Represents the UI, responsible for </span><span><span class="kobospan" id="kobo.354.1">displaying data</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.355.1">Unity implementation</span></em><span class="kobospan" id="kobo.356.1">: Unity UI components, same as </span><span><span class="kobospan" id="kobo.357.1">in MVC</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.358.1">Role</span></em><span class="kobospan" id="kobo.359.1">: Renders the data from the model and handles user input interactions, forwarding them to </span><span><span class="kobospan" id="kobo.360.1">the controller</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.361.1">ViewModel</span></strong></span><span><span class="kobospan" id="kobo.362.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.363.1">Essence</span></em><span class="kobospan" id="kobo.364.1">: Acts </span><a id="_idIndexMarker331" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.365.1">as an intermediary between the model and the view, exposing properties </span><span><span class="kobospan" id="kobo.366.1">and commands</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.367.1">Unity implementation</span></em><span class="kobospan" id="kobo.368.1">: A </span><strong class="source-inline1"><span class="kobospan" id="kobo.369.1">MonoBehaviour</span></strong><span class="kobospan" id="kobo.370.1"> script that facilitates </span><span><span class="kobospan" id="kobo.371.1">data binding</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.372.1">Role</span></em><span class="kobospan" id="kobo.373.1">: Simplifies data binding by exposing data and logic for the view to bind </span><span><span class="kobospan" id="kobo.374.1">to directly</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.375.1">Interaction flow</span></strong></span><span><span class="kobospan" id="kobo.376.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.377.1">User input</span></em><span class="kobospan" id="kobo.378.1">: Captured by the view or directly by </span><span><span class="kobospan" id="kobo.379.1">the ViewModel</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.380.1">Model update</span></em><span class="kobospan" id="kobo.381.1">: The ViewModel updates the model based on </span><span><span class="kobospan" id="kobo.382.1">user input</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.383.1">View update</span></em><span class="kobospan" id="kobo.384.1">:  When data changes occur in the model, they automatically update the view through </span><span><span class="kobospan" id="kobo.385.1">data binding</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.386.1">Pros </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.387.1">in Unity</span></strong></span><span><span class="kobospan" id="kobo.388.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.389.1">Enhanced data binding</span></em><span class="kobospan" id="kobo.390.1">: Streamlines the process of updating the UI in response to changes in the </span><span><span class="kobospan" id="kobo.391.1">underlying data</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.392.1">Testability</span></em><span class="kobospan" id="kobo.393.1">: ViewModel components can be tested independently, </span><span><span class="kobospan" id="kobo.394.1">fostering maintainability</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.395.1">Cons </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.396.1">in Unity</span></strong></span><span><span class="kobospan" id="kobo.397.1">:</span></span><ul class="calibre16"><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.398.1">Learning curve</span></em><span class="kobospan" id="kobo.399.1">: May pose a learning curve for developers unfamiliar with </span><span><span class="kobospan" id="kobo.400.1">the pattern</span></span></li><li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.401.1">Overhead of abstraction</span></em><span class="kobospan" id="kobo.402.1">: Introducing an additional layer with the ViewModel might be considered over-engineering for </span><span><span class="kobospan" id="kobo.403.1">smaller projects</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.404.1">Now that we </span><a id="_idIndexMarker332" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.405.1">understand what MVC and MVVM are, let’s explore how to decide between them for our project based on </span><span><span class="kobospan" id="kobo.406.1">certain factors.</span></span></p>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor090" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.407.1">Choosing the right path for Unity UI</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.408.1">The</span><a id="_idIndexMarker333" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.409.1"> following points explain why we would choose MVC </span><span><span class="kobospan" id="kobo.410.1">in Unity:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.411.1">Well-established compatibility</span></strong><span class="kobospan" id="kobo.412.1">: Unity’s built-in UI system aligns naturally with the principles </span><span><span class="kobospan" id="kobo.413.1">of MVC</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.414.1">Simplicity for smaller projects</span></strong><span class="kobospan" id="kobo.415.1">: For smaller projects or when simplicity is crucial, MVC can be a </span><span><span class="kobospan" id="kobo.416.1">pragmatic choice</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.417.1">The following points explain why we would choose MVVM </span><span><span class="kobospan" id="kobo.418.1">in Unity:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.419.1">Data-driven complexity</span></strong><span class="kobospan" id="kobo.420.1">: MVVM shines in scenarios demanding efficient data binding and complex </span><span><span class="kobospan" id="kobo.421.1">UI structures</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.422.1">Scaling for larger projects</span></strong><span class="kobospan" id="kobo.423.1">: MVVM facilitates scalability and maintainability, making it a robust choice for </span><span><span class="kobospan" id="kobo.424.1">larger endeavors</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">The following points will help you select </span><span><span class="kobospan" id="kobo.426.1">your approach:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.427.1">Consider project size</span></strong><span class="kobospan" id="kobo.428.1">: MVC’s simplicity may be advantageous for smaller projects, while MVVM’s enhanced data binding and testability are beneficial for </span><span><span class="kobospan" id="kobo.429.1">larger endeavors</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.430.1">Evaluate data binding needs</span></strong><span class="kobospan" id="kobo.431.1">: If efficient data binding is crucial, MVVM might be the </span><span><span class="kobospan" id="kobo.432.1">preferred choice</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.433.1">The</span><a id="_idIndexMarker334" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.434.1"> journey through Unity UI development is a dynamic exploration, guided by the architectural choices of MVC and MVVM. </span><span class="kobospan" id="kobo.434.2">While MVC offers simplicity and familiarity, MVVM introduces a layer of abstraction, elevating data binding and testability. </span><span class="kobospan" id="kobo.434.3">As you navigate the Unity UI architecture, consider the specific needs of your project, the complexity of your UI, and the familiarity of your development team. </span><span class="kobospan" id="kobo.434.4">Whether adhering to the clarity of MVC or embracing the sophistication of MVVM, the path you choose defines not only the structure of your UI but also the foundation of an immersive player experience. </span><span class="kobospan" id="kobo.434.5">For our game, we will go with the </span><span><span class="kobospan" id="kobo.435.1">MVC structure.</span></span></p>
<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor091" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.436.1">Practical suggestions for enhancing your UI development</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.437.1">Here are </span><a id="_idIndexMarker335" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.438.1">some tips that can be beneficial for you while working </span><span><span class="kobospan" id="kobo.439.1">on UI.</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.440.1">Create Prefabs for the most frequently </span><span><span class="kobospan" id="kobo.441.1">used elements:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.442.1">For this, consider using the title text as an example and attaching components to it. </span><span class="kobospan" id="kobo.442.2">This makes it easier to implement changes later, as any modifications will impact all the elements in the game. </span><span class="kobospan" id="kobo.442.3">Additionally, you can create images and any other </span><span><span class="kobospan" id="kobo.443.1">UI elements.</span></span></li></ul></li>
<li class="calibre11"><span class="kobospan" id="kobo.444.1">Use </span><span><span class="kobospan" id="kobo.445.1">Sprite Atlases:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.446.1">A Sprite Atlas is a feature in Unity that allows you to pack multiple Sprite textures into a single texture asset. </span><span class="kobospan" id="kobo.446.2">This is particularly useful for optimizing and improving the performance of your game, as it reduces the number of draw calls by combining multiple Sprites into </span><span><span class="kobospan" id="kobo.447.1">one texture.</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.448.1">Here are some key points about Sprite Atlas </span><span><span class="kobospan" id="kobo.449.1">in Unity:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.450.1">Draw call optimization</span></strong><span class="kobospan" id="kobo.451.1">: By using Sprite Atlases, Unity can efficiently render multiple Sprites with a single draw call, which can significantly improve performance, especially on </span><span><span class="kobospan" id="kobo.452.1">mobile devices.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.453.1">Grouping textures</span></strong><span class="kobospan" id="kobo.454.1">: Sprite Atlases enable you to group multiple Sprites or textures together, making it easier to manage and organize your </span><span><span class="kobospan" id="kobo.455.1">game assets.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.456.1">Texture packing</span></strong><span class="kobospan" id="kobo.457.1">: Unity’s Sprite Atlas system performs automatic texture packing, arranging individual Sprites within the Atlas to minimize wasted space and optimize </span><span><span class="kobospan" id="kobo.458.1">texture usage.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.459.1">Mipmapping</span></strong><span class="kobospan" id="kobo.460.1">: Sprite Atlases support mipmapping, which helps improve the rendering quality of textures when they are viewed from </span><span><span class="kobospan" id="kobo.461.1">a distance.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.462.1">Atlas variants</span></strong><span class="kobospan" id="kobo.463.1">: Unity allows you to create different variants of Sprite Atlases for different platforms or screen resolutions, ensuring optimal performance across </span><span><span class="kobospan" id="kobo.464.1">various devices.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.465.1">Integration with Unity Editor</span></strong><span class="kobospan" id="kobo.466.1">: You can create and manage Sprite Atlases directly within the Unity Editor, making it convenient for game developers to visualize and adjust </span><span><span class="kobospan" id="kobo.467.1">their assets.</span></span></li></ul></li>
<li class="calibre11"><span class="kobospan" id="kobo.468.1">Design </span><a id="_idIndexMarker336" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.469.1">alignment using a transparent </span><span><span class="kobospan" id="kobo.470.1">image overlay:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.471.1">When provided with a designer’s view sample, you can overlay an image representing the final result with slight transparency. </span><span class="kobospan" id="kobo.471.2">This allows you to align and organize the view according to </span><span><span class="kobospan" id="kobo.472.1">the design.</span></span></li></ul></li>
<li class="calibre11"><span class="kobospan" id="kobo.473.1">Using the UI </span><span><span class="kobospan" id="kobo.474.1">Extensions package:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.475.1">Discover the UI Extensions package, a valuable toolkit that significantly amplifies the capabilities of Unity’s native UI system. </span><span class="kobospan" id="kobo.475.2">Here’s an overview of its </span><span><span class="kobospan" id="kobo.476.1">key features:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.477.1">Extensive controls</span></strong><span class="kobospan" id="kobo.478.1">: With over 70 additional UI controls, it offers advanced text fields (auto-complete, password masking, multi-line), sliders, progress bars, checkboxes, toggles, color pickers, dropdowns, list views, tree views, grids, tooltips, modal windows, context menus, toolbars, docking panels, </span><span><span class="kobospan" id="kobo.479.1">and more.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.480.1">Customization flexibility</span></strong><span class="kobospan" id="kobo.481.1">: Enjoy extensive customization options for existing UI elements, including the addition of shadows, outlines, and other visual effects, animation of properties (position, color, size), and the creation of custom layouts </span><span><span class="kobospan" id="kobo.482.1">and interactions.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.483.1">Utility functions</span></strong><span class="kobospan" id="kobo.484.1">: Benefit from various helpful utility functions for easy alignment and positioning of elements. </span><span class="kobospan" id="kobo.484.2">Moreover, discover a shortcut for anchoring elements to corners, particularly useful for managing multiple resolutions, especially in </span><span><span class="kobospan" id="kobo.485.1">mobile games.</span></span></li></ul></li></ul><p class="calibre3"><span class="kobospan" id="kobo.486.1">This </span><a id="_idIndexMarker337" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.487.1">package provides a robust set of tools and features, making UI development in Unity more flexible </span><span><span class="kobospan" id="kobo.488.1">and efficient.</span></span></p></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.489.1">Now that we understand practical tips and architectural pattern (MVC and MVVM) structures, let’s dive into creating a UI system using C# to efficiently handle UI behavior in our </span><span><span class="kobospan" id="kobo.490.1">Unity project.</span></span></p>
<h1 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor092" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.491.1">Creating a UI system using C#</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.492.1">In this </span><a id="_idIndexMarker338" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.493.1">section, we will create a C# system for handling UI behavior, leveraging optimization tips and the MVC structure to achieve our objectives. </span><span class="kobospan" id="kobo.493.2">This involves creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.494.1">UIManager</span></strong><span class="kobospan" id="kobo.495.1"> class to oversee views, a </span><strong class="source-inline"><span class="kobospan" id="kobo.496.1">BaseView</span></strong><span class="kobospan" id="kobo.497.1"> class containing core view logic, and a practical example demonstrating the implementation of the </span><span><span class="kobospan" id="kobo.498.1">UI system.</span></span></p>
<h2 id="_idParaDest-89" class="calibre7"><a id="_idTextAnchor093" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.499.1">The UIManager class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">To kick </span><a id="_idIndexMarker339" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.501.1">off this system, we’ll establish a base class called </span><strong class="source-inline"><span class="kobospan" id="kobo.502.1">UIManager</span></strong><span class="kobospan" id="kobo.503.1">. </span><span class="kobospan" id="kobo.503.2">This</span><a id="_idIndexMarker340" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.504.1"> class will handle the invocation of </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">show</span></strong><span class="kobospan" id="kobo.506.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">hide</span></strong><span class="kobospan" id="kobo.508.1"> functions for views and will act as a container for all the views. </span><span class="kobospan" id="kobo.508.2">For each scene, we’ll create a child of </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">UIManager</span></strong><span class="kobospan" id="kobo.510.1">, responsible for controlling the views within that specific scene. </span><span class="kobospan" id="kobo.510.2">This scene-specific manager will hold all the views, providing us with better control over them. </span><span class="kobospan" id="kobo.510.3">This setup allows us to hide all views, ensuring that only one view is active at a time, which is advantageous </span><span><span class="kobospan" id="kobo.511.1">for performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.512.1">The </span><a id="_idIndexMarker341" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.513.1">following code block provides a sample of the </span><strong class="source-inline"><span class="kobospan" id="kobo.514.1">UIManager</span></strong><span class="kobospan" id="kobo.515.1"> base class, which</span><a id="_idIndexMarker342" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.516.1"> includes generic functions for showing and </span><span><span class="kobospan" id="kobo.517.1">hiding views:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.518.1">
public class UIManager : Singleton&lt;UIManager&gt;
{
    public GenericDictionary&lt;Type, BaseView&gt; views = new GenericDictionary&lt;Type, BaseView&gt;();
    private BaseView lastActiveView;
    protected override void Awake()
    {
        base.Awake();
    }
    // Register a view with the UIManager
    public void RegisterView&lt;T&gt;(T view) where T : BaseView
    {
        if (view != null &amp;&amp; !views.ContainsKey(typeof(T)))
        {
            views.Add(typeof(T), view);
        }
    }
    // Show a view
    public void ShowView&lt;T&gt;() where T : BaseView
    {
        if (views.ContainsKey(typeof(T)))
        {
            var view = views[typeof(T)];
            // Show the new view
            view.Show();
            lastActiveView = view;
        }
        else
        {
            Debug.LogError("The View Of Type is Not Exist " + typeof(T).ToString());
        }
    }
    public void HideView&lt;T&gt;()
    {
        if (views.ContainsKey(typeof(T)))
        {
            var view = views[typeof(T)];
            if (view.IsVisible())
                view.Hide();
        }
    }
    // Hide the currently active view
    public void HideActiveView()
    {
        if (lastActiveView != null)
        {
            lastActiveView.Hide();
            lastActiveView = null;
        }
    }
    public BaseView GetView(Type viewType)
    {
        if (views.ContainsKey(viewType)) return views[viewType];
        else return null;
    }
    public T GetView&lt;T&gt;()
    {
        if (views.ContainsKey(typeof(T))) return (T)Convert.ChangeType(views[typeof(T)], typeof(T));
        else return (T)Convert.ChangeType(null, typeof(T));
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.519.1">In the </span><a id="_idIndexMarker343" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.520.1">preceding code block, we employed generic functions to</span><a id="_idIndexMarker344" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.521.1"> handle the showing and hiding of views based on their type directly, avoiding the use of strings for </span><span><span class="kobospan" id="kobo.522.1">improved performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.523.1">We begin by registering the view and adding it to the dictionary, enabling us to hide or show it throughout the gameplay session. </span><span class="kobospan" id="kobo.523.2">Additionally, we have functions to retrieve the view when needed, allowing access or performing specific actions on </span><span><span class="kobospan" id="kobo.524.1">that view.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.525.1">Utilizing UIManager</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.526.1">To utilize </span><a id="_idIndexMarker345" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.527.1">this class, we can create child classes for each scene and either attach this component to a GameObject or simply place it on the main canvas of </span><span><span class="kobospan" id="kobo.528.1">the scene.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.529.1">As evident in the upcoming code block, we have </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">HUDManager</span></strong><span class="kobospan" id="kobo.531.1">, which inherits from </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">UIManager</span></strong><span class="kobospan" id="kobo.533.1">. </span><span class="kobospan" id="kobo.533.2">We will attach it to the main canvas of the gameplay scene to manage and control all views associated with </span><span><span class="kobospan" id="kobo.534.1">this scene:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.535.1">
    public class HUDManager : UIManager
    {
        //Override Methods or Add new Logic here
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.536.1">In the following figure, you’ll notice the </span><strong class="source-inline"><span class="kobospan" id="kobo.537.1">HUDManager</span></strong><span class="kobospan" id="kobo.538.1"> component connected to the </span><span><span class="kobospan" id="kobo.539.1">main canvas:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer063">
<span class="kobospan" id="kobo.540.1"><img alt="Figure 5.8 – The HUDManager component" src="image/B22017_05_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.541.1">Figure 5.8 – The HUDManager component</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.542.1">Now, we</span><a id="_idIndexMarker346" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.543.1"> can proceed to the other key component of the UI system, which is the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.544.1">BaseView</span></strong></span><span><span class="kobospan" id="kobo.545.1"> class.</span></span></p>
<h2 id="_idParaDest-90" class="calibre7"><a id="_idTextAnchor094" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.546.1">The BaseView class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.547.1">In the </span><a id="_idIndexMarker347" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.548.1">UI system, we require a foundational class for all views, encompassing </span><a id="_idIndexMarker348" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.549.1">core functions that define the view’s behavior, actions, or logic during </span><strong class="source-inline"><span class="kobospan" id="kobo.550.1">hide</span></strong><span class="kobospan" id="kobo.551.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.552.1">show</span></strong><span class="kobospan" id="kobo.553.1"> operations. </span><span class="kobospan" id="kobo.553.2">While the UI manager is responsible for invoking these functions, the underlying logic resides in the base class. </span><span class="kobospan" id="kobo.553.3">We predominantly utilize </span><strong class="source-inline"><span class="kobospan" id="kobo.554.1">hide</span></strong><span class="kobospan" id="kobo.555.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.556.1">show</span></strong><span class="kobospan" id="kobo.557.1"> canvas processes for efficiency, and for animations during these operations, we leverage the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.558.1">DoTween</span></strong></span><span><span class="kobospan" id="kobo.559.1"> package.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.560.1">In the following code block, you’ll find the </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">BaseView</span></strong><span class="kobospan" id="kobo.562.1"> class along with its </span><span><span class="kobospan" id="kobo.563.1">core functions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.564.1">
    public abstract class BaseView : MonoBehaviour
    {
        private Canvas canvas;
        public bool isActiveView;
        public GameData gameData;
        public UITween tweenComponent;
        protected virtual void Start()
        {
            canvas = GetComponent&lt;Canvas&gt;();
        }
        // Show this view
        public virtual void Show()
        {
            isActiveView = true;
            canvas.enabled = true;
            gameObject.SetActive(true);
            PlayTweens(true);
            ShowView();
        }
        public virtual void ShowView()
        {
        }
        // Hide this view
        public virtual void Hide()
        {
            PlayTweens(false);
        }
        private void OnOutTweenComplete()
        {
            isActiveView = false;
            canvas.enabled = false;
        }
        public virtual void HideCanvas()
        {
            canvas.enabled = false;
        }
        // Return true if this view is currently visible
        public bool IsVisible()
        {
            return canvas.enabled;
        }
        private void PlayTweens(bool state)
        {
            if (state)
            {
                tweenComponent?.PlayInTween();
            }
            else
            {
                if (tweenComponent == null)
                {
                    OnOutTweenComplete();
                }
                else
                {
                    tweenComponent.PlayOutTween(OnOutTweenComplete);
                }
            }
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.565.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">BaseView</span></strong><span class="kobospan" id="kobo.567.1"> class serves</span><a id="_idIndexMarker349" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.568.1"> as a foundational element within our UI system, facilitating essential functionalities crucial for managing views in Unity projects. </span><span class="kobospan" id="kobo.568.2">At its core, this class offers methods to both show and hide views seamlessly. </span><span class="kobospan" id="kobo.568.3">Moreover, it seamlessly integrates with </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">tween</span></strong><span class="kobospan" id="kobo.570.1"> components, enabling the application of animations during view transitions. </span><span class="kobospan" id="kobo.570.2">Beyond its fundamental functions, the </span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">BaseView</span></strong><span class="kobospan" id="kobo.572.1"> class provides a suite of auxiliary methods, offering invaluable support for implementing the intricate logic of </span><span><span class="kobospan" id="kobo.573.1">our game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">Now that we understand the functionality of the </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">BaseView</span></strong><span class="kobospan" id="kobo.576.1"> class, let’s proceed to grasp the functionality of the </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">UITween</span></strong><span class="kobospan" id="kobo.578.1"> component, which is utilized for animating </span><span><span class="kobospan" id="kobo.579.1">the views.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.580.1">The UITween component</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.581.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.582.1">UITween</span></strong><span class="kobospan" id="kobo.583.1"> component </span><a id="_idIndexMarker350" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.584.1">serves as a wrapper that I’ve</span><a id="_idIndexMarker351" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.585.1"> created for utilizing </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">DoTween</span></strong><span class="kobospan" id="kobo.587.1">, simplifying the process of adding and removing animations in the Inspector for showing or </span><span><span class="kobospan" id="kobo.588.1">hiding views.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.589.1">You can locate all of these classes and additional resources in the GitHub repository, the link to which is mentioned in the Technical </span><span><span class="kobospan" id="kobo.590.1">requirements section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.591.1">In the following figure, you’ll observe the </span><strong class="source-inline"><span class="kobospan" id="kobo.592.1">UITween</span></strong><span class="kobospan" id="kobo.593.1"> component. </span><span class="kobospan" id="kobo.593.2">This serves as a sample class, and we can adjust it to suit </span><span><span class="kobospan" id="kobo.594.1">our game.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer064">
<span class="kobospan" id="kobo.595.1"><img alt="Figure 5.9 – The UITween component" src="image/B22017_05_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.596.1">Figure 5.9 – The UITween component</span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.597.1">Utilizing BaseView</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.598.1">To</span><a id="_idIndexMarker352" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.599.1"> utilize the </span><strong class="source-inline"><span class="kobospan" id="kobo.600.1">BaseView</span></strong><span class="kobospan" id="kobo.601.1"> class, all you need to do is create a child class for each view in the game, enabling the use of core functions. </span><span class="kobospan" id="kobo.601.2">Afterward, you can incorporate specific logic for </span><span><span class="kobospan" id="kobo.602.1">each view.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.603.1">In the following code block, you’ll see an example of the </span><strong class="source-inline"><span class="kobospan" id="kobo.604.1">BaseView</span></strong> <span><span class="kobospan" id="kobo.605.1">class usage:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.606.1">
    public class TopBarView : BaseView
    {
        protected override void Start()
        {
            base.Start();
            StartUIManager.Instance.RegisterView&lt;TopBarView&gt;(this);
            Show();
        }
       //Add here logic for displaying the currencies for the player
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.607.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">TopBar</span></strong><span class="kobospan" id="kobo.609.1"> class, functioning</span><a id="_idIndexMarker353" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.610.1"> as a view class, will be responsible for displaying elements such as the player’s currency in the game. </span><span class="kobospan" id="kobo.610.2">Simply attach the </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">TopBar</span></strong><span class="kobospan" id="kobo.612.1"> class to a </span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">TopBar</span></strong><span class="kobospan" id="kobo.614.1"> Canvas GameObject in your game scene, and </span><span><span class="kobospan" id="kobo.615.1">you’re done.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.616.1">In the following figure, you’ll observe the </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">TopBarView</span></strong><span class="kobospan" id="kobo.618.1"> component attached to </span><span><span class="kobospan" id="kobo.619.1">its canvas:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer065">
<span class="kobospan" id="kobo.620.1"><img alt="Figure 5.10 – The TopBarView component" src="image/B22017_05_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.621.1">Figure 5.10 – The TopBarView component</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.622.1">This </span><a id="_idIndexMarker354" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.623.1">system serves as an abstract framework for the UI system, providing a foundation that can be customized or extended with additional logic as needed for the game. </span><span class="kobospan" id="kobo.623.2">Feel free to tailor and expand upon this structure according to the specific requirements of </span><span><span class="kobospan" id="kobo.624.1">your game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">Next, let’s take an example to see how MVVM would </span><span><span class="kobospan" id="kobo.626.1">be implemented.</span></span></p>
<h2 id="_idParaDest-91" class="calibre7"><a id="_idTextAnchor095" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.627.1">Implementing MVVM</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.628.1">Implementing </span><a id="_idIndexMarker355" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.629.1">the MVVM  structure in Unity involves separating the logic and data management from the UI elements. </span><span class="kobospan" id="kobo.629.2">Let’s look at an example implementation of MVVM </span><span><span class="kobospan" id="kobo.630.1">in Unity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.631.1">In the following code block, </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">PlayerData</span></strong><span class="kobospan" id="kobo.633.1"> represents the data structure, such as player level </span><span><span class="kobospan" id="kobo.634.1">and score:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.635.1">
// Model
public class PlayerData
{
    public int playerLevel;
    public int playerScore;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.636.1">In the following code block, </span><strong class="source-inline"><span class="kobospan" id="kobo.637.1">PlayerViewModel</span></strong><span class="kobospan" id="kobo.638.1"> acts as an intermediary between the model and the view. </span><span class="kobospan" id="kobo.638.2">It holds the logic for data manipulation and exposes properties that the view can </span><span><span class="kobospan" id="kobo.639.1">bind to:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.640.1">
// ViewModel
public class PlayerViewModel : MonoBehaviour
{
    private PlayerData playerData;
    // Properties for data binding
    public int PlayerLevel =&gt; playerData.playerLevel;
    public int PlayerScore =&gt; playerData.playerScore;
    private void Start()
    {
        playerData = new PlayerData();
    }
    public void UpdatePlayerData(int level, int score)
    {
        playerData.playerLevel = level;
        playerData.playerScore = score;
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.641.1">In the </span><a id="_idIndexMarker356" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.642.1">following code block, </span><strong class="source-inline"><span class="kobospan" id="kobo.643.1">PlayerView</span></strong><span class="kobospan" id="kobo.644.1"> represents the UI elements and is responsible for displaying data from </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">ViewModel</span></strong><span class="kobospan" id="kobo.646.1">. </span><span class="kobospan" id="kobo.646.2">It subscribes to </span><strong class="source-inline"><span class="kobospan" id="kobo.647.1">ViewModel</span></strong><span class="kobospan" id="kobo.648.1"> events and updates UI elements based on changes </span><span><span class="kobospan" id="kobo.649.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.650.1">ViewModel</span></strong></span><span><span class="kobospan" id="kobo.651.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.652.1">
// View
public class PlayerView : MonoBehaviour
{
    [SerializeField] private PlayerViewModel playerViewModel;
    private void Start()
    {
        // Subscribe to ViewModel events
        playerViewModel.UpdatePlayerData(1, 100); // Example initialization
    }
    private void Update()
    {
        // Example of data binding
        Debug.Log("Player Level: " + playerViewModel.PlayerLevel);
        Debug.Log("Player Score: " + playerViewModel.PlayerScore);
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.653.1">This </span><a id="_idIndexMarker357" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.654.1">structure allows for a clear separation of concerns, with </span><strong class="source-inline"><span class="kobospan" id="kobo.655.1">ViewModel</span></strong><span class="kobospan" id="kobo.656.1"> handling the logic and data manipulation while the view focuses solely on UI representation. </span><span class="kobospan" id="kobo.656.2">Data binding ensures that changes in </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">ViewModel</span></strong><span class="kobospan" id="kobo.658.1"> automatically reflect in the view, promoting a more organized and maintainable </span><span><span class="kobospan" id="kobo.659.1">code base.</span></span></p>
<h1 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor096" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.660.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.661.1">In this chapter, we learned how to improve our game interfaces using C#. </span><span class="kobospan" id="kobo.661.2">We started by getting better at making the parts of the UI work faster. </span><span class="kobospan" id="kobo.661.3">Then, we figured out ways to organize and control the different views in our game. </span><span class="kobospan" id="kobo.661.4">The skills you picked up here gave you the tools to make your UI look good and run smoothly based on what your </span><span><span class="kobospan" id="kobo.662.1">game needs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.663.1">In the upcoming </span><a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.664.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.665.1">, we’ll dive into handling game data using C#. </span><span class="kobospan" id="kobo.665.2">We’ll learn how to organize and save game information in Unity. </span><span class="kobospan" id="kobo.665.3">These skills will help us manage game progress, save and load game states, and create features that use stored data. </span><span class="kobospan" id="kobo.665.4">As you continue on this coding adventure, you’ll discover new ways to handle game data effectively with C#. </span><span class="kobospan" id="kobo.665.5">Get ready for more coding challenges in the upcoming chapter. </span><span><span class="kobospan" id="kobo.666.1">Happy coding!</span></span></p>
</div>
</body></html>