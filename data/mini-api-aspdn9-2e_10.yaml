- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Profiling and Identifying Bottlenecks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析和识别瓶颈
- en: As your minimal API project evolves, the potential for performance bottlenecks
    increases. Working with data, making connections over networks, and running business
    logic and calculations – all these activities have a performance cost. If configured
    the wrong way, these activities could incur a higher than necessary cost.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您最小的API项目不断发展，性能瓶颈的可能性增加。处理数据、在网络中进行连接以及运行业务逻辑和计算——所有这些活动都有性能成本。如果配置不当，这些活动可能会产生比必要更高的成本。
- en: 'In this chapter, we are going to explore strategies for analyzing resource
    utilization, identifying common bottlenecks, and implementing them. We will cover
    the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨分析资源利用率、识别常见瓶颈并实施它们的策略。我们将涵盖以下内容：
- en: An introduction to profiling and performance monitoring
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析和监控简介
- en: Profiling tools and techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析工具和技术
- en: Common performance bottlenecks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见性能瓶颈
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Visual Studio 2022 or Visual Studio code running, at minimum,
    a new ASP.NET core minimal API project. It is recommended to use the code from
    the previous chapter, as we will be working with performance examples within the
    context of the **MyCompany** API project. Because the examples in this chapter
    are run against the code examples in [*Chapter 10*](B20968_10.xhtml#_idTextAnchor154)
    , you will need to have Entity Framework installed as per the instructions in
    the previous chapter. (See the *Configuring Entity Framework in minimal API projects*
    section in [*Chapter 9*](B20968_09.xhtml#_idTextAnchor143) .)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要运行Visual Studio 2022或Visual Studio code，并创建一个新的ASP.NET core最小API项目。建议使用上一章的代码，因为我们将在**MyCompany**
    API项目的上下文中处理性能示例。由于本章的示例是针对第10章的代码示例运行的（见[B20968_10.xhtml#_idTextAnchor154]），您需要按照上一章的说明安装Entity
    Framework。（参见第9章的*在最小API项目中配置Entity Framework*部分[B20968_09.xhtml#_idTextAnchor143]。）
- en: An introduction to profiling and performance monitoring
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析和监控简介
- en: At the beginning of this chapter, we established that the code we run in a minimal
    API application will incur performance costs, some of which could be presented
    as bottlenecks, hampering the efficiency of the overall system. To remedy this,
    we can leverage a profiling tool, also known as a profiler.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们确定了在最小API应用程序中运行的代码将产生性能成本，其中一些可能表现为瓶颈，阻碍整体系统的效率。为了解决这个问题，我们可以利用性能分析工具，也称为分析器。
- en: Introducing the profiler
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍分析器
- en: 'A **profiler** is a piece of software that measures the cost of running code.
    While your API application runs, the profiler will provide telemetry that outlines
    how expensive certain areas of the code base are in terms of resource usage. This
    allows us to identify areas of inefficiency, which is critical to optimizing the
    performance of your minimal API applications. This is an important practice for
    many reasons, not limited to the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器**是一段测量代码运行成本的软件。当您的API应用程序运行时，分析器将提供遥测数据，概述代码库中某些区域的资源使用成本。这使我们能够识别效率低下的区域，这对于优化最小API应用程序的性能至关重要。这出于许多原因，不仅限于以下内容：'
- en: '**Scalability** : The ability to ensure that your code will be able to perform
    at an increasing rate of demand.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：确保您的代码能够以不断增长的需求率执行的能力。'
- en: '**Availability** : Access to the API to outside clients is paramount. If clients
    cannot access the API because of a lack of available hardware resources, the application
    has lost availability.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：外部客户端访问API至关重要。如果由于缺乏可用硬件资源，客户端无法访问API，则应用程序已失去可用性。'
- en: '**Security** : The connection between the client and API should not be open
    for any longer than necessary. If your API takes a long time to complete a request,
    the connection is open for longer, leaving more opportunities for malicious activity
    to occur.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：客户端和API之间的连接不应比必要的更长。如果您的API完成请求需要很长时间，连接就会保持更长时间，这为恶意活动提供了更多机会。'
- en: '**Cost** : The financial cost of not optimizing a system can be severe. If
    production servers frequently require upgrades because of software bottlenecks,
    each scale-up of the hardware incurs financial costs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：未优化系统可能带来的财务成本可能非常严重。如果生产服务器因软件瓶颈而频繁需要升级，每次硬件升级都会产生财务成本。'
- en: '**User experience** : Ensuring that your API runs as quickly as possible ensures
    that people will have a positive experience, securing repeat usage of the application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验**：确保您的API尽可能快速运行，这样可以确保人们会有积极的体验，从而确保应用程序的重复使用。'
- en: '**Error detection** : While profiling allows for the detection of bottlenecks,
    it can also indirectly reveal other bugs in the code base that may not have been
    detected by unit or integration testing.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检测**：虽然分析允许检测瓶颈，但它也可以间接揭示代码库中可能未被单元或集成测试检测到的其他错误。'
- en: 'Along the same vein, the advantages of profiling minimal APIs are considerable:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，分析最小API的优势是相当可观的：
- en: '**Latency reduction** : With profiling, response times can be increased, resulting
    in a much more responsive API.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟降低**：通过分析，响应时间可以增加，从而使得API响应更加迅速。'
- en: '**Optimal hardware usage** : Profiling can help you see where you are overconsuming
    resources such as CPU, memory, and I/O.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳硬件使用**：分析可以帮助您看到您在过度消耗资源（如CPU、内存和I/O）的地方。'
- en: '**Preventative measures** : Running a profiler to identify potential optimizations
    allows developers to get ahead of potential future issues, letting them make planned
    changes rather than reactionary ones.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预防措施**：运行分析器以识别潜在的优化，让开发者能够提前解决可能出现的未来问题，使他们能够做出计划性的改变，而不是反应性的改变。'
- en: '**Maintenance** : Overall, a more performant code base is usually easier to
    maintain. If the minimal API application is easy to maintain, it will likely see
    a more frequent release cadence.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**：总的来说，性能更好的代码库通常更容易维护。如果最小的API应用程序易于维护，它可能会看到更频繁的发布周期。'
- en: Next, let’s look at some performance metrics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些性能指标。
- en: Performance metrics
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能指标
- en: Before releasing an application for general use, it is difficult to predict
    how an API will cope under heavy load in an accurate way without performing stress
    testing and gathering the resulting data. **Performance monitoring** can help
    by providing insights into how your code is performing in specific scenarios.
    This data in the form of metrics can inform how you optimize your code as you
    approach release. One of the key things you need to understand from performance
    metrics is how the resources on the machine hosting the API handle a high volume
    of requests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布应用程序供公共使用之前，不进行压力测试和收集结果数据，很难准确预测API在重负载下的表现。**性能监控**可以通过提供关于代码在特定场景下表现的见解来帮助。这些以指标形式的数据可以告知您在接近发布时如何优化代码。您需要从性能指标中理解的关键一点是，机器上运行的API资源如何处理大量请求。
- en: 'Profiling can monitor various resources within a minimal API and its dependencies,
    including the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分析可以监控最小API及其依赖项内的各种资源，包括以下内容：
- en: '**Response times** : The amount of time it takes for a request to be handled
    by the API, with a response being returning the client.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：API处理请求并返回响应给客户端所需的时间。'
- en: '**Throughput** : The volume of data flowing through a connection at any given
    time.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：在任何给定时间内通过连接流动的数据量。'
- en: '**CPU processing** : The amount of processing being completed by the API host’s
    CPU during requests, or even on other background tasks not related to a client
    request.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU处理**：API主机CPU在请求期间或甚至在其他与客户端请求无关的背景任务中完成的处理量。'
- en: '**Memory** : The amount of RAM being consumed by the application at any given
    time.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：在任何给定时间内应用程序消耗的RAM量。'
- en: Having access to metrics allows us to start identifying potential bottlenecks
    so that we can then take steps to address them in the minimal API code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获取到指标使我们能够开始识别潜在的瓶颈，这样我们就可以采取措施在最小的API代码中解决它们。
- en: For example, the profiler might show a sudden increase in CPU usage during a
    particular operation. This may indicate that the operation is written in a sub-optimal
    way (e.g., an unnecessary loop or iteration over a collection).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，分析器可能会显示在特定操作期间CPU使用量的突然增加。这可能会表明该操作是以次优的方式编写的（例如，不必要的循环或集合上的迭代）。
- en: With some understanding of profiling and performance monitoring, let’s take
    a look at some tools and techniques for the former.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在对分析器和性能监控有一些了解之后，让我们来看看一些分析器的工具和技术。
- en: Profiling tools and techniques
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析工具和技术
- en: 'There are many different profiling tools available, but for the purposes of
    developing minimal APIs in ASP.NET, we will be looking at two examples: the Visual
    Studio profiler and BenchmarkDotNet. The former is a GUI-based tool, whereas the
    latter is a library that we can add as a dependency to our project.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的分析工具有很多，但为了开发 ASP.NET 中的最小 API，我们将探讨两个示例：Visual Studio 分析器和 BenchmarkDotNet。前者是一个基于
    GUI 的工具，而后者是一个库，我们可以将其添加到项目中作为依赖项。
- en: 'Each of these tools has its strengths in particular use cases, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的每一个都有其特定的用例优势，如这里所示：
- en: '**The Visual Studio profiler** : It is integrated into the IDE and provides
    live performance data and CPU and memory metrics. It is ideal for capturing a
    quick profile, performing basic performance analysis, and identifying areas of
    high CPU and memory usage.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio 分析器**：它集成到 IDE 中，提供实时性能数据和 CPU 以及内存指标。它非常适合快速捕获分析、执行基本性能分析以及识别
    CPU 和内存使用量高的区域。'
- en: '**BenchmarkDotNet** : It can be installed as a package within a .NET project
    and is adept at micro-benchmarking. It is used for establishing baseline performance
    and the fine-tuning of code.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BenchmarkDotNet**：它可以作为一个包安装到 .NET 项目中，擅长于微基准测试。它用于建立基线性能和代码的微调。'
- en: There are several other potential choices that are not free, such as dotTrace
    by JetBrains, which is a very competent profiler that can provide the usual resource
    consumption metrics along with some very in-depth views of the call tree and events
    over a timeline. I can certainly recommend dotTrace, but as it is not free, we
    will keep things simple by exploring profiling examples in the Visual Studio profiler
    and BenchmarkDotNet.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些可能的选择不是免费的，例如 JetBrains 的 dotTrace，它是一个非常强大的分析器，可以提供通常的资源消耗指标，以及一些非常深入的对调用树和事件随时间线视图。我当然可以推荐
    dotTrace，但由于它不是免费的，我们将通过在 Visual Studio 分析器和 BenchmarkDotNet 中探索分析示例来保持简单。
- en: Profiling in Visual Studio
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 中的分析
- en: 'Let us start by setting up profiling in Visual Studio:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Visual Studio 中设置分析开始：
- en: Open the **MyCompany** API example in Visual Studio. Then, click **Debug** ,
    and select **Performance Profiler** . You will see several different options on
    the screen for various kinds of profiling. For this example, we are going to profile
    CPU usage to demonstrate profiling.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 **MyCompany** API 示例。然后，点击 **调试** ，并选择 **性能分析器** 。屏幕上将显示针对各种类型分析的不同选项。对于本例，我们将分析
    CPU 使用情况以演示分析过程。
- en: Tick **CPU Usage** and click **Start** .
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打勾 **CPU 使用情况** 并点击 **开始** 。
- en: '![Figure 10.1: The profiling configuration screen](img/B20968_10_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：分析配置屏幕](img/B20968_10_01.jpg)'
- en: 'Figure 10.1: The profiling configuration screen'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：分析配置屏幕
- en: The aim will be to start profiling so that it is capturing CPU usage data in
    the background while we are interacting with the API. Once the application stops,
    a report will be generated that will give us a breakdown of CPU usage over time,
    which we can then track back to specific lines of code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目标将是开始分析，以便在我们在与 API 交互的同时，它在后台捕获 CPU 使用数据。一旦应用程序停止，将生成一个报告，它将给出 CPU 使用量随时间的变化分析，然后我们可以将其追踪回特定的代码行。
- en: After starting the profiler (ensure that it is recording) your API project will
    also start running. Interact with the API by calling the **GetEmployeeById** endpoint,
    passing an ID value for an existing employee record. You will notice when you
    make the request that the profiler updates in real time. You should see an increase
    in CPU usage as soon as the request starts, which settles down again once the
    request has completed.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始分析器（确保它在记录）后，您的 API 项目也将开始运行。通过调用 **GetEmployeeById** 端点与 API 交互，传递现有员工记录的
    ID 值。您会注意到，在发出请求时，分析器会实时更新。您应该会看到 CPU 使用量在请求开始时立即增加，一旦请求完成，又会恢复平静。
- en: Once you have made some requests to the API, click the **Stop Collection** button
    in the top-left corner of the screen, and then click the **CPU Usage** tab (around
    a quarter of the way down the screen toward the left). The result should be a
    diagnostic report showing the peaks and dips in CPU usage across the time being
    profiled.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦向 API 发送了一些请求，请点击屏幕左上角的 **停止收集** 按钮，然后点击 **CPU 使用情况** 选项卡（屏幕左侧大约四分之一的位置）。结果应该是一个诊断报告，显示在分析时间段内
    CPU 使用情况的峰值和低谷。
- en: '![Figure 10.2: The profiler report for CPU usage](img/B20968_10_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：CPU 使用情况的分析报告](img/B20968_10_02.jpg)'
- en: 'Figure 10.2: The profiler report for CPU usage'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：CPU 使用情况的分析报告
- en: As you can see in *Figure 10* *.2* , there was a spike in CPU usage at the beginning
    of the profiling session. This was at the point that a **GET** request was made
    to the **employees** endpoint, with the API handling the request by returning
    an **Employee** object with the given ID.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*图10.2*中看到的，在分析会话开始时CPU使用量出现了峰值。这是在向**employees**端点发出**GET**请求时发生的，API通过返回具有给定ID的**Employee**对象来处理请求。
- en: There is a wealth of information that can be filtered in this view. Suffice
    it to say, a whole book could be written on profiling in .NET alone. However,
    by way of example, click the **Open Details** button toward the top-right corner
    of the **CPU** **Usage** pane.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中可以过滤出大量信息。仅举一例，关于.NET的分析可以写成一整本书。然而，为了举例说明，点击**CPU使用**面板右上角的**打开详细信息**按钮。
- en: The details shown on the screen following this will provide more detailed information
    about the code that consumes various percentage levels of CPU for the given time.
    There are several key views, such as the **Call Tree** view, which shows the nested
    relationships between function and method calls (i.e., *what* *called what* ).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示的详细信息将提供关于在给定时间内消耗各种CPU百分比级别的代码的更详细信息。有几个关键视图，例如**调用树**视图，它显示了函数和方法调用之间的嵌套关系（即*什么调用了什么*）。
- en: '![Figure 10.3: The Call Tree view, showing the CPU consumed by functions at
    each level of the tree](img/B20968_10_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3: 调用树视图，显示树中各层函数的CPU消耗](img/B20968_10_03.jpg)'
- en: 'Figure 10.3: The Call Tree view, showing the CPU consumed by functions at each
    level of the tree'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '图10.3: 调用树视图，显示树中各层函数的CPU消耗'
- en: The **Functions** view is quite useful in the sense that it can be used to identify
    which specific lines of code are consuming higher amounts of CPU. By sorting this
    view by **Total CPU% descending** , you can quickly identify the top consumer
    of CPU. This can be beneficial when performing optimization on a minimal API,
    as you can gain insights into the underlying functions’ impact on an endpoint’s
    response time for example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**视图非常有用，因为它可以用来识别哪些特定的代码行消耗了更多的CPU。通过按**总CPU%降序**排序这个视图，你可以快速识别CPU消耗量最大的部分。这在优化最小API时可能很有益处，因为你可以了解底层函数对端点响应时间的影响，例如。'
- en: What is more, any of the entries in this view can be double-clicked to reveal
    the original source code, with the CPU usage annotated next to the function signature.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这个视图中的任何条目都可以双击以显示原始源代码，并在函数签名旁边标注CPU使用情况。
- en: The **Caller/Callee** view, which demonstrated what functions are called by
    and what they themselves call, is particularly insightful in this request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用者/被调用者**视图，展示了哪些函数被调用以及它们自身调用了什么，在这个请求中尤其具有洞察力。'
- en: Take the example in *Figure 10* *.4* . We can see that for the current function
    in **EmployeeService** , **GetEmployeeById()** , the CPU resource was consumed
    at **51.42%** . Going deeper, we can see that the function is called into a method
    within Entity Framework Core. In this case, the function was **FirstOrDefault()**
    .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以*图10.4*为例。我们可以看到，对于当前在**EmployeeService**中的函数**GetEmployeeById()**，CPU资源消耗了**51.42**%。进一步分析，我们可以看到该函数被调用到Entity
    Framework Core中的某个方法。在这种情况下，该函数是**FirstOrDefault()**。
- en: '**FirstOrDefault()** is a **Language Integrated Query** ( **LINQ** ) feature
    that will get the first item in a collection that meets the given condition, or
    it will return a default value, in this case, **null** .'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**FirstOrDefault()**是**语言集成查询**（**LINQ**）的一个特性，它将获取满足给定条件的集合中的第一个项目，或者返回默认值，在这种情况下是**null**。'
- en: What we can see in *Figure 10* *.4* is that of the **51.42%** of CPU usage consumed
    by **GetEmployeeById()** , **50.34%** of that usage was taken up by **FirstOrDefault()**
    ; don’t be surprised if the value you get for the same profiling differs. This
    value should and would vary between machines. The important thing is that you
    are able to see a spike in usage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.4*中我们可以看到，**GetEmployeeById()**消耗了CPU使用的**51.42**%，其中**50.34**%的使用被**FirstOrDefault()**占用；如果你得到的相同分析值有所不同，请不要感到惊讶。这个值应该在不同的机器之间有所变化。重要的是，你能看到使用量的峰值。
- en: '![Figure 10.4: The Caller/Callee view, demonstrating the breakdown of CPU usage
    for the GetEmployeeById() function](img/B20968_10_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4: 调用者/被调用者视图，展示了GetEmployeeById()函数的CPU使用情况分解](img/B20968_10_04.jpg)'
- en: 'Figure 10.4: The Caller/Callee view, demonstrating the breakdown of CPU usage
    for the GetEmployeeById() function'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '图10.4: 调用者/被调用者视图，展示了GetEmployeeById()函数的CPU使用情况分解'
- en: This result demonstrates the percentage of CPU usage spread across each function.
    On its own, this does not necessarily indicate a bottleneck, but it is useful
    information when troubleshooting performance or for general optimization.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果展示了每个函数的CPU使用率百分比。单独来看，这并不一定表明存在瓶颈，但在调试性能或进行一般优化时，这是一条有用的信息。
- en: We could dig into this further by replacing **FirstOrDefault()** with our own
    custom implementation of a loop for finding the first employee with the matching
    ID.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用我们自己的自定义循环实现替换**FirstOrDefault()**来进一步研究这个问题，以找到匹配ID的第一个员工。
- en: 'The loop would look like the example here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 循环看起来就像这里给出的示例：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we run this loop in place of **FirstOrDefault()** , we can check the same
    profiling capture and compare the CPU usage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个循环替换**FirstOrDefault()**，我们可以检查相同的性能分析捕获并比较CPU使用率。
- en: In this case, when running the updated code using a loop, we saw a minor increase
    in CPU usage compared to **FirstOrDefault()** . So, while **FirstOrDefault()**
    is not confirmed to be the most performant method of retrieving **Employee** for
    the calling API endpoint, it is confirmed that our alternative is not as performant.
    This is a process of elimination technique, which is an exercise worth practicing
    across your whole code base.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当使用循环而不是**FirstOrDefault()**运行更新后的代码时，我们看到了CPU使用量略有增加。因此，虽然**FirstOrDefault()**尚未被证实是获取调用API端点**Employee**的最高效方法，但我们的替代方案的性能确实较低。这是一个排除法技术，值得在整个代码库中练习。
- en: '![Figure 10.5: CPU usage for GetEmployeeById() using a foreach loop instead
    of FirstOrDefault()](img/B20968_10_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：使用foreach循环而不是FirstOrDefault()对GetEmployeeById()的CPU使用情况](img/B20968_10_05.jpg)'
- en: 'Figure 10.5: CPU usage for GetEmployeeById() using a foreach loop instead of
    FirstOrDefault()'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：使用foreach循环而不是FirstOrDefault()对GetEmployeeById()的CPU使用情况
- en: As mentioned previously, we could go much further into the Visual Studio profiler,
    but that is beyond the scope of this book. With this foundation, you should now
    have at least one item in your toolset for optimizing minimal APIs. Let us look
    at another useful tool for analyzing API performance – BenchmarkDotNet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以进一步深入Visual Studio分析器，但这超出了本书的范围。有了这个基础，你现在应该至少有一个用于优化最小API的工具。让我们看看另一个用于分析API性能的有用工具——BenchmarkDotNet。
- en: Benchmarking with BenchmarkDotNet
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BenchmarkDotNet进行基准测试
- en: '**BenchmarkDotNet** is an open source .NET library designed to facilitate micro-benchmarking
    in .NET applications. It was created by software engineer, Andrey Akinshin, a
    prominent member of the .NET community specializing in software performance.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**BenchmarkDotNet**是一个开源的.NET库，旨在简化.NET应用程序中的微基准测试。它是由软件工程师Andrey Akinshin创建的，他是.NET社区的一位杰出成员，专注于软件性能。'
- en: The project started around 2014 to provide developers with an easy-to-use tool
    for measuring and comparing the performance of different pieces of code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目始于2014年左右，旨在为开发者提供一个易于使用的工具，用于测量和比较不同代码片段的性能。
- en: The library is available as a NuGet package and will need to be installed in
    order for us to run performance benchmarking against the **MyCompany** API project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该库作为NuGet包提供，我们需要将其安装到**MyCompany** API项目中进行性能基准测试。
- en: To keep things clean, we will perform the benchmarking in another project. However,
    we can stay within the current Visual Studio setup by adding the new benchmarking
    project to the current solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，我们将基准测试放在另一个项目中执行。然而，我们可以通过将新的基准测试项目添加到当前解决方案中，保持在当前的Visual Studio设置中。
- en: In Visual Studio’s Solution Explorer, right-click the current solution and select
    **Add** | **New Project** .
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio的解决方案资源管理器中，右键单击当前解决方案，然后选择**添加** | **新建项目**。
- en: In the **New Project** screen there is a search box at the top of the window
    that allows you to search for a project template. Use this to search for **"C#
    Console App"** . Once you see it, select it and click **"Next"** . You will be
    asked to choose a .NET version. We are using version 9, so leave this selected
    and click **"Create"** .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新建项目**界面中，窗口顶部有一个搜索框，允许你搜索项目模板。使用它来搜索**"C#控制台应用程序"**。一旦看到它，选择它并点击**"下一步"**。你将被要求选择.NET版本。我们使用版本9，所以保持选中并点击**"创建"**。
- en: 'Next, we will need to add the **BenchmarkDotNet** library package to the new
    project via the Package Manager Console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过包管理控制台将**BenchmarkDotNet**库包添加到新项目中：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The new project is in our solution and has the required libraries installed,
    but how is it supposed to be able to reference the dependencies from the minimal
    API project?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目在我们的解决方案中，并且安装了所需的库，但它是如何能够从最小 API 项目中引用依赖项的呢？
- en: The way to address this is to create a project reference. This allows us to
    reference object types across multiple .NET projects. This is especially easy
    when the projects are in the same solution as they are in this example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建一个项目引用。这允许我们在多个 .NET 项目之间引用对象类型。当项目与这个例子一样位于同一个解决方案中时，这尤其容易。
- en: To add the project reference, right-click your new benchmarking project and
    click **Add** | **Project Reference** .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加项目引用，右键单击你的新基准测试项目，然后点击 **添加** | **项目引用**。
- en: You will be presented with a dialog box in which you can browse to the project
    location. Your ASP.NET project should have been compiled as a **Dynamic Link Library**
    ( **DLL** ) so you should be able to select that from the bin folder within your
    ASP.NET project directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个对话框，你可以浏览到项目位置。你的 ASP.NET 项目应该已经被编译为一个 **动态链接库** ( **DLL** )，因此你应该能够从你的
    ASP.NET 项目目录中的 bin 文件夹中选择它。
- en: Now that you have a project reference, you can add using statements to reference
    types in that project as if they had been created within the benchmarking project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了项目引用，你可以添加使用语句来引用该项目中的类型，就像它们是在基准测试项目中创建的一样。
- en: We can now move on to setting up our benchmarks and utilizing the dependencies
    that we would have normally injected, but first, the benchmarks need their own
    class; so, create one called **EmployeeBenchmarks** .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续设置我们的基准测试并利用我们通常注入的依赖项，但首先，基准测试需要它们自己的类；因此，创建一个名为 **EmployeeBenchmarks**
    的类。
- en: 'In this new class, create a private field to hold **EmployeeService** :'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新类中，创建一个私有字段来保存 **EmployeeService**：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we can create a method that accesses the required dependencies. We will
    call this method **Setup()** . We need to annotate this method with an attribute
    – **[** **GlobalSetup]**
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个方法来访问所需的依赖项。我们将把这个方法命名为 **Setup()**。我们需要用属性来注释这个方法 – **[** **GlobalSetup]**
- en: 'Having this attribute means that BenchmarkDotNet will run the logic inside
    **Setup()** before benchmarks run:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个属性意味着 BenchmarkDotNet 会在基准测试运行之前运行 **Setup()** 中的逻辑：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code uses **ServiceCollection** , which will require the **Microsoft.Extensions.DependencyInjection**
    package to be installed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 **ServiceCollection**，这将需要安装 **Microsoft.Extensions.DependencyInjection**
    包。
- en: Inside **Setup()** , we have created the required dependencies and added them
    to **ServiceContainer** so that they are ready to be used at runtime.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Setup()** 中，我们创建了所需的依赖项并将它们添加到 **ServiceContainer** 中，以便它们在运行时可以使用。
- en: We have also retrieved **EmployeeService** and stored it in the private field
    so that our benchmark can call the **GetEmployeeId()** function within it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检索了 **EmployeeService** 并将其存储在私有字段中，以便我们的基准测试可以调用其内部的 **GetEmployeeId()**
    函数。
- en: 'Finally, for this class, we add the benchmark itself, which is the important
    part. We want to create a benchmark for the activity running in Entity Framework
    so we will call the **GetEmployeeId()** function so that it interacts with the
    database via **MyCompanyContext** , and this activity will be recorded by BenchmarkDotNet.
    We are passing a hardcoded ID to **GetEmployeeById()** , because we know that
    the **Employee** record with ID **6** exists and that this is not going to change
    (obviously, you must ensure a record with this ID exists, or change the value
    from **6** to one you know to exist in the database):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这个类，我们添加了基准测试本身，这是重要的部分。我们想要为在 Entity Framework 中运行的活动创建一个基准测试，因此我们将调用
    **GetEmployeeId()** 函数，以便通过 **MyCompanyContext** 与数据库交互，并且这个活动将被 BenchmarkDotNet
    记录。我们向 **GetEmployeeById()** 传递了一个硬编码的 ID，因为我们知道 ID 为 **6** 的 **Employee** 记录存在，并且这不会改变（显然，你必须确保存在具有此
    ID 的记录，或者将值从 **6** 更改为你知道存在于数据库中的值）：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice the presence of the **[Benchmark]** attribute decorating the **GetEmployeeByIdBenchmark()**
    method. This labels the method as being a relevant benchmark that should be run.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 **[Benchmark]** 属性装饰了 **GetEmployeeByIdBenchmark()** 方法。这表明该方法是一个相关的基准测试，应该运行。
- en: 'Now, this is where having a separate console application really helps. In the
    **Main()** method of the benchmark console application’s **Program.cs** class,
    we can simply call the static **BenchmarkRunner** and tell it to run any of the
    benchmarks in the benchmark class, which it will detect based on the presence
    of the **[** **Benchmark]** attribute:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有一个单独的控制台应用程序在这里真的很有帮助。在基准控制台应用程序的**Program.cs**类的**Main()**方法中，我们可以简单地调用静态的**BenchmarkRunner**，并告诉它运行基准类中的任何基准测试，它将根据**[**
    **Benchmark]**属性的存在来检测：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The benchmarking console application can now be run to provide results for any
    methods or functions in **EmployeeBenchmarks** that are annotated with the **[**
    **Benchmark]** attribute.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以运行基准测试控制台应用程序，为**EmployeeBenchmarks**中带有**[** **Benchmark]**属性的任何方法或函数提供结果。
- en: Before running the console application, right-click the console application
    project in Solution Explorer and select **Set as** **Startup Project** .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行控制台应用程序之前，在解决方案资源管理器中右键单击控制台应用程序项目，并选择**设置为** **启动项目**。
- en: Once the console app has finished running, you will see the benchmark output
    in the console window, as well as a series of files published to the **bin** directory
    of the application in a folder called **BenchmarkDotNet.Artifacts** . Here, you
    will find the output to the console, as well as the results organized in HTML,
    Markdown, and Excel formats.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序运行完成后，你将在控制台窗口中看到基准输出，以及一系列发布到应用程序**bin**目录中名为**BenchmarkDotNet.Artifacts**的文件夹中的文件。在这里，你可以找到控制台输出，以及以HTML、Markdown和Excel格式组织的结果。
- en: 'Let’s look at the most important section of the output. In the result shown
    in the console, you’ll notice a table. This table contains the benchmarking information
    for **GetEmployeeById()** :'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出中最重要的一部分。在控制台显示的结果中，你会注意到一个表格。这个表格包含了**GetEmployeeById()**的基准测试信息：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This table shows the average time in microseconds that it took to run **GetEmployeeById()**
    out of several iterations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了运行**GetEmployeeById()**所需的平均时间（以微秒为单位），这是在多次迭代中得出的。
- en: The average time taken is displayed as a mean value, giving us a measurement
    we can use as a basis for performance analysis. It would be advisable to note
    this mean average, and then run benchmarking several more times with different
    inputs, to provide further re-enforcement of this average value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 平均耗时以平均值的形式显示，为我们提供了一个可以用于性能分析的基础测量值。建议记录这个平均值，然后使用不同的输入多次运行基准测试，以进一步证实这个平均值。
- en: The **Error** and **StdDev** columns provide some further supporting information.
    **StdDev** represents the **standard deviation** , which is the amount of variation
    from the average. A smaller standard deviation means that benchmark times were
    consistent. If you see a higher standard deviation, it implies more variability
    in average results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误**和**StdDev**列提供了一些额外的支持信息。**StdDev**代表**标准偏差**，即与平均值的差异量。标准偏差越小，基准时间越一致。如果你看到更高的标准偏差，这意味着平均结果有更大的变异性。'
- en: The **Error** column represents the estimated standard deviation of the mean
    average result, which is an indication of how reliable the result is. The smaller
    the number, the more reliable the result.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误**列表示平均平均结果的估计标准偏差，这是结果可靠性的一个指标。数字越小，结果越可靠。'
- en: Again, it makes sense to run several benchmarks with varying inputs. If you
    are seeing similar standard deviations and errors, you can be confident in the
    accuracy of the results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，运行具有不同输入的几个基准测试是有意义的。如果你看到相似的标准偏差和误差，你可以对结果的准确性有信心。
- en: Release mode
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 发布模式
- en: Your project will need to be built in Release mode for the preceding profiling
    to work. If you see the word **Debug** in a dropdown in the top ribbon of Visual
    Studio, change it to **Release** and then rebuild your project.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的分析工作正常，你的项目需要以发布模式构建。如果你在Visual Studio顶部的工具栏下拉菜单中看到单词**调试**，将其更改为**发布**，然后重新构建你的项目。
- en: Common performance bottlenecks
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见性能瓶颈
- en: 'Let’s look at some common reasons that performance could be degraded and how
    you might address them. These are by no means applicable to every situation, but
    they are well-known bottlenecks:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可能导致性能下降的一些常见原因以及如何解决它们。这些方法并不适用于所有情况，但它们是众所周知的问题瓶颈：
- en: '**Database access** : The bottleneck is caused by slow database queries or
    inefficient use of database connections. To mitigate this, do the following:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库访问**：瓶颈是由缓慢的数据库查询或数据库连接使用不当引起的。为了减轻这种情况，请执行以下操作：'
- en: Use asynchronous database operations ( **async/await** ).
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步数据库操作（**async/await**）。
- en: Optimize SQL queries and use proper indexing. Look at any **WHERE** clauses
    or **JOIN** operations that might be taxing the system.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化SQL查询并使用适当的索引。查看任何可能对系统造成负担的**WHERE**子句或**JOIN**操作。
- en: Implement connection pooling to reduce the number of times new connections need
    to be opened.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现连接池以减少需要打开新连接的次数。
- en: Use a caching system such as ASP.NET’s **IMemoryCache** for frequently accessed
    data.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存系统，如ASP.NET的**IMemoryCache**，来存储频繁访问的数据。
- en: '**I/O operations** : The bottleneck is due to blocking I/O operations, such
    as file or network access. To mitigate this, do the following:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O操作**：瓶颈是由于阻塞I/O操作，如文件或网络访问。为了缓解这种情况，请执行以下操作：'
- en: Use asynchronous I/O operations.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步I/O操作。
- en: Minimize disk and network I/O. Where possible, retrieve commonly required data
    from memory rather than from persistent storage or over a network.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化磁盘和网络I/O。在可能的情况下，从内存中检索常用数据，而不是从持久存储或通过网络。
- en: Use efficient data formats (e.g., JSON instead of XML).
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高效的数据格式（例如，使用JSON而不是XML）。
- en: '**Serialization/deserialization** : The bottleneck arises from slow or inefficient
    serialization and deserialization of data. To mitigate this, do the following:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化/反序列化**：瓶颈源于数据序列化和反序列化的缓慢或低效。为了缓解这种情况，请执行以下操作：'
- en: Use optimized serializers such as **System.Text.Json** instead of **Newtonsoft.Json.**
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用优化的序列化程序，如**System.Text.Json**，而不是**Newtonsoft.Json**。
- en: Minimize the size of the data being serialized.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化序列化数据的尺寸。
- en: '**Middleware pipeline** :The bottleneck is caused by excessive or inefficient
    middleware in the request pipeline. To mitigate this, do the following:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件管道**：瓶颈是由请求管道中过多的或不高效的中间件引起的。为了缓解这种情况，请执行以下操作：'
- en: Review and optimize middleware components.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查和优化中间件组件。
- en: Remove unnecessary middleware.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除不必要的中间件。
- en: Use lightweight middleware.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用轻量级中间件。
- en: '**Logging** : The bottleneck results from extensive or synchronous logging.
    To mitigate this, do the following:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：瓶颈源于广泛的或同步的日志记录。为了缓解这种情况，请执行以下操作：'
- en: Use asynchronous logging.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步日志记录。
- en: Reduce the log verbosity level in production.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中降低日志的详细程度。
- en: Use efficient logging frameworks such as Serilog.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高效的日志框架，如Serilog。
- en: '**Dependency injection (DI)** :The bottleneck is due to the inefficient use
    of dependency injection. To mitigate this, do the following:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入（DI）**：瓶颈是由于依赖注入的不高效使用。为了缓解这种情况，请执行以下操作：'
- en: Use scoped or singleton lifetimes where appropriate.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的情况下使用作用域或单例生命周期。
- en: Avoid unnecessary injections of services. If there is a simpler alternative
    that avoids dependency injection, use it.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的服务注入。如果存在更简单的替代方案，可以避免依赖注入，请使用它。
- en: '**Garbage collection (GC) pressure** : The bottleneck results from excessive
    memory allocation, leading to frequent garbage collection. To mitigate this, do
    the following:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收（GC）压力**：瓶颈源于过度的内存分配，导致频繁的垃圾回收。为了缓解这种情况，请执行以下操作：'
- en: Reduce allocations by reusing objects.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重用对象来减少分配。
- en: Use value types instead of reference types where possible.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用值类型而不是引用类型。
- en: Optimize data structures and avoid large allocations of objects onto the heap
    (relates back to using value types over reference types where possible).
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据结构，并避免在堆上大量分配对象（尽可能使用值类型而不是引用类型）。
- en: '**Network latency** : The bottleneck is caused by high latency in network calls.
    To mitigate this, do the following:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络延迟**：瓶颈是由网络调用中的高延迟引起的。为了缓解这种情况，请执行以下操作：'
- en: Minimize the number of network calls.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化网络调用的数量。
- en: Implement retry policies with exponential backoff.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现具有指数退避的重试策略。
- en: Investigate alternative network protocols, using benchmarking to see whether
    they are less resource-intensive.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查替代网络协议，使用基准测试来查看它们是否资源消耗更少。
- en: By having a general understanding of the most common bottlenecks and how they
    can be mitigated, you will become more vigilant when debugging and reviewing code
    in minimal APIs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对最常见的瓶颈及其缓解方法有一个一般性的了解，你将在调试和审查最小API中的代码时更加警觉。
- en: We will now recap the various topics we have covered in this chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回顾本章中我们涵盖的各种主题。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored at a high level the various pitfalls and mitigation
    options for performance issues in minimal APIs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从高层次探讨了最小API中性能问题的各种陷阱和缓解选项。
- en: We started by outlining the basics of performance analysis and why it is important
    within not just minimal APIs, but in general software engineering.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先概述了性能分析的基本原理以及为什么它在不仅仅是最小化API，而且在一般软件工程中都很重要。
- en: We then reviewed some of the different tools on offer, before narrowing the
    scope of the tools we would use to the Visual Studio profiler and BenchmarkDotNet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们审查了一些不同的工具，在缩小我们使用的工具范围后，将工具聚焦于Visual Studio分析器和BenchmarkDotNet。
- en: Then, we started profiling the **MyCompany** API using the Visual Studio profiler,
    with a breakdown of the various metrics that are outputted into the diagnostic
    report produced by the profiler. This allowed us to find the overall CPU usage
    of a section of a code, but then also to break that down further by its called
    functions lower down in the call tree.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始使用Visual Studio分析器对**MyCompany** API进行性能分析，分析器输出的各种指标被分解到由分析器生成的诊断报告中。这使得我们能够找到代码某一部分的整体CPU使用情况，但随后还可以进一步通过调用树中较低层的被调用函数来分解。
- en: Moving on to BenchMarkDotNet, we implemented the same analysis example undertaken
    by the Visual Studio profiler, this time running a performance benchmark against
    the target method. We then reviewed the output to understand how best to secure
    an accurate benchmark based on the consistency of the error rate and the standard
    deviation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来转向BenchMarkDotNet，我们实现了与Visual Studio分析器相同的分析示例，这次是对目标方法进行性能基准测试。然后我们审查了输出结果，以了解如何根据错误率的稳定性和标准差来确保基准测试的准确性。
- en: Like many topics in this book, this is just a scratch of the surface, but it
    will provide a solid foundation for further optimization of minimal APIs and give
    you a good grounding in analyzing their efficiency.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中的许多主题一样，这只是一个表面的探讨，但它将为最小化API的进一步优化提供一个坚实的基础，并为你分析它们的效率提供一个良好的基础。
- en: Let’s move on to the next chapter, in which we will be exploring ways to use
    asynchronous programming to scale minimal APIs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一章，我们将探讨如何使用异步编程来扩展最小化API。
