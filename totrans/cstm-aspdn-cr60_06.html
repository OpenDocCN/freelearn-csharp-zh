<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-52"><em class="italic"><a id="_idTextAnchor092"/>Chapter 6</em>: Using Different Hosting Models</h1>
			<p>In this chapter, we will talk about how to customize hosting in ASP.NET Core. We will look into the hosting options and different kinds of hosting, and take a quick look at hosting on IIS. This chapter is just an overview. It is possible to go into much greater detail for each topic, but that would fill a complete book on its own!</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Setting up <strong class="source-inline">WebHostBuilder</strong></li>
				<li>Setting up Kestrel</li>
				<li>Setting up <strong class="source-inline">HTTP.sys</strong></li>
				<li>Hosting on IIS</li>
				<li>Using Nginx or Apache on Linux</li>
			</ul>
			<p>The topics in this chapter refer to the hosting layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_6.1_B17996.jpg" alt="Figure 6.1 – ASP.NET Core architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – ASP.NET Core architecture</p>
			<p>This chapter tackles the following topics of the server architecture:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_6.2_B17996.jpg" alt="Figure 6.2 – ASP.NET server architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – ASP.NET server architecture</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor093"/>Technical requirements</h1>
			<p>Fo<a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>r this chapter, we just need to set up a small, empty web application:</p>
			<p class="source-code">dotnet new web -n ExploreHosting -o ExploreHosting</p>
			<p>That's it. Open it with Visual Studio Code:</p>
			<p class="source-code">cd ExploreHosting</p>
			<p class="source-code">code .</p>
			<p><em class="italic">Et voilà</em>! A simple project opens in Visual Studio Code.</p>
			<p>The code for this chapter can be found on GitHub here: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter06</a>.</p>
			<h1 id="_idParaDest-54">Se<a id="_idTextAnchor096"/><a id="_idTextAnchor097"/>tting up WebHostBuilder</h1>
			<p>As in the<a id="_idIndexMarker066"/> last chapter, we will focus on <strong class="source-inline">Program.cs</strong> in this section. <strong class="source-inline">WebHostBuilder</strong> is our friend. This is where we configure and create the web host.</p>
			<p>The following code snippet is the default configuration of every new ASP.NET Core web project we create using <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> in Visual Studio or the <strong class="source-inline">dotnet new</strong> command with the .NET CLI:</p>
			<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p>
			<p class="source-code">var app = builder.Build();</p>
			<p class="source-code">app.MapGet("/", () =&gt; "Hello World!");</p>
			<p class="source-code">app.Run();</p>
			<p>As we already know from previous chapters, the default builder has all the necessary stuff preconfigured. All you require in order to run an application successfully on Azure or an on-premises IIS is configured for you.</p>
			<p>But you are<a id="_idIndexMarker067"/> able to override almost all of these default configurations, including the hosting configuration.</p>
			<p>Next, let's set up Kestrel.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor098"/>Setting up Kestrel</h1>
			<p>After <strong class="source-inline">WebHostBuilder</strong> is created, we can use various functions to configure the builder. Here, we <a id="_idIndexMarker068"/>can see one of them, which specifies the <strong class="source-inline">Startup</strong> class that should be used.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As discussed in <a href="B17996_04_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 4</em></a>, <em class="italic">Configuring and Customizing HTTPS with Kestrel</em>, Kestrel is one possibility when it comes to hosting your application. Kestrel is a web server built into .NET and based on .NET socket implementations. Previously, it was built on top of <strong class="bold">libuv</strong>, which is the same web server that is used by Node.js. Microsoft removed the dependency to <strong class="bold">libuv</strong> and <a id="_idIndexMarker069"/>created their own web server implementation based on .NET sockets.</p>
			<p>In the last chapter, we saw the <strong class="source-inline">UseKestrel</strong> method to configure the Kestrel options:</p>
			<p class="source-code">.UseKestrel((host, options) =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">})</p>
			<p>This first argument is <strong class="source-inline">WebHostBuilderContext</strong> to access already-configured hosting settings or the configuration itself. The second argument is an object to configure Kestrel. This code snippet shows what we did in the last chapter to configure the socket endpoints where the host needs to listen:</p>
			<p class="source-code">builder.WebHost.UseKestrel((host, options) =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    var filename = host.Configuration.GetValue(</p>
			<p class="source-code">        "AppSettings:certfilename", "");</p>
			<p class="source-code">    var password = host.Configuration.GetValue(</p>
			<p class="source-code">        "AppSettings:certpassword", "");</p>
			<p class="source-code">    options.Listen(IPAddress.Loopback, 5000);</p>
			<p class="source-code">    options.Listen(IPAddress.Loopback,  5001,  </p>
			<p class="source-code">        listenOptions  =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            listenOptions.UseHttps(filename, password);</p>
			<p class="source-code">        });</p>
			<p class="source-code">});</p>
			<p>(You might need to add a <strong class="source-inline">using</strong> to <strong class="source-inline">System.Net</strong>.)</p>
			<p>This will<a id="_idIndexMarker070"/> override the default configuration where you are able to pass in URLs, for example, using the <strong class="source-inline">applicationUrl</strong> property of <strong class="source-inline">launchSettings.json</strong> or an environment variable.</p>
			<p>Let's now look at how to set up <strong class="source-inline">HTTP.sys</strong>.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor099"/>Setting up HTTP.sys</h1>
			<p>There is another <a id="_idIndexMarker071"/>hosting option, a different web server implementation. <strong class="source-inline">HTTP.sys</strong> is a pretty mature library, deep within Windows, that can be used to host your ASP.NET Core application:</p>
			<p class="source-code">.UseHttpSys(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">})</p>
			<p><strong class="source-inline">HTTP.sys</strong> is different from Kestrel. It cannot be used in IIS because it is not compatible with the ASP.NET Core module for IIS.</p>
			<p>The main <a id="_idIndexMarker072"/>reason for using <strong class="source-inline">HTTP.sys</strong> instead of Kestrel is <strong class="bold">Windows authentication</strong>, which <a id="_idIndexMarker073"/>cannot be used in Kestrel. You can also use <strong class="source-inline">HTTP.sys</strong> if you need to expose your application to the internet without IIS.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">IIS has been running on top of <strong class="source-inline">HTTP.sys</strong> for years. This means that <strong class="source-inline">UseHttpSys()</strong> and IIS are using the same web server implementation. To learn more about <strong class="source-inline">HTTP.sys</strong>, please read the documentation, links to which can be found in the <em class="italic">Further reading</em> section.</p>
			<p>Next, let's look at using IIS for hosting.</p>
			<h1 id="_idParaDest-57">Hosting o<a id="_idTextAnchor100"/>n IIS</h1>
			<p>An ASP.NET Core application shouldn't be directly exposed to the internet, even if it's supported for Kestrel or <strong class="source-inline">HTTP.sys</strong>. It would be best to have something such as a reverse proxy in<a id="_idIndexMarker074"/> between, or at least a service that watches the hosting process. For ASP.NET Core, IIS isn't just a reverse proxy. It also takes care of the hosting process, in case it breaks because of an error. If that happens, IIS will restart the process. Nginx may be used as a reverse proxy on Linux that also takes care of the hosting process.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Be sure you created a new project or removed the Kestrel configuration of the previous section. This won't work with IIS.</p>
			<p>To host an ASP.NET Core web on IIS or Azure, you need to publish it first. Publishing doesn't only compile the project; it also prepares the project for hosting on IIS, Azure, or a web server on Linux, such as Nginx.</p>
			<p>The following command will publish the project:</p>
			<p class="source-code">dotnet publish -o ..\published -r win-x64</p>
			<p>When viewed in a<a id="_idIndexMarker075"/> system browser, this should look as follows:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_6.3_B17996.jpg" alt="Figure 6.3 – A .NET published folder"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – A .NET published folder</p>
			<p>This produces an output that can be mapped in IIS. It also creates a <strong class="source-inline">web.config</strong> to add settings for IIS or Azure. It contains the compiled web application as a DLL.</p>
			<p>If you publish a self-contained application, it also contains the runtime itself. A self-contained application brings its own .NET Core runtime, but the size of the delivery increases a lot.</p>
			<p>And on IIS? Just create a new web and map it to the folder where you placed the published ou<a id="_idTextAnchor101"/><a id="_idTextAnchor102"/>tput:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_6.4_B17996.jpg" alt="Figure 6.4 – The .NET publishing dialog"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The .NET publishing dialog</p>
			<p>It gets a little <a id="_idIndexMarker076"/>more complicated if you need to change the security, if you have some database connections, and so on. This could be a topic for a separate chapter on its own. </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_6.5_B17996.jpg" alt="Figure 6.5 – Hello World! viewed in a browser"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Hello World! viewed in a browser</p>
			<p><em class="italic">Figure 6.5</em> shows the output of the small <strong class="source-inline">MapGet</strong> in the <strong class="source-inline">Program.cs</strong> of the demo project:</p>
			<p class="source-code">app.MapGet("/", () =&gt; "Hello World!");</p>
			<p>Next up, we'll discuss some alternatives for Linux.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor103"/>Using Nginx or Apache on Linux</h1>
			<p>Publishing an ASP.NET Core application on Linux looks very similar to the way it looks on IIS, but preparing it for the reverse proxy requires some additional steps. You will need a web server such as Nginx or Apache as a reverse proxy that forwards the traffic to Kestrel and the ASP.NET Core application: </p>
			<ol>
				<li>First, you <a id="_idIndexMarker077"/>need to allow your app to accept two specific <a id="_idIndexMarker078"/>forwarded headers. To do this, open <strong class="source-inline">Startup.cs</strong> and<a id="_idIndexMarker079"/> add the following lines to the <strong class="source-inline">Configure</strong> method<a id="_idIndexMarker080"/> before the <strong class="source-inline">UseAuthentication</strong> middleware:<p class="source-code">app.UseForwardedHeaders(new ForwardedHeadersOptions</p><p class="source-code">{</p><p class="source-code">    ForwardedHeaders = ForwardedHeaders.XForwardedFor </p><p class="source-code">        | ForwardedHeaders.XForwardedProto</p><p class="source-code">});</p></li>
				<li>You also need to trust the incoming traffic from the reverse proxy. This requires you to add the following lines to the <strong class="source-inline">ConfigureServices</strong> method:<p class="source-code">Builder.Services.Configure&lt;ForwardedHeadersOptions&gt;(</p><p class="source-code">  options =&gt;</p><p class="source-code">{</p><p class="source-code">    options.KnownProxies.Add(</p><p class="source-code">        IPAddress.Parse("10.0.0.100"));</p><p class="source-code">});</p><p>You might need to add a <strong class="source-inline">using</strong> to <strong class="source-inline">Microsoft.AspNetCore.HttpOverrides</strong>.</p></li>
				<li>Add the IP address of the proxy here. This is just a sample.</li>
				<li>Then, you need to publish the application:<p class="source-code"><strong class="bold">dotnet publish --configuration Release</strong></p></li>
				<li>Copy the build output to a folder called <strong class="source-inline">/var/www/yourapplication</strong>. You should also do a quick test on Linux by calling the following<a id="_idTextAnchor104"/> command:<p class="source-code"><strong class="bold">dotnet &lt;yourapplication.dll&gt;</strong></p></li>
				<li>Here, <strong class="source-inline">yourapplication.dll</strong> is the compiled application, including the path. If it is all working correctly, you should be able to call your web on <strong class="source-inline">http://localhost:5000/</strong>.<p>If it is working, the<a id="_idIndexMarker081"/> application should run as a service. This requires <a id="_idIndexMarker082"/>you to <a id="_idIndexMarker083"/>create a <a id="_idIndexMarker084"/>service file on <strong class="source-inline">/etc/systemd/system/</strong>. Call the file <strong class="source-inline">kestrel-yourapplication.service</strong> and place the following content in it:</p><p class="source-code">[Unit]</p><p class="source-code">Description=Example .NET Web API App running on Ubuntu</p><p class="source-code">[Service]</p><p class="source-code">WorkingDirectory=/var/www/yourapplication</p><p class="source-code">ExecStart=/usr/bin/dotnet/var/www/yourapplication/yourapplication.dll</p><p class="source-code">Restart=always</p><p class="source-code"># Restart service after 10 seconds if the dotnet service crashes:</p><p class="source-code">RestartSec=10</p><p class="source-code">KillSignal=SIGINT</p><p class="source-code">SyslogIdentifier=dotnet-example</p><p class="source-code">User=www-data</p><p class="source-code">Environment=ASPNETCORE_ENVIRONMENT=Production</p><p class="source-code">Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false</p><p class="source-code">[Install]</p><p class="source-code">WantedBy=multi-user.target </p><p>Ensure<a id="_idIndexMarker085"/> that the paths in lines 5 and 6 point to the folder where <a id="_idIndexMarker086"/>you placed the build output. This file defines that your<a id="_idIndexMarker087"/> app should run as a service on the default port. It <a id="_idIndexMarker088"/>also watches the app and restarts it in case it crashes. It also defines environment variables that get passed in to configure your application. See <a href="B17996_01_ePub.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a>, <em class="italic">Customizing Logging</em>, to learn how to configure your application using environment variables.</p></li>
			</ol>
			<p>Next up, we'll see how to configure Nginx.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor105"/>Configuring Nginx</h2>
			<p>Now you can tell <a id="_idIndexMarker089"/>Nginx what to do using the following code:</p>
			<p class="source-code">server {</p>
			<p class="source-code">    listen        80;</p>
			<p class="source-code">    server_name   example.com *.example.com;</p>
			<p class="source-code">    location / {</p>
			<p class="source-code">        proxy_pass         http://localhost:5000;</p>
			<p class="source-code">        proxy_http_version 1.1;</p>
			<p class="source-code">        proxy_set_header   Upgrade $http_upgrade;</p>
			<p class="source-code">        proxy_set_header   Connection keep-alive;</p>
			<p class="source-code">        proxy_set_header   Host $host;</p>
			<p class="source-code">        proxy_cache_bypass $http_upgrade;</p>
			<p class="source-code">        proxy_set_header   X-Forwarded-For</p>
			<p class="source-code">                           $proxy_add_x_forwarded_for;</p>
			<p class="source-code">        proxy_set_header   X-Forwarded-Proto $scheme;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This tells Nginx<a id="_idIndexMarker090"/> to forward calls on port <strong class="source-inline">80</strong> to <strong class="source-inline">example.com</strong>, and subdomains of it to <strong class="source-inline">http://localhost:5000</strong>, which is the default address of your application.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor106"/>Configuring Apache</h2>
			<p>The Apache<a id="_idIndexMarker091"/> configuration looks pretty similar to the Nginx method, and does the same things at the end:</p>
			<p class="source-code">&lt;VirtualHost *:*&gt;</p>
			<p class="source-code">   RequestHeader set "X-Forwarded-Proto </p>
			<p class="source-code">     expr=%{REQUEST_SCHEME}</p>
			<p class="source-code">&lt;/VirtualHost&gt;</p>
			<p class="source-code">&lt;VirtualHost *:80&gt;</p>
			<p class="source-code">    ProxyPreserveHost On</p>
			<p class="source-code">    ProxyPass / http://127.0.0.1:5000/</p>
			<p class="source-code">    ProxyPassReverse / http://127.0.0.1:5000/</p>
			<p class="source-code">    ServerName www.example.com</p>
			<p class="source-code">    ServerAlias *.example.com</p>
			<p class="source-code">    ErrorLog ${APACHE_LOG_DIR}yourapplication-error.log</p>
			<p class="source-code">    CustomLog ${APACHE_LOG_DIR}yourapplication-access.log</p>
			<p class="source-code">    common</p>
			<p class="source-code">&lt;/VirtualHost&gt;</p>
			<p>That's it for Nginx and Apache. Let's now w<a id="_idTextAnchor107"/><a id="_idTextAnchor108"/>rap up this chapter.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor109"/>Summary</h1>
			<p>ASP.NET Core and the .NET CLI already contain all the tools to get them running on various platforms and to set it up to get it ready for Azure and IIS, as well as Nginx. This is super easy and well described in the documentation.</p>
			<p>Currently, we have <strong class="source-inline">WebHostBuilder</strong>, which creates the hosting environment of the applications. In version 3.0, we have <strong class="source-inline">HostBuilder</strong>, which is able to create a hosting environment that is completely independent of any web context. </p>
			<p>ASP.NET Core 6.0 has a feature to run tasks in the background inside the application. To learn more about that, read the next chapter.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor110"/>Further reading</h1>
			<p>For more information you can refer to the following links:</p>
			<ul>
				<li><strong class="bold">Kestrel documentation</strong>: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-6.0</a></li>
				<li><strong class="bold">HTTP.sys documentation</strong>: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys?view=aspnetcore-6.0</a></li>
				<li><strong class="bold">ASP.NET Core</strong>: <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/aspnet-core-module?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/aspnet-core-module?view=aspnetcore-6.0</a></li>
			</ul>
		</div>
	</body></html>