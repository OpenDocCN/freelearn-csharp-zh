- en: Chapter 4.  Basic Pattern Matching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。基本模式匹配
- en: This chapter continues the study of functional programming foundations that
    the previous chapter opened. It covers basic data pattern matching. Pattern matching
    is an essential feature-rich mechanism of powerful data processing that is embedded
    into the F# language's core.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续了上一章开启的功能式编程基础研究。它涵盖了基本的数据模式匹配。模式匹配是嵌入到 F# 语言核心的强大数据处理机制中的一个丰富功能特性。
- en: A good grasp of the F# pattern matching features is an absolute must for an
    enterprise developer because most of the time, enterprise business is revolving
    around sophisticated data transformations in **Line Of Business** ( **LOB** )
    **applications** ([https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/](https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/)
    ) and along ****E** xtract Transform Load** ( **ETL** ) ([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
    ) cycles in data warehousing and business analytics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业开发者来说，熟练掌握 F# 的模式匹配特性是绝对必要的，因为大多数时候，企业业务都是围绕**业务线应用程序**（**LOB**）中的复杂数据转换以及数据仓库和商业分析中的**提取、转换、加载**（**ETL**）周期进行的。[https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/](https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/)
    [https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
- en: I intentionally narrowed down the subject of this chapter to basic pattern matching
    for a merely didactic reason. Usually, F# beginners first grasp pattern matching
    as an imperative switch on steroids or just a semantically equivalent way of coding
    lengthy `if...then...elif...elif... ...else...` expressions. Then, they begin
    to recognize the role of pattern matching in data structures decomposition. And
    finally, the pattern matching knowledge acquisition gets completed with embracing
    **active patterns** .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意将本章的主题缩小到基本模式匹配，仅仅出于教学目的。通常，F# 初学者首先将模式匹配视为强化版的命令式 switch，或者仅仅是语义上等价于编写冗长的
    `if...then...elif...elif... ...else...` 表达式。然后，他们开始认识到模式匹配在数据结构分解中的作用。最后，通过接受**活动模式**，模式匹配的知识获取得以完成。
- en: 'The goal of this chapter is to provide you with a thorough grasp of the pattern
    matching features associated with the F# `match` construction:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是为您提供对与 F# `match` 构造相关的模式匹配特性的全面理解：
- en: The overall composition of this rather complicated language construction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个相当复杂语言结构的整体组成
- en: Tacit assumptions behind the parts of match (the ordering of matching rules
    and completeness of pattern cases, to name a few)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配部分背后的隐含假设（例如匹配规则的顺序和模式案例的完整性等）
- en: Specific kinds of pattern cases and how to build composite cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的模式案例类型以及如何构建复合案例
- en: The decomposition abilities consideration is postponed until the coverage of
    the data structures in the upcoming chapters. Similarly, I will cope with **active
    patterns** when covering the advanced programming techniques of F#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将分解能力考虑推迟到下一章关于数据结构的内容。同样，我将在介绍 F# 的高级编程技术时处理**活动模式**。
- en: An explicit form of pattern matching with match construction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有 match 构造的显式模式匹配形式
- en: 'Explicit `match` construction in F# belongs to control flow elements, along
    with `if-then-else` , or `while-do` . Of other F# bits and pieces, a `match` is
    a relatively complicated combination of the following parts and governing rules:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的显式 `match` 构造属于控制流元素，与 `if-then-else` 或 `while-do` 一起。其他 F# 组件中，`match`
    是以下部分和规则的相对复杂组合：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It works in this manner, that is, `comparison-expression` is juxtaposed with
    each `pattern-expression` beginning with `pattern-expression1` and goes down the
    list until either the first match occurs, or passing `pattern-expressionN` still
    non-matched. If a match is found for `pattern-expressionX` , then the result of
    the entire construction is the result of `result-expressionX` . If no matches
    are found, then `MatchFailureException` is thrown, indicating that the match cases
    were incomplete.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它以这种方式工作，即 `comparison-expression` 与每个以 `pattern-expression1` 开头的 `pattern-expression`
    并置，并沿着列表向下进行，直到第一个匹配发生，或者通过 `pattern-expressionN` 仍然没有匹配。如果找到 `pattern-expressionX`
    的匹配，则整个构造的结果是 `result-expressionX` 的结果。如果没有找到匹配，则抛出 `MatchFailureException`，表示匹配案例不完整。
- en: 'The key points of pattern matching that are often missing by F# beginners on
    the first read are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: F# 初学者在第一次阅读时常常遗漏的模式匹配要点如下：
- en: The `match` construction represents an expression, like any other F# construction
    excluding value binding. This means that the value of one and only one of `result-expressions`
    will be taken for the value of the entire construction (given that a certain matching
    has indeed taken place).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match`构造表示一个表达式，就像任何其他F#构造一样，除了值绑定。这意味着只有一个`result-expressions`的值将被用作整个构造的值（假设确实发生了某种匹配）。'
- en: Every `pattern-expression1` through `pattern-expressionN` must share the same
    type, which is also the same with the type of `comparison-expression` in order
    for the `match` construction to compile.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`pattern-expression1`到`pattern-expressionN`都必须具有相同的类型，这与`比较表达式`的类型也相同，以便`match`构造能够编译。
- en: Every `result-expression1` through `result-expressionN` must share the same
    type in order for the match construction to compile.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使匹配构造能够编译，每个`result-expression1`到`result-expressionN`都必须具有相同的类型。
- en: Listed pattern to result cases are tried at run-time one after another in the
    top-down order. This arrangement prescribes a certain ordering of the cases from
    the standpoint of pattern commonality. More specific patterns must precede less
    specific ones; otherwise, more specific patterns will not have chances to be matched
    ever.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出的模式到结果案例按自顶向下的顺序在运行时依次尝试。这种安排规定了从模式共同性的角度来看案例的某种顺序。更具体的模式必须先于不那么具体的模式；否则，更具体的模式将永远不会有机会被匹配。
- en: The set of alternatives represented by all patterns must be exhaustive; otherwise,
    matching `comparison-expression` not covered by any of the patterns will cause
    `MatchFailureException` .
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可能模式表示的备选方案必须是穷尽的；否则，匹配未由任何模式覆盖的`比较表达式`将导致`MatchFailureException`异常。
- en: More atomic pattern terms can be composed into broader pattern expressions using
    Boolean logic operators OR (`|` ), AND (`&` ), and a special `when` guard.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用布尔逻辑运算符OR（`|`）、AND（`&`）和一个特殊的`when`守卫将更原子的模式项组合成更广泛的模式表达式。
- en: Now, I will walk you through the multiplicity of pattern kinds so that you get
    used to their broad repertoire and become comfortable with getting around `match`
    expressions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将带你了解模式种类的多样性，以便你习惯它们的广泛功能，并变得熟悉`match`表达式的使用。
- en: Matching literals
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配字面量
- en: One of the simplest cases of matching patterns is a pattern represented by a
    literal and assuming a simple `comparison-expression` value equality. Literals
    can be of any numeric, character, or string types. They can also be cases of a
    .NET enumeration (each such case is inherently a symbolic name alias of the integer
    value) or a value decorated with the `[<Literal>]` attribute.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配模式的最简单情况之一是由字面量表示的模式，并假设一个简单的`比较表达式`值相等。字面量可以是任何数值、字符或字符串类型。它们也可以是.NET枚举的实例（每个这样的实例本质上都是整数值的符号名称别名）或带有`[<Literal>]`属性的值。
- en: 'In the following script, I can easily match `int` literals and the `int` value
    aliased as `THREE` , decorated with the `[<Literal>]` attribute (`Ch4_1.fsx` ):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下脚本中，我可以轻松地匹配`int`字面量和被`[<Literal>]`属性装饰的`int`值别名`THREE`（`Ch4_1.fsx`）。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This yields string `"3"` , as expected. However, it wouldn''t be possible to
    mix `int` literals with named `int` constant values from the following script
    (`Ch4_1.fsx` ):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生预期的字符串`"3"`。然而，不可能将`int`字面量与以下脚本（`Ch4_1.fsx`）中的命名`int`常量值混合（即`Multiples.Zero`和`Multiples.Five`，尽管它们是字面量，但被类型化为`Multiples`枚举的成员）。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This yields string `"5"` , although being literals, `Multiples.Zero` and `Multiples.Five`
    are typed as members of the `Multiples` enumeration.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生字符串`"5"`，尽管`Multiples.Zero`和`Multiples.Five`是字面量，但它们被类型化为`Multiples`枚举的成员。
- en: (Besides, if you did not grok this yet, placing almost any text between the
    doubled backticks, such as [PRE3] above, makes this text a valid F# name and,
    when used in moderation, may add to improved code readability).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: （此外，如果你还没有完全理解这一点，将几乎任何文本放在双引号之间，例如上面的[PRE3]，会使这段文本成为一个有效的F#名称，并且在使用得当的情况下，可能会增加代码的可读性）。
- en: Wildcard matching
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通配符匹配
- en: 'If I put the preceding scripts into Visual Studio, the F# source code editor
    will draw a blue warning squiggle line under the [PRE4] comparison expression,
    indicating that the set of rules in this `match` construction is not exhaustive,
    as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将前面的脚本放入Visual Studio，F#源代码编辑器将在[PRE4]比较表达式下绘制一条蓝色的波浪线警告，表明此`match`构造中的规则集不是穷尽的，如下面的截图所示：
- en: '![Wildcard matching](img/Image00018.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![通配符匹配](img/Image00018.jpg)'
- en: An example of an incomplete pattern matching
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不完整模式匹配的例子
- en: 'The compiler even gives a sample value of [PRE5] , which is not going to match.
    Although this value is not present within the definition of type `Multiples` ,
    if I synthetically create this value as `enum<Multiples>(1)` and feed it as an
    argument into `transformB` , the result would be the run-time exception of type
    `Microsoft.FSharp.Core.MatchFailureException` . This situation should raise the
    following question: how would it be possible to put a *match all* rule into the
    `match` , which means anything that was not specified in preceding rules?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器甚至给出了一个示例值 [PRE5]，这个值不会匹配。尽管这个值不在 `Multiples` 类型的定义中，但如果我合成这个值作为 `enum<Multiples>(1)`
    并将其作为参数传递给 `transformB`，结果将是 `Microsoft.FSharp.Core.MatchFailureException` 类型的运行时异常。这种情况应该引发以下问题：如何将
    *match all* 规则放入 `match` 中，这意味着任何在先前规则中未指定的内容？
- en: 'For this purpose, F# offers the special **wildcard pattern ** `_` that matches
    anything that was not matched in the preceding rules. With its help and turning
    to the idiomatic F# way of processing undefined values by presenting the result
    as a value of type `option` , the function processing only legitimate `Multiples`
    values may be defined as shown in the following code (`Ch4_1.fsx` ):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，F# 提供了特殊的 **通配符模式** `_`，它可以匹配在先前规则中未匹配到的任何内容。借助它的帮助，并转向 F# 处理未定义值的惯用方法，即以
    `option` 类型的值呈现结果，仅处理合法 `Multiples` 值的函数可以定义如下代码（`Ch4_1.fsx`）：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, the match within the `transformB'` definition carries the exhaustive set
    of match cases. Any legitimate value of `Multiples` given as `m` will be transformed
    into a correspondent `Somestring option` value, and any non-legitimate value of
    the `m` argument will be transformed into a `None` result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`transformB'` 定义中的匹配包含了一组详尽的匹配情况。任何作为 `m` 给定的 `Multiples` 的合法值都将转换为相应的 `Somestring
    option` 值，而任何 `m` 参数的非合法值都将转换为 `None` 结果。
- en: Arranging matching rules
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排列匹配规则
- en: Wildcard pattern demonstrates the importance of arranging the match cases from
    more specific to less specific. For example, if I put the *match all* third rule
    with the wildcard pattern before the first two rules in the preceding script,
    then the F# compiler will put the blue squiggle line under explicit `Multiples`
    values, indicating that these rules will never be matched (check out `transformB''`
    definition in `Ch4_1.fsx` ).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式展示了从更具体到更不具体的匹配情况排列的重要性。例如，如果我将带有通配符模式的 *match all* 第三规则放在前面脚本中的前两个规则之前，那么
    F# 编译器将在显式的 `Multiples` 值下放置蓝色波浪线，表示这些规则将永远不会匹配（检查 `Ch4_1.fsx` 中的 `transformB''`
    定义）。
- en: Named patterns
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名模式
- en: 'The F# compiler performs a certain analysis when a name (identifier) occurs
    in the position of a pattern case. Strictly speaking, there are some opportunities
    for the name to be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当名称（标识符）出现在模式情况的位置时，F# 编译器会进行某种分析。严格来说，名称有以下几种可能性：
- en: A named literal (such as THREE in the earlier script)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名字面量（例如，在早期脚本中的 THREE）
- en: A case value of a discriminated union (such as `None` if matching an F# `option`
    )
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判别联合的案例值（例如，如果匹配 F# 的 `option` 则为 `None`）
- en: A type of an exception (such as `System.ArgumentException` if matching an exception
    type)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常的类型（例如，如果匹配异常类型则为 `System.ArgumentException`）
- en: A custom name of an active pattern (which will be covered in the upcoming chapters)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动模式的自定义名称（将在后续章节中介绍）
- en: If the name occurrence does not fit any of the previously listed alternatives,
    the name is considered a **variable pattern** ([https://msdn.microsoft.com/en-us/library/dd547125.aspx](https://msdn.microsoft.com/en-us/library/dd547125.aspx)
    ). It is treated similarly to the wildcard pattern, getting the value of `comparison-expression`
    parameter, which can be used in the corresponding `result-expression` . Sounds
    confusing, right? Then let's turn to a sample in order to make this matter clear.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称出现不符合之前列出的任何替代方案，则该名称被视为**变量模式**（[https://msdn.microsoft.com/en-us/library/dd547125.aspx](https://msdn.microsoft.com/en-us/library/dd547125.aspx)）。它被处理得类似于通配符模式，获取
    `comparison-expression` 参数的值，该值可以用在相应的 `result-expression` 中。听起来很复杂，对吧？那么让我们通过一个示例来澄清这个问题。
- en: 'I just took the definition of the `transformA` function from the matching literals
    section, changed the name of the function to `transformA''` , and removed the
    definition of the `THREE` literal from the context (`Ch4_2.fsx` ):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是从匹配字面量部分复制了 `transformA` 函数的定义，将函数名称更改为 `transformA'`，并从上下文（`Ch4_2.fsx`）中移除了
    `THREE` 字面量的定义：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The results of experimenting with this function version are shown in the following
    screenshot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了尝试此函数版本的结果。
- en: '![Named patterns](img/Image00019.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![命名模式](img/Image00019.jpg)'
- en: Turning of a literal pattern into a variable pattern
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将字面量模式转换为变量模式
- en: To begin with, the omission of the literal didn't blow up the script, producing
    just a benign warning that `THREE` might be a misspelled pattern name. Applying
    the function to the argument `50` that is completely off produces the same result
    as before for the legitimate argument value `3` . What gives?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，省略字面量并没有使脚本崩溃，只是产生了一个无害的警告，指出`THREE`可能是一个拼写错误的模式名称。将函数应用于完全偏离的参数`50`，得到的结果与合法参数值`3`相同的结果。这是怎么回事？
- en: No magic here; in accordance with the description identifier, `THREE` was not
    recognized as a named literal, discriminated union case, exception type, or active
    pattern. This finding turned it into a variable pattern playing the role of a
    match-all pattern case, which `result-expression` just blindly outputs as string
    `"3".`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 没有魔法；根据描述标识符，`THREE`没有被识别为命名字面量、区分联合情况、异常类型或活动模式。这个发现使其变成了一个扮演匹配所有模式情况角色的变量模式，`result-expression`只是盲目地将它输出为字符串`"3"`。
- en: In my experience as an F# developer, I faced at least one occasion when this
    seemingly innocuous pattern type transformation typo turned into a nasty bug.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的F#开发者经验中，我至少遇到过一次这种看似无害的模式类型转换错误变成了一个讨厌的bug。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The moral: handle with care, and do not disregard F# compiler warnings!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 道德：小心处理，不要忽视F#编译器的警告！
- en: The as pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: as模式
- en: 'Interestingly, a pattern case may have the `as` clause appended to it. This
    clause binds the matched value to a name that may be used within the corresponding
    `result-expression` of the `match` construction or elsewhere within a local context
    of an outer `let` binding. The following script demonstrates how flexible the
    `as` pattern can be (`Ch4_3.fsx` ):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，一个模式情况可以附加一个`as`子句。这个子句将匹配的值绑定到一个名称，该名称可以在`match`构造的相应`result-expression`或外层`let`绑定的局部上下文中使用。以下脚本演示了`as`模式有多灵活（《Ch4_3.fsx》）：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first case, `r` is bound using `as` to the result of `TryParse` , which
    is the tuple, so the expression `snd r` yields the parsed GUID value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`r`使用`as`绑定到`TryParse`的结果，即元组，因此表达式`snd r`产生了解析的GUID值。
- en: In the second case, `as` bounds `r` to any tuple; however, it must be obvious
    from the match cases sequencing that this case matches the failed GUID parsing
    and the value of argument is a garbage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，`as`将`r`绑定到任何元组；然而，从匹配情况的顺序中可以明显看出，这个情况匹配了失败的GUID解析，并且参数的值是垃圾。
- en: 'The following screenshot reflects firing each of these using `as` binding match
    cases in FSI:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图反映了在FSI中使用`as`绑定匹配情况触发每个这些情况：
- en: '![The as pattern](img/Image00020.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![as模式](img/Image00020.jpg)'
- en: Pattern matching with as binding
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 带有as绑定的模式匹配
- en: Grouping patterns
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组模式
- en: Pattern match cases I've covered until this point can be composed together in
    a manner that resembles the terms of a Boolean expression with OR (`|` ) and AND
    (`&` ) operators. Let me demonstrate this technique by implementing a function
    that accepts two string arguments that represent keys and validates that both
    the given values are non-empty, providing a detailed diagnostics.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我到目前为止所涵盖的模式匹配情况可以以类似于具有OR（`|`）和AND（`&`）运算符的布尔表达式术语的方式组合在一起。让我通过实现一个接受两个表示键的字符串参数并验证提供的值都不为空并提供详细诊断的功能来演示这项技术。
- en: 'You should be able to grasp at this point why I should begin the matching with
    the most specific case when both the keys are empty. The next less specific match
    is represented by two symmetric cases when either the first or the second key
    is empty. Here, in order to demonstrate the flexibility provided by F# patterns
    grouping, I combine these two patterns with Boolean OR and at the same time capture
    key values into the local context with a variable pattern represented by the tuple
    `(x,y)` . For the most generic leftover case, I know that both keys are not empty,
    so just a variable pattern is sufficient here. The sought function definition
    is as follows (`Ch4_4.fsx` ):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该能够理解为什么我应该以最具体的案例开始匹配，当两个键都为空时。下一个不那么具体的匹配由两种对称的情况表示，即第一个或第二个键为空。在这里，为了展示
    F# 模式分组提供的灵活性，我使用布尔 OR 将这两个模式组合起来，同时使用表示为元组 `(x,y)` 的变量模式将键值捕获到局部上下文中。对于最通用的剩余情况，我知道两个键都不为空，所以这里只需要一个变量模式就足够了。所寻求的函数定义如下
    (`Ch4_4.fsx` ):'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although the boolean OR pattern combinator helps reach F# code succinctness
    by combining some cases that require the same transformation expression, boolean
    AND is not used that frequently for combining the pattern cases in regular pattern
    matching practice. However, it gets very relevant when grouping *active patterns*
    , which I will be covering in later chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然布尔 OR 模式组合器通过组合需要相同转换表达式的某些案例来帮助达到 F# 代码的简洁性，但在常规模式匹配实践中，布尔 AND 并不经常用于组合模式案例。然而，当分组
    *活动模式* 时，它变得非常相关，我将在后面的章节中介绍。
- en: Guards
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守卫
- en: At this point, I believe you would agree that pattern matching is a powerful
    data transformation feature. Just to further amplify the facilities considered
    so far, F# offers enhancing `pattern-expressions` with additional matching logic.
    *Guard* is represented by an arbitrary boolean expression that is attached to
    `pattern-expression` using the `when` keyword. The guard kicks in only if its
    `pattern-expression` host has matched. Then, the guard expression is computed,
    and if `true` , it springs the transformation performed by the corresponding `result-expression`
    to the right. Otherwise, the entire rule is considered non matched, and the matching
    continues in an usual manner. The `when` guards can be mixed and matched within
    a `match` construction in a completely arbitrary manner.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我相信你可能会同意模式匹配是一个强大的数据转换功能。为了进一步强调迄今为止考虑的功能，F# 提供了增强 `pattern-expressions`
    的额外匹配逻辑。*守卫* 是一个任意布尔表达式，它使用 `when` 关键字附加到 `pattern-expression` 上。只有当其 `pattern-expression`
    宿主匹配时，守卫才会启动。然后，计算守卫表达式，如果为 `true`，则触发相应的 `result-expression` 右侧执行的转换。否则，整个规则被视为未匹配，匹配将继续以常规方式进行。`when`
    守卫可以在 `match` 构造中完全任意地混合和匹配。
- en: 'To demonstrate `when` guards in action, let me slightly modify the previous
    example. In the case where both keys are not empty, there are two subcases: when
    the keys are equal to each other and when they are not. Furthermore, our function
    would be required to format the result for each of these cases differently.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `when` 守卫的实际应用，让我稍微修改一下之前的例子。在两个键都不为空的情况下，有两种子情况：当键彼此相等时和不相等时。此外，我们的函数需要对这些情况中的每一个进行不同的格式化。
- en: 'All that is required for this modification is just one extra line of code preceding
    the last one (remember that I want to add a more specific match case, and then
    it must go in front of a more generic one). The code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次修改，只需要在最后一行之前添加一行代码（记住，我想添加一个更具体的匹配案例，然后它必须放在一个更通用的案例之前）。代码如下：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's it for this modification. I encourage you to play with both scripts `Ch4_4.fsx`
    and `Ch4_5.fsx` in FSI by entering different arguments provided in the scripts
    and observing the changing function behavior.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这次修改的全部内容。我鼓励你通过 FSI 在 `Ch4_4.fsx` 和 `Ch4_5.fsx` 脚本中输入脚本中提供的不同参数，并观察函数行为的改变。
- en: The alternative syntax for anonymous function performing matching
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数执行匹配的替代语法
- en: F# offers a special syntax to define anonymous functions that perform matching,
    or **pattern matching functions** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions)
    ).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供了一种特殊语法来定义执行匹配的匿名函数，或称为**模式匹配函数**([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions)
    )。
- en: This syntax assumes that the anonymous function has a single parameter that
    is placed at the beginning of the function body in the invisible `match` construction.
    Having this alternative way of defining pattern matching anonymous functions just
    adds to the language succinctness and also better reflects the intent behind defining
    such kind of functions within the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法假设匿名函数有一个参数，该参数放置在函数体开始的不可见 `match` 构造中。仅仅有这种定义模式匹配匿名函数的替代方式，就增加了语言的简洁性，并且更好地反映了在代码中定义此类函数的意图。
- en: 'Continuing with coding exercises, in the latest F# script I will rewrite the
    `validate` function using the alternative syntax. However, to achieve this, it
    is required that you address the following problem. The alternative syntax assumes
    that the pattern matching function has a single argument, while validate has a
    pair of arguments. The way out would be to apply skills acquired after reading
    the previous chapter and performing the currying. The following is the code (`Ch4_6.fsx`
    ):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '继续进行编码练习，在最新的 F# 脚本中，我将使用替代语法重写 `validate` 函数。然而，为了实现这一点，你需要解决以下问题。替代语法假设模式匹配函数只有一个参数，而
    `validate` 函数有一对参数。解决方案将是应用在阅读上一章并执行柯里化后获得的技能。以下是对应的代码 (`Ch4_6.fsx`):'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope that this chapter did not leave stones unturned in the matter of plain
    vanilla pattern matching. You should now be well prepared to overcome typical
    pattern matching challenges that F# beginner programmers experience. I remind
    you that further pattern matching features, namely data decomposition and active
    patterns, will be covered in later chapters in order to preserve the logical flow
    of the material.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章在纯模式匹配方面没有遗漏任何细节。你现在应该已经做好了准备，去克服 F# 初学者程序员通常会遇到的典型模式匹配挑战。我提醒你，数据分解和主动模式匹配等进一步的模式匹配特性将在后面的章节中介绍，以保持材料的逻辑流程。
- en: In the next chapter, I will turn to the exciting subject of *Algebraic Data
    Types* . We will explore how data may be composed too and what are the benefits
    behind the data composition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将转向令人兴奋的主题——*代数数据类型*。我们将探讨数据是如何组合的，以及数据组合背后的好处。
