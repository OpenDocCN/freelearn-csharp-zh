<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor132"/>8</h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor133"/>Navigation in MVVM</h1>
<p>So far in our journey of building the <em class="italic">Recipes!</em> app, we have laid a robust foundation using the MVVM design pattern. Now, there’s one important part missing: navigation – that is, moving between different pages of the app. This chapter will focus on the practical side of navigation within .NET MAUI. We’ll break down our discussion into four key areas:</p>
<ul>
<li>About .NET MAUI Shell</li>
<li>Setting up navigation in a .NET MAUI Shell app</li>
<li>Setting up navigation without .NET MAUI Shell</li>
<li>Passing results back</li>
</ul>
<p>MVVM largely focuses on the separation of concerns, decoupling the logic from the presentation layer. When we integrate navigation within the MVVM architecture, we’re essentially extending the principle of “separation of concerns” to the navigation logic. To implement this effectively, it’s essential to grasp key principles of navigation.</p>
<p>By the end of this chapter, you’ll have a solid grasp of .NET MAUI’s navigation capabilities. Whether you opt to utilize .NET MAUI Shell or stick with traditional navigation methods, you’ll be equipped to make your app’s navigation seamless and user-friendly. It’s time to dive in!</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor134"/>Technical requirements</h1>
<p>We will continue to add functionality to the <em class="italic">Recipes!</em> app throughout this chapter. As always, everything can be found on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter08">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter08</a>. You can start from the code provided in the <code>Start</code> folder to follow along with this chapter. The <code>Finish</code> folder contains the completed code, which you can consult for reference.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor135"/>About .NET MAUI Shell</h1>
<p>.NET MAUI Shell is <a id="_idIndexMarker541"/>an opinionated way to create the structure of a .NET MAUI app. It introduces a more simplified approach to building mobile applications, which can be quite complex when it comes to structuring and navigation. Shell streamlines these aspects by providing a unified, declarative syntax for expressing the structure and navigation pattern of an application.</p>
<p>Being opinionated, .NET MAUI Shell has specific guidelines and conventions it expects developers to follow, with the benefit of reducing boilerplate code and effort. It brings a variety of features to the table, aiming to reduce the complexity of mobile application development:</p>
<ul>
<li><strong class="bold">URI-based navigation</strong>: Shell supports a URI-based navigation scheme, similar to web development <a id="_idIndexMarker542"/>models. Developers can define a <strong class="bold">route</strong> to a particular page. These routes allow for easy and loosely coupled navigation around the app, making the navigation code more straightforward and less error-prone.</li>
<li><strong class="bold">Simplifying complex app structures</strong>: Shell offers out-of-the-box support for common UI elements such as flyout menus, tabs, and navigation bars, and all of them combined. Developers can easily add these structures to their apps and have Shell manage the rendering on different platforms.</li>
<li><strong class="bold">Performance</strong>: Shell also aims to improve performance by handling the life cycle of its components more efficiently, offering faster rendering times.</li>
</ul>
<p>However, the opinionated nature of Shell means it might not be suitable for every application scenario or developer. It provides a predefined structure and expects developers to adhere to it, which can be beneficial for simpler apps but might limit flexibility for more complex scenarios.</p>
<p class="callout-heading">.NET MAUI Shell</p>
<p class="callout">.NET MAUI Shell is a powerful tool in any mobile developer’s toolbox. It provides a high level of abstraction to simplify app development, but developers should evaluate whether its opinionated approach aligns with their project requirements and constraints.</p>
<p>Let’s have a <a id="_idIndexMarker543"/>look at how to leverage Shell in a .NET MAUI app.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor136"/>Setting up Shell</h2>
<p>By default, when<a id="_idIndexMarker544"/> creating a new .NET MAUI app, <code>Shell</code> is already wired up automatically. An <code>AppShell</code> class, which inherits from <code>Microsoft.Maui.Controls.Shell</code>, is generated and an instance of this <code>AppShell</code> class is assigned to the <code>MainPage</code> property of the <code>App</code> class:</p>
<pre class="source-code">
public App()
{
    InitializeComponent();
    <strong class="bold">MainPage = new AppShell();</strong>
}</pre> <p>The value of the <code>MainPage</code> property specifies the first page that will be displayed when the application is launched. In other words, it’s the entry point into your application’s UI. This can be a single content page, a navigation page, a tabbed page, or even a master-detail page. Or, as shown here, when leveraging <code>Shell</code>, it can also be a <code>Shell</code> object. <code>Shell</code> acts as a container for your application’s structure and navigation, defining the initial layout and flow of your application.</p>
<p>Though <code>MainPage</code> is the initial page that’s displayed, it is technically possible to change it at any point in the app’s life cycle to accommodate the needs of your application. For instance, you may initially set <code>MainPage</code> to <code>LoginPage</code>, and once the user successfully logs in, you could then change <code>MainPage</code> to your <code>AppShell</code>.</p>
<p>Within the <code>AppShell</code> class, you define the major structural elements of your application. For instance, if your app includes a flyout menu and several tabbed pages, you can define these elements in your <code>AppShell</code>. Here’s a basic example of what that might look like:</p>
<pre class="source-code">
&lt;Shell.FlyoutHeader&gt;
    ...
&lt;/Shell.FlyoutHeader&gt;
&lt;FlyoutItem Title="Quotes" Icon="badge.png"&gt;
    &lt;Tab Title="MVVM"&gt;
        &lt;ShellContent
            Title="Quote of the Day"
            ContentTemplate="{DataTemplate
              local:MainPage_MVVM}"
            Icon="badge.png" /&gt;
    &lt;/Tab&gt;
    &lt;Tab Title="Not MVVM"&gt;
        &lt;ShellContent
            Title="Quote of the Day"
            ContentTemplate="{DataTemplate local:MainPage}"
            Icon="badge.png" /&gt;
    &lt;/Tab&gt;
&lt;/FlyoutItem&gt;
&lt;FlyoutItem Title="Settings" Icon="settings.png"&gt;
    &lt;ShellContent Title="Settings"
                  ContentTemplate="{DataTemplate
                    local:SettingsPage}" /&gt;
&lt;/FlyoutItem&gt;</pre> <p>The code shown<a id="_idIndexMarker545"/> here will render a shell containing a flyout menu with two items: <code>FlyoutItem</code> represents a distinct section of the app. The <code>Quotes</code> section is defined to contain two tabs, each with its title. The content of each tab is defined by a <code>ShellContent</code> object that references the page to be displayed when the tab is selected. The <code>Settings</code> section only contains a <code>ShellContent</code> item, which refers to <code>SettingsPage</code>. Without .NET MAUI Shell, creating a complex layout with a flyout menu, tabs, and separate sections, while managing the navigation between them, could be quite complex and require a lot of boilerplate code. But with Shell, you can define this structure in a simple, declarative way right in your <code>AppShell</code>, making it easier to manage and update. <em class="italic">Figure 8</em><em class="italic">.1</em> shows what the layout shown here, defined in XAML using Shell, looks like:</p>
<div><div><img alt="Figure 8.1: Flyout items and tabs when using Shell" height="942" src="img/B20941_08_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Flyout items and tabs when using Shell</p>
<p>Not only does <a id="_idIndexMarker546"/>Shell allow us to define the main structure of our app, but it also gives us the ability to define routes. Let’s have a look at that.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor137"/>Routing</h2>
<p>.NET MAUI Shell’s <a id="_idIndexMarker547"/>routing system is based on the concept of named routes, which are essentially unique identifiers, or routes, for pages within your application. This simplifies the process of navigating among pages and introduces a way to loosely couple your navigation logic from your page types. Rather than directly referencing page types, you navigate to registered routes. This enables a level of abstraction as you’re navigating to “a page” registered with a specific name, not directly to a specific page. This allows your concrete page associated with a particular route to be changed without requiring changes in your navigation logic.</p>
<p>We can register a route using the <code>RegisterRoute</code> method on the static <code>Microsoft.Maui.Controls.Routing</code> class. Often, routes are registered in the <code>AppShell</code> class’s constructor, but it can be done anywhere in the app, so long as it happens early on in the application’s life cycle. So, the <code>CreateMauiApp</code> method in the <code>MauiProgram</code> class is also a good candidate. In the <em class="italic">Quote Of The Day</em> app, the registration of routes is done in the latter. Whatever location you choose to register your app’s routes, here’s how it’s done:</p>
<pre class="source-code">
Routing.RegisterRoute("about", typeof(AboutPage));</pre> <p>Once registered, you can navigate to the route like so:</p>
<pre class="source-code">
await Shell.Current.GoToAsync("about");</pre> <p>In addition, Shell supports both absolute and relative navigation. An absolute URI, starting with a slash (<code>/</code>), resets the navigation stack before navigation, whereas a relative URI, not starting with a slash, pushes the navigation operation onto the navigation stack. For clarity, the navigation stack is essentially a history of pages the user has navigated through, allowing for forward and backward navigation in the app.</p>
<p>This named-route-based navigation also supports passing parameters between pages:</p>
<pre class="source-code">
await Shell.Current.GoToAsync("about<code>IDictionary&lt;string, object&gt;</code>:</p>
<pre class="source-code">
await Shell.Current.GoToAsync("about",
    <strong class="bold">new Dictionary&lt;string, object&gt;()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        {"foo", "bar" }</strong>
<strong class="bold">    }</strong>);</pre> <p>The reason I prefer this approach is the fact that this allows for passing complex objects, whereas the query string approach only allows for primitive types. And because I like consistency, I prefer to always use the dictionary.</p>
<p>These parameters, which we pass from one page to another, can be retrieved in different ways. One of them is to let the target page inherit the <code>Microsoft.Maui.Controls.IQueryAttributable</code> interface. As shown here, this interface defines just one method, <code>ApplyQueryAttributes</code>, that needs to be implemented:</p>
<pre class="source-code">
public partial class AboutPage : ContentPage,
  <strong class="bold">IQueryAttributable</strong>
{
...
    <strong class="bold">public void ApplyQueryAttributes(</strong>
<strong class="bold">    IDictionary&lt;string, object&gt; query)</strong>
    {
        lblParameter.Text = $"Parameter {query
          .First().Key}: {query.First().Value}";
    }
}</pre> <p>Moreover, if an instance of a class that implements the <code>IQueryAttributable</code> interface is assigned<a id="_idIndexMarker549"/> as the target page’s <code>BindingContext</code> (such as a ViewModel), that <code>ApplyQueryAttributes</code> method would also be invoked.</p>
<p class="callout-heading">Adhering to MVVM best practices</p>
<p class="callout">I’ve often seen ViewModels inheriting the <code>IQueryAttributable</code> interface to receive navigation parameters. Although that works perfectly well, it goes against one of MVVM’s best practices, which says that ViewModels should be framework agnostic. This interface is .NET MAUI and Shell-specific, so it requires a dependency on these frameworks. Later in this chapter, I’ll show you how to not rely on the <code>IQueryAttributable</code> interface and still be able to receive navigation parameters.</p>
<p>As we mentioned previously, there are also other ways to receive parameters on the navigation target. I’m not going to dive deeper into that as we won’t be relying on that when we implement navigation in MVVM.</p>
<p>Let’s have a look at <a id="_idIndexMarker550"/>one final aspect I want to highlight about Shell before we go further: Shell’s support for DI.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor138"/>Supporting Dependency Injection</h2>
<p>In the previous<a id="_idIndexMarker551"/> chapter, we discussed DI<a id="_idIndexMarker552"/> and briefly touched on the fact that Shell allows pages to be resolved dynamically. This allowed us to define the ViewModel as a dependency of a page, which gets injected through the page’s constructor, as shown here:</p>
<pre class="source-code">
public AboutPage(<strong class="bold">AboutPageViewModel vm</strong>)
{
    InitializeComponent();
    BindingContext = vm;
}</pre> <p>The only caveat here is that the page itself needs to be registered in the <code>IServiceCollection</code>, alongside its dependencies of course. With the following in place, we can navigate to <code>"about"</code> and Shell will resolve <code>AboutPage</code> and its dependencies – in this case, <code>AboutPageViewModel</code> – and inject them:</p>
<pre class="source-code">
Routing.RegisterRoute("about", typeof(AboutPage));
builder.Services.AddTransient&lt;AboutPage&gt;();
builder.Services.AddTransient&lt;AboutPageViewModel&gt;();</pre> <p>There is even a convenient extension method in the .NET MAUI Community Toolkit that does all of this at once. Take a look:</p>
<pre class="source-code">
builder.Services.AddTransientWithShellRoute&lt;AboutPage,
  AboutPageViewModel&gt;("about");</pre> <p>The same method also exists for adding the types as scoped or singleton, of course.</p>
<p>In this section, we merely scratched the surface of .NET MAUI Shell, exploring its routing system and support for DI. We saw how it provides a robust, flexible, and intuitive approach to structuring your application and managing navigation.</p>
<p>However, remember that .NET MAUI Shell has a lot more to offer, including advanced features such as flyout customization, search handling, and life cycle events, among others. For deeper insights into these aspects of .NET MAUI Shell, be sure to visit the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<p>Now that we’ve established a solid understanding of .NET MAUI Shell, it’s time to see how we can leverage it within MVVM. In the next section, we’ll focus on setting up navigation in <a id="_idIndexMarker553"/>our <em class="italic">Recipes!</em> app while<a id="_idIndexMarker554"/> adhering to the MVVM pattern. So, let’s dive right in!</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor139"/>Setting up navigation in a .NET MAUI Shell app</h1>
<p>Effective navigation <a id="_idIndexMarker555"/>within the MVVM pattern begins with an integral component: a <code>NavigationService</code>. This service is the driving force behind MVVM navigation. In essence, a <code>NavigationService</code> is a class that implements an <code>INavigationService</code> interface. The <code>INavigationService</code> interface provides the contract for navigating between pages, defining the various methods needed for such operations. These methods could include operations such as <code>GoToDetailPage()</code>, <code>GoBack()</code>, and others, depending on your specific requirements.</p>
<p>Here’s the beauty of this setup: during the app’s startup, we register a framework-specific implementation of the <code>INavigationService</code> interface with the DI container. It’s a perfect illustration of the power of DI, where we program to an interface, not an implementation. This allows our ViewModels to be completely platform-agnostic. This not only promotes code flexibility and testability but also allows us to replace or modify our <code>NavigationService</code> implementation without affecting the rest of our app.</p>
<p>Before we dive deeper into the setup of an <code>INavigationService</code> and explore how it operates within our <em class="italic">Recipes!</em> app, notice that the UI of the app has changed a little bit. The main UI now shows two tabs: <code>RecipesOverviewPage</code>, and <code>SettingsPage</code>. Let’s have a look at implementing a <code>NavigationService</code> interface that leverages .NET MAUI Shell.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Creating an INavigationService interface</h2>
<p>It all starts with <a id="_idIndexMarker556"/>this interface, which will get injected into the ViewModels that want to navigate. And this is where developers tend to have different opinions. Some developers prefer to have a very slimmed-down interface only containing methods such as <code>GoTo(string name)</code>, <code>GoTo(string name, IDictionary&lt;string, object&gt; parameters)</code>, and <code>GoBack()</code>. This allows for a very generic interface and implementation that can easily be reused. I prefer a more per-app approach where I have methods such as <code>GoToOverview()</code>, <code>GoToDetail(string id)</code>, and others. The big advantage I find in this approach is the fact that when I want to navigate to a certain page, I know exactly what parameters are required to navigate to that page. I also find it easier to unit test and it makes it easier to implement app-specific edge cases. I’ve also seen and used generic implementations over the years, containing methods such as <code>GoTo&lt;TViewModel&gt;()</code> for example. It pretty much comes down to personal preference, use case requirements, and the specific needs of the project. I’ll be demonstrating the approach I typically use and have used successfully over the years. Once you understand the main concept of a <code>NavigationService</code>, please use whatever approach you prefer! Let’s create the <code>INavigationService</code> interface for our <em class="italic">Recipes!</em> app:</p>
<ol>
<li>In the <code>Recipes.Client.Core</code> project, add a new folder by right-clicking the project in the <code>Navigation</code>.</li>
<li>Next, right-click the <a id="_idIndexMarker557"/>newly created folder and select <code>INavigationService</code> as the name for the new interface.</li>
<li>As the <em class="italic">Recipes!</em> app doesn’t have a lot of navigation going on, we can keep the interface pretty simple, as shown here:<pre class="source-code">
public interface INavigationService
{
    Task GoToRecipeDetail(string recipeId);
    Task GoToRecipeRatingDetail(RecipeDetailDto
      recipe);
    Task GoBack();
}</pre><p class="list-inset">The interface currently holds three methods. The <code>GoToRecipeDetail</code> method should navigate to the detail page. It accepts a string parameter representing the ID of the recipe we want to load on that page. The <code>GoToRecipeRatingDetail</code> method should load the ratings overview page of the given <code>RecipeDetailDto</code> object. Finally, there is the <code>GoBack</code> method, which should allow us to programmatically navigate back into the app.</p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">This <code>INavigationService</code> interface holds no reference to .NET MAUI or Shell. It’s just a contract for triggering navigations. The fact the interface is part of the <code>Recipes.Client.Core</code> project already gives away that it is framework agnostic. So, whether you want to leverage Shell or not, this interface probably won’t change.</p>
<p>Now that we have <a id="_idIndexMarker558"/>this interface in place, let’s see how we can implement a <code>NavigationService</code> interface that leverages Shell.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor141"/>Creating and using a NavigationService</h2>
<p>Because <a id="_idIndexMarker559"/>the implementation<a id="_idIndexMarker560"/> of <code>NavigationService</code> is specific to a framework, we are going to add it to the <code>Recipes.Mobile</code> project:</p>
<ol>
<li>Let’s add a <code>Navigation</code> folder to the <strong class="bold">Recipes.Mobile</strong> project by right-clicking the project in the <strong class="bold">Solution Explorer</strong> and selecting <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>.</li>
<li>Now, right-click the <code>NavigationService</code>.</li>
<li>This class needs to implement <code>INavigationService</code>, as shown here:<pre class="source-code">
public class NavigationService : INavigationService
{
    ...
}</pre></li> <li>Now, this is where Shell comes in! Earlier in this chapter, we saw how easy it is to use Shell for navigation: just call <code>Shell.Current.GoToAsync</code> and pass in the name of the page you want to navigate to. Let’s add the following method, which wraps around this <code>GoToAsync</code> method, to our new <code>NavigationService</code> class:<pre class="source-code">
private async Task Navigate(string pageName,
    Dictionary&lt;string, object&gt; parameters)
{
    await Shell.Current.GoToAsync(pageName);
}</pre><p class="list-inset">This <code>Navigate</code> method just calls the <code>GoToAsync</code> method of <code>Shell</code>, passing in the given <code>pageName</code> parameter. We’ll look at the <code>parameters</code> parameter later.</p></li> <li>What remains for <code>NavigationService</code> is implementing the <code>INavigationService</code> interface’s <a id="_idIndexMarker561"/>methods, which<a id="_idIndexMarker562"/> is now pretty easy to do, as shown here:<pre class="source-code">
public Task GoToRecipeDetail(string recipeId)
    =&gt; Navigate("RecipeDetail",
        new () { { "id", recipeId } });
public Task GoToRecipeRatingDetail(RecipeDetailDto
  recipe)
    =&gt;  Navigate("RecipeRating",
        new () { { "recipe", recipe } });
public Task GoBack()
    =&gt;  Shell.Current.GoToAsync("..");</pre><p class="list-inset">The first two methods call the <code>Navigate</code> method we created earlier, passing in the name of the page that needs to be loaded, as well as a dictionary containing the <code>recipeId</code> parameter. The <code>GoBack</code> method calls the <code>GoToAsync</code> method of <code>Shell</code>, passing in "..", signaling we want to navigate up the navigation stack.</p></li> <li>Next, we can go ahead and register this <code>NavigationService</code> in the DI container. Open <code>MauiProgram.cs</code> and add the following:<pre class="source-code">
builder.Services.AddSingleton&lt;INavigationService,
  NavigationService&gt;();</pre></li> </ol>
<p>And with that in place, it’s time to update our ViewModels and add <code>INavigationService</code> as a dependency:</p>
<ol>
<li>Head over to <code>RecipesOverviewViewModel</code> and update its constructor so that it accepts an <code>INavigationService</code>. As before, we should also create a <code>readonly</code> field to hold the injected value:<pre class="source-code">
public class RecipesOverviewViewModel :
  ObservableObject
{
    <strong class="bold">private readonly INavigationService</strong>
<strong class="bold">      navigationService;</strong>
...
    public RecipesOverviewViewModel(
        IRecipeService recipeService,
        IFavoritesService favoritesService,
        <strong class="bold">INavigationService navigationService</strong>)
    {
        <strong class="bold">this.navigationService = navigationService;</strong>
...
    }
}</pre></li> <li>Further down this class, we can now update the <code>NavigateToSelectedDetail</code> method to the following:<pre class="source-code">
private async Task NavigateToSelectedDetail()
{
    if (SelectedRecipe is not null)
    {
        <strong class="bold">await navigationService.GoToRecipeDetail</strong>
<strong class="bold">          (SelectedRecipe.Id);</strong>
        SelectedRecipe = null;
    }
}</pre></li> <li>In <code>RecipesOverviewPage.xaml</code>, the <a id="_idIndexMarker563"/>following <a id="_idIndexMarker564"/>can be removed:<pre class="source-code">
SelectionChanged="CollectionView_SelectionChanged"</pre><p class="list-inset">In the <code>RecipesOverviewPage.xaml.cs</code> file, the <code>CollectionView_SelectionChanged</code> method can be removed as well. Up until now, this is what triggered the navigation from the overview page to the detail page.</p></li> </ol>
<p>Now, we need to give <code>RecipeDetailViewModel</code> the same treatment: inject <code>INavigationService</code> and use it to execute navigation to the <code>RecipeRatingsDetailPage</code>:</p>
<ol>
<li>As before, add an additional parameter to the class’s constructor and keep a reference to it in a <code>readonly</code> field:<pre class="source-code">
public partial class RecipeDetailViewModel :
  ObservableObject
{
    <strong class="bold">private readonly INavigationService</strong>
<strong class="bold">      navigationService;</strong>
...
    public RecipeDetailViewModel(
        IRecipeService recipeService,
        IFavoritesService favoritesService,
        IRatingsService ratingsService,
        <strong class="bold">INavigationService navigationService</strong>)
    {
        <strong class="bold">this.navigationService = navigationService;</strong>
        ...
    }
...
}</pre></li> <li>The following snippet shows how we can update the <code>NavigateToRatings</code> method:<pre class="source-code">
<strong class="bold">private Task NavigateToRatings()</strong>
<strong class="bold">    =&gt; navigationService</strong>
<strong class="bold">        .GoToRecipeRatingDetail(recipeDto);</strong>
}</pre><p class="list-inset">This method gets called when <code>NavigateToRatingsCommand</code> is invoked.</p></li> <li>Finally, we need to head over to the <code>RecipeDetailPage.xaml</code> file and update the <code>TapGestureRecognizer</code> on the <code>HorizontalStackLayout</code>, which shows the rating, to the following:<pre class="source-code">
&lt;HorizontalStackLayout.GestureRecognizers&gt;
    &lt;TapGestureRecognizer <strong class="bold">Command="{Binding</strong>
<strong class="bold">      </strong><strong class="bold">NavigateToRatingsCommand}"</strong> /&gt;
&lt;/HorizontalStackLayout.GestureRecognizers&gt;</pre><p class="list-inset">Tapping this control will now trigger <code>NavigateToRatingsCommand</code>, which we just created, which will call the <code>NavigationService</code> to initiate navigation to the <code>RatingsDetailPage</code>.</p></li> <li>The <code>Ratings_Tapped</code> method in the code-behind of <code>RecipeDetailPage</code> can be deleted as it is no longer of any use.</li>
</ol>
<p>The pages, their <a id="_idIndexMarker565"/>ViewModels, and<a id="_idIndexMarker566"/> their routes, are already registered in <code>MauiProgram</code>’s <code>CreateMauiApp</code> method, as shown here:</p>
<pre class="source-code">
...
builder.Services.AddTransient&lt;RecipesOverviewPage&gt;();
builder.Services.AddTransient&lt;RecipesOverviewViewModel&gt;();
builder.Services.AddTransient&lt;RecipeDetailPage&gt;();
builder.Services.AddTransient&lt;RecipeDetailViewModel&gt;();
builder.Services.AddTransient&lt;RecipeRatingsDetailPage&gt;();
builder.Services.AddTransient&lt;RecipeRatingsDetailViewModel&gt;
();
builder.Services.AddTransient&lt;SettingsPage&gt;();
builder.Services.AddTransient&lt;SettingsViewModel&gt;();
Routing.RegisterRoute("MainPage", 
  typeof (RecipesOverviewPage));
Routing.RegisterRoute("RecipeDetail", 
  typeof (RecipeDetailPage));
Routing.RegisterRoute("RecipeRating", 
  typeof (RecipeRatingsDetailPage));</pre> <p>With all of these changes in place, we can now effectively navigate from one page to another. The injected instance of <code>NavigationService</code> in the ViewModels leverages Shell to<a id="_idIndexMarker567"/> navigate between pages. But there is still one thing missing: passing parameters from one page to another. Let’s see how to add this!</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor142"/>Passing parameters</h2>
<p>As mentioned earlier, although .NET MAUI Shell has a baked-in way of passing parameters, I’m not fond of using that in my ViewModels as it would require my ViewModels to depend on MAUI and Shell. Luckily, a solution to that is not that complex. Moreover, it fits nicely in the broader setup of our <code>NavigationService</code>, as we will discuss later in this chapter.</p>
<p>Let’s introduce a new interface: <code>INavigationParameterReceiver</code>. This interface exposes one method called <code>OnNavigatedTo</code> that receives a dictionary of type <code>Dictionary&lt;string, object&gt;</code> as a single parameter. This interface can be implemented by ViewModels that want to accept navigation parameters. When navigated to a page, the <code>NavigationService</code> can check whether the <code>BindingContext</code> of the new page implements this interface and then call the <code>OnNavigatedTo</code> method, passing in the parameters. Let’s see how we can implement this:</p>
<ol>
<li>First, let’s add the <code>INavigationParameterReceiver</code> interface. Right-click the <code>Navigation</code> folder in the <code>Recipes.Client.Core</code> project and select <code>INavigationParameterReceiver</code> as the name of the interface.</li>
<li>As we mentioned previously, this interface should expose the <code>OnNavigatedTo</code> method. Let’s add this:<pre class="source-code">
public interface INavigationParameterReceiver
{
    Task OnNavigatedTo(Dictionary&lt;string, object&gt;
      parameters);
}</pre></li> <li>Head over to <a id="_idIndexMarker568"/>the <code>Navigate</code> method of the <code>NavigationService</code> class and update it to the following:<pre class="source-code">
private async Task Navigate(string pageName,
    Dictionary&lt;string, object&gt; parameters)
{
    await Shell.Current.GoToAsync(pageName);
    <strong class="bold">if (Shell.Current.CurrentPage.BindingContext</strong>
<strong class="bold">        </strong><strong class="bold">is INavigationParameterReceiver receiver)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        await receiver.OnNavigatedTo(parameters);</strong>
<strong class="bold">    }</strong>
}</pre><p class="list-inset">The preceding code will pass the provided parameters to the ViewModel once Shell has navigated to the new page. We can retrieve the current page by calling <code>Shell.Current.CurrentPage</code>. Once we have the current page, we can check whether the page’s <code>BindingContext</code> implements the <code>INavigationParameterReceiver</code> interface. If it does, we can call the <code>OnNavigatedTo</code> method to pass the provided parameters.</p></li> <li><code>RecipeDetailViewModel</code> can now implement the <code>INavigationParameterReceiver</code> interface, as shown here:<pre class="source-code">
public partial class RecipeDetailViewModel :
  ObservableObject, <strong class="bold">INavigationParameterReceiver</strong>
{
...
    <strong class="bold">public Task OnNavigatedTo(</strong>
<strong class="bold">        Dictionary&lt;string, object&gt; parameters)</strong>
<strong class="bold">        =&gt; LoadRecipe(parameters["id"].ToString());</strong>
<code>OnNavigatedTo</code> method is called, the <code>id</code> parameter is retrieved from the<a id="_idIndexMarker569"/> dictionary and passed to the <code>LoadRecipe</code> method.</p></li> <li>Up until now, the constructor of <code>RecipeDetailViewModel</code> called the <code>LoadRecipe</code> method with a hard-coded ID. This call can now be removed.</li>
<li><code>RecipeRatingsDetailViewModel</code> also needs to be updated for it to be able to receive parameters. The following code block shows how it can implement <code>INavigationParameterReceiver</code>:<pre class="source-code">
public class RecipeRatingsDetailViewModel :
  ObservableObject, <strong class="bold">INavigationParameterReceiver</strong>
{
...
    <strong class="bold">public Task OnNavigatedTo(</strong>
<strong class="bold">        Dictionary&lt;string, object&gt; parameters)</strong>
<strong class="bold">        =&gt; LoadData(parameters["recipe"]</strong>
<strong class="bold">            </strong><strong class="bold">as RecipeDetailDto);</strong>
}</pre><p class="list-inset">Please note that there has been a slight change in the <code>LoadData</code> method signature since the previous chapter. Rather than accepting a string, it now takes a <code>RecipeDetailDto</code> object as its parameter. This is an optimization strategy that aims to avoid over-fetching. When we navigate from <code>RecipeDetailPage</code>, we have already loaded the details of a recipe. Therefore, it’s not needed to reload these same details when we move to <code>RecipeRatingDetailPage</code>. By passing in a <code>RecipeDetailDto</code>, we effectively utilize the data we’ve already fetched.</p></li> </ol>
<p>With <code>INavigationParameterReceiver</code> in place, we can effectively pass navigation parameters from one page to another. Let’s see how we can extend our navigation infrastructure even more to allow us to hook into and manage important parts of the ViewModel’s life <a id="_idIndexMarker570"/>cycle: specifically, the moments of navigation to and from a ViewModel.</p>
<p class="callout-heading">Avoid “magic strings”</p>
<p class="callout">The code samples in this chapter use a lot of “magic strings": specific routes are registered for pages, parameters are passed using exact keys, and navigation requires correct input of these routes and keys. While this makes the code samples simple and clear, it’s risky in practice. A single spelling error can lead to runtime errors that aren’t immediately apparent. To prevent such issues, it’s advisable to use string constants for route names and parameters stored in designated classes. We didn’t follow this best practice here for the sake of simplicity, but keep it in mind when you’re writing your code.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor143"/>Hooking into navigation</h2>
<p>Often, we want to<a id="_idIndexMarker571"/> hook into the navigation process to effectively manage ViewModel states during transitions. This allows us to handle setup and cleanup operations, as well as manage state changes when a ViewModel becomes active or inactive in the application. This strategy is particularly useful for tasks such as subscribing to or unsubscribing from services, loading or saving states, and initiating or canceling network requests.</p>
<p>For that purpose, let’s introduce two new interfaces: <code>INavigatedFrom</code> and <code>INavigatedTo</code>. Just like <code>INavigationParameterReceiver</code>, ViewModels can choose to implement these interfaces if they want to react to certain navigation events. Let’s see what they look like:</p>
<pre class="source-code">
public interface INavigatedFrom
{
    Task OnNavigatedFrom(NavigationType navigationType);
}
public interface INavigatedTo
{
    Task OnNavigatedTo(NavigationType navigationType);
}</pre> <p>Both the <code>OnNavigatedFrom</code> and <code>OnNavigatedTo</code> methods accept one parameter of type <code>NavigationType</code>, which<a id="_idIndexMarker572"/> is an enum. This enum has the following implementation:</p>
<pre class="source-code">
public enum NavigationType
{
    Unknown,
    Forward,
    Back,
    SectionChange,
}</pre> <p>With this <code>enum</code> type, we want to give context to the type of navigation that occurred. The <code>SectionChanged</code> value can be used when the user opens another tab for example or selects another item from <code>FlyoutMenu</code>. As you might expect, the <code>Forward</code> and <code>Back</code> values are used when navigating hierarchically from one page to another.</p>
<p>These methods and values of the <code>NavigationType</code> enum enable nuanced reactions to a wide variety of navigation scenarios. Let’s consider some examples:</p>
<ul>
<li>When the <code>OnNavigatedFrom</code> method of a ViewModel is called with <code>Back</code> as the parameter, we can infer that we’re navigating backward away from this ViewModel. In this context, you should consider stopping any ongoing tasks or network requests related to that ViewModel. The page no longer exists on the <code>NavigationStack</code>, so unsubscribing from messages or events may be wise, allowing any unneeded resources to be reclaimed via garbage collection.</li>
<li>If the <code>OnNavigatedFrom</code> method is invoked with <code>Forward</code> as the parameter, we know the page and its ViewModel remain on the <code>NavigationStack</code>. Therefore, the user can easily navigate back to this page. In this situation, we may also want to clean up specific processes or running tasks, but it’s important to ensure they can be quickly reinstated. When the user navigates back to the ViewModel, the <code>OnNavigatedTo</code> method will be triggered with <code>Back</code> as the parameter, signaling a need to restart previously paused processes.</li>
</ul>
<p>Let’s see how we<a id="_idIndexMarker573"/> can add these additional interfaces to our ViewModels and hook up the necessary code to call the methods these interfaces expose:</p>
<ol>
<li>Add the interfaces (<code>INavigatedFrom</code> and <code>INavigatedTo</code>) and the <code>NavigationType</code> enum, as shown in the earlier code blocks, to the <code>Navigation</code> folder of the <code>Recipes.Client.Core</code> project.</li>
<li>When inheriting from the <code>AppShell</code> class, we can override the <code>OnNavigated</code> method. This method is invoked when a navigation is executed by the Shell framework. This is the ideal place to call into the methods of the interfaces that we’ve introduced. Go ahead to the <code>AppShell</code> class and override this method, as shown here:<pre class="source-code">
protected override async void OnNavigated
  (ShellNavigatedEventArgs args)
{
    var navigationType =
        GetNavigationType(args.Source);
    base.OnNavigated(args);
}</pre><p class="list-inset">The <code>ShellNavigatedEventArgs</code> parameter that’s passed into this method has a <code>Source</code> property. This <code>Source</code> property is of type <code>ShellNavigationSource</code> and indicates how the navigation occurred: <code>Push</code>, <code>Pop</code>, <code>PopToRoot</code>, and so on. We want to translate this to the <code>NavigationType</code> enum we introduced earlier, allowing it to be framework-independent from here on.</p></li> <li>To<a id="_idIndexMarker574"/> translate <code>ShellNavigationSource</code> to <code>NavigationType</code>, create the following <code>GetNavigationType</code> method in the <code>AppShell</code> class:<pre class="source-code">
private NavigationType GetNavigationType
  (ShellNavigationSource source) =&gt;
    source switch
    {
        ShellNavigationSource.Push or
        ShellNavigationSource.Insert
            =&gt; NavigationType.Forward,
        ShellNavigationSource.Pop or
        ShellNavigationSource.PopToRoot or
        ShellNavigationSource.Remove
            =&gt; NavigationType.Back,
        ShellNavigationSource.ShellItemChanged or
        ShellNavigationSource.ShellSectionChanged or
        ShellNavigationSource.ShellContentChanged
            =&gt; NavigationType.SectionChange,
        _ =&gt; NavigationType.Unknown
    };</pre></li> <li>Now, we need to find a way to access the ViewModels of the current and previous page, from within the overridden <code>OnNavigated</code> method. Once we get a hold of them, we can call <code>OnNavigatedFrom</code> and <code>OnNavigatedTo</code> when the ViewModel implements the corresponding interfaces. For that purpose, let’s introduce a new interface: <code>INavigationInterceptor</code>. Here’s what it looks like:<pre class="source-code">
public interface INavigationInterceptor
{
    Task OnNavigatedTo(object bindingContext,
        NavigationType navigationType);
}</pre><p class="list-inset">For now, this<a id="_idIndexMarker575"/> interface only exposes one method: <code>OnNavigatedTo</code>. It accepts a parameter of the <code>object</code> type that represents the <code>BindingContext</code> of the current page. It also accepts a parameter of type <code>NavigationType</code>.</p></li> <li>Add this interface as a constructor parameter to <code>AppShell</code> and call its <code>OnNavigatedTo</code> method from the <code>OnNavigated</code> method of Shell, which we’ve just overridden. The following code block shows how to add this:<pre class="source-code">
public partial class AppShell : Shell
{
    <strong class="bold">readonly INavigationInterceptor interceptor;</strong>
    public AppShell(<strong class="bold">INavigationInterceptor</strong>
<strong class="bold">      interceptor</strong>)
    {
        <strong class="bold">this.interceptor = interceptor;</strong>
        InitializeComponent();
    }
    protected override async void OnNavigated
      (ShellNavigatedEventArgs args)
    {
        var navigationType =
            GetNavigationType(args.Source);
        base.OnNavigated(args);
        <strong class="bold">await interceptor.OnNavigatedTo(</strong>
<strong class="bold">            CurrentPage?.BindingContext,</strong>
<strong class="bold">              navigationType);</strong>
    }
...
}</pre></li> <li>Because<a id="_idIndexMarker576"/> the <code>AppShell</code> class now lacks its default constructor and requires a parameter of type <code>INavigationInterceptor</code>, we need to update our code in the <code>App.xaml.cs</code> file, as shown here:<pre class="source-code">
public App(<strong class="bold">INavigationInterceptor interceptor</strong>)
{
    ...
    <strong class="bold">MainPage = new AppShell(interceptor);</strong>
}</pre><p class="list-inset">The constructor of the <code>App</code> class has been updated so that it accepts a parameter of the <code>INavigationInterceptor</code> type.</p></li> <li>What remains is implementing <code>INavigationInterceptor</code> and registering it in the DI<a id="_idIndexMarker577"/> container. This interface can be implemented by our existing <code>NavigationService</code>. Let’s see how:<pre class="source-code">
Public class NavigationService : INavigationService,
  INavigationInterceptor
{
...
    WeakReference&lt;INavigatedFrom&gt; previousFrom;
    public async Task OnNavigatedTo(object
      bindingContext, NavigationType navigationType)
    {
        if(previousFrom is not null &amp;&amp; previousFrom
            .TryGetTarget(out INavigatedFrom from))
        {
            await from.OnNavigatedFrom
              (navigationType);
        }
        if (bindingContext
            is INavigatedTo to)
        {
            await to.OnNavigatedTo(navigationType);
        }
        if(bindingContext is INavigatedFrom
          navigatedFrom)
            previousFrom = new (navigatedFrom);
        else
            previousFrom = null;
}</pre><p class="list-inset">A lot is going on here, so let’s discuss what happens. Remember that the <code>OnNavigatedTo</code> method is called when we have already navigated. So, we must keep a<a id="_idIndexMarker578"/> reference to the previous page’s <code>BindingContext</code> if we want to call a method on that later on. This reference is kept as <code>WeakReference</code> because we don’t want this reference to cause the object not to be garbage collected and causing memory leaks. First, we check whether the <code>previousFrom</code> field is not null and whether it still holds a reference to a value that implements the <code>INavigatedFrom</code> interface. If we get back a value, the <code>OnNavigatedFrom</code> method is called on the <code>BindingContext</code> of the page we’ve navigated from.</p><p class="list-inset">Next, we check whether the passed-in <code>bindingContext</code> parameter implements the <code>INavigatedTo</code> interface. If that’s the case, the <code>OnNavigatedTo</code> method is called.</p><p class="list-inset">In the end, we check whether the given <code>bindingContext</code> implements the <code>INavigatedFrom</code> interface. If so, we store it in the <code>previousFrom</code> field. If not, the <code>previousFrom</code> field is assigned null.</p></li> <li>It’s important to notice that we’ve introduced state to our <code>NavigationService</code> by keeping track of the <code>BindingContext</code> of the previous page through the <code>previousFrom</code> field. As a result, <code>NavigationService</code> should be registered as Singleton so that throughout the app, the same instance of <code>NavigationService</code> is being used. Moreover, the <code>NavigationService</code> should be resolvable as <code>INavigationService</code> in the ViewModels and as <code>INavigationInterceptor</code> for instantiating the <code>AppShell</code> class. To accommodate this, we can update the registration, as follows:<pre class="source-code">
builder.Services.AddSingleton&lt;NavigationService&gt;();
builder.Services.AddSingleton&lt;INavigationService&gt;(
    c =&gt; c.GetRequiredService&lt;NavigationService&gt;());
builder.Services.AddSingleton&lt;INavigationInterceptor&gt;(
    c =&gt; c.GetRequiredService&lt;NavigationService&gt;());</pre></li> </ol>
<p><code>NavigationService</code> itself is registered as a singleton. We also added singleton registrations <a id="_idIndexMarker579"/>for <code>INavigationService</code> and <code>INavigationIntercepter</code>, both returning the registration of <code>NavigationService</code>. This allows us to register one type for multiple interfaces, all pointing to the same instance.</p>
<p>Go ahead and implement the <code>INavigatedTo</code> and <code>INavigatedFrom</code> interfaces in some ViewModels. Add a breakpoint to the implemented methods, run the app, and see what happens by inspecting the parameter values. For our little <em class="italic">Recipes!</em> app, there is no need to add an implementation to said methods, but as managing ViewModel states during transitions is something developers tend to struggle with in larger apps, I wanted to share how I handle these kinds of scenarios.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/>Setting up navigation without .NET MAUI Shell</h1>
<p>As I mentioned<a id="_idIndexMarker580"/> earlier, Shell is an opinionated way to create the structure of a .NET MAUI app. This might not work for you or your particular project. Not using Shell complicates the implementation of a <code>NavigationService</code> a lot, especially when your app has a complex structure such as tabs or a flyout menu. Let’s focus on a simple hierarchical navigation and see what is needed to implement a <code>NavigationService</code> without relying on another framework.</p>
<p>Luckily, the interfaces we created earlier (<code>INavigationService</code>, <code>INavigatedTo</code>, <code>INavigatedFrom</code>, and <code>INavigationParameterReceiver</code>) are framework-independent and can still be used as the backbone of this implementation:</p>
<ol>
<li>No Shell means no routing. However, I do like the concept of having keys associated with a particular view as it allows for a loosely coupled way of navigating. That’s why we’re creating a static <code>Routes</code> class in the <code>Navigation</code> folder of the <code>Recipes.Mobile</code> project, as shown here:<pre class="source-code">
public static class Routes
{
    static Dictionary&lt;string, Type&gt; routes
        = new Dictionary&lt;string, Type&gt;();
    public static void Register&lt;T&gt;(string key)
        where T : Page
        =&gt; routes.Add(key, typeof(T));
    public static Type GetType(string key)
        =&gt; routes[key];
}</pre><p class="list-inset">This class allows us to map keys to types that inherit from <code>Page</code>.</p></li> <li>Next, instead of using the static <code>Routing.RegisterRoute</code> method to register routes in the <code>MauiProgram</code> class, we can now use our own <code>Routes</code> class, like this:<pre class="source-code">
Routes.Register&lt;RecipesOverviewPage&gt;("MainPage");
Routes.Register&lt;RecipeDetailPage&gt;("RecipeDetail");
Routes.Register&lt;RecipeRatingsDetailPage&gt;
  ("RecipeRating");</pre><p class="list-inset">The <code>Routes.GetType</code> method will allow us to retrieve a key’s <code>Type</code> later.</p></li> <li>Before diving into the implementation of the non-Shell <code>NavigationService</code>, let’s add the following code to the <code>INavigationService</code> interface:<pre class="source-code">
Task GoToOverview();</pre></li> <li>In <code>App.xaml.cs</code>, update<a id="_idIndexMarker581"/> the <code>App</code>’s constructor as shown here:<pre class="source-code">
public App(<strong class="bold">INavigationService navigationService</strong>)
{
    Application.Current.UserAppTheme = AppTheme.Light;
    InitializeComponent();
    <strong class="bold">MainPage = new NavigationPage();</strong>
<strong class="bold">    navigationService.GoToOverview();</strong>
}</pre><p class="list-inset">With the updated code, a class implementing the <code>INavigationService</code> interface will be injected. After assigning a new <code>NavigationPage</code> to the <code>MainPage</code> property, we can call the newly added <code>GoToOverview</code> method on the injected <code>INavigationService</code> for it to navigate to the <code>OverviewPage</code>.</p></li> <li>Now, we can go and start implementing the non-Shell <code>NavigationService</code>. Create a new class called <code>NonShellNavigationService</code> in the <code>Navigation</code> folder of the <code>Recipes.Mobile</code> project. As you might expect, this class needs to implement the <code>INavigationService</code> interface, as shown here:<pre class="source-code">
public class NonShellNavigationService :
INavigationService</pre></li> <li>The first thing we want to add is the <code>Navigation</code> property, which is of type <code>Microsoft.Maui.Controls.INavigation</code>. Through this property, we want to effectively route our navigation. The <code>INavigation</code> interface defines navigation-related <a id="_idIndexMarker582"/>methods and properties. Let’s see what that property looks like:<pre class="source-code">
protected INavigation Navigation
{
    get
    {
        INavigation? navigation =
            Application.Current?.MainPage?.Navigation;
        if (navigation is not null)
            return navigation;
        else
        {
            throw new Exception();
        }
    }
}</pre><p class="list-inset">Through the static <code>Current</code> property of the <code>Application</code> class, we can get to the instance of the application, allowing us to access its <code>MainPage</code> property. The <code>MainPage</code> property, which is of type <code>Page</code>, has a <code>Navigation</code> property of type <code>INavigation</code>, which is exactly what we need.</p></li> <li>Like on <code>NavigationService</code>, which used <code>Shell</code>, we also want to add a private <code>Navigate</code> method<a id="_idIndexMarker583"/> that other methods in this class can use. Here’s what this looks like:<pre class="source-code">
private async Task Navigate(string key,
    Dictionary&lt;string, object&gt; parameters)
{
    var type = Routes.GetType(key);
    var page = ServiceProvider.Current
        .GetService(type) as Page;
    page.NavigatedFrom += Page_NavigatedFrom;
    await Navigation.PushAsync(page);
    if (page.BindingContext
        is INavigationParameterReceiver receiver)
    {
        await receiver.OnNavigatedTo(parameters);
    }
    if (Navigation.NavigationStack.Count == 1)
    {
        if (page.BindingContext
        is INavigatedTo to)
            await to.OnNavigatedTo(NavigationType
              .SectionChange);
    }
}</pre><p class="list-inset">With the given key, we can resolve the type we want to navigate to. Using the <code>ServiceProvider</code>, we can retrieve an instance of the given type, satisfying all of its dependencies. Next, an event handler for the resolved page’s <code>NavigatedFrom</code> event is added before we access our <code>Navigation</code> property and push this page onto the navigation stack with the <code>PushAsync</code> method. This is what executes the effective navigation to the requested page. After the page is pushed, its <code>BindingContext</code> is checked to see whether it implements the <code>INavigationParameterReceiver</code> interface. If that’s the case, its <code>OnNavigatedTo</code> method is called, passing in the navigation parameters. The final thing that happens in this method is that it checks whether the size of <code>NavigationStack</code> is <code>1</code>. This means that we navigated to a page and that there’s only one item on the stack, or in other words, this is the first page we’re navigating <a id="_idIndexMarker584"/>to. If that is the case, we want to call the <code>OnNavigatedTo</code> method on the page’s <code>BindingContext</code> if said <code>BindingContext</code> implements the <code>INavigatedTo</code> interface and pass in <code>NavigationType.SectionChange</code>. With this in place, the <code>OnNavigatedTo</code> method is called on initial navigation.</p></li> <li>In the previous method, we added a handler to the page’s <code>NavigatedFrom</code> event. The following code block shows its implementation:<pre class="source-code">
private async void Page_NavigatedFrom(object sender,
  NavigatedFromEventArgs e)
{
    bool isForwardNavigation =
        Navigation.NavigationStack.Count &gt; 1
        &amp;&amp; Navigation.NavigationStack[^2] == sender;
    if (sender is Page page)
    {
        if (!isForwardNavigation)
        {
            page.NavigatedFrom -= Page_NavigatedFrom;
        }
        await OnNavigatedTo(Navigation.NavigationStack
          .Last().BindingContext,
            isForwardNavigation ? NavigationType
              .Forward : NavigationType.Back);
    }
}</pre><p class="list-inset">As we are focusing on hierarchical navigation, navigation from a page can happen for two reasons: we’re navigating forward to another page or we’re navigating back to the previous page. This is what is determined at the beginning of this<a id="_idIndexMarker585"/> method. As this event is handled after the navigation occurred, we can determine forward navigation by looking at the second-to-last item on the <code>NavigationStack</code>: if that entry equals the sender, it means we navigated forward from the sender to another page. If it wasn’t forward navigation, meaning we’ve navigated back from the page to the previous page, we need to remove the event handler from the page’s <code>NavigateFrom</code> event. We need to do this so that the page has no references and can be garbage collected, avoiding potential memory leaks. Finally, we call the <code>OnNavigated</code> method, passing in the <code>BindingContext</code> of the current page (which is the last item in <code>NavigationStack</code>). Depending on whether it is forward navigation or not, we pass in <code>NavigationType.Forward</code> or <code>NavigationType.Backward</code>.</p></li> <li>The <code>OnNavigatedTo</code> method that is being called in the previous code block might look familiar. That’s because it is completely identical to the <code>OnNavigatedTo</code> method <a id="_idIndexMarker586"/>we had in our previous implementation of the <code>NavigationService</code>:<pre class="source-code">
WeakReference&lt;INavigatedFrom&gt; previousFrom;
private async Task OnNavigatedTo(object
  bindingContext,
    NavigationType navigationType)
{
    if (previousFrom is not null &amp;&amp; previousFrom
        .TryGetTarget(out INavigatedFrom from))
    {
        await from.OnNavigatedFrom(navigationType);
    }
    if (bindingContext
        is INavigatedTo to)
    {
        await to.OnNavigatedTo(navigationType);
    }
    if (bindingContext is INavigatedFrom
      navigatedFrom)
        previousFrom = new(navigatedFrom);
    else
        previousFrom = null;
}</pre></li> <li>Finally, let’s have a look at the implemented methods of the <code>INavigationService</code> interface:<pre class="source-code">
public Task GoBack()
    =&gt; Navigation.PopAsync();
public Task GoToRecipeDetail(string recipeId)
=&gt; Navigate("RecipeDetail",
    new() { { "id", recipeId } });
public Task GoToRecipeRatingDetail(RecipeDetailDto
  recipe)
=&gt; Navigate("RecipeRating",
    new() { { "recipe", recipe } });
public Task GoToOverview()
=&gt; Navigate("Overview", null);</pre><p class="list-inset">They also look very <a id="_idIndexMarker587"/>much like they did in the previous implementation because the <code>Navigate</code> method accepts the same parameters as in the previous sample.</p></li> <li>The only thing that’s left to do is register this <code>NonShellNavigationService</code>:<pre class="source-code">
builder.Services.AddSingleton&lt;INavigationService ,
  NonShellNavigationService&gt;();</pre><p class="list-inset">In this setup, we’re not using <code>INavigationInterceptor</code>, so there’s no need to register that.</p></li> </ol>
<p>With that in place, we’ve successfully created a simple <code>NavigationService</code> that does not leverage .NET MAUI Shell. Many of the core concepts were reused in this example, demonstrating that they are a good level of abstraction. That said, this implementation is very simple and naïve. It lacks the support for modal navigation and navigation inside tabs and doesn’t have anything for handling a flyout menu. This example might give you some ideas and insights, but building a <code>NavigationService</code> from scratch, without leveraging Shell, is quite daunting. In many cases, when Shell is not an option for you or your specific project, I think relying on other third-party frameworks might be the way to go. Libraries such as <em class="italic">FreshMvvm</em> and especially <em class="italic">Prism Library</em> are worth <a id="_idIndexMarker588"/>checking out!</p>
<p>Before concluding this chapter, it’s important to address a potentially unclear aspect: how can we effectively return a result from a child page to its parent?</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor145"/>Passing results back</h1>
<p>In this chapter, we’ve<a id="_idIndexMarker589"/> explored passing parameters from one page to another during forward navigation. But what if we need to take an object, use it as a parameter to navigate to another page, manipulate it there, and then retrieve the updated result?</p>
<p>There are various approaches to achieve this, but the most straightforward method is to add a little extension to our navigation framework and allow parameters to be passed when navigating back. For example, on the <code>SettingsPage</code> of the <em class="italic">Recipes!</em> app, we show the user’s current language. There’s a button that navigates to the <code>PickLanguagePage</code>, where the user can select a different language. The current language needs to be passed from the <code>SettingsPage</code> to the <code>PickLanguage</code> page so that the latter can show the current value. When the user selects a new language, the <code>PickLanguagePage</code> should navigate back to the <code>SettingsPage</code> and pass the selected language as a parameter. <em class="italic">Figure 8</em><em class="italic">.2</em> shows how this looks schematically:</p>
<div><div><img alt="Figure 8.2: Passing values back" height="362" src="img/B20941_08_02.jpg" width="1180"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Passing values back</p>
<p>Let’s explore how to implement this scenario:</p>
<ol>
<li>First, add the <code>GoBackAndReturn</code> method to <code>INavigationService</code>:<pre class="source-code">
Task GoBackAndReturn(Dictionary&lt;string, object&gt;
parameters);</pre><p class="list-inset">By introducing this method, we want to allow a ViewModel to trigger back navigation and pass parameters to the ViewModel of the previous page.</p></li> <li>This method is very easy to implement in both <code>NavigationService</code> and <code>NonShellNavigationService</code>. First, let’s take a look at the implementation<a id="_idIndexMarker590"/> in <code>NavigationService</code>:<pre class="source-code">
public async Task GoBackAndReturn(
    Dictionary&lt;string, object&gt; parameters)
{
    await GoBack();
    if (Shell.Current.CurrentPage.BindingContext
        is INavigationParameterReceiver receiver)
    {
        await receiver.OnNavigatedTo(parameters);
    }
}</pre><p class="list-inset">In this method, we first call the <code>GoBack</code> method. Once the back navigation is executed, we check whether <code>BindingContext</code> of the current page implements the <code>INavigationParameterReceiver</code> interface. If that’s the case, we call its <code>OnNavigatedTo</code> method, passing in the parameters.</p></li> <li>On <code>NonShellNavigationService</code>, this method looks very similar:<pre class="source-code">
public async Task GoBackAndReturn(
    Dictionary&lt;string, object&gt; parameters)
{
    await GoBack();
    if(Navigation.NavigationStack.Last()
      .BindingContext
        is INavigationParameterReceiver receiver)
        {
            await receiver.OnNavigatedTo(parameters);
        }
}</pre><p class="list-inset">We are doing the <a id="_idIndexMarker591"/>same thing here as in the <code>NavigationService</code>, except we’re not using the Shell APIs to retrieve the current page. Instead, we’re getting the current page from <code>NavigationStack</code>.</p></li> <li>Next, let’s add the method that should navigate to <code>PickLanguagePage</code>. Add the <code>GoToChooseLanguage</code> method to the <code>INavigationService</code> interface:<pre class="source-code">
Task GoToChooseLanguage(string currentLanguage);</pre></li> <li>In both <code>ShellNavigationService</code> and <code>NonShellNavigationService</code>, implement the <code>GoToChooseLanguage</code> method, like this:<pre class="source-code">
public Task GoToChooseLanguage(string currentLanguage)
    =&gt; Navigate("PickLanguagePage",
    new() { { "language", currentLanguage } });</pre><p class="list-inset">The registration of <code>PickLanguagePage</code>, its route, and its ViewModel is already done in the <code>CreateMauiApp</code> method of the <code>MauiProgram</code> class, as shown here:</p><pre class="source-code">...
builder.Services.AddTransient&lt;PickLanguagePage&gt;();
builder.Services.AddTransient&lt;PickLanguageViewModel&gt;
  ();
...
Routing.RegisterRoute("PickLanguagePage", 
  typeof (PickLanguagePage));
...
//Non-Shell
//Routes.Register&lt;PickLanguagePage&gt;
//("PickLanguagePage");
//Non-Shell
...</pre></li> <li>Update <code>PickLanguageViewModel</code> as it<a id="_idIndexMarker592"/> needs to implement the <code>INavigationParameterReceiver</code> interface and needs to get a dependency on the <code>INavigationService</code> interface. Here’s how it looks:<pre class="source-code">
public class PickLanguageViewModel : ObservableObject,
    <strong class="bold">INavigationParameterReceiver</strong>
{
    <strong class="bold">readonly INavigationService _navigationService;</strong>
    ...
    public PickLanguageViewModel(I
        <strong class="bold">NavigationService navigationService)</strong>
    {
        <strong class="bold">_navigationService = navigationService;</strong>
    }
    <strong class="bold">public async Task OnNavigatedTo(</strong>
<strong class="bold">        Dictionary&lt;string, object&gt; parameters)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        _selectedLanguage =</strong>
<strong class="bold">            parameters["language"] as string;</strong>
<strong class="bold">        OnPropertyChanged(nameof(SelectedLanguage));</strong>
<strong class="bold">    }</strong>
}</pre><p class="list-inset">Note that in the <code>OnNavigatedTo</code> method, we’re assigning the _<code>selectedLanguage</code> field rather than the <code>SelectedLanguage</code> property. This is intentional because <a id="_idIndexMarker593"/>updating the property will immediately invoke the <code>LanguagePicked</code> method. We don’t want to trigger this when we set the initial value of this property. Because of that, we need to call <code>OnPropertyChanged</code> manually, passing the name of the <code>SelectedLanguage</code> property.</p></li> <li>The <code>LanguagePicked</code> method is called when the user selects a new language from the dropdown. This should be where we utilize our new <code>GoBackAndReturn</code> method to navigate back and return the selected language. Let’s take a look:<pre class="source-code">
private Task LanguagePicked()
{
    return _navigationService.GoBackAndReturn(
        new Dictionary&lt;string, object&gt; {
            { "SelectedLanguage", SelectedLanguage }
        });
}</pre></li> <li>Go to <code>SettingsViewModel</code> and make it implement the <code>INavigationParameterReceiver</code> interface:<pre class="source-code">
public class SettingsViewModel :
    ObservableObject, INavigationParameterReceiver</pre><p class="list-inset">Here’s <a id="_idIndexMarker594"/>what the implemented <code>OnNavigatedTo</code> method looks like:</p><pre class="source-code">public Task OnNavigatedTo(
    Dictionary&lt;string, object&gt; parameters)
{
    if(parameters is not null &amp;&amp;
        parameters.ContainsKey("SelectedLanguage"))
    {
        CurrentLanguage =
            parameters["SelectedLanguage"] as string;
    }
    return Task.CompletedTask;
}</pre><p class="list-inset">This <code>OnNavigatedTo</code> method will be called both when navigating “forward” to this ViewModel as well as when navigating “back” to it. The <code>SelectedLanguage</code> parameter that’s sent by <code>PickLanguageViewModel</code> can be picked up here.</p></li> <li><code>SettingsPageViewModel</code> also needs to get the <code>INavigationService</code> interface injected. Here’s how:<pre class="source-code">
Readonly INavigationService _navigationService;
...
public SettingsViewModel(INavigationService service)
{
    _navigationService = service;
...
}</pre></li> <li>Finally, the <code>ChooseLanguage</code> method, which gets triggered when the user taps <code>PickLanguagePage</code>, as shown here:<pre class="source-code">
private async Task ChooseLanguage()
{
    await _navigationService
        .GoToChooseLanguage(CurrentLanguage);
}</pre></li> </ol>
<p>With this update, moving<a id="_idIndexMarker595"/> data between pages is easier and more flexible. Our app now offers smoother user experiences, all thanks to our navigation framework.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/>Summary</h1>
<p>The fundamental picture of navigation is quite straightforward: a navigation service, which is injected into ViewModels, is utilized to handle navigation. ViewModels can implement specific interfaces, enabling them to receive parameters or be notified about navigation activities, be it from or to them.</p>
<p>While the overall idea seems simple, the implementation can be complex, and this is where developers often become puzzled. Fortunately, .NET MAUI Shell streamlines the navigation process in complex UIs, providing a level of ease in the implementation. But as with anything, Shell’s opinionated nature may not suit every application or developer’s preferences. Therefore, we didn’t stop at exploring Shell navigation but also dove into building a navigation service that is not reliant on Shell.</p>
<p>Toward the end of this chapter, we looked a bit deeper into passing parameters and results between pages. We demonstrated that by efficiently combining navigation services and ViewModel coordination, we can create a seamless user experience.</p>
<p>Navigating through the complexities of .NET MAUI navigation can be a challenge, but with a good understanding of the underlying principles and implementation details, we’re better equipped to handle it. As we move forward, we’ll explore handling user input and validation, diving into how to make our applications more interactive.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">.NET MAUI </em><em class="italic">Shell</em>: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/shell/">https://learn.microsoft.com/dotnet/maui/fundamentals/shell/</a></li>
<li><em class="italic">Prism </em><em class="italic">Library</em>: <a href="https://prismlibrary.com/">https://prismlibrary.com/</a></li>
<li><em class="italic">FreshMvvm</em>: <a href="https://github.com/XAM-Consulting/FreshMvvm.Maui">https://github.com/XAM-Consulting/FreshMvvm.Maui</a></li>
</ul>
</div>
</div></body></html>