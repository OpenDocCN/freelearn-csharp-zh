- en: Chapter 5. Reflection and Dynamic Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。反射与动态编程
- en: 'The principles of Reflection in computer science are defined by Wikipedia as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中反射的原则由维基百科定义为：
- en: The ability of a computer program to examine, introspect, and modify its own
    structure and behavior.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机程序检查、内省和修改其自身结构和行为的能力。
- en: The internal structure of the .NET assemblies we saw in the first chapter allows
    us to load and invoke types embedded inside our own or foreign assemblies at runtime
    with a technique called dynamic invocation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中看到的.NET程序集的内部结构使我们能够使用称为动态调用的技术，在运行时加载和调用嵌入在我们自己的或外部程序集中的类型。
- en: Moreover, classes related to CodeDOM and `Reflection.Emit` namespaces permit
    code generation at runtime, either in C# or other languages, including **Intermediate
    Language** (**IL**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与CodeDOM和Reflection.Emit命名空间相关的类允许在C#或其他语言中运行时生成代码，包括**中间语言**（**IL**）。
- en: However, beyond the .NET-to-NET dialogs, we can use Interoperability to manipulate
    applications built in other non-NET programming languages. Actually, many professional
    applications find it suitable—and very useful—to count on external functionalities
    that we might detect as present in the host operating system. This means that
    we can interoperate with **Microsoft Office Suite** (**Word** and **Excel** being
    the most typical cases of these resources).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了.NET到.NET的对话框之外，我们还可以使用互操作性来操作用其他非.NET编程语言构建的应用程序。实际上，许多专业应用程序发现依赖外部功能——这些功能我们可能检测到存在于宿主操作系统中的——是合适的，并且非常有用。这意味着我们可以与**Microsoft
    Office 套件**（其中**Word**和**Excel**是最典型的资源案例）进行互操作。
- en: These applications can provide us with new and exciting possibilities, such
    as graph (charts) generation, text spelling, document template creation, and even
    add-in enhancements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序可以为我们提供新的和令人兴奋的可能性，例如图表（图表）生成、文本拼写、文档模板创建，甚至外接程序增强。
- en: That's why our goal in this chapter is to review some of the most useful concepts
    and use cases that a programmer might find of interest in relation with these
    topics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们的目标是回顾一些程序员可能对这些主题感兴趣的最有用概念和用例。
- en: We will start with Reflection, analyzing the possibilities offered by .NET Framework
    to introspect the very structure of assemblies and invoke internal functionalities
    in a totally programmable way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从反射开始，分析.NET框架提供的用于内省程序集结构和以完全可编程的方式调用内部功能的可能性。
- en: I will also cover the ability of emitting source code at runtime and generate
    new types and launch them at runtime.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将涵盖在运行时生成源代码并生成新类型并在运行时启动它们的能力。
- en: In the second part, we will review the most noticeable and statistically used
    options offered by Interop programming, the name used to indicate when a program
    communicates with another application to establish a controlled, programmatic
    dialog in order to interchange data and emit instructions to other applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们将回顾由互操作编程提供的最显著和统计上使用的选项，互操作编程是指当程序与另一个应用程序通信以建立受控的、程序化的对话框以交换数据和向其他应用程序发出指令时使用的名称。
- en: 'So, in brief, we will go through the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，我们将讨论以下主题：
- en: Concepts and the implementation of Reflection in the .NET framework
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射在.NET框架中的概念和实现
- en: Typical uses of Reflection in everyday programming
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射在日常编程中的典型用途
- en: Using System.Emit to generate source code at runtime
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 System.Emit 在运行时生成源代码
- en: Interop programming from the C# language
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从C#语言进行互操作编程
- en: Using Interop with Microsoft Office apps
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互操作性访问 Microsoft Office 应用程序
- en: Creating Office add-ins or apps
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Office 外接程序或应用程序
- en: Reflection in the .NET Framework
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射在.NET框架中的内容
- en: 'As always, it is good to start with the main definition (MSDN source), which
    states that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，从主要定义（MSDN 源）开始是好的，它声明如下：
- en: The classes in the System.Reflection namespace, together with System.Type, enable
    you to obtain information about loaded assemblies and the types defined within
    them, such as classes, interfaces, and value types. You can also use Reflection
    to create type instances at run time, and to invoke and access them.
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Reflection命名空间中的类，连同System.Type一起，使您能够获取有关已加载的程序集及其内部定义的类型的信息，例如类、接口和值类型。您还可以使用反射在运行时创建类型实例，并调用和访问它们。
- en: Remember, as we mentioned in the first chapter, that the organization of assemblies
    is such that they contain modules, which in turn contain types that contain members.
    Reflection techniques allow you to find out (introspect) which modules, types,
    and members are present inside a given assembly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，正如我们在第一章中提到的，程序集的组织方式是它们包含模块，这些模块反过来又包含类型，这些类型包含成员。反射技术允许你找出（内省）给定程序集中存在的模块、类型和成员。
- en: 'Therefore, when we access any member via Interop, there''s a hierarchy of info
    properties linked to it: the generic member''s info, its System.Type (the type
    it belongs to) namespace, the method base, and also information related to its
    properties, fields and events, as the next graphic shows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们通过Interop访问任何成员时，与之相关联的是信息属性的一个层次结构：泛型成员的信息、其System.Type（它所属的类型）命名空间、方法基类，以及与其属性、字段和事件相关的信息，如图所示：
- en: '![Reflection in the .NET Framework](img/image00503.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![反射在.NET框架中的应用](img/image00503.jpeg)'
- en: As per the .NET architecture analyzed in previous chapters, the two core elements
    that enable this behavior are the assembly's metadata and the .NET's dynamic common
    type system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前几章分析的.NET架构，使这种行为成为可能的是程序集的元数据和.NET的动态公共类型系统。
- en: A simple look at the basic members of the highest element in .NET hierarchy
    (`System.Object`) shows that Reflection is at the very core of its inception,
    since we have a `GetType()` method that is going to be present all along the chain
    of objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地看一下.NET层次结构中最基本成员（`System.Object`）的基本成员，我们可以看到反射是其核心，因为我们有一个将在对象链中始终存在的`GetType()`方法。
- en: 'Actually, `GetType()` returns an instance of the `System.Type` class, served
    in a way that encapsulates all the metadata of the object being examined. It is
    with this `System.Type` instance that you will be able to traverse all details
    of the type or class (except the IL code) and also gain the ability to discover
    the surrounding context: the module that implements that type and its containing
    assembly.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`GetType()`返回一个`System.Type`类的实例，以封装正在检查的对象的所有元数据的方式提供服务。正是通过这个`System.Type`实例，你将能够遍历类型或类的所有细节（除了IL代码），并且还能获得发现周围上下文的能力：实现该类型的模块及其包含的程序集。
- en: 'In the [Chapter 3](part0023.xhtml#aid-LTSU2 "Chapter 3. Advanced Concepts of
    C# and .NET"), *Advanced Concepts of C# and .NET*, we included the following sample
    to test the very basics of Reflection:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0023.xhtml#aid-LTSU2 "第3章。C#和.NET的高级概念")《C#和.NET的高级概念》中，我们包含了以下示例来测试反射的非常基础的概念：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, we''re using `GetType()` and casting the result to a `Type` object,
    which we can later use to inspect the members of the `dyn` variable. A look at
    the Object Browser in the search for the `System.Type` instance makes things quite
    clear:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用`GetType()`并将结果转换为`Type`对象，我们可以稍后使用它来检查`dyn`变量的成员。查看对象浏览器以寻找`System.Type`实例，可以使事情变得非常清晰：
- en: '![Reflection in the .NET Framework](img/image00504.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![反射在.NET框架中的应用](img/image00504.jpeg)'
- en: The screenshot shows how `System.Type` implements the `IReflect` interface,
    which provides a gang of methods for introspection (most of them starting with
    `Get`, followed by the target introspection to find out fields, members, and so
    on).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了`System.Type`如何实现`IReflect`接口，该接口提供了一组用于内省的方法（大多数以`Get`开头，后面跟着目标内省以查找字段、成员等）。
- en: 'Also, note the presence of the `InvokeMember` method, which permits dynamic
    invocation of the type''s members at runtime and can be used for a variety of
    purposes. The return values of these methods are arrays that represent the information
    structure of every individual member: `MemberInfo[]`, `PropertyInfo[]`, `MethodInfo[]`,
    and `FieldInfo[]`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`InvokeMember`方法的存在，它允许在运行时动态调用类型的成员，并可用于各种目的。这些方法的返回值是表示每个单独成员信息结构的数组：`MemberInfo[]`、`PropertyInfo[]`、`MethodInfo[]`和`FieldInfo[]`。
- en: Now, let's start coding some of these ideas in a simple console application
    that declares a `Person` class with three properties and a method and learn how
    we get all this information at runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个简单的控制台应用程序来实现这些想法，该应用程序声明了一个具有三个属性和一个方法的`Person`类，并学习我们如何在运行时获取所有这些信息。
- en: 'Please, notice that the `Person` class owns a property which uses a method
    declared in a distinct namespace (`System.Windows.Forms`). There''s no problem
    to access that method via Reflection and invoking it, only that we have to reference
    the namespace, together with `System.Reflection`, that we''ll use a bit later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Person` 类拥有一个属性，它使用在单独的命名空间（`System.Windows.Forms`）中声明的方 法。通过反射访问并调用该方法没有问题，只是我们必须引用该命名空间，以及稍后我们将使用的
    `System.Reflection`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''re including the output in the code since it is pretty predictable, and
    we''re just asking for the type. However, let''s continue adding some more lines
    before the call to `Read()`, to find out more about the `Person` class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输出包含在代码中，因为它相当可预测，我们只是请求类型。然而，在调用 `Read()` 之前，让我们继续添加一些更多行，以了解更多关于 `Person`
    类的信息：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we find out something else about the internal structure, as shown in the
    output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看输出中显示的内部结构的其他信息：
- en: '![Reflection in the .NET Framework](img/image00505.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![反射在.NET框架中的体现](img/image00505.jpeg)'
- en: Some of the *hidden* members show up now, such as the default constructor created
    by the compiler (`.ctor`), the conversion of the `{get; set;}` declarations into
    pairs of field/access methods, and the inherited members from the object. Using
    these methods, we obtain all the information that's relative to a member.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 *隐藏* 成员现在出现了，例如编译器创建的默认构造函数（`.ctor`），将 `{get; set;}` 声明转换为字段/访问方法对，以及从对象继承的成员。使用这些方法，我们可以获得与成员相关的所有信息。
- en: Not only can we find out the structure of another type, but we can also invoke
    its members, as mentioned earlier. For example, the `ShowPersonData` method receives
    two parameters to configure a `MessageBox` object, where it presents some information
    to the user.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们可以找出其他类型的结构，还可以像之前提到的那样调用其成员。例如，`ShowPersonData` 方法接收两个参数来配置 `MessageBox`
    对象，向用户展示一些信息。
- en: 'This means that we need to be able to call the method and also configure and
    send the parameters it requires. We can do this with the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要能够调用该方法，并配置和发送它所需的参数。我们可以使用以下代码来完成：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since parameters can be of any type, we create an object array that will be
    used at runtime to correspond every item in the array with its argument in the
    method. In this case, we want to pass the caption of the dialog box and the icon
    to be used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数可以是任何类型，我们创建了一个对象数组，该数组将在运行时使用，以将数组中的每个项与其方法中的参数相对应。在这种情况下，我们想要传递对话框的标题和要使用的图标。
- en: 'As expected, we get the corresponding `MessageBox` object at runtime with the
    correct configuration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们在运行时获得了具有正确配置的相应 `MessageBox` 对象：
- en: '![Reflection in the .NET Framework](img/image00506.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![反射在.NET框架中的体现](img/image00506.jpeg)'
- en: 'Of course, we can also perform the manipulation of properties in a similar
    manner:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以以类似的方式执行属性的操纵：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output confirms that the property was of a read/write kind and also confirms
    the results of the change (note that we don''t pass any argument to read the data):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认该属性是可读/写的类型，并确认了更改的结果（注意，我们未传递任何参数来读取数据）：
- en: '![Reflection in the .NET Framework](img/image00507.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![反射在.NET框架中的体现](img/image00507.jpeg)'
- en: Calling external assemblies
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用外部程序集
- en: If we need information and/or functionality concerning a different assembly,
    that's also possible using the `Assembly` object or by referencing the assembly
    and obtaining its data from the static `GetType()` method of the `Type` object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要有关不同程序集的信息和/或功能，也可以使用 `Assembly` 对象或通过引用程序集并从 `Type` 对象的静态 `GetType()`
    方法获取其数据来实现。
- en: 'This includes those that are part of .NET Framework itself. To access all these
    functionalities, the `System.Reflection` namespace provides a cluster of related
    possibilities. A syntax such as this can serve the purpose:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括那些是.NET框架本身的一部分。要访问所有这些功能，`System.Reflection` 命名空间提供了一系列相关可能性。如下所示的语法可以满足这一目的：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, we're reflecting on a reference type (`System.Math`) included in the basic
    library, `mscorlib`, to find out how many members are included, such as in the
    previous case.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在反射包含在基本库 `mscorlib` 中的引用类型（`System.Math`），以找出包含多少成员，就像之前的例子一样。
- en: 'Alternatively, we can load an assembly at runtime using the `Assembly` object
    and even create an instance of that object using the `CreateInstance()` static
    method with code like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `Assembly` 对象在运行时加载程序集，甚至可以使用 `CreateInstance()` 静态方法创建该对象的实例，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is also possible to get all the referenced assemblies of the current (running)
    assembly. The `GetExecutingAssembly()` method returns an `Assembly` object pointing
    to itself, and by calling `GetReferencedAssemblies()`, we get all this information.
    The following code will suffice to obtain this list:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以获取当前（正在运行）程序集的所有引用程序集。`GetExecutingAssembly()`方法返回一个指向自身的`Assembly`对象，通过调用`GetReferencedAssemblies()`，我们得到所有这些信息。以下代码足以获取此列表：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The entire output (including the three previous routines) looks like what is
    shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 整个输出（包括前面的三个例程）看起来就像以下屏幕截图所示：
- en: '![Calling external assemblies](img/image00508.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![调用外部程序集](img/image00508.jpeg)'
- en: Generic Reflection
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型反射
- en: 'Reflection of generic types is also available and can be checked using Boolean
    properties, such as `IsGenericType`, `IsGenericTypeDefinition`, or `GetGenericArguments()`.
    The same mechanisms apply in this case, only checking the corresponding types
    for the difference. The following is a short demo, which declares a generic `Dictionary`
    object and recovers information on its types:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型的反射也是可用的，可以使用布尔属性进行检查，例如`IsGenericType`、`IsGenericTypeDefinition`或`GetGenericArguments()`。在这种情况下，相同的机制适用，只是检查相应的类型以确定差异。以下是一个简短的演示，它声明了一个泛型`Dictionary`对象并恢复其类型信息：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The—quite predictable—output shows characteristics about the type (generic)
    and its members (non generic) and iterates over a loop, checking for the genericity
    of every type (using the `IsGenericParameter` Boolean property) before printing
    its details:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: —相当可预测的—输出显示了类型（泛型）及其成员（非泛型）的特性，并在循环中迭代，在打印其详细信息之前检查每个类型的泛型性（使用`IsGenericParameter`布尔属性）：
- en: '![Generic Reflection](img/image00509.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![泛型反射](img/image00509.jpeg)'
- en: So, changing the methods' calls and/or adding some checking, we can also use
    generic types with Reflection, just as we did with the *classical* ones.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过更改方法的调用和/或添加一些检查，我们也可以使用反射来使用泛型类型，就像我们使用*经典*类型一样。
- en: Emitting code at runtime
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时生成代码
- en: 'Another interesting possibility is the capacity of some classes in the .NET
    Framework to emit code at runtime and—eventually—compile and run it. Observe that
    Visual Studio itself creates code in many scenarios: when creating the structure
    of documents in different languages from a template, using code snippets, scaffolding
    an ORM in ASP.NET, and so on.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的可能是.NET Framework中某些类在运行时生成代码的能力，并最终编译和运行它。注意，Visual Studio本身在许多场景中创建代码：从模板创建不同语言的文档结构，使用代码片段，在ASP.NET中构建ORM，等等。
- en: 'This is a task that can be achieved mainly in two ways: using CodeDOM or by
    means of classes inside the `System.Reflection.Emit` namespace.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务可以通过两种主要方式实现：使用CodeDOM或通过`System.Reflection.Emit`命名空间内的类。
- en: The System.CodeDOM namespace
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: System.CodeDOM命名空间
- en: 'The first option refers to the `System.CodeDOM` and `System.CodeDOM.Compiler`
    namespaces, and it''s been present in .NET since the very first version of the
    framework. Note the DOM part of the name: it means Document Object Model, just
    like in HTML, XML, or other document structures.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项指的是`System.CodeDOM`和`System.CodeDOM.Compiler`命名空间，并且自.NET框架的第一个版本以来就存在。注意名称中的DOM部分：它意味着文档对象模型，就像在HTML、XML或其他文档结构中一样。
- en: With classes inside CodeDOM, we can generate source code using templates that
    define coding structures in different languages, so we can even generate source
    code in all languages supported by .NET Framework.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在CodeDOM内部使用类，我们可以使用模板生成源代码，这些模板定义了不同语言中的编码结构，因此我们甚至可以在.NET Framework支持的所有语言中生成源代码。
- en: 'To generate code for any .NET structure, CodeDOM classes represent any aspect
    of the generated code, and we should use two different mechanisms: one that expresses
    the elements to be built and another that—when lunched—produces the actual code.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要为任何.NET结构生成代码，CodeDOM类代表生成代码的任何方面，我们应该使用两种不同的机制：一种表达要构建的元素，另一种在运行时产生实际的代码。
- en: Let's imagine how can we generate the previous `Person` class; only, reduce
    it to a minimum of elements for sake of clarity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下如何生成之前的`Person`类；只是，为了清晰起见，将其简化到最小元素。
- en: 'We will need the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下内容：
- en: 'An instance of `CodeCompileUnit`, which is in charge of generating the DOM
    structure of our component (its code graph). This structure is responsible for
    scaffolding the different members our class contains: properties, fields, methods,
    and so on.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`CodeCompileUnit`实例，负责生成我们组件的DOM结构（其代码图）。这个结构负责构建我们类包含的不同成员：属性、字段、方法等。
- en: The rest of the elements have to be created one by one using classes available
    in CodeDOM, which represent every possible reserved word or structure (classes,
    methods, parameters, and so on).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的元素必须逐个使用CodeDOM中可用的类创建，这些类代表每个可能的保留字或结构（类、方法、参数等）。
- en: Finally, all elements created individually are included in the `CodeCompileUnit`
    object prior to its generation.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在生成之前，所有单独创建的元素都包含在`CodeCompileUnit`对象中。
- en: 'Let''s take a look at the code, which produces a file that contains the same
    definition of a `Person` class that we used at the beginning of this chapter (for
    the sake of brevity, I''m just including here the initial lines and final lines.
    You''ll find the whole code in demo `Reflection1` inside this chapter''s source
    code):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，它生成一个包含我们在本章开头使用的`Person`类定义的文件（为了简洁起见，我仅包括这里的初始行和末尾行。你可以在本章源代码中的demo
    `Reflection1`中找到完整的代码）：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we establish our entry point in `Program5`, its execution generates a file
    with the same code that we had in the `Program.cs` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`Program5`中建立了入口点，它的执行将生成一个包含我们在`Program.cs`文件中的相同代码的文件。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that you will have to check the `bin/debug` directory, since we didn't
    establish a different output path.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你将不得不检查`bin/debug`目录，因为我们没有建立不同的输出路径。
- en: 'You should see something like the following screenshot in your **Solution Explorer**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在**解决方案资源管理器**中看到以下截图类似的内容：
- en: '![The System.CodeDOM namespace](img/image00510.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![System.CodeDOM命名空间](img/image00510.jpeg)'
- en: As you can see, the generated code is pretty verbose. However, that's what it
    takes to generate code feature by feature. Let's go briefly through it and underline
    the most important classes implied in the generation, starting with the end of
    the `Main` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生成的代码相当冗长。然而，这正是按特征生成代码所必需的。让我们简要地浏览一下，并强调在生成过程中隐含的最重要类，从`Main`方法的末尾开始。
- en: The object that puts everything to work is the `CodeDomProvider` class. It has
    to be instantiated, indicating the language to be used (`CSharp`, in our case).
    At the end, we will invoke its `GenerateCodeFromCompileUnit` method, which will
    use all previous definitions to produce the actual code inside the file defined
    for this purpose.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使一切工作的对象是`CodeDomProvider`类。它必须被实例化，指明要使用的语言（在我们的例子中是`CSharp`）。最后，我们将调用其`GenerateCodeFromCompileUnit`方法，它将使用所有之前的定义来生成为此目的定义的文件中的实际代码。
- en: So, at the top of `Program5`, we declare a `CompilerUnit` object. The other
    crucial component is the `CodeTypeDeclaration` object, which is in charge of storing
    all declarations used while code generation takes place.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`Program5`的顶部，我们声明一个`CompilerUnit`对象。另一个关键组件是`CodeTypeDeclaration`对象，它负责存储在代码生成过程中使用的所有声明。
- en: The rest of the classes implied in the construction are merely helper classes
    to build each brick of the resulting class. This is the role of the `CodeNamespace`,
    `CodeNamespaceImport`, `CodeSnippetTypeMember`, `CodeCommentStatement`, `CodeMemberMethod`,
    and `CodeParameterDeclarationExpression` classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 构造中隐含的其余类仅仅是构建结果类每个砖块的辅助类。这就是`CodeNamespace`、`CodeNamespaceImport`、`CodeSnippetTypeMember`、`CodeCommentStatement`、`CodeMemberMethod`和`CodeParameterDeclarationExpression`类的作用。
- en: Although you may think that this is too much effort to just create the resulting
    class, keep in mind that the automatization of tasks inside Visual Studio follows
    similar paths and that you could create you own mechanisms of code generation
    suited to your needs or the company's requirements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能认为仅仅创建结果类就花费了太多的精力，但请记住，Visual Studio内部任务的自动化遵循类似的路径，你可以创建适合你或公司需求的代码生成机制。
- en: With such programmable context, it's easy to imagine a number of situations
    in which code generation can be tuned by the generating program at runtime, allowing
    you to produce code with different variations depending on options we established
    previously.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的可编程环境中，很容易想象出许多情况，在这些情况下，代码生成可以在运行时由生成程序调整，允许你根据我们之前设定的选项产生不同变体的代码。
- en: The Reflection.Emit namespace
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflection.Emit命名空间
- en: The `System.Reflection.Emit` namespace is intended for code generation, allowing
    developers to create code or metadata from within their applications, independent
    of the specifics of the operating system's loaders.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Reflection.Emit`命名空间旨在进行代码生成，允许开发者在应用程序内部创建代码或元数据，而不依赖于操作系统加载器的具体细节。'
- en: 'Basically, this namespace offers the following programmatic options:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个命名空间提供了以下编程选项：
- en: It allows the building of modules and assemblies at runtime
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许在运行时构建模块和程序集。
- en: It creates classes and types and emits IL
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建类和类型并发出IL。
- en: It launches a .NET compiler to build apps
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启动.NET编译器来构建应用程序。
- en: The way the code is generated here is different from CodeDOM in several aspects.
    One of them is the ability to generate IL code at runtime, which means that the
    execution of some C# code will produce outputs not coded in C# but using these
    instruments.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里生成代码的方式在几个方面与CodeDOM不同。其中之一是能够在运行时生成IL代码，这意味着某些C#代码的执行将产生不是用C#编写的输出，而是使用这些工具生成的。
- en: One of the objects implied in this type of code generation is the `DynamicMethod`
    object included in the `System.Reflection.Emit` namespace. This object allows
    the obtention of another object of type `ILGenerator`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种代码生成类型中隐含的一个对象是包含在`System.Reflection.Emit`命名空间中的`DynamicMethod`对象。此对象允许获取另一个类型为`ILGenerator`的对象。
- en: 'Once you get `ILGenerator`, you can produce IL code dynamically in a very straightforward
    manner:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得`ILGenerator`，你就可以以非常直接的方式动态生成IL代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Observe how we finally call the `DynamicObject.Invoke` method as if it were
    a delegate. If you test the previous code, the output generated will correspond
    to what is the equivalent of the counterpart lines of the code programmed in C#,
    which produces the same information in the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们最终如何调用`DynamicObject.Invoke`方法，就像调用委托一样。如果你测试前面的代码，生成的输出将与C#代码中对应行的等效输出相对应，该代码产生相同的信息输出：
- en: '![The Reflection.Emit namespace](img/image00511.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Reflection.Emit命名空间](img/image00511.jpeg)'
- en: Also, note the presence of the `OpCodes.Ret` value in the last call to `ilgen.Emit`.
    This generates a return statement, which pushes the return value, if present,
    from the evaluation stack to the caller's evaluation stack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在`ilgen.Emit`的最后调用中存在`OpCodes.Ret`值。这生成一个返回语句，如果存在返回值，则将其从评估堆栈推送到调用者的评估堆栈。
- en: 'If you take a look at fields related to OpCodes, you''ll discover that it provides
    an extensive list of field representations of MSIL instructions, as shown in the
    next screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看与OpCodes相关的字段，你会发现它提供了一个广泛的MSIL指令的字段表示列表，如下一张截图所示：
- en: '![The Reflection.Emit namespace](img/image00512.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Reflection.Emit命名空间](img/image00512.jpeg)'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that if you want to take a deep dive into these possibilities, there's
    a page on MSDN, which contains an exhaustive relation of all the OpCodes at [https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你想深入了解这些可能性，MSDN上有一个页面，其中包含所有OpCodes的详尽关系，链接为[https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx)。
- en: Interoperability
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性。
- en: The other big topic we want to cover in this chapter is the possibility of a
    .NET application "talking" to other installed applications in our system. This
    talking means instantiating these applications and interchanging data between
    them or asking the other applications to perform tasks we should program ourselves.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们要讨论的另一个重要主题是.NET应用程序“与”我们系统中的其他已安装应用程序“交流”的可能性。这种交流意味着实例化这些应用程序，在它们之间交换数据，或者请求其他应用程序执行我们本应自己编写的任务。
- en: Initially (in versions previous to C# 4.0), this technology was exclusively
    COM-based. The trick was done via Interop using some DLLs called **Type Libraries**
    (**TLB**) or **Object Libraries** (**OLB**). The programmer should then use (reference)
    these libraries and instantiate their internal objects, which represent the internal
    components of the application to communicate with.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最初（在C# 4.0之前的版本中），这项技术完全是基于COM的。这个技巧是通过Interop使用一些名为**类型库**（**TLB**）或**对象库**（**OLB**）的DLL完成的。程序员随后应该使用（引用）这些库并实例化它们内部的对象，这些对象代表应用程序的内部组件，以便进行通信。
- en: 'This was possible using a **Runtime Callable Wrapper** (**RCW**) whose operational
    schema is explained in the following figure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用**运行时可调用包装器**（**RCW**）实现的，其操作模式在以下图中解释：
- en: '![Interoperability](img/image00513.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![互操作性](img/image00513.jpeg)'
- en: Let's see how communication was made between the COM and .NET worlds. You have
    to keep in mind that COM is not a managed environment, and it executes instructions
    native to the Windows operating system. The RCW component was responsible for
    this and acted as a proxy between both execution contexts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看COM和.NET世界之间是如何进行通信的。你必须记住，COM不是一个托管环境，它执行Windows操作系统的本地指令。RCW组件负责这一点，并在两个执行上下文之间充当代理。
- en: No optional parameters were available for a C# programmer in this model. So,
    you had to pass as many parameters as the method defined, using the `System.Reflection.Missing.Value`
    type, besides other difficulties present in the way Reflection was used to find
    out which members were present and usable, plus other related paraphernalia.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，C#程序员没有可选参数可用。因此，你必须传递方法定义的所有参数，使用`System.Reflection.Missing.Value`类型，除此之外，还有使用Reflection查找哪些成员存在并可用的其他困难，以及相关的其他辅助工具。
- en: 'This is code that illustrates such a situation in early versions. It assumes
    that a reference has been made to the corresponding TLB of Microsoft Word, which
    exposed an object called `ApplicationClass` to allow Word instantiation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了早期版本中这种情况的一个示例。它假设已经引用了Microsoft Word的相应TLB，该TLB公开了一个名为`ApplicationClass`的对象，以允许Word实例化：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note how all the arguments that the `Open` method defines, had to be passed
    as `missing` for this case. As you see, this is a pretty clumsy way to open a
    document and access its members (actually, when using this Interop feature, operating
    from Visual Basic .NET was much easier and simple some time ago.).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有由`Open`方法定义的参数，在这个情况下都必须以`missing`的形式传递。正如你所见，这是一种相当笨拙的方式来打开文档并访问其成员（实际上，在一段时间前，使用这种Interop功能，从Visual
    Basic .NET操作要容易得多，也更简单）。
- en: Primary Interop Assemblies
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要互操作程序集
- en: As technologies evolved, type libraries were replaced with something called
    **PIAs** (**Primary Interop Assemblies**), which play the same role as the RCWs
    but allow programmability in an easier manner.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的演变，类型库被一种称为**PIAs（主要互操作程序集**）的东西所取代，它们扮演着与RCWs相同的作用，但以更简单的方式允许编程。
- en: So, the way to communicate with external (interoperable) applications becomes
    possible through those libraries that take care of the required marshalling of
    data types between two worlds which are—at first—not so easy to connect, especially
    for those programmers not skilled enough to use the COM platform.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与外部（互操作）应用程序通信的方式是通过那些负责在两个世界之间进行数据类型序列化的库，这两个世界最初并不容易连接，尤其是对于那些不够熟练使用COM平台的程序员。
- en: 'The following schema shows this communication architecture:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了这种通信架构：
- en: '![Primary Interop Assemblies](img/image00514.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![主要互操作程序集](img/image00514.jpeg)'
- en: Let's start from the beginning, only using the latest versions to see how we
    operate today.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始，只使用最新版本，看看我们今天是如何操作的。
- en: To obtain (and see in action) an instance of an interoperable application, the
    first step is to reference the corresponding PIA that will serve as the proxy.
    This is available in the **References** option of any .NET application, only not
    in the default DLL's tab but in the **Extensions** tab.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取（并看到）一个互操作应用程序的实例，第一步是引用相应的PIA，它将作为代理。这可以在任何.NET应用程序的**引用**选项中找到，但不是在默认的DLL选项卡中，而是在**扩展**选项卡中。
- en: Note that you will see a bunch of DLLs available, and—in many cases—you'll observe
    duplications. You have to pay attention to the version number, which will vary
    depending on the Office version installed on your machine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你会看到很多DLL可用，并且在很多情况下你会观察到重复。你必须注意版本号，它将根据你机器上安装的Office版本而变化。
- en: 'Besides, you might find duplications of even the same versions in different
    locations in your box. This is due to the fact that the installation of Office
    allows the user to manually include these PIAs during the process or it might
    be due to the previous installation of older Office versions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会在你的机器的不同位置找到甚至相同版本的重复。这是由于安装Office允许用户在安装过程中手动包含这些PIAs，或者可能是因为之前安装了较旧的Office版本：
- en: '![Primary Interop Assemblies](img/image00515.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![主要互操作程序集](img/image00515.jpeg)'
- en: If you check the **COM** option of **Reference Manager**, you will also discover
    the presence of some entries with the word `Excel` inside. They might vary in
    your machine, but usually, they point to the corresponding executable being referenced
    (`Excel.exe`, in the next screenshot).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查**引用管理器**的**COM**选项，你也会发现一些包含“Excel”一词的条目。它们可能在你的机器上有所不同，但通常，它们指向被引用的相应可执行文件（下一个截图中的`Excel.exe`）。
- en: 'However, if you mark this option as well and accept the selection, you won''t
    see a reference to `Excel.exe` in the list of your Project''s references. Instead,
    you''ll see a library whose name is the same as what it was in the previous case
    (when I referenced the PIA) but one that really points to a DLL in the GAC called
    `Microsoft.Office.Interop.Excel`, followed by a GUID number: the reference is
    "redirected" to point to the most suitable library:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你也标记了这个选项并接受选择，你将不会在项目引用列表中看到对`Excel.exe`的引用。相反，你会看到一个与之前情况（当我引用PIA时）相同的名称的库，但它实际上指向GAC中的名为`Microsoft.Office.Interop.Excel`的DLL，后面跟着一个GUID号码：引用被“重定向”以指向最合适的库：
- en: '![Primary Interop Assemblies](img/image00516.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![主要互操作程序集](img/image00516.jpeg)'
- en: The object model that Excel offers to the programmer recalls exactly that of
    its user interface. There's an `Application` object, which represents the entire
    application, and each `Workbook` object is represented by its corresponding object
    in the model. Each one contains a collection of the `Worksheet` objects. Once
    the starting point is ready, the `Range` object enables you to operate with individual
    (or groups of) cells.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Excel提供给程序员的对象模型与它的用户界面完全相同。有一个`Application`对象，它代表整个应用程序，每个`Workbook`对象在模型中由相应的对象表示。每个对象包含一个`Worksheet`对象的集合。一旦起点准备就绪，`Range`对象就可以让你操作单个（或一组）单元格。
- en: To start with, let's call an Excel instance in the modern, easier way, and show
    it with a new Excel book. In this sample, in order to interchange information
    between our application and Excel or Word later on, I'm using a basic Windows
    Forms application, which will launch Excel using the following code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以现代、简单的方式调用一个Excel实例，并用一个新的Excel工作簿显示它。在这个示例中，为了在以后将信息在应用程序和Excel或Word之间交换，我使用了一个基本的Windows
    Forms应用程序，它将使用以下代码启动Excel。
- en: 'Somewhere in our Windows Form, we define this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Windows Form中，我们定义如下：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This, indeed, launches Excel and passes this information to the four cells
    referenced in the code, as we can see in the output. Note the initial declarations
    to reference Excel and Word in our code. With this alias, it becomes easier to
    reference any object in the proxy and the code becomes less verbose. Since we
    call `OpenExcel` when the document is loaded, both applications will be opened,
    the second one being Excel presenting our data:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上启动了Excel并将这些信息传递给代码中引用的四个单元格，正如我们可以在输出中看到的那样。注意我们代码中的初始声明，以引用Excel和Word。由于我们在文档加载时调用`OpenExcel`，因此两个应用程序都将打开，第二个是Excel，展示了我们的数据：
- en: '![Primary Interop Assemblies](img/image00517.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![主要互操作程序集](img/image00517.jpeg)'
- en: This is nothing amazing or unexpected, but we see that it's fairly easy to call
    other applications with Interop and pass data to them. Anyway, some peculiarities
    of Office Interop (also common to other applications) are evident here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么惊人的或意料之外的事情，但我们看到使用Interop调用其他应用程序并传递数据给它们相当容易。无论如何，Office Interop（以及其他应用程序）的一些特殊性在这里是明显的。
- en: To start with, you have to declare the `excel` object as `Visible`. That's because
    by default, Office Interop applications don't show up. This is very useful when
    you just want a functionality to happen and recover the results in your application
    without the target app bothering the final user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须将`excel`对象声明为`Visible`。这是因为默认情况下，Office Interop应用程序不会显示。当你只想让某个功能发生并在你的应用程序中恢复结果，而不希望目标应用程序打扰最终用户时，这非常有用。
- en: 'Obviously, we''re using some objects you might not be familiar with, since
    they belong to the target application: `Range` represents a range of cells within
    the current Worksheet, the `get_Range` method recovers a `Set`/`Get` reference
    to the required cells we pass as an argument. Note, we can indicate the range
    required in the string we passed to this method or use an enumeration, such as
    in `get_Range(c1, c2)`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们正在使用一些你可能不熟悉的对象，因为它们属于目标应用程序：`Range` 代表当前工作表中的单元格范围，`get_Range` 方法恢复一个
    `Set`/`Get` 引用到我们作为参数传递的所需单元格。注意，我们可以在传递给此方法的字符串中指定所需的范围或使用枚举，例如在 `get_Range(c1,
    c2)` 中。
- en: 'Alternatively, we can also create a `Range` object using a syntax like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用如下语法创建一个 `Range` 对象：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Observe that in this case, we declare a `Sheet` object recovered from the available
    collection of sheets that Excel creates in the initial workbook. With this object
    and using an array-like syntax, we select the initial and ending cells to include
    in our range (by default, all of them are accessible).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到在这种情况下，我们声明了一个从 Excel 在初始工作簿中创建的可用工作表集合中恢复的 `Sheet` 对象。使用此对象和类似数组的语法，我们选择要包含在我们范围中的初始和结束单元格（默认情况下，所有这些都可以访问）。
- en: 'Also, note that when we define a rectangle with our cells, several columns
    are collected, so the resulting modification ends up with the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当我们用我们的单元格定义一个矩形时，会收集多个列，因此最终的修改结果如下所示：
- en: '![Primary Interop Assemblies](img/image00518.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![主要互操作程序集](img/image00518.jpeg)'
- en: Formatting cells
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化单元格
- en: Most likely, we will have to format the contents we pass to an Excel sheet.
    This implies another way to operate (which is very coherent; let's underline that).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，我们不得不格式化传递给 Excel 表格的内容。这意味着另一种操作方式（这是非常合理的；让我们强调这一点）。
- en: Most of these objects are defined separately and then applied to the corresponding
    object to be targeted. In the case of formatting, keep in mind that the format
    should be applied to cells that hold some value (it might well be that you opened
    an existing workbook object).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象中的大多数都是单独定义的，然后应用于要针对的对象。在格式化的情况下，请记住，格式应该应用于包含某些值的单元格（可能你打开了一个现有的工作簿对象）。
- en: 'So, we''re going to create another method in our Form to call Excel and create
    a style that we can apply to our cells. Something like this would be enough for
    now:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在我们的表单中创建另一个方法来调用 Excel 并创建一个可以应用于我们单元格的样式。现在这样的方法就足够了：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that some objects always make a reference to the current (active in that
    moment) element, such as `ActiveWorkBook` or an alternative `ActiveSheet`. We
    also can count on an `ActiveCell` object that operates on a given range previously
    selected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些对象总是引用当前（在那个时刻活跃的）元素，例如 `ActiveWorkBook` 或替代的 `ActiveSheet`。我们还可以依赖一个 `ActiveCell`
    对象，它在之前选定的给定范围内操作。
- en: 'Finally, we call `oRange.Columns.AutoFit()` in order to make every column as
    wide as the maximum length inside it. With this definition, we can call `FormatCells`
    whenever we need the style to be applied on any range. In this case, operating
    over the second range defined, the output shows the correct formatting applied:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `oRange.Columns.AutoFit()` 以使每个列的宽度与其中最大长度一致。有了这个定义，我们可以在需要将样式应用于任何范围时调用
    `FormatCells`。在这种情况下，对第二个定义的范围进行操作，输出显示了正确应用了格式的结果：
- en: '![Formatting cells](img/image00519.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![格式化单元格](img/image00519.jpeg)'
- en: Inserting multimedia in a sheet
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在表格中插入多媒体
- en: 'Another interesting option is the ability to insert external images inside
    the area of our selection. This can even be performed using any content available
    on the clipboard. In this case, the code is quite straightforward:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的选择是能够在我们的选择区域内插入外部图片。这甚至可以使用剪贴板上的任何内容来完成。在这种情况下，代码相当简单：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output shows the Packt logo located in the selected cell:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了位于选定单元格中的 Packt 标志：
- en: '![Inserting multimedia in a sheet](img/image00520.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中插入多媒体](img/image00520.jpeg)'
- en: 'We''re assuming that a picture with the Packt Publishing logo is available
    at the current (execution) path. Of course, we could save it in a resource file
    and recover it in some other fashion. For example, we can recover the front page
    image of this book from its corresponding link on the Packt Publishing site at
    [https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg](https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg)
    using this code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设带有 Packt Publishing 标志的图片当前（执行）路径中可用。当然，我们可以将其保存在资源文件中，并以其他方式恢复。例如，我们可以使用以下代码从
    Packt Publishing 网站上的相应链接恢复这本书的封面图像 [https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg](https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg)：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we need the help of the `WebRequest/WebResponse` objects that belong
    to the `System.Net` namespace as well as the `Stream` class, which you find as
    part of the `System.IO` namespace. As you can imagine, in the Windows Forms code,
    we change the previous code for:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要 `System.Net` 命名空间中属于 `WebRequest/WebResponse` 对象的帮助，以及作为 `System.IO`
    命名空间一部分的 `Stream` 类。正如你所想象的那样，在 Windows Forms 代码中，我们更改之前的代码为：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting output shows this book''s front page located at cell A6 (remember
    that it''s important to select the destination target before you do this):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出显示了位于单元格 A6 的这本书的封面（记住，在这样做之前选择目标位置是很重要的）：
- en: '![Inserting multimedia in a sheet](img/image00521.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中插入多媒体](img/image00521.jpeg)'
- en: In this manner, we have a bunch of possible additions to build Excel sheets,
    including external content, which, of course, doesn't have to be graphical and
    admits other types of content (even video).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们有一系列可能的添加到 Excel 表格中的内容，包括外部内容，当然，这些内容不必是图形的，并接受其他类型的内容（甚至是视频）。
- en: When we deal with graphics in Excel, usually what we really want is to instruct
    Excel to build a business chart from some data. Once that is done, we can save
    it as an image file or recover it and present it in our application (often not
    showing Excel's user interface in any manner).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Excel 中处理图形时，通常我们真正想要的是指示 Excel 从一些数据中构建一个业务图表。一旦完成，我们可以将其保存为图像文件或在我们的应用程序中恢复并展示它（通常不会以任何方式显示
    Excel 的用户界面）。
- en: 'To get an Excel chart object up and running, we have to add a chart to the
    WorkBook''s chart collection in a manner similar to what we did with the WorkBook
    itself. To generate a given type of chart, a useful object is the `ChartWizard`
    object, which receives configuration parameters that allow us to indicate one
    from the many types of charts available and the text of `Title` required for our
    chart. So, we might end up with something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Excel 图表对象启动并运行，我们必须以类似于我们对 WorkBook 本身所做的方式将图表添加到 WorkBook 的图表集合中。要生成特定类型的图表，一个有用的对象是
    `ChartWizard` 对象，它接收配置参数，允许我们从一个可用的多种图表类型中选择一种，并为我们的图表提供所需的 `Title` 文本。因此，我们可能会得到如下所示的内容：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The explanation of the different types of charts and styles can be found in
    the MSDN documentation and exceeds the coverage of this book (it is available
    at [https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx](https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的图表和样式的解释可以在 MSDN 文档中找到，并超出了本书的覆盖范围（它可在 [https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx](https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx)
    找到）。
- en: Note that we finally copy the generated graphic to the clipboard in order to
    use the same technique as earlier, although you can use some other approaches
    to get the image as well.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们最终将生成的图形复制到剪贴板，以便使用与之前相同的技术，尽管你也可以使用其他方法来获取图像。
- en: 'To get some straightforward data to build the image, I''ve started from an
    old Microsoft demo, which recovers processes from the memory but changes the target
    to only processes related to Microsoft Office applications and reduces the code
    to a minimum:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取构建图像的一些直接数据，我从旧版的 Microsoft 演示开始，它从内存中恢复进程，但将目标更改为仅与 Microsoft Office 应用程序相关的进程，并将代码简化到最小：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In another event handler linked to a button (the entire demo is available,
    as always, with the companion code for this chapter), we launch the process in
    this way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个与按钮相关联的事件处理程序中（整个演示始终可用，与本章的配套代码一起提供），我们以这种方式启动该过程：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''re assuming that a `PictureBox` control is present in the form with the
    name `pbChart`. However, before showing the results, note that if the user interacts
    with Excel, we need to manually close and destroy the resources created by the
    application; so, in the `form_closing` event, we''re including this sample code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设表单中存在一个名为 `pbChart` 的 `PictureBox` 控件。然而，在显示结果之前，请注意，如果用户与 Excel 交互，我们需要手动关闭和销毁应用程序创建的资源；因此，在
    `form_closing` 事件中，我们包含了以下示例代码：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Besides, we have created an Excel object at the beginning (declared in the
    form''s scope and instantiated in the `Initialize` event), so the `excel` variable
    is available alongside all methods in the form. When executing, we get both applications
    running (I keep Excel visible for demoing purposes):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在开始时创建了一个 Excel 对象（在表单的作用域内声明并在 `Initialize` 事件中实例化），因此 `excel` 变量在表单的所有方法中都是可用的。在执行时，我们同时运行两个应用程序（我保持
    Excel 可见以进行演示）：
- en: '![Inserting multimedia in a sheet](img/image00522.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中插入多媒体](img/image00522.jpeg)'
- en: 'When pressing the **Generate GraphChart** button, we have a duplicate output
    showing the generated graphic in `ActiveWorkBook` along with the picture shown
    within the `PictureBox` control in the Form:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下 **生成 GraphChart** 按钮时，我们会看到重复的输出，其中包括在 `ActiveWorkBook` 中生成的图形以及表单中 `PictureBox`
    控件内显示的图片：
- en: '![Inserting multimedia in a sheet](img/image00523.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中插入多媒体](img/image00523.jpeg)'
- en: Other common usages of Excel Interop include the automation of graphic reports,
    the generation of bulk e-mails, and automatic generation of business documents
    (invoices, receipts, and so on).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Excel Interop 的其他常见用途包括图形报告的自动化、批量电子邮件的生成以及商业文档（发票、收据等）的自动生成。
- en: Interop with Microsoft Word
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Microsoft Word 互操作
- en: The other big star in Office Automation solutions is Microsoft Word. Just like
    Excel, it exposes a very complete **Object Model** (**OM**), updated to expose
    the new features accompanying every release, and it's fully programmable in the
    same fashion as what we've been doing with Excel.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Office 自动化解决方案中的另一个明星是 Microsoft Word。就像 Excel 一样，它提供了一个非常完整的 **对象模型**（**OM**），更新以展示每个版本的新功能，并且可以像我们对
    Excel 所做的那样完全编程。
- en: Naturally, Word's OM, or just WOM, is radically different from Excel and includes
    all the characteristics a programmer would need to automate practically any task.
    Actually, the user interface objects (as it happens with Excel) are faithfully
    represented, and that includes the ability to invoke dialog boxes that launch
    certain processes (such as spellcheck) or any other typical configuration feature
    of the editor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，Word 的 OM，或简称 WOM，与 Excel 完全不同，包括程序员自动化任何任务所需的所有特性。实际上，用户界面对象（正如 Excel 的情况一样）得到了忠实的表现，这包括调用对话框以启动某些进程（如拼写检查）或编辑器的任何其他典型配置功能。
- en: 'As with Excel, automation takes place using a PIA (`Microsoft.Office.Interop.Word.dll`),
    and the initialization process is quite similar:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Excel 一样，自动化是通过 PIA (`Microsoft.Office.Interop.Word.dll`) 实现的，初始化过程相当相似：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Provided that we have a button (`btnOpenWord`), we instantiate a Word object
    at initialization time; so, when the user clicks, we just have to make Word visible
    and use the `Selection` object (which, in case there's nothing selected yet, refers
    to the caret).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个按钮（`btnOpenWord`），我们在初始化时实例化一个 Word 对象；因此，当用户点击时，我们只需使 Word 可见并使用 `Selection`
    对象（如果尚未选择任何内容，则它引用光标）。
- en: 'From this point, `Selection` offers several methods to insert text (`InsertDatetime`,
    `InsertAfter`, `InsertBefore`, `InsertParagraph`, `Text`, and so on). Note how
    the resulting process writes to Word and the whole text inserted remains selected:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，`Selection` 提供了多种方法来插入文本（`InsertDatetime`、`InsertAfter`、`InsertBefore`、`InsertParagraph`、`Text`
    等）。注意，这个过程将写入 Word，并且插入的整个文本都保持选中状态：
- en: '![Interop with Microsoft Word](img/image00524.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![与 Microsoft Word 互操作](img/image00524.jpeg)'
- en: 'As always, it''s important to release objects used during runtime. So, we code
    the following in the `form_closing` event:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在运行时释放所使用的对象是很重要的。因此，我们在 `form_closing` 事件中编写了以下代码：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The manipulation of images is even easier, since we can reference any external
    image with a few lines of code. To load the same image as in the Excel demos,
    we would use the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的处理甚至更加简单，因为我们只需几行代码就可以引用任何外部图像。为了加载与 Excel 演示中相同的图像，我们会使用以下代码：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's important to specify here the position of the image because otherwise,
    the whole selection would be replaced by the `AddPicture` method. This is why
    we add a fourth parameter (`Range`), which allows us to indicate where the image
    should go.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里指定图像的位置很重要，因为否则整个选择将被`AddPicture`方法替换。这就是为什么我们添加一个第四个参数（`Range`），这允许我们指明图像应该放在哪里。
- en: 'Also, observe how we can always know every aspect of the document''s elements
    (the number of characters and collections of `Rows`, `Columns`, `Shapes`, `Tables`,
    `Paragraphs`, and so on). In addition, since we can now use named parameters,
    we just have to pass the required ones:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，观察我们如何始终了解文档元素的所有方面（字符数和`Rows`、`Columns`、`Shapes`、`Tables`、`Paragraphs`等的集合）。此外，由于我们现在可以使用命名参数，我们只需传递所需的参数即可：
- en: '![Interop with Microsoft Word](img/image00525.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![与Microsoft Word的互操作性](img/image00525.jpeg)'
- en: 'Formatting can also be achieved very easily by selecting a `Range` object and
    configuring it to the required values (we created a special button for this named
    `btnFormat`; so, in the `Click` event, we code the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择一个`Range`对象并将其配置到所需值，格式化也可以非常容易地实现（我们为此创建了一个名为`btnFormat`的特殊按钮；因此，在`Click`事件中，我们编写以下代码：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the previous text in our document, once the click event is invoked, we''ll
    get the output shown in this capture:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文档中的前一段文本，一旦点击事件被触发，我们就会得到这个捕获中显示的输出：
- en: '![Interop with Microsoft Word](img/image00526.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![与Microsoft Word的互操作性](img/image00526.jpeg)'
- en: Another very common use of Word relates to its ability to operate with text
    and return such text to the caller function. This is especially useful in checking
    spelling and other internal engines, such as grammar revision.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Word的另一个非常常见的用途与其操作文本并返回文本到调用函数的能力有关。这在检查拼写和其他内部引擎，如语法修订时特别有用。
- en: 'The technique consists of passing the required text to Word, selecting it,
    and launching the **Spell & Grammar** dialog box to operate on it. Once the text
    is revised, we can return the corrected text to the calling application. Let''s
    see how this works in a sample. We have a button labeled `Spell Check` (named
    `btnSpellCheck`), which launches the process of spelling correction using this
    code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术包括将所需文本传递给Word，选择它，并启动**拼写和语法**对话框来操作它。一旦文本被修订，我们就可以将修正后的文本返回到调用应用程序。让我们看看在示例中它是如何工作的。我们有一个名为`Spell
    Check`（命名为`btnSpellCheck`）的按钮，它使用以下代码启动拼写校正过程：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output consists of three elements: our .NET application, Word, and the
    **Spell & Grammar** dialog box, which is launched when we call the `CheckSpelling`
    method, as shown in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括三个元素：我们的.NET应用程序、Word以及当调用`CheckSpelling`方法时启动的**拼写和语法**对话框，如下面的截图所示：
- en: '![Interop with Microsoft Word](img/image00527.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![与Microsoft Word的互操作性](img/image00527.jpeg)'
- en: When the process is over, the corrected results are returned to the caller function,
    where we update the `RichTextBox` control used to hold the text. Note that you
    can keep Word invisible and the only functionality available in the user interface
    would be your application and the **Spell & Grammar** dialog box.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程结束后，修正后的结果会返回给调用函数，在那里我们更新用于保存文本的`RichTextBox`控件。请注意，您可以保持Word不可见，用户界面中唯一可用的功能就是您的应用程序和**拼写和语法**对话框。
- en: 'Also, note that we check the presence of an opened document, which should otherwise
    generate a runtime exception. After the process, our `RichTextBox` control will
    contain the corrected text, as expected:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们检查是否存在打开的文档，否则将生成运行时异常。在过程结束后，我们的`RichTextBox`控件将包含预期的修正文本：
- en: '![Interop with Microsoft Word](img/image00528.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![与Microsoft Word的互操作性](img/image00528.jpeg)'
- en: Besides this utility, practically any other Office-related functionality is
    available via automation in a similar manner. However, this is not the only way
    we can use and extend the Office functionality by means of .NET applications.
    Actually, one of the most successful options relies on Add-In constructions or
    Office apps.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个实用程序之外，实际上任何其他与Office相关的功能都可以通过类似的方式进行自动化。然而，这并不是我们通过.NET应用程序使用和扩展Office功能的唯一方法。实际上，最成功的一种选择依赖于插件构造或Office应用程序。
- en: Office apps
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Office应用程序
- en: 'On the official page of Office 2013 (the version we''re using here, although
    this sample works perfectly well in the 2016 version), Office Apps are defined
    in this way:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Office 2013的官方页面（我们在这里使用的是这个版本，尽管这个示例在2016版本中也运行得很好），Office应用程序是这样定义的：
- en: Apps for Office enable users to run the same solutions across applications,
    platforms, and devices, and provide an improved experience within Office applications
    by integrating rich content and services from the web.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Office应用程序使用户能够在应用程序、平台和设备上运行相同的解决方案，并通过整合来自网络的丰富内容和服务，在Office应用程序中提供改进的体验。
- en: The key architecture is explained a bit further, pointing out that these apps
    run within supported Office 2013 applications by using the power of the web and
    standard web technologies such as HTML5, XML, CSS3, JavaScript, and REST APIs.
    This is very important for a number of reasons.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关键架构进一步解释了，指出这些应用程序通过使用网络的力量和标准网络技术（如HTML5、XML、CSS3、JavaScript和REST API）在支持的Office
    2013应用程序中运行。这一点非常重要，原因有很多。
- en: First, the use of standard technologies allows us to incorporate any previous
    or already created, functional content we might have. If it works on the Web,
    it'll work on one of these apps (although automation via JavaScript APIs does
    not cover all possibilities that PIAs offer). However, on the other hand, APIs
    exposed by JavaScript 5/6 make a number of new programming options available to
    developers (Web Workers, Web Sockets, and so on).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，标准技术的使用使我们能够整合我们可能拥有的任何先前或已经创建的功能性内容。如果它在Web上工作，它将在这些应用程序之一上工作（尽管通过JavaScript
    API的自动化并不涵盖PIAs提供的所有可能性）。然而，另一方面，JavaScript 5/6暴露的API为开发人员提供了许多新的编程选项（Web Workers、Web
    Sockets等）。
- en: 'If this is not enough, consider the huge amount of JavaScript and CSS frameworks
    available today: jQuery, BootStrap, Angular, among others. We can use all of them
    in these applications. Overall, we''re talking about a webpage that is hosted
    inside an Office client application (Excel, Word, PowerPoint, and Project are
    available options).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，请考虑今天可用的大量JavaScript和CSS框架：jQuery、BootStrap、Angular等。我们可以在这些应用程序中使用所有这些框架。总的来说，我们谈论的是一个托管在Office客户端应用程序（Excel、Word、PowerPoint和Project都是可用选项）内的网页。
- en: Note that these apps can run in desktop clients, Office Online, mobile browsers,
    and on premises and in the cloud as well. Options of deployment include the Office
    Store or on-site catalogs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些应用程序可以在桌面客户端、Office Online、移动浏览器以及本地和云环境中运行。部署选项包括Office Store或现场目录。
- en: Let's see how this works, by using the default template that Visual Studio 2015
    offers and analyzing and customizing these contents for an initial, working demo.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的，通过使用Visual Studio 2015提供的默认模板，分析和自定义这些内容以创建一个初始的、可工作的演示。
- en: The Office app default project
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Office应用程序默认项目
- en: 'So, let''s create a new project and select the **Visual C#-Office/SharePoint-Apps**
    tree element: we''re offered three choices. If you select the **Apps for Office**
    option, a selection box will be shown (I''ll use **Task pane** here, but you also
    have **Content** and **Mail**):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个新的项目，并选择**Visual C#-Office/SharePoint-Apps**树元素：我们提供了三个选择。如果您选择**Office应用程序**选项，将显示一个选择框（我将使用**任务窗格**，但您也可以选择**内容**和**邮件**）：
- en: '![The Office app default project](img/image00529.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Office应用程序默认项目](img/image00529.jpeg)'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Other templates for many different types of apps are at your disposal on the
    site available at [http://dev.office.com/code-samples#?filters=office%20add-ins](http://dev.office.com/code-samples#?filters=office%20add-ins).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 网站上提供了许多不同类型应用程序的其他模板，该网站地址为[http://dev.office.com/code-samples#?filters=office%20add-ins](http://dev.office.com/code-samples#?filters=office%20add-ins)。
- en: 'In this demo, I opt for Word as a destination Office application, although
    by default, all checkboxes are marked:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我选择Word作为目标Office应用程序，尽管默认情况下所有复选框都被勾选：
- en: '![The Office app default project](img/image00530.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Office应用程序默认项目](img/image00530.jpeg)'
- en: 'If you review the resulting files, you''ll notice that these apps are basically
    composed of two parts: a manifest file, which configures the app''s behavior,
    and a web page, which references all required resources: jQuery, style sheets,
    JavaScript initialization files, a `web.config` file, and so on.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看生成的文件，您会注意到这些应用程序基本上由两部分组成：一个清单文件，它配置应用程序的行为；以及一个网页，它引用所有必需的资源：jQuery、样式表、JavaScript初始化文件、`web.config`文件等。
- en: 'If you open the manifest file, you''ll see that Visual Studio offers a configuration
    file editor, where you can indicate every functional aspect. A note within the
    **Activation** tab of that window reminds us of the possible targets where this
    app will possibly work:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开清单文件，您会看到Visual Studio提供了一个配置文件编辑器，您可以在其中指示每个功能方面。在该窗口的**激活**选项卡中的注释提醒我们这个应用程序可能工作的目标：
- en: '![The Office app default project](img/image00531.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Office应用默认项目](img/image00531.jpeg)'
- en: Actually, this template already works once compiled, and it operates over a
    block of selected text, passing it back to the **Task** pane, which will appear
    to the right of a new Word document, showing the `Home.html` page. This page,
    in turn, loads the `Home.js` and `app.js` files, which take care of initialization.
    Other `.css` files are added for formatting purposes as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个模板一旦编译就可以工作，它操作所选文本块，将其传递回**任务**窗格，该窗格将出现在新Word文档的右侧，显示`Home.html`页面。这个页面反过来加载`Home.js`和`app.js`文件，负责初始化。此外，还添加了`.css`文件用于格式化。
- en: 'Besides this, there''s a very important piece of JavaScript that is referenced
    via CDN, `office.js`. This is the library in charge of the traffic between the
    two worlds present here: the Office programming model and the HTML5/CSS3/JS world.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个非常重要的JavaScript代码片段，通过CDN引用，名为`office.js`。这是负责此处两个世界之间交通的库：Office编程模型和HTML5/CSS3/JS世界。
- en: 'There''s a graphic schema on the page at [https://technet.microsoft.com/en-us/library/jj219429.aspx](https://technet.microsoft.com/en-us/library/jj219429.aspx),
    which offers a visual look at the scenario at runtime:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上有一个图形方案在[https://technet.microsoft.com/en-us/library/jj219429.aspx](https://technet.microsoft.com/en-us/library/jj219429.aspx)，它提供了在运行时对该场景的视觉观察：
- en: '![The Office app default project](img/image00532.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Office应用默认项目](img/image00532.jpeg)'
- en: 'To run the test, launch the application from Visual Studio, and when Word appears,
    type some text and select it. Optionally, you can try the *lorem trick* (you might
    know it already): simply type `=lorem(n)` in the document, where *n* is the number
    of lorem paragraphs you want to generate, and lorem text will automatically get
    appended to the current text of the document.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，从Visual Studio启动应用程序，当Word出现时，输入一些文本并选择它。可选地，你可以尝试*lorem技巧*（你可能已经知道了）：只需在文档中输入`=lorem(n)`，其中*n*是你想要生成的lorem段落数量，lorem文本将自动附加到文档的当前文本。
- en: 'Once we do that and select a fragment, the button labeled **Get data from selection**
    will recover the selected text and present it at the bottom of the **Task** pane.
    You should see something similar to what is shown in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做并选择一个片段，标记为**从选择获取数据**的按钮将恢复所选文本，并在**任务**窗格的底部展示它。你应该看到以下截图所示的内容：
- en: '![The Office app default project](img/image00533.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Office应用默认项目](img/image00533.jpeg)'
- en: Architectural differences
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构差异
- en: Note that this time, there's no reference to Interop libraries. This is a big
    architectural change, and it's undertaken by the Office JavaScript Object Model—not
    as exhaustive as the ones in PIAs libraries but wide enough to provide us with
    a lot of useful options.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次没有引用Interop库。这是一个重大的架构变化，由Office JavaScript对象模型承担——虽然不如PIAs库中的详尽，但足够宽泛，为我们提供了许多有用的选项。
- en: 'Let''s add a very simple method to show how we can operate in the opposite
    direction: inserting text into the document from the **Task** pane.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个非常简单的方法来展示我们如何反向操作：从**任务**窗格向文档中插入文本。
- en: 'First, we need to add a new element to the **Task** pane user interface. A
    simple button will suffice for our purposes, so we''ll add a new button next to
    the already existing `get-data-from-selection` button: one that I''ll call `insert-data-from-Task-Pane`
    in the `Home.html` file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向**任务**窗格用户界面添加一个新元素。一个简单的按钮就足够我们使用了，所以我们在现有的`get-data-from-selection`按钮旁边添加一个新按钮：在`Home.html`文件中，我将称之为`insert-data-from-Task-Pane`：
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is programming the button''s click event handler in a manner
    similar to what the template demo does, only simplifying the code to the maximum
    here. Thus, inside the `Home.js` file and next to the initialization of the other
    button, we will add a similar function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是按照模板演示的方式编程按钮的点击事件处理程序，但在这里将代码简化到最大程度。因此，在`Home.js`文件中，紧邻其他按钮的初始化代码旁边，我们将添加一个类似的功能：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And, the body of `insertDataFromTaskPane`, contains the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，`insertDataFromTaskPane`的主体包含以下代码：
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that no dialog boxes are allowed on a **Task** pane; so we notify the user
    about the success or error of the process, calling `showNotification` on the app
    object, which sends data to the **Task** pane notification area, previously configured
    in the initialization process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**任务**窗格不允许使用对话框；因此，我们通过在应用程序对象上调用`showNotification`来通知用户过程的成功或错误，将数据发送到之前在初始化过程中配置的**任务**窗格通知区域。
- en: 'Consequently, we''re moving in both directions here: from the **Task** pane
    to the Word document, inserting a couple of lines and notifying how things worked
    out in the opposite direction. Observe that the `setSelectedDataAsync` method
    provides us with a mechanism to insert data into the document in a manner similar
    to what we did previously with `insertAfter` methods of the PIAs object model.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里向两个方向前进：从**任务窗格**到Word文档，插入几行并通知相反方向的工作情况。注意，`setSelectedDataAsync`方法为我们提供了一个机制，以类似于我们之前使用PIAs对象模型的`insertAfter`方法的方式将数据插入文档中。
- en: Finally, remember that in the JavaScript world it's usual to assign a callback
    function as the last argument of many function calls in order to allow feedback
    on the resulting method or add an extra functionality once execution is finished.
    The argument recovered in the function declaration (the `result` object) contains
    properties that include relevant information, such as the status of the operation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，在JavaScript世界中，通常将回调函数作为许多函数调用的最后一个参数来分配，以便在方法执行完成后提供反馈或添加额外的功能。在函数声明中恢复的参数（`result`对象）包含包括操作状态等相关信息在内的属性。
- en: There's plenty of information about programming this type of application in
    the MSDN documentation, in which you'll be able to see new types of applications
    of this sort, especially applications that allow the construction of Add-ins for
    Office 365.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSDN文档中关于编程此类应用程序的信息非常丰富，你将能够看到这类应用的新类型，特别是允许构建Office 365插件的程序。
- en: 'Just for the sake of completeness, let''s show the results of the previous
    code in this screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了完整性，让我们通过这张截图展示之前代码的结果：
- en: '![Architectural differences](img/image00534.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![架构差异](img/image00534.jpeg)'
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw several aspects of programming that have to do with the ability of .NET
    Framework to introspect its own assemblies and invoke its functionality in a standard
    fashion and even use CodeDOM's possibilities to generate code at runtime, enabling
    a generation of templates and other code fragments at will.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了与.NET Framework能够以标准方式自省其自己的程序集并调用其功能，甚至使用CodeDOM的可能性在运行时生成代码相关的编程的几个方面，这使我们可以随意生成模板和其他代码片段。
- en: We also saw a brief intro to `Reflection.Emit` just to check how it's possible
    to generate IL code at runtime and insert it into other executable code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要介绍了`Reflection.Emit`，只是为了检查如何在运行时生成IL代码并将其插入其他可执行代码中。
- en: In the second part of this chapter, we covered the most common scenarios used
    in Office Automation, a technique that allows us to call functionalities included
    in Office, such as Excel and Word, and interact with them via proxy libraries
    (the Primary Interop Assemblies) in a way in which we gain almost absolute control
    over the other applications, being able to pass and recover information between
    our application and the Office partner via instructions emitted to these proxies.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们涵盖了在Office自动化中最常见的场景，这是一种允许我们调用包括Excel和Word在内的Office中包含的功能的技术，并通过代理库（主互操作程序集）与之交互，以几乎绝对控制其他应用程序的方式，能够通过向这些代理发出的指令在应用程序和Office合作伙伴之间传递和恢复信息。
- en: We finally included a short introduction to the new way of building components,
    which appeared in version 2013 of Office (Office apps) and saw the basic architecture
    of these types of components, reviewing the basic template Visual Studio offers
    and modifying it to include a simple, double direction functionality via **Office
    JavaScript Object Model**.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终包括了关于构建组件新方法的简要介绍，这种方法出现在Office 2013版本（Office应用）中，并了解了这些类型组件的基本架构，回顾了Visual
    Studio提供的基本模板，并将其修改为通过**Office JavaScript对象模型**实现简单、双向的功能。
- en: In the next chapter, we will focus on database programming, covering the foundations
    of interactions with relational models available in Visual Studio.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于数据库编程，涵盖在Visual Studio中可用的关系模型交互的基础。
