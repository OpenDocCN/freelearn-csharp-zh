- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Caching, Queuing, and Resilient Background Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存、队列和弹性后台服务
- en: In this chapter, you will be introduced to multiple technologies and techniques
    that will improve the scalability and reliability of your services, no matter
    what service technology you choose to implement them with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解多种技术和技巧，这些技术和技巧将提高你服务的可扩展性和可靠性，无论你选择哪种服务技术来实现。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding service architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务架构
- en: Caching with ASP.NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 进行缓存
- en: Fault tolerance with Polly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Polly 实现容错
- en: Queuing with RabbitMQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RabbitMQ 进行队列
- en: Implementing long-running background services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现长时间运行的后台服务
- en: Understanding service architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务架构
- en: In *Chapter 8*, *Building and Securing Web Services Using Minimal APIs*, you
    learned how to build a web service using ASP.NET Core Minimal APIs. Before looking
    at alternative technologies to build services, it is worth taking a step back
    and reviewing service architecture and what causes bottlenecks in service performance
    and scalability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 8 章*，*使用最小 API 构建和保障 Web 服务* 中，你学习了如何使用 ASP.NET Core 最小 API 构建一个 Web 服务。在查看构建服务的替代技术之前，值得退一步回顾服务架构以及是什么原因导致服务性能和可扩展性的瓶颈。
- en: What parts of a system are slowest?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统中最慢的部分是什么？
- en: 'Traditionally, the slowest parts of a system are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，系统中最慢的部分是：
- en: The network (slowest)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络（最慢）
- en: The disk
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘
- en: Memory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: CPU cache memory (fastest)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 缓存内存（最快）
- en: Each step can be 5 to 10 times slower than the next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步可能比下一步慢 5 到 10 倍。
- en: However, networks are much faster than they used to be, and systems often run
    within remote data centers. Imagine your service needs some data. Is it faster
    to read from the local server disk or to make a call to another server?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，网络比以前快得多，系统通常在远程数据中心运行。想象一下，如果你的服务需要一些数据，是直接从本地服务器磁盘读取更快，还是调用另一个服务器更快？
- en: 'Server-to-server call within the same data center: 500,000 nanoseconds (ns)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一数据中心内的服务器到服务器调用：500,000 纳秒（ns）
- en: 'Disk seek: 10,000,000 ns'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘寻道：10,000,000 ns
- en: Numbers every (developer) should know
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个开发者都应该知道的数字
- en: 'Jeff Dean, a Google Fellow, quotes in his presentations the actual times in
    nanoseconds (ns) for various technologies to access or read data. They are shown
    in *Table 9.1*, and I have added a column to scale the numbers to be more comprehensible
    to a human:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌公司高级工程师杰夫·迪恩在他的演讲中引用了各种技术访问或读取数据的实际纳秒（ns）时间。它们显示在 *表 9.1* 中，并且我添加了一列来将数字换算成更易于人类理解的单位：
- en: '| **Technology** | **Actual** | **Humanized** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **技术** | **实际** | **人性化** |'
- en: '| CPU cycle | 0.1 ns | 1 second |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| CPU 周期 | 0.1 ns | 1 秒 |'
- en: '| L1 cache reference | ½ ns | 5 seconds |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| L1 缓存引用 | ½ ns | 5 秒 |'
- en: '| L2 cache reference | 5 ns | 1 minute |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| L2 缓存引用 | 5 ns | 1 分钟 |'
- en: '| Mutex lock/unlock | 25 ns | 4 minutes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 锁定/解锁互斥锁 | 25 ns | 4 分钟 |'
- en: '| Main memory reference | 100 ns | ¼ hour |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 主内存引用 | 100 ns | ¼ 小时 |'
- en: '| Send 1K byte over 1 Gbps network | 10,000 ns | 28 hours |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 在 1 Gbps 网络上发送 1K 字节 | 10,000 ns | 28 小时 |'
- en: '| Read 1 MB sequentially from memory | 250,000 ns | 29 days |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 从内存中顺序读取 1 MB | 250,000 ns | 29 天 |'
- en: '| Round trip within same datacenter | 500,000 ns | 2 months |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 同一数据中心内的往返 | 500,000 ns | 2 个月 |'
- en: '| Read 1 MB sequentially from SSD | 1,000,000 ns | 4 months |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 从 SSD 顺序读取 1 MB | 1,000,000 ns | 4 个月 |'
- en: '| Disk seek | 10,000,000 ns | 3¼ years |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 磁盘寻道 | 10,000,000 ns | 3¼ 年 |'
- en: '| Read 1 MB sequentially from disk | 20,000,000 ns | 6¼ years |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 从磁盘顺序读取 1 MB | 20,000,000 ns | 6¼ 年 |'
- en: '| Send packet CA->Netherlands->CA | 150,000,000 ns | 47½ years |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 从加拿大到荷兰的 CA 发送数据包 | 150,000,000 ns | 47½ 年 |'
- en: 'Table 9.1: Nanosecond times for various technologies to access or read data'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1：各种技术访问或读取数据的纳秒时间
- en: '**More Information**: *Designs, Lessons, and Advice from Building Large Distributed
    Systems*, by Jeff Dean, [http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：杰夫·迪恩所著的 *构建大型分布式系统的设计、经验和建议*，[http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)。'
- en: The point is not to debate if reading from drives or SSDs is faster or not than
    network calls. It is more about being aware of the differences between getting
    data that’s close and data that’s far away. The orders of magnitude are comparatively
    massive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是不要争论从驱动器或 SSD 读取是否比网络调用更快，更重要的是要意识到获取近处数据和远处数据的差异。数量级上的差异是相当巨大的。
- en: For example, if a CPU needs to process some data and it is already in the L1
    cache, then it takes the equivalent of 1 second. If it needs to read the data
    from memory, it takes the equivalent of a quarter of an hour. If it needs to fetch
    that data from a server in the same data center, it takes the equivalent of 2
    months. And if it is in California and the data is in the Netherlands, it takes
    the equivalent of 47½ years!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个 CPU 需要处理一些数据，并且它已经在 L1 缓存中，那么它只需要相当于 1 秒的时间。如果它需要从内存中读取数据，那么它需要相当于四分之一小时的时间。如果它需要从同一数据中心的服务器中获取数据，那么它需要相当于
    2 个月的时间。如果它在加利福尼亚，而数据在荷兰，那么它需要相当于 47½ 年的时间！
- en: This is why caching is so important. Caching is about temporarily storing data
    as close to where it will be needed as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么缓存如此重要的原因。缓存是将数据临时存储在尽可能接近需要的地方。
- en: Caching with ASP.NET Core
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 进行缓存
- en: Caching can enable our systems to copy some data from a remote data center to
    a local data center, or from a server or disk to memory. Caches store data as
    key-value pairs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以使我们的系统从远程数据中心复制一些数据到本地数据中心，或者从服务器或磁盘到内存。缓存以键值对的形式存储数据。
- en: However, one of the hardest parts of caching is getting the balance right between
    storing enough data and keeping it fresh. The more data we copy, the more resources
    we use. And we need to consider how we will keep the copies synchronized with
    the original data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缓存中最困难的部分之一是找到存储足够数据和保持数据新鲜之间的平衡。我们复制的越多，我们使用的资源就越多。我们需要考虑如何保持副本与原始数据的一致性。
- en: General caching guidelines
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用缓存指南
- en: Caching works best with data that costs a lot to generate and does not change
    often.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存最适合成本高昂且不经常更改的数据。
- en: 'Follow these guidelines when caching:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存时遵循以下指南：
- en: Your code should never depend on cached data. It should always be able to get
    the data from the original source when the data is not found in the cache.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码永远不应该依赖于缓存数据。当数据在缓存中找不到时，它应该始终能够从原始源获取数据。
- en: Wherever you cache data (in-memory or in a database) it is a limited resource,
    so deliberately limit the amount of data cached and for how long by implementing
    expirations and size limits. You should monitor cache hits (when data is successfully
    found in the cache) to obtain the right balance for your specific scenarios.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你在哪里缓存数据（内存或数据库），它都是有限的资源，因此应通过实现过期和大小限制来故意限制缓存的数据量和缓存时间。你应该监控缓存命中（当数据在缓存中成功找到时）以获得特定场景的正确平衡。
- en: In the coding tasks in this section, you will implement all of these guidelines.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的编码任务中，你将实现所有这些指南。
- en: Let’s start by reviewing the caching technologies built-in to ASP.NET Core.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下 ASP.NET Core 内置的缓存技术。
- en: Building a controller-based Web API service
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基于控制器的 Web API 服务
- en: 'To explore various caching technologies, let’s build a basic web service:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索各种缓存技术，让我们构建一个基本的 Web 服务：
- en: 'Use your preferred code editor to create a new Web API controller-based project,
    as defined in the following list:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个新的基于控制器的 Web API 项目，如下所示：
- en: Project template: **ASP.NET Core Web API** / `webapi --use-controllers`
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**ASP.NET Core Web API** / `webapi --use-controllers`
- en: Solution file and folder: `Chapter09`
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: Project file and folder: `Northwind.WebApi.Service`
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.WebApi.Service`
- en: '**Authentication type**: **None**'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证类型**：**无**'
- en: '**Configure for HTTPS**: Selected'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置 HTTPS**：已选择'
- en: '**Enable Docker**: Cleared'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 Docker**：已清除'
- en: '**Use controllers**: Selected'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用控制器**：已选择'
- en: '**Enable OpenAPI support**: Selected'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 OpenAPI 支持**：已选择'
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不使用顶层语句**：已清除'
- en: Make sure to select the **Use controllers** checkbox or specify the `--use-controllers`
    or `-controllers` switch. We will not use minimal APIs, which is the default way
    a Web API is implemented using the .NET 8 project templates. If you use JetBrains
    Rider, you might want to use the `dotnet new` command until Rider supports a **Use
    controllers** option.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保选择 **使用控制器** 复选框或指定 `--use-controllers` 或 `-controllers` 开关。我们不会使用最小 API，这是使用
    .NET 8 项目模板实现 Web API 的默认方式。如果你使用 JetBrains Rider，你可能想使用 `dotnet new` 命令，直到 Rider
    支持一个 **使用控制器** 选项。
- en: 'Add a project reference to the Northwind database context project for the SQL
    Server that you created in *Chapter 3*, *Building Entity Models for SQL Server
    Using EF Core*, as shown in the following markup:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目引用添加到你在 *第 3 章*，*使用 EF Core 为 SQL Server 构建实体模型* 中创建的 Northwind 数据库上下文项目，如下所示：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The path cannot have a line break. If you did not complete the task of creating
    the class libraries in *Chapter 3*, then download the solution projects from the
    GitHub repository.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径不能有换行符。如果你没有完成 *第 3 章* 中创建类库的任务，那么请从 GitHub 仓库下载解决方案项目。
- en: 'In the project file, change invariant globalization to `false`, and treat warnings
    as errors, as shown in the following markup:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，将不变全球化更改为 `false`，并将警告视为错误，如下标记所示：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Explicitly setting invariant globalization to `true` is new in the ASP.NET
    Core Web API project template with .NET 8\. It is designed to make a web service
    non-culture-specific so that it can be deployed anywhere in the world and have
    the same behavior. By setting this property to `false`, the web service will default
    to the culture of the current computer it is hosted on. You can read more about
    invariant globalization mode at the following link: [https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md](https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md).'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显式地将不变全球化设置为 `true` 是 .NET 8 的 ASP.NET Core Web API 项目模板中的新功能。它旨在使 web 服务不受文化限制，以便可以在世界任何地方部署并具有相同的行为。通过将此属性设置为
    `false`，web 服务将默认为当前托管计算机的文化。你可以在以下链接中了解更多关于不变全球化模式的信息：[https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md](https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md)。
- en: 'At the command prompt or terminal, build the `Northwind.WebApi.Service` project
    to make sure the entity model class library projects outside the current solution
    are properly compiled, as shown in the following command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，构建 `Northwind.WebApi.Service` 项目以确保当前解决方案之外的实体模型类库项目被正确编译，如下命令所示：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `Properties` folder, in `launchSettings.json`, modify the `applicationUrl`
    of the profile named `https` to use port `5091` for `https` and port `5092` for
    `http`, as highlighted in the following configuration:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Properties` 文件夹中，在 `launchSettings.json` 中，将名为 `https` 的配置文件的 `applicationUrl`
    修改为使用端口 `5091` 用于 `https` 和端口 `5092` 用于 `http`，如下配置所示：
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Visual Studio 2022 and JetBrains Rider will read this settings file and automatically
    run a web browser if `launchBrowser` is `true`, and then navigate to the `applicationUrl`
    and `launchUrl`. Visual Studio Code and `dotnet run` will not, so you will need
    to run a web browser and navigate manually to [https://localhost:5091/swagger](https://localhost:5091/swagger).
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Visual Studio 2022 和 JetBrains Rider 将读取此设置文件，如果 `launchBrowser` 为 `true`，则自动运行一个浏览器，并导航到
    `applicationUrl` 和 `launchUrl`。Visual Studio Code 和 `dotnet run` 不会这样做，因此你需要手动运行一个浏览器并手动导航到
    [https://localhost:5091/swagger](https://localhost:5091/swagger)。
- en: Delete the file named `WeatherForecast.cs`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除名为 `WeatherForecast.cs` 的文件。
- en: In the `Controllers` folder, delete the file named `WeatherForecastController.cs`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Controllers` 文件夹中，删除名为 `WeatherForecastController.cs` 的文件。
- en: 'In `Program.cs`, import the namespace to add the `NorthwindContext` to configured
    services, as highlighted in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入命名空间以将 `NorthwindContext` 添加到配置的服务中，如下代码所示：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `Controllers` folder, add a new class file named `ProductsController.cs`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Controllers` 文件夹中，添加一个名为 `ProductsController.cs` 的新类文件。
- en: 'In `ProductsController.cs`, modify its contents to define a controller-based
    Web API to work with products in the Northwind database, as we did for minimal
    APIs, as shown in the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 中，修改其内容以定义一个基于控制器的 Web API，用于与 Northwind 数据库中的产品一起工作，就像我们对最小
    API 所做的那样，如下代码所示：
- en: '[PRE5]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If your database server is not running, for example, because you are hosting
    it in Docker, a virtual machine, or the cloud, then make sure to start it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的数据库服务器没有运行，例如，因为你正在 Docker、虚拟机或云中托管它，那么请确保启动它。
- en: Start the web service project using the `https` profile without debugging.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 配置文件不调试启动 web 服务项目。
- en: If you are using Visual Studio 2022, then select the **https** profile in the
    drop-down list, and then navigate to **Debug** | **Start Without Debugging** or
    press *Ctrl* + *F5*. A web browser should navigate to the Swagger documentation
    web page automatically.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio 2022，则在下拉列表中选择 **https** 配置文件，然后导航到 **调试** | **不调试启动**
    或按 *Ctrl* + *F5*。浏览器应自动导航到 Swagger 文档网页。
- en: 'If you are using Visual Studio Code, then enter the command `dotnet run --launch-profile
    https`, manually start a web browser, and navigate to the Swagger documentation
    web page: [https://localhost:5091/swagger](https://localhost:5091/swagger).'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio Code，那么输入命令 `dotnet run --launch-profile https`，手动启动一个网页浏览器，并导航到
    Swagger 文档网页：[https://localhost:5091/swagger](https://localhost:5091/swagger)。
- en: On Windows, if prompted to do so, you will have to set the Windows Defender
    Firewall to allow access to your local web service.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Windows 上，如果需要，你必须将 Windows Defender 防火墙设置为允许访问你的本地 Web 服务。
- en: 'Use Swagger to test the various endpoints, and note the SQL statements logged
    to the output as you do so, for example:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Swagger 测试各种端点，并注意你这样做时记录到输出的 SQL 语句，例如：
- en: Get the first page of 10 products.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 10 个产品中的第一页。
- en: Get the 6th page of 10 products.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 10 个产品中的第 6 页。
- en: Get the product with an ID of 77.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 ID 为 77 的产品。
- en: Get the single out-of-stock product.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取单个缺货产品。
- en: Get the seven discontinued products.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 7 个已停售的产品。
- en: Get products whose names start with `cha`.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取名称以 `cha` 开头的产品。
- en: 'Create (`POST`), update (`PUT`), and delete a product. For hints about how
    to perform these tests, read the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/ch09-swagger-tests.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch09-swagger-tests.md).'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建（`POST`）、更新（`PUT`）和删除一个产品。有关如何执行这些测试的提示，请阅读以下链接：[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch09-swagger-tests.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch09-swagger-tests.md)。
- en: If you completed *Chapter 8*, *Building and Securing Web Services Using Minimal
    APIs*, then instead of manually using Swagger, you can use the `.http` files we
    created to test the minimal API web service. Just change the port from `5081`
    to `5091`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了 *第 8 章*，*使用 Minimal APIs 构建和保障 Web 服务*，那么你就可以使用我们创建的 `.http` 文件来测试最小
    API Web 服务，而无需手动使用 Swagger。只需将端口从 `5081` 更改为 `5091`。
- en: Now that we have a basic web service, we can start activating caching in it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基本的 Web 服务，我们可以在其中开始启用缓存。
- en: Caching objects using in-memory caching
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存缓存缓存对象
- en: The `IMemoryCache` interface represents a cache that uses local server memory.
    If you have multiple servers hosting your service or website, then you must enable
    “sticky sessions.” This means that an incoming request from a client or visitor
    will be directed to the same server as previous requests from that client or visitor,
    allowing the request to find the correct cached data in that server’s memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMemoryCache` 接口表示一个使用本地服务器内存的缓存。如果你有多个服务器托管你的服务或网站，那么你必须启用“粘性会话”。这意味着来自客户端或访客的传入请求将被定向到与该客户端或访客之前请求相同的服务器，从而使请求能够在该服务器的内存中找到正确的缓存数据。'
- en: The `Microsoft.Extensions.Caching.Memory` package has a modern implementation
    of `IMemoryCache`. Avoid the older `System.Runtime.Caching`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Caching.Memory` 包实现了 `IMemoryCache` 的现代版本。避免使用较旧的 `System.Runtime.Caching`。'
- en: Sizes are defined using custom units. If you store simple `string` values, then
    you could use the length of the string. If you don’t know the size, you could
    just use 1 unit for each entry to simply limit the number of entries.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大小使用自定义单位定义。如果你存储简单的 `string` 值，那么你可以使用字符串的长度。如果你不知道大小，你可以为每个条目使用 1 个单位来简单地限制条目数量。
- en: 'When you add an object to a cache, you should set an expiration. There are
    two types, absolute and sliding, and you can set one or the other, both, or neither:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将对象添加到缓存中时，你应该设置一个过期时间。有两种类型，绝对和滑动，你可以设置一个或两个，或者都不设置：
- en: '**Absolute expiration**: This is a fixed date/time, for example, 1am on December
    24, 2023\. When the date/time is reached, the object is evicted. To use this,
    set the `AbsoluteExpiration` property of a cache entry to a `DateTime` value.
    Choose this if you need to guarantee that at some point the data in the cache
    will be refreshed.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对过期**：这是一个固定的日期/时间，例如，2023 年 12 月 24 日凌晨 1 点。当日期/时间到达时，对象将被移除。要使用此功能，请将缓存条目的
    `AbsoluteExpiration` 属性设置为 `DateTime` 值。如果你需要保证缓存中的数据在某个时间点被刷新，请选择此选项。'
- en: '**Sliding expiration**: This is a time span, for example, 20 seconds. When
    the time span expires, the object is evicted. However, whenever an object is read
    from the cache, its expiration is reset for another 20 seconds. This is why it
    is described as *sliding*. A common duration for a **Content Management System**
    (**CMS**), where content like a web page is loaded from a database, is 12 hours.
    Content frequently viewed by visitors, like the home page, is then likely to remain
    in memory. To use this, set the `SlidingExpiration` property of a cache entry
    to a `TimeSpan` value. Choose this if it is acceptable for data to potentially
    never be refreshed. A good CMS will have an additional mechanism to reliably force
    a refresh when new content is published, but this functionality is not built into
    .NET caching.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动过期**：这是一个时间跨度，例如，20 秒。当时间跨度过期时，对象会被移除。然而，每当从缓存中读取对象时，其过期时间会被重置为另一个 20 秒。这就是为什么它被称为
    *滑动*。对于 **内容管理系统**（**CMS**），其中像网页这样的内容是从数据库加载的，常见的持续时间是 12 小时。被访客频繁查看的内容，如主页，因此很可能保留在内存中。要使用此功能，请将缓存条目的
    `SlidingExpiration` 属性设置为 `TimeSpan` 值。如果你可以接受数据可能永远不会刷新，请选择此选项。一个好的 CMS 将具有一个额外的机制，在发布新内容时可靠地强制刷新，但此功能不是内置在
    .NET 缓存中的。'
- en: '**Both expirations**: If you only set a sliding expiration, an object may stay
    in the cache forever, so you might also want to set the `AbsoluteExpirationRelativeToNow`
    property to a `TimeSpan` further in the future, after which the object should
    definitely be evicted. Choose this if you want the best of both worlds.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两种过期方式**：如果你只设置了滑动过期，一个对象可能会永远留在缓存中，因此你可能还想将 `AbsoluteExpirationRelativeToNow`
    属性设置为未来的一个 `TimeSpan`，在此之后对象应该肯定会被移除。如果你想要两者兼得，请选择此选项。'
- en: '**Never**: You can set a cache entry to have a priority of `CacheItemPriority.NeverRemove`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永不**：你可以设置缓存条目具有 `CacheItemPriority.NeverRemove` 的优先级。'
- en: You can also configure a method to call back to when an object is evicted from
    the cache. This allows you to execute some business logic to decide if you want
    to add the object back into the cache, perhaps after refreshing it from the original
    data source. You do this by calling the `RegisterPostEvictionCallback` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以配置一个方法，当对象从缓存中移除时调用。这允许你执行一些业务逻辑来决定是否要将对象重新添加到缓存中，可能是在从原始数据源刷新之后。你可以通过调用
    `RegisterPostEvictionCallback` 方法来完成此操作。
- en: 'Let’s explore the in-memory cache:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索内存缓存：
- en: 'In the `Northwind.WebApi.Service` project, in `Program.cs`, import the namespace
    to work with the in-memory cache, as shown in the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Service` 项目中，在 `Program.cs` 文件中，导入命名空间以使用内存缓存，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Program.cs`, after the call to `CreateBuilder`, in the section for configuring
    services, register an implementation for the in-memory cache, configured to store
    a maximum of 50 products, as shown in the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在调用 `CreateBuilder` 之后，在配置服务的部分中，注册内存缓存的实现，配置为存储最多 50 个产品，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `ProductsController.cs`, import the namespace to work with the in-memory
    cache, as shown in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，导入命名空间以使用内存缓存，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `ProductsController.cs`, declare some fields to store the in-memory cache
    and a key for the out-of-stock products, as shown in the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，声明一些字段来存储内存缓存和缺货产品的键，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `ProductsController.cs`, in the `GetOutOfStockProducts` action method, add
    statements to try to get the cached out-of-stock products, and if they are not
    cached, get them from the database and set them in the cache, using a sliding
    expiration of five seconds, as highlighted in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，在 `GetOutOfStockProducts` 动作方法中，添加语句尝试获取缓存的缺货产品，如果它们未被缓存，则从数据库中获取并将它们设置在缓存中，使用五秒的滑动过期，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Start the web service project using the `https` profile without debugging.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 配置文件启动 Web 服务项目，不进行调试。
- en: Arrange the windows so that you can see the command prompt or terminal at the
    same time as the web page.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口排列好，以便你可以在同时看到命令提示符或终端的同时看到网页。
- en: On the Swagger web page, click **GET /api/product/outofstock** to expand that
    section.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Swagger 网页上，点击 **GET /api/product/outofstock** 来展开该部分。
- en: Click the **Try it out** button.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Try it out** 按钮。
- en: 'Click the **Execute** button, and note in the output that EF Core executes
    a SQL statement to get the products, the total hit counter is zero, and one product
    has now been cached, as shown in the following output:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**执行**按钮，注意在输出中看到 EF Core 执行一个 SQL 语句来获取产品，总命中计数器为零，现在有一个产品已被缓存，如下所示：
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Click **Execute** within five seconds, and continue to click it a few more
    times:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在五秒内点击**执行**，然后继续点击几次：
- en: Note that EF Core does not need to re-execute the SQL statement because the
    products are cached, and if something reads them within a five-second sliding
    expiration, they will stay in memory forever.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 EF Core 不需要重新执行 SQL 语句，因为产品被缓存了，如果有人在五秒滑动过期内读取它们，它们将永远保留在内存中。
- en: 'Note the total hit counter for the cache increments each time the out-of-stock
    products are found in the cache, as shown in the following output:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意缓存的总命中计数器每次在缓存中找到缺货产品时都会增加，如下所示：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Wait at least five seconds.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少等待五秒。
- en: Click **Execute**, and note in the output that EF Core executes a SQL statement
    to get the products because they have not been read within the five-second sliding
    expiration window.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**执行**，注意在输出中看到 EF Core 执行一个 SQL 语句来获取产品，因为它们在五秒滑动过期窗口内没有被读取。
- en: Close the browser and shut down the web server.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器并关闭 web 服务器。
- en: Caching objects using distributed caching
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分布式缓存缓存对象
- en: 'Distributed caches have benefits over in-memory caches. Cached objects:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存比内存缓存有优势。缓存的对象：
- en: Are consistent across requests to multiple servers.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对多个服务器的请求中保持一致性。
- en: Survive server restarts and service deployments.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生存服务器重启和服务部署。
- en: Do not waste local server memory.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会浪费本地服务器内存。
- en: Are stored in a shared area, so in a server farm scenario with multiple servers,
    you do not need to enable sticky sessions.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在共享区域，所以在具有多个服务器的服务器农场场景中，你不需要启用粘性会话。
- en: '**Warning!** A disadvantage of distributed caches is that in-memory caches
    can store any object, but a distributed cache can only store `byte` arrays. Your
    object needs to be serialized and sent across a network to the remote cache.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**分布式缓存的一个缺点是，内存缓存可以存储任何对象，但分布式缓存只能存储 `byte` 数组。你的对象需要被序列化并通过网络发送到远程缓存。'
- en: 'Microsoft provides the `IDistributedCache` interface with pre-defined methods
    to manipulate items in any distributed cache implementation. The methods are:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了 `IDistributedCache` 接口，并预定义了方法来操作任何分布式缓存实现中的项。这些方法包括：
- en: '`Set` or `SetAsync`: To store an object in the cache.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set` 或 `SetAsync`：将对象存储在缓存中。'
- en: '`Get` or `GetAsync`: To retrieve an object from the cache.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get` 或 `GetAsync`：从缓存中检索对象。'
- en: '`Remove` or `RemoveAsync`: To remove an object from the cache.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove` 或 `RemoveAsync`：从缓存中删除对象。'
- en: '`Refresh` or `RefreshAsync`: To reset the sliding expiration for an object
    in the cache.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Refresh` 或 `RefreshAsync`：重置缓存中对象的滑动过期。'
- en: 'There are many implementations of distributed caching to choose from, including
    the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多分布式缓存的实现可供选择，包括以下：
- en: 'SQL Server: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-sql-server-cache](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-sql-server-cache)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQL Server: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-sql-server-cache](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-sql-server-cache)'
- en: 'Redis: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-redis-cache](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-redis-cache)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redis: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-redis-cache](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed#distributed-redis-cache)'
- en: 'NCache: [http://www.alachisoft.com/ncache/aspnet-core-idistributedcache-ncache.html](http://www.alachisoft.com/ncache/aspnet-core-idistributedcache-ncache.html)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NCache: [http://www.alachisoft.com/ncache/aspnet-core-idistributedcache-ncache.html](http://www.alachisoft.com/ncache/aspnet-core-idistributedcache-ncache.html)'
- en: We will use the **Distributed Memory Cache**, which is a Microsoft built-in
    implementation of `IDistributedCache` that stores items in memory on the server
    where the service runs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**分布式内存缓存**，这是微软内置的 `IDistributedCache` 实现，它将项目存储在运行服务的服务器上的内存中。
- en: It is not an actual distributed cache, but it is useful for scenarios like unit
    testing, where you want to remove the dependency on yet another external service,
    or while learning, as we are doing in this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个实际的分布式缓存，但它对于像单元测试这样的场景很有用，你希望移除对另一个外部服务的依赖，或者在学习时使用，就像我们在本书中所做的那样。
- en: Later, you only need to change the configured distributed cache, not the service
    implementation code that uses it, because all interactions go through the registered
    `IDistributedCache` implementation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你只需要更改配置的分布式缓存，而不是使用它的服务实现代码，因为所有交互都通过注册的 `IDistributedCache` 实现进行。
- en: Let’s go!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'In the `Northwind.WebApi.Service` project, in `Program.cs`, after the call
    to `CreateBuilder`, in the section for configuring services, register the implementation
    for the distributed memory cache, as shown in the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Service` 项目中，在 `Program.cs` 文件中，在调用 `CreateBuilder` 之后，在配置服务的部分中，注册分布式内存缓存的实现，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `ProductsController.cs`, import the namespace for working with a distributed
    cache implementation and serialized JSON, as shown in the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，导入用于处理分布式缓存实现和序列化 JSON 的命名空间，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `ProductsController.cs`, declare some fields to store the distributed cache
    implementation and an item key for discontinued products, as highlighted in the
    following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，声明一些字段来存储分布式缓存实现和停售产品的项目键，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `ProductsController.cs`, define a `private` method to get the discontinued
    products from the database, and set them in the distributed cache, using a sliding
    expiration of 5 seconds and an absolute expiration of 20 seconds, as shown in
    the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，定义一个 `private` 方法来从数据库获取停售产品，并将它们设置在分布式缓存中，使用
    5 秒的滑动过期和 20 秒的绝对过期，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `ProductsController.cs`, in the `GetDiscontinuedProducts` action method,
    add statements to try to get the cached discontinued products, and if not cached,
    get them from the database. If a `byte` array is found in the cache, try to deserialize
    it into products, but if that fails too, get the products from the database, as
    highlighted in the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsController.cs` 文件中，在 `GetDiscontinuedProducts` 动作方法中，添加语句尝试获取缓存的停售产品，如果没有缓存，则从数据库中获取。如果在缓存中找到一个
    `byte` 数组，尝试将其反序列化为产品，但如果这也失败了，则从数据库中获取产品，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unlike the in-memory cache that can store any live object, objects stored in
    distributed cache implementations must be serialized into `byte` arrays because
    they need to be transmittable across networks.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与可以存储任何活动对象的内存缓存不同，存储在分布式缓存实现中的对象必须序列化为 `byte` 数组，因为它们需要能够在网络上传输。
- en: Start the web service project, using the `https` profile without debugging.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不带调试的 `https` 配置启动 web 服务项目。
- en: Arrange the windows so that you can see the command prompt or terminal at the
    same time as the web page.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整窗口，以便同时看到命令提示符或终端和网页。
- en: On the Swagger web page, click **GET /api/product/discontinued** to expand that
    section.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Swagger 网页上，点击 **GET /api/product/discontinued** 来展开该部分。
- en: Click the **Try it out** button.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **尝试一下** 按钮。
- en: Click the **Execute** button, and note in the output that EF Core executes a
    SQL statement to get the products.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **执行** 按钮，并在输出中注意 EF Core 执行了一个 SQL 语句来获取产品。
- en: Click **Execute** within five seconds, continue to click it a few more times,
    and note that EF Core does not need to re-execute the SQL statement because the
    products are cached. If something reads them within a five-second sliding expiration,
    they will stay in memory forever.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在五秒内点击 **执行**，然后继续点击几次，并注意 EF Core 不需要重新执行 SQL 语句，因为产品已经被缓存。如果在五秒的滑动过期时间内有东西读取它们，它们将永远保留在内存中。
- en: Wait at least five seconds.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少等待五秒。
- en: Click **Execute**, and note in the output that EF Core executes a SQL statement
    to get the products because they have not been read within the five-second sliding
    expiration window.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **执行**，并在输出中注意 EF Core 执行了一个 SQL 语句来获取产品，因为它们在五秒的滑动过期时间内没有被读取。
- en: Continue to click **Execute** repeatedly, and note that after 20 seconds, EF
    Core must execute a SQL statement to refresh the products.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续点击 **执行**，并注意在 20 秒后，EF Core 必须执行一个 SQL 语句来刷新产品。
- en: Close the browser and shut down the web server.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器并关闭 web 服务器。
- en: A new abstraction for distributed caching
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式缓存的新的抽象
- en: The ASP.NET Core team is working on adding a new abstraction for distributed
    caching to make it easier to use. It is not expected to be ready for .NET 8\.
    It might be included in a point release, like 8.1, but more likely will be built-in
    with .NET 9.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 团队正在努力添加一个新的分布式缓存抽象，使其更容易使用。它预计不会在 .NET 8 中准备好。它可能包含在点版本中，如 8.1，但更有可能内置在
    .NET 9 中。
- en: Some `GetAsync` extension methods and supporting methods have been written by
    Marc Gravell. He maintains the most popular package to integrate .NET with Redis,
    so he has a lot of experience with distributed caching.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `GetAsync` 扩展方法和支持方法是由 Marc Gravell 编写的。他维护着最受欢迎的将 .NET 与 Redis 集成的包，因此他在分布式缓存方面拥有丰富的经验。
- en: 'While we wait for an official implementation, you can read or download the
    source code to his extensions at the following link: [https://github.com/mgravell/DistributedCacheDemo/blob/main/DistributedCacheExtensions.cs](https://github.com/mgravell/DistributedCacheDemo/blob/main/DistributedCacheExtensions.cs).
    The file is only 137 lines long, so it is easy to add to your own projects straight
    away.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待官方实现的同时，您可以在以下链接中阅读或下载他的扩展的源代码：[https://github.com/mgravell/DistributedCacheDemo/blob/main/DistributedCacheExtensions.cs](https://github.com/mgravell/DistributedCacheDemo/blob/main/DistributedCacheExtensions.cs)。该文件只有
    137 行，因此很容易立即添加到您自己的项目中。
- en: 'The main difference in the new extension methods is that you do not need to
    call the `Set` or `SetAsync` methods anymore because they are abstracted away
    inside the new `GetAsync` methods, as shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 新扩展方法的主要区别在于，您不再需要调用 `Set` 或 `SetAsync` 方法，因为它们被抽象在新的 `GetAsync` 方法中，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, note that the new extension methods are all asynchronous and generic,
    with a type `T` that will be serialized as JSON by default, but this can be overridden
    to use alternatives like the binary format protobuf.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，新的扩展方法都是异步和泛型的，具有类型 `T`，默认情况下将序列化为 JSON，但可以覆盖以使用二进制格式 protobuf 等替代方案。
- en: '**More Information**: You can learn more about the plans for these new extension
    methods at the following link: [https://devblogs.microsoft.com/dotnet/caching-abstraction-improvements-in-aspnetcore/](https://devblogs.microsoft.com/dotnet/caching-abstraction-improvements-in-aspnetcore/).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于这些新扩展方法的计划：[https://devblogs.microsoft.com/dotnet/caching-abstraction-improvements-in-aspnetcore/](https://devblogs.microsoft.com/dotnet/caching-abstraction-improvements-in-aspnetcore/)。'
- en: Caching web responses using HTTP caching
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HTTP 缓存来缓存网页响应
- en: In-memory and distributed caching work with any type of app or service, using
    any transport technology, because all the magic happens on the server.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 内存和分布式缓存可以与任何类型的应用程序或服务一起工作，使用任何传输技术，因为所有的魔法都在服务器上发生。
- en: Response aka HTTP caching is tied to HTTP GET requests and responses because
    it is based on HTTP headers. Therefore, it only works with apps and services that
    use HTTP as their transport technology, like web services built using Web APIs,
    minimal APIs, and OData.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 响应，即 HTTP 缓存，与 HTTP GET 请求和响应相关联，因为它基于 HTTP 头部。因此，它仅适用于使用 HTTP 作为其传输技术的应用程序和服务，例如使用
    Web API、最小 API 和 OData 构建的 Web 服务。
- en: '**More Information**: You can read the official standard for HTTP caching at
    the following link: [https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中阅读 HTTP 缓存的官方标准：[https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111)。'
- en: 'Requirements for HTTP aka response caching include the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 缓存（即响应缓存）的要求包括以下内容：
- en: The request must be a `GET` or `HEAD` one. `POST`, `PUT`, and `DELETE` requests,
    and so on, are never cached by HTTP caching.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求必须是 `GET` 或 `HEAD` 类型。`POST`、`PUT` 和 `DELETE` 请求等永远不会被 HTTP 缓存。
- en: The response must have a `200 OK` status code.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应必须有一个 `200 OK` 状态码。
- en: If the request has an `Authorization` header, then the response is not cached.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求有一个 `Authorization` 头部，则响应不会被缓存。
- en: If the request has a `Vary` header, then the response is not cached when the
    values are not valid or `*`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求有一个 `Vary` 头部，则当值无效或为 `*` 时，响应不会被缓存。
- en: The web server sets response caching headers, and then intermediate proxies
    and clients should respect the headers to tell them how they should cache the
    responses.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器设置响应缓存头部，然后中间代理和客户端应尊重这些头部以告知它们如何缓存响应。
- en: '**Good Practice**: Response aka HTTP caching is not typically useful for web
    user interfaces because web browsers often set request headers that prevent HTTP
    caching. For web user interfaces, output caching is better suited, and we will
    cover that in *Chapter 14*, *Building Web User Interfaces Using ASP.NET Core*.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：响应缓存（即 HTTP 缓存）通常对 Web 用户界面没有太大用处，因为 Web 浏览器通常会设置请求头部以防止 HTTP 缓存。对于
    Web 用户界面，输出缓存更适合，我们将在第 14 章，*使用 ASP.NET Core 构建Web用户界面*中介绍。'
- en: 'The `Cache-Control` HTTP header for requests and responses has some common
    directives, as shown in *Table 9.2*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应的 `Cache-Control` HTTP 头部有一些常见的指令，如下表 9.2 所示：
- en: '| **Directive** | **Description** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| `public` | Clients and intermediaries can cache this response. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `public` | 客户端和中间代理可以缓存此响应。|'
- en: '| `private` | Only a client should cache this response. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `private` | 只有客户端应缓存此响应。|'
- en: '| `max-age` | The client does not accept responses older than the specified
    number of seconds. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `max-age` | 客户端不接受超过指定秒数的旧响应。|'
- en: '| `no-cache` | A client request is asking for a non-cached response. A server
    is telling the client and intermediaries not the cache the response. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `no-cache` | 客户端请求的是非缓存的响应。服务器告诉客户端和中间代理不要缓存响应。|'
- en: '| `no-store` | A cache must not store the request or response. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `no-store` | 缓存不得存储请求或响应。|'
- en: 'Table 9.2: Common Cache-Control HTTP header directives'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2：常见的 Cache-Control HTTP 头部指令
- en: 'As well as `Cache-Control`, there are other headers that might affect caching,
    as shown in *Table 9.3*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Cache-Control` 之外，还有其他可能影响缓存的头部，如下表 9.3 所示：
- en: '| **Header** | **Description** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **头部** | **描述** |'
- en: '| `Age` | Estimated number of seconds old the response is. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `Age` | 响应估计的秒数。|'
- en: '| `Expires` | An absolute date/time after which the response should be considered
    expired. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `Expires` | 响应应在绝对日期/时间之后被视为已过期。|'
- en: '| `Vary` | All fields must match for a cached response to be sent. Otherwise,
    a fresh response is sent. For example, a query string of `color`. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `Vary` | 所有字段必须匹配才能发送缓存的响应。否则，将发送新的响应。例如，查询字符串为 `color`。|'
- en: 'Table 9.3: Common HTTP headers for caching'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.3：常见的 HTTP 缓存头部
- en: 'For example, a client could ask for a fresh list of discontinued products,
    and the service should not use any cached version, as shown in the following HTTP
    response:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，客户端可以请求一个停产的产品的最新列表，服务不应使用任何缓存版本，如下面的 HTTP 响应所示：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A service could return some products as a JSON array, with a header to say
    that intermediaries should not cache the response but clients can, as shown in
    the following HTTP response:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以返回一些产品作为 JSON 数组，并在头部说明中间代理不应缓存响应，但客户端可以，如下面的 HTTP 响应所示：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Decorate a controller or method with the `[ResponseCache]` attribute to control
    caching responses from the server (code to control caching requests has to go
    in the client code). This attribute has common parameters, as shown in *Table
    9.4*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[ResponseCache]` 属性装饰控制器或方法以控制来自服务器的缓存响应（控制缓存请求的代码必须放在客户端代码中）。此属性有常用参数，如下表
    9.4 所示：
- en: '| **Property** | **Description** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Duration` | How long to cache in seconds. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `Duration` | 缓存时间（以秒为单位）。|'
- en: '| `Location` | Where the response can be cached. `Any` (`cache-control:` `public`),
    `Client` (`cache-control:` `private`), `None` (`cache-control:` `no-cache`). |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `Location` | 响应可以缓存的地点。`Any` (`cache-control:` `public`), `Client` (`cache-control:`
    `private`), `None` (`cache-control:` `no-cache`)。|'
- en: '| `NoStore` | Sets `cache-control:` `no-store`. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `NoStore` | 设置 `cache-control:` `no-store`。|'
- en: '| `VaryByHeader` | Sets the `Vary` header. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `VaryByHeader` | 设置 `Vary` 头部。|'
- en: '| `VaryByQueryKeys` | Query keys to vary by. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `VaryByQueryKeys` | 要变化的查询键。|'
- en: 'Table 9.4: Common parameters of the [ResponseCache] attribute'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.4：[ResponseCache] 属性的常见参数
- en: 'Let’s apply response caching to the web service:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将响应缓存应用到 Web 服务中：
- en: 'In the `Northwind.WebApi.Service` project, in `Program.cs`, after the call
    to add the distributed memory cache, add a statement to add response caching middleware
    as a dependency service, as shown in the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Service` 项目中的 `Program.cs` 文件中，在调用添加分布式内存缓存之后，添加一个语句来添加响应缓存中间件作为依赖服务，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `Program.cs`, after the call to use HTTPS redirection, add a statement to
    use response caching middleware, as shown in the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在调用使用 HTTPS 重定向之后，添加一个语句来使用响应缓存中间件，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Good Practice**: If using CORS middleware, then `UseCors` must be called
    before `UseResponseCaching`.'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：如果使用 CORS 中间件，则必须在 `UseResponseCaching` 之前调用 `UseCors`。'
- en: 'In `ProductsController.cs`, decorate the `Get` method with an `int id` parameter
    with the `[ResponseCache]` attribute, as highlighted in the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductsController.cs`中，使用`[ResponseCache]`属性装饰带有`int id`参数的`Get`方法，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `[ResponseCache]` attribute can be applied to Razor Pages, MVC controller
    classes, and MVC action methods for both web services and websites.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`[ResponseCache]`属性可以应用于Razor页面、MVC控制器类以及MVC动作方法，无论是用于Web服务还是网站。'
- en: Start the web service project, using the `https` profile without debugging.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`https`配置文件启动Web服务项目，不进行调试。
- en: In the `HttpRequests` folder, open the `webapi-get-products.http` file.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HttpRequests`文件夹中，打开`webapi-get-products.http`文件。
- en: 'Modify the base address to use port `5091`, and then send the request for a
    specific product, like `77`, as shown in the following code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基本地址修改为使用端口`5091`，然后发送请求以获取特定产品，例如`77`，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the response includes headers to control caching, as highlighted
    in the following output:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，响应包括用于控制缓存的头信息，如下面的输出所示：
- en: '[PRE25]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Close the browser and shut down the web server.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器并关闭Web服务器。
- en: '**Good Practice**: Response caching should only be enabled for anonymous requests.
    Authenticated requests and responses should not be cached.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：仅应启用匿名请求的响应缓存。认证请求和响应不应被缓存。'
- en: Caching is one of the best ways to improve the performance and scalability of
    your services. Next, we will learn how to improve a service’s resilience when
    inevitable failures occur.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是提高您服务性能和可扩展性的最佳方法之一。接下来，我们将学习如何在不可避免地发生故障时提高服务的弹性。
- en: Fault tolerance with Polly
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Polly实现容错
- en: 'Polly is *“a .NET resilience and transient-fault-handling library that allows
    developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead
    Isolation, and Fallback in a fluent and thread-safe manner,”* as stated on the
    official Polly GitHub repository, which can be found at the following link: [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方Polly GitHub仓库所述，Polly是*“一个.NET弹性及瞬态故障处理库，允许开发者以流畅且线程安全的方式表达重试、断路器、超时、舱壁隔离和回退等策略，”*该仓库的链接如下：[https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)。
- en: Transient faults are errors caused by temporary conditions, such as temporary
    service unavailability or network connectivity issues. It is essential to handle
    transient faults in distributed systems, or they can become almost unusable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬态故障是由暂时条件引起的错误，例如暂时性服务不可用或网络连接问题。在分布式系统中处理瞬态故障至关重要，否则它们可能会变得几乎无法使用。
- en: Understanding retry and circuit breaker patterns
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解重试和断路器模式
- en: The **Retry** pattern enables clients to automatically retry a failed action
    with the expectation that the fault will succeed if retried after a short delay.
    Be careful, because if you implement the Retry pattern naively, then it can make
    the problem worse!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**重试**模式使客户端能够自动重试失败的操作，预期在短暂延迟后故障将成功。请注意，如果您天真地实现重试模式，那么它可能会使问题变得更糟！'
- en: For example, if you set a fixed time between retries, then all the clients who
    received a fault will attempt to retry at the same time, overloading the service.
    To avoid this issue, retries are often set with an exponentially increasing time
    between retries, or they might use jitter (aka randomizer) algorithms.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您设置固定的重试时间间隔，那么所有收到故障的客户端将同时尝试重试，从而超载服务。为了避免这个问题，重试通常设置成指数级增加的重试时间间隔，或者它们可能使用抖动（也称为随机化器）算法。
- en: The **Circuit Breaker** pattern prevents calls when a threshold of faults is
    reached. In effect, it is a way for a service to detect if a fault is *not* transient,
    or not transient enough to keep retrying.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**断路器**模式在达到错误阈值时阻止调用。实际上，这是一种服务检测错误是否**不是**瞬时的，或者不足以持续重试的方法。'
- en: '**More Information**: There is a nice summary table of resilience policies
    for Polly on its GitHub repository: [https://github.com/App-vNext/Polly#resilience-policies](https://github.com/App-vNext/Polly#resilience-policies).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：Polly的GitHub仓库中有一个关于弹性策略的很好的总结表格：[https://github.com/App-vNext/Polly#resilience-policies](https://github.com/App-vNext/Polly#resilience-policies)。'
- en: Defining and executing policies
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和执行策略
- en: In any type of .NET project that calls any unreliable code, you can reference
    the Polly package and then define a policy using the `Policy` class. Polly is
    not used in the unreliable code or service itself. It is used by any clients that
    call the code or service.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何调用不可靠代码的.NET项目中，你可以引用Polly包，然后使用`Policy`类定义一个策略。Polly不用于不可靠的代码或服务本身。它被任何调用代码或服务的客户端使用。
- en: 'For example, you might need to call two methods that might throw arithmetic
    or custom exceptions, and you want to automatically retry up to three times, so
    you define a policy to handle this, as shown in the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能需要调用两个可能会抛出算术或自定义异常的方法，并且你希望自动重试最多三次，因此你定义一个策略来处理这种情况，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, you can use that policy to execute the methods, as shown in the following
    code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用该策略来执行方法，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each call to `Execute` gets its own counter for retries, so if the call to `GetProducts`
    needs two retries, the call to `GetCustomers` still has a full three retries of
    its own.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`Execute`都会为其自己的重试计数器，所以如果`GetProducts`调用需要两次重试，那么`GetCustomers`调用仍然有它自己的完整三次重试。
- en: For unlimited retries, you can call the `RetryForever` method, but this is not
    recommended.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无限重试，你可以调用`RetryForever`方法，但这个方法不建议使用。
- en: For asynchronous methods, there are matching asynchronous methods; for example,
    instead of `Retry`, use `RetryAsync`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步方法，存在对应的异步方法；例如，而不是使用`Retry`，使用`RetryAsync`。
- en: 'To execute some statements when a retry occurs, for example, to log information,
    the `Retry` method can have a callback, as shown in the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要在重试发生时执行某些语句，例如记录信息，`Retry`方法可以有一个回调，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Defining wait intervals between retries
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义重试之间的等待间隔
- en: Instead of immediately retrying after a fault, it is good practice to wait a
    moment before retrying.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与在故障后立即重试相比，在重试之前等待一段时间是一个好的实践。
- en: 'For example, to wait and retry, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，等待并重试，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of hardcoded delay values, you can also define a function to generate
    them, as shown in the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义一个函数来生成它们，而不是使用硬编码的延迟值，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, if we pass an array of fixed delays, even if they are calculated, imagine
    what happens when a fault occurs in a busy web service. All the clients receive
    an exception, they all wait for the first second, and they all attempt to recall
    the web service one second later. This causes floods that could make the situation
    worse!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们传递一个固定延迟的数组，即使它们是计算出来的，想象一下当繁忙的网络服务发生故障时会发生什么。所有客户端都会收到一个异常，他们都会等待第一秒，然后他们都会在第二秒后尝试重新调用网络服务。这可能导致洪水，从而使情况变得更糟！
- en: Jittering is the idea of adding small amounts of randomization to time delays.
    There are many implementations that you can find online, and the best is built-in
    with an extra Polly package. We will use it to generate time delays in our example
    project.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Jittering是一种在时间延迟中添加少量随机化的想法。你可以在网上找到许多实现，最好的是内置在额外的Polly包中。我们将在示例项目中使用它来生成时间延迟。
- en: Applying policies to HTTP clients
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将策略应用于HTTP客户端
- en: When calling a web service, it’s a good practice to define an HTTP client factory
    and register it in a dependency services collection.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用网络服务时，定义一个HTTP客户端工厂并将其注册到依赖服务集合中是一个好的实践。
- en: In this scenario, you will not call the methods that might throw an exception
    yourself. Instead, you must define a policy and then attach it to a registered
    HTTP client, so that it automatically follows that policy.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，你不会自己调用可能会抛出异常的方法。相反，你必须定义一个策略，并将其附加到一个已注册的HTTP客户端上，这样它就会自动遵循该策略。
- en: 'To do so, we will use an extension class named `HttpPolicyExtensions` to create
    policies specifically for common HTTP requests and failures, as shown in the following
    code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们将使用名为`HttpPolicyExtensions`的扩展类来创建专门针对常见HTTP请求和失败的策略，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To attach the policy to an HTTP client, call the `AddPolicyHandler` extension
    method after defining the factory. You will see how to do this in practice later
    in this section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义工厂之后，调用`AddPolicyHandler`扩展方法将策略附加到HTTP客户端上。你将在本节稍后看到如何在实践中这样做。
- en: Adding random faults to the web service
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向网络服务添加随机故障
- en: 'First, let’s add random faults to the web service:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向网络服务添加随机故障：
- en: 'In the `Northwind.WebApi.Service` project, in `ProductsController.cs`, in the
    `Get` action method that has a `name` parameter, add statements to randomly throw
    an exception two-thirds of the time, as highlighted in the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Service` 项目中，在 `ProductsController.cs` 文件中，在具有 `name` 参数的
    `Get` 动作方法中，添加语句以随机抛出三分之二时间的异常，如下所示：
- en: '[PRE32]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Build the project.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: Building an MVC project to call the faulty web service
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个 MVC 项目以调用有缺陷的 Web 服务
- en: 'Next, let’s create an ASP.NET Core MVC client that calls the randomly faulty
    web service endpoint. Initially, it will just receive the exception if the web
    service throws an exception. Later, we will add transient fault handling using
    Polly:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个 ASP.NET Core MVC 客户端，该客户端调用随机有缺陷的 Web 服务端点。最初，它将仅接收 Web 服务抛出的异常。稍后，我们将添加使用
    Polly 的瞬态故障处理：
- en: 'Use your preferred code editor to add a new project, as defined in the following
    list:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器添加一个新项目，如下所示列表定义：
- en: 'Project template: **ASP.NET Core Web App (Model-View-Controller)** / `mvc`'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**ASP.NET Core Web App (Model-View-Controller)** / `mvc`
- en: 'Solution file and folder: `Chapter09`'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: 'Project file and folder: `Northwind.WebApi.Client.Mvc`'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.WebApi.Client.Mvc`
- en: 'Other Visual Studio 2022 options:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 Visual Studio 2022 选项：
- en: '**Authentication Type**: **None**.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证类型**: **无**.'
- en: '**Configure for HTTPS**: Selected.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置 HTTPS**: 已选择。'
- en: '**Enable Docker**: Cleared.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 Docker**: 已清除。'
- en: '**Do not use top-level statements**: Cleared.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**: 已清除。'
- en: 'In the `Northwind.WebApi.Client.Mvc` project, in the `Properties` folder, in
    `launchSettings.json`, change the `applicationUrl` for the `https` profile to
    use port `5093` for `https` and `5094` for `http`, as shown in the following markup:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Client.Mvc` 项目中，在 `Properties` 文件夹中，在 `launchSettings.json`
    文件中，将 `https` 配置的 `applicationUrl` 修改为使用端口 `5093` 用于 `https` 和 `5094` 用于 `http`，如下所示：
- en: '[PRE33]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `Northwind.WebApi.Client.Mvc` project file, treat warnings as errors,
    and add a reference to the entity models project so that we can use the `Product`
    class, as shown in the following markup:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Client.Mvc` 项目文件中，将警告视为错误，并添加对实体模型项目的引用，以便我们可以使用 `Product`
    类，如下所示：
- en: '[PRE34]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Build the `Northwind.WebApi.Client.Mvc` project at the command prompt or terminal
    by entering the following command: `dotnet build`.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中通过输入以下命令构建 `Northwind.WebApi.Client.Mvc` 项目：`dotnet build`。
- en: 'In the `Northwind.WebApi.Client.Mvc` project, in `Program.cs`, import the namespace
    to work with HTTP headers, as shown in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Client.Mvc` 项目中，在 `Program.cs` 文件中，导入用于处理 HTTP 标头的命名空间，如下所示：
- en: '[PRE35]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In `Program.cs`, before calling the `builder.Build()`, add statements to configure
    an HTTP client factory to call the web service, as shown in the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在调用 `builder.Build()` 之前，添加语句以配置一个 HTTP 客户端工厂以调用 Web 服务，如下所示：
- en: '[PRE36]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `Models` folder, add a new class file named `HomeProductsViewModel.cs`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中，添加一个名为 `HomeProductsViewModel.cs` 的新类文件。
- en: 'In `HomeProductsViewModel.cs`, define a class to store information needed in
    the view, like the partial product name the visitor wants to search for, a sequence
    of products, and an error message, as shown in the following code:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeProductsViewModel.cs` 文件中，定义一个类以存储视图所需的信息，例如访客想要搜索的部分产品名称、产品序列和错误消息，如下所示：
- en: '[PRE37]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `Controllers` folder, in `HomeController.cs`, import the namespace for
    the entity models, as shown in the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Controllers` 文件夹中，在 `HomeController.cs` 文件中，导入实体模型的命名空间，如下所示：
- en: '[PRE38]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `HomeController.cs`, add statements to store the registered HTTP client
    factory in a private `readonly` field, as shown highlighted in the following code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeController.cs` 文件中，添加语句以将注册的 HTTP 客户端工厂存储在私有的 `readonly` 字段中，如下所示：
- en: '[PRE39]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `HomeController.cs`, add an asynchronous action method named `Products`,
    which will use the HTTP factory to request products whose name contains a value
    entered as an optional `name` parameter, in a custom MVC route, as shown in the
    following code:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeController.cs` 文件中，添加一个名为 `Products` 的异步动作方法，该方法将使用 HTTP 工厂请求包含作为可选 `name`
    参数输入的值的名称的产品，在自定义 MVC 路由中，如下所示：
- en: '[PRE40]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `Views/Home` folder, add a new file named `Products.cshtml`. (The Visual
    Studio 2022 project item template is named **Razor View - Empty**. The JetBrains
    Rider project item template is named **Razor MVC View**.)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views/Home` 文件夹中，添加一个名为 `Products.cshtml` 的新文件。（Visual Studio 2022 项目项模板命名为
    **Razor View - Empty**。JetBrains Rider 项目项模板命名为 **Razor MVC View**。）
- en: 'In `Products.cshtml`, modify its contents to output a table of products that
    match part of a product name entered in a textbox, as shown in the following markup:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Products.cshtml` 文件中，修改其内容以输出一个表格，显示与在文本框中输入的产品名称部分匹配的产品，如下面的标记所示：
- en: '[PRE41]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In `Views/Home`, in `Index.cshtml`, add code to define a link to the products
    page, as shown in the following markup:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views/Home` 目录中的 `Index.cshtml` 文件中，添加代码以定义到产品页面的链接，如下面的标记所示：
- en: '[PRE42]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Start the `Northwind.WebApi.Service` project, using the `https` profile without
    debugging.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不带调试的 `https` 配置启动 `Northwind.WebApi.Service` 项目。
- en: Start the `Northwind.WebApi.Client.Mvc` project, using the `https` profile without
    debugging.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不带调试的 `https` 配置启动 `Northwind.WebApi.Client.Mvc` 项目。
- en: If you are using Visual Studio Code, then the web browser will not start automatically.
    Start Chrome, and then navigate to `https://localhost:5093`.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio Code，那么网页浏览器将不会自动启动。启动 Chrome，然后导航到 `https://localhost:5093`。
- en: On the home page, click **Search for products by name**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页上，点击 **按名称搜索产品**。
- en: 'If the search works, you will see the successful results shown in *Figure 9.1*:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索成功，你将看到 *图 9.1* 中显示的成功结果：
- en: '![](img/B19587_09_01.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_09_01.png)'
- en: 'Figure 9.1: A successful call to the faulty random web service'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.1*：对故障随机 Web 服务的成功调用'
- en: 'fails, you will see an error message, as shown in *Figure 9.2*:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果失败，你将看到 *图 9.2* 中显示的错误消息：
- en: '![](img/B19587_09_02.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_09_02.png)'
- en: 'Figure 9.2: A successful call to the faulty random web service'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.2*：对故障随机 Web 服务的成功调用'
- en: 'In the command prompt or terminal, when a fault occurs you will see the exception,
    as shown in the following partial output:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，当发生故障时，你将看到异常，如下面的部分输出所示：
- en: '[PRE43]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Enter different partial names and click **Get Products** until you have seen
    both a successful search and a failed search.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入不同的部分名称并点击 **获取产品**，直到你看到成功搜索和失败搜索。
- en: Close the browsers and shut down the web servers.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器并关闭 Web 服务器。
- en: Implementing the Retry pattern for transient fault handling
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现短暂故障处理的重试模式
- en: 'Now that we have a web service and MVC client with random faults, let’s add
    transient fault handling by using the Retry pattern:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个带有随机故障的 Web 服务和 MVC 客户端，让我们使用重试模式来添加短暂故障处理：
- en: 'In the `Northwind.WebApi.Client.Mvc` project file, globally and statically
    import the `System.Console` class, and add a package reference for the Microsoft
    package to integrate Polly with ASP.NET Core (which has a dependency on the `Polly`
    package), and for a library to add jittering to retry time spans, as shown in
    the following markup:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Client.Mvc` 项目文件中，全局和静态导入 `System.Console` 类，并添加对 Microsoft
    包的包引用以将 Polly 集成到 ASP.NET Core（它依赖于 `Polly` 包），以及添加抖动到重试时延的库，如下面的标记所示：
- en: '[PRE44]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Build the `Northwind.WebApi.Client.Mvc` project to restore packages.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `Northwind.WebApi.Client.Mvc` 以恢复包。
- en: 'In `Program.cs`, import common Polly namespaces to work with ASP.NET Core,
    as shown in the following code:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，导入常见的 Polly 命名空间以与 ASP.NET Core 一起工作，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `Program.cs`, before the statement to add an HTTP client to services, add
    statements to generate five jittered and exponentially increasing time-span values,
    output them to the console, use them to define an asynchronous wait and retry
    policy, and then add the retry policy to the HTTP client factory, as highlighted
    in the following code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在添加 HTTP 客户端到服务语句之前，添加生成五个抖动和指数增长的时延值语句，将它们输出到控制台，使用它们来定义异步等待和重试策略，然后将重试策略添加到
    HTTP 客户端工厂中，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If your database server is not running (for example, because you are hosting
    it in Docker, a virtual machine, or in the cloud), then make sure to start it.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的数据库服务器没有运行（例如，因为你正在 Docker、虚拟机或云中托管它），那么请确保启动它。
- en: Start the `Northwind.WebApi.Service` project, using the `https` profile without
    debugging.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不带调试的 `https` 配置启动 `Northwind.WebApi.Service` 项目。
- en: Start the `Northwind.WebApi.Client.Mvc` project, using the `https` profile without
    debugging.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不带调试的 `https` 配置启动 `Northwind.WebApi.Client.Mvc` 项目。
- en: 'In the command prompt or terminal for the MVC project, note the jittered time
    spans, as shown in the following output:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MVC 项目的命令提示符或终端中，注意抖动时延，如下面的输出所示：
- en: '[PRE47]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Your five delays will be different, but they should start at about 1 second
    and increase from that.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的五个延迟将不同，但它们应该从大约 1 秒开始并增加。
- en: Arrange the web service command prompt or terminal and the MVC website browser
    so that you can see both side by side.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安排好Web服务命令提示符或终端和MVC网站浏览器，以便你可以并排看到它们。
- en: On the home page, click **Search for products by name**.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页上，点击**按名称搜索产品**。
- en: Note that the MVC website might have to make multiple requests before showing
    the page, which will take up to about 15 seconds. For example, when I ran my projects,
    the MVC web site made four requests that failed before succeeding on the fifth
    attempt. You will see the exceptions logged in the web service output.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，MVC网站可能需要在显示页面之前发出多个请求，这可能会花费大约15秒的时间。例如，当我运行我的项目时，MVC网站在前五次尝试成功之前失败了四次。你将在Web服务输出中看到记录的异常。
- en: Enter a partial product name, click **Get Products**, and note that the web
    page will likely appear successfully again, even if one or more requests must
    be made beforehand.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入部分产品名称，点击**获取产品**，并注意网页可能会成功再次出现，即使在此之前必须发出一个或多个请求。
- en: It is possible that you could exceed the maximum of five requests, in which
    case you will see the error message as before.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能你可能会超过五个请求的最大限制，在这种情况下，你将看到之前出现的错误信息。
- en: 'Microsoft has created their own packages that wrap Polly to make it even easier
    to use. They are the `Microsoft.Extensions.Http.Resilience` and `Microsoft.Extensions.Resilience`
    packages. You can learn about this at the following link: [https://devblogs.microsoft.com/dotnet/building-resilient-cloud-services-with-dotnet-8/](https://devblogs.microsoft.com/dotnet/building-resilient-cloud-services-with-dotnet-8/)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 微软创建了他们自己的包装，将Polly包装起来，使其更容易使用。它们是`Microsoft.Extensions.Http.Resilience`和`Microsoft.Extensions.Resilience`包。你可以在以下链接中了解更多信息：[https://devblogs.microsoft.com/dotnet/building-resilient-cloud-services-with-dotnet-8/](https://devblogs.microsoft.com/dotnet/building-resilient-cloud-services-with-dotnet-8/)
- en: Now that you’ve seen two techniques that improve services, caching, and handling
    transient faults, let’s look a third powerful technique, queuing.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了两种提高服务的技术，缓存和处理短暂故障，让我们看看第三种强大的技术，队列。
- en: Queuing with RabbitMQ
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RabbitMQ进行队列
- en: Queuing can improve the scalability of your service, just as it can in the physical
    world. When too many clients all need to call a service at once, we can use a
    queue to smooth out the load.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 队列可以提高你服务的可伸缩性，就像在物理世界中一样。当太多客户端同时需要调用一个服务时，我们可以使用队列来平滑负载。
- en: There are many queuing systems available for all the major development platforms.
    One of the most popular is RabbitMQ. It implements the **Advanced Message Queuing
    Protocol** (**AMQP**).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有主要开发平台，都有许多可用的队列系统。其中最受欢迎的是RabbitMQ。它实现了**高级消息队列协议**（**AMQP**）。
- en: With AMQP, messages are published to exchanges, which then distribute message
    copies to queues using rules named bindings. Then a broker can deliver the messages
    to consumers subscribed to a queue (sometimes called a topic) or a consumer can
    read from a queue when they want.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AMQP，消息被发布到交换机，然后根据名为绑定的规则将消息副本分发到队列。然后代理可以将消息传递给订阅了队列（有时称为主题）的消费者，或者消费者可以在需要时从队列中读取。
- en: Since networks and systems often fail, AMQP uses message acknowledgments to
    tell the broker when a consumer has successfully processed a message, and only
    then does the broker remove the message from the queue.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络和系统经常出现故障，AMQP使用消息确认来告诉代理消费者何时成功处理了消息，然后代理才会从队列中删除消息。
- en: 'RabbitMQ supports four types of exchange:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ支持四种类型的交换机：
- en: '**Direct**: A direct exchange delivers messages based on a message routing
    key. Multiple queues can be bound to the exchange, but messages are only delivered
    to a queue if they have a matching routing key. They are mostly used for unicast
    messages. The default (empty name) exchange is a direct exchange. It is pre-bound
    with a routing key that is the same name as the queue. This is the type we will
    use in this book.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接**：直接交换机根据消息路由键交付消息。多个队列可以绑定到交换机，但只有当消息具有匹配的路由键时，才会将消息传递到队列。它们主要用于单播消息。默认（空名称）交换机是一个直接交换机。它与队列相同的名称的路由键预先绑定。这是我们在这本书中将使用的那种类型。'
- en: '**Fanout**: A fanout exchange delivers messages to all queues that are bound
    to it, and the routing key is ignored. These are good for broadcasting messages.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扇出**：扇出交换机将消息发送到所有绑定到它的队列，并且忽略路由键。这些非常适合广播消息。'
- en: '**Topic**: A topic exchange delivers messages based on a routing key and criteria
    defined in the binding between the exchange and a queue. They are used for the
    publish/subscribe pattern, where there are many consumers but they want to receive
    different messages, based on factors like geographic location, registered interests,
    and so on.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：主题交换基于交换和队列之间的绑定中定义的路由键和标准来传递消息。它们用于发布/订阅模式，其中存在许多消费者，但他们希望根据地理位置、注册兴趣等因素接收不同的消息。'
- en: '**Headers**: A headers exchange delivers messages based on multiple attributes
    in a message header instead of a routing key.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部信息**：头部交换基于消息头中的多个属性而不是路由键来传递消息。'
- en: 'The RabbitMQ API uses the following types:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ API使用以下类型：
- en: '`IConnection`: This represents an AMQP connection.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConnection`：这代表一个AMQP连接。'
- en: '`ConnectionFactory`: This creates `IConnection` instances. It has default values
    for common properties designed to work with the Docker image. For example, `UserName`
    is `guest`, `Password` is `guest`, `VirtualHost` is `/`, `HostName` is `localhost`,
    and `Port` is `5672`.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionFactory`：它创建`IConnection`实例。它为常见属性提供默认值，旨在与Docker镜像一起使用。例如，`UserName`是`guest`，`Password`是`guest`，`VirtualHost`是`/`，`HostName`是`localhost`，`Port`是`5672`。'
- en: '`IModel`: This represents the AMQP channel and has methods to perform common
    tasks, like declaring a queue with `QueueDeclare` or sending a message using `BasicPublish`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IModel`：这代表AMQP通道，并具有执行常见任务的方法，如使用`QueueDeclare`声明队列或使用`BasicPublish`发送消息。'
- en: '`IBasicConsumer`: This represents a message consumer.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IBasicConsumer`：这代表一个消息消费者。'
- en: '`EventBasicConsumer`: This is an implementation of a message consumer that
    integrates with the .NET event system, making it easy for a client app to process
    a message as soon as it is sent and received.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventBasicConsumer`：这是一个与.NET事件系统集成的消息消费者实现，使得客户端应用程序能够一旦发送和接收消息就立即处理它。'
- en: '**Good Practice**: Queuing systems can get complicated fast. In this book,
    we will cover the basics, but if you decide to implement any queuing system in
    production, then you will want to learn much more about how to implement them
    deeply.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：队列系统可能会很快变得复杂。在这本书中，我们将介绍基础知识，但如果您决定在生产中实现任何队列系统，那么您将需要学习更多关于如何深入实现它们的知识。'
- en: You can install RabbitMQ locally on your computer, but for maximum ease of use,
    I recommend using a Docker image.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的计算机上本地安装RabbitMQ，但我建议使用Docker镜像以获得最大便利性。
- en: 'To install RabbitMQ on your computer, read the instructions at the following
    link for your operating system: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的计算机上安装RabbitMQ，请阅读以下链接中针对您操作系统的说明：[https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
- en: Setting up RabbitMQ using Docker
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker设置RabbitMQ
- en: The Docker image we will use has RabbitMQ version 3.12.0 and is designed to
    be used as a throwaway container, where you simply start the container and your
    project can start using it with the default configuration.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的Docker镜像具有RabbitMQ版本3.12.0，并设计为用作一次性容器，您只需启动容器，项目就可以使用默认配置开始使用它。
- en: '**More Information**: You can read more about the Docker image at the following
    link: [https://registry.hub.docker.com/_/rabbitmq/](https://registry.hub.docker.com/_/rabbitmq/).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于Docker镜像的信息：[https://registry.hub.docker.com/_/rabbitmq/](https://registry.hub.docker.com/_/rabbitmq/).'
- en: 'Let’s get started with RabbitMQ in a Docker container:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Docker容器中开始使用RabbitMQ：
- en: 'Install **Docker** from the following link: [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接安装**Docker**：[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
- en: Start **Docker**.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动**Docker**。
- en: 'At the command prompt or terminal, pull down the latest container image for
    RabbitMQ on Docker and run it, opening ports `5672` and `15672` to the container,
    which are used by default by AMQP, as shown in the following command:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，从Docker拉取最新的RabbitMQ容器镜像并运行它，将端口`5672`和`15672`打开到容器，这些端口是AMQP默认使用的，如下所示：
- en: '[PRE48]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that the first time you run this command, the RabbitMQ image will not
    be found on your local computer, as shown in the following output:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，第一次运行此命令时，您的本地计算机上找不到RabbitMQ镜像，如下所示：
- en: '[PRE49]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that the image will then be downloaded automatically, as shown in the
    following output:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，然后镜像将自动下载，如下所示：
- en: '[PRE50]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that RabbitMQ runs on Erlang, and its copyright and license information
    is displayed when the container starts up, as shown in the following output:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 RabbitMQ 在 Erlang 上运行，并且当容器启动时显示其版权和许可信息，如下所示：
- en: '[PRE51]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note the RabbitMQ service listens on port `5672` and has started four plugins,
    as shown in the following output:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 RabbitMQ 服务正在端口 `5672` 上监听并已启动四个插件，如下所示：
- en: '[PRE52]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Leave the command prompt or terminal running.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持命令提示符或终端运行。
- en: 'Optionally, in **Docker Desktop**, note that a container for RabbitMQ runs
    and listens on ports `5672` (the actual queue service) and `15672` (its management
    service), as shown in *Figure 9.3*:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在 **Docker Desktop** 中，请注意 RabbitMQ 的容器正在运行并监听端口 `5672`（实际的队列服务）和 `15672`（其管理服务），如图
    *9.3* 所示：
- en: '![](img/B19587_09_03.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_09_03.png)'
- en: 'Figure 9.3: RabbitMQ running in a Docker container'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：RabbitMQ 在 Docker 容器中运行
- en: Sending messages to a queue using an MVC website
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MVC 网站向队列发送消息
- en: Now that we have the RabbitMQ system running, we can add the RabbitMQ client
    package to the MVC website project so that it can send messages to a queue.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了 RabbitMQ 系统，我们可以将 RabbitMQ 客户端包添加到 MVC 网站项目中，以便它可以向队列发送消息。
- en: 'But first, let’s create a class library to define models we will use with the
    queue:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们创建一个类库来定义我们将与队列一起使用的模型：
- en: 'Use your preferred code editor to create a new class library project, as defined
    in the following list:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新的类库项目，如下所示：
- en: Project template: **Class Library** / `classlib`
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: Solution file and folder: `Chapter09`
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: Project file and folder: `Northwind.Queue.Models`
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Queue.Models`
- en: 'Add a project reference to the Northwind entity models project for SQL Server
    that you created in *Chapter 3*, *Building Entity Models for SQL Server Using
    EF Core*, as shown in the following markup:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Northwind 实体模型项目添加为项目引用，该项目是在 *第 3 章* 中创建的，即使用 EF Core 为 SQL Server 构建实体模型，如下所示：
- en: '[PRE53]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'At the command prompt or terminal, build the project to make sure the entity
    model class library projects outside the current solution are properly compiled,
    as shown in the following command:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，构建项目以确保当前解决方案之外的实体模型类库项目已正确编译，如下所示：
- en: '[PRE54]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Delete the file named `Class1.cs`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除名为 `Class1.cs` 的文件。
- en: Add a new file named `ProductQueueMessage.cs`.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `ProductQueueMessage.cs` 的新文件。
- en: 'In `ProductQueueMessage.cs`, define a class that will represent a message in
    a queue with a simple plain text property and a complex `Product` entity model
    type as a second property, as shown in the following code:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductQueueMessage.cs` 文件中，定义一个类，该类将代表队列中的消息，具有一个简单的纯文本属性和一个复杂的 `Product`
    实体模型类型作为第二个属性，如下所示：
- en: '[PRE55]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `Northwind.WebApi.Client.Mvc` project file, add a reference to the queue
    models project so that we can use the `ProductQueueMessage` class, as shown in
    the following markup:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Client.Mvc` 项目文件中，添加对队列模型项目的引用，以便我们可以使用 `ProductQueueMessage`
    类，如下所示：
- en: '[PRE56]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `Northwind.WebApi.Client.Mvc` project file, add a package reference
    for RabbitMQ clients, as shown in the following markup:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Client.Mvc` 项目文件中，添加 RabbitMQ 客户端的包引用，如下所示：
- en: '[PRE57]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can check the latest package version at the following link: [https://www.nuget.org/packages/RabbitMQ.Client/](https://www.nuget.org/packages/RabbitMQ.Client/)'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下链接中检查最新包版本：[https://www.nuget.org/packages/RabbitMQ.Client/](https://www.nuget.org/packages/RabbitMQ.Client/)
- en: Build the `Northwind.WebApi.Client.Mvc` project.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `Northwind.WebApi.Client.Mvc` 项目。
- en: In the `Models` folder, add a new class file named `HomeSendMessageViewModel.cs`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中，添加一个名为 `HomeSendMessageViewModel.cs` 的新类文件。
- en: 'Define a class to represent the information that needs to be displayed in a
    view for sending a message including a couple of properties for showing message
    to the visitor when a message is successfully sent and when an error occurs, as
    shown in the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类来表示需要在视图中显示的发送消息的信息，包括一些属性，用于在消息成功发送和发生错误时向访客显示消息，如下所示：
- en: '[PRE58]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `Views\Home`, in `Index.cshtml`, add a link to a page that will let the
    visitor send a message to a queue, as shown in the following markup:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Home` 目录下的 `Index.cshtml` 文件中，添加一个链接到允许访客向队列发送消息的页面，如下所示：
- en: '[PRE59]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In `HomeControllers.cs`, import namespaces to work with RabbitMQ and serialize
    JSON, as shown in the following code:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeControllers.cs` 文件中，导入命名空间以使用 RabbitMQ 和序列化 JSON，如下所示：
- en: '[PRE60]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `HomeControllers.cs`, add statements to define an action method that responds
    to a `GET` request by showing a web form to send a message, as shown in the following
    code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeControllers.cs` 中，添加语句以定义一个响应 `GET` 请求的动作方法，通过显示发送消息的网页表单，如下所示代码：
- en: '[PRE61]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In `HomeControllers.cs`, add statements to define an action method that responds
    to a `POST` request by sending a message from information in the form, as shown
    in the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeControllers.cs` 中，添加语句以定义一个响应 `POST` 请求的动作方法，通过发送表单中的信息发送消息，如下所示代码：
- en: '[PRE62]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In `Views\Home`, add a new empty Razor View named `SendMessage.cshtml`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Home` 中，添加一个名为 `SendMessage.cshtml` 的新空 Razor 视图。
- en: 'Define a web page with a form to send a message, as shown in the following
    markup:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个带有表单的网页来发送消息，如下所示标记：
- en: '[PRE63]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Consuming message from a queue using a console app
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控制台应用程序从队列中消费消息
- en: 'Finally, we can create a console app that will process messages from the queue:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个将处理队列消息的控制台应用程序：
- en: 'Use your preferred code editor to create a new console app project, as defined
    in the following list:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新的控制台应用程序项目，如下所示列表：
- en: Project template: **Console App** / `console`
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: Solution file and folder: `Chapter09`
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: Project file and folder: `Northwind.Queue.Consumer`
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Queue.Consumer`
- en: 'Treat warnings as errors, add a package reference for RabbitMQ, add project
    references to the Northwind entity models project and the queue message models
    project, and statically and globally import the `System.Console` class, as shown
    in the following markup:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将警告视为错误，添加 RabbitMQ 的包引用，将 Northwind 实体模型项目和队列消息模型项目添加到项目引用中，并静态和全局导入 `System.Console`
    类，如下所示标记：
- en: '[PRE64]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At the command prompt or terminal, build the project, as shown in the following
    command:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，构建项目，如下所示命令：
- en: '[PRE65]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In `Program.cs`, delete any existing statements, and then add statements to
    read messages from the `product` queue, as shown in the following code:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除任何现有语句，然后添加从 `product` 队列读取消息的语句，如下所示代码：
- en: '[PRE66]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If your database server is not running (for example, because you are hosting
    it in Docker, a virtual machine, or in the cloud), then make sure to start it.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的数据库服务器没有运行（例如，因为您在 Docker、虚拟机或云中托管它），那么请确保启动它。
- en: Start the `Northwind.WebApi.Service` project, using the `https` profile without
    debugging.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.WebApi.Service` 项目，使用 `https` 配置文件且不进行调试。
- en: Start the `Northwind.WebApi.Client.Mvc` project, using the `https` profile without
    debugging.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.WebApi.Client.Mvc` 项目，使用 `https` 配置文件且不进行调试。
- en: 'Start the `Northwind.Queue.Consumer` console app project with or without debugging:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.Queue.Consumer` 控制台应用程序项目，带或不带调试：
- en: Optionally, you can configure your solution to start up all three projects at
    once, as shown for Visual Studio 2022 in *Figure 9.4*:![](img/B19587_09_04.png)
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，您可以配置解决方案以同时启动所有三个项目，如图 *9.4* 所示（针对 Visual Studio 2022）：![](img/B19587_09_04.png)
- en: 'Figure 9.4: Configuring three startup projects to test message queues'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.4：配置三个启动项目以测试消息队列
- en: 'Arrange the console app and the MVC web page so that you can see both, then
    click **Send a message**, and enter a simple text message and a valid product
    ID (1 to 77), as shown in *Figure 9.5*:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安排控制台应用程序和 MVC 网页，以便您可以同时看到它们，然后单击 **发送消息**，并输入一个简单的文本消息和有效的产品 ID（1 到 77），如图
    *9.5* 所示：
- en: '![](img/B19587_09_05.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_09_05.png)'
- en: 'Figure 9.5: An ASP.NET Core MVC website sending a message to a queue'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：向队列发送消息的 ASP.NET Core MVC 网站
- en: 'Click **Send**, and note the message that appears in the console app, as shown
    in *Figure 9.6*:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送**，并注意控制台应用程序中出现的消息，如图 *9.6* 所示：
- en: '![](img/B19587_09_06.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_09_06.png)'
- en: 'Figure 9.6: A console app consuming a message from the queue'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：从队列中消费消息的控制台应用程序
- en: 'In the command prompt or terminal for Docker, press *Ctrl* + *C* to shut down
    the container, and note the result, as shown in the following output:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker 的命令提示符或终端中，按 *Ctrl* + *C* 关闭容器，并注意结果，如下所示输出：
- en: '[PRE67]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In **Docker Desktop**, note the container is gone from the list, but the image
    remains for quicker use next time.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Docker Desktop** 中，注意容器已从列表中消失，但镜像仍然存在，以便下次更快地使用。
- en: '**More Information**: You can read more about using RabbitMQ with .NET at the
    following link: [https://www.rabbitmq.com/dotnet-api-guide.html](https://www.rabbitmq.com/dotnet-api-guide.html).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于在 .NET 中使用 RabbitMQ 的信息：[https://www.rabbitmq.com/dotnet-api-guide.html](https://www.rabbitmq.com/dotnet-api-guide.html)。'
- en: The combination of caching, queuing, and handling transient faults goes a long
    way to making your services more resilient, scalable, and performant. In the last
    section of this chapter, we will look at long-running background services.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存、队列和处理短暂故障的组合对于使您的服务更加健壮、可扩展和高效大有裨益。在本章的最后部分，我们将探讨长时间运行的后台服务。
- en: Implementing long-running background services
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现长时间运行的后台服务
- en: 'It is common to need long-running background services to perform operations
    like:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 需要长时间运行的后台服务来执行诸如操作是很常见的：
- en: Performing a task on a regular timed schedule.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定期的时间表上执行任务。
- en: Processing queued messages.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理队列中的消息。
- en: Performing intense work like building AI and ML models or processing video and
    images.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行像构建 AI 和 ML 模型或处理视频和图像这样的密集型工作。
- en: In the distant past, on the Windows operating system, to have some code running
    in the background meant building a **Windows Service**. For example, the database
    engine of SQL Server is implemented as a Windows Service. With the move to cross-platform,
    .NET needs a cross-platform solution to run code in the background.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在遥远的过去，在 Windows 操作系统中，要在后台运行一些代码意味着构建一个 **Windows 服务**。例如，SQL Server 的数据库引擎就是作为
    Windows 服务实现的。随着跨平台的迁移，.NET 需要一个跨平台的解决方案来在后台运行代码。
- en: Background services often do not have a user interface, although they might
    provide one for the configuration and management of the service.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 后台服务通常没有用户界面，尽管它们可能为服务的配置和管理提供用户界面。
- en: Building a worker service
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建工作服务
- en: 'Now, let’s build a worker service project so that we can see how we would host
    a long-running background service:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个工作服务项目，以便我们可以看到如何托管长时间运行的后台服务：
- en: 'Use your preferred code editor to add a new project, as defined in the following
    list:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器添加一个新项目，如下面的列表所示：
- en: 'Project template: **Worker Service** / `worker`'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**工作服务** / `worker`
- en: 'Solution file and folder: `Chapter09`'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: 'Project file and folder: `Northwind.Background.Workers`'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Background.Workers`
- en: '**Enable Docker**: Cleared'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 Docker**：已清除'
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除'
- en: '**Enable native AOT publish**: Cleared'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生 AOT 发布**：已清除'
- en: 'In the `Northwind.Background.Workers` project file, note that the .NET SDK
    is `Microsoft.NET.Sdk.Worker`, and then make the following changes, as highlighted
    in the following markup:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Background.Workers` 项目文件中，请注意 .NET SDK 是 `Microsoft.NET.Sdk.Worker`，然后按照以下标记进行以下更改：
- en: Treat warnings as errors.
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将警告视为错误。
- en: Add a package reference for RabbitMQ.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 RabbitMQ 的包引用。
- en: 'Add references to the entity models and queue models projects:'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对实体模型和队列模型项目的引用：
- en: '[PRE68]'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Build the `Northwind.Background.Workers` project at the command prompt or terminal
    by entering the following command: `dotnet build`.'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中通过输入以下命令构建 `Northwind.Background.Workers` 项目：`dotnet build`。
- en: 'In `Program.cs`, note that the initialization statements are like an ASP.NET
    Core project, and that it registers a hosted service named `Worker` and then runs
    the host, as shown in the following code:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，请注意初始化语句类似于 ASP.NET Core 项目，并且它注册了一个名为 `Worker` 的托管服务然后运行宿主，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In `Worker.cs`, note that the `Worker` class inherits from `BackgroundService`
    and implements its `ExecuteAsync` method by looping until a cancellation is requested,
    logging the current date/time, and then pausing for one second, as shown in the
    following code:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Worker.cs` 中，请注意 `Worker` 类继承自 `BackgroundService` 并通过循环直到请求取消、记录当前日期/时间然后暂停一秒钟来实现其
    `ExecuteAsync` 方法，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Start the project without debugging, note the current time is output once per
    second, and then press *Ctrl* + *C* to shut down the worker service, as shown
    in the following output:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不进行调试启动项目，注意当前时间每秒输出一次，然后按 *Ctrl* + *C* 关闭工作服务，如下面的输出所示：
- en: '[PRE71]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Processing queued message using a worker service
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作服务处理队列中的消息
- en: 'Now, we can do some useful work, like reading messages from a RabbitMQ queue:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以做一些有用的工作，比如从 RabbitMQ 队列中读取消息：
- en: Rename `Worker.cs` to `QueueWorker.cs` and the `Worker` class to `QueueWorker`.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Worker.cs` 重命名为 `QueueWorker.cs`，并将 `Worker` 类重命名为 `QueueWorker`。
- en: 'In `Program.cs`, change the hosted service class name from `Worker` to `QueueWorker`,
    as shown in the following code:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，将托管服务类的名称从 `Worker` 更改为 `QueueWorker`，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `QueueWorker.cs`, import namespaces to work with RabbitMQ queues and implement
    a queue processor, as highlighted in the following code:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `QueueWorker.cs` 中导入命名空间以使用 RabbitMQ 队列并实现队列处理器，如下所示代码：
- en: '[PRE73]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Start the RabbitMQ container, as shown in the following command:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 RabbitMQ 容器，如下所示命令：
- en: '[PRE74]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Wait for the messages to say it is ready for clients to connect on port `5672`,
    as shown in the following output:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待消息表明它已准备好在端口 `5672` 上供客户端连接，如下所示输出：
- en: '[PRE75]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Leave the command prompt or terminal running.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让命令提示符或终端继续运行。
- en: If your database server is not running (for example, because you are hosting
    it in Docker, a virtual machine, or in the cloud), then make sure to start it.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的数据库服务器没有运行（例如，因为您在 Docker、虚拟机或云中托管它），那么请确保启动它。
- en: Start the `Northwind.WebApi.Service` project without debugging so that we can
    query for products in the Northwind database.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.WebApi.Service` 项目，以便我们可以查询 Northwind 数据库中的产品。
- en: Start the `Northwind.WebApi.Client.Mvc` project without debugging so that we
    can send messages to the RabbitMQ queue.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.WebApi.Client.Mvc` 项目，以便我们可以向 RabbitMQ 队列发送消息。
- en: In the MVC website, click **Send a message**, and then enter a message of `apples`
    and a product ID of `1`.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MVC 网站中，点击 **发送消息**，然后输入消息 `apples` 和产品 ID `1`。
- en: Repeat for `bananas` and `2`, and `cherries` and `3`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `bananas` 和 `2`，以及 `cherries` 和 `3` 重复操作。
- en: 'Start the `Northwind.Background.Workers` project without debugging, and note
    the three messages are processed from the queue, as shown in the following output:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.Background.Workers` 项目，并注意从队列中处理了三条消息，如下所示输出：
- en: '[PRE76]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Executing code on a timed schedule
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在定时计划上执行代码
- en: Another common use of worker services is to implement timed events. A timer-based
    background service can use the `System.Threading.Timer` class that triggers the
    `DoWork` method.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 工作进程服务的另一个常见用途是实现定时事件。基于定时器的后台服务可以使用触发 `DoWork` 方法的 `System.Threading.Timer`
    类。
- en: 'Let’s add another service to the background worker project:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向后台工作进程项目添加另一个服务：
- en: In the `Northwind.Background.Workers` project, add a new class named `TimerWorker.cs`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Background.Workers` 项目中，添加一个名为 `TimerWorker.cs` 的新类。
- en: 'Modify the class, as shown in the following code:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类，如下所示代码：
- en: '[PRE77]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In `Program.cs`, add a statement to register the timer worker service, as shown
    in the following code:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加一个语句来注册定时器工作进程服务，如下所示代码：
- en: '[PRE78]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Start the `Northwind.Background.Workers` project without debugging, and note
    the initialization of both workers, as shown in the following output:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.Background.Workers` 项目，并注意两个工作进程的初始化，如下所示输出：
- en: '[PRE79]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Leave the background workers running for at least 10 seconds, and note the
    queue worker writes to the log every second and the timer worker writes to the
    log every five seconds, as shown in the following output:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让后台工作进程至少运行 10 秒钟，并注意队列工作进程每秒向日志写入一次，定时器工作进程每五秒向日志写入一次，如下所示输出：
- en: '[PRE80]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Press *Ctrl* + *C* to shut down the background workers, and note the clean
    shutdown of the timer worker, as shown in the following output:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 关闭后台工作进程，并注意定时器工作进程的干净关闭，如下所示输出：
- en: '[PRE81]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If we wanted to use the timer background service to have more flexibility, instead
    of running it at a regular interval like five seconds, we could have it run a
    scheduled task check every second, and only if a task has reached its scheduled
    time does it then run that task. We need somewhere to define tasks and when they
    are scheduled to run. Although you can build this infrastructure yourself, it
    is easier to use a third-party library like **Hangfire**.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用定时器后台服务以获得更多灵活性，而不是像每五秒那样定期运行，我们可以让它每秒检查一次预定任务，并且只有当任务达到预定时间时才运行该任务。我们需要一个地方来定义任务以及它们何时被预定运行。虽然您可以自己构建这个基础设施，但使用像
    **Hangfire** 这样的第三方库更容易。
- en: Building a website to host Hangfire
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Hangfire 的网站以托管
- en: 'Hangfire is open source and free for commercial use. It supports the following
    patterns of use:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Hangfire 是开源的，并且可以免费用于商业用途。它支持以下使用模式：
- en: '**Fire-and-forget**: Jobs that are executed once and started immediately.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性执行并忽略结果**：执行一次并立即启动的工作。'
- en: '**Delayed**: Jobs that are executed once but at a date and time in the future.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟执行**：虽然只执行一次，但会在未来的日期和时间执行的工作。'
- en: '**Recurring**: Jobs that are executed repeatedly at a regular CRON schedule.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复执行**：按照常规 CRON 调度重复执行的工作。'
- en: '**Continuation**: Jobs that are executed on completion of a parent job.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延续执行**：在父作业完成后执行的工作。'
- en: '**Batches**: Jobs that are transactional. These are only available in the paid
    version.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**：事务性作业。这些仅在付费版本中可用。'
- en: 'Hangfire has persistent storage and can be configured to use:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: Hangfire 具有持久存储，并可以配置为使用：
- en: SQL Server
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server
- en: Redis
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: In-memory
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中
- en: Community-developed storage
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区开发的存储
- en: 'Let’s set up an empty ASP.NET Core project to host Hangfire:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个空的 ASP.NET Core 项目来托管 Hangfire：
- en: 'Use your preferred code editor to create a new Web API controller-based project,
    as defined in the following list:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新的基于 Web API 控制器的项目，如下面的列表所示：
- en: Project template: **ASP.NET Core Empty** / `web`
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**ASP.NET Core Empty** / `web`
- en: Solution file and folder: `Chapter09`
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: Project file and folder: `Northwind.Background.Hangfire`
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Background.Hangfire`
- en: '**Configure for HTTPS**: Selected.'
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置 HTTPS**：已选择。'
- en: '**Enable Docker**: Cleared.'
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 Docker**：已清除。'
- en: '**Do not use top-level statements**: Cleared.'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除。'
- en: 'In the project file, treat warnings as errors, and add package references to
    work with Hangfire and persist its data to SQL Server, as shown in the following
    markup:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，将警告视为错误，并添加包引用以与 Hangfire 一起工作并将数据持久化到 SQL Server，如下面的标记所示：
- en: '[PRE82]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Build the project to restore packages.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以还原包。
- en: 'In the `Properties` folder, in `launchSettings.json`, modify the `applicationUrl`
    of the profile named `https` to use port `5095` for `https` and port `5096` for
    `http`, as highlighted in the following configuration:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Properties` 文件夹中，在 `launchSettings.json` 中，修改名为 `https` 的配置文件的 `applicationUrl`，使其使用端口
    `5095` 用于 `https` 和端口 `5096` 用于 `http`，如下面的配置所示：
- en: '[PRE83]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In `appsettings.Development.json`, add an entry to set the Hangfire log level
    to `Information`, as highlighted in the following JSON:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `appsettings.Development.json` 中，添加一个条目来设置 Hangfire 日志级别为 `Information`，如下面的
    JSON 所示：
- en: '[PRE84]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create a SQL Server database named `Northwind.HangfireDb`:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Northwind.HangfireDb` 的 SQL Server 数据库：
- en: If you are using Visual Studio 2022, navigate to **View** | **Server Explorer**,
    right-click **Data Connections**, choose **Create New SQL Server database…**,
    enter connection information and the database name, and then click **OK**.
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio 2022，请转到 **视图** | **服务器资源管理器**，右键单击 **数据连接**，选择 **创建新的
    SQL Server 数据库…**，输入连接信息和数据库名称，然后单击 **确定**。
- en: 'If you are using Visual Studio Code, navigate to **SQL** **Server**, right-click
    and choose **New Query**, enter connection information, and then in the query
    window, enter the following SQL command and execute it:'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio Code，请转到 **SQL** **Server**，右键单击并选择 **新建查询**，输入连接信息，然后在查询窗口中输入以下
    SQL 命令并执行它：
- en: '[PRE85]'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    configure Hangfire to use SQL Server and to enable Hangfire Dashboard, as shown
    in the following code:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后添加语句来配置 Hangfire 使用 SQL Server 并启用 Hangfire 仪表板，如下面的代码所示：
- en: '[PRE86]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Start the `Northwind.Background.Hangfire` project without debugging, and note
    the messages written to the console, as shown in the following output:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.Background.Hangfire` 项目，并注意控制台输出的消息，如下所示输出：
- en: '[PRE87]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the browser, note the plain text message, and then in the address bar, append
    `hangfire`, and note the **Hangfire Dashboard** user interface, as shown in *Figure
    9.7*:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，注意查看纯文本消息，然后在地址栏中追加 `hangfire`，并注意**Hangfire 仪表板**用户界面，如图 9.7 所示：
- en: '![](img/B19587_09_07.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_09_07.png)'
- en: 'Figure 9.7: Hangfire Dashboard user interface'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：Hangfire 仪表板用户界面
- en: 'Close the browser window, and at the command prompt or terminal for the Hangfire
    service, press *Ctrl* + *C* to cleanly shut down the server, and note the messages,
    as shown in the following output:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器窗口，在 Hangfire 服务的命令提示符或终端中，按 *Ctrl* + *C* 来干净地关闭服务器，并注意消息，如下面的输出所示：
- en: '[PRE88]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Scheduling jobs using Hangfire
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hangfire 调度作业
- en: 'Next, we will allow a client to schedule a job (in this case, just writing
    a message to the console a specified number of seconds in the future) by `POST`ing
    to the web service:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将允许客户端通过向 Web 服务 `POST` 来调度一个作业（在这种情况下，只是将消息写入控制台，在未来的指定秒数后）：
- en: In the `Northwind.Background.Hangfire` project, add a new class file named `WriteMessageJobDetail.cs`.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Background.Hangfire` 项目中，添加一个名为 `WriteMessageJobDetail.cs` 的新类文件。
- en: 'In `WriteMessageJobDetail.cs`, define a class to represent a scheduled job,
    as shown in the following code:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WriteMessageJobDetail.cs` 中，定义一个表示计划作业的类，如下面的代码所示：
- en: '[PRE89]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the `Northwind.Background.Hangfire` project, add a new class file named `Program.Methods.cs`.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Background.Hangfire` 项目中，添加一个名为 `Program.Methods.cs` 的新类文件。
- en: 'In `Program.Methods.cs`, extend the partial `Program` class with a method to
    write a message to the console in green color, as shown in the following code:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Methods.cs` 中，通过一个方法扩展部分 `Program` 类，该方法可以将消息以绿色颜色写入控制台，如下面的代码所示：
- en: '[PRE90]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In `Program.cs`, import namespaces to work with the job, as shown in the following
    code:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入命名空间以处理工作，如下面的代码所示：
- en: '[PRE91]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In `Program.cs`, after the statement to map a `GET` request, map a `POST` request
    to the relative path `/schedulejob`, get the job details from the body of the
    `POST` request, and use it to schedule a background job, using Hangfire to run
    at the specified time in seconds in the future, as shown in the following code:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在映射 `GET` 请求的语句之后，将 `POST` 请求映射到相对路径 `/schedulejob`，从 `POST`
    请求的正文获取工作详情，并使用它来安排一个后台工作，使用 Hangfire 在未来的指定秒数后运行，如下面的代码所示：
- en: '[PRE92]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Start the `Northwind.Background.Hangfire` project without debugging.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.Background.Hangfire` 项目。
- en: 'In the command prompt or terminal, confirm that all the dispatchers started,
    as shown in the following output:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，确认所有调度器都已启动，如下面的输出所示：
- en: '[PRE93]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the browser, navigate to `/hangfire` to view Hangfire Dashboard.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，导航到 `/hangfire` 以查看 Hangfire Dashboard。
- en: In your code editor, in the `HttpRequests` folder, create a file named `hangfire-schedule-job.http`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中，在 `HttpRequests` 文件夹中，创建一个名为 `hangfire-schedule-job.http` 的文件。
- en: 'In `hangfire-schedule-job.http`, add statements to make a `POST` request to
    the Hangfire service, as shown in the following code:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `hangfire-schedule-job.http` 中添加语句以向 Hangfire 服务发送 `POST` 请求，如下面的代码所示：
- en: '[PRE94]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Send the request, and note the successful response, as shown in the following
    output:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求，并注意成功的响应，如下面的输出所示：
- en: '[PRE95]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the browser, in **Hangfire Dashboard**, click **Jobs** in the top menu click
    **Jobs**, in the left side menu, and then note there is one scheduled job, as
    shown in *Figure 9.8*:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，在 **Hangfire Dashboard** 中，点击顶部菜单中的 **作业**，在左侧菜单中点击 **作业**，并注意有一个计划任务，如图
    *9.8* 所示：
- en: '![](img/B19587_09_08.png)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_09_08.png)'
- en: 'Figure 9.8: Scheduled jobs in Hangfire'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：Hangfire 中的计划任务
- en: 'Wait until 30 seconds have passed, and then in the left -side menu, click **Succeeded**,
    and note the job has succeeded, as shown in *Figure 9.9*:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 30 秒钟后，然后在左侧菜单中点击 **成功**，并注意工作已成功，如图 *9.9* 所示：
- en: '![](img/B19587_09_09.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_09_09.png)'
- en: 'Figure 9.9: Succeeded jobs in Hangfire'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：Hangfire 中的成功作业
- en: 'At the command prompt or terminal, note the message that was written to the
    console, as shown in the following output:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，注意写入控制台的消息，如下面的输出所示：
- en: '[PRE96]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Close the browser and shut down the server.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器并关闭服务器。
- en: '**More Information**: You can read more about Hangfire at the following link:
    [https://www.hangfire.io/](https://www.hangfire.io/).'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于 Hangfire 的信息：[https://www.hangfire.io/](https://www.hangfire.io/)。'
- en: Practicing and exploring
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题，进行一些动手实践，并深入探索本章的主题来测试你的知识和理解。
- en: Exercise 9.1 – Test your knowledge
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: How much longer does it take to read 1 MB of data from SSD compared to memory?
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与内存相比，从 SSD 读取 1 MB 数据需要多长时间？
- en: What is the difference between absolute and sliding expirations?
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绝对过期和滑动过期有什么区别？
- en: What unit of measurement is used by `Size` for the in-memory cache?
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Size` 在内存缓存中使用的测量单位是什么？'
- en: You have written the following statement to get information about in-memory
    caching but `stats` is `null`. What must you do to fix this issue?
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经编写了以下语句来获取内存缓存的信息，但 `stats` 是 `null`。你必须做什么来解决这个问题？
- en: '[PRE97]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: What data types can be stored in (a) an in-memory cache, and (b) a distributed
    cache?
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (a) 内存缓存和 (b) 分布式缓存可以存储哪些数据类型？
- en: What are the differences between the Retry and Circuit Breaker patterns?
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重试模式和断路器模式有什么区别？
- en: When using the RabbitMQ default direct exchange, what must the routing key be
    for a queue named `product`?
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 RabbitMQ 默认的直接交换时，名为 `product` 的队列的路由键必须是什么？
- en: What is the difference between a fanout and a topic exchange?
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广播交换和主题交换有什么区别？
- en: What port does RabbitMQ listen on by default?
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RabbitMQ 默认监听哪个端口？
- en: When inheriting from the `BackgroundService` class, what method must you override
    that is called automatically by the host to run your service?
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从 `BackgroundService` 类继承时，你必须覆盖哪个方法，该方法是主机自动调用来运行你的服务的？
- en: Exercise 9.2 – Explore topics
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.2 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-9---caching-queuing-and-resilient-background-services](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-9---caching-queuing-and-resilient-background-services)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-9---caching-queuing-and-resilient-background-services](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-9---caching-queuing-and-resilient-background-services)'
- en: Exercise 9.3 – Replace the Distributed Memory Cache with another distributed
    cache implementation
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.3 – 用另一个分布式缓存实现替换分布式内存缓存
- en: In this chapter, we used the Distributed Memory Cache implementation to explore
    how to use a distributed cache.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了分布式内存缓存实现来探索如何使用分布式缓存。
- en: As an optional exercise, register for an Azure account if you have not already,
    create an **Azure Cache for Redis** resource, and change your web service project
    configuration to use it.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项可选练习，如果你还没有注册 Azure 账户，请注册一个，创建一个名为 **Azure Cache for Redis** 的资源，并将你的 Web
    服务项目配置更改为使用它。
- en: 'In the `Northwind.WebApi.Service`, you will need to reference the Redis package,
    comment out the previously registered distributed cache implementation, and then
    call the extension method to register Redis as the distributed cache implementation:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.Service` 中，你需要引用 Redis 包，注释掉之前注册的分布式缓存实现，然后调用扩展方法将 Redis
    注册为分布式缓存实现：
- en: '[PRE98]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Read more at the following links:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中了解更多信息：
- en: 'Azure Cache for Redis: [https://azure.microsoft.com/en-us/products/cache/](https://azure.microsoft.com/en-us/products/cache/).'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure Cache for Redis: [https://azure.microsoft.com/en-us/products/cache/](https://azure.microsoft.com/en-us/products/cache/).'
- en: 'Redis NuGet package: [https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis).'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redis NuGet 包: [https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis).'
- en: 'Redis with .NET: [https://docs.redis.com/latest/rs/references/client_references/client_csharp](https://docs.redis.com/latest/rs/references/client_references/client_csharp).'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redis 与 .NET: [https://docs.redis.com/latest/rs/references/client_references/client_csharp](https://docs.redis.com/latest/rs/references/client_references/client_csharp).'
- en: Exercise 9.4 – Replace Hangfire with Quartz.NET
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.4 – 用 Quartz.NET 替换 Hangfire
- en: '**Quartz.NET** is a similar library to Hangfire. Read the official documentation,
    and then create a project named `Northwind.Background.Quartz` that implements
    the same functionality as `Northwind.Background.Hangfire`:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quartz.NET** 是与 Hangfire 类似的库。阅读官方文档，然后创建一个名为 `Northwind.Background.Quartz`
    的项目，该项目的功能与 `Northwind.Background.Hangfire` 相同：'
- en: '[https://www.quartz-scheduler.net/](https://www.quartz-scheduler.net/)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.quartz-scheduler.net/](https://www.quartz-scheduler.net/)'
- en: Exercise 9.5 – Review the Reliable Web App pattern
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.5 – 审查可靠的 Web 应用模式
- en: 'The **Reliable Web App** (**RWA**) pattern is a set of best practices with
    prescriptive guidance that helps developers successfully migrate an on-premises
    web project to the cloud. It includes a reference implementation and shows how
    to make the most of Azure cloud services to modernize mission-critical workloads
    in a reliable, secure, high-performance, cost-efficient manner using modern design,
    development, and operational practices:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠的 Web 应用**（**RWA**）模式是一套包含指导性建议的最佳实践，帮助开发者成功地将本地 Web 项目迁移到云端。它包括一个参考实现，并展示了如何利用
    Azure 云服务以可靠、安全、高性能、成本效益的方式，通过现代的设计、开发和运营实践来现代化关键业务负载：'
- en: '[https://learn.microsoft.com/en-us/azure/architecture/web-apps/guides/reliable-web-app/dotnet/plan-implementation](https://learn.microsoft.com/en-us/azure/architecture/web-apps/guides/reliable-web-app/dotnet/plan-implementation)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/azure/architecture/web-apps/guides/reliable-web-app/dotnet/plan-implementation](https://learn.microsoft.com/en-us/azure/architecture/web-apps/guides/reliable-web-app/dotnet/plan-implementation)'
- en: 'A collection of videos about the RWA pattern for .NET are at the following
    link:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接包含关于 .NET RWA 模式的视频集合：
- en: '[https://www.youtube.com/playlist?list=PLI7iePan8aH54gIDJquV61dE3ENyaDi3Q](https://www.youtube.com/playlist?list=PLI7iePan8aH54gIDJquV61dE3ENyaDi3Q)'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/playlist?list=PLI7iePan8aH54gIDJquV61dE3ENyaDi3Q](https://www.youtube.com/playlist?list=PLI7iePan8aH54gIDJquV61dE3ENyaDi3Q)'
- en: Summary
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: About service architecture and how different parts of a system can affect performance.
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于服务架构以及系统的不同部分如何影响性能。
- en: How to cache data closer to the action, using in-memory and distributed caching.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用内存和分布式缓存将数据缓存得更靠近操作。
- en: How to control HTTP caching for clients and intermediaries.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何控制客户端和中间件对 HTTP 缓存的访问。
- en: How to implement fault tolerance using Polly.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Polly 实现容错。
- en: How to implement queuing using RabbitMQ.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 RabbitMQ 实现队列。
- en: How to implement long-running background services using `BackgroundService`
    and Hangfire.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `BackgroundService` 和 Hangfire 实现长时间运行的后台服务。
- en: In the next chapter, you will learn how to use Azure Functions to implement
    nano services, aka serverless services.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 Azure Functions 来实现纳米服务，也就是无服务器服务。
- en: Learn more on Discord
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
- en: '![](img/QR_Code3048220001028652625.png)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code3048220001028652625.png)'
