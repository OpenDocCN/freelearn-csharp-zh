<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor233"/>7</h1>
<h1 id="_idParaDest-123"><a id="_idTextAnchor234"/>Variants of Trees</h1>
<p>In the previous chapters, you learned about many data structures, starting with simple ones such as arrays. Now, it is time for you to get to know a significantly more complex group of data structures, namely <strong class="bold">trees</strong>.</p>
<p>At the beginning of this chapter, a <strong class="bold">basic tree</strong> will be<a id="_idIndexMarker598"/> presented, together with its implementation in the C# language, and with some examples showing it in action. Then, a <strong class="bold">binary tree</strong> will be<a id="_idIndexMarker599"/> introduced, with a detailed description of its implementation and an example of its application. A <strong class="bold">binary search tree</strong> (<strong class="bold">BST</strong>) is another tree variant and is <a id="_idIndexMarker600"/>one of the most popular types of trees, used in many algorithms. You will also<a id="_idIndexMarker601"/> cover <strong class="bold">self-balancing trees</strong>, namely <strong class="bold">AVL</strong><a id="_idIndexMarker602"/> and <strong class="bold">red-black trees</strong> (<strong class="bold">RBTs</strong>). Then, you will see a <strong class="bold">trie</strong> as a specialized data structure for performing <a id="_idIndexMarker603"/>operations on strings. The remaining part of the chapter is dedicated to a short introduction to the topic of <strong class="bold">heaps</strong>.</p>
<p>Arrays, lists, stacks, queues, dictionaries, sets, and now trees. Are you ready to increase the level of difficulty and learn the next data structures? If so, let’s start reading!</p>
<p>In this chapter, the following topics will be covered:</p>
<ul>
<li>Basic trees</li>
<li>Binary trees</li>
<li>Binary search trees</li>
<li>Self-balancing trees</li>
<li>Tries</li>
<li><a id="_idTextAnchor235"/><a id="_idTextAnchor236"/>Heaps</li>
</ul>
<h1 id="_idParaDest-124"><a id="_idTextAnchor237"/>Basic trees</h1>
<p>Let’s start with introducing trees. What <a id="_idIndexMarker604"/>are they? Do you have any ideas about how such a data structure should look? If not, let’s take a look at the following diagram, which depicts a tree with captions regarding its particular elements:</p>
<div><div><img alt="Figure 7.1 – ﻿Illustration of a tree" src="img/B18069_07_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Illustration of a tree</p>
<p>A tree consists of multiple <strong class="bold">nodes</strong>, including<a id="_idIndexMarker605"/> one <strong class="bold">root</strong> (<strong class="bold">100</strong> in the diagram). The root<a id="_idIndexMarker606"/> does not <a id="_idIndexMarker607"/>contain a <strong class="bold">parent</strong> node, while all other nodes do. For example, the parent element of node <strong class="bold">1</strong> is <strong class="bold">100</strong>, while node <strong class="bold">96</strong> has node <strong class="bold">30</strong> as the parent.</p>
<p>Moreover, each node can have any number <a id="_idIndexMarker608"/>of <strong class="bold">child</strong> nodes, such as three <strong class="bold">children</strong> (that is, <strong class="bold">50</strong>, <strong class="bold">1</strong>, and <strong class="bold">150</strong>) in the case of the <strong class="bold">root</strong>. The child nodes of the same node can be named <strong class="bold">siblings</strong>, as in the case of nodes <strong class="bold">70</strong> and <strong class="bold">61</strong>. A node without children is named a <strong class="bold">leaf</strong>, such <a id="_idIndexMarker609"/>as <strong class="bold">45</strong> and <strong class="bold">6</strong> in the diagram.</p>
<p>Let’s take a look at the rectangle with three nodes (that is, <strong class="bold">30</strong>, <strong class="bold">96</strong>, and <strong class="bold">9</strong>). Such a part of the tree can be called a <strong class="bold">subtree</strong>. Of course, you <a id="_idIndexMarker610"/>can find many subtrees in the tree.</p>
<p class="callout-heading">Imagine a tree</p>
<p class="callout">If you want to better imagine a tree, look at the structure of a slightly larger company, where at the very top of the hierarchy there<a id="_idIndexMarker611"/> is the <strong class="bold">chief executive officer</strong> (<strong class="bold">CEO</strong>), to whom the <strong class="bold">chief operating officer</strong> (<strong class="bold">COO</strong>), <strong class="bold">chief marketing officer</strong> (<strong class="bold">CMO</strong>), <strong class="bold">chief financial officer</strong> (<strong class="bold">CFO</strong>), and <strong class="bold">chief technology officer</strong> (<strong class="bold">CTO</strong>) are assigned. As<a id="_idIndexMarker612"/> sales is one<a id="_idIndexMarker613"/> of the key topics in the <a id="_idIndexMarker614"/>company’s operations, regional <a id="_idIndexMarker615"/>directors report to the COO, and for each of them, between three and five sales specialists are assigned. Look for yourself – you have a tree in your mind right now! Its root is the CEO, which has four children (COO, CMO, CFO, and CTO), which can have further child nodes to create subsequent levels of the hierarchy. Sales specialists who no longer have any subordinates are named leaves.</p>
<p>Let’s briefly talk about the minimum and maximum numbers of children of a node. In general, such numbers are not limited, and each node can contain zero, one, two, three, or even more children. However, in practical applications, the number of children is often limited to two, as y<a id="_idTextAnchor238"/>o<a id="_idTextAnchor239"/>u will see soon.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor240"/>Implementation</h2>
<p>The C#-based implementation of a<a id="_idIndexMarker616"/> basic tree seems to be quite obvious and not complicated. To do so, you declare two classes, representing a single node and a whole tree, as describe<a id="_idTextAnchor241"/>d<a id="_idTextAnchor242"/> in this section.</p>
<h3>Node</h3>
<p>The first class is named <code>TreeNode</code> and is declared as a generic class to provide a developer with the ability to specify a type of data stored in each node. Thus, you can create a strongly typed solution, which<a id="_idIndexMarker617"/> eliminates the necessity of casting objects to target types. The code is as follows:</p>
<pre class="source-code">
public class <strong class="bold">TreeNode&lt;T&gt;</strong>
{
    public T? <strong class="bold">Data</strong> { get; set; }
    public TreeNode&lt;T&gt;? <strong class="bold">Parent</strong> { get; set; }
    public List&lt;TreeNode&lt;T&gt;&gt; <strong class="bold">Children</strong> { get; set; } = [];
    public int <strong class="bold">GetHeight</strong>()
    {
        int height = 1;
        TreeNode&lt;T&gt; current = this;
        while (current.Parent != null)
        {
            height++;
            current = current.Parent;
        }
        return height;
    }
}</pre> <p>The class contains three properties:</p>
<ul>
<li>The data stored in the node (<code>Data</code>)</li>
<li>A reference to the parent node (<code>Parent</code>)</li>
<li>A collection of references to child nodes (<code>Children</code>)</li>
</ul>
<p>Apart from th<a id="_idIndexMarker618"/>e properties, the <code>TreeNode</code> class contains the <code>GetHeight</code> method, which returns the height of the node – that is, the distance from this node to the root node. The implementation of this method is very simple because it just uses a <code>while</code> loop to go up from the node until there is no parent element, which means that <a id="_idTextAnchor243"/>t<a id="_idTextAnchor244"/>he root is reached.</p>
<h3>Tree</h3>
<p>The next necessary class<a id="_idIndexMarker619"/> is named <code>Tree</code>. It represents the whole tree, as follows:</p>
<pre class="source-code">
public class <strong class="bold">Tree&lt;T&gt;</strong>
{
    public TreeNode&lt;T&gt;? <strong class="bold">Root</strong> { get; set; }
}</pre> <p>The class contains only one property, <code>Root</code>. You can use this property to get access to the root node, and then you can use its <code>Children</code> property to obtain data of its child nodes. Then, you can take a look at each of them and get data of their child nodes, as well. By repeating such operations, you can get data from all nodes located in the tree.</p>
<p>It is worth noting that<a id="_idIndexMarker620"/> both <code>TreeNode</code> and <code>Tree</code> classes are generic, and the same type is used in the case of these classes. For instance, if tree nodes should store <code>string</code> values, the <code>string</code> type should be used for instances of <code>Tree<a id="_idTextAnchor245"/></code> <a id="_idTextAnchor246"/>and <code>TreeNode</code> classes.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor247"/>Example – hierarchy of identifiers</h2>
<p>Do you want to see how<a id="_idIndexMarker621"/> to use a tree in a C#-based application? Let’s take a look at our first example. The aim is to construct a tree with a few nodes, as shown in the following diagram. Only the group of nodes with a bolder border will be presented in the code. However, it is a good idea to adjust the code to construct the whole tree by yourself:</p>
<div><div><img alt="Figure 7.2 – ﻿Illustration of the hierarchy of identifiers example" src="img/B18069_07_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Illustration of the hierarchy of identifiers example</p>
<p>Here, each node stores an integer value, so <code>int</code> is the type used for both the <code>Tree</code> and <code>TreeNode</code> classes. The<a id="_idIndexMarker622"/> following code should be placed in the <code>Program.cs</code> file:</p>
<pre class="source-code">
Tree&lt;int&gt; tree = new() { Root = new() { Data = <strong class="bold">100</strong> } };
tree.Root.Children =
[
    new() { Data = <strong class="bold">50</strong>, Parent = tree.Root },
    new() { Data = <strong class="bold">1</strong>, Parent = tree.Root },
    new() { Data = <strong class="bold">150</strong>, Parent = tree.Root }
];
tree.Root.Children[2].Children =
[
    new() { Data = <strong class="bold">30</strong>, Parent = tree.Root.Children[2] }
];</pre> <p>The code looks quite simple, doesn’t it? At the beginning, a new instance of the <code>Tree</code> class is created and the root node is configured by creating a new instance of the <code>TreeNode</code> class and setting a value of the <code>Data</code> property to <code>100</code>.</p>
<p>In the following lines, the child nodes of the root node are specified, namely the nodes with values equal to <code>50</code>, <code>1</code>, and <code>150</code>. For each of them, a value of the <code>Parent</code> property is set to a reference to the previously added root node.</p>
<p>The remaining part of the code shows how to add a child node for a given node, namely for the third child of the root node – that is, the node with a value equal to <code>150</code>. Here, only one node is added: the one with the value set to <code>30</code>. Of course, you need to specify a reference to the parent node, as well.</p>
<p>That’s all! You created the first program that uses trees. Now, you can run it, but you will not see any output in the console. If you want to see how the data of nodes is organized, you can debug the program and see the values of vari<a id="_idTextAnchor248"/><a id="_idTextAnchor249"/>ables while debugging.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor250"/>Example – company structure</h2>
<p>In the previous example, you saw<a id="_idIndexMarker623"/> how to use integer values as data stored in each node in a tree. However, it is also possible to store instances of user-defined classes in nodes. In this example, you will see how to create a tree presenting the structure of a company, divided into three main departments: development, research, and sales.</p>
<p>Within each department, there can be another structure, such as in the case of the development team. Here, <strong class="bold">John Smith</strong> is head of development. He is a boss for <strong class="bold">Chris Morris</strong>, who is a manager for two junior developers, <strong class="bold">Eric Green</strong> and <strong class="bold">Ashley Lopez</strong>. The latter is also a supervisor of <strong class="bold">Emily Young</strong>, who is a developer intern.</p>
<p>An example tree is shown in the following diagram:</p>
<div><div><img alt="Figure 7.3 – ﻿Illustration of the company structure example" src="img/B18069_07_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Illustration of the company structure example</p>
<p>As you can see, each node should store more information than just an integer value. There should be a name and a role. Such data is stored as values of properties in an instance of the <code>Person</code> record, which<a id="_idIndexMarker624"/> is shown next:</p>
<pre class="source-code">
public record <strong class="bold">Person</strong>(string Name, string Role);</pre> <p>Apart from creating a new record, it is also necessary to add some code:</p>
<pre class="source-code">
Tree&lt;Person&gt; company = new()
{
    Root = new()
    {
        Data = new Person("<strong class="bold">Marcin Jamro</strong>",
            "Chief Executive Officer"),
        Parent = null
    }
};
company.Root.Children =
[
    new() { Data = new Person("<strong class="bold">John Smith</strong>",
        "Head of Development"), Parent = company.Root },
    new() { Data = new Person("<strong class="bold">Alice Batman</strong>",
        "Head of Research"), Parent = company.Root },
    new() { Data = new Person("<strong class="bold">Lily Smith</strong>",
        "Head of Sales"), Parent = company.Root }
];
company.Root.Children[2].Children =
[
    new() { Data = new Person("<strong class="bold">Anthony Black</strong>",
        "Senior Sales Specialist"),
        Parent = company.Root.Children[2] }
];</pre> <p>In the first line, a new instance of the <code>Tree</code> class is created. It is worth mentioning that the <code>Person</code> record is used as a type specified while creating new instances of the <code>Tree</code> and <code>TreeNode</code> classes. Thus, you can easily store more than one simple data type for each node. The remaining lines of code look similar to the first example for basic trees. Here, you also specify the root node (for the <code>Chief Executive Officer</code> role), then configure its child elements (<code>John Smith</code>, <code>Alice Batman</code>, and <code>Lily Smith</code>), and set a child node for one of the existing nodes, namely the node for the <code>Head of </code><code>Sales</code> role.</p>
<p>Does it look simple and <a id="_idIndexMarker625"/>straightforward? In the next section, you will see a more restricted, but very important and well-known variant<a id="_idTextAnchor251"/> <a id="_idTextAnchor252"/>of trees: a binary tree.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor253"/>Binary trees</h1>
<p>Generally speaking, each node in a basic tree can <a id="_idIndexMarker626"/>contain any number of children. However, in the case of <strong class="bold">binary trees</strong>, <strong class="bold">a node cannot contain more than two children</strong>. It means that <strong class="bold">it can contain zero,</strong><em class="italic"> </em><strong class="bold">one, or two child nodes</strong>. Such a requirement has an important impact on the shape of a binary tree, as shown in the following two diagrams presenting binary trees:</p>
<div><div><img alt="Figure 7.4 – ﻿Illustration of binary trees" src="img/B18069_07_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Illustration of binary trees</p>
<p>As already mentioned, a node in<a id="_idIndexMarker627"/> a binary tree can contain at most two children. For this <a id="_idIndexMarker628"/>reason, they are referred to as the <strong class="bold">left child</strong> and the <strong class="bold">right child</strong>. In the case of the binary<a id="_idIndexMarker629"/> tree shown on the left-hand side of the preceding diagram, node <strong class="bold">21</strong> has two children, namely <strong class="bold">68</strong> as the left child and <strong class="bold">12</strong> as the right child, while node <strong class="bold">100</strong> has only a left child.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor254"/>Traversal</h2>
<p>Have you thought about <a id="_idIndexMarker630"/>how you can iterate through all the nodes in a tree? How can you specify an order of nodes during <strong class="bold">traversal</strong> of a tree? There are three common approaches, namely <strong class="bold">pre-order</strong>, <strong class="bold">in-order</strong>, and <strong class="bold">post-order</strong>, as shown next:</p>
<div><div><img alt="Figure 7.5 – Pre-order, in-order, and post-order traversal" src="img/B18069_07_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Pre-order, in-order, and post-order traversal</p>
<p>As you can see in the diagram, there are visible differences between the approaches. However, do you have <a id="_idIndexMarker631"/>any idea how you can apply pre-order, in-order, or post-order traversals for binary trees? Let’s explain all of these approaches in detail.</p>
<h3>Pre-order</h3>
<p>If you want to<a id="_idIndexMarker632"/> traverse a binary tree with the <strong class="bold">pre-order</strong> approach, you first visit the root node. Then, you visit the left child. Finally, the right child is visited. Of course, such a rule does not apply only to the root node, but to any node in a tree. For this reason, you can understand the order of pre-order traversal as <strong class="bold">first visiting the current node, then its left child (the whole left subtree using the pre-order approach recursively), and finally its right child (the right subtree in a </strong><strong class="bold">similar way)</strong>.</p>
<p>The explanation can sound a bit complicated, so let’s take a look at a simple example regarding the tree shown on the left of the preceding diagram. First, the root node (that is, <strong class="bold">1</strong>) is visited. Then, you analyze its left child node. For this reason, the next visited node is the current node, <strong class="bold">9</strong>. The next step is the pre-order traversal of its left child. Thus, <strong class="bold">5</strong> is visited. As this node does not contain any children, you can return to the stage of traversing when <strong class="bold">9</strong> is the current node. It has already been visited, as has its left child node, so it is time to proceed to its right child. Here, you first visit the current node, <strong class="bold">6</strong>, and follow to its left child, <strong class="bold">3</strong>. You can apply the same rules to continue traversing the tree. The final order is <strong class="bold">1</strong>, <strong class="bold">9</strong>, <strong class="bold">5</strong>, <strong class="bold">6</strong>, <strong class="bold">3</strong>, <strong class="bold">4</strong>, <strong class="bold">2</strong>, <strong class="bold">7</strong>, <strong class="bold">8</strong>.</p>
<p>If it still sounds a bit confusing, the<a id="_idIndexMarker633"/> following diagram should remove any doubts:</p>
<div><div><img alt="Figure 7.6 – Detailed diagram of pre-order traversal" src="img/B18069_07_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Detailed diagram of pre-order traversal</p>
<p>The diagram presents<a id="_idIndexMarker634"/> the following steps of the pre-order traversal with additional indicators: <strong class="bold">C</strong> for the <strong class="bold">current node</strong>, <strong class="bold">L</strong> for the <strong class="bold">left child</strong>, and <strong class="bold">R</strong> for the <strong class="bold">right child</strong>.</p>
<h3>In-order</h3>
<p>The second traversal mode is called <strong class="bold">in-order</strong>. It differs from the pre-order approach in the order that nodes are <a id="_idIndexMarker635"/>visited: <strong class="bold">the left child, the current node, and then the </strong><strong class="bold">right child</strong>.</p>
<p>If you take a look at the<a id="_idIndexMarker636"/> example shown in the diagram with all three traversal modes, you can see that the first visited node is <strong class="bold">5</strong>. Why? At the beginning, the root node is analyzed, but it is not visited because the in-order traversal starts with the left child node. Thus, it analyzes node <strong class="bold">9</strong>, but it also has a left child, <strong class="bold">5</strong>, so you proceed to this node. As this node does not have any children, the current node (<strong class="bold">5</strong>) is visited. Then, you return to the step when the current node is <strong class="bold">9</strong>, and, as its left child was already visited, you also visit the current node. Next, you follow to the right child, but it has a left child, <strong class="bold">3</strong>, which should be visited first. According to the same rules, you visit the remaining nodes in the binary tree. The final order is <strong class="bold">5</strong>, <strong class="bold">9</strong>, <strong class="bold">3</strong>, <strong class="bold">6</strong>, <strong class="bold">1</strong>, <strong class="bold">4</strong>, <strong class="bold">7</strong>, <strong class="bold">8</strong>, <strong class="bold">2</strong>.</p>
<h3>Post-order</h3>
<p>The last traversal mode is named <strong class="bold">post-order</strong> and supports the following order of node traversal: <strong class="bold">the left child, the right child, and then the </strong><strong class="bold">current node</strong>.</p>
<p>Let’s analyze the post-order<a id="_idIndexMarker637"/> example shown on the right-hand side of the diagram. At the beginning, the root node is analyzed but it is not visited because the post-order traversal starts with the left child node. Thus, you proceed to node <strong class="bold">9</strong>, then <strong class="bold">5</strong>, which you visit first. Next, you need to analyze the right child of node <strong class="bold">9</strong>. However, node <strong class="bold">6</strong> has the left child (<strong class="bold">3</strong>), which should be visited earlier. For this reason, after <strong class="bold">5</strong>, you visit <strong class="bold">3</strong>, and then <strong class="bold">6</strong>, followed by <strong class="bold">9</strong>. What is interesting is that the root node of the binary tree is visited at the end. The final order is <strong class="bold">5</strong>, <strong class="bold">3</strong>, <strong class="bold">6</strong>, <strong class="bold">9</strong>, <strong class="bold">8</strong>, <strong class="bold">7</strong>, <strong class="bold">2</strong>, <strong class="bold">4</strong>, <strong class="bold">1</strong>.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">If you want to check whether a binary tree contains a given value, you need to check each node, traversing the tree using one of three available modes: pre-order, in-order, or post-order. This means that the lookup time is linear, namely <em class="italic">O(n)</em>.</p>
<p>After this short introduction, let’s proce<a id="_idTextAnchor255"/>e<a id="_idTextAnchor256"/>d to the C#-based implementation.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor257"/>Implementation</h2>
<p>The implementation of a binary tree is simple, especially if you use the already d<a id="_idTextAnchor258"/>escribed code for the <a id="_idIndexMarker638"/>basic tree. Let’s start<a id="_idTextAnchor259"/> with a class representing a node.</p>
<h3>Node</h3>
<p>A node in a binary tree is represented by an instance of <code>BinaryTreeNode</code>, which inherits from the <code>TreeNode</code> generic class. In the <code>BinaryTreeNode</code> class, it is necessary to hide the <code>Children</code> definition<a id="_idIndexMarker639"/> from the base class, as well as declare two properties, <code>Left</code> and <code>Right</code>, which represent both possible children of a node. The relevant part of the code is as follows:</p>
<pre class="source-code">
public class <strong class="bold">BinaryTreeNode&lt;T&gt;</strong>
    : TreeNode&lt;T&gt;
{
    <strong class="bold">public new BinaryTreeNode&lt;T&gt;?[] Children { get; set; }</strong>
        <strong class="bold">= [null, null];</strong>
    public BinaryTreeNode&lt;T&gt;? <strong class="bold">Left</strong>
    {
        get { return Children[0]; }
        set { Children[0] = value; }
    }
    public BinaryTreeNode&lt;T&gt;? <strong class="bold">Right</strong>
    {
        get { return Children[1]; }
        set { Children[1] = value; }
    }
}</pre> <p>Moreover, you need to ensure that the array with child nodes contains exactly two items, initially set to <code>null</code>. Thus, if you want to add a child node, a reference to it should be placed as the first or the second element of the array from the <code>Children</code> property. Therefore, such an <a id="_idIndexMarker640"/>array always has exactly two elements, and <a id="_idIndexMarker641"/>you can access the first or the second one without any exception. If such an element is set to any node, a reference to it is <a id="_idTextAnchor260"/>r<a id="_idTextAnchor261"/>eturned. Otherwise, <code>null</code> is returned.</p>
<h3>Tree</h3>
<p>The next necessary class is <a id="_idIndexMarker642"/>named <code>BinaryTree</code>. It represents the whole binary tree. By using the generic class, you can easily specify the type of data stored in each node. The first part of the implementation of the <code>BinaryTree</code> class is as follows:</p>
<pre class="source-code">
public class <strong class="bold">BinaryTree&lt;T&gt;</strong>
{
    public BinaryTreeNode&lt;T&gt;? <strong class="bold">Root</strong> { get; set; }
    public int <strong class="bold">Count</strong> { get; set; }
}</pre> <p>The <code>BinaryTree</code> class contains two properties:</p>
<ul>
<li><code>Root</code> indicates the root node (instance of the <code>BinaryTreeNode</code> class)</li>
<li><code>Count</code> stores the total number of nodes placed in the tree</li>
</ul>
<p>Of course, these are not the only members of the class because it is also equipped with a set of methods regarding traversing the tree. The first traversal method is <code>TraversePreOrder</code> method is as follows:</p>
<pre class="source-code">
private void <strong class="bold">TraversePreOrder</strong>(BinaryTreeNode&lt;T&gt;? node,
    List&lt;BinaryTreeNode&lt;T&gt;&gt; result)
{
    if (node == null) { return; }
    <strong class="bold">result.Add(node);</strong>
    <strong class="bold">TraversePreOrder(node.Left, result);</strong>
    <strong class="bold">TraversePreOrder(node.Right, result);</strong>
}</pre> <p>The method takes two parameters: the current node (<code>node</code>) and the list of already visited nodes (<code>result</code>). The recursive implementation is very simple. First, you check whether the node exists by ensuring that the parameter is not equal to <code>null</code>. Then, you add the current node to the collection <a id="_idIndexMarker643"/>of visited nodes, start the same traversal method for the left child, and then start it for the right child.</p>
<p>Similar implementation is possible for the <code>TraverseInOrder</code> method, as follows:</p>
<pre class="source-code">
private void <strong class="bold">TraverseInOrder</strong>(BinaryTreeNode&lt;T&gt;? node,
    List&lt;BinaryTreeNode&lt;T&gt;&gt; result)
{
    if (node == null) { return; }
    <strong class="bold">TraverseInOrder(node.Left, result);</strong>
    <strong class="bold">result.Add(node);</strong>
    <strong class="bold">TraverseInOrder(node.Right, result);</strong>
}</pre> <p>Here, you call the <code>TraverseInOrder</code> method for the left child, add the current node to the list of visited nodes, and start the in-order traversal for the right child.</p>
<p>The next method is related to the <strong class="bold">post-order</strong> traversal mode, as follows:</p>
<pre class="source-code">
private void <strong class="bold">TraversePostOrder</strong>(BinaryTreeNode&lt;T&gt;? node,
    List&lt;BinaryTreeNode&lt;T&gt;&gt; result)
{
    if (node == null) { return; }
    <strong class="bold">TraversePostOrder(node.Left, result);</strong>
    <strong class="bold">TraversePostOrder(node.Right, result);</strong>
    <strong class="bold">result.Add(node);</strong>
}</pre> <p>The code is similar to the already described methods, but, of course, another order of visiting nodes is applied. Here, you start with the left child, then you visit the right child, followed by adding the current <a id="_idIndexMarker644"/>node to the list of visited nodes.</p>
<p>Finally, let’s add a public method for traversing the tree in various modes, which calls the private methods presented earlier. The relevant code is as follows:</p>
<pre class="source-code">
public List&lt;BinaryTreeNode&lt;T&gt;&gt; <strong class="bold">Traverse</strong>(TraversalEnum mode)
{
    List&lt;BinaryTreeNode&lt;T&gt;&gt; nodes = [];
    if (Root == null) { return nodes; }
    switch (mode)
    {
        case TraversalEnum.PreOrder:
            <strong class="bold">TraversePreOrder</strong>(Root, nodes);
            break;
        case TraversalEnum.InOrder:
            <strong class="bold">TraverseInOrder</strong>(Root, nodes);
            break;
        case TraversalEnum.PostOrder:
            <strong class="bold">TraversePostOrder</strong>(Root, nodes);
            break;
    }
    return nodes;
}</pre> <p>The method takes only one parameter, namely a value of the <code>TraversalEnum</code> enumeration, which chooses the proper mode from pre-order, in-order, and post-order. The <code>Traverse</code> method uses a <code>switch</code> statement to call a suitable private method, depending on the value of the parameter. The <a id="_idIndexMarker645"/>mentioned enumeration is as follows:</p>
<pre class="source-code">
public enum <code>BinaryTree</code> class is <code>GetHeight</code>. It returns the height of the tree, which can be understood as the maximum number of steps to travel from any leaf node to the root. The implementation is as follows:</p>
<pre class="source-code">
public int <strong class="bold">GetHeight</strong>() =&gt; Root != null
    ? Traverse(TraversalEnum.PreOrder)
        .Max(n =&gt; n.GetHeight())
    : 0;</pre> <p>After the introduction to the topic of binary trees, let’s see an example where this data structure is used for stori<a id="_idTextAnchor262"/>n<a id="_idTextAnchor263"/>g questions and answers in a simple quiz.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor264"/>Example – simple quiz</h2>
<p>As an example of a binary tree, a simple quiz application will be prepared. The quiz consists of a few questions and <a id="_idIndexMarker646"/>answers, shown depending on previously taken decisions. The application presents the question, waits until the user presses <em class="italic">Y</em> (yes) or <em class="italic">N</em> (no), and proceeds to the next question or shows the answer.</p>
<p>The structure of the quiz is created in the form of a binary tree, as follows:</p>
<div><div><img alt="Figure 7.7 – ﻿Illustration of the simple quiz example" src="img/B18069_07_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Illustration of the simple quiz example</p>
<p>At the beginning, the user is asked whether they have any experience in application development. If so, the program asks whether they have worked as a developer for more than 5 years. In the case of a positive answer, the result regarding applying to work as a senior developer is <a id="_idIndexMarker647"/>presented. Of course, other answers and questions are shown in the case of different decisions taken by the user.</p>
<p>The implementation of the simple quiz requires the <code>BinaryTree</code> and <code>BinaryTreeNode</code> classes, which were presented and explained earlier. Each node stores only a <code>string</code> value as data, representing either a question or an answer.</p>
<p>Let’s take a look at the main part of the code:</p>
<pre class="source-code">
BinaryTree&lt;string&gt; tree = GetTree();
BinaryTreeNode&lt;string&gt;? node = tree.Root;
while (<strong class="bold">node != null</strong>)
{
    if (<strong class="bold">node.Left != null &amp;&amp; node.Right != null</strong>)
    {
        Console.WriteLine(<strong class="bold">node.Data</strong>);
        node = Console.ReadKey(true).Key switch
        {
            ConsoleKey.Y =&gt; <strong class="bold">node.Left</strong>,
            ConsoleKey.N =&gt; <strong class="bold">node.Right</strong>,
            _ =&gt; node
        };
    }
    else
    {
        Console.WriteLine(<strong class="bold">node.Data</strong>);
        node = null;
    }
}</pre> <p>In the first line, the <code>GetTree</code> method is called to construct a tree with questions and answers. Such a method will be shown next. Then, the root node is taken as the current node, for which the following operations are taken until an answer is reached.</p>
<p>At the beginning, you check whether<a id="_idIndexMarker648"/> the left and right child nodes exist – that is, whether it is a question and not an answer. Then, the textual content is written in the console, and the program waits until the user presses a key. If it is equal to <em class="italic">Y</em>, the current node’s left child is used as the current node. In the case of pressing <em class="italic">N</em>, the current node’s right child is used instead.</p>
<p>When decisions taken by the user cause an answer to be shown, it is presented in the console, and <code>null</code> is assigned to the <code>node</code> variable. Therefore, you break out of the <code>while</code> loop.</p>
<p>As mentioned, the <code>GetTree</code> method is used to construct a binary tree with questions and answers. Its code is presented <a id="_idIndexMarker649"/>as follows:</p>
<pre class="source-code">
BinaryTree&lt;string&gt; <strong class="bold">GetTree</strong>()
{
    BinaryTree&lt;string&gt; tree = new();
    tree.Root = new BinaryTreeNode&lt;string&gt;()
    {
        Data = "<strong class="bold">Do you have an experience</strong>
            <strong class="bold">in app development?</strong>",
        Children =
        [
            new BinaryTreeNode&lt;string&gt;()
            {
                Data = "<strong class="bold">Have you worked as a developer</strong>
                    <strong class="bold">for 5+ years?</strong>",
                Children =
                [
                    new() { Data = "<strong class="bold">Apply as</strong>
                        <strong class="bold">a senior developer</strong>" },
                    new() { Data = "<strong class="bold">Apply as</strong>
                        <strong class="bold">a middle developer</strong>" }
                ]
            },
            new BinaryTreeNode&lt;string&gt;()
            {
                Data = "<strong class="bold">Have you completed a university?</strong>",
                Children =
                [
                    new() { Data = "<strong class="bold">Apply as</strong>
                        <strong class="bold">a junior developer</strong>" },
                    new BinaryTreeNode&lt;string&gt;()
                    {
                        Data = "<strong class="bold">Will you find some time</strong>
                            <strong class="bold">during the semester?</strong>",
                        Children =
                        [
                            new() { Data = "<strong class="bold">Apply for</strong>
                                <strong class="bold">long-time internship</strong>" },
                            new() { Data = "<strong class="bold">Apply for</strong>
                                <strong class="bold">summer internship</strong>" }
                        ]
                    }
                ]
            }
        ]
    };
    tree.Count = 9;
    return tree;
}</pre> <p>At the beginning, a new instance of the <code>BinaryTree</code> generic class is created, and you assign a new instance of <code>BinaryTreeNode</code> to the <code>Root</code> property.</p>
<p>What is interesting is that even while creating questions and answers programmatically, you create some kind of a tree-like structure because you use the <code>Children</code> property and specify items directly within such constructions. Therefore, you do not need to create many local variables for all questions and answers. It is worth noting that a question-related node is an<a id="_idIndexMarker650"/> instance of the <code>BinaryTreeNode</code> class with two child nodes (for <em class="italic">yes</em> and <em class="italic">no</em> decisions), while an answer-related node is a leaf, so it does not contain any child nodes.</p>
<p class="callout-heading">Important note</p>
<p class="callout">In the presented solution, the values of the <code>Parent</code> property of the <code>BinaryTreeNode</code> instances are not set. If you want to use them or get the height of a node or a tree, you should set them on your own.</p>
<p>The simple quiz application is ready! You can build the project, launch it, and answer a few questions to see the results. Then, let’s close the program and proceed to the next section, where a variant o<a id="_idTextAnchor265"/>f<a id="_idTextAnchor266"/> the binary tree data structure is presented.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor267"/>Binary search trees</h1>
<p>A binary tree is an interesting data structure that allows the creation of a hierarchy of elements, with the restriction that each node can contain at most two children, but without any rules about relationships <a id="_idIndexMarker651"/>between the nodes. For this reason, if you want to check whether a binary tree contains a given value, you need to check each node, traversing the tree using one of three available modes: pre-order, in-order, or post-order. This means that the lookup time is linear, namely <em class="italic">O(n)</em>.</p>
<p>What about a situation where there are some precise rules regarding relations between nodes in a tree? Let’s imagine a scenario where you know that the left subtree contains nodes with values smaller than the root’s value, while the right subtree contains nodes with values greater than the root’s value. Then, you can compare the searched value with the current node and decide whether you should continue searching in the left or right subtree. Such an approach can significantly limit the number of operations necessary to check whether the tree contains a given value. It seems quite interesting, doesn’t it?</p>
<p>This approach is applied in the <strong class="bold">binary search tree (BST)</strong> data structure. It is a kind of binary tree that introduces two strict rules regarding<a id="_idIndexMarker652"/> relations between nodes in the tree. <strong class="bold">The rules state that for any node, the values of all nodes in its left subtree must be smaller than its value, and the values of all nodes in its right subtree must be greater than </strong><strong class="bold">its value.</strong></p>
<p class="callout-heading">Can you add duplicates to BSTs?</p>
<p class="callout">In general, a BST can contain two or<a id="_idIndexMarker653"/> more elements with the same value. However, within this book, a simplified version is given, which does not accept more than one element with the same value.</p>
<p>How does it look in practice? Let’s take a look at the following diagram of BSTs:</p>
<div><div><img alt="Figure 7.8 – ﻿Illustration of binary search trees." src="img/B18069_07_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Illustration of binary search trees.</p>
<p>The tree shown on the left-hand side contains 12 nodes. Let’s check whether it complies with the BST rule. You can do so by analyzing each node in the tree, except leaf nodes. Let’s start with the root node (with value <strong class="bold">50</strong>), which contains four descendant nodes in the left subtree (<strong class="bold">40</strong>, <strong class="bold">30</strong>, <strong class="bold">45</strong>, <strong class="bold">43</strong>), all smaller than <strong class="bold">50</strong>. The root node contains seven descendant nodes in the right subtree (<strong class="bold">60</strong>, <strong class="bold">80</strong>, <strong class="bold">70</strong>, <strong class="bold">65</strong>, <strong class="bold">75</strong>, <strong class="bold">90</strong>, <strong class="bold">100</strong>), all greater than <strong class="bold">50</strong>. That means that the BST rule is satisfied for the root node. While checking the BST rule for node <strong class="bold">80</strong>, you see that the values of all descendant nodes in the left subtree (<strong class="bold">70</strong>, <strong class="bold">65</strong>, <strong class="bold">75</strong>) are smaller than <strong class="bold">80</strong>, while the values in the right subtree (<strong class="bold">90</strong>, <strong class="bold">100</strong>) are greater than <strong class="bold">80</strong>. You should perform the same verification for all other nodes. Similarly, you can confirm that the BST from the right-hand side of the diagram adheres to the rules.</p>
<p>However, two such BSTs<a id="_idIndexMarker654"/> significantly differ in their <strong class="bold">topology</strong>. Both have the same height, but the number of nodes is different, namely 12 and 7. The one on the left seems to be <strong class="bold">fat</strong>, while the other is rather <strong class="bold">skinny</strong>. Which one is better? To answer this question, let’s think about the algorithm for searching a value in the tree. As an example, the process of searching for the value <strong class="bold">43</strong> is shown in the following diagram:</p>
<div><div><img alt="Figure 7.9 – Searching for a given value in a BST" src="img/B18069_07_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Searching for a given value in a BST</p>
<p>At the beginning (<strong class="bold">Step 1</strong>), you take a value of the root node (that is, <strong class="bold">50</strong>) and check whether the given value (<strong class="bold">43</strong>) is smaller <a id="_idIndexMarker655"/>or greater. It is smaller, so you proceed to search in the left subtree (<strong class="bold">Step 2</strong>). Thus, you compare <strong class="bold">43</strong> with <strong class="bold">40</strong>. This time, the right subtree is chosen because <strong class="bold">43</strong> is greater than <strong class="bold">40</strong>. Next, <strong class="bold">43</strong> is compared with <strong class="bold">45</strong> (<strong class="bold">Step 3</strong>), and the left subtree is chosen. Here, you compare <strong class="bold">43</strong> with <strong class="bold">43</strong>, and the given value is found (<strong class="bold">Step 4</strong>). If you take a look at the tree, you will see that only four comparisons are necessary.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">The shape of a tree has a great impact on the lookup performance. Of course, <strong class="bold">it is much better to have a fat tree with limited height than a skinny tree with a bigger height</strong>. The performance boost is caused by making decisions as to whether searching should be continued in the left or right subtree, without the necessity of analyzing the values of all nodes. If nodes do not have both subtrees, the positive impact on the performance will be limited. In the worst case, when <a id="_idIndexMarker656"/>each node contains only one child, the search time is even linear. However, in the ideal BST, the lookup time is an <em class="italic">O(log </em><em class="italic">n)</em> operation.</p>
<p>After this short introduction, let’s proceed to the implementation in the C# language. At the end, you will see an example that<a id="_idTextAnchor268"/> <a id="_idTextAnchor269"/>shows how to use this data structure in practice.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor270"/>Implementation</h2>
<p>The implementation of a BST is a bit more difficult than the previously described variants of trees. For example, it requires <a id="_idIndexMarker657"/>you to prepare operations of insertion and removal of nodes from a tree, which do not break the rule<a id="_idTextAnchor271"/> regarding the arrangement of ele<a id="_idTextAnchor272"/>ments in the BST. You will see a solution shortly.</p>
<h3>Tree</h3>
<p>The whole tree is represented by an instance of the <code>BinarySearchTree</code> class, which inherits from the <code>BinaryTree</code> generic class, as in<a id="_idIndexMarker658"/> the following code snippet:</p>
<pre class="source-code">
public class <strong class="bold">BinarySearchTree&lt;T&gt;</strong>
    : <strong class="bold">BinaryTree&lt;T&gt;</strong>
    where T : <strong class="bold">IComparable</strong>
{
}</pre> <p>It is worth mentioning that the type of data, stored in each node, should be comparable. For this reason, it has to implement the <code>IComparable</code> interface. Such a requirement is necessary because the algorithm needs to know the relationships between values.</p>
<p>Of course, it is not the final version of the implementation of the <code>BinarySearchTree</code> class. You will very soon learn how to add new featu<a id="_idTextAnchor273"/>re<a id="_idTextAnchor274"/>s, such as lookup, insertion, and <a id="_idIndexMarker659"/>removal of nodes.</p>
<h3>Lookup</h3>
<p>Now, let’s take a look at the <code>Contains</code> method, which checks whether the tree contains a node with a given value. Of course, this method takes into account the BST rule regarding the arrangement of <a id="_idIndexMarker660"/>nodes to limit the number of comparisons. The code is presented in the following block:</p>
<pre class="source-code">
public bool <strong class="bold">Contains</strong>(T data)
{
    BinaryTreeNode&lt;T&gt;? node = Root;
    while (<strong class="bold">node != null</strong>)
    {
        int result = data.CompareTo(node.Data);
        if (result == 0) { <strong class="bold">return true;</strong> }
        else if (result &lt; 0) { <strong class="bold">node = node.Left;</strong> }
        else { <strong class="bold">node = node.Right;</strong> }
    }
    return false;
}</pre> <p>The method takes only one parameter, namely the value to find in the tree. Inside the method, a <code>while</code> loop exists. Within it, the searched value is compared with the value of the current node. If they are equal (the comparison returns <code>0</code>), the value is found, and <code>true</code> is returned to inform that the search is completed successfully. If the searched value is smaller than the value of the current node, the algorithm continues searching in the left subtree. Otherwise, the right subtree is used instead.</p>
<p class="callout-heading">How to compare objects?</p>
<p class="callout">The <code>CompareTo</code> method is provided by the implementation of the <code>IComparable</code> interface from the <code>System</code> namespace. Such a method makes it possible to compare two values. If they are equal, <code>0</code> is returned. If the object on which the method is called is bigger than the parameter, a value higher than <code>0</code> is returned. Otherwise, a value lower than <code>0</code> is returned.</p>
<p>The loop is executed<a id="_idIndexMarker661"/> until the node<a id="_idTextAnchor275"/> <a id="_idTextAnchor276"/>is found or there is no suitable child node to follow.</p>
<h3>Insertion</h3>
<p>The next necessary operation is the insertion of a node into a BST. Such a task is a bit more complicated because you <a id="_idIndexMarker662"/>need to find a place for adding a new element that will not violate BST rules. Let’s take a look at the code of the <code>Add</code> method:</p>
<pre class="source-code">
public void <strong class="bold">Add</strong>(T data)
{
    BinaryTreeNode&lt;T&gt;? parent = GetParentForNewNode(data);
    BinaryTreeNode&lt;T&gt; node = new()
    {
        Data = data,
        Parent = parent
    };
    if (parent == null)
    {
        <strong class="bold">Root = node;</strong>
    }
    else if (data.CompareTo(parent.Data) &lt; 0)
    {
        <strong class="bold">parent.Left = node;</strong>
    }
    else
    {
        <strong class="bold">parent.Right = node;</strong>
    }
    Count++;
}</pre> <p>The method takes one parameter, namely a value that should be added to the tree. Within the method, you find a parent element (using the <code>GetParentForNewNode</code> auxiliary method, shown a bit later), where <a id="_idIndexMarker663"/>a new node should be added as a child. Then, a new instance of the <code>BinaryTreeNode</code> class is created, and the values of its <code>Data</code> and <code>Parent</code> properties are set.</p>
<p>In the following part of the method, you check whether the found parent element is equal to <code>null</code>. It means that there are no nodes in the tree, and a new node should be added as the root, which is well visible in the line, where a reference to the node is assigned to the <code>Root</code> property.</p>
<p>The next comparison checks whether the value for addition is smaller than the value of the parent node. In such a case, a new node should be added as the left child of the parent node. Otherwise, the new node is placed as the right child of the parent node. At the end, the number of elements stored in the tree is incremented.</p>
<p>Let’s take a look at the auxiliary method for finding the parent element for a new node:</p>
<pre class="source-code">
private BinaryTreeNode&lt;T&gt;? <strong class="bold">GetParentForNewNode</strong>(T data)
{
    BinaryTreeNode&lt;T&gt;? current = Root;
    BinaryTreeNode&lt;T&gt;? parent = null;
    while (<strong class="bold">current != null</strong>)
    {
        <strong class="bold">parent = current;</strong>
        int result = data.CompareTo(current.Data);
        if (result == 0) { throw new ArgumentException(
            $"The node {data} already exists."); }
        else if (result &lt; 0) { <strong class="bold">current = current.Left;</strong> }
        else { current = <strong class="bold">current.Right;</strong> }
    }
    return <strong class="bold">parent</strong>;
}</pre> <p>This method takes one parameter, namely a value of the new node. Within this method, you declare two variables representing the currently analyzed node (<code>current</code>) and the parent node (<code>parent</code>). Such values <a id="_idIndexMarker664"/>are modified in a <code>while</code> loop until the algorithm finds a proper place for the new node.</p>
<p>In the loop, you store a reference to the current node as the potential parent node. Then, you check whether the value for addition is equal to the value of the current node. If so, an exception is thrown because it is not allowed to add more than one element with the same value to the analyzed version of the BST. If the value for addition is smaller than the value of the current node, the algorithm continues searching for a place for the new node in the left subtree. Otherwise, the right subtree of the current node is used. At the end, the value of the <code>parent</code> variable is<a id="_idTextAnchor277"/> <a id="_idTextAnchor278"/>returned to indicate the found location for the new node.</p>
<h3>Removal</h3>
<p>You now know how to create a new BST, add some nodes to it, as well as check whether a given value already exists in the tree. However, can you also remove an item from a tree? Of course! The main method<a id="_idIndexMarker665"/> regarding the removal of a node from the tree is named <code>Remove</code> and takes only one parameter, namely the value of the node that should be removed. The implementation of the <code>Remove</code> method is as follows:</p>
<pre class="source-code">
public void <code>Remove</code>. The implementation of this private<a id="_idIndexMarker666"/> method is more complicated and is as follows:</p>
<pre class="source-code">
private void <strong class="bold">Remove</strong>(BinaryTreeNode&lt;T&gt;? node, T data)
{
    if (node == null)
    {
        return;
    }
    else if (data.CompareTo(node.Data) &lt; 0)
    {
        <strong class="bold">Remove(node.Left, data);</strong>
    }
    else if (data.CompareTo(node.Data) &gt; 0)
    {
        <strong class="bold">Remove(node.Right, data);</strong>
    }
    else
    {
        if (node.Left == null || node.Right == null)
        {
            BinaryTreeNode&lt;T&gt;? newNode =
                node.Left == null &amp;&amp; node.Right == null
                    ? null
                    : node.Left ?? node.Right;
            <strong class="bold">ReplaceInParent(node, newNode!);</strong>
            Count--;
        }
        else
        {
            BinaryTreeNode&lt;T&gt; successor =
                <strong class="bold">FindMinimumInSubtree(node.Right);</strong>
            node.Data = successor.Data;
            <strong class="bold">Remove(successor, successor.Data!);</strong>
        }
    }
}</pre> <p>At the beginning, the method checks whether the current node (the <code>node</code> parameter) exists. If not, you exit from the<a id="_idIndexMarker667"/> method.</p>
<p>Then, the <code>Remove</code> method tries to find the node to remove. That is achieved by comparing the value of the current node with the value for removal and calling the <code>Remove</code> method recursively for either the left or right subtree of the current node.</p>
<p>The most interesting operations are performed in the following part of the method. Here, you need to handle four scenarios of node removal, namely the following:</p>
<ul>
<li>Removing a leaf node</li>
<li>Removing a node with only a left child</li>
<li>Removing a node with only a right child</li>
<li>Removing a node with both left and right children</li>
</ul>
<p>In the case of <strong class="bold">removing a leaf node</strong>, you just update a reference to the deleted node in the parent element. Therefore, there will be no reference from the parent node to the deleted node, and it cannot be reached while traversing the tree.</p>
<p><strong class="bold">Removing a node with only a left child</strong> is also simple because you only need to replace a reference to the deleted node (in the parent element) with the node that is a left child of the deleted node. This scenario is shown in the following diagram, which presents how to remove node <strong class="bold">80</strong> with only the left child:</p>
<div><div><img alt="Figure 7.10 – Removing a node with only a left child from a BST" src="img/B18069_07_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Removing a node with only a left child from a BST</p>
<p>The case of <strong class="bold">removing a node with only a right child </strong>is very similar to the second case. Thus, you just replace a reference to the deleted node (in the parent element) with the node that is a right child of the <a id="_idIndexMarker668"/>deleted node.</p>
<p>All those three cases are handled in the code in a similar way, by calling the <code>ReplaceInParent</code> auxiliary method, the code of which is as follows:</p>
<pre class="source-code">
private void <strong class="bold">ReplaceInParent</strong>(BinaryTreeNode&lt;T&gt; node,
    BinaryTreeNode&lt;T&gt; newNode)
{
    if (node.Parent != null)
    {
        BinaryTreeNode&lt;T&gt; parent =
            (BinaryTreeNode&lt;T&gt;)node.Parent;
        if (parent.Left == node) { <strong class="bold">parent.Left = newNode;</strong> }
        else { <strong class="bold">parent.Right = newNode;</strong> }
    }
    else { <strong class="bold">Root = newNode;</strong> }
    if (newNode != null) { <strong class="bold">newNode.Parent = node.Parent;</strong> }
}</pre> <p>The method takes two parameters: the node for removal (<code>node</code>) and the node that should replace it in the parent <a id="_idIndexMarker669"/>node (<code>newNode</code>). For this reason, if you want to remove a leaf node, you just pass <code>null</code> as the second parameter because you do not want to replace the removed node with anything else. In the case of removing a node with only one child, you pass a reference to the left or right child.</p>
<p>If the node for removal is not the root, you check whether it is the left child of the parent. If so, a proper reference is updated. It means that the new node is set as the left child of the parent node of the node for removal. In a similar way, the method handles the scenario when the node for removal is the right child of the parent. If the node for removal is the root, the node for replacing is set as the root. At the end, you check whether the new node is not equal to <code>null</code>. It means that you are not removing a leaf node. In such a case, you set a value of the <code>Parent</code> property to indicate that the new node should have the same parent as the node for removal.</p>
<p>A bit more complicated scenario is <code>Remove</code> method recursively for the found node. The relevant part of the code is shown in the following code snippet, copied here from the <code>Remove</code> private method for your convenience:</p>
<pre class="source-code">
BinaryTreeNode&lt;T&gt; successor =
    FindMinimumInSubtree(node.Right);
node.Data = successor.Data;
Remove(successor, successor.Data!);</pre> <p>The last auxiliary method is named <code>FindMinimumInSubtree</code> and is as follows:</p>
<pre class="source-code">
private BinaryTreeNode&lt;T&gt; <strong class="bold">FindMinimumInSubtree</strong>(
    BinaryTreeNode&lt;T&gt; node)
{
    while (<strong class="bold">node.Left != null</strong>) { <strong class="bold">node = node.Left;</strong> }
    return node;
}</pre> <p>The method takes the root of <a id="_idIndexMarker670"/>the subtree, where the minimum value should be found, as the parameter. Within the method, a <code>while</code> loop is used to get the leftmost element. When there is no left child, the current value of the <code>node</code> variable is returned.</p>
<p class="callout-heading">Where you can find more information?</p>
<p class="callout">There is a lot of information about BSTs in books, research papers, as well as over the internet. Howe<a href="https://en.wikipedia.org/wiki/Binary_search_tree">ver, the presented implementation of a BST is ba</a>sed on the code shown at https://en.wikipedia.org/wiki/Binary_search_tree, where you can also find more information about this data structure. I strongly <a id="_idIndexMarker671"/>encourage you to be curious about various data structures and algorithms and to broaden your knowledge.</p>
<p>The preceding code does not look very difficult, does it? However, how does it work in practice? Let’s take a look at a diagram depicting the removal of a node with two children:</p>
<div><div><img alt="Figure 7.11 – Removing a node with two children in a BST" src="img/B18069_07_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Removing a node with two children in a BST</p>
<p>The diagram shows how to remove the node with <strong class="bold">40</strong> as the value. To do so, you need to find the successor. It is the node with the minimum value in the right subtree of the node<a id="_idTextAnchor279"/> <a id="_idTextAnchor280"/>for removal. The successor is <a id="_idIndexMarker672"/>node <strong class="bold">42</strong>, which replaces node <strong class="bold">40</strong>.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor281"/>Example – BST visualization</h2>
<p>While reading the section <a id="_idIndexMarker673"/>regarding BSTs, you learned a lot about this data structure. So, it is high time to create an example program to see this variant of trees in action. The application will show you how to create a BST, add some nodes (both manually and using the previously presented method for insertion), remove nodes, traverse the tree, as well as visualize the tree in the console.</p>
<p>At the beginning, a new tree (with nodes storing integer values) is prepared by creating a new instance of the <code>BinarySearchTree</code> class. It is configured manually by adding three nodes, together with indicating proper references for children and parent elements. The relevant part of the <a id="_idIndexMarker674"/>code is as follows:</p>
<pre class="source-code">
BinarySearchTree&lt;int&gt; tree = new();
tree.Root = new BinaryTreeNode&lt;int&gt;() { Data = <strong class="bold">100</strong> };
tree.Root.Left = new() { Data = <strong class="bold">50</strong>, Parent = tree.Root };
tree.Root.Right = new() { Data = <strong class="bold">150</strong>, Parent = tree.Root };
tree.Count = 3;
Visualize(tree, "BST with 3 nodes (50, 100, 150):");</pre> <p>Then, you use the <code>Add</code> method to add some nodes to the tree and visualize the current state of the tree using the <code>Visualize</code> method, as follows:</p>
<pre class="source-code">
tree.Add(<strong class="bold">75</strong>);
tree.Add(<strong class="bold">125</strong>);
Visualize(tree, "BST after adding 2 nodes (75, 125):");</pre> <p>Let’s add five more nodes with the following code:</p>
<pre class="source-code">
tree.Add(<strong class="bold">25</strong>);
tree.Add(<strong class="bold">175</strong>);
tree.Add(<strong class="bold">90</strong>);
tree.Add(<strong class="bold">110</strong>);
tree.Add(<strong class="bold">135</strong>);
Visualize(tree, "BST after adding 5 nodes
    (25, 175, 90, 110, 135):");</pre> <p>The next set of operations is related to the removal of various nodes from the tree, together with visualization of particular changes. The part of the code is as follows:</p>
<pre class="source-code">
tree.Remove(<strong class="bold">25</strong>);
Visualize(tree, "BST after removing the node 25:");
tree.Remove(<strong class="bold">50</strong>);
Visualize(tree, "BST after removing the node 50:");
tree.Remove(<strong class="bold">100</strong>);
Visualize(tree, "BST after removing the node 100:");</pre> <p>At the end, all three traversal<a id="_idIndexMarker675"/> modes are presented. The suitable code is as follows:</p>
<pre class="source-code">
foreach (TraversalEnum mode
    in Enum.GetValues&lt;TraversalEnum&gt;())
{
    Console.Write($"\n{mode} traversal:\t");
    Console.Write(string.Join(", ",
        tree.Traverse(mode).Select(n =&gt; n.Data)));
}</pre> <p>Another interesting task is the development of a tree visualization in the console. Such a feature is really useful because it allows a comfortable and fast way of observing the tree without the necessity of debugging the application in the IDE and expanding the following elements in the tooltip with the current values of variables. However, presenting a tree in the console is not a trivial task. Fortunately, you do not need to worry about it because you will learn how to implement such a feature in this section.</p>
<p>First, let’s take a look at the <code>Visualize</code> method:</p>
<pre class="source-code">
void <strong class="bold">Visualize</strong>(BinarySearchTree&lt;int&gt; tree, string caption)
{
    char[,] console = Initialize(tree, out int width);
    VisualizeNode(tree.Root, 0, width / 2,
        console, width);
    Console.WriteLine(caption);
    Draw(console);
}</pre> <p>The method takes two parameters, namely an instance of the <code>BinarySearchTree</code> class representing the whole tree, and a caption that should be shown above the visualization. Within the method, an<a id="_idIndexMarker676"/> array with characters that should be presented in the console is initialized using the <code>Initialize</code> auxiliary method, shown a bit later. Then, you call the <code>VisualizeNode</code> recursive method to fill various parts of the array with data regarding particular nodes existing in the tree. At the end, the caption and the board (represented by the array) are written in the console.</p>
<p>The <code>Initialize</code> method creates the aforementioned array, as presented in the following code snippet:</p>
<pre class="source-code">
const int <strong class="bold">ColumnWidth</strong> = 5;
char[,] <strong class="bold">Initialize</strong>(BinarySearchTree&lt;int&gt; tree,
    out int width)
{
    int height = tree.GetHeight();
    width = (int)Math.Pow(2, height) - 1;
    char[,] console =
        new char[height * 2, ColumnWidth * width];
    for (int y = 0; y &lt; console.GetLength(0); y++)
    {
        for (int x = 0; x &lt; console.GetLength(1); x++)
        {
            console[y, x] = ' ';
        }
    }
    return console;
}</pre> <p>The two-dimensional array contains the number of rows equal to the height of the tree multiplied by <code>2</code> to have space also for lines connecting nodes with parents. The number of columns is calculated according to<a id="_idIndexMarker677"/> the formula <em class="italic">columnwidth</em> * 2height - 1, where <em class="italic">columnwidth</em> is the <code>ColumnWidth</code> constant value and <em class="italic">height</em> is the height of the tree.</p>
<p>These values can be simpler to understand if you take a look at the result:</p>
<div><div><img alt="Figure 7.12 – ﻿Screenshot of the BST visualization example" src="img/B18069_07_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Screenshot of the BST visualization example</p>
<p>In the <code>Visualize</code> method, <code>VisualizeNode</code> is called. Are you interested to learn about how it works and how you can present not only the values of nodes but also lines? If so, let’s take a look at its code, which is as follows:</p>
<pre class="source-code">
void <strong class="bold">VisualizeNode</strong>(BinaryTreeNode&lt;int&gt;? node, int row,
    int column, char[,] console, int width)
{
    if (node == null) { return; }
    char[] chars = node.Data.ToString().ToCharArray();
    int margin = (ColumnWidth - chars.Length) / 2;
    for (int i = 0; i &lt; chars.Length; i++)
    {
        int col = ColumnWidth * column + i + margin;
        console[row, col] = chars[i];
    }
    int columnDelta = (width + 1) /
        (int)Math.Pow(2, node.GetHeight() + 1);
    <strong class="bold">VisualizeNode(node.Left, row + 2,</strong>
        <strong class="bold">column - columnDelta, console, width);</strong>
    <strong class="bold">VisualizeNode(node.Right, row + 2,</strong>
        <strong class="bold">column + columnDelta, console, width);</strong>
    DrawLineLeft(node, row, column, console, columnDelta);
    DrawLineRight(node, row, column, console, columnDelta);
}</pre> <p>The <code>VisualizeNode</code> method takes five parameters, including the current node for visualization (<code>node</code>), the index of a row (<code>row</code>), and the index of a column (<code>column</code>). Within the method, there is a<a id="_idIndexMarker678"/> check for whether the current node exists. If it does, the value of the node is obtained as a <code>char</code> array, the margin is calculated, and the <code>char</code> array (with a character-based representation of the value) is written in the buffer (the <code>console</code> variable) within a <code>for</code> loop.</p>
<p>In the following lines of code, the <code>VisualizeNode</code> method is called for the left and right child nodes of the current node. Of course, you need to adjust the index of the row (by adding <code>2</code>) and the index of the column (by adding or subtracting the calculated value).</p>
<p>At the end, lines are drawn by calling the <code>DrawLineLeft</code> and <code>DrawLineRight</code> methods. The first is presented in the following code snippet:</p>
<pre class="source-code">
void <strong class="bold">DrawLineLeft</strong>(BinaryTreeNode&lt;int&gt; node, int row,
    int column, char[,] console, int columnDelta)
{
    if (node.Left == null) { return; }
    int sci = ColumnWidth * (column - columnDelta) + 2;
    int eci = ColumnWidth * column + 2;
    for (int x = sci + 1; x &lt; eci; x++)
    {
        console[row + 1, x] = '-';
    }
    console[row + 1, sci] = '+';
    console[row + 1, eci] = '+';
}</pre> <p>The method also takes five parameters:</p>
<ul>
<li>The current node for which the line should be drawn (<code>node</code>)</li>
<li>The index of a row (<code>row</code>)</li>
<li>The index of a column (<code>column</code>)</li>
<li>An array as a screen buffer (<code>console</code>)</li>
<li>A delta value calculated in the <code>VisualizeNode</code> method</li>
</ul>
<p>At the beginning, you check whether the current node contains a left child because only then is it necessary to draw the left part of the line. If so, you calculate the start (<code>sci</code>, which stands for <em class="italic">start column index</em>) and end (<code>eci</code> as <em class="italic">end column index</em>) indices of columns and fill the proper elements of the array with dashes. At the end, a plus sign is added to the array in the place<a id="_idIndexMarker679"/> where the drawn line will be connected with the right line of another element and on the other side of the line.</p>
<p>In almost the same way, you draw the right line for the current node. Of course, you need to adjust the code regarding calculating column start and end indices. The final version of the code of the <code>DrawLineRight</code> method is as follows:</p>
<pre class="source-code">
void <strong class="bold">DrawLineRight</strong>(BinaryTreeNode&lt;int&gt; node, int row,
    int column, char[,] console, int columnDelta)
{
    if (node.Right == null) { return; }
    int sci = ColumnWidth * column + 2;
    int eci = ColumnWidth * (column + columnDelta) + 2;
    for (int x = sci + 1; x &lt; eci; x++)
    {
        console[row + 1, x] = '-';
    }
    console[row + 1, sci] = '+';
    console[row + 1, eci] = '+';
}</pre> <p>At the end, let’s see the <code>Draw</code> method that shows the board in the console. It just iterates through all elements <a id="_idIndexMarker680"/>of the array and writes them in the console, as follows:</p>
<pre class="source-code">
void <strong class="bold">Draw</strong>(char[,] console)
{
    for (int y = 0; y &lt; console.GetLength(0); y++)
    {
        for (int x = 0; x &lt; console.GetLength(1); x++)
        {
            Console.Write(console[y, x]);
        }
        Console.WriteLine();
    }
}</pre> <p>That’s all! You wrote the whole code necessary to build the project, launch the program, and see it in action. Just after launching, you will see the first BST, as follows:</p>
<div><div><img alt="Figure 7.13 – ﻿Screenshot of the ﻿BST visualization example, step 1" src="img/B18069_07_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Screenshot of the BST visualization example, step 1</p>
<p>After adding the next two<a id="_idIndexMarker681"/> nodes, <code>75</code> and <code>125</code>, the BST looks a bit different:</p>
<div><div><img alt="Figure 7.14 – ﻿Screenshot of the BST visualization example, step 2" src="img/B18069_07_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Screenshot of the BST visualization example, step 2</p>
<p>Then, you perform an insertion operation for the next five elements. These operations have a very visible impact on the tree shape, as presented in the console:</p>
<div><div><img alt="Figure 7.15 – ﻿Screenshot of the BST visualization example, step 3" src="img/B18069_07_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Screenshot of the BST visualization example, step 3</p>
<p>After adding 10 elements, the program shows the impact of removing a particular node on the shape of the tree. To start, let’s <a id="_idIndexMarker682"/>remove the leaf node with <code>25</code> as the value:</p>
<div><div><img alt="Figure 7.16 – ﻿Screenshot of the BST visualization example, step 4" src="img/B18069_07_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Screenshot of the BST visualization example, step 4</p>
<p>Then, the program removes a node with only one child node, namely the right one. What is interesting is that the right child also has a right child. However, the presented algorithm works properly in such conditions, and you receive the following result:</p>
<div><div><img alt="Figure 7.17 – ﻿Screenshot of the BST visualization example, step 5" src="img/B18069_07_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Screenshot of the BST visualization example, step 5</p>
<p>The last removal operation is the most complicated one because it requires you to remove the node with both children, and it also performs the role of the root. In such a case, the leftmost element from the right subtree of the root is found and replaces the node for removal, as shown in the final view of the tree:</p>
<div><div><img alt="Figure 7.18 – ﻿Screenshot of the BST visualization example, step 6" src="img/B18069_07_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – Screenshot of the BST visualization example, step 6</p>
<p>One more set of operations is left, namely traversal of the tree in pre-order, in-order, and post-order. The application<a id="_idIndexMarker683"/> presents the following results:</p>
<pre class="console">
Pre-order traversal:    110, 75, 90, 150, 125, 135, 175
In-order traversal:     75, 90, 110, 125, 135, 150, 175
Post-order traversal:   90, 75, 135, 125, 175, 150, 110</pre> <p>The created application looks quite impressive, doesn’t it? You created not only the implementation of a BST from scratch but also prepared the platform for its visualization in the console. Great job!</p>
<p class="callout-heading">Is it already sorted?</p>
<p class="callout">Let’s take one more look at the results of the in-order approach. As you can see, it gives you the nodes sorted in ascending order in the case of a BST.</p>
<p>However, can you see a potential problem with the created solution? What about a scenario where you remove nodes only from the given area of a tree or when you insert already sorted values? It could mean that a fat tree, with a<a id="_idIndexMarker684"/> proper <strong class="bold">breadth-depth ratio</strong>, could become a skinny one. In the worst case, it could even be depicted as a list, where all nodes have only one child. Do you have any idea how to solve the problem of unbalanced trees and keep them balanced all the time? If no<a id="_idTextAnchor282"/><a id="_idTextAnchor283"/>t, next, you will find some information on how to achieve this goal.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor284"/>Self-balancing trees</h1>
<p>In this section, you will get to know two variants of a <strong class="bold">self-balancing tree</strong>, which <strong class="bold">keeps the tree balanced all the time while adding and removing nodes.</strong> However, why is it so important? As already<a id="_idIndexMarker685"/> mentioned, the lookup performance depends on the shape of the tree. In the case of improper organization of nodes, forming a list, the process of searching for a given value can be an <em class="italic">O(n)</em> operation. With a correctly arranged tree, the performance can be significantly improved with <em class="italic">O(log n)</em>.</p>
<p>Do you know that a BST can very easily become an <strong class="bold">unbalanced tree</strong>? Let’s make a simple test of adding the following nine <a id="_idIndexMarker686"/>numbers to the tree, from <strong class="bold">1</strong> to <strong class="bold">9</strong>. Then, you will receive a tree with the shape shown in the following diagram on the left. However, the same values can be arranged in another way, as a <strong class="bold">balanced tree</strong>, with a significantly better<a id="_idIndexMarker687"/> breadth-depth ratio, which is shown on the right:</p>
<div><div><img alt="Figure 7.19 – Difference between an unbalanced and a balanced tree" src="img/B18069_07_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – Difference between an unbalanced and a balanced tree</p>
<p>You now know what unbalanced and balanced trees are, as well as what is the aim of self-balancing trees. However, what is <a id="_idIndexMarker688"/>an AVL tree or a red-black tree? How do they work? What rules should be taken into account while using these data structures? You will find answers to these questions next.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor285"/>AVL trees</h2>
<p>An <strong class="bold">AVL tree</strong> is named after its inventors, namely Adelson-Velsky and Landis. It is <strong class="bold">a binary search tree with the additional requirement that, for each node, the height of its left and right subtrees cannot differ by more than one</strong>. Of course, that rule must be maintained after adding and removing nodes <a id="_idIndexMarker689"/>from a tree. The important role is<a id="_idIndexMarker690"/> performed by <strong class="bold">rotations</strong>, used to fix incorrect arrangements of nodes.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">While talking about AVL trees, it is crucial to indicate the performance of this data structure. In this case, both average and worst-case scenarios of insertion, removal, and lookup are <em class="italic">O(log n)</em>, so there is significant improvement in the worst-case scenarios in comparison with a BST.</p>
<p>The implementation of AVL trees, including various rotations necessary to keep the balanced state of a tree, is not trivial and will require quite a long explanation. Due to the limited number of pages in the book, its implementation is not presented here. Fortunately, you can use one of the available NuGet packages that support such t<a id="_idTextAnchor286"/>ree-based data structures to benefit from AVL trees in your applications.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor287"/>Red-black trees</h2>
<p>A <strong class="bold">red-black tree</strong> (<strong class="bold">RBT</strong>) is the next variant of self-balancing <a id="_idIndexMarker691"/>binary search trees. As a variant of BSTs, this data structure requires that standard BST rules are maintained. Moreover, the following rules must be<a id="_idIndexMarker692"/> taken into account:</p>
<ul>
<li><strong class="bold">Each node must be colored either red or black</strong>. Thus, you need to add additional data for a node that stores a color.</li>
<li><code>NIL</code> pseudo-nodes should be used as leaves in the tree, while all other nodes are internal ones. Moreover, all <code>NIL</code> pseudo-nodes must be black.</li>
<li><strong class="bold">If a node is red, both its children must </strong><strong class="bold">be black</strong>.</li>
<li>For any node, <code>NIL</code> pseudo-node) <strong class="bold">must be </strong><strong class="bold">the same</strong>.</li>
</ul>
<p>A proper RBT is presented in the<a id="_idIndexMarker693"/> following diagram:</p>
<div><div><img alt="Figure 7.20 – ﻿Illustration of a red-black tree" src="img/B18069_07_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 – Illustration of a red-black tree</p>
<p>The tree consists of nine nodes, each colored red or black. It is worth mentioning the <code>NIL</code> pseudo-nodes, which are added as leaf nodes. If you again take a look at the set of rules listed previously, you can confirm that all such rules are maintained in this case.</p>
<p>Similarly to AVL trees, RBTs also must maintain rules after adding or removing a node. In this case, the process of restoring the RBT properties is even more complicated because it involves both <strong class="bold">recoloring</strong> and <strong class="bold">rotations</strong>.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">While talking about this variant of self-balancing BSTs, it is also worth noting the performance. In both average and worst-case scenarios, insertion, removal, and lookup are <em class="italic">O(log n)</em> operations, so they are the same as in the case of AVL trees and much better in worst-case scenarios in comparison with BSTs.</p>
<p>Fortunately, you do not need to know and understand the internal details, which are quite complex, to benefit from this data structure and apply it to your projects. As already mentioned in the case of AVL trees, you can also use one of the available NuGet packages for RBTs.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">The topic of trees is much broader than shown in this chapter. For this reason, if you are interested in such a subject, I strongly encourage you to search for more information on your own. You can also find some content on <em class="italic">Wikipedia</em>, such as at <a href="https://en.wikipedia.org/wiki/Binary_tree">https://en.wikipedia.org/wiki/Binary_tree</a> and <a href="https://en.wikipedia.org/wiki/Binary_search_tree">https://en.wikipedia.org/wiki/Binary_search_tree</a>. Self-balancing trees are covered at <a href="https://en.wikipedia.org/wiki/AVL_tree">https://en.wikipedia.org/wiki/AVL_tree</a> and <a href="https://en.wikipedia.org/wiki/Red-black_tree">https://en.wikipedia.org/wiki/Red-black_tree</a>. The topic of tries and binary heaps (mentioned later in this chapter) is presented as well at <a href="https://en.wikipedia.org/wiki/Trie">https://en.wikipedia.org/wiki/Trie</a> and <a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>.</p>
<p>You already learned some <a id="_idIndexMarker694"/>basic information about self-balancing trees, namely AVL trees and RBTs. So, let’s take a look at another tree-based structure, namely a trie, which is a great solution for string-related operations.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor288"/>Tries</h1>
<p>A tree is a powerful data structure that is used in various scenarios. One of them is related to processing strings, such as for <strong class="bold">autocomplete </strong>and<strong class="bold"> spellchecker</strong> features that you certainly know from many systems. If you want to implement it in your application, you can benefit from another <a id="_idIndexMarker695"/>tree-based data structure, namely a <strong class="bold">trie</strong>. It is used to store strings and to perform prefix-based searching.</p>
<p><strong class="bold">A trie is a tree with one root node, where each node represents a string and each edge indicates a character. A trie node contains references to the next nodes as an array with 26 elements, representing 26 chars from the alphabet (from </strong><strong class="p-bold-italics">a</strong><strong class="bold"> to </strong><strong class="p-bold-italics">z</strong><strong class="bold">). When you go from the root to each node, you receive a string, which is either a saved word or </strong><strong class="bold">its substring</strong>.</p>
<p class="callout-heading">Why exactly 26 elements?</p>
<p class="callout">Here, we use 26 elements representing 26 chars because it is the exact number of basic characters between <code>a</code> and <code>z</code> in the alphabet, without any special characters existing in various languages. Of course, in your implementation, you can expand this set with other characters, such as <code>ą</code>, <code>ę</code>, or <code>ś</code> from Polish, as well as with even digits or some special characters, such as a dash. Choosing a proper set of characters depends on the scenario in which this data structure will be used.</p>
<p>Does it sound<a id="_idIndexMarker696"/> complicated? It could, so let’s take a look at the following diagram, which should remove any doubts:</p>
<div><div><img alt="Figure 7.21 – ﻿Illustration of a trie" src="img/B18069_07_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.21 – Illustration of a trie</p>
<p>The diagram depicts a trie that stores the following words: <strong class="bold">ai</strong>, <strong class="bold">aid</strong>, <strong class="bold">aim</strong>, <strong class="bold">air</strong>, <strong class="bold">airplane</strong>, <strong class="bold">airport</strong>, <strong class="bold">algorithm</strong>, <strong class="bold">all</strong>, <strong class="bold">allergy</strong>, <strong class="bold">allow</strong>, <strong class="bold">allowance</strong>. As you can see, there is a root node (marked with <strong class="bold">-</strong>) that contains only one child, namely for the <strong class="bold">a</strong> substring. This node contains two child nodes, regarding the <strong class="bold">ai</strong> word and the <strong class="bold">al</strong> substring. The <strong class="bold">ai</strong> node has three children, namely representing <strong class="bold">aid</strong>, <strong class="bold">aim</strong>, and <strong class="bold">air</strong> words. In a similar way, you can analyze the whole trie. Please keep in mind that words are marked with bolder lines while substrings are<a id="_idIndexMarker697"/> shown with lighter ones.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">The searching and insertion in the case of a trie are <em class="italic">O(n)</em> operations, where <em class="italic">n</em> indicates a word length. So, a trie is an efficient data structure for string-based operations.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor289"/>Implementation</h2>
<p>After this short introduction, let’s<a id="_idIndexMarker698"/> move to something more exciting – coding!</p>
<h3>Node</h3>
<p>Please take a look at the<a id="_idIndexMarker699"/> following implementation of a class representing a node:</p>
<pre class="source-code">
public class <strong class="bold">TrieNode</strong>
{
    public TrieNode[] <strong class="bold">Children</strong> { get; set; }
        = new TrieNode[26];
    public bool <strong class="bold">IsWord</strong> { get; set; } = false;
}</pre> <p>The <code>TrieNode</code> class contains two properties. The first is named <code>Children</code> and is an array with <code>26</code> elements. Each of them represents a particular letter from an alphabet, starting from <code>a</code> (index equal to <code>0</code>) and ending with <code>z</code> (index equal to <code>25</code>). If there is another word with the same prefix, a reference to the next node is located in a suitable element of the <code>Children</code> array. The second property is named <code>IsWord</code> and indicates whether the current node is the last char from a word. It means that you can get this word by moving from the root <a id="_idIndexMarker700"/>element to this node.</p>
<h3>Trie</h3>
<p>The next part of the code shows the implementation of a class representing a trie:</p>
<pre class="source-code">
public class <strong class="bold">Trie</strong>
{
    private readonly TrieNode <strong class="bold">_root</strong> = new();
}</pre> <p>Here, there is a private <a id="_idIndexMarker701"/>field representing the root element. Of course, you need to add some methods to make it operational. First, let’s implement a method that checks whether a given word exists in the trie. Its code is as follows:</p>
<pre class="source-code">
public bool <strong class="bold">DoesExist</strong>(string word)
{
    TrieNode current = _root;
    <strong class="bold">foreach (char c in word)</strong>
    {
        TrieNode child = <strong class="bold">current.Children[c - 'a'];</strong>
        if (child == null) { return false; }
        current = child;
    }
    return <strong class="bold">current.IsWord</strong>;
}</pre> <p>At the beginning, you save a reference to the root element as the current node. Then, you iterate through the following characters that form the word. For each character (represented by the <code>c</code> variable), you get a proper node (<code>child</code>). If it is <code>null</code>, it means that the word does not exist in the trie. Otherwise, you save the child element as the current one. When the <code>foreach</code> loop ends, the current node represents a node of the last character, so you just need to return the value of the <code>IsWord</code> property.</p>
<p>The next method allows you to insert a word into a trie, as shown here:</p>
<pre class="source-code">
public void <strong class="bold">Insert</strong>(string word)
{
    TrieNode current = _root;
    <strong class="bold">foreach (char c in word)</strong>
    {
        int i = c - 'a';
        <strong class="bold">current.Children[i] = current.Children[i] ?? new();</strong>
        current = current.Children[i];
    }
    <strong class="bold">current.IsWord = true;</strong>
}</pre> <p>The preceding code is a<a id="_idIndexMarker702"/> bit similar to that already described. However, there is one important difference in the <code>foreach</code> loop. Here, you create a new child node if it does not exist for any of the chars forming the word. At the end, you indicate that the node represents the word by setting the value of the <code>IsWord</code> property to <code>true</code>.</p>
<p>As already mentioned, a trie is a data structure that allows you to perform <strong class="bold">prefix-based searching</strong> in an<a id="_idIndexMarker703"/> efficient way. So, let’s implement it:</p>
<pre class="source-code">
public List&lt;string&gt; <strong class="bold">SearchByPrefix</strong>(string prefix)
{
    TrieNode current = _root;
    foreach (char c in prefix)
    {
        TrieNode child = current.Children[c - 'a'];
        if (child == null) { return []; }
        current = child;
    }
    List&lt;string&gt; results = [];
    <strong class="bold">GetAllWithPrefix(current, prefix, results);</strong>
    return results;
}</pre> <p>The method takes one parameter, namely the prefix of the searched words. At the beginning, you iterate through all <a id="_idIndexMarker704"/>characters of the prefix to get a reference to the last character forming the prefix. If a child node is not found at any phase, you return an empty list, which means that there are no results.</p>
<p>Otherwise, you create a <code>List&lt;string&gt;</code> instance to store the result, and then you call the <code>GetAllWithPrefix</code> method, the code of which is shown next:</p>
<pre class="source-code">
private void <strong class="bold">GetAllWithPrefix</strong>(TrieNode node,
    string prefix, List&lt;string&gt; results)
{
    if (node == null) { return; }
    <strong class="bold">if (node.IsWord) { results.Add(prefix); }</strong>
    <strong class="bold">for (char c = 'a'; c &lt;= 'z'; c++)</strong>
    {
        <strong class="bold">GetAllWithPrefix(node.Children[c - 'a'],</strong>
            <strong class="bold">prefix + c, results);</strong>
    }
}</pre> <p>You check whether the current node is <code>null</code>. If so, you return from the method. Otherwise, you verify whether the current node forms a word. If so, you add it to <code>results</code>. Next, you iterate through all alphabet characters, namely from <code>a</code> to <code>z</code>, and call the same method recursively to find the next words and add them to the list with <code>results</code>.</p>
<p>As you can see, the basic<a id="_idIndexMarker705"/> implementation of a trie is not a complicated task and can be done with clear and short code. However, how can you test a trie in action? Let’s see:</p>
<pre class="source-code">
<strong class="bold">Trie trie = new();</strong>
trie.<strong class="bold">Insert</strong>("algorithm");
trie.<strong class="bold">Insert</strong>("aid");
trie.<strong class="bold">Insert</strong>("aim");
trie.<strong class="bold">Insert</strong>("air");
trie.<strong class="bold">Insert</strong>("ai");
trie.<strong class="bold">Insert</strong>("airport");
trie.<strong class="bold">Insert</strong>("airplane");
trie.<strong class="bold">Insert</strong>("allergy");
trie.<strong class="bold">Insert</strong>("allowance");
trie.<strong class="bold">Insert</strong>("all");
trie.<strong class="bold">Insert</strong>("allow");
bool isAir = trie.<strong class="bold">DoesExist</strong>("air");
List&lt;string&gt; words = trie.<strong class="bold">SearchByPrefix</strong>("ai");
foreach (string word in words)
{
    Console.WriteLine(word);
}</pre> <p>The preceding code forms a trie, as shown in <em class="italic">Figure 7</em><em class="italic">.21</em>, with 11 words starting with <code>a</code>, such as <code>algorithm</code> and <code>allow</code>. You add such words with the <code>Insert</code> method. Then, you check whether the <code>air</code> word exists with the <code>DoesExist</code> method. Next, you get all words that start with the <code>ai</code> prefix and write them in the console:</p>
<pre class="console">
ai
aid
aim
air
airplane
airport</pre> <p>At the end of the section regarding tries, let’s talk about the space complexity of this data structure. As you can see, you need to store 26 references to child nodes for each trie node, and there can be <a id="_idIndexMarker706"/>a lot of situations where only one or two references are set. For instance, you can take a look at the <code>algorithm</code> word, where a lot of space is wasted. It would be much better to optimize it in some way to make the whole tree smaller.</p>
<p>Fortunately, it is possible to use another <a id="_idIndexMarker707"/>data structure that is named a <strong class="bold">radix tree</strong> or a <strong class="bold">compressed trie</strong>, which<a id="_idIndexMarker708"/> is <strong class="bold">a space-optimized version of a trie</strong>. The difference is quite simple: namely, <strong class="bold">you merge with the parent each node that is the only child of this parent</strong>. Of course, <strong class="bold">edges can represent a substring</strong> in such a case.</p>
<p>If you want to see what a radix tree looks like for the same input data as in the diagram of a trie, take a look at the following diagram:</p>
<div><div><img alt="Figure 7.22 – ﻿Illustration of a radix tree" src="img/B18069_07_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – Illustration of a radix tree</p>
<p>Looks much simpler, doesn’t it? For example, let’s analyze the path from the root node to <strong class="bold">algorithm</strong>. Here, you use <a id="_idIndexMarker709"/>only three edges, namely <strong class="bold">a</strong>, <strong class="bold">l</strong>, and <strong class="bold">gorithm</strong>.</p>
<p class="callout-heading">Try to implement it on your own</p>
<p class="callout">Based on the preceding diagram and the implementation of a trie, I encourage you to try to implement a radix tree on your own. You should also prepare a method for searching a word in such a data structure. Good luck!</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor290"/>Example – autocomplete</h2>
<p>As an example of a trie application, you will create an <code>Countries.txt</code> file with<a id="_idIndexMarker710"/> names of countries, as well as add it to the project as content that will be automatically copied to the output directory.</p>
<p class="callout-heading">How to add a file to the project?</p>
<p class="callout">You should right-click on the project node in the <code>.txt</code> extension. After confirmation, the file is created. If you want to mark this file as a content file and automatically copy it to the output directory, you should click on the file and change two properties in the <strong class="bold">Properties</strong> window. First, change <strong class="bold">Build Action</strong> to <strong class="bold">Content</strong>. Then, set <strong class="bold">Copy to Output Directory</strong> to <strong class="bold">Copy always</strong>.</p>
<p>A part of the file with <a id="_idIndexMarker711"/>country names is as follows:</p>
<pre class="source-code">
Afghanistan
Albania
Algeria (...)
Pakistan
Palau
Panama
Papua New Guinea
Paraguay
Peru
Philippines
Poland
Portugal (...)
Zambia
Zimbabwe</pre> <p>Of course, a lot of country names are omitted in the preceding code snippet. However, when the file with country names is ready, you need to read its content and form a trie, as presented in the following code block:</p>
<pre class="source-code">
using System.Text.RegularExpressions;
<strong class="bold">Trie trie = new();</strong>
string[] countries =
    await File.ReadAllLinesAsync("Countries.txt");
foreach (string country in countries)
{
    Regex regex = new("[^a-z]");
    string name = country.ToLower();
    name = regex.Replace(name, string.Empty);
    <strong class="bold">trie.Insert(name);</strong>
}</pre> <p>At the beginning, you create a <a id="_idIndexMarker712"/>new instance of the <code>Trie</code> class. Then, you read all lines from the <code>Countries.txt</code> file and store them in the <code>countries</code> array.</p>
<p>The remaining part of the code consists of a <code>foreach</code> loop that iterates through all country names. For each of them, you make it lowercase and remove all chars other than <code>a</code>-<code>z</code>. Such a task is performed with a regular expression and the <code>Regex</code> class from the <code>System.Text.RegularExpressions</code> namespace.</p>
<p>When the trie is ready, you use a <code>while</code> loop, as shown next:</p>
<pre class="source-code">
string text = string.Empty;
while (true)
{
    Console.Write("Enter next character: ");
    ConsoleKeyInfo key = Console.ReadKey();
    if (key.KeyChar &lt; 'a' || key.KeyChar &gt; 'z') { return; }
    text = (text + key.KeyChar).ToLower();
    <strong class="bold">List&lt;string&gt; results = trie.SearchByPrefix(text);</strong>
    if (results.Count == 0) { return; }
    Console.WriteLine(
        $"\nSuggestions for {text.ToUpper()}:");
    results.ForEach(r =&gt; Console.WriteLine(r.ToUpper()));
    Console.WriteLine();
}</pre> <p>Inside the <code>while</code> loop, you wait until the user presses any key. If this key is other than <code>a</code>-<code>z</code>, the program ends its operation. Otherwise, you append the entered char to the prefix that is used for searching all country names that start with this prefix. If the number of results is equal to zero, the<a id="_idIndexMarker713"/> application ends its operation. Otherwise, you use the <code>ForEach</code> extension method to write each suggestion on a separate line.</p>
<p>As you can see, a trie provides you with a powerful and efficient mechanism for implementing an autocomplete feature. But what does it look like in practice? Let’s take a look at the following output regarding searching for <code>POLAND</code>:</p>
<pre class="console">
Enter next character: p
Suggestions for P:
PAKISTAN
PALAU
PANAMA
PAPUANEWGUINEA
PARAGUAY
PERU
PHILIPPINES
POLAND
PORTUGAL
Enter next character: o
Suggestions for PO:
POLAND
PORTUGAL
Enter next character: l
Suggestions for POL:
POLAND
Enter next character: e</pre> <p>At the beginning, you can see names of countries that start with <code>P</code>. After typing <code>O</code>, you limit the results to countries<a id="_idIndexMarker714"/> whose names start with <code>PO</code>. In the same way, you further increase the prefix and get fewer and fewer results.</p>
<p>Let’s proceed to the last part of this chapter,<a id="_idTextAnchor291"/> which is related to heaps. What are they, and why are they featured in a chapter about trees?</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor292"/>Heaps</h1>
<p>A <strong class="bold">heap</strong> is another variant of a tree, which you already got to know in <a href="B18069_03.xhtml#_idTextAnchor088"><em class="italic">Chapter 3</em></a>,<em class="italic"> Arrays and Sorting</em>. There, you used a heap in the heap sort algorithm for sorting an array. For this reason, in the current <a id="_idIndexMarker715"/>chapter, you will see only a brief summary of this data structure. However, I strongly encourage you not to leave this topic and learn much more about heaps on your own, as they are powerful and popular data structures.</p>
<p>As you already know, a binary heap exists in two versions: <strong class="bold">min-heap</strong> and <strong class="bold">max-heap</strong>. For each of them, an additional property must be satisfied:</p>
<ul>
<li><strong class="bold">For min-heap</strong>: The value of each<a id="_idIndexMarker716"/> node must be greater than or equal to the value of its parent node</li>
<li><strong class="bold">For max-heap</strong>: The value of<a id="_idIndexMarker717"/> each node must be less than or equal to the value of its parent node</li>
</ul>
<p>These rules perform a very important role because they dictate that <strong class="bold">the root node always contains the smallest value (in the min-heap) or the largest value (in the max-heap)</strong>. You benefited from this assumption while sorting. Do you remember?</p>
<p>A binary heap must also adhere to the <strong class="bold">complete binary tree</strong> rule, which requires that <strong class="bold">each node cannot contain more than two children and all levels of a tree must be fully filled, except the last one, which must be filled from left to right</strong> and can have some space on the right.</p>
<p>Let’s take a look at the following two binary heaps:</p>
<div><div><img alt="Figure 7.23 – ﻿Illustration of a min-heap and a max-heap" src="img/B18069_07_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – Illustration of a min-heap and a max-heap</p>
<p>You can easily check whether both heaps adhere to all the rules. As an example, let’s verify the heap property for the node with a value equal to <strong class="bold">20</strong> from the min-heap variant (shown on the left). The node has two children with values of <strong class="bold">35</strong> and <strong class="bold">50</strong>, which are both greater than <strong class="bold">20</strong>. In the same way, you can check the remaining nodes in the heap.</p>
<p>The binary tree rule is also maintained, as each node contains at most two children. The last requirement is that each level of the tree is fully filled except the last one, which does not need to be fully filled, but must contain nodes from left to right. In the min-heap example, three levels are fully filled (with one, two, and four nodes), while the last level contains two nodes (<strong class="bold">25</strong> and <strong class="bold">70</strong>), placed on the two leftmost positions. In the same way, you can confirm that the max-heap (shown on the right) is configured properly.</p>
<p>At the end of this short introduction to the topic of heaps, and especially to binary heaps, it is worth mentioning the broad range of applications. First of all, this data structure is a convenient way of implementing a <strong class="bold">priority queue</strong> with the operation of inserting a new value and removing the <a id="_idIndexMarker718"/>smallest value (in the min-heap) or the largest value (in the max-heap). Moreover, a heap is used in the <strong class="bold">heap sort algorithm</strong>, as well as in <strong class="bold">graph algorithms</strong>.</p>
<p>A binary heap can either be implemented from scratch or you can use some of the already available implementations as NuGet packages. One of the solutions is named <code>PommaLabs.Hippie</code> and can be easily installed on the project using the <strong class="bold">NuGet Package Manager</strong>. The mentioned library contains an implem<a id="_idTextAnchor293"/>entation of a few variants of heaps, including binary heaps, <strong class="bold">binomial heaps</strong>, and <strong class="bold">Fibonacci heaps</strong>.</p>
<p>Trees were everywhere in this chapter, and heaps are also representatives of thi<a id="_idTextAnchor294"/>s data structure! As you already learned a lot about trees, let’s proceed to the <em class="italic">Summary</em> section.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor295"/>Summary</h1>
<p>The current chapter was the longest so far in the book. However, it contained a lot of information about variants of trees. Such data structures perform a very important role in many algorithms, and it is good to learn more about them, as well as to know how to use them in your applications. For this reason, this chapter contained not only short theoretical introductions but also diagrams, explanations, and code samples.</p>
<p>At the beginning, <strong class="bold">the concept of a tree</strong> was described. As a reminder, a tree consists of <strong class="bold">nodes</strong>, including one <strong class="bold">root</strong>. The root does not contain a parent node, while all other nodes do. Each node can have any number of <strong class="bold">child nodes</strong>. The child nodes of the same node can be named <strong class="bold">siblings</strong>, while a node without children is named a <strong class="bold">leaf</strong>.</p>
<p>Various variants of trees follow this structure. The first one described in the chapter is a <strong class="bold">binary tree</strong>. In this case, a node can contain at most two children. However, the rules for <strong class="bold">binary search trees</strong> are even more strict. For any node in such trees, the values of all nodes in its left subtree must be smaller than the value of the node, while the values of all nodes in its right subtree must be greater than the value of the node. BSTs have a broad range of applications and provide developers with significant improvements in the lookup performance. However, it is possible to easily make a tree unbalanced while adding sorted values to the tree. Thus, the positive impact on the performance can be limited.</p>
<p>Fortunately, <code>NIL</code> pseudo-nodes. Moreover, it is required that if a node is red, both its children must be black, and for any node, the number of black nodes on the route to a descendant leaf must be the same.</p>
<p>Then, you learned a lot about <strong class="bold">tries</strong> and saw their great performance regarding processing strings, such as for autocomplete or spellchecker features. Each trie is a tree with one root node, where each node represents a string and each edge indicates a character. A trie node contains references to the next nodes as an array with elements representing possible characters. When you go from the root to each node, you receive a string, which is either a saved word or its substring. Within this part, a <strong class="bold">radix tree</strong> was mentioned as well, which is a space-optimized version of a trie.</p>
<p>The remaining part of the chapter was related to <strong class="bold">binary heaps</strong>. As a reminder, a heap is another variant of a tree, which exists in two versions, <strong class="bold">min-heap</strong> and <strong class="bold">max-heap</strong>. It is worth noting that the value of each node must be greater than or equal to (for min-heaps) or less than or equal to (for max-heaps) the value of its parent node.</p>
<p>Let’s proceed to <strong class="bold">graphs</strong>, which are the subject of the next chapter!</p>
</div>
</body></html>