<html><head></head><body>
		<div id="_idContainer059">
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor116"/>5</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/>Building Restful APIs</h1>
			<p>In today’s online-centric digital landscape, <strong class="bold">application programming interfaces </strong>(<strong class="bold">APIs</strong>) have become ubiquitous in the development of <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) applications. They allow different systems and applications to communicate with each other and share data. Among the different types of <a id="_idIndexMarker256"/>APIs, <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>)ful APIs have become the most widely used and accepted standard, and that is what we will focus on in <span class="No-Break">this chapter.</span></p>
			<p>This chapter will introduce you to the basics of building RESTful APIs and the key principles that guide their design. You will learn about the key components of a RESTful API, such as resources, representations, and the main HTTP verbs (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">).</span></p>
			<p>Additionally, you will learn about the various strategies to version RESTful APIs, such as URL versioning, custom header versioning, media type versioning, and deprecation <span class="No-Break">and sunsetting.</span></p>
			<p>The main topics covered in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>What are <span class="No-Break">RESTful APIs?</span></li>
				<li>Matching API operations to <span class="No-Break">HTTP verbs</span></li>
				<li>Designing better <span class="No-Break">with REST</span></li>
				<li>Versioning <span class="No-Break">public APIs</span></li>
				<li><span class="No-Break">Testing APIs</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of the key principles and strategies to build RESTful APIs, and you will be well-equipped to design, develop, and <span class="No-Break">test them.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>All code from this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>What are RESTful APIs?</h1>
			<p>REST was <a id="_idIndexMarker257"/>introduced by Roy Fielding in his doctoral dissertation at the University of California, Irvine, in 2000. In his dissertation, Fielding defined the architectural constraints that formed the basis of RESTful systems and described how REST could be used to build scalable and flexible web services. The concepts outlined in his dissertation have since become widely adopted and are used as the foundation to build many modern <span class="No-Break">web APIs.</span></p>
			<p>RESTful APIs <a id="_idIndexMarker258"/>are a type of web-based interface that allows for communication between different software systems. They utilize a standard set of constraints and principles defined by the REST architecture to exchange data between a client and server. Resources are identified by unique URLs, and the behavior toward these resources is defined by the HTTP methods used. RESTful APIs are commonly used to build scalable and flexible web services and can return data in different formats, such as JSON or XML. They offer a simple and flexible way for different software systems to interact and exchange data over <span class="No-Break">the internet.</span></p>
			<p>Let’s break down what the REST <span class="No-Break">acronym means!</span></p>
			<p><strong class="bold">Representational</strong> refers to the idea that each resource in a RESTful API is represented by a unique identifier (such as a URL) and can be represented in a variety of formats, such as JSON or XML. The representation of a resource is a snapshot of its current state and can be used by a client to manipulate <span class="No-Break">the resource.</span></p>
			<p>You can think of a resource as an object, such as a description of a user in a system. The user will typically have a unique ID that is used to refer to that user. In a REST system, the user <em class="italic">resource</em> with an ID = 123 could be <em class="italic">represented</em> by the <span class="No-Break">following URL:</span></p>
			<p><span class="No-Break"><strong class="source-inline">https://www.a-system.com/api/v1/users/123</strong></span></p>
			<p>The user can be retrieved, modified, or deleted by using this URL. The URL <em class="italic">represents</em> the user on any external system that is consuming <span class="No-Break">the </span><span class="No-Break"><strong class="bold">PAI</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="bold">state</strong> of a resource refers to its current data and metadata, such as its content, creation date, and any associated metadata. In RESTful APIs, the state of a resource can be manipulated through the use of HTTP methods such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></p>
			<p>If you were to issue a <strong class="source-inline">GET</strong> request to the preceding dummy URL, you would receive the <em class="italic">state</em> of the object represented by <span class="No-Break">that URL.</span></p>
			<p><strong class="bold">Transfer</strong> refers <a id="_idIndexMarker259"/>to the transfer of the representation of a resource from a server to a client and vice versa. The transfer is typically performed over the HTTP protocol and is based on the principles of statelessness and uniform resource identification. In RESTful APIs, the transfer of state is used to create, read, update, and delete resources on <span class="No-Break">the server.</span></p>
			<p>RESTful APIs do <a id="_idIndexMarker260"/>not have to communicate over HTTP, although they very often do. They could use any other possible communication protocol, such as <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>). However, the large majority of RESTful APIs use HTTP as the chosen communication mechanism, and that is all that we will consider in this chapter. If you have a use case for an alternative communication protocol, then I hope the information in this chapter is useful in a more <span class="No-Break">general sense!</span></p>
			<p>Before we get into the details of building restful APIs, there are a few general points to consider that will aid our understanding of some of the more complex concepts that <span class="No-Break">will follow.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Idempotency</h2>
			<p>In the<a id="_idIndexMarker261"/> context of a RESTful API, idempotency is a property of an API endpoint that allows multiple identical requests to have the same effect as a single request. This means that, regardless of the number of times the same request is made, the end result should be <span class="No-Break">the same.</span></p>
			<p>An idempotent request will always produce the same response from a server, regardless of how many times it is executed. This property is useful to reduce the chance of errors and conflicts when making multiple requests to the same endpoint, especially when dealing with network connectivity issues or other types <span class="No-Break">of failures.</span></p>
			<p>The most common HTTP methods considered idempotent are <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, and certain types of <strong class="source-inline">POST</strong> requests. On the other hand, non-idempotent methods, such as <strong class="source-inline">POST</strong> without specifying the idempotent semantics, may have unintended side effects if repeated <span class="No-Break">multiple times.</span></p>
			<p>This is to say that you can retrieve a resource at a URL as many times as you like, and the response will be the same every time. A <strong class="source-inline">GET</strong> request <span class="No-Break">is idempotent.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor121"/>Safety</h2>
			<p>In the <a id="_idIndexMarker262"/>context of a RESTful API, a “safe” operation is one that is guaranteed not to modify the state of a server or have any side effects. Safe operations are read-only and do not alter any resources on <span class="No-Break">the server.</span></p>
			<p>The most common example of a safe operation is a <strong class="source-inline">GET</strong> request, which retrieves data from the server without changing it. Other safe operations might include <strong class="source-inline">OPTIONS</strong>, <strong class="source-inline">HEAD</strong>, and some types of <strong class="source-inline">POST</strong> requests that are specifically designed to only retrieve data and not make any changes to the <span class="No-Break">server state.</span></p>
			<p>Safe operations are contrasted with “unsafe” operations, such as <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong>, operations that modify the state of the server and may have side effects. These operations are considered unsafe because they can have unintended consequences if executed improperly, such as deleting important data or altering resources in <span class="No-Break">unexpected ways.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>HTTP status codes</h2>
			<p>HTTP status codes <a id="_idIndexMarker263"/>are three-digit numbers returned by a server in response to a client’s request. These codes indicate the outcome of the request and provide information about the status of the <span class="No-Break">requested resource.</span></p>
			<p>There are many HTTP status codes – I will briefly reference only the set that I think is most applicable to building RESTful APIs. Don’t worry about memorizing all of these! As you will see, when we start to build up the examples, it is quite intuitive which ones should be used and when! And remember, information like this is only ever a Google <span class="No-Break">search away!</span></p>
			<p>Each status code is a three-digit number. The first digit gives the category of the status code. There are five <a id="_idIndexMarker264"/>category codes, each with a specific meaning and purpose. These are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">1xx (informational)</strong>: This <a id="_idIndexMarker265"/>category of status codes indicates that the request was received and the server is continuing to process it. The most common status code in this category is <span class="No-Break"><strong class="source-inline">100 Continue</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">2xx (successful)</strong>: This<a id="_idIndexMarker266"/> category of status codes indicates that the request was successfully received, understood, and accepted. The most common status codes in this category are <strong class="source-inline">200 OK</strong> and <span class="No-Break"><strong class="source-inline">201 Created</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">3xx (redirection)</strong>: This <a id="_idIndexMarker267"/>category of status codes indicates that further action needs to be taken by the client in order to complete the request. The most common status codes in this category are <strong class="source-inline">301 Moved Permanently</strong> and <span class="No-Break"><strong class="source-inline">302 Found</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">4xx (client error)</strong>: This <a id="_idIndexMarker268"/>category of status codes indicates that the request contains bad syntax or cannot be fulfilled by the server. The most common status codes in this category are <strong class="source-inline">400 Bad Request</strong> and <span class="No-Break"><strong class="source-inline">401 Unauthorized</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">5xx (server error)</strong>: This<a id="_idIndexMarker269"/> category of status codes indicates that the server failed to fulfill a valid request. The most common status codes in this category are <strong class="source-inline">500 Internal Server Error</strong> and <strong class="source-inline">503 </strong><span class="No-Break"><strong class="source-inline">Service Unavailable</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>There are <a id="_idIndexMarker270"/>many status codes within these categories. Some of <a id="_idIndexMarker271"/>the common and most applicable to RESTful APIs are <span class="No-Break">given here:</span></p>
			<ul>
				<li><strong class="source-inline">200 OK</strong>: The request was successful, and the requested resource was returned. This status is commonly returned from a successful <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, or <span class="No-Break"><strong class="source-inline">PATCH</strong></span><span class="No-Break"> request.</span></li>
				<li><strong class="source-inline">201 Created</strong>: The request was successful, and a new resource was created as a result. This status code is often returned as the result of a successful <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request.</span></li>
				<li><strong class="source-inline">204 No Content</strong>: The request was successful, but no resource was returned. This status is commonly returned from a successful <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> request.</span></li>
				<li><strong class="source-inline">400 Bad Request</strong>: The request was malformed or invalid. With a RESTful API, requests are often in JSON format. This would imply that the object is not correct per the expectations of <span class="No-Break">the API.</span></li>
				<li><strong class="source-inline">401 Unauthorized</strong>: The request requires authentication, and the client did not provide <span class="No-Break">valid credentials.</span></li>
				<li><strong class="source-inline">403 Forbidden</strong>: The client does not have access to the <span class="No-Break">requested resource.</span></li>
				<li><strong class="source-inline">404 Not Found</strong>: The requested resource could not be found. The request is looking for a resource that is <span class="No-Break">not there.</span></li>
				<li><strong class="source-inline">405 Method Not Allowed</strong>: The request method, such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong>, is not allowed for the requested resource on <span class="No-Break">the server.</span></li>
				<li><strong class="source-inline">500 Internal Server Error</strong>: An unspecified error occurred on the server. This<a id="_idIndexMarker272"/> status code is a “catch-all” error to let the user know that something has gone wrong on the server – for example, there could be an exception in the <span class="No-Break">backend code.</span></li>
				<li><strong class="source-inline">503 Service Unavailable</strong>: The server is currently unable to handle the request due to maintenance or <span class="No-Break">high traffic.</span></li>
			</ul>
			<p>There are<a id="_idIndexMarker273"/> many other HTTP status codes that can be used, each with a specific meaning and purpose. We will make use of these codes when we build out an example later in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Dealing with errors</h2>
			<p>When<a id="_idIndexMarker274"/> it comes to dealing with an error code on a RESTful API, it is important to have a clear and consistent approach in place. The HTTP status code is an essential part of this approach, and by using the status codes correctly, clients of the API are able to understand what has gone wrong and will have an idea as <span class="No-Break">to why.</span></p>
			<p>In addition to using the status codes correctly, it also helps to provide clear and informative error messages. These messages should explain what has gone wrong in an easily understood way and, if possible, provide guidance on how to resolve <span class="No-Break">the issue.</span></p>
			<p>The preceding will help users of the API, but it is also very important that the developers of the API are also informed when there has been an error so that they can take action to resolve or prevent recurrences. Because developers cannot watch over every API interaction, this is typically done <span class="No-Break">with logging.</span></p>
			<p>Logging refers to the process of capturing and recording information about an API’s behavior and performance and persisting this information in a data store so that it can be searched later to identify issues and troubleshoot problems. Logging is an essential part of any API’s operational infrastructure, as it provides a record of what has happened <a id="_idIndexMarker275"/>on <span class="No-Break">the system.</span></p>
			<p>This chapter will focus on API implementation, but we haven’t forgotten about logging and monitoring – we will cover both in detail in <a href="B19343_09.xhtml#_idTextAnchor219"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">!</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>JSON data formatting</h2>
			<p>While<a id="_idIndexMarker276"/> RESTful APIs do not have to use <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) formatting, it is an exceptionally popular choice and will be the <a id="_idIndexMarker277"/>formatting standard that is used throughout this book. JSON is a lightweight data exchange format that is easy for humans to read and write, and it is also easy for machines to parse and generate. It is completely language-independent, but it does make use of conventions that are familiar to the C family of languages (C, C++, C#, Java, and <span class="No-Break">so on).</span></p>
			<p>Here is an example of some information represented <span class="No-Break">as JSON:</span></p>
			<pre class="source-code">
{
    "name": "Roger Waters",
    "age": 79,
    "isBassist": true,
    "numbers": [90, 80, 85, 95],
    "address": {
        "street": "123 Main St",
        "city": "A Town",
    }
}</pre>
			<p>JSON data takes the form of key-value pairs, where each key is a string, and each value can be of type string, number, Boolean, null, array, or another JSON object. The ability to nest JSON objects allows for complex types to be represented in this <span class="No-Break">straightforward way.</span></p>
			<p>The keys are always strings, so they are encased in double quotation marks. The values are encased in quotes if they are strings, square brackets if they are arrays, and curly brackets if <a id="_idIndexMarker278"/>they are objects. All of these are shown in the <span class="No-Break">preceding snippet.</span></p>
			<p>We have established that JSON-encoded data will be sent and received over HTTP. Next, we will look at how that data is transmitted, looking at the most common HTTP verbs and describing how and when to <span class="No-Break">use them.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/>Matching API operations to HTTP verbs</h1>
			<p>In <a id="_idIndexMarker279"/>language, a verb is a “doing” word. It describes an action, state, or occurrence. In English, examples of verbs include “run,” “think,” “sing,” and “do,” as well as many <span class="No-Break">thousands more!</span></p>
			<p>The HTTP verbs describe things that you can “do” over HTTP! Five main verbs are used – <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">DELETE</strong>. Each of these serves a different purpose, although the precise purpose of each is not tightly defined, and it is not uncommon to accidentally use the wrong one. In this section, we will cover the uses of the five commonly used HTTP verbs, and we will give an example of them being used in our <span class="No-Break">demo application.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>GET</h2>
			<p>The <strong class="source-inline">GET</strong> HTTP verb <a id="_idIndexMarker280"/>is used to <em class="italic">retrieve a resource from a server</em>. When <a id="_idIndexMarker281"/>a client sends a <strong class="source-inline">GET</strong> request to a server, the server responds by returning the requested resource to the client. The resource can be any type of data, such as a web page, image, or file. The <strong class="source-inline">GET</strong> verb is the most widely used HTTP verb and is considered to be a safe and idempotent method, which means that it can be called multiple times without any side effects. It is also cacheable, which means that the response can be stored in a cache and reused to improve performance. The <strong class="source-inline">GET</strong> verb should only be used to retrieve information and never to make changes on <span class="No-Break">the server.</span></p>
			<p>When it comes to RESTful APIs, the <strong class="source-inline">GET</strong> verb is used to retrieve a representation of a resource or a collection of resources from a server. The resource can be identified by a <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>), and <a id="_idIndexMarker282"/>the representation of the resource is typically in a format such as JSON or XML. The <strong class="source-inline">GET</strong> request can also include query parameters, which can be used to filter the results or specify the format of the returned data. The server responds to a <strong class="source-inline">GET</strong> request with a representation of the resource in the form of an <a id="_idIndexMarker283"/>HTTP response, along with the appropriate HTTP status code. The most common status code for a <strong class="source-inline">GET</strong> request is <strong class="source-inline">200 OK</strong>, indicating that the request was successful and the resource <span class="No-Break">was returned.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>POST</h2>
			<p>The <strong class="source-inline">POST</strong> HTTP verb is <a id="_idIndexMarker284"/>used to <em class="italic">submit an entity to be processed by the resource identified by the URI</em>. A <strong class="source-inline">POST</strong> request is typically used to create a new<a id="_idIndexMarker285"/> resource or (sometimes) to update an existing one. The <strong class="source-inline">POST</strong> verb is not idempotent, which means that it can have different effects depending on how many times it is called. It is also not safe, meaning that it can modify the resource on <span class="No-Break">the server.</span></p>
			<p>When a client sends a <strong class="source-inline">POST</strong> request to a RESTful API, typically, the server creates a new resource with the data provided in the request body and returns a response with a status code indicating the outcome of the request. The most common status code for a successful <strong class="source-inline">POST</strong> request is <strong class="source-inline">201 Created</strong>, indicating that a new resource has been successfully created. The URI of the newly created resource is typically included in the response headers so that the client application can retrieve and work with the newly created resource immediately. The data in a <strong class="source-inline">POST</strong> request can be in any format, such as JSON or XML, but it is usually in the <span class="No-Break">JSON format.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>DELETE</h2>
			<p>The <strong class="source-inline">DELETE</strong> HTTP verb<a id="_idIndexMarker286"/> is used to <em class="italic">delete a resource from a server</em>. A <strong class="source-inline">DELETE</strong> request is <a id="_idIndexMarker287"/>used to remove the specified resource from the server. The <strong class="source-inline">DELETE</strong> verb is idempotent, which means that it can be called multiple times without any side effects. It is also not safe, meaning that it can modify the resource on <span class="No-Break">the server.</span></p>
			<p>When a client sends a <strong class="source-inline">DELETE</strong> request to a RESTful API, the server deletes the specified resource and returns a response with a status code, indicating the outcome of the request. The most common status code for a successful <strong class="source-inline">DELETE</strong> request is <strong class="source-inline">204 No Content</strong>, indicating that the resource has been successfully deleted. The client usually doesn’t receive <a id="_idIndexMarker288"/>any content in the response body, only the status code. The <strong class="source-inline">DELETE</strong> request usually requires the URI of the resource to be specified in the request so that the server is able to identify which resource <span class="No-Break">to delete.</span></p>
			<p>It’s worth<a id="_idIndexMarker289"/> noting that some RESTful APIs may not allow <strong class="source-inline">DELETE</strong> requests and will return a <strong class="source-inline">405 Method Not Allowed</strong> status code if a <strong class="source-inline">DELETE</strong> request <span class="No-Break">is received.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>PUT</h2>
			<p>The <strong class="source-inline">PUT</strong> HTTP verb <a id="_idIndexMarker290"/>is used to <em class="italic">update an existing resource or create a new one if it does not exist</em>. A <strong class="source-inline">PUT</strong> request is used to submit a representation<a id="_idIndexMarker291"/> of the resource to be updated or created. The representation of the resource is included in the request body and typically encoded in a format such as JSON or XML. The <strong class="source-inline">PUT</strong> verb is idempotent, which means that it can be called multiple times without any side effects. It is also not safe, meaning that it can modify the resource on <span class="No-Break">the server.</span></p>
			<p>When a client sends a <strong class="source-inline">PUT</strong> request to a RESTful API, the server updates the specified resource with the data provided in the request body and returns a response with a status code, indicating the outcome of the request. The most common status code for a successful <strong class="source-inline">PUT</strong> request is <strong class="source-inline">200 OK</strong>, indicating that the resource has been successfully updated. If a new resource is created, the <strong class="source-inline">201 Created</strong> status code will be returned. The URI of the updated resource is typically included in the <span class="No-Break">response headers.</span></p>
			<p>It’s worth noting that <strong class="source-inline">PUT</strong> requests may require a client to send the full representation of the resource in the request body, including all properties, even if only a few of them are to be updated. This can make a <strong class="source-inline">PUT</strong> request inefficient in terms of bandwidth used, and it may be better to use the <span class="No-Break"><strong class="source-inline">PATCH</strong></span><span class="No-Break"> verb.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>PATCH</h2>
			<p>The <strong class="source-inline">PATCH</strong> HTTP verb is used to <em class="italic">partially update an existing resource on a server</em>. A <strong class="source-inline">PATCH</strong> request is<a id="_idIndexMarker292"/> used to submit a set of changes to be made to the specified<a id="_idIndexMarker293"/> resource rather than replacing the entire resource. The set of changes is typically encoded in a format such as JSON or XML and is included in the request body. The <strong class="source-inline">PATCH</strong> verb is idempotent, which means that it can be called multiple times without any side effects. It is also not safe, meaning that it can modify the resource on <span class="No-Break">the server.</span></p>
			<p>In a <a id="_idIndexMarker294"/>RESTful API context, the <strong class="source-inline">PATCH</strong> verb is typically used to partially update an existing resource on the server. When a client sends a <strong class="source-inline">PATCH</strong> request to a RESTful API, the server applies the changes provided in the request body to the specified resource and returns a response with a status code indicating the outcome of the request. The most common status code for a successful <strong class="source-inline">PATCH</strong> request is <strong class="source-inline">200 OK</strong>, indicating that the resource <a id="_idIndexMarker295"/>has been successfully updated. The URI of the updated resource is typically included in the response headers. The data in a <strong class="source-inline">PATCH</strong> request can be in any format, such as JSON <span class="No-Break">or XML.</span></p>
			<p>It’s worth noting that <strong class="source-inline">PATCH</strong> requests require a client to send a specific set of changes to be made to the resource rather than the full representation of the resource. This makes <strong class="source-inline">PATCH</strong> requests more lightweight and efficient than <strong class="source-inline">PUT</strong> requests for <span class="No-Break">partial updates.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/>Data transfer objects</h1>
			<p>Another important <a id="_idIndexMarker296"/>concept to understand when working with APIs is <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>). A DTO is a design pattern that is commonly used to transfer data between layers or systems. In the case of a RESTful API, this is typically to transfer data from the backend (API) to the frontend <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). The general purpose of DTOs is to decouple the structure of the data from the underlying systems that use it, allowing for more flexibility and easier maintenance. They also provide a standardized way to handle data, making it easier for different components of a system to communicate and <span class="No-Break">exchange information.</span></p>
			<p>DTOs are particularly useful in RESTful APIs, as they provide a standard way to represent data when sending and receiving requests between a client and a server. When designing a RESTful API, the use of DTOs allows the API to define the structure of the data that is exchanged without having to tightly couple the implementation of the API to the structure of the data. This decoupling makes it easier to evolve the API and make changes to the underlying data model without affecting the API clients. Additionally, using DTOs enables the API to shape the data it returns to better match the needs of the client, reducing the amount of data transferred over the network and improving performance. Furthermore, DTOs can be used to validate the data being passed between the client and server, ensuring that only valid data is accepted <span class="No-Break">and processed.</span></p>
			<p>The first set of DTOs that we will see in this chapter will look a lot like the entity types that we defined for our database in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> and <a href="B19343_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, and they will relate to operations <a id="_idIndexMarker297"/>that we may wish to perform on the database. For example, the following entity type represents <strong class="source-inline">Habit</strong> in <span class="No-Break">the database:</span></p>
			<pre class="source-code">
[Index(nameof(Id), nameof(UserId))]
public class GoodHabit : IHasTenant
{
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public int UserId { get; set; }
    public virtual User User { get; set; } = default!;
    public virtual ICollection&lt;Progress&gt; ProgressUpdates {
      get; set; } = default!;
    public virtual ICollection&lt;Reminder&gt; Reminders { get;
      set; } = default!;
    public virtual Goal Goal { get; set; } = default!;
    public Duration Duration { get; set; }
    public string TenantName { get; set; } = default!;
}</pre>
			<p>Let’s say that we wanted to create a simple <strong class="source-inline">Habit</strong> that only had a <strong class="source-inline">Name</strong> property populated and was tied to a certain <strong class="source-inline">User</strong>. We could send the <span class="No-Break">following DTO:</span></p>
			<pre class="source-code">
    public class CreateHabitDto {
        public string Name { get; set; }
        public int UserId { get; set; }
    }</pre>
			<p>This could be used by the backend to create a simple <strong class="source-inline">GoodHabit</strong> object in <span class="No-Break">the database.</span></p>
			<p>If we wanted to retrieve the <strong class="source-inline">GoodHabit</strong> objects but only with the name and ID properties, we could use a DTO that looked <span class="No-Break">like this:</span></p>
			<pre class="source-code">
    public class GetGoodHabitDto {
        public int Id { get; set; }
        public string Name { get; set; }
    }</pre>
			<p>And, if we <a id="_idIndexMarker298"/>needed more information than simply a name and an ID, we could further define another DTO that looked <span class="No-Break">like this:</span></p>
			<pre class="source-code">
    public class GetGoodHabitDetailDto {
        public int Id { get; set; }
        public string Name { get; set; }
        public string UserName { get; set; }
        public string GoalName { get; set; }
        public string Duration { get; set; }
    }</pre>
			<p>You can see how we can start with the entity type that has a lot of database-specific information, and we can selectively model that data in different ways for different <span class="No-Break">use cases.</span></p>
			<p>We will illustrate this point with examples later in <span class="No-Break">this chapter!</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Designing better with REST</h1>
			<p>Good design <a id="_idIndexMarker299"/>with RESTful APIs is essential to create an API that is easy to use and understand. One of the key principles of REST is that it is based on the use of resources and their representations. Therefore, it’s essential to design the API’s resources and their representations in a way that is meaningful <span class="No-Break">and consistent.</span></p>
			<p>When <a id="_idIndexMarker300"/>designing resources, it’s important to use URIs that are meaningful and consistent. Resources should be named in a way that is easy to understand, and the URIs should be structured logically and hierarchically – for example, <strong class="source-inline">/users/1/orders/2</strong> is more meaningful <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">/users?id=1&amp;orderid=2</strong></span><span class="No-Break">.</span></p>
			<p>Representations of resources should be in a format that is easy to parse, such as JSON or XML. It’s also important to use the <strong class="source-inline">Content-Type</strong> and <strong class="source-inline">Accept</strong> headers to specify the format of the request and response. This allows the client to specify its preferred format and the server to provide the <span class="No-Break">appropriate representation.</span></p>
			<p>Another important aspect of a good RESTful API design is<a id="_idIndexMarker301"/> stateless communication. This means that a client and server should not maintain any state between requests. This can be achieved through the use of HTTP headers and cookies. This allows for a higher degree of scalability and flexibility, as the server does not have to maintain any state for <span class="No-Break">each client.</span></p>
			<p>Security is also<a id="_idIndexMarker302"/> an important aspect of RESTful API design. It’s important to use secure communication protocols, such as HTTPS, and to implement authentication and authorization mechanisms to protect an <span class="No-Break">API’s resources.</span></p>
			<p>In addition to the aforementioned points, good RESTful API design also includes error handling, caching, versioning, and documentation. Good documentation is essential for developers to understand how to use the API. It’s also important to provide clear and informative error messages to clients when an error occurs. In the previous chapter, we built up a database. In this chapter, we’ll now add an API to interact with the database that we built. We will use <a id="_idIndexMarker303"/>a very typical layer structure for a SaaS app that looks something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B19343_05_01.jpg" alt="Figure 5.1 – The layering structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The layering structure</p>
			<p>In the preceding diagram, we can see the database and the <strong class="bold">object–relational mapping</strong> (<strong class="bold">ORM</strong>) that we covered in previous chapters. In this chapter, we are learning about the API, so we will build a service layer to interact with the database and a controller layer to handle communication with the UI or any <span class="No-Break">other client.</span></p>
			<p>A <a id="_idIndexMarker304"/>service layer <a id="_idIndexMarker305"/>is an architectural pattern in software design that acts as an intermediary between the application’s UI and the underlying data storage. The main purpose of a service layer is to encapsulate and abstract the business logic of an application, promoting the separation of concerns and making it easier to maintain and modify the code. It also enables better unit testing, as the service layer can be tested in isolation from the rest of the application. Additionally, it can improve the scalability of an application by allowing the UI and data storage components to <span class="No-Break">evolve independently.</span></p>
			<p>In a RESTful API, controllers <a id="_idIndexMarker306"/>are responsible for handling HTTP requests from clients and returning appropriate HTTP responses. They act as an intermediary between a client and an application’s business logic, using the appropriate service layer to perform any <span class="No-Break">necessary operations.</span></p>
			<p>Controllers are responsible for mapping URLs to specific actions in an application, such as retrieving data from a database, creating new resources, or updating existing ones. They parse an incoming request to determine the desired action and then use the appropriate service layer to perform that action and generate <span class="No-Break">a response.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>An example API design</h2>
			<p>You will <a id="_idIndexMarker307"/>recall that in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we started to build out the <strong class="source-inline">HabitService</strong> API with a couple of endpoints. We’ll start from where <a id="_idIndexMarker308"/>we left off in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, but we will add a lot more functionality to <span class="No-Break">the controller!</span></p>
			<p>The three endpoints that we have already added are <span class="No-Break">the following:</span></p>
			<p>A <strong class="source-inline">GET</strong> endpoint that gets a single habit based on a <span class="No-Break">passed-in ID:</span></p>
			<pre class="source-code">
public async Task&lt;IActionResult&gt; GetAsync(int id) =&gt; Ok(await _habitService.GetById(id));</pre>
			<p>Another <strong class="source-inline">GET</strong> endpoint that returns all of <span class="No-Break">the habits:</span></p>
			<pre class="source-code">
public async Task&lt;IActionResult&gt; GetAsync() =&gt; Ok(await _habitService.GetAll());</pre>
			<p>And finally, a <strong class="source-inline">POST</strong> endpoint that will create a new habit in <span class="No-Break">the database:</span></p>
			<pre class="source-code">
public async Task&lt;IActionResult&gt; CreateAsync(CreateHabitDto request) =&gt; Ok(await _habitService.Create(request.Name, request.Description));</pre>
			<p>In this<a id="_idIndexMarker309"/> section, we <a id="_idIndexMarker310"/>will add an endpoint for each of the five primary HTTP verbs that we have discussed in this chapter. We already have <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong>, so we will add <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></p>
			<h3>DTOs</h3>
			<p>But, before we write <a id="_idIndexMarker311"/>the endpoints, we will first add the DTOs. We already have a <strong class="source-inline">CreateHabitDto</strong> that was added in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. Run the following script from the root folder, or add the <span class="No-Break">files manually:</span></p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.HabitService/Dtos; \</strong>
<strong class="bold">touch HabitDetailDto.cs; \</strong>
<strong class="bold">touch HabitDto.cs; \</strong>
<strong class="bold">touch UpdateHabitDto.cs; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>Copy the following into the <span class="No-Break"><strong class="source-inline">HabitDetailDto</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class HabitDetailDto {
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public string UserName { get; set; } = default!;
    public string GoalName { get; set; } = default!;
    public string Duration { get; set; } = default!;
}</pre>
			<p>Then add the following to the <span class="No-Break"><strong class="source-inline">HabitDto</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class HabitDto
{
    public int Id { get; set; } = default!;
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<p>And finally, add<a id="_idIndexMarker312"/> the following to the <span class="No-Break"><strong class="source-inline">UpdateHabitDto</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class UpdateHabitDto
{
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<p>That is all that is required for the DTOs. We will use these when we start to build out <span class="No-Break">the endpoints.</span></p>
			<h3>AutoMapper</h3>
			<p>We<a id="_idIndexMarker313"/> now <a id="_idIndexMarker314"/>need to consider a tool that we will use to convert between the database types and the DTOs. That tool <span class="No-Break">is AutoMapper.</span></p>
			<p>AutoMapper is an open source library that enables you to establish a configuration to convert one object to another. This can be particularly useful when translating between different types of objects, such as database entities and DTOs. Even though both the DTO and the entities might have a similar structure, their implementation can differ. This library helps to keep your codebase clean and maintainable by reducing the amount of repetitive and boilerplate mapping code that is needed to translate between different types, making your application more efficient and easier to modify or add <span class="No-Break">new features.</span></p>
			<p>AutoMapper is <a id="_idIndexMarker315"/>designed to <a id="_idIndexMarker316"/>make it easy to map one type of object to another, and it provides a simple, fluent API to define the mappings. Some of the key features of <a id="_idIndexMarker317"/><span class="No-Break">AutoMapper include:</span></p>
			<ul>
				<li>Support for flattening and unflattening of <span class="No-Break">object hierarchies</span></li>
				<li>Support for converting between different data types and <span class="No-Break">custom-type converters</span></li>
				<li>Support for advanced configuration options, such as mapping to and from interfaces and <span class="No-Break">inheritance hierarchies</span></li>
				<li>Support for custom logic and conventions to be used <span class="No-Break">during mapping</span></li>
				<li>Support for <strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) expressions to <span class="No-Break">define mappings</span></li>
			</ul>
			<p>AutoMapper can help to keep your codebase clean and maintainable by reducing the amount of repetitive, boilerplate mapping code that is required to convert between different types. This can make your application more efficient, and it makes it easier to add new features or make changes to <span class="No-Break">existing ones.</span></p>
			<p>To get started with AutoMapper, install the tool in the API project with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</strong></pre>
			<p>With the packages updated, as shown in the preceding code snippet, we can start to create mappings for the database types that we <span class="No-Break">have created.</span></p>
			<p>You will recall that we added an entity type called ‘Habit’ in the database project in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and we have added a number of additional properties to the object in <a href="B19343_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>. If you run the <strong class="source-inline">HabitService</strong> and use Thunder Client to hit the endpoint that returns all of the habits, you will see that the data which is returned includes all of these <span class="No-Break">additional properties.</span></p>
			<p>This habit class represents a database entity. It is very specific to the database and works very well to represent the idea of a good habit for that specific use case. But, it does not work well to transmit data to <span class="No-Break">the UI.</span></p>
			<p>We would rather that <a id="_idIndexMarker318"/>the data was sent to the UI in the form of a DTO, such as the one we <span class="No-Break">created previously.</span></p>
			<ul>
				<li>There is no need to include the collections for the progress updates or the reminders. Including this information could add a huge amount to the required bandwidth of <span class="No-Break">the app.</span></li>
				<li>The <strong class="source-inline">TenentName</strong> property is of no use to the user because they will already know which tenant <span class="No-Break">they are!</span></li>
			</ul>
			<p>The DTO that we have created looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class HabitDto
{
    public int Id { get; set; } = default!;
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<p>In this example, we are taking the ID, name, and description of the habit directly from the entity type, but more complex transformations are <span class="No-Break">also possible.</span></p>
			<p>While we could simply copy the properties over manually, that could quickly get very tedious, so we’ll use <strong class="source-inline">AutoMapper</strong> to do <span class="No-Break">this automatically!</span></p>
			<p>Start by going into the <strong class="source-inline">Program.cs</strong> class and adding the <span class="No-Break"><strong class="source-inline">AutoMapper</strong></span><span class="No-Break"> service:</span></p>
			<pre class="source-code">
builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());</pre>
			<p>Next, open up the <strong class="source-inline">HabitsController</strong> class, and add the following to the <strong class="source-inline">using</strong> statements: <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">AutoMapper</strong></span><span class="No-Break">.</span></p>
			<p>Then, add the following to the <span class="No-Break">class definition:</span></p>
			<pre class="source-code">
private readonly IMapper _mapper;</pre>
			<p>Next, add the <span class="No-Break"><strong class="source-inline">using</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
using AutoMapper;</pre>
			<p>Next, modify<a id="_idIndexMarker319"/> the constructor to take in the mapper, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
    public HabitsController(
        ILogger&lt;HabitsController&gt; logger,
        IHabitService goodHabitsService,
        IMapper mapper
        )
    {
        _logger = logger;
        _habitService = goodHabitsService;
        _mapper = mapper;
    }</pre>
			<p>Finally, modify the two existing <strong class="source-inline">GET</strong> endpoints in the controller to use <strong class="source-inline">AutoMapper</strong>, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
    [HttpGet("{id}")]
    public async Task&lt;IActionResult&gt; GetAsync(int id) =&gt;
      Ok(_mapper.Map&lt;HabitDto&gt;(await
      _habitService.GetById(id)));
    [HttpGet]
    public async Task&lt;IActionResult&gt; GetAsync() =&gt;
      Ok(_mapper.Map&lt;ICollection&lt;HabitDto&gt;&gt;(await
      _habitService.GetAll()));</pre>
			<p>Before, the controller was simply returning the entity object from the database, now that object is being mapped automatically to a DTO, which is returned from the controller. This does require a little <span class="No-Break">configuration, though.</span></p>
			<p>The final<a id="_idIndexMarker320"/> step is to tell <strong class="source-inline">AutoMapper</strong> how it should convert between the <span class="No-Break">two types.</span></p>
			<p>Add a folder called <strong class="source-inline">Mappers</strong> in the <strong class="source-inline">HabitService</strong> project and a class called <strong class="source-inline">HabitMapper.cs</strong>. You can use <span class="No-Break">this script:</span></p>
			<pre class="source-code">
mkdir Mappers; \
cd Mappers; \
touch HabitMapper.cs; \
cd ..;</pre>
			<p>In this class, add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using AutoMapper;
using GoodHabits.HabitService.Dtos;
using GoodHabits.Database.Entities;
namespace GoodHabits.HabitService.Mappers;
public class HabitMapper : Profile
{
    public HabitMapper()
    {
        CreateMap&lt;Habit, HabitDto&gt;();
    }
}</pre>
			<p>The <strong class="source-inline">CreateMap</strong> method instructs <strong class="source-inline">AutoMapper</strong> to map between the <span class="No-Break">two types.</span></p>
			<p>You can now hit the<a id="_idIndexMarker321"/> endpoint using Thunder Client to get the habits, and you should see something <span class="No-Break">like this:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B19343_05_02.jpg" alt="Figure 5.2 – A successful response"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A successful response</p>
			<p>This section has demonstrated how we can automatically convert between database types and types for data transfer. This is a very important piece of the API puzzle, and understanding how to operate AutoMapper will help you write better code and also reduce the amount of data sent between the API and any <span class="No-Break">connected clients.</span></p>
			<h3>Modify the service</h3>
			<p>Before <a id="_idIndexMarker322"/>we can build the additional endpoints on the API to update and delete the habits, we need to add some functionality to the service class. We already created the service class and interface in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, but we will extend the <span class="No-Break">functionality here.</span></p>
			<p>Add the following to <span class="No-Break">the interface:</span></p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using GoodHabits.HabitService.Dtos;
namespace GoodHabits.HabitService;
public interface IHabitService
{
Task&lt;Habit&gt; Create(string name, string description);
Task&lt;Habit&gt; GetById(int id);
Task&lt;IReadOnlyList&lt;Habit&gt;&gt; GetAll();
Task DeleteById(int id);
Task&lt;Habit?&gt; UpdateById(int id, UpdateHabitDto request);
}</pre>
			<p>The <strong class="source-inline">HabitService</strong> class that implements the preceding interface will need to have two methods <a id="_idIndexMarker323"/>added to delete and update the habits that are stored in the database. Add the following two methods to the <span class="No-Break"><strong class="source-inline">HabitService</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
    public async Task DeleteById(int id)
    {
        var habit = await _dbContext.Habits!.FindAsync(id)
          ?? throw new ArgumentException("User not found");
        _dbContext.Habits.Remove(habit);
        await _dbContext.SaveChangesAsync();
    }
    public async Task&lt;Habit?&gt; UpdateById(int id,
      UpdateHabitDto request)
    {
        var habit = await _dbContext.Habits!.FindAsync(id);
        if (habit == null) return null;
        habit.Name = request.Name;
        habit.Description = request.Description;
        await _dbContext.SaveChangesAsync();
        return habit;
    }</pre>
			<p>You will <a id="_idIndexMarker324"/>also need to add a <strong class="source-inline">using</strong> statement to the <span class="No-Break">service class:</span></p>
			<pre class="source-code">
using GoodHabits.HabitService.Dtos;</pre>
			<p>That is all that is required in the <span class="No-Break">service layer.</span></p>
			<p>That has been quite a lot of configuration, but we are now ready to build the <span class="No-Break">controller class.</span></p>
			<h3>Add to the controller</h3>
			<p>We have<a id="_idIndexMarker325"/> done most of the heavy lifting already by adding the DTOs, configuring AutoMapper, and building the service layer. We will need to add three additional endpoints to the controller. Let’s start with the <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> endpoint:</span></p>
			<pre class="source-code">
    [HttpDelete("{id}")]
    public async Task&lt;IActionResult&gt; DeleteAsync(int id)
    {
        await _habitService.DeleteById(id);
        return NoContent();
    }</pre>
			<p>This is pretty straightforward. It uses the service method to delete the entry in the database and then returns <strong class="source-inline">NoContent</strong> – which is considered best practice for a <span class="No-Break">delete method.</span></p>
			<p>Next, add the endpoint to update the object with the <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> verb:</span></p>
			<pre class="source-code">
    [HttpPut("{id}")]
    public async Task&lt;IActionResult&gt; UpdateAsync(int id,
      UpdateHabitDto request)
    {
        var habit = await _habitService.UpdateById(id,
          request);
        if (habit == null)
        {
            return NotFound();
        }
        return Ok(habit);
    }</pre>
			<p>There is <a id="_idIndexMarker326"/>some error trapping here, which returns <strong class="source-inline">404</strong> if the client attempts to update an entry that does <span class="No-Break">not exist.</span></p>
			<p>Finally, add the endpoint that updates an object using the <span class="No-Break"><strong class="source-inline">PATCH</strong></span><span class="No-Break"> verb:</span></p>
			<pre class="source-code">
    [HttpPatch("{id}")]
    public async Task&lt;IActionResult&gt; UpdateAsync(int id,
      [FromBody] JsonPatchDocument&lt;UpdateHabitDto&gt; patch)
    {
        var habit = await _goodHabitsService.GetById(id);
        if (habit == null) return NotFound();
        var updateHabitDto = new UpdateHabitDto { Name =
          habit.Name, Description = habit.Description };
        try
        {
            patch.ApplyTo(updateHabitDto, ModelState);
            if (!TryValidateModel(updateHabitDto)) return
              ValidationProblem(ModelState);
            await _goodHabitsService.UpdateById(id,
              updateHabitDto);
            return NoContent();
        }
        catch (JsonPatchException ex)
        {
            return BadRequest(new { error = ex.Message });
        }
    }</pre>
			<p>This is a<a id="_idIndexMarker327"/> little more involved, as it uses <strong class="source-inline">JsonPatchDocument</strong> to modify the object. You will also need to add two <span class="No-Break"><strong class="source-inline">using</strong></span><span class="No-Break"> statements:</span></p>
			<pre class="source-code">
using Microsoft.AspNetCore.JsonPatch;
using Microsoft.AspNetCore.JsonPatch.Exceptions;</pre>
			<p>That is all that we need to do at this stage. We now have a good example of the five most common HTTP verbs. Before we move on, we should test that these all work. We will use Thunder Client <span class="No-Break">for this.</span></p>
			<h3>Testing</h3>
			<p>To test the<a id="_idIndexMarker328"/> endpoint that we have just added, we will need a test client. In keeping with the theme of using <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), we <a id="_idIndexMarker329"/>will add an extension to the code so that we can do everything in one place. We have touched on this tool a couple of times already, but we will take a close look in <span class="No-Break">this section.</span></p>
			<p>You’ll see the Thunder Client icon on the <span class="No-Break">extensions toolbar:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B19343_05_03.jpg" alt="Figure 5.3 – The Thunder Client icon"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The Thunder Client icon</p>
			<p>With <a id="_idIndexMarker330"/>Thunder Client, you can hit your API straight from VS Code and check that it is behaving as expected. We’ll do this now. Start the API running by going to the terminal in VS Code, navigating to the API project, and typing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet run</pre>
			<p>This will build the project and get the API running. Now we can start adding <span class="No-Break">the tests!</span></p>
			<h4>Add a GET request</h4>
			<p>Now, complete <a id="_idIndexMarker331"/>the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Click on the Thunder Client icon (<em class="italic">if you don’t see this on the left-hand menu, exit and restart the </em><span class="No-Break"><em class="italic">Docker environment</em></span><span class="No-Break">).</span></li>
				<li>Click on the <strong class="bold">Collections</strong> tab and add a new collection <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">GoodHabits</strong></span><span class="No-Break">.</span></li>
				<li><em class="italic">Right-click</em> on the newly created collection, click <strong class="bold">New Request</strong> and add a request called <strong class="source-inline">GET </strong>Habits (don’t click on the bit below the <strong class="bold">New Request</strong> button; right-click <span class="No-Break">the collection).</span></li>
			</ol>
			<p>Your collection should look like this:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B19343_05_04.jpg" alt="Figure 5.4 – The Thunder Client collection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The Thunder Client collection</p>
			<ol>
				<li value="4">Click <a id="_idIndexMarker332"/>on the <strong class="bold">GET</strong> <span class="No-Break">user request:</span><ol><li>Set the URL <span class="No-Break">to </span><span class="No-Break">http://localhost:5100/api/habits</span><span class="No-Break">.</span></li><li>In the <strong class="bold">Headers</strong> tab, add a <strong class="source-inline">tenant</strong> key with the <strong class="source-inline">CloudSphere</strong> value (you’ll remember from <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> that we need to specify the tenant for <span class="No-Break">the multi-tenancy).</span></li></ol></li>
			</ol>
			<p>When you’re <a id="_idIndexMarker333"/>done, it should look like this:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B19343_05_05.jpg" alt="Figure 5.5 – The configured request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The configured request</p>
			<p>The preceding screenshot shows a correctly configured <strong class="source-inline">GET</strong> request that should return all of the habits in <span class="No-Break">the database.</span></p>
			<p>Finally, click<a id="_idIndexMarker334"/> the <strong class="bold">Send</strong> button to issue the <strong class="source-inline">GET</strong> request and test the endpoint. You will see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B19343_05_06.jpg" alt="Figure 5.6 – The returned habits"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The returned habits</p>
			<p>We have put in quite a lot of work to get to this stage! We are showing the data from the <strong class="source-inline">SeedData</strong> file in the database project, returned from our <strong class="source-inline">HabitsService</strong>. We will shortly build a UI to present <span class="No-Break">this information.</span></p>
			<h4>Add a POST request</h4>
			<p>Repeat the <a id="_idIndexMarker335"/>preceding, building a <strong class="source-inline">POST</strong><strong class="bold"> </strong>user request. In this case, we’ll need to specify the habit details in the body in <span class="No-Break">JSON format:</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B19343_05_07.jpg" alt="Figure 5.7 – The configured POST request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The configured POST request</p>
			<p>You can see that the JSON specified matches the <span class="No-Break"><strong class="source-inline">CreateHabitDto</strong></span><span class="No-Break"> class.</span></p>
			<p>Don’t forget to set the tenant in the header and change the request type to <strong class="source-inline">POST</strong>! Hitting <strong class="bold">Send</strong> will confirm that the habit has <span class="No-Break">been created.</span></p>
			<p>So far, we have tested the <strong class="source-inline">get all</strong> endpoint and the <strong class="source-inline">POST</strong> endpoint. It would be a useful exercise to add another <strong class="source-inline">GET</strong> to test the <strong class="source-inline">get-by-id</strong> endpoint <span class="No-Break">as well!</span></p>
			<h4>Add a DELETE request</h4>
			<p>We may <a id="_idIndexMarker336"/>want to delete a habit from the database, so we have added the required methods to the service and the controller. We can test this again in the <span class="No-Break">same way:</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B19343_05_08.jpg" alt="Figure 5.8 – The configured DELETE request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The configured DELETE request</p>
			<p>The <a id="_idIndexMarker337"/>preceding screenshot shows that no content is required in the body. But don’t forget to add the <span class="No-Break">tenant header!</span></p>
			<h4>Add a PUT request</h4>
			<p>Testing<a id="_idIndexMarker338"/> the <strong class="source-inline">PUT</strong> endpoint that we have added is fairly straightforward. Configure a <strong class="source-inline">PUT</strong> request <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B19343_05_09.jpg" alt="Figure 5.9 – The configured PUT request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The configured PUT request</p>
			<p>The preceding figure shows how to configure a <strong class="source-inline">PUT</strong> request. This will alter the name and description of the habit with <strong class="source-inline">id=103</strong>. You may need to change the ID in the URL if you have made changes to the data along the way. You can check that this has made the changes by<a id="_idIndexMarker339"/> hitting the <strong class="source-inline">get-by-id</strong> <span class="No-Break">endpoint again.</span></p>
			<h4>Add a PATCH request</h4>
			<p>Testing<a id="_idIndexMarker340"/> the <strong class="source-inline">PATCH</strong> endpoint is a little more tricky. You will recall that the <strong class="source-inline">PATCH</strong> endpoint that we built in the controller is expecting a <strong class="source-inline">JsonPatchDocument</strong> object, so this is what we will have to supply. A <strong class="source-inline">Patch</strong> document could look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[
    {
        "op": "replace",
        "path": "/Name",
        "value": "A New Name"
    }
]</pre>
			<p>The preceding code uses the <strong class="source-inline">replace</strong> operator to change the value of the <strong class="source-inline">Name</strong> variable. We can set up the request <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B19343_05_10.jpg" alt="Figure 5.10 – The configured PATCH request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The configured PATCH request</p>
			<p>Configuring this and hitting send will update the habit with <strong class="source-inline">id=103</strong>. Again, you may need to change the ID in <span class="No-Break">the URL.</span></p>
			<p>You will <a id="_idIndexMarker341"/>notice that the service will return a <strong class="source-inline">204 No Content</strong> response upon a successful patch. This is the expected behavior and is considered best practice for the response to a <span class="No-Break">successful </span><span class="No-Break"><strong class="source-inline">PATCH</strong></span><span class="No-Break">.</span></p>
			<p>This would be a good time to talk a bit more about <span class="No-Break">HTTP codes!</span></p>
			<h3>Using the correct HTTP codes</h3>
			<p>Earlier in this chapter, we <a id="_idIndexMarker342"/>talked about HTTP status codes, and we looked at a few that may be useful to consider, even for the very basic examples we <span class="No-Break">saw previously.</span></p>
			<p>The two that we should add and test are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>If a request is made to get a user that does not exist, the correct status code should be <strong class="source-inline">404 </strong><span class="No-Break"><strong class="source-inline">Not found</strong></span></li>
				<li>If a successful request is made to create a new user, the correct status code should be <span class="No-Break"><strong class="source-inline">201 Created</strong></span></li>
			</ul>
			<p>Because we have separated the service and the controller, we do not have to change any of the service logic to facilitate this. The controller has the sole responsibility for assigning the HTTP status codes. While the example here is fairly straightforward, I hope you can see how separating the logic in this way can be very beneficial when things start to get <span class="No-Break">more complex.</span></p>
			<p>We’ll start by modifying the <strong class="source-inline">GET</strong> method, which takes an <strong class="source-inline">id</strong> parameter to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
    [HttpGet("{id}")]
    public async Task&lt;IActionResult&gt; GetAsync(int id)
    {
        var habit = await _habitService.GetById(id);
        if (habit == null) return NotFound();
        return Ok(_mapper.Map&lt;HabitDto&gt;(await
          _habitService.GetById(id)));
    }</pre>
			<p>We <a id="_idIndexMarker343"/>have simply added a check to see whether the user object is <strong class="source-inline">null</strong>, and if so, we return <strong class="source-inline">NotFound()</strong>, which will return the <strong class="source-inline">404</strong> <span class="No-Break">status code.</span></p>
			<p>You can test this in Thunder Client by requesting a user ID that you know doesn’t exist in <span class="No-Break">your database:</span></p>
			<p class="IMG---Figure">    </p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B19343_05_11.jpg" alt="Figure 5.11 – Habit not found"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Habit not found</p>
			<p>In the preceding screenshot, we have demonstrated that requesting a non-existent user now results in a <strong class="source-inline">404</strong> HTTP <span class="No-Break">status code.</span></p>
			<p>Next, let’s fix the HTTP code to create a new user. Modify the <strong class="source-inline">Create</strong> endpoint to look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
    [HttpPost]
    public async Task&lt;IActionResult&gt;
      CreateAsync(CreateHabitDto request)
    {
        var habit = await _habitService
          .Create(request.Name, request.Description);
        var habitDto = _mapper.Map&lt;HabitDto&gt;(habit);
       return CreatedAtAction("Get", "Habits", new { id =
         habitDto.Id }, habitDto);
    }</pre>
			<p>We have <a id="_idIndexMarker344"/>changed the return from <strong class="source-inline">Ok()</strong> to <strong class="source-inline">CreatedAtAction(…)</strong>. This will return <strong class="source-inline">201 – Created</strong> and also the location of the newly created resource to <span class="No-Break">the user.</span></p>
			<p>If you go back into Thunder Client and create another user, you will see <span class="No-Break">the following:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B19343_05_12.jpg" alt="Figure 5.12 – Created with a 201 status code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Created with a 201 status code</p>
			<p>Clicking on the <strong class="bold">Headers</strong> tab will give you the location of the newly created resource. This can be very useful to consumers of your API who may want to interact with the new <span class="No-Break">resource immediately.</span></p>
			<p>If you look at the <strong class="source-inline">PUT</strong> and the <strong class="source-inline">PATCH</strong> endpoints in <strong class="source-inline">HabitsController</strong>, you can see that we are returning a few different status codes depending on what has happened when processing the response. It would be a good exercise to go through these and convince yourself that you have understood why each of them has <span class="No-Break">been selected.</span></p>
			<p>If you look at the <strong class="source-inline">PATCH</strong> endpoint, you will see that it<a id="_idIndexMarker345"/> performs the <span class="No-Break">following actions:</span></p>
			<ul>
				<li>It checks to see whether the ID provided is valid and, if not, returns <strong class="source-inline">404 – </strong><span class="No-Break"><strong class="source-inline">Not Found</strong></span></li>
				<li>It checks to see whether the updated model is valid and, if not, returns a validation problem (a subset of <strong class="source-inline">400 </strong><span class="No-Break"><strong class="source-inline">Bad Request</strong></span><span class="No-Break">)</span></li>
				<li>If there are any other issues with the update, it returns <strong class="source-inline">400 </strong><span class="No-Break"><strong class="source-inline">Bad Request</strong></span></li>
				<li>If there are no issues, it returns <strong class="source-inline">204 </strong><span class="No-Break"><strong class="source-inline">No Content</strong></span></li>
			</ul>
			<p>The <strong class="source-inline">No Content</strong> HTTP status code (<strong class="source-inline">204</strong>) is used to indicate that the server has successfully processed the request and that there is no response body to return. In the case of a <strong class="source-inline">PATCH</strong> request, the <strong class="source-inline">No Content</strong> status code is used to indicate that the server has successfully processed the update to the resource without returning any content in the <a id="_idIndexMarker346"/>response. The idea is that the client already knows what the updated resource looks like, and therefore, there is no need to return the updated resource information in the response. The client can simply assume that the update was successful and that the resource was updated <span class="No-Break">as requested.</span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Versioning public APIs</h1>
			<p>Versioning <a id="_idIndexMarker347"/>public RESTful APIs is the process of creating and maintaining multiple versions of an API to accommodate changes and new features. This ensures that existing clients are not affected by changes made to the API and that new clients can take advantage of the <span class="No-Break">new features.</span></p>
			<p>Versioning is a <a id="_idIndexMarker348"/>critical aspect of API development and maintenance because it enables the evolution of an API over time while maintaining compatibility with existing clients. This is particularly important in cases where APIs are used by multiple clients, and breaking changes would impact the functionality of those clients. With versioning, multiple versions of an API can coexist, and clients can choose to upgrade to the latest version or continue using an earlier version that suits their needs. This way, versioning provides the necessary flexibility for APIs to evolve and improve over time without disrupting the stability of <span class="No-Break">existing integrations.</span></p>
			<p>There are several strategies to version RESTful APIs, each with its own advantages <span class="No-Break">and disadvantages:</span></p>
			<ul>
				<li><strong class="bold">URL versioning</strong>: This<a id="_idIndexMarker349"/> strategy involves including <a id="_idIndexMarker350"/>the version number in the URI of the API, such as <strong class="source-inline">/v1/users</strong> or <strong class="source-inline">/v2/users</strong>. This approach is easy to implement and understand, but it can be difficult to maintain and scale as the number of <span class="No-Break">versions increases.</span></li>
				<li><strong class="bold">Custom header versioning</strong>: This<a id="_idIndexMarker351"/> strategy <a id="_idIndexMarker352"/>involves including the version number in a custom header, such as <strong class="source-inline">X-API-Version</strong>. This approach allows for more flexibility, as the URI does not have to change, but it can be more complex to implement and may not be supported by <span class="No-Break">all clients.</span></li>
				<li><strong class="bold">Media type versioning</strong>: This <a id="_idIndexMarker353"/>strategy involves <a id="_idIndexMarker354"/>using different media types to represent different versions of the API, such as <strong class="source-inline">application/vnd.example.v1+json</strong> or <strong class="source-inline">application/vnd.example.v2+json</strong>. This approach allows for more flexibility, as the URI and headers do not have to change, but it can be more complex to implement and may not be supported by <span class="No-Break">all clients.</span></li>
				<li><strong class="bold">Deprecation and sunsetting</strong>: This <a id="_idIndexMarker355"/>strategy involves marking old versions of the API as deprecated and eventually sunsetting them. This approach allows for a gradual transition and gives clients time to update their code before the old version <span class="No-Break">is removed.</span></li>
			</ul>
			<p>It is worth <a id="_idIndexMarker356"/>noting that the most appropriate versioning strategy will depend on the specific needs of an API and its clients. It’s important to communicate the versioning strategy and the timeline for the deprecation of old versions to the API’s clients in order to minimize disruption and allow them to <span class="No-Break">plan accordingly.</span></p>
			<p>The most common way to version an API is to include the version number in the URL of the API endpoint. For example, the URL of an API endpoint might look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
https://api.example.com/v1/resources</pre>
			<p>This method allows different versions of an API to coexist and makes it easy to manage changes to the API over time by simply changing the version number in the URL. This also allows clients to choose which version of the API they want to use in their applications, and it helps prevent breaking changes in the API from affecting existing <span class="No-Break">client applications.</span></p>
			<p>If a second version of the preceding example was created, it could be found at the <span class="No-Break">following link:</span></p>
			<pre class="source-code">
https://api.example.com/v2/resources</pre>
			<p>A huge benefit <a id="_idIndexMarker357"/>of this is that both versions can exist at the same time and users who have clients that still expect the <strong class="source-inline">v1</strong> version can continue to work seamlessly. Of course, supporting multiple versions can be hard, and ideally, this would be a transient state with the intention to deprecate the <strong class="source-inline">v1</strong> version at <span class="No-Break">some point.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Example code showing how to version an API</h2>
			<p>Previously<a id="_idIndexMarker358"/> in this chapter, we built a controller to manage the users and added a number of endpoints to it. We have not yet added any versioning to the API, though; note that the URLs that we have tested with (using Thunder Client) do not have a version associated with them, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
http://localhost:5100/api/habits</pre>
			<p>Let’s <span class="No-Break">change that!</span></p>
			<p>Start by opening a console and adding the versioning package to the <span class="No-Break"><strong class="source-inline">HabitService</strong></span><span class="No-Break"> project:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet add package Microsoft.AspNetCore.Mvc.Versioning</strong></pre>
			<p>Add the <strong class="source-inline">using</strong> statement <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">Program.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc.Versioning;</pre>
			<p>Next, copy the following <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">Program.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
builder.Services.AddApiVersioning(opt =&gt;
    {
        opt.DefaultApiVersion = new
          Microsoft.AspNetCore.Mvc.ApiVersion(1,0);
        opt.AssumeDefaultVersionWhenUnspecified = true;
        opt.ReportApiVersions = true;
        opt.ApiVersionReader = ApiVersionReader.Combine(new
          UrlSegmentApiVersionReader(),
          new HeaderApiVersionReader("x-api-version"),
          new MediaTypeApiVersionReader("x-api-version"));
    });</pre>
			<p>Let’s review the <a id="_idIndexMarker359"/>preceding code <span class="No-Break">in detail:</span></p>
			<ul>
				<li>The first flag sets the default API version. This allows a client to work with the API without specifying <span class="No-Break">a version.</span></li>
				<li>The second flag instructs the application to use the default if nothing is specified. This is an example of defensive programming – your users will thank you <span class="No-Break">for this!</span></li>
				<li>The third flag is returns options – this returns the available versions in the response header so that a calling client can see that there are options available for <span class="No-Break">that method.</span></li>
				<li>Finally, <strong class="source-inline">ApiVersionReader</strong> makes it possible for clients to choose whether to put the version in the URL or the request header. Again, it’s good to give consumers of the API the choice <span class="No-Break">in this.</span></li>
			</ul>
			<p>Now, we need to update <strong class="source-inline">HabitsController</strong> to work with <span class="No-Break">multiple versions.</span></p>
			<p>To illustrate this point, we’ll just use a simple <strong class="source-inline">GET</strong> endpoint. But you can apply the same logic to any of <span class="No-Break">the endpoints.</span></p>
			<p>Change the attributes of the <strong class="source-inline">HabitsController</strong> class to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[ApiController]
[Route("api/[controller]")]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0")]</pre>
			<p>Let’s prove what we have done by adding an endpoint to the controller and mapping it to <strong class="source-inline">version 1.0</strong>, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
    [MapToApiVersion("1.0")]
    [HttpGet("version")]
    public virtual async Task&lt;IActionResult&gt; GetVersion()
    {
        return Ok("Response from version 1.0");
    }</pre>
			<p>We have<a id="_idIndexMarker360"/> flagged this method as virtual so that we can override it in a <span class="No-Break">subsequent version.</span></p>
			<p>Create a file called <strong class="source-inline">HabitsControllerv2.cs</strong> and add the following <span class="No-Break">to it:</span></p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
namespace GoodHabits.HabitService.Controllers.v2;
[ApiController]
[Route("api/[controller]")]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("2.0")]
public class HabitsController : ControllerBase
{
    [MapToApiVersion("2.0")]
    [HttpGet("version")]
    public virtual IActionResult GetVersion()
    {
        return Ok("Response from version 2.0");
    }
}</pre>
			<p>Note that this maps the <strong class="source-inline">version</strong> endpoint to the <strong class="source-inline">v2</strong> API. You can test this in Thunder Client in the usual way, and you will see that changing the version you provide in the URL changes which response <span class="No-Break">you get.</span></p>
			<p>Also, note that we have specified the <strong class="source-inline">Route</strong> attribute twice – once with the version included and <a id="_idIndexMarker361"/>once without. This allows the default versioning that we specified in <strong class="source-inline">Program.cs</strong> to <span class="No-Break">take effect.</span></p>
			<p>In Thunder Client, run three tests – one test without a version, one with <strong class="source-inline">v1</strong>, and one <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">v2</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>No <span class="No-Break">version: </span><span class="No-Break">http://localhost:5100/api/Habits/version</span></li>
				<li>Version <span class="No-Break">1: </span><span class="No-Break"><strong class="source-inline">http://localhost:5100/api/v1/Habits/version</strong></span></li>
				<li>Version <span class="No-Break">2: </span><span class="No-Break"><strong class="source-inline">http://localhost:5100/api/v2/Habits/version</strong></span></li>
			</ul>
			<p>You will see that the first one returns <strong class="source-inline">v1</strong>, as that is the default, and you will see that the other two perform as you <span class="No-Break">would expect.</span></p>
			<p>You should also note that the requests that we previously set up in Thunder Client continue to operate as expected. This is great from the point of view of a consumer of the API. We have just introduced versioning and added <strong class="source-inline">v2</strong> without breaking any <span class="No-Break">existing functionality!</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Testing APIs</h1>
			<p>In this <a id="_idIndexMarker362"/>chapter, we have demonstrated quite extensively how to test your API using Thunder Client. Testing APIs (and testing in general) is a huge subject that could be the subject of a book on its own. If you are interested, I have provided some pointers for further reading in the <span class="No-Break">following section!</span></p>
			<p>The following list provides some examples of the type of testing that you may want to carry out to ensure that your API is functioning correctly. Unit testing involves testing individual components of an API to ensure that they are working as expected. This is typically done using a unit testing framework, such as NUnit, and can <span class="No-Break">be automated:</span></p>
			<ul>
				<li>Functional testing involves testing an API end to end to ensure that all the components are working together correctly. This can be done manually or by using an automated testing tool, such as Selenium <span class="No-Break">or TestComplete.</span></li>
				<li>Integration testing involves testing an API in conjunction with other systems, such as a database or other API. This can be done using an integration testing framework, such as Cucumber <span class="No-Break">or FitNesse.</span></li>
				<li>Performance testing involves testing an API to ensure that it can handle the expected load and is <span class="No-Break">performing optimally.</span></li>
				<li>Security testing involves testing an API to ensure that it is secure and not vulnerable to common security threats, such as SQL injection or cross-site scripting. This can be done using a security testing tool, such as Nessus or <span class="No-Break">OWASP ZAP.</span></li>
				<li>Usability testing involves testing an API to ensure that it is easy to use and understand. This can be done manually or by using a usability testing tool, such as UserTesting or <span class="No-Break">Crazy Egg.</span></li>
				<li>Postman is a popular tool for testing RESTful APIs. It allows developers to easily create, send, and analyze HTTP requests. It has a user-friendly interface and supports various features, such as request and response validation, environment variables, and automated testing. It also allows us to test end-to-end scenarios, and it can be integrated with other tools such <span class="No-Break">as Jenkins.</span></li>
			</ul>
			<p>It’s worth <a id="_idIndexMarker363"/>noting that testing RESTful APIs is an ongoing process that should be done throughout the development process, not just at the end. This will help to ensure that an API works as expected and any issues are identified and <span class="No-Break">resolved quickly.</span></p>
			<p>In this chapter, we have demonstrated testing an API using Thunder Client inside VS Code. This is a very useful tool, with the benefit that the tests that are defined are saved in the repo and are checked against <span class="No-Break">the code.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/>Summary</h1>
			<p>We have covered a <em class="italic">lot</em> in this chapter! I hope it has not been overwhelming! We started at the start with a definition of REST. Then, we covered HTTP status codes and HTTP verbs to give some background on some of the underlying fundamentals of <span class="No-Break">REST APIs.</span></p>
			<p>We then looked at an example, covered the five most important HTTP verbs (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">PATCH</strong>), and showed how we could build them and test them with Thunder Client right within <span class="No-Break">VS Code!</span></p>
			<p>We also looked at <strong class="source-inline">AutoMapper</strong> and how to simplify object conversions to create DTOs from <span class="No-Break">entity types.</span></p>
			<p>Finally, we worked through an example of how to version an API and looked at some additional <span class="No-Break">testing techniques.</span></p>
			<p>In the next chapter, we will consider microservices, and we’ll look at how we can break up this application into a number of <span class="No-Break">smaller microservices!</span></p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Further reading</h1>
			<ul>
				<li>HTTP response status <span class="No-Break">codes: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</span></a></li>
				<li>Using HTTP Methods for RESTful <span class="No-Break">Services: </span><a href="https://www.restapitutorial.com/lessons/httpmethods.html"><span class="No-Break">https://www.restapitutorial.com/lessons/httpmethods.html</span></a></li>
				<li>HATEOAS and Why It’s Needed in RESTful <span class="No-Break">API? </span><a href="https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/"><span class="No-Break">https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/</span></a></li>
				<li>Testing an <span class="No-Break">API: </span><a href="https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/"><span class="No-Break">https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/</span></a></li>
				<li>How to use API versioning in ASP.NET Core Web API and integrate it with Swagger using .NET <span class="No-Break">6: </span><a href="https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/"><span class="No-Break">https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/</span></a></li>
			</ul>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/>Questions</h1>
			<ol>
				<li>What are the advantages of using <strong class="source-inline">PATCH</strong> <span class="No-Break">over </span><span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break">?</span></li>
				<li>What is the benefit of <span class="No-Break">using AutoMapper?</span></li>
				<li>What HTTP code should be used when a new resource has <span class="No-Break">been created?</span></li>
				<li>What does the <strong class="source-inline">500</strong> range of HTTP <span class="No-Break">codes signify?</span></li>
				<li>What does REST <span class="No-Break">stand for?</span></li>
				<li>What is the purpose <span class="No-Break">of DTOs?</span></li>
			</ol>
		</div>
	</body></html>