<html><head></head><body>
        

                            
                    <h1 class="header-title">Object Pool</h1>
                
            
            
                
<p>The Object Pool pattern is straightforward to understand; as its name suggests, it organizes a pool of objects. The simplest way to visualize the design intent behind this pattern is to imagine a swimming pool filled to the brim with balloons of various colors. If you wish, you can take all the green ones out, play with them and, once done, put them back. In other words, you always have a collection of specific types of objects ready to be used, and a place to store them afterward.</p>
<p>If we translate this concept into code, what we have is specific types of objects already contained in memory, which we can pull from when we need and then pool them back into memory when we are finished. This approach means we are using a constant size of reserved memory for specific types of ready-made objects. As you may already presume, this is a very optimized way of managing objects for a video game project.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will review the basics of the Object Pool pattern</li>
<li>We will implement the Object Pool pattern to manage reusable game objects for a zombie game</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">This chapter is hands-on; you will need to have a basic understanding of Unity and C#.<br/></p>
<p>We will be using the following specific Unity engine and C# language concepts:</p>
<ul>
<li>Prefabs</li>
<li>Singletons</li>
<li>Namespaces</li>
</ul>
<p>If you are unfamiliar with these concepts, please review them before starting this chapter.</p>
<p class="mce-root"/>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2WutcB2">http://bit.ly/2WutcB2</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Object Pool pattern</h1>
                
            
            
                
<p>The Object Pool pattern is usually defined as a creational design pattern in academic documentation, but in this book, we have categorized it as an optimization pattern, because its core purpose is more aligned with optimization than the creation process – at least in the way we are going to use it.</p>
<p>The core concept of this pattern is simple; a pool in the form of a container holds a collection of initialized objects. Clients can request the Object Pool for a specific type and number of objects. The Client must return the objects to the Object Pool once it's done using them. So, this means the pool always get filled back up, and is never drained.</p>
<p>The following diagram illustrates the back and forth between the <kbd>Client</kbd> and the <kbd>ObjectPool</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/55cefb52-61e0-4305-8ec2-5a7e41f4307c.png" style="width:29.58em;height:23.17em;"/></p>
<p>As you can see, the <kbd>Reusable Object</kbd> is always in memory; it is just its owner that switches between the Client and <kbd>ObjectPool</kbd>, depending on whether it's in an acquired or released state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>The Object Pool pattern is quite popular with Unity developers, but it has its critics in the broader software development community:</p>
<p><strong>Benefits</strong>:</p>
<ul>
<li><strong>Predictable memory usage</strong>: Because the Object Pool pattern is configurable, you can set limits for the number of instances of specific objects available.</li>
<li><strong>Performance boost</strong>: By having objects already initialized in memory, you avoid the loading cost of initializing new ones.</li>
</ul>
<p><strong>Drawbacks</strong>:</p>
<ul>
<li><strong>Layering on already-managed memory</strong>: Some criticize the Object Pool pattern as being unnecessary in most cases, because modern managed programming languages such as C# already optimally control memory allocation.</li>
<li><strong>Unpredictable object states</strong>: The main pitfall of the Object Pool pattern is that, if incorrectly managed, objects will be returned to the pool in their current state instead of their default one. This issue can cause unpredictable behaviors the next time they are pulled out of the pool, because objects might be in an unexpected state.</li>
</ul>
<p>Object pools have a lot of added value for mobile games, because phones have limited memory and resources compared to the average PC or console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p class="mce-root">As with the other creational patterns, the Object Pool can be a great pattern to use when designing a spawn system. But, this time, we will focus on having a Client pulling and pooling directly from an Object Pool without any layers of abstraction between them, so we can see the system at work.</p>
<p>Just to give some context to the following code example, let's imagine we are doing a <em>Plants versus Zombies</em> clone. Like most zombie games, we have hordes of zombies moving toward a target. Each horde can contain various types of zombies, such as the following:</p>
<ul>
<li>Walkers</li>
<li>Runners</li>
</ul>
<p>But, what's important to consider is that every time our player kills one of them, instead of destroying the instance of the defeated zombie in memory, we can instead send it back to an Object Pool so that it can be used again afterward. With this approach, we are recycling our zombie-type entities instead of initializing new ones.</p>
<p>In the next section, we will implement this use case and adapt it, so that it works with Unity's GameObjects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>This chapter might be difficult to follow just by reading the code, because we are managing prefabs inside a scene. So, we recommend that you download the Unity project associated with this book on our Git depot at <a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a>.<a href="https://github.com/keagancarneiro/Hands-On-Game-Development-Patterns-with-Unity-2018"/></p>
<p>In the Unity project, there should be a folder named Object Pool, with a scene included that will have the entire set of dependencies to run this example properly.</p>
<p>But, in case the GitHub address is unavailable, here's a quick list of steps that need to be done in order to execute the following code example inside a Unity scene:</p>
<ol>
<li>Open a new scene, add an empty <kbd>GameObject</kbd>, and name it <kbd>Object Pool</kbd>.</li>
<li>Create a set of prefabs and related scripts for each type of zombie. Here are some examples of zombie behavior scripts:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>Runner</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Zombie<br/>{<br/>    public class Runner : MonoBehaviour<br/>    {<br/>        public void Run()<br/>        {<br/>            // Zombie runs!<br/>        }<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>Walker</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Zombie<br/>{<br/>    public class Walk: MonoBehaviour<br/>    {<br/>        public void Walk()<br/>        {<br/>            // Zombie walks!<br/>        }<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>Screamer</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Zombie<br/>{<br/>    public class Screamer : MonoBehaviour<br/>    {<br/>        public void Scream()<br/>        {<br/>            // Zombie screams!<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>Attach the <kbd>ObjectPool</kbd> script to the <kbd>GameObject</kbd> Object Pool.</li>
</ol>
<ol start="4">
<li>In the inspector of the <kbd>GameObject</kbd> Object Pool, configure the list of zombie prefabs that the <kbd>ObjectPool</kbd> instance will manage. You can refer to the following screenshot for reference:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/43532542-f677-4cd0-9daf-34be205bf351.png" style="width:24.92em;height:17.75em;"/></p>
<p>Now, it's time for us to write the <kbd>ObjectPool</kbd> class. As you will see, it's quite long, so it's essential we read through it, and review its core features afterward:</p>
<pre>using UnityEngine;<br/>using System.Collections.Generic;<br/><br/>public class ObjectPool : Singleton&lt;ObjectPool&gt;<br/>{<br/>        // The objects to pool.<br/>        public GameObject[] objects;<br/><br/>        // The list of pooled objects.<br/>        public List&lt;GameObject&gt;[] pooledObjects;<br/><br/>        // The amount of objects to buffer.<br/>        public int[] amountToBuffer;<br/><br/>        public int defaultBufferAmount = 3;<br/><br/>        // The container of pooled objects.<br/>        protected GameObject containerObject;<br/><br/>        void Start()<br/>        {<br/>            containerObject = new GameObject("ObjectPool");<br/>            pooledObjects = new List&lt;GameObject&gt;[objects.Length];<br/><br/>            int i = 0;<br/>            foreach (GameObject obj in objects)<br/>            {<br/>                pooledObjects[i] = new List&lt;GameObject&gt;();<br/><br/>                int bufferAmount;<br/><br/>                if (i &lt; amountToBuffer.Length)<br/>                {<br/>                    bufferAmount = amountToBuffer[i];<br/>                }<br/>                else<br/>                {<br/>                    bufferAmount = defaultBufferAmount;<br/>                }<br/><br/>                for (int n = 0; n &lt; bufferAmount; n++)<br/>                {<br/>                    GameObject newObj = Instantiate(obj) as GameObject;<br/>                    newObj.name = obj.name;<br/>                    PoolObject(newObj);<br/>                }<br/><br/>                i++;<br/>            }<br/>        }<br/><br/>        // Pull an object of a specific type from the pool.<br/>        public GameObject PullObject(string objectType)<br/>        {<br/>            bool onlyPooled = false;<br/>            for (int i = 0; i &lt; objects.Length; i++)<br/>            {<br/>                GameObject prefab = objects[i];<br/><br/>                if (prefab.name == objectType)<br/>                {<br/>                    if (pooledObjects[i].Count &gt; 0)<br/>                    {<br/>                        GameObject pooledObject = pooledObjects[i][0];<br/>                        pooledObject.SetActive(true);<br/>                        pooledObject.transform.parent = null;<br/><br/>                        pooledObjects[i].Remove(pooledObject);<br/><br/>                        return pooledObject;<br/>                    }<br/>                    else if (!onlyPooled)<br/>                    {<br/>                        return Instantiate(objects[i]) as GameObject;<br/>                    }<br/><br/>                    break;<br/>                }<br/>            }<br/><br/>            // Null if there's a hit miss.<br/>            return null;<br/>        }<br/><br/>        // Add object of a specific type to the pool.<br/>        public void PoolObject(GameObject obj)<br/>        {<br/>            for (int i = 0; i &lt; objects.Length; i++)<br/>            {<br/>                if (objects[i].name == obj.name)<br/>                {<br/>                    obj.SetActive(false);<br/>                    obj.transform.parent = containerObject.transform;<br/>                    pooledObjects[i].Add(obj);<br/>                    return;<br/>                }<br/>            }<br/><br/>            Destroy(obj);<br/>        }<br/>    }</pre>
<p>So, here's a quick breakdown of what's happening in the <kbd>ObjectPool</kbd> class in each function:</p>
<ul>
<li><kbd>Start()</kbd>: In this function, we are initializing a <kbd>list()</kbd> that will contain instances of our pooled objects.</li>
<li><kbd>PullObject()</kbd>: By calling this function, Clients can request an instance of an object from the pool just by specifying the name of its type. If we have it in store, we return its instance; if not, we initialize a new instance of it.</li>
<li><kbd>PoolObject()</kbd>: A client can use this function to return instances of objects to the pool. <kbd>ObjectPool</kbd> will deactivate the returning object and attach it back to itself as a child, so it can keep it contained.</li>
</ul>
<p>We can also see that our <kbd>ObjectPool</kbd> class is a singleton; this is a common approach, because we usually need to have Object Pools globally accessible and always available. To learn how to implement a singleton, please review <a href="b8d60568-5961-4e57-b722-36028db5d1a9.xhtml">Chapter 6</a>, <em>Singleton</em>.</p>
<p>The next step is to test out our <kbd>ObjectPool</kbd> with a <kbd>Client</kbd> class:</p>
<pre>using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>            if (Input.GetKeyDown(KeyCode.G))<br/>            {<br/>                GameObject walker = ObjectPool.Instance.PullObject("Walker");<br/>                walker.transform.Translate(Vector3.forward * Random.Range(-5.0f, 5.0f));<br/>                walker.transform.Translate(Vector3.right * Random.Range(-5.0f, 5.0f));<br/>            }<br/><br/>            if (Input.GetKeyDown(KeyCode.P))<br/>            {<br/>                object[] objs = GameObject.FindObjectsOfType(typeof(GameObject));<br/><br/>                foreach (object o in objs)<br/>                {<br/>                    GameObject obj = (GameObject)o;<br/><br/>                    if (obj.gameObject.GetComponent&lt;Zombie.Walker&gt;() != null)<br/>                    {<br/>                        ObjectPool.Instance.PoolObject(obj);<br/>                    }<br/>                }<br/>            }<br/>        }</pre>
<p class="mce-root">Our <kbd>Client</kbd> class is quite straightforward:</p>
<ul>
<li>If the player presses <em>G</em>, we request an instance of a Walker zombie from the <kbd>ObjectPool</kbd>. Then, we place it randomly in the scene.</li>
</ul>
<ul>
<li>If the player presses <em>P</em>, we send all the Walker objects that are currently in our scene back into the pool.</li>
</ul>
<p>And that's it; with one class, we can implement a simple, configurable, and extensible Object Pool.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have just added the Object Pool pattern to our toolkit; it's one of the most useful patterns for Unity developers because, as we saw in our code example, we can easily recycle GameObjects that are already in our scene without having to initialize new ones. When dealing with huge prefabs that contain a lot of data and components to initialize, this pattern can help you avoid inconsistent frame rates.</p>
<p>In the next chapter, we are going to explore the Spatial Partition pattern—a subject matter that's quite important to understand when building open-world games.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p class="mce-root">Now that you have learned all the core creational patterns, such as Factory, Prototype, and Object Pool, it would be a valuable practical exercise to combine all those patterns and build the ultimate Spawn System. The goal is to have a system that reuses instances of objects of specific types and only creates new ones when it's necessary, and, if it does, uses a Factory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Game Programming Patterns</em> by Robert Nystrom<strong><br/></strong><a href="http://gameprogrammingpatterns.com/">http://gameprogrammingpatterns.com</a><a href="http://gameprogrammingpatterns.com/"/></li>
</ul>


            

            
        
    </body></html>