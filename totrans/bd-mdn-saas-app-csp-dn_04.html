<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-101" class="chapter-number"><a id="_idTextAnchor102"/>4</h1>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Building Databases and Planning for Data-Rich Applications</h1>
			<p>In previous chapters, we established a foundational SaaS application consisting of a straightforward database with a single table. This database was connected to an API, and we showcased secure multi-tenancy implementation using SQL Server, .NET, and <span class="No-Break">Entity Framework.</span></p>
			<p>In this chapter, we will delve deeper into the intricacies of the database layer and its interactions with Entity Framework. As the bedrock of an entire application, the design choices made at the database level will influence every subsequent layer in the stack. We will explore how to construct and design resilient databases for data-intensive SaaS applications. You will acquire a variety of skills, such as normalization, indexing, performance optimization, as well as techniques to test and maintain <span class="No-Break">the database.</span></p>
			<p>Once deployed, a database often represents the most demanding aspect of a system to keep current. The database is inherently stateful, and it is crucial to prevent data loss or corruption during updates. In addition to learning about database design and construction, we will examine several strategies to maintain and update the database, with an emphasis on the tools provided by <span class="No-Break">Entity Framework.</span></p>
			<p>The expertise you gain in this chapter is vital to create scalable and dependable SaaS applications. By mastering the methods discussed in this chapter, you will be capable of designing databases optimized for performance, scalability, and maintainability, thereby facilitating the development and maintenance of your <span class="No-Break">SaaS applications.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The importance of data in a <span class="No-Break">SaaS application</span></li>
				<li>Building a database using SQL Server and <span class="No-Break">Entity Framework</span></li>
				<li>Testing the database and <span class="No-Break">data-rich applications</span></li>
				<li>Working in production, keeping your database up to date, and keeping your <span class="No-Break">data safe</span></li>
			</ul>
			<p>Data and a database are the foundations of a SaaS application. Let’s start by considering how important <span class="No-Break">they are.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>All code from this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>The importance of data in a SaaS application</h1>
			<p>In a<a id="_idIndexMarker206"/> SaaS application, a database serves as the foundation for the application. The database (or more accurately, the data contained within) is what drives the application and where the primary value for users lies. A SaaS application without data is just an <span class="No-Break">empty shell!</span></p>
			<p>One of the key considerations when building a SaaS application is the type of data that the application will store and how it will be used. Will the application be storing large amounts of structured data, such as customer records or transaction histories? Or will it be storing unstructured data, such as the data underpinning a social media feed? The type of data will have a significant impact on the design and architecture of <span class="No-Break">the application.</span></p>
			<p>Another important consideration is how the data will be accessed and manipulated. Will the data be accessed by a large number of users simultaneously, or will it only be accessed by a few users at a time? Will the data be updated frequently, or will it be mostly static? These factors will influence the choice of database technology and the design of the <span class="No-Break">data model.</span></p>
			<p>In a SaaS application, it is also important to consider how the data will be shared among different tenants. As we discussed in the previous chapter, the data for each tenant must be kept separate and secure, while still allowing for efficient access to and manipulation of the data that pertains to the current tenant. This requires careful planning and design of a data model and <span class="No-Break">database schema.</span></p>
			<p>It is also important to consider scalability. While a SaaS application may well start off with a small user base and thus a comparatively low number of reads/writes, this can change very quickly as the user base increases! It’s important to design a data model and schema in a way that allows the application to grow. Similarly, the amount of data that is transmitted over the internet must be managed. Bandwidth is not free nor unlimited, and in data-intensive applications, this can become <span class="No-Break">a burden.</span></p>
			<p>The importance of data is not limited to technical considerations. Data plays a crucial role in the user experience. The way that data is presented, organized, and accessed can significantly impact the usability of an application. While this is, of course, dependent on the user interface, the structure of the underlying data, and the ease and speed with which it can be queried, will be noticed at the frontend by <span class="No-Break">end users.</span></p>
			<p>For a<a id="_idIndexMarker207"/> company building an application and hosting a database, data can be a key source of revenue. Some SaaS applications monetize their data by selling access to information about consumer demographics and buying habits to businesses looking to target specific market demographics. This data is often collected and classified by machine learning algorithms, allowing for insights about the users and creators of the data. With this valuable information, businesses can create targeted marketing campaigns and improve their products and services to better meet the needs of <span class="No-Break">their customers.</span></p>
			<p>Data is important for a myriad of reasons, and so it should go without saying that maintaining data security and compliance is a crucial aspect of building a successful SaaS application. It is the responsibility of the SaaS provider to ensure that sensitive data, such as financial or personal information, is kept secure and compliant with relevant regulations. To achieve this, the SaaS provider may need to implement various security measures, such as encryption and access controls, to protect <span class="No-Break">the data.</span></p>
			<p>Data and the database are absolutely critical parts of a SaaS application, and it’s important for SaaS developers to have a strong understanding of how to design, build, and maintain <span class="No-Break">data-rich applications.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Building a database</h1>
			<p>In this <a id="_idIndexMarker208"/>section, we will focus on using SQL Server and Entity Framework to design and construct a database for your SaaS application. We will cover a range of topics, including choosing the right database technology, designing an efficient and scalable data model with Entity Framework, and implementing database security and compliance measures with SQL Server. By the end of this section, you will have a solid understanding of how to build a robust and reliable database for your <span class="No-Break">SaaS application.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor107"/>Types of database</h2>
			<p>Because this is a book focused on making use of the Microsoft stack, I will focus on SQL Server as the underlying database platform, and I will use Entity Framework to interact with the <a id="_idIndexMarker209"/>database. SQL Server is a <strong class="bold">relational database</strong>, which is a type of database that stores data in the form of tables, with rows representing <a id="_idIndexMarker210"/>individual records and columns representing data attributes. It is a very structured way to store data, and the “shape” of the data must be known in advance and built into the application at <span class="No-Break">design time.</span></p>
			<p>While we will focus on SQL Server and, therefore, relational data, it is worth briefly considering the alternatives, which are outside the scope of this book. Some of the following alternatives may be worth further investigation if you have a specific use case that may require something other than <span class="No-Break">relational data:</span></p>
			<ul>
				<li><strong class="bold">Document databases</strong>: A document database is<a id="_idIndexMarker211"/> a type of <a id="_idIndexMarker212"/>database that stores data in the form of documents. In this context, a document is data that is typically made up of key-value pairs and is designed to be scalable and flexible. In a document database, the structure or shape of the data will not be set when the database is designed, making it a good choice to store and query large volumes of data with <span class="No-Break">diverse structures.</span></li>
				<li><strong class="bold">Graph databases</strong>: These <a id="_idIndexMarker213"/>databases store data in the<a id="_idIndexMarker214"/> form of nodes (representing data entities) and edges (representing relationships between nodes). They are often used in applications that need to represent complex relationships between data entities, such as social networks or <span class="No-Break">recommendation engines.</span></li>
				<li><strong class="bold">Key-value stores</strong>: These<a id="_idIndexMarker215"/> databases store data in<a id="_idIndexMarker216"/> the form of key-value pairs, where the key is used to identify the data and the value is the data itself. They are often used for simple data storage and retrieval scenarios where the data does not need to be queried or indexed. This is similar to a document database but more limited in that it is only really suitable for simple <span class="No-Break">use cases.</span></li>
				<li><strong class="bold">In-memory databases</strong>: These databases store data in memory, rather than on disk. They<a id="_idIndexMarker217"/> are often used for applications <a id="_idIndexMarker218"/>that require fast read and write access to data, such as online gaming or financial applications. Note that in-memory databases can also be used to help test databases. These are two separate use cases and should not <span class="No-Break">be confused.</span></li>
				<li><strong class="bold">Time-series databases</strong>: These <a id="_idIndexMarker219"/>databases are<a id="_idIndexMarker220"/> designed specifically for storing and querying time-stamped data, such as sensor readings or financial transactions. They are often used in applications that need to analyze data <span class="No-Break">over time.</span></li>
			</ul>
			<p>In this chapter, we will focus on SQL Server, which is a relational database. We will interact with the database using a tool that Microsoft developed specifically for this purpose – namely, <span class="No-Break">Entity Framework.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor108"/>What is ACID?</h2>
			<p>When working with databases – and particularly relational databases – you will often come across the acronym <strong class="bold">ACID</strong>. This<a id="_idIndexMarker221"/> refers to the four properties of a database transaction – namely, atomicity, consistency, isolation, <span class="No-Break">and durability:</span></p>
			<ul>
				<li><strong class="bold">Atomicity</strong>: A <a id="_idIndexMarker222"/>transaction is treated as a single, indivisible unit of work, and either all its operations are completed or none of <span class="No-Break">them are</span></li>
				<li><strong class="bold">Consistency</strong>: The<a id="_idIndexMarker223"/> transaction brings the database from one valid state to another, preserving database invariants <span class="No-Break">and constraints</span></li>
				<li><strong class="bold">Isolation</strong>: The<a id="_idIndexMarker224"/> concurrent execution of transactions results in a system state that would be obtained if transactions were executed serially, in <span class="No-Break">some order</span></li>
				<li><strong class="bold">Durability</strong>: Once a<a id="_idIndexMarker225"/> transaction has been committed, its changes to the database persist and survive future <span class="No-Break">system failures</span></li>
			</ul>
			<p>These properties are a set of properties that are guaranteed by a database management system to ensure the reliability and consistency of data stored in a database. ACID is most commonly associated with <strong class="bold">relational database management systems</strong> (<strong class="bold">RDBMS</strong>), such as Oracle, MySQL, PostgreSQL, and Microsoft SQL Server. However, some newer<a id="_idIndexMarker226"/> databases, such as NoSQL databases and NewSQL databases, may also provide ACID guarantees, although they may have different levels of consistency and durability. The level of ACID support depends on the specific database technology and how it is implemented <span class="No-Break">and configured.</span></p>
			<p>ACID is generally associated with transactions in relational databases, and less commonly so in NoSQL or document databases. In this chapter, and indeed throughout this book, we will focus on SQL Server, a relational database that provides support for <span class="No-Break">ACID transactions.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Entity Framework</h2>
			<p>Entity Framework is<a id="_idIndexMarker227"/> an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) tool<a id="_idIndexMarker228"/> that allows developers to interact with a database using .NET objects. It simplifies the process of accessing and manipulating data by eliminating the need to write SQL queries and manually map data to objects. Entity Framework is well-suited for developers who are familiar with .NET and want to streamline their data access and manipulation tasks, which makes it an excellent choice for study in this .<span class="No-Break">NET-focused book!</span></p>
			<p>While we will focus on SQL Server, one of the big benefits of using Entity Framework is its ability to generate database-agnostic code, allowing developers to change a database platform or support multiple database platforms without having to significantly rewrite their code. This feature is of particular interest when dealing with a multi-tenant SaaS application, where certain customers may mandate a specific <span class="No-Break">database platform.</span></p>
			<p>Entity Framework wraps up a lot of the complexities associated with writing code that interacts with a database. Concepts such as lazy loading, change tracking, and automatic migration of data and schema changes are handled out of <span class="No-Break">the box.</span></p>
			<p>Unlike many other ORMs, Entity Framework supports several different approaches to interacting with a database, including the traditional database-first approach, the code-first approach, and the model-first approach. This gives developers the flexibility to choose the approach that best fits <span class="No-Break">their needs.</span></p>
			<p>Entity Framework is a powerful tool that can greatly enhance the productivity of experienced .NET developers by simplifying data access and manipulation tasks, and it is highly recommended <a id="_idIndexMarker229"/>when approaching a project that will be highly dependent on a data platform – such as a <span class="No-Break">SaaS application.</span></p>
			<p>It is out of the scope of this chapter to cover all of the possible ways to use Entity Framework, so I will focus on one – <span class="No-Break">Code First.</span></p>
			<h4>Code first with Entity Framework</h4>
			<p>Code first with Entity Framework<a id="_idIndexMarker230"/> is a development approach that allows developers to create their .NET application’s data model using C# code, rather than designing a database using a UI such as SQL Server Management Studio, or through writing and maintaining SQL scripts. This approach is particularly useful for developers who prefer to work with code and want more control over their application’s data model. With code first, developers can define their data model using classes and properties in their code, and Entity Framework will handle the creation and management of the underlying database. This approach allows developers to focus on the data model and business logic of their application, without having to worry about the implementation details of <span class="No-Break">the database.</span></p>
			<p>We saw this approach in <a href="B19343_02.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. When the database was configured, we didn’t write a single line of SQL code – we wrote a C# class called <strong class="source-inline">GoodHabits.cs</strong> and defined the data structure in C# code. We then used two commands on the Entity Framework CLI that updated the database. In <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we modified this file to <span class="No-Break">facilitate multi-tenancy.</span></p>
			<h4>Stored procedures with Entity Framework</h4>
			<p>Traditionally, it <a id="_idIndexMarker231"/>has been very common to use stored procedures when designing a database. While this is still a very valid and useful approach to database development, it is increasingly being seen as best practice to use an ORM such as Entity Framework to access and manipulate data in a database, rather than using stored procedures. There are a few reasons <span class="No-Break">for this.</span></p>
			<p>Entity Framework allows you to work with objects and entities in your code, rather than having to write raw SQL queries. This gives you a higher level of abstraction, which can make it easier to develop an application. With this approach, you can build your database in a familiar object-orientated way, which can make it easier to reason about and maintain. Entity Framework is able to interpret relationships between objects and create database relationships from C# code. If you create logic and then model it in a stored procedure, Entity Framework loses sight of <span class="No-Break">that logic.</span></p>
			<p>Another <a id="_idIndexMarker232"/>huge benefit of using Entity Framework is that many database platforms are supported out of the box. However, logic in stored procedures is typically not transferrable between database platforms and would have to be built and maintained separately on a <span class="No-Break">per-platform basis.</span></p>
			<p>Finally, Entity Framework has a number of testing tools available to use. Using stored procedures and triggers will require specific testing infrastructure and techniques, and this may make it harder to test an application because logic is split between code and <span class="No-Break">the database.</span></p>
			<p>There are certain cases when using stored procedures or triggers may be beneficial. These include <span class="No-Break">the following:</span></p>
			<ul>
				<li>When working with very large datasets, or in situations where performance is critical, it may be advantageous to execute logic directly against a database by way of a <span class="No-Break">stored procedure</span></li>
				<li>In cases where data security is a concern, stored procedures can help to prevent unauthorized access to data by limiting the types of queries that can be run against <span class="No-Break">a database.</span></li>
				<li>In cases where you want to abstract the data access layer of your application from the underlying database schema, using stored procedures can help to decouple the two. This can be particularly useful in situations where a database schema may <span class="No-Break">change frequently.</span></li>
			</ul>
			<p>It is important to understand your specific use case when deciding whether or not to make use of stored procedures in your database. For the demo application, we will continue to use Entity Framework to manipulate and access <span class="No-Break">the database.</span></p>
			<h4>Normalization</h4>
			<p>Database normalization<a id="_idIndexMarker233"/> is the process of organizing a database in a way that reduces redundancy and improves data integrity. It involves dividing the database into smaller, more focused tables that are related to each other through relationships. The goal of normalization is to eliminate redundancy and ensure that each piece of data is stored in only one place in the database. Normalization is an important step in the database design process and can greatly improve the performance and reliability of <span class="No-Break">a database.</span></p>
			<p>Entity Framework <a id="_idIndexMarker234"/>supports the process of normalizing a database in several ways. One of the main ways it does this is through the creation and modification of tables and relationships within the database. This allows developers to structure their data in a way that reduces redundancy and improves data integrity – a key goal of normalization. Entity Framework also includes support for the automatic migration of data changes. This means that when developers make changes to their data model, those changes are automatically reflected in the underlying database. This can be particularly useful when normalizing a database, as it allows developers to easily update the structure of their data without having to manually migrate data <span class="No-Break">between tables.</span></p>
			<p>In addition, Entity Framework’s LINQ query syntax allows developers to easily retrieve and manipulate data from a normalized database. It supports a wide range of operations, including filtering, sorting, and aggregation, making it easy to work with data from multiple tables. Finally, Entity Framework’s support for eager and lazy loading allows developers to optimize the performance of their application by only loading the data they need on demand, rather than loading all data upfront. This can be harder with a poorly normalized database. Overall, Entity Framework provides a number of tools and features to help developers normalize their databases and improve the performance and reliability of <span class="No-Break">their applications.</span></p>
			<p>There are several normal forms that can be used to measure the degree of normalization in a database. The first three (called 1NF, 2NF, and 3NF) are used to address redundancy in a database and are generally considered to be good practice in <span class="No-Break">most instances.</span></p>
			<p>Beyond the first three, the additional normal forms are designed to address specific types of problems; however, these are less commonly used and are considered out of the scope of <span class="No-Break">this chapter.</span></p>
			<p>It is worth noting that achieving higher normal forms does not always constitute a better-designed database. It is generally better to design a database that is efficient and performant around a specific use case than to adhere blindly to the normalization rules. That said, achieving 3NF is usually a good starting point from which to work, and further normalization, or indeed denormalization, can follow <span class="No-Break">from there.</span></p>
			<p>Let’s illustrate this with an example. Let’s consider adding a user table to the <strong class="source-inline">GoodHabit</strong> example we developed in <a href="B19343_02.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
			<p>To<a id="_idIndexMarker235"/> achieve the first normal form (1NF), all attributes in the database must be atomic. This means that each column in the database should contain a single value. We could design a user table that looked <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B19343_Figure_4.1.jpg" alt="Figure 4.1 – Poorly normalized data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Poorly normalized data</p>
			<p>The preceding table shows poorly normalized data. The <strong class="bold">Name</strong> column contains two pieces of information (first and last name), which may be useful to use separately. The <strong class="bold">Habits</strong> column contains a comma-separated list of data. This can be improved upon <span class="No-Break">like so:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19343_Figure_4.2.jpg" alt="Figure 4.2 – Data in the first normal form (1NF)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Data in the first normal form (1NF)</p>
			<p>The preceding table shows the data in 1NF. Each attribute holds a single value. We now have a row in the database for each habit, but the users appear multiple times. If Dave decided that he would prefer to be called David, we would have to update the data in <span class="No-Break">multiple places.</span></p>
			<p>To move this data into the second normal form, we need to break the data into two tables – one for the user, and one for the habit. We will need a third table to link the users to the habits they are going to <span class="No-Break">work on:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19343_Figure_4.3.jpg" alt="Figure 4.3 – Data in the second normal form (2NF)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Data in the second normal form (2NF)</p>
			<p>This is <a id="_idIndexMarker236"/>much better, and we can start to see that this could be queried and updated in a very tidy way. There is one further improvement we could make though. The <strong class="bold">Habit</strong> table has a <strong class="bold">Frequency</strong> column that is indirectly dependent on the ID column. This is called a transitive dependency. In order to move this data to the third normal form, we must break this transitive dependency by adding a <span class="No-Break"><strong class="bold">Frequency</strong></span><span class="No-Break"> table:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19343_Figure_4.4.jpg" alt="Figure 4.4 – Data in the third normal form (3NF)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Data in the third normal form (3NF)</p>
			<p>The third normal form is sufficient at this stage, and we’ll take this no further. You can see that all of the data is separated into individual tables, and linked through foreign key constraints to the <strong class="bold">UserHabit</strong> table. This allows efficient querying and updating of the data in <span class="No-Break">the database.</span></p>
			<h3>Indexing and performance optimization</h3>
			<p>Indexing a database <a id="_idIndexMarker237"/>means creating a separate data structure that is used to improve the performance of certain types of queries. Indexes are typically created on specific columns within a table, allowing the database to quickly locate the rows that match given criteria. For example, if you have a large table of customer records and you frequently search for customers by their last name, you could create an index on the <strong class="source-inline">last_name</strong> column to improve the performance of those searches. Indexes can significantly improve the performance of certain types of queries, but they also have a cost in terms of storage space and maintenance. As a result, it is important to carefully consider which columns should be indexed and to balance the benefits of indexing with <span class="No-Break">the costs.</span></p>
			<p>To do indexing<a id="_idIndexMarker238"/> with Entity Framework, developers can use a variety of tools and approaches. One way to do indexing is to use the Entity Framework Fluent API, which allows developers to define indexes on their entities using code. To create an index using the Fluent API, developers can use the <strong class="source-inline">HasIndex</strong> method and specify the properties that should be included in the index. Another option is to use Entity Framework Designer, a visual tool that allows developers to design their data model using a graphical interface. The Designer includes the ability to define indexes on entities by right-clicking on an entity and selecting <strong class="bold">Add Index</strong>. Finally, developers can use database migrations to create indexes on their entities by adding the appropriate code to their <span class="No-Break">migration files.</span></p>
			<p>Configuring indexes with Entity Framework <span class="No-Break">is straightforward!</span></p>
			<p>If we consider the <strong class="source-inline">GoodHabit</strong> table that we developed in <a href="B19343_02.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we used the following C# code to define the structure of <span class="No-Break">the table:</span></p>
			<pre class="source-code">
public class GoodHabit
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
}</pre>
			<p>We can add an index to the <strong class="source-inline">Name</strong> column by decorating the class with an attribute <span class="No-Break">like so:</span></p>
			<pre class="source-code">
[Index(nameof(Name))]
public class GoodHabit
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
}</pre>
			<p>This will <a id="_idIndexMarker239"/>instruct the database platform to create an<a id="_idIndexMarker240"/> index for the <strong class="source-inline">Name</strong> column. We could do the same for the <strong class="source-inline">ID</strong> column in the same way. You can create a composite index by setting the attribute <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[Index(nameof(Name), nameof(Id))]</pre>
			<p>If you need to set the sort order of the indexes, you can use one of <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[Index(nameof(Name), nameof(Id)), AllDescending = true]
[Index(nameof(Name), nameof(Id)), IsDescending = new[] { false, true }]</pre>
			<p>If you want to name your index, you can use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[Index(nameof(Name), Name = "Index_Name")]</pre>
			<p>There is a great deal of flexibility provided by Entity Framework, and it is out of the scope of this book to cover all <span class="No-Break">of it.</span></p>
			<p>You can get more information about it <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations"><span class="No-Break">https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations</span></a><span class="No-Break">.</span></p>
			<p>We will now build out a database for the example application, being mindful of what we have <span class="No-Break">just learned.</span></p>
			<h3>Designing a database schema using Entity Framework code first</h3>
			<p>Before we start <a id="_idIndexMarker241"/>designing a database, let’s stop and think about what our <span class="No-Break">requirements are:</span></p>
			<ul>
				<li>The database will store user information to identify <span class="No-Break">individual users</span></li>
				<li>Users can add habits to the database to track their progress and achieve <span class="No-Break">their goals</span></li>
				<li>Users can log progress for each habit and set reminders to <span class="No-Break">perform it</span></li>
				<li>Users can set goals for their habits, such as running a certain number of miles or saving a certain amount <span class="No-Break">of money</span></li>
				<li>The database can support users in achieving their goals and improving their overall well-being by tracking and managing <span class="No-Break">their habits</span></li>
			</ul>
			<p>The following <a id="_idIndexMarker242"/>figure shows a diagram representing the database that we just configured. This shows the tables, columns, and relationships between <span class="No-Break">the tables:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B19343_Figure_4.5.jpg" alt="Figure 4.5 – A suggested database schema"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – A suggested database schema</p>
			<p>The preceding diagram shows a schema that can meet the requirements <span class="No-Break">defined previously.</span></p>
			<h3>Creating the entity classes</h3>
			<p>As we are using <a id="_idIndexMarker243"/>Entity Framework code first, we will build this database by writing C# code. Create the entity classes with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.Database/Entities; \</strong>
<strong class="bold">touch Goal.cs; \</strong>
<strong class="bold">touch Progress.cs; \</strong>
<strong class="bold">touch Reminder.cs; \</strong>
<strong class="bold">touch User.cs;</strong></pre>
			<p>We <a id="_idIndexMarker244"/>already have the <strong class="source-inline">Habit</strong> entity, but we will update it with some additional properties. Copy the following code <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">Habit.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Name), nameof(Id))]
public class Habit : IHasTenant
{
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
    public int UserId { get; set; }
    public virtual ICollection&lt;Progress&gt; ProgressUpdates {
      get; set; } = default!;
    public virtual ICollection&lt;Reminder&gt; Reminders { get;
      set; } = default!;
    public virtual Goal Goal { get; set; } = default!;
    public Duration Duration { get; set; }
    public string TenantName { get; set; } = default!;
}
public enum Duration { DayLong, WeekLong, MonthLong }</pre>
			<p>Next, <strong class="source-inline">Goal.cs</strong> should<a id="_idIndexMarker245"/> look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class Goal
{
    public int Id { get; set; }
    public int HabitId { get; set; }
    public virtual Habit Habit { get; set; } = default!;
}</pre>
			<p><strong class="source-inline">Progress.cs</strong> should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class Progress
{
    public int Id { get; set; }
    public DateTime Date { get; set; }
    public int HabitId { get; set; }
    public virtual Habit Habit { get; set; } = default!;
}</pre>
			<p><strong class="source-inline">Reminder.cs</strong> should<a id="_idIndexMarker246"/> look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class Reminder
{
    public int Id { get; set; }
    public Frequency Frequency { get; set; }
    public int HabitId { get; set; }
    public virtual Habit Habit { get; set; } = default!;
}
public enum Frequency { Daily, Weekly, Monthly }</pre>
			<p>And finally, <strong class="source-inline">User.cs</strong> should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class User
{
    public int Id { get; set; }
    public string FirstName { get; set; } = default!;
    public string LastName { get; set; } = default!;
    public string Email { get; set; } = default!;
}</pre>
			<p>Add the<a id="_idIndexMarker247"/> following lines of code into the <span class="No-Break"><strong class="source-inline">GoodHabitsDbContext</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
  public DbSet&lt;User&gt;? Users { get; set; }
  public DbSet&lt;Progress&gt;? Progress { get; set; }
  public DbSet&lt;Reminder&gt;? Reminders { get; set; }
  public DbSet&lt;Goal&gt;? Goals { get; set; }</pre>
			<p>You can create the migration by running the following in <span class="No-Break">the console:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet-ef migrations add AdditionalEntities --startup-project ../GoodHabits.HabitService/GoodHabits.HabitService.csproj</strong></pre>
			<p>The migrations will be automatically applied to the database when <strong class="source-inline">HabitService</strong> runs, so simply run the Habit service to push the changes to <span class="No-Break">the database.</span></p>
			<p>Using the Server Explorer to view the database, we can see that the schema has been <span class="No-Break">successfully applied!</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B19343_Figure_4.6.jpg" alt="Figure 4.6 – The schema applied to the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The schema applied to the database</p>
			<p>The preceding<a id="_idIndexMarker248"/> figure shows that the schema has successfully migrated to <span class="No-Break">the database.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Testing data-rich applications</h1>
			<p>Testing<a id="_idIndexMarker249"/> the database layer of a SaaS application is an essential part of the development process. A database is a critical component of any application, as it stores and manages the data that an application relies on. Ensuring that the database is working correctly is crucial for the overall stability and performance of <span class="No-Break">the application.</span></p>
			<p>There are several challenges that you may encounter when testing the database layer of your application. One challenge is ensuring that the database schema is correct and that the data is stored and retrieved correctly. Another challenge is ensuring that the database is properly optimized for performance, particularly if you are dealing with large amounts <span class="No-Break">of data.</span></p>
			<p>There are a<a id="_idIndexMarker250"/> number of different techniques that you can use to test the database layer of your application. One common technique is to use unit tests to verify that individual database functions are working correctly. Another technique is to use integration tests to ensure that the database is working correctly in conjunction with the rest of the application. You may also want to use performance tests to ensure that the database is able to handle large amounts of data without experiencing <span class="No-Break">any issues.</span></p>
			<p>Unit tests are a type of automated testing that is used to verify the behavior of individual units of code, such as individual functions or methods. In contrast to unit tests, integration tests focus on testing how different parts of an application work together as a system. Integration tests are used to ensure that different components of the application are able to communicate and interact with one <span class="No-Break">another correctly.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>Upgrading a database</h1>
			<p>Upgrading a<a id="_idIndexMarker251"/> database with Entity Framework involves making changes to the database schema and data to reflect changes in an application. This can include adding new tables or columns, modifying existing tables or columns, and migrating data from one format <span class="No-Break">to another.</span></p>
			<p>There are several approaches that you can take when upgrading a database with Entity Framework. One approach is to use the <strong class="source-inline">DbMigrations</strong> class to automatically generate and execute the necessary SQL commands to update the database schema. This can be convenient, as it allows you to make changes to the database using a high-level API, rather than having to write raw SQL commands. However, it can also be less flexible than some other approaches, as it relies on Entity Framework to generate the SQL commands, and that may not always produce optimal results. This is the approach that we will take in <span class="No-Break">this chapter.</span></p>
			<p>It is worth being aware of a popular alternative approach, which is to use Entity Framework’s <strong class="source-inline">DbContext</strong> class to manually execute SQL commands to update a database. This can be more flexible, as you have complete control over the SQL commands that are executed. However, it can also be more time-consuming and error-prone, as you have to write and debug the SQL <span class="No-Break">commands yourself.</span></p>
			<p>Finally, it is, of course, possible to update a database separately from Entity Framework using any preferred method, which most likely involves executing <span class="No-Break">SQL scripts.</span></p>
			<p>I think<a id="_idIndexMarker252"/> that it is generally preferable to make use of the built-in migration tools and allow Entity Framework to do the heavy lifting <span class="No-Break">for us.</span></p>
			<p>We saw this process in practice twice – when we created the initial migration in <a href="B19343_02.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, and when we just updated <span class="No-Break">the schema.</span></p>
			<p>If you look at the <strong class="source-inline">Migrations</strong> folder in the <strong class="source-inline">Database</strong> project, you should see the <span class="No-Break">following files:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B19343_Figure_4.7.jpg" alt="Figure 4.7 – The Migrations folder"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The Migrations folder</p>
			<p>In the preceding figure, we can see the <strong class="source-inline">.._InitialSetup.cs</strong> file that contains our first pass, the <strong class="source-inline">.._MultiTenant.cs</strong> file that has the modifications that we made in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and the <strong class="source-inline">AdditionalEntities.cs</strong> file that we added in <span class="No-Break">this chapter.</span></p>
			<p>If you recall, in <a href="B19343_02.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we added the initial migration with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet-ef migrations add Initial</pre>
			<p>However, when creating the second migration, we used <span class="No-Break">this instead:</span></p>
			<pre class="source-code">
dotnet-ef migrations add MultiTenant --startup-project ../GoodHabits.Api/GoodHabits.Api.csproj</pre>
			<p>The reason for this is that the work we did in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> to introduce the multi-tenancy has added parameters to the constructor, which are defined in the API project. Pointing the migration<a id="_idIndexMarker253"/> tool at the API project allows it to create migrations via the <span class="No-Break"><strong class="source-inline">HabitService</strong></span><span class="No-Break"> project.</span></p>
			<p>If you look into either of these generated classes, you will see two methods, named <strong class="source-inline">Up</strong> and <strong class="source-inline">Down</strong>. These methods allow the migration to be added to the database, or <span class="No-Break">rolled back.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Applying the migrations</h2>
			<p>Because of <a id="_idIndexMarker254"/>how we have configured the databases for multi-tenancy in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we do not need to manually update each database. However, should you find you need to manually update a database, you can use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet-ef database update --startup-project ../GoodHabits.Api/GoodHabits.HabitService.csproj</strong></pre>
			<p>Issuing this command will instruct Entity Framework to look in the <strong class="source-inline">Migrations</strong> folder and compare the migrations that it finds there with the migrations that are present in the database. If there are any additional migrations that have not yet been applied to the database, Entity Framework will apply those migrations. Let’s take a closer look at the first one we created, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">initial</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
#pragma warning disable CA1814 // Prefer jagged arrays over
                               // multidimensional
namespace GoodHabits.Database.Migrations
{
    /// &lt;inheritdoc /&gt;
    public partial class InitialSetup : Migration
    {
        /// &lt;inheritdoc /&gt;
        protected override void Up(MigrationBuilder
          migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Habits",
                columns: table =&gt; new
                {
                    Id = table.Column&lt;int&gt;(type: "int",
                      nullable: false)
                        .Annotation("SqlServer:Identity",
                          "1, 1"),
                    Name = table.Column&lt;string&gt;(type:
                      "nvarchar(max)", nullable: false),
                    Description =
                      table.Column&lt;string&gt;(type:
                      "nvarchar(max)", nullable: false)
                },
                constraints: table =&gt;
                {
                    table.PrimaryKey("PK_Habits",
                      x =&gt; x.Id);
                });
            migrationBuilder.InsertData(
                table: "Habits",
                columns: new[] { "Id", "Description",
                  "Name" },
                values: new object[,]
                {
                    { 100, "Become a francophone",
                      "Learn French" },
                    { 101, "Get really fit",
                      "Run a marathon" },
                    { 102, "Finish your book project",
                      "Write every day" }
                });
        }
        /// &lt;inheritdoc /&gt;
        protected override void Down(MigrationBuilder
          migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Habits");
        }
    }
}</pre>
			<p>This code is auto-generated by the migration tool, but it’s perfectly acceptable to manually adjust the<a id="_idIndexMarker255"/> code here if there is a reason to. We can see two methods here. One is called <strong class="source-inline">Up</strong>, and the <span class="No-Break">other </span><span class="No-Break"><strong class="source-inline">Down</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Up</strong> method creates the table in the database, and the <strong class="source-inline">Down</strong> method drops the table. This is converted into SQL code, which is issued to the database engine when the <strong class="source-inline">database update</strong> command <span class="No-Break">is issued.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor113"/>Summary</h1>
			<p>We have covered a lot in <span class="No-Break">this chapter!</span></p>
			<p>We learned that data is important in a SaaS application. This can be trying not only from a technical point of view but also from the point of view of a user, as well as the organization building <span class="No-Break">the application.</span></p>
			<p>We then moved on to a technical implementation with Entity Framework, demonstrating how to build a database in code using C#, and then automatically generate migrations and update <span class="No-Break">the database.</span></p>
			<p>We also talked about testing strategies and maintaining a database <span class="No-Break">in production.</span></p>
			<p>In the next chapter, we will build out the API layer and start to interact with the data structure we previously created. The application will start to <span class="No-Break">take shape!</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor114"/>Further reading</h1>
			<ul>
				<li>What is <span class="No-Break">Code-First?: </span><a href="https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx"><span class="No-Break">https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx</span></a></li>
				<li>Testing with Entity <span class="No-Break">Framework:</span><span class="No-Break"><span class="hidden"> </span></span><a href="https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/"><span class="No-Break">https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/</span></a></li>
				<li>Data-driven <span class="No-Break">culture: </span><a href="https://www.smartkarrot.com/resources/blog/data-driven-culture/"><span class="No-Break">https://www.smartkarrot.com/resources/blog/data-driven-culture/</span></a></li>
				<li>Database <span class="No-Break">normalization: </span><a href="https://www.sqlshack.com/what-is-database-normalization-in-sql-server/"><span class="No-Break">https://www.sqlshack.com/what-is-database-normalization-in-sql-server/</span></a></li>
			</ul>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Questions</h1>
			<ol>
				<li>In what ways can a business monetize data that is present in a <span class="No-Break">SaaS application?</span></li>
				<li>What are the ethical considerations around <span class="No-Break">data monetization?</span></li>
				<li>How are foreign key relationships represented in <span class="No-Break">Entity Framework?</span></li>
				<li>What is the difference between a unit test and an <span class="No-Break">integration test?</span></li>
				<li>If I want to roll back migration in a live database, how do I ensure that no data <span class="No-Break">is lost?</span></li>
			</ol>
		</div>
	</body></html>