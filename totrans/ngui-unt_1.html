<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with NGUI</h1></div></div></div><p>In this first chapter, we will talk about the overall workflow of NGUI before we import the plugin and create our first UI. Then we will look into the UI's structure, important parameters, and general behavior.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is NGUI?</h1></div></div></div><p>The <strong>Next-Gen User Interface</strong> kit <a id="id0" class="indexterm"/>is a plugin for Unity 3D. It has the great advantage of being easy to use, very powerful, and optimized compared to Unity's built-in GUI system, <strong>UnityGUI</strong>. Since<a id="id1" class="indexterm"/> it is written in C#, it is easily understandable and you may tweak it or add your own features, if necessary.</p><p>The <strong>NGUI Standard License</strong>
<a id="id2" class="indexterm"/> costs $95. With this, you will have useful example scenes included. I recommend this license to start comfortably—a free evaluation version is available, but it is limited, outdated, and not recommended.</p><p>The <strong>NGUI Professional License</strong>
<a id="id3" class="indexterm"/>, priced at $200, gives you access to NGUI's GIT repository to access the latest beta features and releases in advance.</p><p>A $2000 <strong>Site License</strong>
<a id="id4" class="indexterm"/> is available for an unlimited number of developers within the same studio.</p><p>Let's have an overview of the main features of this plugin and see how they work.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>UnityGUI versus NGUI</h2></div></div></div><p>With Unity's GUI, <a id="id5" class="indexterm"/>you must create the entire UI in code by adding lines that display labels, textures, or any other UI element on the screen. These lines have to be written inside a special function, <code class="literal">OnGUI()</code>, that is called for every frame. This is no longer necessary; with NGUI, UI elements are simple GameObjects!</p><p>You can create widgets—this is what NGUI calls labels, sprites, input fields, and so on—move them, rotate them, and change their dimensions using handles or the Inspector. Copying, pasting, creating prefabs, and every other useful feature of Unity's workflow is also available.</p><p>These widgets<a id="id6" class="indexterm"/> are viewed by a camera and rendered on a layer that you can specify. Most of the parameters are accessible through Unity's Inspector, and you can see what your UI looks like directly in the Game window, without having to hit the Play button.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Atlases</h2></div></div></div><p>Sprite<a id="id7" class="indexterm"/>s and fonts are all contained in a large texture called atlas. With only a few clicks, you can easily create and edit your atlases. If you don't have any images to create your own UI assets, simple default atlases come with the plugin.</p><p>That system means that for a complex UI window composed of different textures and fonts, the same material and texture will be used when rendering. This results in only one draw call for the entire window. This, along with other optimizations, makes NGUI the perfect tool to work on mobile platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Events</h2></div></div></div><p>NGUI also <a id="id8" class="indexterm"/>comes with an easy-to-use event framework that is written in C#. The plugin comes with a large number of additional components that you can attach to GameObjects. These components can perform advanced tasks depending on which events are triggered: hover, click, input, and so on. Therefore, you may enhance your UI experience while keeping it simple to configure. Code less, get more!</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Localization</h2></div></div></div><p>NGUI comes<a id="id9" class="indexterm"/> with its own localization system, enabling you to easily set up and change your UI's language with the push of a button. All your strings are located in the <code class="literal">.txt</code> files: one file per language.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Shaders</h2></div></div></div><p>Lighting, <a id="id10" class="indexterm"/>normal mapping, and refraction shaders are supported in NGUI, which can give you beautiful results. Clipping is also a shader-controlled feature with NGUI, used for showing or hiding specific areas of your UI.</p><p>We've now covered what NGUI's main features are, and how it can be useful to us as a plugin, and now it's time to import it inside Unity.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Importing NGUI</h1></div></div></div><p>After<a id="id11" class="indexterm"/> buying the product from the Asset Store or getting the evaluation version, you have to download it. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Unity project.</li><li class="listitem">Navigate to <strong>Window</strong> | <strong>Asset Store</strong>. Select your download library.</li><li class="listitem">Click on the <strong>Download</strong> button next to <strong>NGUI: Next-Gen UI</strong>.</li><li class="listitem">When the download completes, click on the NGUI icon / product name in the library to access the product page.</li><li class="listitem">Click on the <strong>Import</strong> button and wait for a pop-up window to appear.</li><li class="listitem">Check the checkbox for <strong>NGUI v.3.0.2.unitypackage</strong> and click on <strong>Import</strong>.</li><li class="listitem">In the Project view, navigate to <strong>Assets</strong> | <strong>NGUI</strong> and double-click on <strong>NGUI v.3.0.2</strong>.</li><li class="listitem">A new imported pop-up window will appear. Click on <strong>Import</strong> again.</li><li class="listitem">Click any button on the toolbar to refresh it. The NGUI tray will appear!</li></ol></div><p>The NGUI tray will look like the following screenshot:</p><div><img src="img/8667OT_01_01.jpg" alt="Importing NGUI"/></div><p>You have now successfully imported NGUI to your project. Let's create your first 2D UI.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating your UI</h1></div></div></div><p>We will <a id="id12" class="indexterm"/>now create our first 2D user interface<a id="id13" class="indexterm"/> with NGUI's UI Wizard. This wizard will add all the elements needed for NGUI to work.</p><p>Before we continue, please save your scene as <code class="literal">Menu.unity</code>.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>UI Wizard</h2></div></div></div><p>Create your<a id="id14" class="indexterm"/> UI by opening the UI Wizard by navigating to <strong>NGUI</strong> | <strong>Open</strong> | <strong>UI Wizard</strong> from the toolbar. Let's now take a look at the UI Wizard window and its parameters.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Window</h3></div></div></div><p>You should <a id="id15" class="indexterm"/>now have the following pop-up window with two parameters:</p><div><img src="img/8667OT_01_02.jpg" alt="Window"/></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Parameters</h3></div></div></div><p>The two<a id="id16" class="indexterm"/> parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Layer</strong>: This is the layer on which your UI will be displayed</li><li class="listitem" style="list-style-type: disc"><strong>Camera</strong>: This will decide if the UI will have a camera, and its drop-down options are as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>None</strong>: No camera will be created</li><li class="listitem" style="list-style-type: disc"><strong>Simple 2D</strong>: Uses a camera with orthographic projection</li><li class="listitem" style="list-style-type: disc"><strong>Advanced 3D</strong>: Uses a camera with perspective projection</li></ul></div></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Separate UI Layer</h2></div></div></div><p>I recommend that<a id="id17" class="indexterm"/> you separate your UI from other usual layers. We should do it as shown in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on the drop-down menu next to the <strong>Layer</strong> parameter.</li><li class="listitem">Select <strong>Add Layer</strong>.</li><li class="listitem">Create a new layer and name it <code class="literal">GUI2D</code>.</li><li class="listitem">Go back to the UI Wizard window and select this new <strong>GUI2D</strong> layer for your UI.</li></ol></div><p>You can now click on the <strong>Create Your UI</strong> button. Your first 2DUI has been created!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Your UI structure</h1></div></div></div><p>The wizard<a id="id18" class="indexterm"/> has created four new GameObjects on the scene for us:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">UI Root (2D)</li><li class="listitem" style="list-style-type: disc">Camera</li><li class="listitem" style="list-style-type: disc">Anchor</li><li class="listitem" style="list-style-type: disc">Panel</li></ul></div><p>Let's now review each in detail.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>UI Root (2D)</h2></div></div></div><p>The <a id="id19" class="indexterm"/>
<strong>UIRoot</strong> component<a id="id20" class="indexterm"/> scales widgets down to keep them at a manageable size. It is also responsible for the <strong>Scaling Style</strong>—it will either scale UI elements to remain pixel perfect or to occupy the same percentage of the screen, depending on the parameters you specify.</p><p>Select the <strong>UI Root (2D)</strong> GameObject in the Hierarchy. It has the <code class="literal">UIRoot.cs</code> script attached to it. This script adjusts the scale of the GameObject it's attached to in order to let you specify widget coordinates in pixels, instead of Unity units as shown in the following screenshot:</p><div><img src="img/8667OT_01_03.jpg" alt="UI Root (2D)"/></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Parameters</h3></div></div></div><p>The <strong>UIRoot</strong> component<a id="id21" class="indexterm"/> has four parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Scaling Style</strong>: The following are the available scaling styles:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>PixelPerfect</strong>: This will ensure that your UI will always try to remain at the same size in pixels, no matter what resolution. In this scaling mode, a 300 x 200 window will be huge on a 320 x 240 screen and tiny on a 1920 x 1080 screen. That also means that if you have a smaller resolution than your UI, it will be cropped.</li><li class="listitem" style="list-style-type: disc"><strong>FixedSize</strong>: This will ensure that your UI will be proportionally resized depending on the screen's height. The result is that your UI will not be pixel perfect but will scale to fit the current screen size.</li><li class="listitem" style="list-style-type: disc"><strong>FixedSizeOnMobiles</strong>: This will ensure fixed size on mobiles and pixel perfect everywhere else.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Manual Height</strong>: With the <strong>FixedSize</strong> scaling style, the scale will be based on this height. If your screen's height goes over or under this value, it will be resized to be displayed identically while maintaining the aspect ratio (width/height proportional relationship).</li><li class="listitem" style="list-style-type: disc"><strong>Minimum Height</strong>: With the <strong>PixelPerfect</strong> scaling style, this parameter defines the <a id="id22" class="indexterm"/>minimum height for the screen. If your screen height goes below this value, your UI will resize. It will be as if the <strong>Scaling Style</strong> parameter was set to <strong>FixedSize</strong> with <strong>Manual Height</strong> set to this value.</li><li class="listitem" style="list-style-type: disc"><strong>Maximum Height</strong>: With the <strong>PixelPerfect</strong> scaling style, this parameter defines the maximum height for the screen. If your screen height goes over this value, your UI will resize. It will be as if the <strong>Scaling Style</strong> parameter was set to <strong>FixedSize</strong> with <strong>Manual Height</strong> set to this value.<div><div><h3 class="title"><a id="note02"/>Note</h3><p>Please set the <strong>Scaling Style</strong> parameter to <strong>FixedSize</strong> with a <strong>Manual Height</strong> value of 1080. This will allow us to have the same UI on any screen size up to 1920 x 1080.</p></div></div></li></ul></div><p>Even though the UI will look the same on different resolutions, the <strong>aspect ratio</strong> is still a problem since the rescale is based on the screen's height only. If you want to cover both 4:3 and 16:9 screens, your UI should not be too large—try to keep it square. Otherwise, your UI might be cropped on certain screen resolutions.</p><p>On the other hand, if you want a 16:9 UI, I recommend you force this aspect ratio only. Let's do it now for this project by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Navigate to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Player</strong>.</li><li class="listitem">In the <strong>Inspector</strong> option, unfold the <strong>Resolution and Presentation</strong> group.</li><li class="listitem">Unfold the <strong>Supported Aspect Ratios</strong> group.</li><li class="listitem">Check only the <strong>16:9</strong> box.</li></ol></div><p>Now that we have seen the UI Root's different parameters, let's discuss the camera.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Camera</h2></div></div></div><p>Select the<a id="id23" class="indexterm"/> <strong>Camera</strong> GameObject in the <strong>Hierarchy</strong> view. It has the <a id="id24" class="indexterm"/>
<code class="literal">UICamera.cs</code> script attached to it. This script must be attached to any camera that needs to interact with your UI.</p><p>Its purpose is to send different messages concerning events that happen to UI elements such as colliders attached to a button. Some of the more frequently used events are <code class="literal">OnClick()</code> and <code class="literal">OnHover()</code>.</p><p>You may have multiple cameras if you consider it necessary; for example, you can have an orthographic camera for 2D in-game UI elements and a separate perspective camera for a 3D pause menu.</p><p>For the purpose of this book, we will stick with only one camera.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Parameters</h3></div></div></div><p>The <code class="literal">UICamera.cs</code> script <a id="id25" class="indexterm"/>has a large number of parameters as shown in the following screenshot:</p><div><img src="img/8667OT_01_04.jpg" alt="Parameters"/></div><p>These<a id="id26" class="indexterm"/> parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Event Type</strong>: Select which event type this camera will send.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>World</strong>: This is used for interacting with 3D-world GameObjects</li><li class="listitem" style="list-style-type: disc"><strong>UI</strong>: This is used for interacting with the 2D UI</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Event Mask</strong>: Select which layer will be used to receive events.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In our case, we will set it to <strong>GUI2D</strong> since our UI will reside on it.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Debug</strong>: This consists of the enable or disable debug mode options. This option is useful when you have unwanted behavior.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enabled: When <strong>Debug</strong> is enabled, the currently hovered object will be displayed on the top left-hand corner of the screen</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Allow Multi Touch</strong>: This consists of the enable or disable touch mode options that allow simultaneous touches. This is mandatory if you want to use pinch-to-zoom or other such gestures on mobile platforms.</li><li class="listitem" style="list-style-type: disc"><strong>Sticky Press</strong>: <a id="id27" class="indexterm"/>This consists of the enable or disable sticky press mode options.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enabled: If you drag your finger out of a pressed button, it will remain in the pressed state and no other element will receive upcoming events from that finger until it is released</li><li class="listitem" style="list-style-type: disc">Disabled: If you drag your finger out of a pressed button, it will no longer be pressed and other elements will receive upcoming events from that finger</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Sticky Tooltip</strong>: It consists of the enable or disable sticky tool tip mode options.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enabled: The tool tip disappears when the mouse moves out of the widget</li><li class="listitem" style="list-style-type: disc">Disabled: The tool tip disappears as soon as the mouse moves</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Tooltip Delay</strong>: It consists of the required stationary time in seconds before the widget's tool tip is displayed.</li><li class="listitem" style="list-style-type: disc"><strong>Raycast Range</strong>: A raycast is an invisible ray that is cast from one point towards a specific direction and is stopped if it encounters another object. The camera uses raycasts from the mouse or touch position towards the camera's forward direction to detect collisions and handle events. You may set the range of this raycast if you need to limit the interaction to a certain range. The default <strong>-1</strong> value implies that the raycast's range will be as far as the camera can see.</li><li class="listitem" style="list-style-type: disc"><strong>Event Sources</strong>: These Booleans let you specify what events this camera listens to.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mouse</strong>: This is used for mouse movements, left/right/middle click, and scroll wheel.</li><li class="listitem" style="list-style-type: disc"><strong>Touch</strong>: This is used for touch-enabled devices.</li><li class="listitem" style="list-style-type: disc"><strong>Keyboard</strong>: This is used for keyboard input. It uses the <code class="literal">OnKey()</code> event.</li><li class="listitem" style="list-style-type: disc"><strong>Controller</strong>: This is used for joystick-based devices. It uses the <code class="literal">OnKey()</code> event.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Thresholds</strong>: These values come in handy when you want to specify the minimum values before a particular event is triggered. This may vary from one game/app to another.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mouse Drag</strong>: When a mouse button is pressed (the <code class="literal">OnPress()</code> event is triggered), this value determines how far in pixels the mouse must move before it is considered a drag, and sends <code class="literal">OnDrag()</code> events to the dragged object</li><li class="listitem" style="list-style-type: disc"><strong>Mouse Click</strong>: When a mouse button is pressed (the <code class="literal">OnPress()</code> event is triggered), this value determines how far in pixels the mouse can travel before the button release has no effect (the <code class="literal">OnClick()</code> event is not triggered)</li><li class="listitem" style="list-style-type: disc"><strong>Touch Drag</strong>: This is the same as <strong>Mouse Drag</strong>, but for touch-based devices</li><li class="listitem" style="list-style-type: disc"><strong>Touch Tap</strong>: This is the same as <strong>Mouse Click</strong>, but for touch-based devices</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Axes and Keys</strong>: These <a id="id28" class="indexterm"/>parameters let you assign Unity input axes and keys to NGUI's input system.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Horizontal</strong>: This is the input axis for horizontal movement (the left and right key events)</li><li class="listitem" style="list-style-type: disc"><strong>Vertical</strong>: This is the input axis for vertical movement (the up and down key events)</li><li class="listitem" style="list-style-type: disc"><strong>Scroll</strong>: This is the input axis for scrolling</li><li class="listitem" style="list-style-type: disc"><strong>Submit 1</strong>: This is the primary keycode for validation</li><li class="listitem" style="list-style-type: disc"><strong>Submit 2</strong>: This is the secondary keycode for validation</li><li class="listitem" style="list-style-type: disc"><strong>Cancel 1</strong>: This is the primary keycode for cancel.</li><li class="listitem" style="list-style-type: disc"><strong>Cancel 2</strong>: This is the secondary keycode for cancel.</li></ul></div><div><div><h3 class="title"><a id="note03"/>Note</h3><p>You can edit Unity inputs at any time by navigating to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Input</strong>.</p></div></div></li></ul></div><p>Ok, we have seen what the main parameters of the <code class="literal">UICamera</code> component are. We have to see what the camera's anchor child is.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Anchor</h2></div></div></div><p>An<a id="id29" class="indexterm"/> anchor is used to attach GameObjects to the same area<a id="id30" class="indexterm"/> inside the camera view. For example, you can attach them to borders or corners of the screen, or another widget.</p><p>Select the <strong>Anchor</strong> GameObject in the <strong>Hierarchy</strong> view. It has the <strong>UIAnchor</strong> component attached to it. It is configured to center content on the screen based on the parent camera.</p><p>Before we create widgets, we must understand how these <strong>UIAnchor</strong> parameters modify their placement behavior.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Parameters</h3></div></div></div><p>The <strong>UIAnchor</strong> component<a id="id31" class="indexterm"/> has seven parameters as seen in the following screenshot:</p><div><img src="img/8667OT_01_05.jpg" alt="Parameters"/></div><p>These parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Ui Camera</strong>: This is the reference camera from which our anchor bounds are determined. By default, it is set to the camera used by the UI.</li><li class="listitem" style="list-style-type: disc"><strong>Container</strong>: If you drag and drop a GameObject in this field, it will overwrite the camera anchoring. This can be useful if you need to anchor your panels or widgets based on a container GameObject, instead of a camera. Your content will be placed using the assigned container's position.</li><li class="listitem" style="list-style-type: disc"><strong>Side</strong>: Do you want your child GameObjects to be centered or attached to one side or corner of your referenced camera/container? You can choose your anchor point here.</li><li class="listitem" style="list-style-type: disc"><strong>Half Pixel Offset</strong>: You should leave this Boolean checked. It makes widget positions pixel perfect on Windows machines.</li><li class="listitem" style="list-style-type: disc"><strong>Run Only Once</strong>: This Boolean can be checked if your screen resolution never changes, or if you want it to remove it on start. As a result, your anchor will be executed at the start and then removed and no longer be updated.</li><li class="listitem" style="list-style-type: disc"><strong>Relative Offset</strong>: This <code class="literal">Vector2</code> class takes two values between -1 and 1 to add a relative offset to the final position. With a value of 0.12 for <strong>X</strong> and 0.32 for <strong>Y</strong>, it will result in an offset of 12% horizontally and 32% vertically—it will look the same<strong> </strong>on any resolution because the offset depends on the screen size.</li><li class="listitem" style="list-style-type: disc"><strong>Pixel Offset</strong>: This parameter is like <strong>Relative Offset</strong>, but it is absolute instead of relative. You can enter the offset in pixels—it will look different<strong> </strong>depending on the resolution because the offset will stay identical in pixels on all screen sizes.</li></ul></div><p>We have <a id="id32" class="indexterm"/>explained the different <strong>UIAnchor</strong> parameters, but what is this last child, Panel? Let's look into that, and we'll be ready to create our first widget!</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Panel</h2></div></div></div><p>Select <a id="id33" class="indexterm"/>the <strong>Panel</strong> GameObject in the <strong>Hierarchy</strong> view. It has a <strong>UIPanel</strong> component attached.</p><p>A panel's purpose <a id="id34" class="indexterm"/>is to hold widgets and render geometry in only one draw call. You may create multiple panels to split your UI, but it will add a draw call per new panel.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Parameters</h3></div></div></div><p>The <a id="id35" class="indexterm"/>
<code class="literal">UIPanel.cs</code> script has eight parameters as shown in the following screenshot:</p><div><img src="img/8667OT_01_06.jpg" alt="Parameters"/></div><p>These parameters<a id="id36" class="indexterm"/> are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Alpha</strong>: You may change the <strong>transparency level</strong><a id="id37" class="indexterm"/> of the entire panel. All child widgets will be affected by this alpha value, but nested panels won't.</li><li class="listitem" style="list-style-type: disc"><strong>Depth</strong>: This is used to define which panel is rendered over another. A panel with a depth value of 1 will appear in front of a panel with a depth value of 0. You can use either the <strong>Back</strong> or <strong>Forward</strong> button to change the <strong>Depth</strong> or simply enter a number in the field. Panels can also have negative depth.</li><li class="listitem" style="list-style-type: disc"><strong>Normals</strong>: This Boolean must be checked if you need it to react to lighting<strong> </strong>using shaders. It will calculate normals for your UI geometry.</li><li class="listitem" style="list-style-type: disc"><strong>Cull</strong>: This Boolean gives you the ability to disable the child widgets rendering while the panel is being dragged, which improves performance.</li><li class="listitem" style="list-style-type: disc"><strong>Static</strong>: If all your panel's widgets are static and won't ever move, check this—it will improve performance!</li><li class="listitem" style="list-style-type: disc"><strong>Show All</strong>: This <a id="id38" class="indexterm"/>will show all draw calls in the <strong>Inspector</strong> view.</li><li class="listitem" style="list-style-type: disc"><strong>Panel Tool</strong>: This is a panel managing tool. You can visualize and select each panel in the scene. You can open it with <em>Alt</em> + <em>Shift</em> + <em>P</em> or navigate to <strong>NGUI</strong> | <strong>Open</strong> | <strong>Panel Tool</strong>. Will this panel show in the <strong>Panel Tool</strong> parameter? This should be unchecked for dynamically created temporary panels through code, like a warning message or ammo pick-up notification.</li><li class="listitem" style="list-style-type: disc"><strong>Clipping</strong>: This will let us hide widgets outside a given rectangle. When turned on, you will be able to choose the clipping rectangle's dimensions with the <code class="literal">Center</code> and <code class="literal">Size</code> parameters. Anything outside this rectangle will be hidden.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>None</strong>: No clipping—the entire panel will be displayed.</li><li class="listitem" style="list-style-type: disc"><strong>Hard Clip</strong>: Clipping enabled—rough clipping of widgets outside the box.</li><li class="listitem" style="list-style-type: disc"><strong>Soft Alpha</strong>: Clipping enabled—soft clipping with fade-out / fade-in borders.</li></ul></div><p>We've now taken a look at the parameters of the <strong>UIPanel</strong> component, which will be used to hold our widgets.</p></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>During this chapter, we discussed NGUI's basic workflow—it works with GameObjects, uses atlases to combine multiple textures in one large texture, has an event system, can use shaders, and has a localization system.</p><p>After importing the NGUI plugin, we created our first 2D UI with the UI Wizard, reviewed its parameters, and created our own GUI 2D layer for our UI to reside on.</p><p>Finally, we analyzed the four GameObjects that were created automatically for us by NGUI. After reviewing their parameters, we can summarize their roles as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>UI Root</strong> holds the UI and scales it for pixel perfect or fixed sizes</li><li class="listitem" style="list-style-type: disc">The <strong>Camera</strong> views the UI and sends messages to the widgets for interactions</li><li class="listitem" style="list-style-type: disc">The <strong>Anchor</strong> can attach elements to the borders of screen or objects and add offsets</li><li class="listitem" style="list-style-type: disc">The <strong>Panel</strong> holds our widgets and renders them, with or without clipping</li></ul></div><p>We are now ready to create our first widget. It's time to move on to the next chapter.</p></div></body></html>