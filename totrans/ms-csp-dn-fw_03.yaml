- en: Chapter 3. Advanced Concepts of C# and .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how the C# language evolved in early versions, 2.0 and 3.0, with
    important features, such as generics, lambda expressions, the LINQ syntax, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 4.0, some common and useful practices were eased into
    the language (and framework libraries), especially everything related to synchronicity,
    execution threads, parallelism, and dynamic programming. Finally, although versions
    6.0 and 7.0 don't include game-changing improvements, we can find many new aspects
    intended to simplify the way we write code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'New features in C# 4: covariance and contravariance, tuples, lazy initialization,
    Dynamic programming, the `Task` object and asynchronous calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The async/await structure (belongs to C# 5).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s new in C# 6.0: string interpolation, Exception filters, the `NameOf`
    operator, null-conditional operator, auto-property initializers, static using,
    expression bodied methods and index initializers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'News in C# 7.0: Binary Literals, Digit Separators, Local Functions, Type switch,
    Ref Returns, Tuples, Out var, Pattern Matching, Arbitrary async returns and Records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# 4 and .NET framework 4.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the release of Visual Studio 2010, new versions of the framework showed
    up, although that was the last time they were aligned (to date). C# 5.0 is linked
    to Visual Studio 2012 and .NET framework 4.5, and C# 6, appeared in Visual Studio
    2015 and was related to a new (not too big) review of .NET framework: 4.6\. The
    same happens to C#7, although this is aligned with Visual Studio 2017.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to clarify things, I''m including a table that shows the whole evolution
    of the language and the frameworks aligned to them along with the main features
    and the corresponding version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '| C# version | .NET version | Visual Studio | Main features |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| C# 1.0 | .NET 1.0 | V. S. 2002 | Initial |'
  prefs: []
  type: TYPE_TB
- en: '| C# 1.2 | .NET 1.1 | V. S. 2003 | Minor features and fixes. |'
  prefs: []
  type: TYPE_TB
- en: '| C# 2.0 | .NET 2.0 | V. S. 2005 | Generics, anonymous methods, nullable types,
    iterator blocks. |'
  prefs: []
  type: TYPE_TB
- en: '| C# 3.0 | .NET 3.5 | V. S. 2008 | Anonymous types, var declarations (implicit
    typing), lambdas, extension methods, LINQ, expression trees. |'
  prefs: []
  type: TYPE_TB
- en: '| C# 4.0 | .NET 4.0 | V. S. 2010 | Delegate and interface generic variance,
    dynamic declarations, argument improvements, tuples, lazy instantiation of objects.
    |'
  prefs: []
  type: TYPE_TB
- en: '| C# 5.0 | .NET 4.5 | V. S. 2012 | Async/await for asynchronous programming
    and some other minor changes. |'
  prefs: []
  type: TYPE_TB
- en: '| C# 6.0 | .NET 4.6 | V. S. 2015 | Roslyn services and a number of syntax simplification
    features. |'
  prefs: []
  type: TYPE_TB
- en: '| C# 7.0 | .NET 4.6 | V. S. 2017 | Syntatic "sugar", extended support for tuples,
    Pattern Matching, and some minor features. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 1: Alignment of C#, .NET, and Visual Studio versions*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, let's start with delegate and interface generic variance, usually called
    covariance and contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and contravariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As more developers adopted the previous techniques shown in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Core Concepts of C# and .NET"), *Core Concepts of C# and .NET*, new
    necessities came up and new mechanisms appeared to provide flexibility were required.
    It's here where some already well-known principles will apply (there were theoretical
    and practical approaches of compilers and authors, such as Bertrand Meyer).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Luca Cardelli* explains as far back as in 1984 the concept of variant in OOP
    (refer to *A semantics of multiple inheritance* by Luca Cardelli ([http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf](http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf)).'
  prefs: []
  type: TYPE_NORMAL
- en: Meyer referred to the need for generic types in the article *Static Typing*
    back in 1995 (also available at [http://se.ethz.ch/~meyer/publications/acm/typing.pdf](http://se.ethz.ch/~meyer/publications/acm/typing.pdf)),
    indicating that *for safety, flexibility, and efficiency, the proper combination*
    (he's talking about static and dynamic features in a language) *is, I believe,
    static typing and dynamic binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other seminal work, nowadays widely used, *ACM A.M. Turing Award* winner
    *Barbara Liskov* published his famous *Substitution Principle*, which states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '"In a computer program, if S is a subtype of T, then objects of type T may
    be replaced with objects of type S (i.e., objects of type S may substitute objects
    of type T) without altering any of the desirable properties of that program (correctness,
    task performed, etc.)."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some ideas about covariance and contra-variance are explained in an excellent
    explanation published by Prof. Miguel Katrib and Mario del Valle in the already
    extinct *dotNetMania* magazine. However, you can find it (in Spanish) at [https://issuu.com/pacomarin3/docs/dnm_062](https://issuu.com/pacomarin3/docs/dnm_062).
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, this means that if we have a type, `Polygon`, and two subtypes, `Triangle`
    and `Rectangle`, which inherit from the former, the following actions are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The concept of variance is related to situations where you can use classes,
    interfaces, methods, and delegates defined over a type `T` instead of the corresponding
    elements defined over a subtype or super-type of `T`. In other words, if `C<T>`
    is a generic entity of type `T`, can I substitute it for another of type `C<T1>`
    or `C<ST>`, `T1` being a subtype of `T` and `ST` a super-type of `T`?
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the proposal, basically, the question arises where can I apply
    Liskov's substitution principle and expect correct behavior?
  prefs: []
  type: TYPE_NORMAL
- en: This capability of some languages is called (depending on the direction of the
    inheritance) covariance for the subtypes, and its counterpart, contravariance.
    These two features are absolutely linked to parametric polymorphism, that is,
    generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In versions 2.0 and 3.0 of the language, these features were not present. If
    we write the following code in any of these versions, we will not even get to
    compile it, since the editor itself will notify us about the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even before compiling, we will be advised that it''s not possible to convert
    a triangle into a polygon, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance and contravariance](img/image00454.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous example, the solution is easy when we use C# 4.0 or higher:
    we can convert the `triangles` assignment to `List<Polygon>` by calling the generic
    type converter for `List` just by adding a simple call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, LINQ extensions come to our rescue, since several converters were
    added to collections in order to provide them with these type of convenient manipulations,
    which simplify the use object's hierarchies in a coherent manner.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance in interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this code, where we change the defined polygons identifier as type
    `IEnumerable<Polygon>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn''t lead to a compilation error because the same ideas are applied
    to interfaces. To allow this, the generic parameter of interfaces such as `IEnumerable<T>`
    is used only as an out value. In such cases, it''s interesting to take a look
    at the definition using the **Peek Definition** option (available on the editor''s
    context menu for any type):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance in interfaces](img/image00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In turn, the `IEnumerable` interface only defines the `GetEnumerator` method
    in order to return an iteration mechanism to go through a collection of `T` types.
    It's only used to return `T` by means of the `Current` property and nothing else.
    So, there's no danger of the possible manipulation of elements in an incorrect
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, according to our example, there's no way you can use an object
    of type `T` and place a rectangle where a triangle is expected because the interface
    specifies that `T` is used only in an exit context; it's used as a return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the definition of this in Object Browser, asking for `IEnumerator<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance in interfaces](img/image00456.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s not the same situation, though, when you use another interface, such
    as `IList`, which allows the user to change a type once it is assigned in the
    collection. For instance, the following code generates a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is just the same as earlier, only changing the type
    of generic interface used for the `polygons3` assignment. Why? Because the definition
    of `IList` includes an indexer that you could use to change the internal value,
    as Object Explorer shows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other indexer, the implementation provides a way to change a value
    in the collection by a direct assignment. This means that we can write this code
    to provoke a breach in the hierarchy of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the definition of interface `IList<T>`: `this[int]` is read/write, as
    the next capture shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance in interfaces](img/image00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is due to the ability to set an item in the collection to another value
    once it is created, as we can see in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that this `out` specification is only applicable when using
    the interface. `Types` derived from `IEnumerable<T>` (or any other interface that
    defines an `out` generic parameter) are not obliged to fulfill this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this covariance is only applicable to reference types when using
    references' conversion statements. That's the reason why we cannot assign `IEnumerable<int>`
    to `IEnumerable<object>`; such conversion implies boxing (the heap and the stack
    are implicated), so it's not a pure reference conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance in generic types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Covariance can be extended to generic types and used with predefined delegates
    (remember, those delegates supplied by the Framework Factory that can be of types
    `Action`, `Predicate`, and `Func`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To place a simple code that shows this feature, observe the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re assigning a list of delegates of type `Rectangle` to an enumerable
    of delegates of type `Polygon`. This is possible because three characteristics
    play their role:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rectangle` is assignable to `Polygon` for Substitution Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Func<Rectangle>` is assignable to `Func<Polygon>` due to covariance in the
    generic `out T` parameter of `Func<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `IEnumerable<Func<Rectangle>>` is assignable to `IEnumerable<Func<Polygon>>`
    due to a covariance extension over the generic type `out T` of `IEnumerable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the mentioned Substitution Principle should not be mistaken with the
    convertible character of some types (especially, primitive or basic types).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this feature, just think of the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second sentence generates a compilation error because although there is
    an implicit conversion from `int` to `double`, such conversion is considered for
    covariance, since this is only applicable to inheritance relations between types,
    and that is not the case with `int` and `double` types because none of them inherits
    from the other.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance in LINQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another situation in which covariance is important shows up when using some
    of the operators defined by the LINQ syntax. This happens, for instance, with
    the `Union` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous versions, consider that you try to code something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you code something like the preceding code, you will get a compilation error,
    which doesn't happen from version 4.0 onward. This is because in the renewed definition,
    parameters of operator `Union` use the mentioned covariance, since they are of
    type `IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s not possible to compile something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is because the compiler indicates that there's no definition of `Union`
    and the best method overload, `Queryable.Union<Program.Rectangle> (IQueryable<Program.Rectangle>,
    IEnumerable<Program.Rectangle>)`, requires a receiver of type `IQueryable<Program.Rectangle>`,
    as shown in the upcoming screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be avoided this time by means of helping the compiler understand our
    purpose via generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the way in which the **Error List** window describes the error, justifying
    it in terms of proper source code elements and their definitions and capabilities
    (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Covariance in LINQ](img/image00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contravariance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The case of contravariance is different and usually a bit more difficult to
    understand. To comprehend things through a known example, let's remember the `IComparer<T>`
    interface that we used in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used an implementation of `IComparer<T>` to compare collections of types
    `Customer` and `Provider` indistinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can compare both types as long as the `Customer` and `Provider`
    classes implement the `IPersonBalance` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous (to C# 4.0) versions of the language, consider that you tried to
    use a similar code to compare polygons and triangles, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then get an error indicating the usual: there''s no conversion between
    `Triangle` and `Polygon`, while there''s really no risk in receiving these types
    since no change will happen; they will only be used to compare the entities.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the inheritance arrow goes upside down—from the specific to the
    generic—and since both are of type `Polygon`, the comparison should be possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from version 4.0 of C#, this was changed. The new definition of the
    `IComparer` interface defines another `in` modifier for the `T` operator, using
    the **Peek Definition** feature when you right-click on the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Contravariance](img/image00459.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the definition indicates that parameter `T` is contravariant:
    you can use the type you specified or any type that is less derived, that is,
    any antecessor of the type in the inheritance chain.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `in` modifier specifies this possibility and indicates to
    the compiler that type `T` can only be used in entry contexts, such as what happens
    here because the purpose of `T` is to specify the type of entry arguments `x`
    and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples: a remembrance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From very early times, programming languages try to express the idea of tuples,
    first embodied in the COBOL language. Later, Pascal followed it up with the concept
    of record: a special type of data structure that, unlike arrays, collects data
    types of different natures in order to define a particular structure, such as
    a customer or a product.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's also remember that the C language itself provided structures (structs)
    enhanced into objects in the C++ evolution. Usually, every field of this structure
    represents a characteristic of the whole, so it makes more sense to access its
    value through a meaningful description instead of using its position (like in
    arrays).
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea was also related to the database relational model, so it was particularly
    suitable to represent these entities. With objects, functionalities are added
    to recreate fragments of real object properties that are required to be represented
    in an application: the object model.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the interest of reusability and adaptability, OOP started promoting
    objects to hide parts of its state (or the whole state) as a means to preserve
    its internal coherence. *Methods of a class should only have the purpose of maintaining
    the internal logic of its own state*, said a theoretician at the beginning of
    an OOP class in a well-known university whose name I don't want to remember. We
    can admit that, exceptions aside, this assertion is true.
  prefs: []
  type: TYPE_NORMAL
- en: If there are parts of the state that can be abstracted (in math terms, you could
    say that they constitute a pattern), they are candidates for a higher class (abstract
    or not), so reusability starts with these common factors.
  prefs: []
  type: TYPE_NORMAL
- en: Along this evolution, the concept of tuple got lost in a way, ceding all the
    land to the concept of object, and programming languages (with some notable exceptions,
    mainly in the area of functional languages) ceased to have their own notation
    in order to work with tuples.
  prefs: []
  type: TYPE_NORMAL
- en: However, practice has shown that not all work with data requires the wearing
    of uniform objects. Perhaps one of the most obvious situations shows up when querying
    data from a database—the way we've seen in LINQ queries. Once the filtered data
    meets certain requirements, we only need some components (which is known as a
    projection in the jargon of databases, as we've tested in previous examples).
  prefs: []
  type: TYPE_NORMAL
- en: This projections are nothing but anonymous objects, which don't deserve to be
    predefined, since they're usually handled in a single procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples: implementation in C#'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of tuples in .NET 4 is based on the definition (`mscorlib.dll`
    assembly and the `System` namespace) of eight generic classes `Tuple<>` with different
    number of type parameters to represent tuples of different cardinalities (it's
    also called arity).
  prefs: []
  type: TYPE_NORMAL
- en: As a complement to this family of generic classes, eight overloads of the `Create`
    method in the `Tuple` class are provided, converting it into a factory of many
    possible variations of these types. In order to deliver resources for the creation
    of longer tuples, the eighth tuple in the list can also be a tuple itself, allowing
    it to grow as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of one of these methods. Thus,
    to create tuples, we can take advantage of a more concise notation and write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll discover how the Intellisense system of Visual Studio warns us about
    the structure generated by this declaration and how it is interpreted by the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuples: implementation in C#](img/image00460.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we can express it in this simple way instead of using the following, more
    explicit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since tuples can hold elements of any kind, it is alright to declare a tuple
    of a variety of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to what we would do when defining the elements of an object''s
    state, and we can be sure that the compiler will infer its different types, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuples: implementation in C#](img/image00461.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This usage becomes obvious when comparing it with a typical record in the database's
    table, with the ability of vertically selecting the members (fields, if you want)
    that we need. We're going to see an example of comparing tuples with anonymous
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples: support for structural equality'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the tuples .NET classes (and, therefore, their bodies treated by reference),
    comparing two tuples with the `==` operator is referential; that is, it relies
    on memory addresses where the compared objects reside; therefore, it returns `false`
    for two different objects-tuples even if they store identical values.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `Equals` method has been redefined in order to establish equality
    based on the comparison of the values of each pair of corresponding elements (the
    so-called structural equality), which is desired in most tuple's applications
    and which is also the default semantics for the comparison of tuples' equality
    in the F# language.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the implementation of structural equality for tuples has its peculiarities,
    starting with the fact that tuples with a tupled eighth member have to be accessed
    in a recursive manner.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples versus anonymous types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the case of projections, tuples adapt perfectly and allow us to get rid
    of anonymous types. Imagine that we want to list three fields of a given `Customers`
    table (say, their `Code`, `Name`, and `Balance` fields from dozens of possible
    fields), and we need to filter them by their `City` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assume that we have a collection of customers named `Customers`, it''s
    easier to write a method in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, the method returns `IEnumerable<Tuple<int, string, double>>`, which we can
    refer where required, having extra support from the Intellisense engine and making
    it very easy to iterate and present in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this feature, I''ve generated a random name list from the site ([http://random-name-generator.info/](http://random-name-generator.info/))
    named `ListOfNames.txt` in order to have a list of random customer names, and
    I have populated the rest of fields with random values so that we have a list
    of customers based on the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are quite a lot of random name generators you can find on the Internet,
    besides the ones mentioned previously. You can just configure them (they allow
    a certain degree of tuning) and save the results in a text file within Visual
    Studio. Only, remember that the copy and paste operation will most likely include
    a Tab code (`\t`) separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TuplesDemo` class, which holds the entry point, the following code
    is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this structure, everything works fine, and there''s no need to use anonymous
    objects, as we can see in the Console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuples versus anonymous types](img/image00462.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The only imperfection comes from the way we make references to `Balance` members,
    since they lose the type names, so we have to reference them by the identifiers
    `Item1`, `Item2`, and so on (this has been improved in version C# 7 where tuples'
    members can have identifiers).
  prefs: []
  type: TYPE_NORMAL
- en: But even so, this is an advantage with respect to the previous approach, and
    we have more control over the generated members coming out of the LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization and instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To finish this review on the most important features appearing in C# 4.0, I''d
    like to cover a new way of the instantiation of objects, named lazy initialization.
    The official documentation defines lazy objects and lazy initialization of an
    object, indicating that its creation is deferred until it is first used. (Note,
    here, that both terms are synonymous: initialization and instantiation).'
  prefs: []
  type: TYPE_NORMAL
- en: This reminds us that *Lazy initialization is primarily used to improve performance,
    avoid wasteful computation, and reduce program memory requirements*. Typically,
    this happens when you have an object that takes some time to create (like a connection)
    or, for any reason, might produce a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating the object in the usual way, .NET 4.0 introduces `Lazy<T>`,
    which defers the creation effectively, allowing evident performance improvements,
    as we'll see in the following demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the previous code, but this time, we double the method for the creation
    of customers by adding a lazy version of it. To be able to prove it more accurately,
    we introduce a delay in the constructor of the `Customer` class, so it finally
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note two main differences: first, the constructor forces a delay of a tenth
    of a second for every call. Second, the new way to create the `Customer` list
    (`getCustomersLazy`) is declared as `List<Lazy<Customer>>`. Besides, every call
    to the constructor comes from a lambda expression associated with the `Lazy<Customer>`
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Main` method, this time, we don''t need to present the results; we
    only need to present the time elapsed for the creation of `Customers` using both
    approaches. So, we modified it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, the same class is called, and the same sentences are also
    used in creation, only changed to be lazy in the first creation process. By the
    way, you can change the order of creation (calling the non-lazy routine in the
    first place) and check whether there''s no meaningful change in performance: the
    lazy structure executes almost instantly (hardly some more than 100 milliseconds,
    which is the time forced by `Thread.Sleep(100)` in the initial creation of `Customer`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference, as you can see in the following screenshot, can be significant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy initialization and instantiation](img/image00463.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, a new and useful solution for certain scenarios that appeared in version
    4.0 of the framework becomes especially interesting when delaying the creation
    of objects can produce big differences in time for the initial presentation of
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most requested features by programmers was the ability to create
    and manipulate objects without the restrictions imposed by static typing, since
    there are many daily situations in which this possibility offers a lot of useful
    options.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's not mistake the dynamic features offered by C# 4.0 with the concept
    of Dynamic Programming in general computer science, in which the definition refers
    to the case where a problem is divided into smaller problems, and the optimal
    solution for each of these cases is sought, with the program being able to access
    each of these smaller solutions at a later time for optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of .NET Framework, though, C# 4.0 introduced a set of features
    linked to a new namespace (`System.Dynamic`) and a new reserved word, `dynamic`,
    which allows the declaration of elements that get rid of the type-checking feature
    we've seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `dynamic` keyword, we can declare variables that are not checked
    in compilation time but can be resolved at runtime. For instance, we can write
    the following declaration without any problems (at the time of writing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `o` has been declared in an static way as dynamic, which is a
    type supported by the compiler. This code compiles even without knowing what `UnknownMethod`
    means or whether it exists at execution time. If the method doesn''t exist, an
    exception will be thrown. Concretely, due the dynamic binding nature of the process,
    a `Microsoft.CSharp.RuntimeBinder.RuntimeBinderException` comes up, as we see
    when we misspell a call to the `ToUpper()` method in a string (we''ll explain
    the code snippet a bit later):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic typing](img/image00464.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When this kind of declaration appeared, there was some confusion related to
    the differences with declaring the previous sentence, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that we have to know previously that a type `T` exists
    and it has a method called `UnknownMethod`. In this case, the casting operation
    ensures that an IL code is generated to guarantee that the `p` reference is conformant
    with the `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, the compiler cannot emit the code to call `UnknownMethod`
    because it doesn't even know whether such a method exists. Instead, it emits a
    dynamic call, which will be handled by another, new execution engine called **Dynamic
    Language Runtime**, or **DLR**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The role of DLR, among others, is also to infer the corresponding type, and
    from that point, treat dynamic objects accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this that means we can not only use the value of `dyn`, but also its properties
    and methods like what the previous code shows, behaving in the way that''s expected,
    and showing that `dyn` is a type string object and presenting the results in Console,
    just as if we have declared `dyn` as `string` from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic typing](img/image00465.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Perhaps you remember the reflection characteristics we mentioned in [Chapter
    1](part0015.xhtml#aid-E9OE2 "Chapter 1. Inside the CLR"), *Inside the CLR*, and
    are wondering why we need this if many of the features available in this manner
    can be also managed with reflection programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a comparison, let''s quickly remember how this possibility would look
    like (let''s say we want to read the `Length` property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For this scenario, we get the same output that we expect, and technically,
    the performance penalty is dismissible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic typing](img/image00466.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It seems that both results are the same, although the way in which we get them
    is quite different. However, besides the boilerplate involved in reflection techniques,
    DLR is more efficient, and we also have the possibility of personalizing dynamic
    invocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s true that it might seem contradictory for experienced static typing programmers:
    we lose the Intellisense linked to it, and the dynamic keyword forces the editor
    behind to understand that methods and properties accompanying such types will
    present themselves as dynamic as well. Refer to the tooltip shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic typing](img/image00467.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Part of the flexibility of this feature comes from the fact that any reference
    type can be converted into dynamic, and this can be done (via `Boxing`) with any
    value type.
  prefs: []
  type: TYPE_NORMAL
- en: However, once we have established our dynamic object to be of a type (such as
    `String`, in this case), the dynamism ends there. I mean, you cannot use other
    kinds of resources apart from those available in the definition of the `String`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The ExpandoObject object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the additions linked to this dynamic feature of the language is something
    called `ExpandoObject`, which—as you might have figured out by the name—allows
    you to expand an object with any number of properties of any type, keeping the
    compiler quiet and behaving in a similar way as it would happen when coding in
    real dynamic languages, such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can use one of these `ExpandoObject` object to create
    an object that grows in a totally dynamic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As the preceding code shows, it is not just that we can expand the object with
    new properties of the type we want; we can even nest objects inside each other.
    There''s no problem at runtime, as this screenshot shows in the Console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ExpandoObject object](img/image00468.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Actually, these dynamic features can be used in conjunction with other generic
    characteristics we've already seen, since the declaration of generic dynamic objects
    is also allowed in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this, we can create a method that builds `ExpandoObjects` containing
    some information about Packt Publishing books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that everything is declared as dynamic: the method itself and the arguments
    passed to it as well. Later on, we can use generic collections with these objects,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything works as expected. Internally, `ExpandoObject` behaves like `Dictionary<string,
    object>`, where the name of the field added dynamically is the key (of type `String`),
    and the value is an object of any kind. So, in the previous code, the `Find` method
    of the `List` collection works correctly, finds the object we''re looking for,
    and retrieves the title to show it the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ExpandoObject object](img/image00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are some other dynamic features, but we will deal with some of them in
    the chapter dedicated to Interop, where we'll examine the possibilities of an
    interaction between a C# application and other applications in the OS, including
    Office applications and—generally speaking—any other application that implements
    and exposes a Type library.
  prefs: []
  type: TYPE_NORMAL
- en: Optional and named parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The declaration of optional parameters had been requested by programmers a long
    time ago, especially considering that it's a feature that was present in Visual
    Basic .NET since the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the Redmond team implemented this is simple: you can define a constant
    value associated with a parameter as long as you locate the parameter at the end
    of the parameters'' list. Thus, we can define one of those methods in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Thus, optional parameters are characterized by being given an initial value.
    In this way, if the `RepeatStringOptional` method is called with only one argument,
    the `text` parameter is initialized with the passed value, so it will never be
    null. The IDE itself reminds us of such a situation when writing a call to the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional and named parameters](img/image00470.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that by convention, any element enclosed in square brackets is considered
    optional in computer science definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a variant of the previous feature, we can also provide an argument with
    name using the `function_name (name: arg)` syntax pattern. The same structural
    pattern of optional arguments is followed; that is, if we pass a named argument
    to a function, it has to be placed after any other positional argument, although
    within the named parameters section their relative order does not matter.'
  prefs: []
  type: TYPE_NORMAL
- en: The Task object and asynchronous calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although it is not part of the language itself, a **Base Class Library** (**BCL**)
    feature is worth mentioning in this chapter, as it is one of the most important
    innovations in this version of the framework. Up until this point, building and
    executing threads was something that was covered mainly in two forms: using the
    objects provided by the `System.Thread` namespace (available since version 1.0
    of the framework) and from version 3.0, using the `BackgroundWorker` object, which
    was a wrapper on top of a functionality available in `System.Thread` to facilitate
    the creation of these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The latter was primarily used in long duration processes, when a feedback was
    required during execution (progress bars, among others). It was a first attempt
    to ease thread programming, but since the new `Task` object came up, most of these
    scenarios (and many others, implying parallel or thread running processes) are
    mainly coded in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its usage is simple (especially when compared to previous options). You can
    declare a `Task` non-generic object and associate it with any method with the
    help of an `Action` delegate, as the IDE suggests when creating a new task by
    calling its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Task object and asynchronous calls](img/image00471.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, if we have a slow method and we have no special requirements about the
    type returned (so it can be non-generic), it''s possible to call it in a separate
    thread by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note a few details in this code: first, the argument is passed by reference.
    This means that the value of `theString` is changed by `SlowMethod`, but no return
    type is provided because the method should fit the signature of an `Action` (no
    return type); thus, to access the modified value, we pass it by reference and
    include in our `SlowMethod` code how to modify it.'
  prefs: []
  type: TYPE_NORMAL
- en: The other main point is that we need to wait until `SlowMethod` finishes before
    trying to access `theString` (observe that the method is forced to take 3 seconds
    to complete by calling `Thread.Sleep(3000)`. Otherwise, execution would continue
    and the value accessed would be just the original empty string. In between, it's
    possible to perform other actions, such as printing a message in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic variation of this object is also provided when we need `Task` to
    operate with a given type. As long as we define a variable of type `Task<T>`,
    the IDE changes the tooltip to remind us that in this case, a delegate of type
    `Func<T>` should be provided instead of `Action`, as is the case. You can compare
    this screenshot with the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Task object and asynchronous calls](img/image00472.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, in the following code, we adopt the more common approach of creating
    the generic Task object by calling the `StartNew<T>` method available in the `Factory`
    object of `Task<T>`, so we can simplify the former example in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this time we don't need an intermediate variable to store the
    return value, and the `Task<T>` definition allows you to create a `Task` object
    of almost any type.
  prefs: []
  type: TYPE_NORMAL
- en: There's much more about tasks and related features, such as parallel execution,
    asynchronous calls, and so on, so we'll go deeper into all this in [Chapter 12](part0078.xhtml#aid-2ACBS2
    "Chapter 12. Performance"), *Performance*, which we dedicate to performance and
    optimization, so take this as a very brief introduction to the subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 5.0: async/await declarations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to enhance the possibilities of creation and the management of asynchronous
    processes and to simplify the code even more, version 5.0 of C# introduced a couple
    of new reserved words in order to facilitate the insertion of asynchronous calls
    without having to implement an extra method to receive the results: the couple
    of words are `async`/`await` (one cannot be used without the other).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a method is marked as `async`, the compiler will check for the presence
    of another sentence prefixed with the `await` keyword. Although we write the method
    as a whole, the compiler fragments (internally) the method into two parts: the
    one where the `async` keyword appears initially, and the rest counting from the
    line in which `await` is used.'
  prefs: []
  type: TYPE_NORMAL
- en: At execution time, as soon as the `await` sentence is found, the execution flow
    returns to the calling method and executes the sentences that follow, if any.
    As soon as the slow process returns, execution continues with the rest of sentences
    located next to the awaited statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view a brief initial sample of how it works in a transformation of the
    previous example (as I mentioned in relation with tasks, this topic will also
    be covered with more detail in the chapter dedicated to performance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that I'm just writing the same code with a different syntax. When the execution
    flow reaches the first line of `SlowMethod` (marked as `await`), it launches another
    execution thread and returns to the thread in the calling method (`Main`). Consequently,
    we can see the `Awaiting for SlowMethod` message before the `Finished at` indication
    located at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output it is quite clear, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C# 5.0: async/await declarations](img/image00473.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, as we indicated in relation with the `Task` object, there's much
    more to this than what is expressed here in this ephemeral introduction, and we'll
    cover this in [Chapter 10](part0055.xhtml#aid-1KEEU1 "Chapter 10. Design Patterns"),
    *Design Patterns*. But for now, we can have an idea about the benefits and simplification
    provided by this code construct.
  prefs: []
  type: TYPE_NORMAL
- en: What's new in C# 6.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some pretty interesting features appeared in this version of the language, in
    many cases, linked to everyday problems and suggestions of developers worldwide.
    Also, as stated in Table 1 of this chapter, the really huge, meaningful improvement
    comes from a set of functionalities linked to Roslyn Services, which provide a
    different bunch of possibilities related to the editing and compiling features
    of the IDE. We will cover these in [Chapter 8](part0044.xhtml#aid-19UOO2 "Chapter 8. Open
    Source Programming"), *Open Source Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: However, Roselyn is not the only interesting option that appeared in C# 6.0\.
    There are a number of minor but very useful and syntactic "sweets" this version
    includes, which help the coder write more succinct expressions and reduce the
    occurrence of bugs. Let's start with something called string interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String interpolation is a way to simplify string expressions that contain C/C++
    style interpolation. For instance, instead of writing the classic `Console.Write("string
    {0}", data)` composition, we can now express this by simply including the identifier
    inside curly brackets, so the previous expression would become `$"string {data}"`
    as far as we precede the string with the `$` symbol in order to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can mix the `@` symbol with `$` given that the `$` symbol goes
    before the `@` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you can use the `{}` area to include a C# expression that will be
    correctly evaluated at runtime and converted into a string by calling the `ToString`
    method so that it's not limited to identifiers. Thus, we can even include file
    I/O operations—like we do in the following code—and get the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, I have a text file (`TextFile.txt`) with a line of content, which
    is presented in the output accompanied by a string literal in a single line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the next capture, expressions inside the curly braces are
    totally evaluated and the result inserted in the output string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![String interpolation](img/image00474.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This technique, besides simplifying expressions, can be used easily in conjunction
    with other new C# 6.0 features, such as Exception filters.
  prefs: []
  type: TYPE_NORMAL
- en: Exception filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another addition refers to exceptions. Exception filters provide a way to personalize
    any occurred exception depending on a condition that can be coded using any valid
    C# expression, which should be located next to the new `when` sub-clause that
    might follow any `Catch` clause now.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, let's suppose that we want to create a conditional test
    for an exception that doesn't have much to do with the exception itself (or maybe
    it does, but that's not the case here). Or, we can even suppose that we want to
    catch a situation related to an external state, such as the system's date/time
    or what have you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code catches a situation in which the previous file exists but
    produces an exception on Saturdays, to say something bizarre. We can modify the
    code in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This possibility provides us with new ways to catch exceptions linked to conditions
    that don't belong (necessarily) to the exception context but to any other situation;
    just consider that the expression can be much more complex than that in the demo
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The nameof operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nameof` operator is a contextual keyword with a syntax similar to `typeof`,
    which yields the name of any program element (usually, an identifier). Or, if
    you want, it converts the filename variable of the previous example into filename.
  prefs: []
  type: TYPE_NORMAL
- en: This approach offers several advantages. First, if we need the name of such
    an element, no reflection technique is required. Besides, the compiler is going
    to guarantee that whatever we pass as an argument to the operator is a valid element;
    also, it integrates with the editor's Intellisense and behaves better in some
    refactoring scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s useful in try-catch structures as well, for example, when indicating
    the reason for a failure specifying the name of the element that causes the exception
    and even in attributes, as the "official" example of MSDN suggests (refer to [https://msdn.microsoft.com/en-us/library/dn986596.aspx](https://msdn.microsoft.com/en-us/library/dn986596.aspx)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The null-conditional operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This operator is the latest member of the family of features designed to deal
    with null values in C#. Since version 1.0, we could, of course, check (`value
    == null`) within a conditional statement to avoid undesired failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, `Nullable` types arrived (remember, appending a ? symbol to a variable
    declaration allows it to be null, and these types include a Boolean `HasValue`
    property to check this situation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When a conversion is required, the `TryParse` method of many basic types allows
    us to check for valid values (not only null).
  prefs: []
  type: TYPE_NORMAL
- en: 'As language evolved, new ways of dealing with null values kept coming up. In
    C# 4.0, one of the most useful things was the null-coalescing operator. It works
    a bit like the ? operator: it locates itself between two elements to check for
    nullability, and if the left-hand side is not null, it returns it; otherwise,
    it returns the right-hand side operand. It''s so simple that it even lets you
    mix it with string interpolation in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the expected result in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The null-conditional operator](img/image00475.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, the previous code writes `Unspecified` in the console, since `str` is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in C# 6.0, we have another ability: the null conditional operator, or null
    propagation operator (or even, the `Elvis` operator, as it''s called by some members
    of the C# team, assuming that the two lower points are a couple of eyes and the
    higher part of the question mark the toupee!), which can be inserted in an expression,
    and it stops evaluating the right-hand side of the expression if the value of
    the `adorned` element with the operator is not present. Let''s understand this
    better through an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to print out the length of the `str` string in the previous case,
    we can simply add another Console sentence, such as `Console.WriteLine(str.Length.ToString());`.
    The problem is that it would provoke an exception when trying to access the `Length`
    property of `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we can use this operator in very simple way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By including the null conditional `?` operator, the `Length` property is not
    even accessed, so there's no exception, and we will get the expected output (an
    empty string, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put everything together in a block of code so that we compare different
    behaviors for null and non-null strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code compiles with no problems and generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The null-conditional operator](img/image00476.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Observe the fifth entry: no value is presented because no evaluation has been
    made of the `Length` of `str`. There are numerous cases in which this is just
    the operator we need: it could be checking a null delegate before invocation or
    inserting it right before any common `ToString` call for usual conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-property initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auto-property initializers are another improvement that helps manage immutable
    properties (those that once given a value, don't change along the life of the
    application).
  prefs: []
  type: TYPE_NORMAL
- en: In preceding versions, declaring read-only properties was kind of redundant.
    You had to declare the read-only backup private field and take care of its initialization
    and, later, provide an explicit implementation of such property (instead of using
    the common auto-properties). Finally, to access the value, a property-get member
    was included. This was the way good practices recommended you to create this particular
    type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also why auto-properties are so handy. For example, if our application
    captures the current username and operating system version of the machine, it''s
    installed in a pair of read-only properties. It suffices to indicate this in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''re using a more concise syntax to express the same idea and obtain
    the same results as what we achieved with the classical approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Auto-property initializers](img/image00477.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Static using declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to simplify syntax is based on the idea of extending directives
    in the code to make them capable of referencing static members of the .NET Framework
    and using them in the same way as we use other declarations mentioned in a `using`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we can include a declaration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point, any reference to a member of the `Math` class can be done
    directly without an indication of the namespace (and the static class) it belongs
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're using string interpolation all over the demos, since the simplification
    it allows is very useful, especially for these console-type snippets (I omitted
    the output in this case, you can figure it out...).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, there''s another typical case in which this functionality is important:
    when we use `Enum` members. Most of the time, we already know the possible values,
    so if we are indicating a typical `Enum`, such as the day of the week, we can
    indicate the corresponding `Enum` type as a static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use it just like earlier (remember, the number of `Enum` types in .NET
    is quite large):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We even keep things more generic, using the `nameof` operator we already saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we would still get the expected output, though expressed in a much more
    generic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static using declarations](img/image00478.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the demo is a Console application, even Console can be referenced in
    this way; so, consider that we want to change the colors of the output in the
    Console instead of writing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put it all together in much simpler way (of course, some developers
    may argue that this is a matter of syntactic tastes.). At the top of the code,
    we declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the rest is all simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is presented in a tuned Console this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static using declarations](img/image00479.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Expression bodied methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When coding lambda expressions, we''ve seen that we could omit the curly braces
    used to indicate the body of a method in order to simplify the code. Now, we can
    do something similar in methods, allowing us to express overriding in a simpler
    way. Consider this example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Overriding the `ToString()` method is expressed using a simpler manner that
    contains string interpolation. It's pretty readable and concise, and it works
    just the same as it did in previous versions. (I also omitted the output, but
    you can easily infer it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same idea is valid to declare calculated properties in a class, for example.
    If we need to complete the previous class with a calculated property that returns
    a Boolean indicating whether the `FullName` member is longer that 12 characters
    (we call it `FullNameFits`), we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this becomes much more concise and expressive than it was before
    this version.
  prefs: []
  type: TYPE_NORMAL
- en: Index initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s, finally, mention another feature related to initializers. Until now,
    when initializing index setters, we had to do it in separate statements. To put
    this in context, now if we have to initialize an array of values that coincides
    with certain numbers that are already well known, as is the case with Web Errors
    Dictionary (that is, 404-Not Found, and so on), we can define it in this way (all
    in one sentence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So, right in the initialization process, we define the keys required (or, at
    least, initially required) regardless of whether they have to be changed later
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: In all, we can say the C# new features in version 6.0 is not very deep and significant,
    especially when compared to version 4.0, to mention just one. However, they're
    quite useful and they reduce the required code on many scenarios in which the
    programmer already knows the structure to write well enough so as to get rid of
    some of the verbosity connected to some programming structures.
  prefs: []
  type: TYPE_NORMAL
- en: What's new in C# 7.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, you have to keep in mind that to work with the new features proposed
    by version 7.0 of the language, you will need to have Visual Studio 2017 (any
    version, including the Community Edition) or Visual Studio Code with the OmniSharp
    Extension (C# plugin), which also allows to use the language in other popular
    editors like Vim, Emacs, Sublime, Atom, Brackets, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have that ready, C# 7 features will be available in the IDE and we
    can start playing with these additions. Also, it's important to note that Microsoft
    is encouraging the contributors of the coming versions of the language to deploy
    new features in a faster path, although including a smaller set of new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, this version does not include something as foundational to the language
    as LINQ or async/await. C# 7 adds extra syntactic sugar in some cases, except
    its most powerful features: the new support for tuples and deconstructions.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the "syntactic sugar."
  prefs: []
  type: TYPE_NORMAL
- en: Binary literals and digit separators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can express binary numbers as literals directly in the definition of the
    type that holds them, like this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: But when declared in this form, you can easily end up with long expressions
    difficult to evaluate and assess at first sight. That's why we now have a new
    language feature called digit separators.
  prefs: []
  type: TYPE_NORMAL
- en: That means you can include any number of underscore symbols located in any position
    inside a number literal and it will be interpreted correctly by the compiler.
    In this manner, it becomes easier to read the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is valid for any type of number literal, as it happens in the sixth entry
    in the next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In case we want to check the automatic conversion to integers, we can test
    the result quite easily, adding a couple of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary literals and digit separators](img/image00480.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pattern matching and switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many cases, we need to check the value of a variable marked as `out`. Remember
    that in order to use `out`, the variable has to be initialized first. To illustrate
    this situation, consider the following code, in which a function has to evaluate
    whether a string parameter passed to it can be interpreted as an integer or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have to declare and initialize the `i` variable before we
    can retrieve the resulting value from the conversion and double it (in case it
    is an `int`).
  prefs: []
  type: TYPE_NORMAL
- en: 'How about avoiding the previous declaration and having `i` declared and initialized
    inside the `if` statement? That''s what we can do now with out inline declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We have a more concise, elegant way of expressing the same idea. We're checking
    whether `s` matches the `int` pattern and, if it does, declaring and assigning
    the resulting value in a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to use pattern matching is within the `switch` statements, which
    have also been extended with more patterns to evaluate the value passed to it.
    Actually, you can now switch on anything, not just primitive types such as `int`
    or `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function assumes it is going to receive an object and has to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the object is null or different from an `int` or a string, return a string
    value indicating so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is an `int` or if it is an string convertible to an `int`, duplicate
    its value and return it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It it is a string not convertible to an `int`, add a prefix and return it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As per the preceding code, now you can indicate pattern matching to check whatever
    the value is, and we can even combine similar situations, such as checking for
    an `int` or for a string containing an `int` in sequential `case` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Observe the use of `when` in the string pattern matching, which plays the role
    of an `if`, really.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if it is a string but it's not convertible, we use the prefix procedure.
    These two features are syntactic sugar (as they call it), but they're pretty expressive
    and help in simplifying type checking and complex checking situations such as
    the one coded here.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the section named *Tuples: implementation in C#*, we saw how to declare
    and use tuples using the `Tuple` class, and, also, some of the drawbacks linked
    to that early version or these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in C# 7, tuples reach a new dimension. You no longer have to use the `Tuple`
    class to declare tuples, and thanks to pattern matching, the compiler is perfectly
    comfortable with declarations that include a tuple syntax next to a `var` definition
    or use a tuple as the return type of a method (allowing us to return more than
    a value, without requiring out parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous declaration is now understood by the compiler, as the next capture
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tuples](img/image00481.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That makes the use of the `Tuple` class unnecessary and also it makes much natural
    to work with these types. Besides, we had to use the members `Item1`, `Item2`,
    and so on to access the values of the tuple. Now we can give descriptive names
    to each member of the tuple to clarify its purpose (such as `n` and `s` in this
    sample).
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that you can return a tuple in a function. Let's follow
    an adapted version of the official demo that PM Mads Torgersen usually presents
    to explain this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to know how many items there are inside the initial declaration
    of `binNumbers` and also perform a sum of all its members, in the same function.
    We could write a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, invoke the method and present the results in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We obtain the expected results. But let's go through the code to view the details
    of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the return value of the function is a tuple and its members, named accordingly,
    which makes the calling code more readable. Also, the internal `result` variable
    is defined and initialized with the tuple syntax: a list of comma-separated values,
    optionally prefixed with a name for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is then assigned to the `res` variable, which can use the named
    parameters to output them in the console using string interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decomposition is a characteristic that allows us to deconstruct or decompose
    an object into its parts, or some of its parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the declaration of the `res` variable, we could even avoid
    the use of `res` by declaring the named members of the tuple, to obtain exactly
    the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can have access to the required returning values, but there's
    no need to hold them in a named variable; thus, we say that the resulting value
    has been "decomposed" into its forming parts.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in this case, we're taking advantage that the type to deconstruct
    is a tuple already. What about other objects? You can deconstruct any object as
    long as it has a `Deconstruct` method defined or you create an extension method
    with that name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to be able to decompose a `DateTime` value. Of course, there''s
    no `Deconstruct` method defined inside the `DateTime` object, but we can create
    one pretty easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have that definition accessible, we could "extract" those values from
    the current time with a sentence like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would get the output shown in the following capture, which also shows
    the previous calculation on the number or items in the array and its sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decomposition](img/image00482.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Local functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript programmers are used to passing functions as parameters and returning
    functions as a return value. That's not available in C#, except for the functionality
    available through lambda expressions that we saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions are not that, but they allow us to declare a function that is
    local to another closing function, with the ability to access the variables defined
    in the upper function. Therefore, they are local to the function in which they
    are declared.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to our demo of `ProcessArray` and imagine you want to separate the code
    inside the `ForEach` loop aside in another function, but you want to modify the
    values directly (without the `out` references).
  prefs: []
  type: TYPE_NORMAL
- en: 'You could rewrite the process with an inside function of this kind with the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This time, we go through the collection using a `ForEach` loop and, inside the
    loop, we call the local function `ProcessItem`, which has access to the result
    members.
  prefs: []
  type: TYPE_NORMAL
- en: In which cases do these inside functions make sense? One case would be when
    a helper method is only going to be used inside a single function, like in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Ref return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's learn a bit about these feature, which is only partially available,
    since they plan to extend it along the quick-path-release cadence of the language
    they announced in Connect(); 2016 event.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that in the same way you can pass values by reference, now you can
    return reference values and even store values in reference variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mads Torgersen code mentioned previously includes the following (self-explaining)
    code, to see how we would declare such a function a how we could use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the code, the function is marked with `ref` right before declaring the return
    type (`int`). Later, after declaring an array of numbers, the function is called
    with a 7 as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The value 7 occupies the fifth position in the array, so its order number is
    4\. But since the returned value is stored as `ref`, a subsequent assignment of
    9 changes that value inside the array to 9\. That's why the final sentence prints
    9.
  prefs: []
  type: TYPE_NORMAL
- en: In all, perhaps the changes included in this last version of the language are
    not as meaningful as there were those in versions 2, 3, or 4 of the language,
    but even so, they facilitate the programmer's tasks in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw the most renowned features included in recent versions of the C# language
    and .NET Framework from their 4.0 versions.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the C# 4.0 version, with a review of Delegate and Interface generic
    variance (covariance and contravariance), dynamic declarations, argument improvements,
    tuples and Lazy Instantiation of objects, which implied important changes in expressiveness
    and the power of the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we gave a brief introduction to the `async/await` structure as a means
    to simplify asynchronous calls by coding the two parts usually required in only
    one method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we did a review of the most important features included in version C#
    6.0, which is mainly based on new ways to reduce verbosity in the language.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've seen the most important features added to the recently published
    version 7.0, which are mainly based on syntactic sugar to make expressions more
    meaningful and the new pattern matching features which make the use of tuples
    a very feasible option in many common situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll do a comparison of languages, including the F# and
    TypeScript support in Visual Studio as well as provide some prospects about their
    use in the future.
  prefs: []
  type: TYPE_NORMAL
