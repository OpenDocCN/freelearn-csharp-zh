<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Contacts, Camera, and Location</h1></div></div></div><p class="calibre8">Some of the most vital features used by mobile applications today are based on the new types of data that can be collected by our devices. Features such as GPS location and camera are staples in modern applications such as Instagram or Twitter. It's difficult to develop an application and not use some of these native features. So, let's explore our options to take advantage of this functionality with Xamarin.</p><p class="calibre8">In this chapter, we will do the following:</p><div><ul class="itemizedlist"><li class="listitem">Introduce the Xamarin.Mobile library</li><li class="listitem">Read the address book on Android and iOS</li><li class="listitem">Retrieve the GPS location of our device</li><li class="listitem">Pull photos from the camera and photo library</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec69" class="calibre1"/>Introducing Xamarin.Mobile</h1></div></div></div><p class="calibre8">To simplify<a id="id652" class="calibre1"/> the development of these features across multiple platforms, Xamarin has developed a library called <strong class="calibre2">Xamarin.Mobile</strong>. It delivers a single API to access the contacts, GPS location, heading of the screen, camera, and photo library for iOS, Android, and even Windows platforms. It also takes advantage of the <strong class="calibre2">Task Parallel Libraries</strong> (<strong class="calibre2">TPL</strong>) to deliver a modern C# API that will make our developers<a id="id653" class="calibre1"/> more productive than what their native alternatives would. This gives you the ability to write nice, clean, asynchronous code using the <code class="literal">async</code> and <code class="literal">await</code> keywords in C#. You can also reuse the same code in iOS and Android, minus a few differences that are required by the Android platform.</p><p class="calibre8">To install Xamarin.Mobile, open the <strong class="calibre2">Xamarin Component Store</strong> in <strong class="calibre2">Xamarin Studio</strong>, and add the <strong class="calibre2">Xamarin.Mobile</strong> component to a project as shown in the following screenshot. You're going to use the following features (of the component):</p><div><img src="img/00077.jpeg" alt="Introducing Xamarin.Mobile" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Before <a id="id654" class="calibre1"/>we dig further into using Xamarin.Mobile, let's review the namespaces and functionality available with the library:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Xamarin.Contacts</code>: This contains classes that enable you to interact with the full <a id="id655" class="calibre1"/>address book. It includes everything from the contact's photo, phone numbers, address, e-mail, website, and so on.</li><li class="listitem"><code class="literal">Xamarin.Geolocation</code>: This combined with the accelerometer gives you access<a id="id656" class="calibre1"/> to the device's GPS location, including the altitude, heading, longitude, latitude, and speed. You can track the device's position explicitly or listen for GPS position changes over time.</li><li class="listitem"><code class="literal">Xamarin.Media</code>: This <a id="id657" class="calibre1"/>grants access to the device's cameras (if there is more than one) and built-in photo library. This is an easy way to add photo selection capabilities to any application.</li></ul></div><p class="calibre8">For the full documentation of Xamarin.Mobile, visit the API documentation with the Component Store at <a class="calibre1" href="http://componentsapi.xamarin.com">http://componentsapi.xamarin.com</a>. You can also view it in the native <a id="id658" class="calibre1"/>Mono documentation browser by clicking on <strong class="calibre2">Open API Documentation</strong> when viewing the component in Xamarin Studio.</p><p class="calibre8">Xamarin.Mobile is<a id="id659" class="calibre1"/> also an open source project with the standard <a id="id660" class="calibre1"/>Apache 2.0 license. You can contribute to the project or submit issues to the GitHub page at <a class="calibre1" href="https://github.com/xamarin/Xamarin.Mobile">https://github.com/xamarin/Xamarin.Mobile</a>. Feel free to use Xamarin.Mobile in your applications or fork, and modify it for your own purposes.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec70" class="calibre1"/>Accessing contacts</h1></div></div></div><p class="calibre8">To<a id="id661" class="calibre1"/> begin our exploration of what Xamarin.Mobile offers, let's access the address book within a Xamarin application. For iOS, the first step is to make a <strong class="calibre2">Single View Application</strong> project by navigating to <strong class="calibre2">iOS</strong> | <strong class="calibre2">iPhone Storyboard</strong>. Make sure you add Xamarin.Mobile to the project from the Component Store.</p><p class="calibre8">Now, let's implement a simple <code class="literal">UITableView</code> with a list of contacts:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="literal">MainStoryboard.storyboard</code> file. Delete any existing controllers created by the project template.</li><li class="listitem" value="2">Create <code class="literal">UINavigationController</code> with a <code class="literal">UITableViewController</code> as its root child controller.</li><li class="listitem" value="3">Set the <strong class="calibre2">Class</strong> of <code class="literal">UITableViewController</code> to <code class="literal">ContactsController</code> by navigating to <strong class="calibre2">Properties</strong> | <strong class="calibre2">Widget</strong> in the iOS designer.</li><li class="listitem" value="4">Save the storyboard file and return to Xamarin Studio.</li></ol><div></div><p class="calibre8">Open the automatically generated <code class="literal">ContactsController.cs</code> and start implementing the table view. Add <code class="literal">using Xamarin.Contacts;</code> to the top of the file and make the following changes to the controller:</p><div><pre class="programlisting">public partial class ContactsController :UITableViewController, IUITableViewDataSource
{
  public ContactsController (IntPtr handle) : base (handle)
  {
    Title = "Contacts";
  }
}</pre></div><p class="calibre8">We filled out the title for the navigation bar, <code class="literal">"Contacts"</code>, and set the class to implement <code class="literal">IUITableViewDataSource</code>. This is a new type of interface that Xamarin has created to simplify using Objective-C protocols from C#. It is exactly the same as creating a class that inherits from <code class="literal">UITableViewSource</code>, as we did in the earlier chapters, but you can do it from your controller as well. Xamarin has done some tricks here. They created an interface with the methods that can be optionally implemented, which isn't something that C# supports. This <a id="id662" class="calibre1"/>type of interface can make your code a bit cleaner by reducing the need for a new class, which is great for very simple controllers.</p><p class="calibre8">Next, let's add some code to load the contacts:</p><div><pre class="programlisting">Contact[] contacts;

public async override void ViewDidLoad()
{
  base.ViewDidLoad();
  try
  {
    var book = new AddressBook();
    await book.RequestPermission();
    contacts = book.ToArray();
  }
  catch
  {
    new UIAlertView("Oops!","Something went wrong, try again later.",null, "Ok").Show();
  }
}</pre></div><p class="calibre8">To use Xamarin.Mobile for loading contacts, you must first create an <code class="literal">AddressBook</code> object. Next, we have to call <code class="literal">RequestPermissions</code> in order to ask the user for permission to access the address book. This is an important step since it is required by iOS devices before an application can access the user's contacts. This prevents potentially nefarious applications from retrieving contacts without the user's knowledge. Android, on the other hand, only presents these permissions before installing an application.</p><p class="calibre8">Next, we used the <code class="literal">System.Linq</code> extension method <code class="literal">ToArray</code> to enumerate over the address book and store it in a member variable named contacts. You can also use <code class="literal">foreach</code> over the <code class="literal">AddressBook</code> object depending on your needs.</p><p class="calibre8">If you were to compile and run the application at this point, you would be greeted by the standard iOS pop up requesting access to contacts, as shown in the following screenshot:</p><div><img src="img/00078.jpeg" alt="Accessing contacts" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If you accidentally<a id="id663" class="calibre1"/> hit <strong class="calibre2">Don't Allow</strong>, you can change this setting by navigating to <strong class="calibre2">Settings</strong> | <strong class="calibre2">Privacy</strong> | <strong class="calibre2">Contacts</strong> on the device. In the iOS Simulator, you can also reset all the privacy prompts in the simulator by closing the application and navigating to <strong class="calibre2">Settings</strong> | <strong class="calibre2">General</strong> | <strong class="calibre2">Reset</strong> | <strong class="calibre2">Reset Location &amp; Privacy</strong>. This is a good tip to know whether you need to retest during development.</p><p class="calibre8">So, for the<a id="id664" class="calibre1"/> next step, we'll need to implement the <code class="literal">IUITableViewDataSource</code> interface so that we can work with the array of contacts and display them on the screen. Add the following methods to the controller just like you would to <code class="literal">UITableViewSource</code>:</p><div><pre class="programlisting">public override int RowsInSection(UITableView tableview, int section)
{
  return contacts != null ? contacts.Length : 0;
}
public override UITableViewCell GetCell(UITableView tableView, NSIndexPath indexPath)
{
  var contact = contacts [indexPath.Row];
  var cell = tableView.DequeueReusableCell(CellName);
  if (cell == null)
    cell = new UITableViewCell(UITableViewCellStyle.Default, CellName);
  cell.TextLabel.Text =contact.LastName + ", " + contact.FirstName;
  return cell;
}</pre></div><p class="calibre8">Also, add a <code class="literal">CellName</code> constant string to the class by selecting a string identifier such as <code class="literal">ContactCell</code>. Now, if you compile and run the program, you'll be able to see the list of contacts on the device. The following screenshot shows the default list of contacts in the iOS Simulator:</p><div><img src="img/00079.jpeg" alt="Accessing contacts" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec40" class="calibre1"/>Retrieving contacts on Android</h2></div></div></div><p class="calibre8">In a <a id="id665" class="calibre1"/>very similar fashion, we can retrieve a list of contacts <a id="id666" class="calibre1"/>in Android with Xamarin.Mobile. All of the APIs in Xamarin.Mobile are identical in Android with the exception of the requirement of <code class="literal">Android.Content.Context</code> to be passed in a few places. This is because many native Android APIs require a reference to the current activity (or to the other context such as <code class="literal">Application</code>) in order to function properly. To begin, create a standard Android application project by navigating to <strong class="calibre2">Android</strong> | <strong class="calibre2">Android Application</strong> in Xamarin Studio. Make sure you add Xamarin.Mobile to the project from the Component Store.</p><p class="calibre8">In a parallel iOS, let's create a simple <code class="literal">ListView</code> to display a list of contacts as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="literal">Main.axml</code> file from the <code class="literal">layout</code> folder in the <code class="literal">Resources</code> directory in the Android designer.</li><li class="listitem" value="2">Remove the default button from the project template and add <strong class="calibre2">ListView</strong> to the layout.</li><li class="listitem" value="3">Set its <strong class="calibre2">Id</strong> to <code class="literal">@+id/contacts</code>.</li><li class="listitem" value="4">Save the file and open <code class="literal">MainActivity.cs</code> so that we can make some changes to the code.</li></ol><div></div><p class="calibre8">Let's begin<a id="id667" class="calibre1"/> by removing most of the code; we don't need <a id="id668" class="calibre1"/>the code that came from the project template. You will also need to add a <code class="literal">using</code> statement for <code class="literal">Xamarin.Contacts</code>. Next, let's implement a simple <code class="literal">BaseAdapter&lt;Contact&gt;</code> class inside the <code class="literal">MainActivity</code> class as follows:</p><div><pre class="programlisting">class ContactsAdapter : BaseAdapter&lt;Contact&gt;
{
  public Contact[] Contacts { get; set; }

  public override long GetItemId(int position)
  {
    return position;
  }
  public override View GetView(int position, View convertView, ViewGroup parent)
  {
    var contact = this [position];
    var textView = convertView as TextView;
    if (textView == null)
    {
      textView = new TextView(parent.Context);
    }
    textView.Text = contact.LastName + ", " + contact.FirstName;
    return textView;
  }
  public override int Count
  {
    get { return Contacts == null ? 0 : Contacts.Length; }
  }
  public override Contact this[int index]
  {
    get { return Contacts [index]; }
  }
}</pre></div><p class="calibre8">This will display each contact in <code class="literal">TextView</code> for each row in <code class="literal">ListView</code>. One thing that we've done here in order to simplify things is add a property for the array of contacts. This should be<a id="id669" class="calibre1"/> pretty straightforward and similar to what <a id="id670" class="calibre1"/>we did in the previous chapters.</p><p class="calibre8">Now, let's set up the adapter in <code class="literal">OnCreate</code> as follows:</p><div><pre class="programlisting">protected async override void OnCreate(Bundle bundle)
{
  base.OnCreate(bundle);

  SetContentView(Resource.Layout.Main);
  var listView = FindViewById&lt;ListView&gt;(Resource.Id.contacts);
  var adapter = new ContactsAdapter();
  listView.Adapter = adapter;
  try
  {
    var book = new AddressBook(this);
    await book.RequestPermission();
    adapter.Contacts = book.ToArray();
    adapter.NotifyDataSetChanged();
  }
  catch
  {
    new AlertDialog.Builder(this).SetTitle("Oops").SetMessage("Something went wrong, try again later.").SetPositiveButton("Ok", delegate { }).Show();
  }
}</pre></div><p class="calibre8">This code calls Xamarin.Mobile that is identical to what we did on the code for iOS except that here, <code class="literal">this</code> had to be passed for the Android <code class="literal">Context</code> in the constructor for <code class="literal">AddressBook</code>. Our code changes are complete; however, if you run the application right now, an exception would be thrown. Android requires permission in the manifest file, which will notify the user of its access to the address book when downloaded from Google Play.</p><p class="calibre8">We must create an <code class="literal">AndroidManifest.xml</code> file and declare a permission as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the project options for the Android project.</li><li class="listitem" value="2">Select the <strong class="calibre2">Android Application</strong> tab under <strong class="calibre2">Build</strong>.</li><li class="listitem" value="3">Click on <strong class="calibre2">Add Android manifest</strong>.</li><li class="listitem" value="4">Under the <strong class="calibre2">Required permissions</strong> section, check <strong class="calibre2">ReadContacts</strong>.</li><li class="listitem" value="5">Click on <strong class="calibre2">OK</strong> to save your changes.</li></ol><div></div><p class="calibre8">Now, if you<a id="id671" class="calibre1"/> run the application, you will get a list of all<a id="id672" class="calibre1"/> the contacts on the device, as shown in the following screenshot:</p><div><img src="img/00080.jpeg" alt="Retrieving contacts on Android" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec71" class="calibre1"/>Looking up GPS location</h1></div></div></div><p class="calibre8">Using Xamarin.Mobile to track a user's GPS location is as simple as accessing their contacts. There<a id="id673" class="calibre1"/> is a similar process for setting up access on iOS and Android, but in the case of location, you don't have to request permission from code. iOS will automatically show the standard alert requesting the permission. Android, on the other hand, merely requires a manifest setting.</p><p class="calibre8">As an example, let's create an application that displays a list of GPS location updates over time. Let's begin with an iOS example by creating a Single View Application project. This can be done by navigating to <strong class="calibre2">iOS</strong> | <strong class="calibre2">iPhone Storyboard</strong> and clicking on<strong class="calibre2"> Single View Application</strong>, just like we did in the previous section. Make sure you add Xamarin.Mobile to the project from the Component Store.</p><p class="calibre8">Now, let's implement a simple <code class="literal">UITableView</code> to display a list of GPS updates as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="literal">MainStoryboard.storyboard</code> file. Delete any existing controllers created by the project template.</li><li class="listitem" value="2">Create <code class="literal">UINavigationController</code> with <code class="literal">UITableViewController</code> as its root child controller.</li><li class="listitem" value="3">Set the class of <code class="literal">UITableViewController</code> to <code class="literal">LocationController</code> by navigating to <strong class="calibre2">Properties</strong> | <strong class="calibre2">Widget</strong> in the iOS designer.</li><li class="listitem" value="4">Save the storyboard file and return to Xamarin Studio.</li></ol><div></div><p class="calibre8">Open <code class="literal">LocationController.cs</code> and let's start by setting up our GPS to update a table view over time. Add <code class="literal">using Xamarin.Geolocation;</code> to the top of the file. We can set up some member variables and create our <code class="literal">Geolocator</code> object in the controller's constructor as follows:</p><div><pre class="programlisting">Geolocator locator;
List&lt;string&gt; messages = new List&lt;string&gt;();
public LocationController (IntPtr handle) : base (handle)
{
  Title = "GPS";
  locator = new Geolocator();
  locator.PositionChanged += OnPositionChanged;
  locator.PositionError += OnPositionError;
}</pre></div><p class="calibre8">Next, we can set up our event handlers as follows:</p><div><pre class="programlisting">void OnPositionChanged (object sender, PositionEventArgs e)
{
  messages.Add(string.Format("Long: {0:0.##} Lat: {1:0.##}",e.Position.Longitude, e.Position.Latitude));
  TableView.ReloadData();
}
void OnPositionError (object sender, PositionErrorEventArgs e)
{
  messages.Add(e.Error.ToString());
  TableView.ReloadData();
}</pre></div><p class="calibre8">These will<a id="id674" class="calibre1"/> add a message to the list when there is an error or a location change. We used <code class="literal">string.Format</code> to only display the longitude and latitude up to two decimal places.</p><p class="calibre8">Next, we have to actually tell <code class="literal">Geolocator</code> to start listening for GPS updates. We can do this in <code class="literal">ViewDidLoad</code> as follows:</p><div><pre class="programlisting">public override void ViewDidLoad()
{
  base.ViewDidLoad();
  locator.StartListening(1000, 50);
}</pre></div><p class="calibre8">In the preceding code, <code class="literal">1000</code> is a hint for the minimum time to update the GPS location, and the value <code class="literal">50</code> is a hint for the number of meters that will trigger a position update.</p><p class="calibre8">Last but not least, we need to set up the table view. Set up <code class="literal">LocationController</code> to implement <code class="literal">IUITableViewDataSource</code> and add the following methods to the controller:</p><div><pre class="programlisting">public override int RowsInSection(UITableView tableview, int section)
{
  return messages.Count;
}
public override UITableViewCell GetCell(UITableView tableView, NSIndexPath indexPath)
{
  var cell = tableView.DequeueReusableCell(CellName);
  if (cell == null)
    cell = new UITableViewCell(UITableViewCellStyle.Default, CellName);
  cell.TextLabel.Text = messages [indexPath.Row];
  return cell;
}</pre></div><p class="calibre8">If you compile and run the application, you should see an iOS permission prompt followed by <a id="id675" class="calibre1"/>the longitude and latitude in the table view over time, as shown in the following screenshot:</p><div><img src="img/00081.jpeg" alt="Looking up GPS location" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec41" class="calibre1"/>Implementing GPS location on Android</h2></div></div></div><p class="calibre8">Just as<a id="id676" class="calibre1"/> in the previous section, using Xamarin.Mobile <a id="id677" class="calibre1"/>for GPS location is almost identical to the APIs we used in iOS. To begin with our Android example, go to <strong class="calibre2">Android</strong> | <strong class="calibre2">Android Application</strong> in Xamarin Studio. Make sure you add Xamarin.Mobile to the project from the Component Store.</p><p class="calibre8">Let's create <code class="literal">ListView</code> to display a list of messages of the GPS location updates as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="literal">Main.axml</code> file from the <code class="literal">layout</code> folder under the <code class="literal">Resources</code> directory in the Android designer.</li><li class="listitem" value="2">Remove the default button from the project template and add <code class="literal">ListView</code> to the layout.</li><li class="listitem" value="3">Set its <strong class="calibre2">Id</strong> to <code class="literal">@+id/locations</code>.</li><li class="listitem" value="4">Save the file and open <code class="literal">MainActivity.cs</code> so that we can make some code changes.</li></ol><div></div><p class="calibre8">As usual, remove<a id="id678" class="calibre1"/> any extra code that was <a id="id679" class="calibre1"/>created by the project template. Next, add a <code class="literal">using</code> statement for <code class="literal">Xamarin.Geolocation</code>. Then, add a simple <code class="literal">BaseAdapter&lt;string&gt;</code> to the <code class="literal">MainActivity</code> class as follows:</p><div><pre class="programlisting">class Adapter : BaseAdapter&lt;string&gt;
{
  List&lt;string&gt; messages = new List&lt;string&gt;();

  public void Add(string message)
  {
    messages.Add(message);
    NotifyDataSetChanged();
  }
  public override long GetItemId(int position)
  {
    return position;
  }
  public override View GetView(int position, View convertView, ViewGroup parent)
  {
    var textView = convertView as TextView;
    if (textView == null)
      textView = new TextView(parent.Context);
    textView.Text = messages [position];
    return textView;
  }
  public override int Count
  {
    get { return messages.Count; }
  }
  public override string this[int index]
  {
    get { return messages [index]; }
  }
}</pre></div><p class="calibre8">This is <a id="id680" class="calibre1"/>similar to other Android adapters <a id="id681" class="calibre1"/>we have set up in the past. One difference here is that we made a member variable that contains a <code class="literal">List&lt;string&gt;</code> of messages and a method to add the new messages to the list.</p><p class="calibre8">Now, let's add a few methods to the <code class="literal">MainActivity</code> class in order to set up the GPS location updates as follows:</p><div><pre class="programlisting">Geolocator locator;
Adapter adapter;

protected override void OnCreate(Bundle bundle)
{
  base.OnCreate(bundle);
  SetContentView(Resource.Layout.Main);
  var listView = FindViewById&lt;ListView&gt;(Resource.Id.locations);
  listView.Adapter = adapter = new Adapter();
  locator = new Geolocator(this);
  locator.PositionChanged += OnPositionChanged;
  locator.PositionError += OnPositionError;
}
protected override void OnResume()
{
  base.OnResume();
  locator.StartListening(1000, 50);
}
protected override void OnPause()
{
  base.OnPause();
  locator.StopListening();
}
void OnPositionChanged (object sender, PositionEventArgs e)
{
  adapter.Add(string.Format("Long: {0:0.##} Lat: {1:0.##}",e.Position.Longitude, e.Position.Latitude));
}
void OnPositionError (object sender, PositionErrorEventArgs e)
{
  adapter.Add(e.Error.ToString());
}</pre></div><p class="calibre8">Again, this<a id="id682" class="calibre1"/> looks identical to the code for iOS <a id="id683" class="calibre1"/>except for the constructor for <code class="literal">Geolocator</code>. If you run the application at this point, it would start with no errors. However, no events will be fired from the <code class="literal">Geolocator</code> object. We first need to add a permission to access the location from the Android Manifest file. It is also a good idea to start the locator in <code class="literal">OnResume</code> and stop it in <code class="literal">OnPause</code>. This will conserve the battery by stopping GPS location when this activity is no longer on the screen.</p><p class="calibre8">Let's create an <code class="literal">AndroidManifest.xml</code> file and declare two permissions as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the project options for the Android project.</li><li class="listitem" value="2">Select the <strong class="calibre2">Android Application</strong> tab under <strong class="calibre2">Build</strong>.</li><li class="listitem" value="3">Click on <strong class="calibre2">Add Android manifest</strong>.</li><li class="listitem" value="4">Under the <strong class="calibre2">Required permissions</strong> section, check <strong class="calibre2">AccessCoarseLocation</strong> and <strong class="calibre2">AccessFineLocation</strong>.</li><li class="listitem" value="5">Click on <strong class="calibre2">OK</strong> to save your changes.</li></ol><div></div><p class="calibre8">Now, if you compile and run the application, you will get the GPS location updates over time, as shown in the following screenshot:</p><div><img src="img/00082.jpeg" alt="Implementing GPS location on Android" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec72" class="calibre1"/>Accessing the photo library and camera</h1></div></div></div><p class="calibre8">The last<a id="id684" class="calibre1"/> major feature of Xamarin.Mobile is the ability to access <a id="id685" class="calibre1"/>photos in order to give users the ability to add their own content to your applications. Using a class called <code class="literal">MediaPicker</code>, you can pull photos from the device's camera or photo library and optionally display your own UI for the operation.</p><p class="calibre8">Let's create an application that loads an image from the camera or photo library on the press of a button and displays it on the screen. To begin with, create a Single View Application project by going to <strong class="calibre2">iOS</strong> | <strong class="calibre2">iPhone Storyboard</strong> | <strong class="calibre2">Single View Application</strong> in Xamarin<a id="id686" class="calibre1"/> Studio. Make sure to add Xamarin.Mobile to the project from the Component Store.</p><p class="calibre8">Now, let's implement a<a id="id687" class="calibre1"/> screen with two <code class="literal">UIButton</code> and a <code class="literal">UIImageView</code> as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="literal">MainStoryboard.storyboard</code> file. Delete any existing controllers created by the project template.</li><li class="listitem" value="2">Create <code class="literal">UIViewController</code> with one <code class="literal">UIImageView</code> and two <code class="literal">UIButton</code> named <code class="literal">Library</code> and <code class="literal">Camera</code>.</li><li class="listitem" value="3">Set the class of <code class="literal">UITableViewController</code> to <code class="literal">ContactsController</code> by navigating to <strong class="calibre2">Properties</strong> | <strong class="calibre2">Widget</strong> in the iOS designer.</li><li class="listitem" value="4">Create the <strong class="calibre2">Name</strong> field for each view in the controller named <code class="literal">imageView</code>, <code class="literal">library</code>, and <code class="literal">camera</code> respectively.</li><li class="listitem" value="5">Save the storyboard file and return to Xamarin Studio.</li></ol><div></div><p class="calibre8">Now, open <code class="literal">PhotoController.cs</code> and add the following code in <code class="literal">ViewDidLoad</code>:</p><div><pre class="programlisting">MediaPicker picker;
public override void ViewDidLoad()
{
  base.ViewDidLoad();

  picker = new MediaPicker();
  if (!picker.IsCameraAvailable)
    camera.Enabled = false;
  camera.TouchUpInside += OnCamera;
  library.TouchUpInside += OnLibrary;
}</pre></div><p class="calibre8">Note that we have to check <code class="literal">IsCameraAvailable</code> and disable the <code class="literal">camera</code> button. There are iOS devices such as the first generation iPad that could possibly not have a camera. Besides this, we just need to create an instance of <code class="literal">MediaPicker</code> that can be used when you click on each button.</p><p class="calibre8">Now, let's add a method for each button's <code class="literal">TouchUpInside</code> event and a couple of other helper methods as follows:</p><div><pre class="programlisting">async void OnCamera (object sender, EventArgs e)
{
  try
  {
    var file = await picker.TakePhotoAsync(new StoreCameraMediaOptions());
    imageView.Image = ToImage(file);
  }
  catch
  {
    ShowError();
  }
}
async void OnLibrary (object sender, EventArgs e)
{
  try
  {
    var file = await picker.PickPhotoAsync();
    imageView.Image = ToImage(file);
  }
  catch
  {
      ShowError();
  }
}
UIImage ToImage(MediaFile file)
{
  using (var stream = file.GetStream())
  {
    using (var data = NSData.FromStream(stream))
    {
      return UIImage.LoadFromData(data);
    }
  }
}
void ShowError()
{
  new UIAlertView("Oops!", "Something went wrong, try again later.", null, "Ok").Show();
}</pre></div><p class="calibre8">Using <code class="literal">MediaPIcker</code> is <a id="id688" class="calibre1"/>pretty straightforward; you merely<a id="id689" class="calibre1"/> have to call <code class="literal">TakePhotoAsync</code> or <code class="literal">PickPhotoAsync</code> to retrieve a <code class="literal">MediaFile</code> instance. Then, you can call <code class="literal">GetStream</code> to do what you want with the image data. In our case, we created <code class="literal">UIImage</code> to display directly in <code class="literal">UIImageView</code>. It is also necessary to use a <code class="literal">try-catch</code> block in case something unexpected happens or the user cancels.</p><p class="calibre8">You should <a id="id690" class="calibre1"/>now be able to run the app and select a photo to be viewed<a id="id691" class="calibre1"/> on the screen. The following screenshot shows a nice default photo from the iOS simulator that I selected from the photo library:</p><div><img src="img/00083.jpeg" alt="Accessing the photo library and camera" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec42" class="calibre1"/>Accessing photos on Android</h2></div></div></div><p class="calibre8">In comparison<a id="id692" class="calibre1"/> to iOS, we have to use a slightly different<a id="id693" class="calibre1"/> pattern on Android to retrieve photos from the camera or photo library. A common pattern in Android is that it calls <code class="literal">StartActivityForResult</code> to launch an activity from another application. When this activity is completed, <code class="literal">OnActivityResult</code> will be called from your activity. Because of this, Xamarin.Mobile could not use the same APIs on Android as the other platforms. To start our example, create an Android Application project by going to <strong class="calibre2">Android</strong> | <strong class="calibre2">Android Application</strong> in Xamarin Studio. Make sure you add Xamarin.Mobile to the project from the Component Store.</p><p class="calibre8">Let's create two <strong class="calibre2">Buttons</strong> and an <strong class="calibre2">ImageView</strong> to mimic our UI on iOS as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="literal">Main.axml</code> file from the <code class="literal">layout</code> folder under the <code class="literal">Resources</code> directory in the Android designer.</li><li class="listitem" value="2">Remove the default button from the project template, and add two new <code class="literal">Button</code> named <code class="literal">Library</code> and <code class="literal">Camera</code>.</li><li class="listitem" value="3">Set their <strong class="calibre2">Id</strong> to <code class="literal">@+id/library</code> and <code class="literal">@+id/camera</code>, respectively.</li><li class="listitem" value="4">Create an <code class="literal">ImageView</code> with an <strong class="calibre2">Id</strong> of <code class="literal">@+id/imageView</code>.</li><li class="listitem" value="5">Save the file and open <code class="literal">MainActivity.cs</code> so that we can make changes to our code.</li></ol><div></div><p class="calibre8">As usual, remove any extra code that was created by the project template. Next, add a <code class="literal">using</code> statement for <code class="literal">Xamarin.Media</code>. Then, we can add a new <code class="literal">OnCreate</code> method and some member variables for our activity as follows:</p><div><pre class="programlisting">MediaPicker picker;
ImageView imageView;

protected override void OnCreate(Bundle bundle)
{
  base.OnCreate(bundle);
  SetContentView(Resource.Layout.Main);
  var library = FindViewById&lt;Button&gt;(Resource.Id.library);
  var camera = FindViewById&lt;Button&gt;(Resource.Id.camera);
  imageView = FindViewById&lt;ImageView&gt;(Resource.Id.imageView);
  picker = new MediaPicker(this);
  library.Click += OnLibrary;
  camera.Click += OnCamera;
  if (!picker.IsCameraAvailable)
    camera.Enabled = false;
}</pre></div><p class="calibre8">We retrieved the instance of our views and created a new <code class="literal">MediaPicker</code> by passing our activity as <code class="literal">Context</code> to its constructor. We hooked up some <code class="literal">Click</code> event handlers, and disabled the <code class="literal">camera</code> button since a camera is not available.</p><p class="calibre8">Next, let's<a id="id694" class="calibre1"/> implement the two <code class="literal">Click</code> event handlers<a id="id695" class="calibre1"/> as follows:</p><div><pre class="programlisting">void OnLibrary (object sender, EventArgs e)
{
  var intent = picker.GetPickPhotoUI();
  StartActivityForResult (intent, 1);
}
void OnCamera (object sender, EventArgs e)
{
  var intent = picker.GetTakePhotoUI(new StoreCameraMediaOptions
  {
    Name = "test.jpg", Directory = "PhotoPicker"
  });
  StartActivityForResult (intent, 1);
}</pre></div><p class="calibre8">In each case, we make a call to <code class="literal">GetPickPhotoUI</code> or <code class="literal">GetTakePhotoUI</code> in order to get an instance of an Android <code class="literal">Intent</code> object. This object is used to start the new activities within an application. <code class="literal">StartActivityForResult</code> will also start the <code class="literal">Intent</code> object, expecting a result to be returned from the new activity. We also set some values with <code class="literal">StoreCameraMediaOptions</code> to specify a filename and temporary directory to store the photo.</p><p class="calibre8">Next, we need to implement <code class="literal">OnActivityResult</code> in order to handle what will happen when the new activity is completed:</p><div><pre class="programlisting">protected async override void OnActivityResult(
  int requestCode, Result resultCode, Intent data)
{
  if (resultCode == Result.Canceled)
  return;
  var file = await data.GetMediaFileExtraAsync(this);
  using (var stream = file.GetStream())
  {
    imageView.SetImageBitmap(await
      BitmapFactory.DecodeStreamAsync(stream));
  }
}</pre></div><p class="calibre8">If this is successful, we retrieve <code class="literal">MediaFile</code> and load a new <code class="literal">Bitmap</code> with the returned <code class="literal">Stream</code>. Next, all that is needed is to call <code class="literal">SetImageBitmap</code> to display the image on the screen.</p><p class="calibre8">Let's create <a id="id696" class="calibre1"/>an <code class="literal">AndroidManifest.xml</code> file and declare <a id="id697" class="calibre1"/>two permissions as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the project options for the Android project.</li><li class="listitem" value="2">Select the <strong class="calibre2">Android Application</strong> tab under <strong class="calibre2">Build</strong>.</li><li class="listitem" value="3">Click on <strong class="calibre2">Add Android manifest</strong>.</li><li class="listitem" value="4">Under the <strong class="calibre2">Required permissions</strong> section, check <strong class="calibre2">Camera</strong> and <strong class="calibre2">WriteExternalStorage</strong>.</li><li class="listitem" value="5">Click on <strong class="calibre2">OK</strong> to save your changes.</li></ol><div></div><p class="calibre8">You should now be able to run the application and load photos to be displayed on the screen, as shown in the following screenshot:</p><div><img src="img/00084.jpeg" alt="Accessing photos on Android" class="calibre9"/></div><p class="calibre10"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec73" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we discovered the Xamarin.Mobile library and how it can accelerate common native tasks in a cross-platform way. We retrieved the contacts from the address book and set up GPS location updates over time. Lastly, we loaded photos from the camera and photo library. Using the native APIs directly would mean twice as much code on each platform, so we saw how the Xamarin.Mobile library is a useful abstraction that can reduce some development time.</p><p class="calibre8">After completing this chapter, you should have a complete grasp of the Xamarin.Mobile library and the common functionality it provides for cross-platform development. It gives clean, modern APIs that offer the <code class="literal">async</code>/<code class="literal">await</code> functionality that can be accessed across iOS, Android, and Windows Phone. Accessing contacts, GPS, and photos across platforms is very straightforward with Xamarin.Mobile.</p><p class="calibre8">In the next chapter, we will cover the steps of how to submit applications to the iOS App Store and Google Play. This will include how to prepare your app to pass the iOS guidelines as well as properly signing up your app for Google Play.</p></div></body></html>