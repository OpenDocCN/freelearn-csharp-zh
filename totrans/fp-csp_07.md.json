["```cs\npublic class Tower\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int Damage { get; set; }\n}\npublic Result<List<Tower>, string> UpgradeTowers(List<Tower> towers)\n{\n    // Write your code here\n}\n```", "```cs\npublic Result<Func<Tower, bool>, string> ValidateDamage = new Result<Func<Tower, bool>, string>(tower => tower.Damage < 100);\npublic Result<Func<Tower, bool>, string> ValidateName = new Result<Func<Tower, bool>, string>(tower => tower.Name.Length > 5 && !tower.Name.Contains(\"BannedWord\"));\n```", "```cs\npublic Result<Tower, string> FetchTower(int towerId) { /* Fetches tower based on ID */ }\npublic Result<Tower, string> UpgradeTower(Tower tower) { /* Upgrades the tower and can fail */ }\npublic Result<Tower, string> DeployTower(Tower tower) { /* Attempts to deploy the tower */ }\n```", "```cs\nFunc<T, T> identity = x => x;\n```", "```cs\nint number = 29;\nint result = identity(number);\nConsole.WriteLine(result);\n  // Output: 29\nstring text = \"Hello Functional programming in C# readers!\";\nstring resultText = identity(text);\nConsole.WriteLine(resultText);\n  // Output: Hello Functional programming in C# readers!\n```", "```cs\nBook AddPages(Book book, int pages) => new Book { Title = book.Title, Pages = book.Pages + pages };\nBook AppendSubtitle(Book book, string subtitle) => new Book { Title = $\"{book.Title}: {subtitle}\", Pages = book.Pages };\n```", "```cs\nList<Book> books = new()\n{\n    new Book { Title = \"C# Basics\", Pages = 100 },\n    new Book { Title = \"Advanced C#\", Pages = 200 }\n};\n// Apply AddPages to each book and then apply AppendSubtitle\nvar sequentialApplicationResult = books.Select(book => AddPages(book, 50)).Select(book => AppendSubtitle(book, \"Updated Edition\"));\n// Apply AddPages then AppendSubtitle to each book\nvar combinedApplicationResult = books.Select(book => AppendSubtitle(AddPages(book, 50), \"Updated Edition\"));\n// Print the results\nConsole.WriteLine(\"books.Select(AddPages).Select(AppendSubtitle): \" + string.Join(\", \", sequentialApplicationResult.Select(b => b.Title)));\nConsole.WriteLine(\"books.Select(book => AppendSubtitle(AddPages(book, 50))): \" + string.Join(\", \", combinedApplicationResult.Select(b => b.Title)));\n// Output:\n// books.Select(AddPages).Select(AppendSubtitle): C# Basics: Updated Edition, Advanced C#: Updated Edition\n// books.Select(book => AppendSubtitle(AddPages(book, 50))): C# Basics: Updated Edition, Advanced C#: Updated Edition\n```", "```cs\npublic class Result<TValue, TError>\n{\n    private TValue _value;\n    private TError _error;\n    public bool IsSuccess { get; private set; }\n    private Result(TValue value, TError error, bool isSuccess)\n    {\n        _value = value;\n        _error = error;\n        IsSuccess = isSuccess;\n    }\n    public TValue Value\n    {\n        get\n        {\n            if (!IsSuccess) throw new InvalidOperationException(\"Cannot fetch Value from a failed result.\");\n            return _value;\n        }\n    }\n    public TError Error\n    {\n        get\n        {\n            if (IsSuccess) throw new InvalidOperationException(\"Cannot fetch Error from a successful result.\");\n            return _error;\n        }\n    }\n    public static Result<TValue, TError> Success(TValue value) => new Result<TValue, TError>(value, default, true);\n    public static Result<TValue, TError> Failure(TError error) => new Result<TValue, TError>(default, error, false);\n    public Result<TResult, TError> Map<TResult>(Func<TValue, TResult> mapper)\n    {\n        return IsSuccess\n            ? Result<TResult, TError>.Success(mapper(_value!))\n            : Result<TResult, TError>.Failure(_error!);\n    }\n}\n```", "```cs\nBook AddPages(Book book, int pages) => new Book { Title = book.Title, Pages = book.Pages + pages };\nBook AppendSubtitle(Book book, string subtitle) => new Book { Title = $\"{book.Title}: {subtitle}\", Pages = book.Pages };\nFunc<Book, Book> identity = book => book;\nvar success = Result<Book, string>.Success(new Book { Title = \"C# Basics\", Pages = 100 });\nvar error = Result<Book, string>.Failure(\"Error message\");\n// Identity law\nvar successAfterIdentity = success.Map(identity);\n// successAfterIdentity should have value \"C# Basics\", 100 pages\nvar errorAfterIdentity = error.Map(identity);\n// errorAfterIdentity should have the \"Error message\" error\n// Composition law\nFunc<Book, Book> composedFunction = book => AppendSubtitle(AddPages(book, 50), \"Updated Edition\");\nvar success = Result<Book, string>.Success(new Book { Title = \"C# Basics\", Pages = 100 });\n// Applying composed function directly\nvar directComposition = success.Map(composedFunction);\n// directComposition should hold value \"C# Basics: Updated Edition\", 150 pages\n// Applying functions one after the other\nvar stepwiseComposition = success.Map(book => AddPages(book, 50)).Map(book => AppendSubtitle(book, \"Updated Edition\"));\n// stepwiseComposition should also hold value \"C# Basics: Updated Edition\", 150 pages\n```", "```cs\nResult<Func<int, decimal>, string> CalculateRoyaltiesFunc = new Result<Func<int, decimal>, string>(sales => sales * 0.1m);\nResult<Func<decimal, decimal>, string> AdjustRoyaltiesFunc = new Result<Func<decimal, decimal>, string>(royalties => royalties * 1.05m);\n```", "```cs\nResult<int, string> salesResult = new Result<int, string>(150);\n```", "```cs\nvar royaltiesResult = salesResult\n    .Apply(CalculateRoyaltiesFunc)\n    .Apply(AdjustRoyaltiesFunc);\n// the royaltiesResult holds the value 15.75\n```", "```cs\nResult<Func<int, decimal>, string> CalculateRoyaltiesFunc = Result<Func<int, decimal>, string>.Failure(\"Can't calculate royalties\");\n```", "```cs\npublic Result<TResult, TError> Apply<TResult>(Result<Func<TValue, TResult>, TError> resultFunc)\n{\n    if (resultFunc.IsSuccess && this.IsSuccess)\n    {\n        return Result<TResult, TError>.Success(resultFunc.Value(this.Value));\n    }\n    else\n    {\n        var error = resultFunc.IsSuccess ? this._error! : resultFunc.Error;\n        return Result<TResult, TError>.Failure(error);\n    }\n}\n```", "```cs\n// Identity function\nFunc<int, int> identity = x => x;\n// Result-wrapped value, representing, for example, a count of books\nvar bookCount = Result<int, string>.Success(10);\n// Applying the identity function to the bookCount\nvar identityApplied = bookCount.Map(identity);\n// The identity operation should not alter the original Result\nConsole.WriteLine(identityApplied.IsSuccess && identityApplied.Value == 10);  // Output: True\n```", "```cs\nFunc<int, double> calculateRoyalties = sales => sales * 0.15;\nint bookSales = 100;\n// Applying function then wrapping\nvar directApplication = Result<double, string>.Success(calculateRoyalties(bookSales));\n// Wrapping then applying function\nvar wrappedApplication = Result<int, string>.Success(bookSales).Map(calculateRoyalties);\n// Both operations should yield the same result\nConsole.WriteLine(directApplication.IsSuccess && wrappedApplication.IsSuccess && directApplication.Value == wrappedApplication.Value);  // Output: True\n```", "```cs\nResult<Func<int, double>, string> wrappedCalculateRoyalties = new Result<Func<int, double>, string>(calculateRoyalties);\nResult<int, string> salesResult = Result<int, string>.Success(bookSales);\n// Wrapped function applied to wrapped value\nvar applied = salesResult.Apply(wrappedCalculateRoyalties);\n// Equivalent to applying a function that takes a function and applies it to the value\nFunc<Func<int, double>, Result<double, string>> applyFuncToValue = func => Result<double, string>.Success(func(bookSales));\nvar interchangeResult = wrappedCalculateRoyalties.Map(applyFuncToValue);\n// The results of applied and interchangeResult should be equivalent\n```", "```cs\nFunc<int, double> calculateRoyalties = sales => sales * 0.15;\nFunc<double, double> adjustForMarket = royalties => royalties * 1.05;\n// Composition of functions outside the Result context\nFunc<int, double> composed = sales => adjustForMarket(calculateRoyalties(sales));\n// Applying composed function to a Result-wrapped value\nvar composedApplication = Result<int, string>.Success(bookSales).Map(composed);\n// The result of composedApplication should be equivalent to applying each function within the Result context in sequence\n```", "```cs\npublic Result<TResult, TError> Bind<TResult>(Func<TValue, Result<TResult, TError>> func)\n    {\n        return IsSuccess ? func(_value!) : Result<TResult, TError>.Failure(_error!);\n    }\n```", "```cs\nResult<Manuscript, string> FetchManuscript(int manuscriptId) { ... }\nResult<EditedManuscript, string> EditManuscript(Manuscript manuscript) { ... }\nResult<FormattedManuscript, string> FormatManuscript(EditedManuscript edited) { ... }\nvar manuscriptId = 101;\nvar publishingPipeline = FetchManuscript(manuscriptId)\n    .Bind(EditManuscript)\n    .Bind(FormatManuscript);\n```", "```cs\nFunc<int, Result<double, string>> calculateRoyalties = sales => new Result<double, string>(sales * 0.15);\nint bookSales = 100;\nvar leftIdentity = Result<int, string>.Success(bookSales).Bind(calculateRoyalties);\nvar directApplication = calculateRoyalties(bookSales);\n// leftIdentity should be equivalent to directApplication\n```", "```cs\nvar manuscriptResult = Result<Manuscript, string>.Success(new Manuscript());\nvar rightIdentity = manuscriptResult.Bind(manuscript => Result<Manuscript, string>.Success(manuscript));\n// rightIdentity should be equivalent to manuscriptResult\n```", "```cs\nvar associativity1 = FetchManuscript(manuscriptId).Bind(EditManuscript).Bind(FormatManuscript);\nvar associativity2 = FetchManuscript(manuscriptId).Bind(manuscript => EditManuscript(manuscript).Bind(FormatManuscript));\n// associativity1 should be equivalent to associativity2\n```", "```cs\nResult<Publication, string> PublishManuscript(FormattedManuscript formatted) { ... }\nvar finalResult = FetchManuscript(manuscriptId)\n    .Bind(EditManuscript)\n    .Bind(FormatManuscript)\n    .Bind(PublishManuscript);\n```", "```cs\npublic class Tower\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int Damage { get; set; }\n}\npublic Result<List<Tower>, string> UpgradeTowers(List<Tower> towers)\n{\n    // Write your code here\n}\n```", "```cs\npublic Result<Func<Tower, bool>, string> ValidateDamage = new Result<Func<Tower, bool>, string>(tower => tower.Damage < 100);\npublic Result<Func<Tower, bool>, string> ValidateName = new Result<Func<Tower, bool>, string>(tower => tower.Name.Length > 5 && !tower.Name.Contains(\"BannedWord\"));\n```", "```cs\npublic Result<Tower, string> FetchTower(int towerId) { /* Fetches tower based on ID */ }\npublic Result<Tower, string> UpgradeTower(Tower tower) { /* Upgrades the tower and can fail */ }\npublic Result<Tower, string> DeployTower(Tower tower) { /* Attempts to deploy the tower */ }\n```", "```cs\npublic Result<List<Tower>, string> UpgradeTowers(Result<List<Tower>, string> towersResult)\n{\n    return towersResult.Map(towers =>\n        towers.Select(tower =>\n        {\n            tower.Name += \" (Upgraded)\";\n            return tower;\n        }).ToList());}\n```", "```cs\npublic Result<bool, string> ValidateTower(Result<Tower, string> towerResult)\n{\n    var damageValidated = towerResult.Apply(ValidateDamage);\n    var nameValidated = towerResult.Apply(ValidateName);\n    return damageValidated.Bind(damageResult =>\n        nameValidated.Map(nameResult => damageResult && nameResult));\n}\n```", "```cs\npublic Result<Tower, string> ProcessAndDeployTower(int towerId)\n{\n    return FetchTower(towerId)\n        .Bind(UpgradeTower)\n        .Bind(DeployTower);\n}\n```"]