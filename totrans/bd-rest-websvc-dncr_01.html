<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started</h1>
                </header>
            
            <article>
                
<p>Modern web development demands interaction with servers without any hassle. What this means is that with the evolution of different UI and backend frameworks, developers need to find a way of sharing data with any available framework without any dependencies. This means there should be a way of sharing data from the server with clients, irrespective of their language and framework. To bring a uniformity to sharing data, the first thing that comes to mind is <kbd>.xml</kbd> and <kbd>.json</kbd>. These formats are supported by every framework.</p>
<p>In this chapter, we will look at an architectural style by which we can get or send data from any program written in any language using any framework. With REST, the architecture we will be discussing, we can bring in methods that can be easily consumed by clients for data operations.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>RESTful services</li>
<li>Why should we use RESTful services? The difference between RESTful and RESTless services</li>
<li>Client-server architecture</li>
<li>ASP.NET Core and RESTful services</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discussing RESTful services</h1>
                </header>
            
            <article>
                
<p><strong>REST</strong> stands for <strong>representational state transfer</strong>. It is an architectural style that defines a set of guidelines for building web services.</p>
<p class="mce-root">What is an architectural style? It's nothing but a concept with predefined principles. We will talk about these principles in a moment. When you follow REST, you are actually implementing the principles that are the building blocks of REST in your application.</p>
<p class="mce-root">However, the implementation of REST will definitely differ from developer to developer. There is no fixed implementation style. Don't get confused with <strong>architectural patterns</strong>, which are not concepts but the actual implementations. MVC is an architectural pattern as it has a fixed structure that defines how the components interact with each other where they can't be differently implemented. </p>
<p>The following is a very simple diagram of a REST-based service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/641c4372-c171-4dd6-b846-750dd2afd7d7.png" style="width:25.83em;height:16.17em;"/></div>
<p>To simplify things, consider the preceding diagram, which shows you a service that has certain methods, such as <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>. That is what this style is all about. When you design your service, which will have all these methods—with the intended operations inside them—we can consider it as a REST-based service, otherwise known as a RESTful service. More importantly, the service can be called from an application built in any platform and language as the service has a standard architecture.</p>
<p>As discussed, a RESTful service is a service that supports REST. Let's talk about the characteristics of REST so that we can understand what is expected from a service that is RESTful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST characteristics</h1>
                </header>
            
            <article>
                
<p>The main building blocks of web services are the client and server architectures. The response sent from the server is actually a reply to the client's request. It's like you are asking a question and the server responds if it finds the answer. The response that comes from the server is actually a resource in a certain format or representation. The formats that are usually seen are <kbd>.json</kbd>, <kbd>.xml</kbd>, <kbd>.pdf</kbd>, <kbd>.doc</kbd>, and so on. </p>
<p>REST is stateless. <strong>Stateless</strong> means that the state of the system is always different. So, when a request comes to the server, it is served and forgotten. Thus, the next request does not depend on the state of the previous one. Each request is handled by the server independently.</p>
<p>The requests are performed in an HTTP connection. They each take the form of a <strong>u</strong><span><strong>niform resource identifier</strong> (</span><strong><span>URI</span></strong><span>). This identifier helps us to locate the required resource on the web server.</span></p>
<p>Roy Fielding’s PhD dissertation, entitled <em>Architectural Styles and the Design of Network-Based Software Architectures</em>, defined REST. The following are some key points extracted from his research:</p>
<ul>
<li>Like many distributed architectures, REST imposes layers, statelessness, and caching.</li>
<li>REST improves efficiency, interoperability, and overall performance.</li>
<li>REST introduces uniformity by following a set of rules on how to identify and manipulate resources, along with the process to simplify the description about its operations through metadata so that the messages passed will be self-explanatory. We will talk more about this uniformity, which is called the <strong>u</strong><strong>niform interface</strong>.</li>
<li>As REST is an architectural style, a service can be developed using any language or platform as long as it supports HTTP.</li>
</ul>
<div class="packt_infobox">You can read the whole dissertation at <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a><span>. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource-oriented architecture</h1>
                </header>
            
            <article>
                
<p>Every resource on the web has been given a unique identifier, otherwise known as a URI. The <span><strong>uniform resource locator</strong></span> <span>(</span><span><strong>URL</strong>) is the most common type of URI used on the web today. The URL</span> <a href="https://www.packtpub.com/">https://www.packtpub.com/</a><span> identifies and locates the Packt Publishing site.</span></p>
<p>Let's look at a quick picture of the architecture. In the following diagram, a client is trying to access a resource through an identifier (URL). The resource is present on the server and has a representation that can be returned to the client when requested:  </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bc2b638a-ee53-42e8-96dc-e7bd8f7b1943.png" style="width:22.00em;height:17.42em;"/></div>
<p>As the name suggests, the URL is something that is tied to only one resource; therefore, if I want to point someone to one resource, I can easily share that identifier in email, chat, and so on.</p>
<p>These identifiers can by easily remembered if they are named with company or resource names. The best example is <a href="https://www.google.com/">www.google.com</a><span>, </span><span>which is very easy to remember as the name Google is present. Therefore, we can spread the resource link by word of mouth and you can enter it into a web browser, such as Chrome or Firefox, within seconds.</span></p>
<p>You might find hyperlinks on a particular web page that link to another website for another resource. That means that resources are now interconnected because of the hyperlinks.</p>
<p>These interconnected resources form the resource-oriented architecture. Hyperlinks make it easy to navigate from one resource to another by using the target resource URI.</p>
<div class="packt_infobox">For example, in HTML, you link to another resource through the anchor element. The following is one anchor element that links to Packt's IoT book catalog page:<br/>
<br/>
<kbd>&lt;a href="https://www.packtpub.com/tech/Internet%20of%20<br/>
Things"&gt;Packt IoT Books&lt;/a&gt;</kbd></div>
<p>By default, the anchor element is rendered as an underlined text. When you hover over it, you can see the attached URI at the bottom, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/88e544c6-dead-49bb-bf36-e490df4a8afd.png"/></div>
<p><span>You can click on the anchor text (<span class="packt_screen">Packt IoT Books</span>), which then fires a <kbd>GET</kbd> request for the target resource URI.</span></p>
<p>Note that the moment you click the hyperlink, you will land on a web page that is actually a representation of a resource. The most common representation you will encounter is in HTML <span>format</span><span>. Some other common formats are (X)HTML, JPEG, GIF, WMV, SWF, RSS, ATOM, CSS, JavaScript/JSON, and so on. When a browser receives one of these representations, it tries to parse it and then renders it for viewing, if parsing succeeds.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI</h1>
                </header>
            
            <article>
                
<p>We have talked a lot about resources. They are actually the pages that we see on a particular website. However, resources in HTTP are not just simple files in the form of HTML web pages. Generally, a resource is defined as any piece of information that can be uniquely  identified by a URI, such as <a href="http://packtpub.com/">http://packtpub.com/</a>.</p>
<p>Let's talk about URIs for a moment. A URI consists of a few components: a URI scheme name, such as <kbd>http</kbd> or <kbd>ftp</kbd> is the first part, followed by a colon character. After the colon character comes the hierarchical part:</p>
<pre>&lt;scheme name&gt; : &lt;hierarchical part&gt; [ ? &lt;query&gt; ] [ # &lt;fragment&gt; ]</pre>
<p>Let's analyze one URI:</p>
<pre>https://www.flipkart.com/men/tshirts/pr?sid=2oq%2Cs9b%2Cj9y</pre>
<p>Let's break down the preceding URI:</p>
<ul>
<li>The scheme name is <kbd>https</kbd>.</li>
<li>The scheme name is followed by the hierarchical part, <kbd>//www.flipkart.com/men/tshirts/pr</kbd>. The hierarchical part starts with <kbd>//</kbd>.</li>
<li>The hierarchical part also contains an optional query, which is <kbd><span>sid=2oq%2Cs9b%2Cj9y</span></kbd>, in this case.</li>
</ul>
<p>The following is an example of a URI containing the optional fragment part:</p>
<pre>https://en.wikipedia.org/wiki/Packt#PacktLib</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST constraints</h1>
                </header>
            
            <article>
                
<p>REST is defined by six constraints, as shown in the following diagram. One of them is optional:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e2cdfe5c-ba40-4e18-90eb-9fa10d21acce.png" style="width:34.33em;height:19.92em;"/></div>
<p>Each of these constraints enforce a design decision <span>for the service </span><span>that is to be followed. If it is not followed, the service can't be denoted as RESTful. Let's discuss these constraints one by one.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-server architecture</h1>
                </header>
            
            <article>
                
<p>The client or the consumer of the service should not worry about how the server processes the data and stores it in the database. Similarly, the server does not need to depend on the client's implementation, especially the UI.</p>
<p>Think of an <em>internet of things</em> device or <em>sensor</em> that doesn't have much of a UI. However, it interacts with the server to store data using APIs, which are programmed to be fired on specific events. Suppose you are using an IoT device that alerts you when your car runs out of petrol. At the time of a petrol shortage detection by the sensor in the IoT device, it calls the <span>configured </span><span>API, which then finally sends an alert to the owner.</span></p>
<p>What that means is that the client and server are not one entity and each can live without the other. They can be designed and evolved independently. Now you might ask, <em>How can a client </em><em>work </em><em>without knowing about the server's architecture, and vice versa?</em> <span>Well, that is what these constraints are meant for. The service, when interacted with by the clients, provides enough information about its nature: how to consume it, and what operations you can carry out using it.</span></p>
<p>As we go ahead in this section, you will realize that there is absolutely no relation between the client and the server, and they can be completely decoupled if they adhere to all these constraints perfectly. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateless</h1>
                </header>
            
            <article>
                
<p>The term stateless means that the state in which the application remains for a particular time may not persist to the next moment. A RESTful service does not maintain the application's state, and thus it is stateless.</p>
<p>A request in a RESTful service does not depend on a past request. The service treats each request independently. On the other hand, a stateful service needs to record the application's current state when the request is performed so that it can act as required for the next request.</p>
<p>Moreover, because of an absence of these complications, stateless services become very easy to host. As we need not worry about the state of the application, it becomes easy to implement, and maintenance becomes smooth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching</h1>
                </header>
            
            <article>
                
<p>To avoid generating the same data with every request, there is a technique called <strong>caching</strong> that is used to store the data either on the client's or the server's side. This cached data may be used for further reference whenever it is required.</p>
<p>When using caching, it is important that you manage it properly. The reason for this is simple. We are storing data that won't be replaced by fresh data from the server. While this is an advantage that increases the performance of the service, at the same time, if we are not careful as to what to cache and configure during its lifetime, we might end up seeing outdated data. For example, suppose we are showing the live <span>price</span><span> of </span><span>gold on our website and we cached this figure. The next time the price changes, it won't be reflected unless we expire the cache that was previously stored.</span></p>
<p>Let's look at the different kinds of HTTP headers and how to configure caches:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Header</strong></p>
</td>
<td>
<p><strong>Application</strong></p>
</td>
</tr>
<tr>
<td>
<p>Date</p>
</td>
<td>
<p>Date and time of the generation of the representation.</p>
</td>
</tr>
<tr>
<td>
<p>Last modified</p>
</td>
<td>
<p>Date and time when this representation was last modified by the server.</p>
</td>
</tr>
<tr>
<td>
<p>Cache-control</p>
</td>
<td>
<p>The HTTP 1.1 header used to control caching. We will look at this in more detail after this table.</p>
</td>
</tr>
<tr>
<td>
<p>Expires</p>
</td>
<td>
<p>This header helps to tag an expiration date and time for this representation.</p>
</td>
</tr>
<tr>
<td>
<p>Age</p>
</td>
<td>
<p>Denotes the time in seconds since the representation was fetched from the server.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span>The configuration of the preceding five headers depends upon the nature of the service. Take the example of the service that provides the live </span><span>price of </span><span>gold—ideally, it would have the cache age limit as low as possible, or even have caching turned off, because users should see the latest results every time they refer to the site.</span></p>
<p><span>However, a site that contains many images would hardly change or update them. In that case, the cache can be configured to store them for a longer duration.</span></p>
<p>These header values are consulted in accordance with the cache-control header to check whether the cached results are still valid or not.</p>
<p>The following are the most common values for the cache-control header:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Directive</strong></p>
</td>
<td>
<p><strong>Application</strong></p>
</td>
</tr>
<tr>
<td>
<p>Public</p>
</td>
<td>
<p>This is the default directive. This allows every component to cache the representation.</p>
</td>
</tr>
<tr>
<td>
<p>Private</p>
</td>
<td>
<p>Only the client or server can cache the representation. However, i<span>ntermediary components are restricted.</span></p>
</td>
</tr>
<tr>
<td>
<p>no-cache/no-store</p>
</td>
<td>
<p>With this value, we can turn off caching.</p>
</td>
</tr>
<tr>
<td>
<p>max-age</p>
</td>
<td>
<p>This value is the time in seconds after the date and time is mentioned in the <em>Date</em> header, which denotes the validity of the representation.</p>
</td>
</tr>
<tr>
<td>
<p>s-maxage</p>
</td>
<td>
<p>This does the same as max-age, but only targets intermediary caching.</p>
</td>
</tr>
<tr>
<td>
<p>must-revalidate</p>
</td>
<td>
<p>This states that the representation must be revalidated if the max-age has passed.</p>
</td>
</tr>
<tr>
<td>
<p>proxy-validate</p>
</td>
<td>
<p>This does the same as max-revalidate, but only targets intermediary caching.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code on demand (optional)</h1>
                </header>
            
            <article>
                
<p>As the phrase <em>code on demand</em> suggests, the service may try to execute code on the client to extend the functionality. However, this is optional, and not every service does this.</p>
<p>Consider an example of a web application that calls a ticketing service to fetch all the available tickets. The service wants always to show this information in an alert. In order to do this, the service can return a JavaScript code along with the data, which has an alert message with the number of available tickets. Thus, as soon as the client receives the response from the service, an alert is executed and the data is shown.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uniform interface</h1>
                </header>
            
            <article>
                
<p>When we encounter the word <em>interface</em>, the first thing that comes to our mind is decoupling. We create interfaces to have loosely coupled architecture, and the same type of architecture is seen in the case of RESTful.</p>
<p><span>While implementing REST, we use the same concept to decouple the client from the implementation of the REST service. However, to implement such a decoupling between the client and the service, standards are defined that every RESTful service supports.</span></p>
<p><span>Note the word <em>standard</em> in the preceding line. We have so many services in the world and, obviously, the consumers outnumber the services. As a result, we have to follow some rules while designing the services because every client should understand the service easily without any hassle.</span></p>
<p>REST is defined by four interface constraints:</p>
<ul>
<li><strong>Identification of resources</strong>: A URI is used to identify a resource. The resource is a web document.</li>
<li><strong>Manipulation of resources through representations</strong>: <span>When a client has a given resource—along with any metadata—they should have enough information to either modify or delete the resource. </span><span>So, for example, <kbd>GET</kbd> means that you want to retrieve data about the URI-identified resource. You can describe an operation with an <kbd>HTTP</kbd> method and a URI.</span></li>
<li><strong>Self-descriptive messages</strong>: The messages passed should contain enough information about the data to be understood and processed for further operations. MIME types are used for this purpose.</li>
<li><strong>Hypermedia as the engine of the application state</strong> (<strong>HATEOAS</strong>): The representation returned from the service should contain all the future actions as links. It is the same as visiting a website in which you find different hyperlinks providing you with the different types of available operations.</li>
</ul>
<p>HTTP 1.1 provides a set of methods, called verbs. Implementing these verbs in our services would mark them as standardized. The important verbs are as follows:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Operation Performed on Server</strong></p>
</td>
<td>
<p><strong>Method Type</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Read/retrieve a resource.</p>
</td>
<td>
<p>Safe</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>Either insert a new resource or update the resource if it already exists.</p>
</td>
<td>
<p>Idempotent</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Insert a new resource. Can be used to update an existing resource as well.</p>
</td>
<td>
<p>Nonidempotent</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Delete a resource .</p>
</td>
<td>
<p>Idempotent</p>
</td>
</tr>
<tr>
<td>
<p><kbd>OPTIONS</kbd></p>
</td>
<td>
<p>Get a list of all the allowed operations for a resource.</p>
</td>
<td>
<p>Safe</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HEAD</kbd></p>
</td>
<td>
<p>Return only the response headers with no response body.</p>
</td>
<td>
<p>Safe</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding table is quite self-explanatory, except the <em>Method Type</em> column. Let me clarify this.</p>
<p>A s<em>afe</em> operation when performed on the service does not have any effect on the original value of the resource. As the <kbd>GET</kbd>, <kbd>OPTIONS</kbd>, and <kbd>HEAD</kbd> verbs only retrieve or read the resource-related stuff and does not update that, they are safe.</p>
<p>An <em>idempotent (can be repeated)</em> operation when performed gives the same result no matter how many times we perform it. For example, when you make a <kbd>DELETE</kbd> or <kbd>PUT</kbd> operation, you are actually operating on a particular resource, and the operation can be repeated with no issues.</p>
<div class="packt_infobox"><kbd>POST</kbd> versus <kbd>PUT</kbd>: This is a very common topic of discussion on the internet, and one that is very easy to understand. B<span>oth</span><span> </span><kbd>POST</kbd> <span>and</span> <kbd>PUT</kbd><span> can be used to insert or update a resource. However, </span><kbd>POST</kbd> <span>is nonidempotent, meaning that it isn't repeatable. The reason is that each time you call using </span><kbd>POST</kbd><span>, it will create a new resource if you don't provide the exact URI of the resource. The next time you use </span><kbd>POST</kbd><span>, it will again create a new resource. However, in</span> <kbd>PUT</kbd><span>, it will first validate the existence of the resource. If it exists, it will update it; otherwise, it will create it.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More explanation</h1>
                </header>
            
            <article>
                
<p>Among all the available methods, <kbd>GET</kbd> is the most popular one, as it is used to fetch the resource.</p>
<p>The <kbd>HEAD</kbd> <span>method</span><span> </span><span>will </span><span>only</span><span> </span><span>return the response headers with an empty body. This is mostly only required when we don't need the whole representation of the resource.</span></p>
<p>The <kbd>OPTIONS</kbd> method is used to get a list of the allowed or available operations on the resource.</p>
<p>Consider the following request:</p>
<pre>OPTIONS http://packtservice.com/Authors/1 HTTP/1.1 HOST: <span>packtservice</span></pre>
<p>If the request is authorized and authenticated, it might return something like the following:</p>
<pre>200 OK Allow: HEAD, GET, PUT</pre>
<p>The response is actually saying that the service can be called using <span>only </span><span>all these methods.</span></p>
<p>Make sure you use the HTTP methods according to their specification. If you design the service to allow <kbd>GET</kbd>, but perform a delete operation inside that, then clients will get confused. As they try to <kbd>GET</kbd> something, it will actually delete the resource, which is weird.</p>
<p>The following is a request that is made with <kbd>GET</kbd>, but it actually deletes the resource inside the server (just imagine): </p>
<pre>GET http://packtservice.com/DeleteAuthor/1 HTTP/1.1 HOST: packtservice</pre>
<p>The preceding request might work and delete the resource, but this is not regarded as a RESTful design. The recommended operation would be to use <kbd>DELETE</kbd> method to delete a resource like the following:</p>
<pre>DELETE http://packtservice.com/Authors/1 HTTP/1.1 HOST: packtservice</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POST versus PUT explained</h1>
                </header>
            
            <article>
                
<p><span>The use of <kbd>POST</kbd> and <kbd>PUT </kbd></span>can be summarized in the following two points:</p>
<ul>
<li><kbd>PUT</kbd> is idempotent—it can be repeated, and yields the same result every time. If the resource does not exist, it will create it; otherwise, it will update it.</li>
<li><kbd>POST</kbd> is nonidempotent—multiple resources will be created if it is called more than once.</li>
</ul>
<p>The <span><span>preceding contrast between these verbs </span></span>is just a general difference. However, there is a very important and significant difference. When using <kbd>PUT</kbd>, specifying the complete URI of the resource is necessary. Otherwise, it won't work. For example, the following won't work as it does not specify the exact URI of the author, which can be done by specifying an ID:</p>
<pre><span>PUT http://packtservice.com/Authors/</span></pre>
<p>To fix this, you can send an ID with this URI using something like the following:</p>
<pre><span>PUT http://packtservice.com/Authors/19<br/></span>created/updated.</pre>
<p>This means that the author with the ID <kbd>19</kbd> will be processed, but if that does not exist, it will be created first. Subsequent requests with this URI will be considered as requests to modify the author resource with an ID of <kbd>19</kbd>.</p>
<p>On the other hand, if we do the same with a <kbd>POST</kbd> request like the following, it will create a new author resource with the posted data:</p>
<pre><span>POST http://packtservice.com/Authors/<br/></span></pre>
<p>Interestingly, if you repeat this, you will be responsible for duplicate records with the same data. That is why it is <em>nonidempotent</em> in nature.</p>
<p>Note the following request with <kbd>POST</kbd> with an ID. Unlike <kbd>PUT</kbd>, <kbd>POST</kbd> won't consider this for a new resource, if that is does not exist. It will always be treated as an update request:</p>
<pre><span>POST http://packtservice.com/Authors/19<br/>updated.</span></pre>
<p>The following are the main points to focus on in this section:</p>
<ul>
<li><kbd>PUT</kbd> creates or updates one resource, as long as you are calling the same URI</li>
<li><kbd>PUT</kbd> and <kbd>POST</kbd> behave the same, if the resource already exists</li>
<li><kbd>POST</kbd>, without an ID, will create a resource each time it is fired</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layered system</h1>
                </header>
            
            <article>
                
<p>Most modern applications are designed using multiple layers, and the same is expected from a RESTful service. In a layered system, each layer is restricted to only seeing or knowing the next layer in the hierarchy.</p>
<p>Having a layered architecture helps improve the code's readability, hides complexities, and improves the code's maintainability. Imagine that you have one layer and everything takes place in it, from authentication to database operations. This is absolutely not recommended, as the primary components, such as authentications, business logic, and database operations, are not separated out.</p>
<p>Thus, this constraint is expected from a RESTful service, and no client can actually say that it is connected to the final layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages and disadvantages of RESTful services</h1>
                </header>
            
            <article>
                
<p>The following are some advantages and disadvantages of RESTful services:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages</h1>
                </header>
            
            <article>
                
<p>The advantages of using RESTful services are as follows:</p>
<ul>
<li>No dependency on a platform or any programming language</li>
<li>Standardized methods through HTTP</li>
<li>It doesn't store the state of the clients on the server</li>
<li>Supports caching</li>
<li>Accessible to any type of client, such as mobile, web, or desktop</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disadvantages</h1>
                </header>
            
            <article>
                
<p>While there are advantages, there must be some cons. Let's look at some disadvantages of RESTful services:</p>
<ul>
<li>If the standards are not followed correctly, they are difficult for clients to understand</li>
<li>Documentation becomes problematic as no such metadata is provided</li>
<li>Security is a concern, if no such process is followed to restrict the access of resources</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ASP.NET Core and RESTful services</h1>
                </header>
            
            <article>
                
<p>.NET Core is defined as a cross-platform, open-source, cloud-ready, and modular .NET platform for creating modern web apps, microservices, libraries, and console applications that run everywhere (Windows, Linux, and macOS).</p>
<p>ASP.NET Core is a free and open-source web framework, and the next generation of ASP.NET. It is a modular framework consisting of small packages of framework components that run on both the full .NET Framework, Windows, and the cross-platform .NET Core.</p>
<p class="mce-root">The framework is a complete rewrite from the ground up. It unites the previously separate ASP.NET MVC and ASP.NET Web API into a single programming model.</p>
<p><span>ASP.NET Web API has been built to map the web/HTTP programming model to the .NET Framework programming model. It uses familiar constructs, such as Controller, Action, Filter, and so on, which are used in ASP.NET MVC.</span></p>
<p><span>ASP.NET Web API is designed on top of the ASP.NET MVC runtime, along with some components that simplify HTTP programming. We can leverage Web API technology to perform actions on the server with .NET Framework; however, to be RESTful, we should adhere to the standards that we discussed earlier in this chapter. Fortunately, Web API automatically manages all the low-level transport details of HTTP while maintaining all the required constraints.</span></p>
<p>Because of the uniformity that Web API provides, enforcing the RESTful principles, clients such as mobiles, web applications, the cloud, and so on can easily access it without any problem:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c703ef2-d204-4aea-ae42-52884f2b364e.png" style="width:44.67em;height:32.58em;"/></div>
<p>Prior to ASP.NET Core, MVC and Web API were different as they inherited <kbd>Controller</kbd> and <kbd>ApiController</kbd> classes respectively. On the other hand, in ASP.NET Core, they follow the same structure.</p>
<p>The following is the Solution Explorer view of both MVC and Web API. You can see that they have a similar structure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8294820e-a200-4a3f-ac9a-0aa7ac67d764.png" style="width:43.42em;height:24.50em;"/></div>
<p>The following is a controller that was automatically created when I clicked on <span class="packt_screen">File | New | Project | ASP.NET Core Web Application | Web API</span>. You can see the base class of the controller is <kbd>Controller</kbd> instead of <kbd>ApiController</kbd>:</p>
<pre>namespace WebAPIExample.Controllers<br/>{<br/>  [Route("api/[controller]")]<br/>  public class <strong>ValuesController : Controller</strong><br/>  {<br/>    // GET api/values<br/>    [HttpGet]<br/>    public IEnumerable&lt;string&gt; Get()<br/>    {<br/>      return new string[] { "value1", "value2" };<br/>    }<br/>    // GET api/values/5<br/>    [HttpGet("{id}")]<br/>    public string Get(int id)<br/>    {<br/>      return "value";<br/>    }<br/>    // POST api/values<br/>    [HttpPost]<br/>    public void Post([FromBody]string value)<br/>    { }<br/>    // PUT api/values/5<br/>    [HttpPut("{id}")]<br/>    public void Put(int id, [FromBody]string value)<br/>    { }<br/>    // DELETE api/values/5<br/>    [HttpDelete("{id}")]<br/>    public void Delete(int id)<br/>    {  }<br/>  }<br/>}</pre>
<p>Don't worry about codes now; we will discuss everything later in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>REST defines how to use the uniform interface through additional constraints, how to identify resources, how to manipulate resources through representations, and how to include metadata that makes messages self-describing.</p>
<p>The web is built on HTTP’s uniform interface, and the focus is on interacting with resources and their representations. REST isn’t tied to any specific platform or technology; the web is the only major platform that fully embodies REST. The basic style of the architecture of RESTful web services is client–server.</p>
<p>Here, the client requests a resource and the server processes and responds to the requested resource. The response of the server is user-based and platform-independent. The separation of concerns is the principle behind the client–server constraints. Because in client–server architecture, the storage and user interfaces are roles taken by the server and client respectively, it has improved portability of the user interface across multiple platforms.</p>
<p>We should document every resource and URI for client developers. We can use any format for structuring our document, but it should contain enough information about resources, URIs, available methods, and any other information required for accessing the service.</p>
<p><em>Swagger</em> is a tool that can be used for documentation purposes, and provides all the information regarding the API endpoints on one screen, where you can visualize the API and test it by sending parameters as well. Developers can use another tool called <em>Postman</em> for testing out APIs. Both of these tools will be explained with examples in the upcoming chapters of this book.</p>
<p>ASP.NET Web API is a development environment constructed to develop RESTful web services that allow applications to send and receive HTTP requests (<em>web requests</em>)<span> </span><span>easily</span><span> </span><span>and perform operations based on the types of requests that are made to it (such as providing information about a user when given their ID, and so on).</span></p>
<p>Web API design in ASP.NET Core has been simplified following the same programming model as MVC.</p>
<p>In the next chapter, we will start coding by setting up the environment and look into the various fundamentals of the HTTP verbs in Web API.</p>


            </article>

            
        </section>
    </body></html>