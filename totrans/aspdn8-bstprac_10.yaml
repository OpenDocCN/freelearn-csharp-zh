- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Push Your Application with Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With each new release of **ASP.NET**, the ASP.NET team continues to make performance
    a priority. When ASP.NET Core introduced a different way of building web applications
    with streamlined enhancements (including **middleware** and **Razor Pages**) the
    focus was continually on improving the C# language as well. These technologies
    are what give ASP.NET its spark and speed.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET is cross-platform, has built-in support for dependency injection, is
    open source, and is one of the fastest-performing frameworks in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: While this is an ASP.NET book with a chapter on performance, there will be additional
    aspects of web development that are equally as important. We’ll stay focused on
    ASP.NET and C# performance as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Performance Matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing Baselines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Performance Best Practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand the importance of performance
    in your application, how to establish client-side and server-side baselines and
    techniques on how to optimize the client-side resources for faster delivery, and
    finally, how to deliver content faster with server-side performance techniques
    such as optimizing HTML, implementing various caching techniques, and identifying
    slow queries.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating baselines and testing performance for your web application, there
    is a need for an IDE or editor you feel comfortable with for writing code. We
    recommend using your favorite editor to view the GitHub repository. Our recommendations
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio** (preferably the latest version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual** **Studio Code**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JetBrains Rider**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is located in Packt Publishing’s GitHub repository,
    located at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Why Performance Matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance takes many shapes and forms in web development since there are so
    many moving pieces to make a website always ready and available to our users.
    As a developer, if someone asked for help regarding a website being slow, what
    advice would you recommend? It’s a tough question to answer verbally without examining
    the website. With websites, there may be times when performance isn’t just one
    technology; the problem may be more than one bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when loading a web page in the browser, do you see content appear,
    but images take a long time and paint row by row? How about accessing the database?
    Do you have slow queries where the server takes a minute to retrieve records?
    Are web APIs performing at more than two seconds for each request?
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, performance is an analysis of an entire website including browser,
    server, C#, API, and database.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon published a study calculating that if a page load slowed down by even
    1 second on their website, it could cost them $1.6B in sales.
  prefs: []
  type: TYPE_NORMAL
- en: How one second could cost Amazon $1.6 billion in sales
  prefs: []
  type: TYPE_NORMAL
- en: The research was reported by Fast Company and is located at [https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales](https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales).
  prefs: []
  type: TYPE_NORMAL
- en: While this is a head-turner, there is a more recent article on how Netflix replaced
    React with plain JavaScript (more commonly called Vanilla JavaScript). This provided
    huge gains in performance. In the case study, it reported one page had 300 KB
    of JavaScript, which is a lot. However, compared to other websites such as [CNN.com](http://CNN.com)
    (4.4 MB of JavaScript) and [USAToday.com](http://USAToday.com) (1.5 MB of JavaScript),
    300 KB of JavaScript is considered minimal.
  prefs: []
  type: TYPE_NORMAL
- en: A Netflix web performance case study
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome Engineering Lead *Addy Osmani* wrote an article about the performance
    gains Netflix experienced through optimizations. The case study can be found at
    [https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9).
  prefs: []
  type: TYPE_NORMAL
- en: With these specific scenarios and case studies, many companies took notice and
    focused primarily on performance. Even Microsoft focused its efforts on performance
    by submitting its results to TechEmpower’s industry framework benchmark results.
    As a result of the constant improvement, ASP.NET is now ranked as one of the fastest
    platforms for the web.
  prefs: []
  type: TYPE_NORMAL
- en: TechEmpower framework benchmark results
  prefs: []
  type: TYPE_NORMAL
- en: 'Every year, TechEmpower updates its results in a chart that can be found at
    [https://techempower.com/benchmarks/](https://techempower.com/benchmarks/). As
    of July 19, 2022, ASP.NET is ranked #9 in performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with Google as the most dominant player in the search engine industry,
    it attached how fast a page loads to your **search engine result pages** (**SERPs**).
    Translation: the speed of your site is one of the ranking factors for how high
    you are in the search results (which we’ll discuss in the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: Google using site speed in web search ranking
  prefs: []
  type: TYPE_NORMAL
- en: On Google’s blog, they mentioned that page speed is another factor taken into
    account when ranking your website. The post is found at [https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking](https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking).
  prefs: []
  type: TYPE_NORMAL
- en: Performance is one of my favorite topics. The idea of making small changes that
    lead to large performance gains is definitely exciting. It also can be visually
    apparent as well. This chapter is meant to assist in using techniques and tools
    to identify those performance issues on any website.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is, in past chapters, we’ve already mentioned specific ways to
    improve performance that we’ll refer back to when relevant. As I’ve said in [*Chapter
    4*](B19493_04.xhtml#_idTextAnchor086), performance should be the top priority
    when building ASP.NET web applications, with security running a close second.
  prefs: []
  type: TYPE_NORMAL
- en: Performance has always been a mix between an art and a science as you’ll see
    in some of the sections in this chapter. There is *perceived* performance and
    then there’s *actual* performance.
  prefs: []
  type: TYPE_NORMAL
- en: Actual performance is a measurement when an activity or task immediately responds
    and notifies the user that it’s finished. An immediate response is a goal. Perceived
    performance is a subjective measurement where users experience an activity or
    task as quick, even when it isn’t. One example of perceived performance is when
    the user requests a web page and the browser renders the page immediately. The
    content continues to load in the background while keeping the user’s focus by
    allowing them to scroll through the page waiting for the additional content. As
    a result, users think the site is “fast” because it responded immediately. Spinners
    and progress bars are other ways to achieve perceived performance while something
    is processing.
  prefs: []
  type: TYPE_NORMAL
- en: While perceived performance is a way to divert a user’s attention while waiting
    for a process to complete, this chapter will focus more on actual performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn how to create baselines for client-side and
    server-side code using public web tools and specific server tools such as **Visual
    Studio Performance Profiler**, **Benchmark.net**, and **Application Insights**.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing Baselines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how do you know you’re experiencing a slowdown on a website? Is it because
    of a recent release of a software product, or a new NuGet package installed causing
    the slowdown?
  prefs: []
  type: TYPE_NORMAL
- en: While identifying an issue, you may be asking yourself, “what changed?” But
    the question everyone *should* be asking is “how do you measure performance?”
    In order to measure it, there needs to be a baseline of what’s expected when it
    comes to performance.
  prefs: []
  type: TYPE_NORMAL
- en: Each part of your application should include performance tests. Whether it’s
    the frontend, a C# subsystem, a web API, or the database, the proper systems should
    be in place to notify the team when a system isn’t performing as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Using Client-Side Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Issues on the client side are mostly due to load times, delivery of resources
    not found (such as HTML pages, images, CSS, and JavaScript), or JavaScript errors
    in general. However, this doesn’t mean the entire problem is on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a baseline for your client-side code should be conducted through a
    testing tool such as **Cypress** or **Selenium** during development and recording
    the duration of tests. Compare the latest scenarios with previous test results
    to see where there is a time difference.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach for determining a baseline is to use various tools on the web
    such as the tools listed in this section. Think of these tools as like taking
    your car to the mechanic for maintenance. These tools scan your public website,
    analyze all aspects of the site, and provide a report on how to fix each issue
    found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the tools to give you insights into the performance of a website include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google PageSpeed Insights** ([https://pagespeed.web.dev](https://pagespeed.web.dev)):
    Google uses its search engine to rank your site and provides an exceptional tool
    to help with website problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighthouse** ([https://developer.chrome.com/docs/lighthouse/](https://developer.chrome.com/docs/lighthouse/)):
    If your site isn’t publicly accessible to analyze from one of these tools, you
    can use the Lighthouse extension to run tests on the site in-house. Lighthouse
    produces a full report of recommendations on how to make your site perform better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GTMetrix** ([https://gtmetrix.com](https://gtmetrix.com)): GTMetrix is a
    tool I’ve been using over the years and it continues to impress and improve each
    year. It provides a performance summary, speed visualization, and recommendations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Search Console** ([https://search.google.com/search-console](https://search.google.com/search-console)):
    Google created this for administrators of websites to identify performance issues
    along with other general maintenance tools, such as what people are typing into
    Google to find your website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevTools**: DevTools is a panel of web developer tools located inside of
    Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Edge to help web developers
    analyze web pages, and it’s becoming the IDE of the internet. Pressing F12 in
    the browser will open the panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools are great for gauging how well your site performs on the internet
    and how it performs based on the last revision. If your last release takes 0.5
    seconds to load and the latest release now takes three seconds, it’s time to examine
    what changed. What better way to check this than to automate the process (refer
    to [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)) by reporting on the performance
    issue before deploying the site?
  prefs: []
  type: TYPE_NORMAL
- en: Using Server-Side Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With ASP.NET, creating baselines for your code is just as easy with a number
    of tools at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review some of the tools available for creating a baseline
    for your code such as Visual Studio, Benchmark.net, Application Insights, and
    other tools such as NDepend.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Performance Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Visual Studio being a solid IDE in the industry, the ability to gauge C#
    performance was becoming more prevalent because if code was slow, developers wanted
    a way to locate the bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Performance Profiler in Visual Studio 2022](img/B19493_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Performance Profiler in Visual Studio 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting **Performance Profiler**, you’re presented with a list of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – List of available options before running Performance Profiler](img/B19493_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – List of available options before running Performance Profiler
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are a vast number of options crossing multiple touchpoints.
    For example, there is a **Database** option to look at how your queries are performing
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The metrics for databases are similar to the **Entity Framework** details explaining
    the duration it took to execute the query. Another option is identifying where
    async/await problems can occur as well as memory usage and object allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark.net
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are smaller, self-contained methods required to test, one of the best
    tools around for micro-benchmarking is Benchmark.net ([https://benchmarkdotnet.org/](https://benchmarkdotnet.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark.net takes specific methods and tests them with different scenarios.
    The one caveat to this is that the Benchmark project *must* be a console application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if we wanted to test the age-old debate as to which is faster
    between string concatenation or a `StringBuilder` class, we would write two benchmark
    tests to determine which was faster, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a string in one scenario and an instance of
    a `StringBuilder()` class in another. To accomplish the same goal, we add 10,000
    ‘a’s and start the benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the results in *Figure 10**.3*, the obvious choice is to use `StringBuilder()`
    for performing large string concatenations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Comparing the performance of a string concatenation versus
    a StringBuilder() class](img/B19493_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Comparing the performance of a string concatenation versus a StringBuilder()
    class
  prefs: []
  type: TYPE_NORMAL
- en: In regards to creating a baseline, we added an additional parameter to our `[Benchmark]`
    attribute in our first scenario, called `Baseline`, and set it to `true`. This
    tells Benchmark.net to use this as our baseline when measuring the performance
    of our other methods. You can have any number of methods to achieve the same result,
    but everything will be compared to the one method with `Baseline=true` in the
    Benchmark attribute.
  prefs: []
  type: TYPE_NORMAL
- en: For small, compact methods, Benchmark.net is definitely a great tool for providing
    insight into ways to create faster code using micro-optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Application Insights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Microsoft’s Application Insights is meant to be a general-purpose analysis
    tool for collecting telemetry about everything your application does. Once set
    up, Application Insights can collect data about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Requests – web pages and API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies – what is your application loading behind the scenes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions – every exception your application throws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance counters – automatically identifying slowdowns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heartbeats – is the application still up and running?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs – a centralized location for collecting all types of logs for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding Application Insights, Application Insights *does* require an Azure
    subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Application Insights additional material
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to set up Application Insights and way too many to cover
    in this chapter. For more information on Application Insights and how to set it
    up for your application, navigate to [https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core](https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other recommendations for creating baselines and identifying bottlenecks
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JetBrains dotTrace/dotMemory** – dotTrace is a performance profiler tool,
    and dotMemory is a memory profiler tool. Both are exceptional tools and perform
    deep dives into how well your application performs. dotTrace and dotMemory give
    you the ability to compare a baseline of results against another set of results
    (“comparing snapshots”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RedGate ANTS Performance Profiler/Memory Profiler** – With the ability to
    profile .NET code and memory allocations, the ANTS Performance and Memory Profiler
    demonstrates a similar approach to performance and memory profiling while conducting
    a deep-dive analysis while your code is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if..else` or switches). These can be user-defined as well to meet your code
    quality requirements using **Code Query for LINQ** (**CQLinq**). NDepend also
    has capabilities to integrate into your CI/CD pipeline to automate the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build-it-yourself metrics** – Back in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163),
    we explained how to “identify slow integration tests.” Using the diagnostic Stopwatch
    on your unit, integration, and APIs, you can perform and report on these metrics
    even before sending out a release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When these tools examine your application, they perform analysis on how to optimize
    your code by finding hotspots. If the hotspot is called enough times, your application’s
    performance will suffer. The path to get to this hotspot is called the **hot path**.
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you can create a baseline with databases, most optimizations are done
    at the database level by analyzing stored procedures, index management, and schema
    definitions. Each database type has its own performance tools for finding bottlenecks.
    For now, we’ll focus specifically on **SQL** **Server** tools.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server Management Studio (SSMS) Profiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With **SSMS** using a profiler interface, developers have the ability to identify
    whether a particular ad-hoc query, stored procedure, or table isn’t performing
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server Profiler is located under the **Tools** option as the first menu
    item, as shown in *Figure 10**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – SQL Server Profiler in SSMS](img/B19493_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – SQL Server Profiler in SSMS
  prefs: []
  type: TYPE_NORMAL
- en: On running SQL Server profiler, every request sent to the database is logged
    along with how long it took, how many reads and writes are necessary, and the
    results returned.
  prefs: []
  type: TYPE_NORMAL
- en: Query Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the latest features of SQL Server 2016 is the **Query Store**. The Query
    Store provides you with insight into how to improve performance on SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once enabled (right-click on database | **Properties** | **Query Store** |
    **Operation Mode: On**), it’ll begin analyzing your SQL Server workload when actively
    being used and make recommendations on how to improve performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is collected, the metrics are available using stored procedures
    to identify slow-performing queries.
  prefs: []
  type: TYPE_NORMAL
- en: Query Store additional material
  prefs: []
  type: TYPE_NORMAL
- en: For additional material on Microsoft’s Query Store, navigate to [https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store](https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store).
    For performance tuning using Query Store, navigate to [https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store](https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we covered why establishing baselines is important while listing
    various client-side tools such as Google Page Speed Insights, Lighthouse, GTMetrix,
    Google Search Console, and Chrome DevTools for gauging performance. We also looked
    at server-side tools such as Visual Studio Performance Profiler, Benchmark.net,
    Application Insights, JetBrains dotMemory and dotTrace, RedGate ANTS Performance
    Profiler/Memory Profiler, and NDepend for identifying issues with codebases. With
    databases, we mentioned two tools to identify performance bottlenecks: SQL Server
    Management Studio Profiler and Query Store. We also mentioned hotspots, or hot
    paths, where frequently called, unoptimized code could cause performance issues
    in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover the best practices for some client-side and server-side
    techniques, but will mostly focus on server-side optimizations using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Performance Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, the content in this chapter applies
    to client *and* server techniques to get the most out of your ASP.NET websites.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll first focus on optimizing the client by applying image
    optimization, minimizing your requests, using CDNs, and other tips to improve
    client-side performance. Then we’ll focus on server-side techniques such as optimizing
    your HTML, caching, and **Entity Framework Core** performance techniques along
    with identifying slow queries.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing client-side performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll learn about image optimizations, identifying Google’s
    **Core Web Vitals** metrics, using a CDN when applicable, how to minimize requests,
    and where to place scripts and styles.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing Image Optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the Web Almanac ([https://almanac.httparchive.org/en/2022/media#bytesizes](https://almanac.httparchive.org/en/2022/media#bytesizes)),
    image optimization is one of the worst problems on the web. The number of devices
    required to support it doesn’t make this any easier. Let’s see how we can optimize
    this experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic usage of an `<``img>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for responsive layouts, the `<img>` tag has an `srcset` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code identifies the size of the viewport (the web page) and loads
    the appropriate image. The `max-width` media condition says that if the viewport
    is 640px, use the 400px image. If the max-width is over 640px and less than 800px,
    use the 800px image.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to support a number of different responsive layouts. Once you
    define the layout for your site, images should complement the layout size as well.
    What does this mean? For every image, you should have an image created for each
    responsive layout. For example, the preceding default image logo should have three
    images: `logo-400.jpg`, `logo-800.jpg`, and `logo-1024.jpg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `loading="lazy"` tells the browser to defer loading the images until
    the browser can determine the size of the viewport to display the proper image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, images can become extremely large and can contain encoded data such
    as GPS data when a picture is taken. Compressing an image is the process of removing
    the extra data, making the image smaller and quicker to load in a browser. This
    is a server-side task and can be included as a task in your client-side task runner
    (previously discussed in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimum steps for image optimization should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Determine the site’s responsive layouts** – Identify the sizes you need for
    your images (400px, 800px, etc.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create the images based on the layouts** – There should be a resized image
    for each layout size.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Optimize the images** – For each image on your site, compress the images
    so they are smaller and load faster by removing the extra data attached to each
    image. Use image services such as Optimazilla ([https://imagecompressor.com/](https://imagecompressor.com/))
    or TinyPNG ([https://tinypng.com/](https://tinypng.com/)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`srcset` and `sizes` attributes so the browser can determine the best image
    to display based on the viewport size.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Image optimization is too big a topic for a small chapter, but this quick overview
    should be enough to provide a better experience for website users.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the aforementioned client-side tools for creating baselines can be used
    to identify where multiple requests are made for resources. On average, websites
    have 58 requests for JavaScript and CSS (that’s *not* counting images). Each request
    causes latency and depending on the resource, it’ll take longer than a user is
    willing to wait.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already learned how to use a better approach when structuring your JavaScript
    and CSS back in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137), eliminating a
    large number of requests for your JavaScript and CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if there’s a large number of consistent-sized images and you’re calling
    each one separately, a better approach would be to create one large image (sprite
    sheet) containing all of the images and use CSS to display them. Instead of your
    browser requesting 15 social network logos, make one call to an image and split
    them out using CSS, as shown in *Figure 10**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Sprite sheet of 32x32 social network icons](img/B19493_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Sprite sheet of 32x32 social network icons
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this sprite sheet, the CSS would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The background identifies which image to use as a background by using the offset
    top and left positions. To display the RSS icon in HTML, it would be presented
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Such services to create sprites include CodeShack’s Images to Sprite Sheet Generator
    ([https://codeshack.io/images-sprite-sheet-generator/](https://codeshack.io/images-sprite-sheet-generator/))
    and Toptal’s CSS Sprites Generator ([https://www.toptal.com/developers/css/sprite-generator](https://www.toptal.com/developers/css/sprite-generator)).
  prefs: []
  type: TYPE_NORMAL
- en: Using CDNs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a site uses a large number of static files, using a **content delivery network**
    (**CDN**) provides a much-needed service of delivering content based on location.
    These geographically based servers cache files so they’re delivered quicker based
    on where a user is located.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if someone in California requests a file from Nevada, it’s quicker
    than someone requesting the file from England. The closer the content, the quicker
    the user receives it.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts on client-side performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While there are a ton of client-side tips we could cover, let’s close this
    section out with some final thoughts on making the client quicker:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scripts at the bottom, styles at the top** – Avoid placing scripts in the
    header, but absolutely place the styles in the header. Placing scripts at the
    bottom confirms the **Document Object Model** (**DOM**) is completely loaded and,
    if immediately executed, JavaScript is able to find the DOM elements because they’ve
    already been rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply Google’s Core Web Vitals to your site** – If you’re using either Lighthouse
    or Google’s Page Speed Insights, you’ll notice the following acronyms for identifying
    your site’s performance: FCP (First Contentful Paint), LCP (Largest Contentful
    Paint), CLS (Cumulative Layout Shift), and FID (First Input Delay). Review these
    terms at [https://web.dev/vitals](https://web.dev/vitals) to provide a better
    web experience for your users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<details>`/`<summary>` HTML tags may be enough. Also, browsers are becoming
    even more modern and evolved with new tags such as the `<dialog>` tag where JavaScript
    isn’t necessary. Refer to [https://caniuse.com/](https://caniuse.com/) for browser
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you learned how to optimize the client side by optimizing your
    images, along with how CDNs improve the loading of your static content and how
    to minimize your requests to lower latency issues. For our final notes, we examined
    some tips such as placing scripts at the bottom and styles at the top, applying
    Google’s Core Web Vitals to websites, providing sites that are responsive regardless
    of device, and using HTML instead of JavaScript where it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll shift our focus from the client to the server side
    and look at some of the common practices when optimizing C# and Entity Framework
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: Common Server-side Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With C# being such a robust language, there are so many ways to create a web
    application. As you saw in [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114) with
    Entity Framework Core, each design pattern fit a certain need but worked the same
    regardless of the pattern. The good news with these performance techniques is
    they apply to web standards and design patterns already used in the industry.
    One such example is ETags. At one point, they were considered a separate web concept
    requiring specific code. Now, when using static files, these ETags are integrated
    into websites without any additional coding. They’re considered a web standard
    with browsers.
  prefs: []
  type: TYPE_NORMAL
- en: What we’re going to address in this section is how to improve performance by
    adding these web standards and design patterns to our own web application to make
    it even faster.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn about the various performance enhancements we can
    apply to your code using C#, including quick performance gains you can apply immediately
    to your own website, and we’ll learn how to add a middleware component to optimize
    your HTML, improve Entity Framework Core performance with only four letters, and
    identify slow Entity Framework Core queries.
  prefs: []
  type: TYPE_NORMAL
- en: Applying quick performance wins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While some of these quick hits are well-known (and some have been covered in
    previous chapters), it doesn’t hurt to review them to get the most performance
    out of your website:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Turn Debug Off** – When you run your application with debug mode, additional
    information is compiled into each assembly for debugging purposes. When changed
    to release mode, you are getting an optimized version of your assemblies for deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use async/await** – As mentioned in previous chapters, using async/await
    provides performance benefits and should be used for tasks involving file I/O,
    database, and API calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the database** – When using Entity Framework Core, try to assess the
    goal and evaluate the best approach: whether it’s an Entity Framework Core simple
    data access method or whether a stored procedure would provide faster performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChangeState` management such as updating an entity, use `.AsNoTracking()`
    to reduce the Entity Framework overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are some tips to give a web application a quick lift in performance,
    we’re now ready to dive into more involved code-based techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we learned about optimizing images (in the last section) and optimizing
    JavaScript and CSS (in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)), we now
    need to focus on the *other* client-side resource: HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: When you “view source” in the browser, you’d like to see this beautifully formatted
    document that everyone can understand. But when the browser receives this document,
    it doesn’t care how big it is or even how “pretty” it is. The browser simply parses
    and renders the HTML as it comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed how much space is wasted in this document for the sake of formatting?
    For example, let’s load the “Buck’s Coffee Shop” web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Network** tab in Chrome DevTools, we see it’s 4.1 KB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)](img/B19493_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)
  prefs: []
  type: TYPE_NORMAL
- en: Since the browser doesn’t care, wouldn’t it be better if we could reduce the
    size of the HTML?
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware can assist with this. If we use our standard middleware template
    from [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031), we can create an `HtmlShrink`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code contains our familiar middleware scaffolding. Our `HtmlShrinkMiddleware`
    component now instantiates an `HtmlShrinkStream` class to perform our compression,
    removing any whitespace in the HTML. Also, we created the standard extension at
    the bottom of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `HtmlShrinkStream` class is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our `HtmlShrinkStream` class, our efforts are concentrated on the `Write()`
    method. We look at the buffer received, turn it into an HTML string, replace all
    whitespace by using a RegEx, and finally, write the `buffer` to the `responseStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add our `HtmlShrink` middleware extension to our pipeline by adding
    the following line to our `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once added, any HTML received in the browser will be stripped of any whitespace.
    If we look at Buck’s Coffee Shop home page, we can see everything works, but if
    we view the source, we can see everything is a little more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page](img/B19493_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page
  prefs: []
  type: TYPE_NORMAL
- en: 'It may not look pretty, but if we look at the **Network** tab in Chrome DevTools,
    we can see a difference in what was sent to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)](img/B19493_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)
  prefs: []
  type: TYPE_NORMAL
- en: That’s almost 20% smaller than the original size.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling DbContext pooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connection pooling is the ability to reuse a connection for multiple users.
    By default, database connections already use connection pooling through a `SqlConnection`.
    This concept was applied to Entity Framework Core’s `DbContext`.
  prefs: []
  type: TYPE_NORMAL
- en: If a web application uses Entity Framework Core heavily, you want the best performance
    available. All it takes is to update your middleware `DbContext` connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I might have the following line in my middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can immediately improve our performance by adding four letters to this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the `AddDbContextPool<>()` method contains the same syntax, but after
    a `DbContext` is done, it will reset its state and store it for later when a new
    instance of the `DbContext` is required. We are recycling our `DbContext`s!
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how large your `DbContext` is, every time a new instance is created,
    the creation of the DbContext takes time. Using the `.AddDbContextPool<>()` method
    gives us the performance boost we need.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core DbContext pooling benchmarks
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft performed benchmarks with and without DbContext pooling. With DbContext
    pooling implemented, the performance increased by over 50%. Microsoft even included
    the source code to the benchmark code. The results can be found at [https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks](https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks).
  prefs: []
  type: TYPE_NORMAL
- en: Identifying slow queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability to identify slow queries is sometimes difficult, since we are in
    Visual Studio and may not see what’s happening behind the scenes when sending
    a query to the database. So, how do we find these slow queries in our web application?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the DbContext’s `OnConfiguring()` method, add a `.LogTo()` method to your
    `DbContextOptionsBuilder` and you’ll see every database call and the time it took
    to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.LogTo()` method will produce the following log entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For this particular query, it took *46ms* to execute. The `.LogTo()` method
    provides an easy way to identify whether a query is performing to the best of
    its ability or is a likely candidate for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned some bite-sized optimizations along with a new middleware
    to shrink your HTML, how to speed up Entity Framework Core using DbContext pooling,
    and how to locate slow queries throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll focus on the various types of caching and how each
    one is different and can work collectively to improve the overall performance
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since caching is extremely important to a web application, it’s only fitting
    it gets its own section to cover all of the possible types of caching available.
    In the industry, there’s a saying: “the best database call is no call at all.”
    They’re likely referring to caching.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn the different types of caching that include response
    and output caching, data caching, and caching static files.
  prefs: []
  type: TYPE_NORMAL
- en: Using response caching and output caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether making a call to a web page or an API, the ability to cache data is
    extremely important. Implementing a simple caching strategy to immediately return
    data is efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '`ResponseCaching` is a middleware extension that is best suited for GET or
    HEAD API requests from a client. When utilizing response caching, .NET uses the
    standard HTTP caching semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 9111: HTTP caching'
  prefs: []
  type: TYPE_NORMAL
- en: For additional material on HTTP caching, navigate to [https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add response caching, the builder must add it to the services and the application
    (app) must “use” it, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once in place, any API call would provide the cached data from the browser by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: ResponseCaching middleware
  prefs: []
  type: TYPE_NORMAL
- en: For more details on `ResponseCaching`, navigate to [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for most web UIs such as Razor Pages, `OutputCaching` is the better
    option because browsers set request headers to prevent caching. `OutputCaching`’s
    configuration is similar to `ResponseCaching`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the middleware configuration, we add the `AddOutputCache()` method to the
    services collection and place the `UseOutputCache()` method after the `UseRouting()`
    method and, if it’s used, after the `UseCors()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `OutputCache` is added to the middleware, this doesn’t mean we are
    automatically caching our UI pages. We also need to identify which pages are cached
    by adding an `[OutputCache]` attribute to the Razor Page class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If no parameters are defined in the attribute, the default policy for caching
    pages is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP 200 status codes are cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP GET or HEAD requests are cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responses where cookies are set are *not* cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responses to authenticated requests are *not* cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response caching is meant for caching on the client side or through the browser
    and output caching is cached on the server. If two users access the same page
    from two different browsers, response caching won’t help since each browser will
    cache the page in each browser. However, if output caching was implemented, this
    would cache the page on the server and quickly deliver the page to both users.
  prefs: []
  type: TYPE_NORMAL
- en: Caching your pages gives users a better experience when coupled with data caching,
    which we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user visits a website, they are shown a certain amount of data based
    on who they are. For example, when the first user visits a blog, they could be
    presented with the same data as the next visitor to the site. If the data doesn’t
    change that often, it doesn’t make sense to travel all the way back to the database
    to retrieve the same data again. Data caching helps us solve this problem. Data
    caching is taking commonly used data and storing it for a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example to show the approach. Since we’re using Entity Framework
    Core, we’ll have an existing service (`CoffeeService`) containing a simple `.GetAll()`
    method returning all of the coffees. We can wrap a new caching class around the
    service called `CacheCoffeeService`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`CacheCoffeeService` inherits from `CoffeeService` and uses the `ICachedCoffeeService`
    interface. The `ICachedCoffeeService` interface should be *exactly* the same as
    `CoffeeService` except for one minor detail: a reload parameter added to each
    call with a default of false.'
  prefs: []
  type: TYPE_NORMAL
- en: If we can’t find the entire list of coffees in the cache or we decide we want
    to reload the entire coffee list, we make a call to the base class (`CoffeeService.GetAll())`),
    save the new list to the cache, and return the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when you call `CachedCoffeeService.GetAll()` with no parameters,
    you’ll get the cached version of the list. Pass a `true` to the `.GetAll()` and
    you’ll refresh your cache and receive the latest list of coffees.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach provides the benefit of combining a caching layer with standard
    data access, giving us the best of both worlds. When creating these data caches,
    the benefit is immediately obvious: gaining performance by using memory as your
    database, which is thread-safe. However, be wary of how many tables or how much
    data you are storing in the cache.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it may seem like a trade-off using memory as a database, another caching
    option is using a distributed cache. A distributed cache is a cache shared across
    multiple app servers and provides the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It is coherent/aware of requests across servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the power goes out for a server, the cached data is persisted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, a distributed cache doesn’t use local memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the best candidates for data caching are small lookup tables (< 100
    records) and rarely-accessed table data.
  prefs: []
  type: TYPE_NORMAL
- en: Caching static files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all of these static files such as images, CSS, and JavaScript available
    to our web application, you’d think there would be a way to cache these files
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.UseStaticFiles()` method, there is a context parameter containing
    an `HttpContext`, so we can use the response object to change the cache-control
    headers for our static files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code takes our static files middleware component and allows a
    `StaticFileOptions` instance, which also has an `OnPrepareResponse` event available
    to us. For our cache duration, we set every static file header’s cache duration
    to 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to disable caching, we would modify the response to change the
    following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sample disables caching for every static file.
  prefs: []
  type: TYPE_NORMAL
- en: Again, while these files are cached on the server’s local memory, keep in mind
    that when the power goes down, so does the cache.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to cache a certain folder or file type, the `ctx` parameter contains
    not only a `Context` property of the `HttpContext` type, but a `File` property
    containing an `IFileInfo` type that includes `FileInfo` data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we covered a lot in this chapter, there are additional ways to achieve
    performance in web applications using more advanced techniques. The methods covered
    in this chapter are the best approaches for achieving performance in ASP.NET web
    applications. More than ever, performance is now considered one of the more important
    features in web applications, since it’s now usually tied to a company’s finances.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we first learned why performance matters by showing the effects
    of a slow website, how minor adjustments can produce large dividends, and how
    search engines reward websites for performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create baselines to identify possible bottlenecks using performance
    tools to analyze the client and server-side code with various tools.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about client-side techniques to optimize images, using CDNs
    to improve the loading of static content, and how to minimize your requests to
    lower latency issues. We also examined some quick tips such as placing scripts
    at the bottom and styles at the top, reviewing Google’s Core Web Vitals to understand
    how they gauge website performance, and using HTML instead of JavaScript where
    it’s relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we focused on the server side by reviewing some small, immediate optimizations
    along with improving performance by optimizing HTML before it’s sent back to the
    client. From there, we learned how to speed up Entity Framework Core by adding
    DbContext pooling and identifying slow queries. The final piece to our performance
    chapter was implementing caching, which included learning about response caching,
    output caching, data caching, and how to cache static files.
  prefs: []
  type: TYPE_NORMAL
- en: In the appendix, we’ll examine some programming guidelines, along with what
    ASP.NET 8 projects look like nowadays.
  prefs: []
  type: TYPE_NORMAL
