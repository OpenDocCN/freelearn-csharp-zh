<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Using Styles, Templates, and Triggers
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating the <kbd>Style</kbd> of a control</li>
<li>Creating the <kbd>Style</kbd> of a control based on another <kbd>Style</kbd></li>
<li>Applying <kbd>Style</kbd> to a control automatically</li>
<li>Editing the template of any control</li>
<li>Creating a property trigger</li>
<li>Creating a multi trigger</li>
<li>Creating a data trigger</li>
<li>Creating a multi data trigger</li>
<li>Creating an event trigger</li>
</ul>
<h1 id="uuid-1776dc82-b263-4961-9808-a4632248a40d">Introduction</h1>
<p>When designing a user interface for an application, you need to ensure the consistency of the look and feel of the controls across the application. For example, if you are using buttons, they should look the sameâ€”similar colors, the same margins, and so on.</p>
<p><strong>Styles</strong> are objects that hold the <kbd>Setter</kbd> properties to provide a bunch of settings to elements and controls. Style also provides control templates, which are used to customize the control template to have a distinctive look and feel.</p>
<p>In the Win32/WinForms model, the look and the behavior of the controls were tightly bundled; but in WPF world a control template is created in XAML using designer-oriented tools, and this applies styles to produce a similar look. You can also inherit a style from a different style.</p>
<p>In this chapter, we will discuss styles, templates, triggers, and their relationships with the controls to which they are applied.</p>
<h1 id="uuid-c2a4b87b-0b0f-4b09-826b-d8dd518ece7b">Creating the style of a control</h1>
<p>Styles provide you with a convenient way to group a set of properties and triggers within a single object and apply it to the elements. You can do this selectively to a set of controls, or you can apply it to all the controls automatically, based on the control type.</p>
<p>In this recipe, we'll begin with the default style of a button and set its various style properties to give it a new look. We will then apply it selectively to set the style of multiple button controls.</p>
<h2 id="uuid-51cf3d9d-4f5a-423c-b798-f5d6aa36bd33">Getting ready</h2>
<p>Let's get started by creating a new project called <kbd>CH06.ControlStyleDemo</kbd>. Make sure you create the project based on the WPF application template.</p>
<h2 id="uuid-92a7ddc3-4f89-4d8d-b5cd-62d03bdf4343">How to do it...</h2>
<p>In this recipe, we will get started by creating two buttons inside the application window. Then we will create a style for the button and apply it to both of the controls. Follow these steps to try it on your own:</p>
<ol>
<li>From the <span class="packt_screen">Solution Explorer</span>, open the <kbd>MainWindow.xaml</kbd> and replace the existing <kbd>Grid</kbd> panel by a <kbd>StackPanel</kbd>.</li>
<li>Set the <kbd>Orientation</kbd> property of the <kbd>StackPanel</kbd> to <kbd>Vertical</kbd>, so that we can stack the child controls vertically.</li>
</ol>
<p> </p>
<ol start="3">
<li>Now add a few buttons inside it and assign a content. Here's our markup of the <kbd>StackPanel</kbd> with two buttons:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
     Margin="10"&gt; 
    &lt;Button Content="Click Here"/&gt; 
    &lt;Button Content="Click Here"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="4">
<li>Build and run the application. You will see the following UI:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a831b4ec-c8eb-4cb0-9690-a04ea022b8c2.png"/></div>
<ol start="5">
<li>Close the application and return to the <kbd>MainWindow.xaml</kbd> page. Inside the <kbd>Window</kbd> tag, add <kbd>&lt;Window.Resources&gt;&lt;/Window.Resources&gt;</kbd> to add the button style inside it.</li>
<li>Copy the following style inside the resources to define a style called <kbd>ButtonBaseStyle</kbd>, for our button controls:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style x:Key="ButtonBaseStyle"  
       TargetType="{x:Type Button}"&gt; 
    &lt;Setter Property="Height"  
            Value="30"/&gt; 
    &lt;Setter Property="MinWidth"  
            Value="180"/&gt; 
    &lt;Setter Property="FontSize"  
            Value="16"/&gt; 
    &lt;Setter Property="HorizontalAlignment"  
            Value="Center"/&gt; 
    &lt;Setter Property="Padding"  
            Value="8 0"/&gt; 
&lt;/Style&gt;</pre>
<ol start="7">
<li>Now apply the defined style to both of the buttons by adding the attribute <kbd>Style="{StaticResource ButtonBaseStyle}"</kbd>. Here's the code, for your reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
    Margin="10"&gt; 
    &lt;Button Content="Click Here" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
    &lt;Button Content="Click Here" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="8">
<li>Once this is done, build the project, and run the application again. You will see that the buttons are now shaped properly with some padding between the text and the edge. Also, the font size has increased, as defined in the style. Here's how it looks now:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3afa50e2-997c-4287-b784-8483fad8c59f.png"/></div>
<ol start="9">
<li>Let's add a few additional <kbd>Setter</kbd> properties to the style. We will now define a <kbd>4px</kbd> margin, a hand cursor, and a border, as shared here:</li>
</ol>
<pre style="padding-left: 90px">&lt;Setter Property="Margin"  
        Value="4"/&gt; 
&lt;Setter Property="Cursor"  
        Value="Hand"/&gt;     
&lt;Setter Property="BorderThickness"  
        Value="2"/&gt; </pre>
<ol start="10">
<li>Here's the complete style that we have built up to this point:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;Style x:Key="ButtonBaseStyle"  
           TargetType="{x:Type Button}"&gt; 
        &lt;Setter Property="Height"  
                Value="30"/&gt; 
        &lt;Setter Property="MinWidth"  
                Value="180"/&gt; 
        &lt;Setter Property="FontSize"  
                Value="16"/&gt; 
        &lt;Setter Property="HorizontalAlignment"  
                Value="Center"/&gt; 
        &lt;Setter Property="Padding"  
                Value="8 0"/&gt; 
        &lt;Setter Property="Margin"  
                Value="4"/&gt; 
        &lt;Setter Property="Cursor"  
                Value="Hand"/&gt;     
        &lt;Setter Property="BorderThickness"  
                Value="2"/&gt; 
    &lt;/Style&gt; 
&lt;/Window.Resources&gt; </pre>
<ol start="11">
<li>Let's compile the project and run the application again. You will now see a better UI with proper styling of the button controls, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c38304d6-8ff2-4878-be6e-e6f248512a51.png"/></div>
<h2 id="uuid-6b4161ed-23af-4e63-838e-6948c04317bd">How it works...</h2>
<p>When you create a <kbd>Style</kbd> object, you set a bunch of <kbd>Setter</kbd> objects to it to define various properties to change the look and feel of the control. This may include the height, width, positions, alignments, colors, fonts, control template, triggers, and more.</p>
<p>The <kbd>FrameworkElement</kbd> class exposes a <kbd>Style</kbd> property that can be filled by a <kbd>Style</kbd> object. Styles are always built as resources, as you see them inside the <kbd>&lt;Window.Resources&gt;</kbd> tag in our example. It contains an <kbd>x:Key</kbd> property, which defines the name/key of the style. By using this <kbd>Key</kbd>, you can perform a binding from any other resources/controls within the scope. The <kbd>TargetType</kbd> property of a <kbd>Style</kbd> object is typically set, which makes the <kbd>Style</kbd> applicable to that type, which can be any type, even a type of a custom control.</p>
<p>In this example, the applied style works on <kbd>Button</kbd> objects. Trying to apply the same to some other element type will cause a runtime exception.</p>
<h2 id="uuid-c2d34896-ae1e-4ea6-a611-17c9302eb9ea">There's more...</h2>
<p>You can omit defining the <kbd>TargetType</kbd> of a <kbd>Style</kbd>, but, for that to work, you must define the property with a fully qualified name. For example, the preceding <kbd>Style</kbd> can be written as shown here to get the same result:</p>
<pre style="padding-left: 60px">&lt;Style x:Key="ButtonBaseStyle"&gt; 
    &lt;Setter Property="Button.Height"  
            Value="30"/&gt; 
    &lt;Setter Property="Button.MinWidth"  
            Value="180"/&gt; 
    &lt;Setter Property="Button.FontSize"  
            Value="16"/&gt; 
    &lt;Setter Property="Button.HorizontalAlignment"  
            Value="Center"/&gt; 
    &lt;Setter Property="Button.Padding"  
            Value="8 0"/&gt; 
    &lt;Setter Property="Button.Margin"  
            Value="4"/&gt; 
    &lt;Setter Property="Button.Cursor"  
            Value="Hand"/&gt; 
    &lt;Setter Property="Button.BorderThickness"  
            Value="2"/&gt; 
&lt;/Style&gt; </pre>
<p>As this makes the property name redundant, to define a qualified name people prefer to use the first one with a <kbd>TargetType</kbd> defined. Then, what is the use of the second type of declaration? Yes, the question is valid. With this type of styling, by specifying the fully qualified name of the property, you can define a style targeting various types of controls where the said properties are available.</p>
<div class="packt_infobox">A point to note is that if you explicitly define a property to a control, it will override the property value defined in the <kbd>Style</kbd>.</div>
<h1 id="uuid-8bbe5353-4156-492c-b08f-2acb3fd2941b">Creating the Style of a control based on another Style</h1>
<p>Styles support inheritance. That means, you can derive a <kbd>Style</kbd> from another <kbd>Style</kbd>. This can be done using the <kbd>BasedOn</kbd> property, which must point to another <kbd>Style</kbd> to inherit from. In this recipe, we will learn how to create a <kbd>Style</kbd> of a button control based on another <kbd>Style</kbd> of the same type.</p>
<h2 id="uuid-57586537-6fb4-4daf-b8e0-3f89c0e92a75">Getting ready</h2>
<p>Let's get started by creating a project named <kbd>CH06.StyleInheritanceDemo</kbd>. To do this, open your Visual Studio instance and create a project based on the WPF application template.</p>
<h2 id="uuid-87c24313-8995-4abf-90a9-0eb3b6e40a6b">How to do it...</h2>
<p>Follow these steps to create a base style for a button control and then derive it to create different button styles:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file and create a <kbd>&lt;Window.Resources&gt;&lt;/Window.Resources&gt;</kbd> section inside the <kbd>Window</kbd> tag.</li>
<li>Now, inside the window resources, add the following style definition, which we discussed in the previous recipe of this chapter:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style x:Key="ButtonBaseStyle"  
       TargetType="{x:Type Button}"&gt; 
    &lt;Setter Property="Height"  
            Value="30"/&gt; 
    &lt;Setter Property="MinWidth"  
            Value="180"/&gt; 
    &lt;Setter Property="FontSize"  
            Value="16"/&gt; 
    &lt;Setter Property="HorizontalAlignment"  
            Value="Center"/&gt; 
    &lt;Setter Property="Padding"  
            Value="8 0"/&gt; 
    &lt;Setter Property="Margin"  
            Value="4"/&gt; 
    &lt;Setter Property="Cursor"  
            Value="Hand"/&gt; 
    &lt;Setter Property="BorderThickness"  
            Value="2"/&gt; 
&lt;/Style&gt; </pre>
<ol start="3">
<li>Replace the default <kbd>Grid</kbd> to have the following <kbd>StackPanel</kbd> with four button controls, having the same style that we have created:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Margin="10"&gt; 
    &lt;Button x:Name="baseButton" 
            Content="Base Button Style" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
    &lt;Button x:Name="redButton" 
            Content="Red Button Style" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
    &lt;Button x:Name="greenButton" 
            Content="Green Button Style" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
    &lt;Button x:Name="blueButton" 
            Content="Blue Button Style" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="4">
<li>Build the project and run it. You will see the following UI has the same style applied to all the button controls:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/105afbf0-14bf-43ed-97fe-0dadbbe09bf0.png" style=""/></div>
</li>
<li>To demonstrate the <kbd>Style</kbd> inheritance, let's create another <kbd>Style</kbd>, based on the base <kbd>Style</kbd>. Give it a new <kbd>Key</kbd> name, <kbd>RedButtonStyle</kbd>, set the <kbd>TargetType</kbd> to <kbd>Button</kbd>, and add a new attribute <kbd>BasedOn="{StaticResource ButtonBaseStyle}"</kbd> to create the inheritance.</li>
<li>Add some additional <kbd>Setter</kbd> values to the newly created style to define its border, background, and foreground color. Here's the markup for the <kbd>RedButtonStyle</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style x:Key="RedButtonStyle"  
       TargetType="{x:Type Button}" 
       BasedOn="{StaticResource ButtonBaseStyle}"&gt; 
    &lt;Setter Property="BorderBrush"  
            Value="DarkRed"/&gt; 
    &lt;Setter Property="Foreground"  
            Value="White"/&gt; 
    &lt;Setter Property="Background"  
            Value="OrangeRed"/&gt; 
&lt;/Style&gt; </pre>
<ol start="7">
<li>Now change the <kbd>Style</kbd> property of the <kbd>redButton</kbd> to point itself to <kbd>RedButtonStyle</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button x:Name="redButton" 
        Content="Red Button Style" 
        Style="{StaticResource RedButtonStyle}"/&gt; </pre>
<ol start="8">
<li>Let's run the application once again, which will have the following UI, where the second button will have a reddish background color and a white font color:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2f2c67be-14ba-49e3-8600-0e05f817195e.png"/></div>
</li>
<li>Now, add two more styles, based on the <kbd>ButtonBaseStyle</kbd>, and name them as <kbd>GreenButtonStyle</kbd> and <kbd>BlueButtonStyle</kbd>.</li>
<li>Set their <kbd>BorderBrush</kbd>, <kbd>Foreground</kbd>, and <kbd>Background</kbd> properties to have a greenish and bluish color, respectively. To do this, copy the following styles inside the <kbd>&lt;Window.Resources&gt;</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style x:Key="GreenButtonStyle"  
       TargetType="{x:Type Button}" 
       BasedOn="{StaticResource ButtonBaseStyle}"&gt; 
    &lt;Setter Property="BorderBrush"  
            Value="ForestGreen"/&gt; 
    &lt;Setter Property="Foreground"  
            Value="ForestGreen"/&gt; 
    &lt;Setter Property="Background"  
            Value="GreenYellow"/&gt; 
&lt;/Style&gt; 
 
&lt;Style x:Key="BlueButtonStyle"  
       TargetType="{x:Type Button}" 
       BasedOn="{StaticResource ButtonBaseStyle}"&gt; 
    &lt;Setter Property="BorderBrush"  
            Value="DarkSlateBlue"/&gt; 
    &lt;Setter Property="Foreground"  
            Value="DarkSlateBlue"/&gt; 
    &lt;Setter Property="Background"  
            Value="SkyBlue"/&gt; 
&lt;/Style&gt; </pre>
<ol start="11">
<li>To apply the preceding styles, modify the <kbd>Style</kbd> property of the <kbd>greenButton</kbd> and the <kbd>blueButton</kbd> as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button x:Name="greenButton" 
        Content="Green Button Style" 
        Style="{StaticResource GreenButtonStyle}"/&gt; 
 
&lt;Button x:Name="blueButton" 
        Content="Blue Button Style" 
        Style="{StaticResource BlueButtonStyle}"/&gt;</pre>
<ol start="12">
<li>Here's the code snippet for the entire <kbd>StackPanel</kbd>, which will now have four buttons. Among which the first button is following the base style, whereas the other three buttons are following the new red, green, and blue button styles, respectively:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Margin="10"&gt; 
    &lt;Button x:Name="baseButton" 
            Content="Base Button Style" 
            Style="{StaticResource ButtonBaseStyle}"/&gt; 
    &lt;Button x:Name="redButton" 
            Content="Red Button Style" 
            Style="{StaticResource RedButtonStyle}"/&gt; 
    &lt;Button x:Name="greenButton" 
            Content="Green Button Style" 
            Style="{StaticResource GreenButtonStyle}"/&gt; 
    &lt;Button x:Name="blueButton" 
            Content="Blue Button Style" 
            Style="{StaticResource BlueButtonStyle}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="13">
<li>Time to build the project and run the application. Now, when the application launches, it will have the following UI, but with unique styles. As mentioned earlier, the colors of the buttons will be as per the values we set to the different styles:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/47fe7d6e-c20f-43fb-8278-1573b5f5f37d.png"/></div>
</li>
</ol>
<h2 id="uuid-fe8ff2fe-a0aa-4be9-88e2-195a44aef7b1">How it works...</h2>
<p>An inherited style can have additional <kbd>Setter</kbd> properties to set, or it can provide a different value for a property that has been set by the base <kbd>Style</kbd>. In the preceding example, the <kbd>RedButtonStyle</kbd>, <kbd>GreenButtonStyle</kbd>, and <kbd>BlueButtonStyle</kbd> inherit from the first (<kbd>ButtonBaseStyle</kbd>), and add <kbd>BorderBrush</kbd>, <kbd>Foreground</kbd>, and <kbd>Background</kbd> setter properties to it.</p>
<h1 id="uuid-472d9292-6b60-4de8-a63c-985b9e70141a">Applying Style to a control automatically</h1>
<p>In the previous two recipes, we learned about creating styles and applying them to controls by using the <kbd>x:Key</kbd> name. It's not always feasible to manually assign the style to a set of huge controls within the same application. For this reason, we need to apply it automatically to all the elements within the scope of a specific window or the entire application.</p>
<p>For example, we may want all buttons within the same app to have the same look and feel. This makes creating new buttons easier, as the developer/designer doesn't have to know what style to apply. If the auto styling is configured, it will make the work far smoother.</p>
<p>Let's see how this can be done with a simple example.</p>
<h2 id="uuid-a79c65c0-f26f-4329-bd6e-d4f4d0c74b6a">Getting ready</h2>
<p>To start this recipe, open your Visual Studio instance and create a new WPF application project called <kbd>CH06.StyleUsageDemo</kbd>.</p>
<h2 id="uuid-b6ba8189-2f92-4fd4-af0a-8c69e67599d6">How to do it...</h2>
<p>Follow these steps to create styles for button controls and apply them to controls within the same window, followed by applying them across the application:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> and replace the existing <kbd>Grid</kbd> with the following <kbd>StackPanel</kbd>, containing four button controls:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Margin="10"&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="2">
<li>Create a <kbd>&lt;Window.Resources&gt;&lt;/Window.Resources&gt;</kbd> section inside the <kbd>Window</kbd> tag and add the following style inside it:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="{x:Type Button}"&gt; 
    &lt;Setter Property="Height"  
            Value="30"/&gt; 
    &lt;Setter Property="MinWidth"  
            Value="180"/&gt; 
    &lt;Setter Property="FontSize"  
            Value="16"/&gt; 
    &lt;Setter Property="HorizontalAlignment"  
            Value="Center"/&gt; 
    &lt;Setter Property="Padding"  
            Value="8 0"/&gt; 
    &lt;Setter Property="Margin"  
            Value="4"/&gt; 
    &lt;Setter Property="Cursor"  
            Value="Hand"/&gt; 
    &lt;Setter Property="BorderThickness"  
            Value="2"/&gt; 
    &lt;Setter Property="BorderBrush"  
            Value="DarkRed"/&gt; 
    &lt;Setter Property="Foreground"  
            Value="White"/&gt; 
    &lt;Setter Property="Background"  
            Value="OrangeRed"/&gt; 
&lt;/Style&gt; </pre>
<ol start="3">
<li>Inside the <span class="packt_screen">Solution Explorer</span>, right-click on the project. Follow the path <span class="packt_screen">Add</span> | <span class="packt_screen">Window...</span> from the context menu entry to open the <span class="packt_screen">Add New Item</span> dialog window.</li>
<li>Enter the name as <kbd>SecondaryWindow</kbd> and click <span class="packt_screen">Add</span>. This will create <kbd>SecondaryWindow.xaml</kbd> and <kbd>SecondaryWindow.xaml.cs</kbd> files inside the project.</li>
<li>Open the <kbd>SecondaryWindow.xaml</kbd> file and replace <kbd>Grid</kbd> with the same <kbd>StackPanel</kbd> to create the UI, having four buttons inside it. Here's the markup that you need to copy:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Margin="10"&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
    &lt;Button Content="Red Button Style"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="6">
<li>Now, navigate to the <kbd>App.xaml</kbd> file and remove the <kbd>StartupUri="MainWindow.xaml"</kbd> attribute, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2ebc7729-9eec-4a4a-830b-cf81e8a38ba4.png"/></div>
<ol start="7">
<li>Now go to its code-behind file, that is, the <kbd>App.xaml.cs</kbd>, and insert the following code block inside the class implementation to create instances of both the <kbd>MainWindow</kbd> and the <kbd>SecondaryWindow</kbd> to show on the screen:</li>
</ol>
<pre style="padding-left: 90px">protected override void OnStartup(StartupEventArgs e) 
{ 
    base.OnStartup(e); 
 
    new MainWindow().Show(); 
    new SecondaryWindow().Show(); 
} </pre>
<ol start="8">
<li>Once this is done, compile your project, and run the application.</li>
<li>As shown in the following screenshot, you will have two windows on the screen. One window (<kbd>MainWindow</kbd>) will have the styles applied to the button controls, whereas the other window (<kbd>SecondaryWindow</kbd>) will have the default look and feel:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/629afc7a-0e57-4d87-b182-1759c55bbf38.png"/></div>
<ol start="10">
<li>Now close the application and navigate to the <kbd>MainWindow.xaml</kbd> file. Copy the style that we have there and delete/comment the entire <kbd>Window.Resources</kbd> section.</li>
<li>Now open the <kbd>App.xaml</kbd> file and paste the copied content inside the <kbd>Application.Resources</kbd> tag, as shared here:</li>
</ol>
<pre style="padding-left: 90px">&lt;Application.Resources&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
        &lt;Setter Property="Height"  
                Value="30"/&gt; 
        &lt;Setter Property="MinWidth"  
                Value="180"/&gt; 
        &lt;Setter Property="FontSize"  
                Value="16"/&gt; 
        &lt;Setter Property="HorizontalAlignment"  
                Value="Center"/&gt; 
        &lt;Setter Property="Padding"  
                Value="8 0"/&gt; 
        &lt;Setter Property="Margin"  
                Value="4"/&gt; 
        &lt;Setter Property="Cursor"  
                Value="Hand"/&gt; 
        &lt;Setter Property="BorderThickness"  
                Value="2"/&gt; 
        &lt;Setter Property="BorderBrush"  
                Value="DarkRed"/&gt; 
        &lt;Setter Property="Foreground"  
                Value="White"/&gt;</pre>
<pre style="padding-left: 90px">        &lt;Setter Property="Background"  
                Value="OrangeRed"/&gt; 
    &lt;/Style&gt; 
&lt;/Application.Resources&gt; </pre>
<ol start="12">
<li>Let's build and run the application. You will now see that the styles are applied to both windows. Here's a screenshot of the same:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/356c2a3a-0980-44bc-9058-9bedc498ec85.png"/></div>
<h2 id="uuid-9aba3bee-b787-41a4-a86c-3910e118071e">How it works...</h2>
<p>The automatic styling works when you create a style without specifying an <kbd>x:Key</kbd> value. Any element that does not set its style explicitly obtains it automatically.</p>
<p>In the preceding example, we had the buttons in both the windows (<kbd>MainWindow</kbd> and <kbd>SecondaryWindow</kbd>), and no <kbd>Style</kbd> was manually applied to any one of them, but still the controls in the <kbd>MainWindow</kbd> got the style of <span class="packt_screen">Red Button</span>, as the <kbd>Style</kbd> within that window was created without specifying any key (<kbd>&lt;Style TargetType="{x:Type Button}"&gt;</kbd>).</p>
<p>For <kbd>SecondaryWindow</kbd>, we had no <kbd>Style</kbd> element defined, and, thus, it applied the default style of the button.</p>
<p>When we moved the <kbd>Style</kbd> definition to the <kbd>Application.Resources</kbd> tag in <kbd>App.xaml</kbd>, it registered the <kbd>Style</kbd> to the application level. Now, when you run the application, both the windows will receive the style from the application resource, and all controls of type <kbd>Button</kbd> will apply that style automatically.</p>
<div class="mce-root packt_tip">If an element wishes to revert to its default style, it can set its <kbd>Style</kbd> property to <kbd>null</kbd>. This is generally written as <kbd>{x:Null}</kbd> in XAML.</div>
<h1 id="uuid-deb2bd0a-a48f-4dab-9489-4d31a452a886">Editing the template of any control</h1>
<p>WPF allows you to customize the template of any control. Using Visual Studio, you can easily edit any template to meet your requirements. In this recipe, we will discuss how to edit the template of a <kbd>ProgressBar</kbd> control.</p>
<h2 id="uuid-a0562dc0-3a1e-4a0a-905b-905f31be9eca">Getting ready</h2>
<p>Let's get started with creating a project called <kbd>CH06.ControlTemplateDemo</kbd>. Make sure you select the right WPF application template while creating the project.</p>
<h2 id="uuid-c14200c8-9edf-469d-bec4-e204b271135e">How to do it...</h2>
<p>Follow these steps to edit the progress bar template:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file and replace the default <kbd>Grid</kbd> control with a vertical <kbd>StackPanel</kbd>.</li>
<li>Add two <kbd>ProgressBar</kbd> controls inside the <kbd>StackPanel</kbd> and set their <kbd>Height</kbd>, <kbd>Width</kbd>, and <kbd>Value</kbd> properties, as shared here:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical"&gt; 
    &lt;ProgressBar Height="30" 
                 Margin="10" 
                 Value="40"/&gt; 
    &lt;ProgressBar Height="30" 
                 Margin="10" 
                 Value="60"/&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="3">
<li>If you run the application, you will see the application window contains two progress bar controls. Both the controls will have the default style applied to them. Here's a screenshot of the same:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50edd9c8-90a4-457c-9983-177c164513f1.png"/></div>
<ol start="4">
<li>Now, we will create a custom template for the <kbd>ProgressBar</kbd> control and apply it to the second progress bar. To do this, add the following markup inside the <kbd>Window</kbd> tag to define the template under the <kbd>Window.Resources</kbd>.</li>
<li>Make sure you set the proper <kbd>TargetType</kbd> and assign an <kbd>x:Key</kbd> name to it:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;ControlTemplate TargetType="{x:Type ProgressBar}" 
                     x:Key="ProgressBarTemplate"&gt; 
        &lt;Grid&gt; 
            &lt;Rectangle x:Name="PART_Track" 
                       Fill="AliceBlue"/&gt; 
 
            &lt;Rectangle x:Name="PART_Indicator" 
                       StrokeThickness="0" 
                       HorizontalAlignment="Left"&gt; 
                &lt;Rectangle.Fill&gt; 
                    &lt;LinearGradientBrush  
                           EndPoint=".08,0" 
                           SpreadMethod="Repeat"&gt; 
                        &lt;GradientStop  
                                 Offset="0"  
                                 Color="Green" /&gt; 
                        &lt;GradientStop  
                                 Offset=".8"  
                                 Color="Green" /&gt; 
                        &lt;GradientStop  
                                 Offset=".8"  
                                 Color="Transparent" /&gt; 
                        &lt;GradientStop  
                                 Offset="1"  
                                 Color="Transparent" /&gt; 
                    &lt;/LinearGradientBrush&gt; 
                &lt;/Rectangle.Fill&gt; 
            &lt;/Rectangle&gt; 
 
            &lt;TextBlock FontSize="20" 
                       FontWeight="Bold" 
                       Foreground="White" 
                       HorizontalAlignment="Center" 
                       VerticalAlignment="Center"/&gt; 
        &lt;/Grid&gt; 
    &lt;/ControlTemplate&gt; 
&lt;/Window.Resources&gt; </pre>
<ol start="6">
<li>Now apply the template to the second control by adding the <kbd>Template="{StaticResource ProgressBarTemplate}"</kbd> attribute value. After doing this, the XAML will look as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical"&gt; 
    &lt;ProgressBar Height="30" 
                 Margin="10" 
                 Value="40"/&gt; 
 
    &lt;ProgressBar Height="30" 
                 Margin="10" 
                 Value="60" 
                 Template="{StaticResource  
                            ProgressBarTemplate}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="7">
<li>Let's run the application once again. You will see the second control has our custom template applied to it, and it looks like this:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/859213cc-daa4-42ce-8b5c-5d2dff6f8c44.png"/></div>
<h2 id="uuid-12e28c0e-c042-4a4c-80b1-bb4b20feed36">How it works...</h2>
<p>When you assign the <kbd>Template="{StaticResource ProgressBarTemplate}"</kbd> to the control, it applies the template to the associated control. The progress bar control contains two major parts defined in its template, and they are, <kbd>PART_Track</kbd> and <kbd>PART_Indicator</kbd>. The first one is used to define the base track of the control, whereas the second one defines the progress indicator.</p>
<p>In our template, we assigned a <kbd>LinearGradientBrush</kbd> as the <kbd>PART_Indicator</kbd> rectangle's <kbd>Fill</kbd> color to design the progress indication in a bar format. <kbd>GradientStop</kbd> is used to define the <kbd>Offset</kbd> of the selected color, as follows:</p>
<pre style="padding-left: 60px">&lt;LinearGradientBrush EndPoint=".08,0" 
                     SpreadMethod="Repeat"&gt; 
    &lt;GradientStop Offset="0"  
                  Color="Green" /&gt; 
    &lt;GradientStop Offset=".8"  
                  Color="Green" /&gt; 
    &lt;GradientStop Offset=".8"  
                  Color="Transparent" /&gt; 
    &lt;GradientStop Offset="1"  
                  Color="Transparent" /&gt; 
&lt;/LinearGradientBrush&gt; </pre>
<p>Now, when the application runs, because of its repeat behavior (<kbd>SpreadMethod="Repeat"</kbd>) of <kbd>LinearGradientBrush</kbd>, the stacked bars will spread across the control based on the value.</p>
<h2 id="uuid-3eb212e8-791c-4429-bb3f-0fc193d9e9ca">There's more...</h2>
<p>It's not easy to remember the default template body of the controls. It is also not possible to remember each control part, defined as <kbd>PART_Name</kbd>. Visual Studio provides an effortless way to modify the template.</p>
<p>To do this, right-click on the control and follow the context menu entry <span class="packt_screen">Edit Template</span> | <span class="packt_screen">Edit a Copy...,</span> as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e587592f-4a69-4706-81b1-89a93f545af7.png"/></div>
<p>This will open up a dialog window to specify the file where you want to create the style. If you select <span class="packt_screen">Application</span>, it will be created under the <kbd>Application.Resources</kbd> tag and will be accessible throughout the application.</p>
<p>If you choose <span class="packt_screen">This document</span>, it will get created under the <kbd>Window.Resources</kbd> tag:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/3dfa9257-3301-46b2-90cc-f71476f168bd.png"/></div>
<p>From this screen, you also have an option of whether to create an implicit or explicit style. Select <span class="packt_screen">Apply to all</span> to create an <strong>implicit style</strong>, and all controls of that type will get the same style within that scope. In another case, give it a <strong>Key</strong> name. Once you click <span class="packt_screen">OK</span>, it will create the default template in the same XAML. You can customize it based on your requirements.</p>
<div class="packt_tip">Never remove any <kbd>PART</kbd> controls of a template, which is defined by <kbd>PART_</kbd>, as the controls internally need them.</div>
<h1 id="uuid-4e636a27-dfe0-455f-ad6d-1650cd2058b3">Creating a property trigger</h1>
<p>A trigger enables you to change property values when certain conditions are satisfied. It can also enable you to take actions based on property values by allowing you to dynamically change the appearance and/or the behavior of your control without writing additional codes in the code-behind classes.</p>
<p>The most common trigger is the <strong>property trigger</strong>, which can be simply defined in XAML with a <kbd>&lt;Trigger&gt;</kbd> element. It triggers when a specific property on the owner control changes to match a specified value.</p>
<p>In this recipe, we will learn about property triggers with a suitable example.</p>
<h2 id="uuid-7bc9b162-aff8-42c6-844a-5b4c3a509111">Getting ready</h2>
<p>Open your Visual Studio instance and create a new WPF application project called <kbd>CH06.PropertyTriggerDemo</kbd>.</p>
<h2 id="uuid-28dbdfff-54d9-4edd-91cc-bf00b1de960c">How to do it...</h2>
<p>To work with the property trigger, we will use a <kbd>Label</kbd> control in this example and trigger the system to change its various properties on mouse hover. Follow these simple steps:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> page and add the following <kbd>Label</kbd> control inside the grid:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Label Content="Hover over the text" 
           HorizontalAlignment="Center" 
           VerticalAlignment="Center"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="2">
<li>Inside the <kbd>Window</kbd> tag, create a <kbd>Window.Resources</kbd> tag to hold the style of the <kbd>Label</kbd> control. Create a <kbd>Style</kbd> inside the resources and set its <kbd>TargetType</kbd> to <kbd>Button</kbd>.</li>
<li>Add the following trigger inside the style:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style.Triggers&gt; 
    &lt;Trigger Property="IsMouseOver"  
             Value="True"&gt; 
        &lt;Setter Property="FontSize"  
                Value="30"/&gt; 
        &lt;Setter Property="Foreground" 
                Value="Red"/&gt; 
        &lt;Setter Property="Background"  
                Value="LightYellow"/&gt; 
        &lt;Setter Property="Effect"&gt; 
            &lt;Setter.Value&gt; 
                &lt;DropShadowEffect  
                     RenderingBias="Performance"  
                     BlurRadius="1"/&gt; 
            &lt;/Setter.Value&gt; 
        &lt;/Setter&gt; 
    &lt;/Trigger&gt; 
&lt;/Style.Triggers&gt;</pre>
<ol start="4">
<li>Here's the complete style containing the trigger for the <kbd>Label</kbd> control, which will change the mentioned properties on mouse hover:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;Style TargetType="{x:Type Label}"&gt; 
        &lt;Style.Triggers&gt; 
            &lt;Trigger Property="IsMouseOver"  
                     Value="True"&gt; 
                &lt;Setter Property="FontSize"  
                        Value="30"/&gt; 
                &lt;Setter Property="Foreground"  
                        Value="Red"/&gt; 
                &lt;Setter Property="Background"  
                        Value="LightYellow"/&gt; 
                &lt;Setter Property="Effect"&gt; 
                    &lt;Setter.Value&gt; 
                        &lt;DropShadowEffect  
                             RenderingBias="Performance"  
                             BlurRadius="1"/&gt; 
                    &lt;/Setter.Value&gt; 
                &lt;/Setter&gt; 
            &lt;/Trigger&gt; 
        &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
&lt;/Window.Resources&gt;</pre>
<ol start="5">
<li>Now, build the project and run it. You will see a <span class="packt_screen">Hover over the text</span> <span>label </span>on the application window. Mouse hover on the text to see the effect on the screen, as shown here:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/51bb599a-dbed-474a-ab85-9df9b79004f4.png"/></div>
</li>
</ol>
<h2 id="uuid-1c80f45f-2bbe-49ab-ad3c-62170145771f">How it works...</h2>
<p>The style of the <kbd>Label</kbd> creates a <kbd>Trigger</kbd> that fires on mouse hover by checking the <kbd>IsMouseOver="True"</kbd> property value. When the condition satisfies, it sets the <kbd>Setter</kbd> properties as defined under it.</p>
<p>When the condition becomes <kbd>false</kbd>, the setters are logically removed, reverting the properties to their original values. This means that it is not required to provide an <em>opposite</em> trigger.</p>
<h1 id="uuid-297c179c-1c70-4605-b824-1e4e9188dd29">Creating a multi trigger</h1>
<p>It is not mandatory to use a trigger to perform only an action based on a single condition. Sometimes you need to create it with a composition of multiple conditions that activate the entire trigger, if all the conditions are met. This is what the <strong>multi trigger</strong> does. Let's see how to create a multi trigger.</p>
<h2 id="uuid-2c300b99-b4b3-4e19-a4e4-9ca8e7be65f1">Getting ready</h2>
<p>Open your Visual Studio IDE and create a new WPF application called <kbd>CH06.MultiTriggerDemo</kbd>.</p>
<h2 id="uuid-8577bad9-6339-4da4-9906-525ce3ecc199">How to do it...</h2>
<p>In the following steps, we will build a simple application that will create and execute a multi trigger based on some conditions and change the <kbd>Foreground</kbd> and <kbd>Background</kbd> properties of the <kbd>TextBox</kbd> controls:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Replace the default <kbd>Grid</kbd> panel with a vertical <kbd>StackPanel</kbd>.</li>
<li>Add two <kbd>TextBox</kbd> controls inside the panel and set their <kbd>Text</kbd> property to represent some text. Here's the XAML that we will be using in this example:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel&gt; 
    &lt;TextBox Text="Focus your cursor here" 
             FontSize="20" 
             HorizontalAlignment="Stretch" 
             VerticalAlignment="Center" 
             Height="30" 
             Margin="4"/&gt; 
 
    &lt;TextBox Text="Focus your cursor here" 
             FontSize="20" 
             HorizontalAlignment="Stretch" 
             VerticalAlignment="Center" 
             Height="30" 
             Margin="4"/&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="4">
<li>Now, under the window resources (<kbd>Window.Resources</kbd>), create a <kbd>Style</kbd> that targets a <kbd>TextBox</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="{x:Type TextBox}"&gt; 
 
&lt;/Style&gt; </pre>
<ol start="5">
<li>Create a style trigger with <kbd>MultiTrigger</kbd>, based on one or more conditions, and apply the setters, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style.Triggers&gt; 
    &lt;MultiTrigger&gt; 
        &lt;MultiTrigger.Conditions&gt; 
            &lt;Condition Property="IsEnabled"  
                       Value="True" /&gt; 
            &lt;Condition Property="IsKeyboardFocused"  
                       Value="True" /&gt; 
        &lt;/MultiTrigger.Conditions&gt; 
 
        &lt;MultiTrigger.Setters&gt; 
            &lt;Setter Property="Foreground"  
                    Value="Green" /&gt; 
            &lt;Setter Property="Background"  
                    Value="LightGreen" /&gt; 
        &lt;/MultiTrigger.Setters&gt; 
    &lt;/MultiTrigger&gt; 
&lt;/Style.Triggers&gt; </pre>
<ol start="6">
<li>Let's execute the application and focus on the <kbd>TextBox</kbd> controls to see the behavior:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/947b0dfb-f63f-4b20-8d98-487926bd17db.png" style=""/></div>
<h2 id="uuid-19cafe00-4123-48c1-a5a7-a3565a618eec">How it works...</h2>
<p>This is almost like the <strong>Property Trigger</strong>, but here it is used to set an action on multiple property changes, and will execute it when all the conditions within the <kbd>MulitTrigger.Conditions</kbd> are satisfied. The  <kbd>MultiTrigger</kbd> object hosts a collection of these <kbd>Condition</kbd> objects.</p>
<p>Here, in this example, we have <kbd>MultiTrigger</kbd> associated with <kbd>TextBox</kbd> controls. When the control is enabled and gets keyboard focus, it changes its <kbd>Foreground</kbd> and <kbd>Background</kbd> properties. When either of them is <kbd>false</kbd>, it returns the property values to its original state.</p>
<h1 id="uuid-0641ecc7-fe0b-4967-9418-332b56b1f733">Creating a data trigger</h1>
<p>As the name says, the <strong>data trigger</strong> applies property values to perform a set of actions on the <kbd>Data</kbd> that has been bound to the <kbd>UIElement</kbd>. This is represented by the <kbd>&lt;DataTrigger&gt;</kbd> element.</p>
<p>In this recipe, we will learn how to create a trigger that acts on the underlying data.</p>
<h2 id="uuid-f828bec3-d8fe-432f-851d-eda62199f9e0">Getting ready</h2>
<p>Let's get started with creating a new WPF project. Open the Visual Studio and create a project called <kbd>CH06.DataTriggerDemo</kbd>.</p>
<h2 id="uuid-3dc13882-7704-48e3-91e8-ed8dae61a3ac">How to do it...</h2>
<p>Follow these simple steps to create a data trigger that will act to change the <kbd>Background</kbd> and <kbd>Content</kbd> property of a <kbd>Label</kbd>, based on the radio button selection:</p>
<ol>
<li>
<p>From the <span class="packt_screen">Solution Explorer</span>, open the <kbd>MainWindow.xaml</kbd> file.</p>
</li>
<li>
<p>Let's divide the <kbd>Grid</kbd> panel into two columns:</p>
</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition/&gt; 
    &lt;ColumnDefinition/&gt; 
&lt;/Grid.ColumnDefinitions&gt;</pre>
<ol start="3">
<li>
<p>Now insert a <kbd>Label</kbd> of <kbd>150 </kbd>x <kbd>100</kbd> dimension at column <kbd>0</kbd> (zero) and set its <kbd>Foreground</kbd> property to <kbd>White</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 90px">&lt;Label Width="150" 
       Height="100" 
       Grid.Column="0" 
       Foreground="White" 
       FontSize="20" 
       BorderBrush="Gray" 
       BorderThickness="1"/&gt; </pre>
<ol start="4">
<li>
<p>Insert a vertical <kbd>StackPanel</kbd> at Column <kbd>1</kbd> and add three radio buttons inside it. Make sure you set their names and the <kbd>GroupName</kbd>. The <kbd>x:Name</kbd> property is used to define the name of the controls and the <kbd>GroupName="colors"</kbd> is used to define a single group for the radios. Here's the complete XAML markup:</p>
</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Grid.Column="1" 
            Margin="10"&gt; 
    &lt;RadioButton x:Name="rdoRed" 
                 GroupName="colors" 
                 Content="Red (#FFFF0000)"/&gt; 
 
    &lt;RadioButton x:Name="rdoGreen" 
                 GroupName="colors" 
                 Content="Green (#FF00FF00)"/&gt; 
 
    &lt;RadioButton x:Name="rdoBlue" 
                 GroupName="colors" 
                 Content="Blue (#FF0000FF)"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="5">
<li>
<p>Inside the <kbd>Window.Resources</kbd> tag of the window, create a <kbd>Style</kbd> that targets <kbd>Label</kbd> control:</p>
</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="{x:Type Label}"&gt; 
 
&lt;/Style&gt;</pre>
<ol start="6">
<li>
<p>Insert the following trigger inside the <kbd>Style</kbd>. The <kbd>&lt;Style.Triggers&gt;</kbd> contains three <kbd>DataTrigger</kbd> bound to the checkbox controls:</p>
</li>
</ol>
<pre style="padding-left: 90px">&lt;Style.Triggers&gt; 
    &lt;DataTrigger Binding="{Binding ElementName=rdoRed,  
                           Path=IsChecked}" 
                 Value="True"&gt; 
        &lt;Setter Property="Content" 
                Value="Red"/&gt; 
        &lt;Setter Property="Background"  
                Value="Red"/&gt; 
    &lt;/DataTrigger&gt; 
 
    &lt;DataTrigger Binding="{Binding ElementName=rdoGreen,  
                           Path=IsChecked}" 
                 Value="True"&gt; 
        &lt;Setter Property="Content" 
                Value="Green"/&gt; 
        &lt;Setter Property="Background"  
                Value="Green"/&gt; 
    &lt;/DataTrigger&gt; 
 
    &lt;DataTrigger Binding="{Binding ElementName=rdoBlue,  
                           Path=IsChecked}" 
                 Value="True"&gt; 
        &lt;Setter Property="Content" 
                Value="Blue"/&gt; 
        &lt;Setter Property="Background"  
                Value="Blue"/&gt; 
    &lt;/DataTrigger&gt; 
&lt;/Style.Triggers&gt; </pre>
<ol start="7">
<li>
<p>As the trigger is ready, let's build the project and run it. Change the radio button selection and observe how it works, as shown in the following screenshot:</p>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/66d2c691-74a0-4542-bbd2-cc555473c59f.png"/></div>
<h2 id="uuid-ac249975-1838-453f-a226-88ea0521727b">How it works...</h2>
<p>When you click on the first radio button (<kbd>rdoRed</kbd>), it triggers the first data trigger, as it satisfies the <kbd>IsChecked</kbd> property of <kbd>rdoRed</kbd> control and modifies the <kbd>Setter</kbd> propertiesâ€”<kbd>Content</kbd> and <kbd>Background</kbd>.</p>
<p>Similarly, when you change the selection to the second or third radios, the respective <kbd>DataTrigger</kbd> will fire and update the <kbd>Label</kbd> control, according to the <kbd>Setter</kbd> properties.</p>
<h1 id="uuid-bdefe387-d8de-4075-a3b9-12d004d2d202">Creating a multi data trigger</h1>
<p>A <strong>multi data trigger</strong> is the same as the <strong>data trigger</strong>, with the only difference being that you can set property values based on multiple conditions defined in the <kbd>MultiDataTrigger.Conditions</kbd>. Property values are defined in the <kbd>MultiDataTrigger.Setters</kbd>.</p>
<p>Let's learn about the multi data trigger usages in this recipe.</p>
<h2 id="uuid-65da250a-8e1a-49e5-95e8-de72c2519ad6">Getting ready</h2>
<p>To get started with the multi data trigger, let's start by creating a project called <kbd>CH06.MultiDataTriggerDemo</kbd>. Make sure you select the proper project template.</p>
<h2 id="uuid-da12e7cb-06cd-44e3-9267-61a5f11d2689">How to do it...</h2>
<p>Follow these steps to create a UI with two checkboxes and a button, and then apply a multi data trigger to enable/disable the button, based on the check state:</p>
<ol>
<li>Let's begin by replacing the <kbd>Grid</kbd> with a <kbd>StackPanel</kbd>, having two checkbox (<kbd>chkLicense</kbd> and <kbd>chkTerms</kbd>) controls and one button:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel HorizontalAlignment="Center"  
            VerticalAlignment="Center"&gt; 
    &lt;CheckBox x:Name="chkLicense"  
              Content="Yes, I accept license agreement" /&gt; 
    &lt;CheckBox x:Name="chkTerms"  
              Content="Yes, I accept Terms &amp;amp; Conditions" /&gt; 
 
    &lt;Button HorizontalAlignment="Center"  
            Margin="0,20,0,0"  
            FontSize="20"  
            Content="Register"&gt; 
 
    &lt;/Button&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="2">
<li>Now, modify the <kbd>Button</kbd> to expose its style, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button HorizontalAlignment="Center"  
        Margin="0,20,0,0"  
        FontSize="20"  
        Content="Register"&gt; 
    &lt;Button.Style&gt; 
 
    &lt;/Button.Style&gt; 
&lt;/Button&gt; </pre>
<ol start="3">
<li>Add the following button style inside it, which contains a <kbd>MultiDataTrigger</kbd> to enable/disable the button:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="{x:Type Button}"&gt; 
    &lt;Setter Property="IsEnabled"  
            Value="False"/&gt; 
    &lt;Style.Triggers&gt; 
        &lt;MultiDataTrigger&gt; 
            &lt;MultiDataTrigger.Conditions&gt; 
                &lt;Condition Binding="{Binding  
                           ElementName=chkLicense,  
                           Path=IsChecked}"  
                           Value="True" /&gt; 
                &lt;Condition Binding="{Binding  
                           ElementName=chkTerms,  
                           Path=IsChecked}" 
                           Value="True" /&gt; 
            &lt;/MultiDataTrigger.Conditions&gt; 
 
            &lt;Setter Property="IsEnabled"  
                    Value="True" /&gt; 
        &lt;/MultiDataTrigger&gt; 
    &lt;/Style.Triggers&gt; 
&lt;/Style&gt;</pre>
<ol start="4">
<li>Now run the application, which will have two checkboxes and a button on the screen. Change the selections of the checkbox controls to see the behavior:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/96eee90e-16da-4ed0-9c5a-869aa7e2ef1d.png"/></div>
<h2 id="uuid-d79e883c-9618-4bda-84ef-43e58e3f8c8c">How it works...</h2>
<p>A multi data trigger works based on the conditions set to it, which acts on the underlying data. In our example, we have a <kbd>MultiDataTrigger</kbd> with two conditions.</p>
<p>According to the conditions, if both the checkbox controls are checked, it will trigger and enable the button by setting the <kbd>IsEnabled</kbd> property to <kbd>True</kbd>. When any of the preceding conditions are not satisfied, it will automatically set the <kbd>IsEnabled</kbd> property to the previous value, which is <kbd>False</kbd> in our case.</p>
<h1 id="uuid-771fa0f8-c92a-458c-b080-67885477f5f5">Creating an event trigger</h1>
<p>Till now, we have seen property triggers and data triggers, which work based on comparing a property to a value. In this recipe, we will learn about <strong>event triggers</strong> which fire when a routed event occurs.</p>
<h2 id="uuid-af9b54ed-7806-42ad-b97a-2287ab92e229">Getting ready</h2>
<p>Inside your Visual Studio IDE, create a new project called <kbd>CH06.EventTriggerDemo</kbd>, based on the WPF application template.</p>
<h2 id="uuid-edaf2851-8e28-42f5-9f1b-cbb93caca5d6">How to do it...</h2>
<p>Follow these steps to create a simple event trigger on a <kbd>TextBlock</kbd> control:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> and add the following <kbd>TextBlock</kbd> inside the <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBlock Text="Hover here"  
           FontSize="30"  
           Opacity="0.2"  
           HorizontalAlignment="Center"  
           VerticalAlignment="Center"&gt; 
    &lt;TextBlock.Style&gt; 
 
    &lt;/TextBlock.Style&gt; 
&lt;/TextBlock&gt; </pre>
<ol start="2">
<li>Add the following style, containing <kbd>EventTrigger</kbd>, to the <kbd>TextBlock.Style</kbd> attribute:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="TextBlock"&gt; 
    &lt;Style.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="MouseEnter"&gt; 
            &lt;EventTrigger.Actions&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard&gt; 
                        &lt;DoubleAnimation  
              Duration="0:0:0.500"  
              Storyboard.TargetProperty="FontSize"  
              To="50" /&gt; 
                        &lt;DoubleAnimation  
              Duration="0:0:0.500"  
              Storyboard.TargetProperty="Opacity"  
              To="1.0"/&gt; 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger.Actions&gt; 
        &lt;/EventTrigger&gt; 
 
        &lt;EventTrigger RoutedEvent="MouseLeave"&gt; 
            &lt;EventTrigger.Actions&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard&gt; 
                        &lt;DoubleAnimation  
              Duration="0:0:0.500"  
              Storyboard.TargetProperty="FontSize"  
              To="30" /&gt; 
                        &lt;DoubleAnimation  
              Duration="0:0:0.500"  
              Storyboard.TargetProperty="Opacity"  
              To="0.2"/&gt; 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger.Actions&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/Style.Triggers&gt; 
&lt;/Style&gt; </pre>
<ol start="3">
<li>Build the application and run it. Hover your mouse on top of the text and you will see that the font size of the text gradually increases, and the visibility becomes <kbd>100%</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c94dd95-d8b6-4a53-a751-5dab07f5d1ff.png"/></div>
<h2 id="uuid-8f6190e8-ffee-4bac-bb29-5b9f844d8563">How it works...</h2>
<p>The event triggers are generally used to perform actions when the <strong>Routed Events</strong> of the associated <kbd>FrameworkElement</kbd> raises. This is mainly used in animations to control the look and feel when a certain UI event is raised.</p>
<p>In this example, when you hover over the mouse cursor on the <kbd>TextBlock</kbd> control, the <kbd>MouseEnter</kbd> event fires and that triggers <kbd>EventTrigger</kbd>, which we have defined in the XAML. It then animates the text to have a bigger font size and a higher opacity to give a bigger, better visible content.</p>
<p>When the <kbd>MouseLeave</kbd> event fires, it reduces the size of the font and brings the control opacity to <kbd>20%</kbd>. More about the <kbd>Storyboard</kbd> animations will be discussed in <em>Chapter 8,</em><span class="ChapterrefPACKT"> </span><em>Working with Animations</em>.</p>


            </article>

            
        </section>
    </body></html>